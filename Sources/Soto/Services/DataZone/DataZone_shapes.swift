//===----------------------------------------------------------------------===//
//
// This source file is part of the Soto for AWS open source project
//
// Copyright (c) 2017-2024 the Soto project authors
// Licensed under Apache License v2.0
//
// See LICENSE.txt for license information
// See CONTRIBUTORS.txt for the list of Soto project authors
//
// SPDX-License-Identifier: Apache-2.0
//
//===----------------------------------------------------------------------===//

// THIS FILE IS AUTOMATICALLY GENERATED by https://github.com/soto-project/soto-codegenerator.
// DO NOT EDIT.

#if canImport(FoundationEssentials)
import FoundationEssentials
#else
import Foundation
#endif
@_spi(SotoInternal) import SotoCore

extension DataZone {
    // MARK: Enums

    public enum AcceptRuleBehavior: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case all = "ALL"
        case none = "NONE"
        public var description: String { return self.rawValue }
    }

    public enum AuthType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case disabled = "DISABLED"
        case iamIdc = "IAM_IDC"
        public var description: String { return self.rawValue }
    }

    public enum AuthenticationType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case basic = "BASIC"
        case custom = "CUSTOM"
        case oauth2 = "OAUTH2"
        public var description: String { return self.rawValue }
    }

    public enum ChangeAction: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case publish = "PUBLISH"
        case unpublish = "UNPUBLISH"
        public var description: String { return self.rawValue }
    }

    public enum ComputeEnvironments: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case athena = "ATHENA"
        case python = "PYTHON"
        case spark = "SPARK"
        public var description: String { return self.rawValue }
    }

    public enum ConfigurableActionTypeAuthorization: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case https = "HTTPS"
        case iam = "IAM"
        public var description: String { return self.rawValue }
    }

    public enum ConnectionStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case createFailed = "CREATE_FAILED"
        case creating = "CREATING"
        case deleteFailed = "DELETE_FAILED"
        case deleted = "DELETED"
        case deleting = "DELETING"
        case ready = "READY"
        case updateFailed = "UPDATE_FAILED"
        case updating = "UPDATING"
        public var description: String { return self.rawValue }
    }

    public enum ConnectionType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case athena = "ATHENA"
        case bigquery = "BIGQUERY"
        case databricks = "DATABRICKS"
        case documentdb = "DOCUMENTDB"
        case dynamodb = "DYNAMODB"
        case hyperpod = "HYPERPOD"
        case iam = "IAM"
        case mysql = "MYSQL"
        case opensearch = "OPENSEARCH"
        case oracle = "ORACLE"
        case postgresql = "POSTGRESQL"
        case redshift = "REDSHIFT"
        case saphana = "SAPHANA"
        case snowflake = "SNOWFLAKE"
        case spark = "SPARK"
        case sqlserver = "SQLSERVER"
        case teradata = "TERADATA"
        case vertica = "VERTICA"
        case workflowsMwaa = "WORKFLOWS_MWAA"
        public var description: String { return self.rawValue }
    }

    public enum DataAssetActivityStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case failed = "FAILED"
        case publishingFailed = "PUBLISHING_FAILED"
        case skippedAlreadyImported = "SKIPPED_ALREADY_IMPORTED"
        case skippedArchived = "SKIPPED_ARCHIVED"
        case skippedNoAccess = "SKIPPED_NO_ACCESS"
        case succeededCreated = "SUCCEEDED_CREATED"
        case succeededUpdated = "SUCCEEDED_UPDATED"
        case unchanged = "UNCHANGED"
        public var description: String { return self.rawValue }
    }

    public enum DataProductItemType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case asset = "ASSET"
        public var description: String { return self.rawValue }
    }

    public enum DataProductStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case createFailed = "CREATE_FAILED"
        case created = "CREATED"
        case creating = "CREATING"
        public var description: String { return self.rawValue }
    }

    public enum DataSourceErrorType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case accessDeniedException = "ACCESS_DENIED_EXCEPTION"
        case conflictException = "CONFLICT_EXCEPTION"
        case internalServerException = "INTERNAL_SERVER_EXCEPTION"
        case resourceNotFoundException = "RESOURCE_NOT_FOUND_EXCEPTION"
        case serviceQuotaExceededException = "SERVICE_QUOTA_EXCEEDED_EXCEPTION"
        case throttlingException = "THROTTLING_EXCEPTION"
        case validationException = "VALIDATION_EXCEPTION"
        public var description: String { return self.rawValue }
    }

    public enum DataSourceRunStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case failed = "FAILED"
        case partiallySucceeded = "PARTIALLY_SUCCEEDED"
        case requested = "REQUESTED"
        case running = "RUNNING"
        case success = "SUCCESS"
        public var description: String { return self.rawValue }
    }

    public enum DataSourceRunType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case prioritized = "PRIORITIZED"
        case scheduled = "SCHEDULED"
        public var description: String { return self.rawValue }
    }

    public enum DataSourceStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case creating = "CREATING"
        case deleting = "DELETING"
        case failedCreation = "FAILED_CREATION"
        case failedDeletion = "FAILED_DELETION"
        case failedUpdate = "FAILED_UPDATE"
        case ready = "READY"
        case running = "RUNNING"
        case updating = "UPDATING"
        public var description: String { return self.rawValue }
    }

    public enum DataZoneEntityType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case domainUnit = "DOMAIN_UNIT"
        public var description: String { return self.rawValue }
    }

    public enum DeploymentMode: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case onCreate = "ON_CREATE"
        case onDemand = "ON_DEMAND"
        public var description: String { return self.rawValue }
    }

    public enum DeploymentStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case failed = "FAILED"
        case inProgress = "IN_PROGRESS"
        case pendingDeployment = "PENDING_DEPLOYMENT"
        case successful = "SUCCESSFUL"
        public var description: String { return self.rawValue }
    }

    public enum DeploymentType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case create = "CREATE"
        case delete = "DELETE"
        case update = "UPDATE"
        public var description: String { return self.rawValue }
    }

    public enum DomainStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case available = "AVAILABLE"
        case creating = "CREATING"
        case creationFailed = "CREATION_FAILED"
        case deleted = "DELETED"
        case deleting = "DELETING"
        case deletionFailed = "DELETION_FAILED"
        public var description: String { return self.rawValue }
    }

    public enum DomainUnitDesignation: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case owner = "OWNER"
        public var description: String { return self.rawValue }
    }

    public enum DomainVersion: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case v1 = "V1"
        case v2 = "V2"
        public var description: String { return self.rawValue }
    }

    public enum EdgeDirection: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case downstream = "DOWNSTREAM"
        case upstream = "UPSTREAM"
        public var description: String { return self.rawValue }
    }

    public enum EnableSetting: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case disabled = "DISABLED"
        case enabled = "ENABLED"
        public var description: String { return self.rawValue }
    }

    public enum EntityType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case asset = "ASSET"
        case dataProduct = "DATA_PRODUCT"
        public var description: String { return self.rawValue }
    }

    public enum EnvironmentStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case active = "ACTIVE"
        case createFailed = "CREATE_FAILED"
        case creating = "CREATING"
        case deleteFailed = "DELETE_FAILED"
        case deleted = "DELETED"
        case deleting = "DELETING"
        case disabled = "DISABLED"
        case expired = "EXPIRED"
        case inaccessible = "INACCESSIBLE"
        case suspended = "SUSPENDED"
        case updateFailed = "UPDATE_FAILED"
        case updating = "UPDATING"
        case validationFailed = "VALIDATION_FAILED"
        public var description: String { return self.rawValue }
    }

    public enum FilterExpressionType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case exclude = "EXCLUDE"
        case include = "INCLUDE"
        public var description: String { return self.rawValue }
    }

    public enum FilterStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case invalid = "INVALID"
        case valid = "VALID"
        public var description: String { return self.rawValue }
    }

    public enum FormTypeStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case disabled = "DISABLED"
        case enabled = "ENABLED"
        public var description: String { return self.rawValue }
    }

    public enum GlossaryStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case disabled = "DISABLED"
        case enabled = "ENABLED"
        public var description: String { return self.rawValue }
    }

    public enum GlossaryTermStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case disabled = "DISABLED"
        case enabled = "ENABLED"
        public var description: String { return self.rawValue }
    }

    public enum GlueConnectionType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case bigquery = "BIGQUERY"
        case documentdb = "DOCUMENTDB"
        case dynamodb = "DYNAMODB"
        case mysql = "MYSQL"
        case opensearch = "OPENSEARCH"
        case oracle = "ORACLE"
        case postgresql = "POSTGRESQL"
        case redshift = "REDSHIFT"
        case saphana = "SAPHANA"
        case snowflake = "SNOWFLAKE"
        case sqlserver = "SQLSERVER"
        case teradata = "TERADATA"
        case vertica = "VERTICA"
        public var description: String { return self.rawValue }
    }

    public enum GovernanceType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case awsManaged = "AWS_MANAGED"
        case userManaged = "USER_MANAGED"
        public var description: String { return self.rawValue }
    }

    public enum GroupProfileStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case assigned = "ASSIGNED"
        case notAssigned = "NOT_ASSIGNED"
        public var description: String { return self.rawValue }
    }

    public enum GroupSearchType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case datazoneSsoGroup = "DATAZONE_SSO_GROUP"
        case ssoGroup = "SSO_GROUP"
        public var description: String { return self.rawValue }
    }

    public enum HyperPodOrchestrator: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case eks = "EKS"
        case slurm = "SLURM"
        public var description: String { return self.rawValue }
    }

    public enum InventorySearchScope: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case asset = "ASSET"
        case dataProduct = "DATA_PRODUCT"
        case glossary = "GLOSSARY"
        case glossaryTerm = "GLOSSARY_TERM"
        public var description: String { return self.rawValue }
    }

    public enum JobRunMode: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case onDemand = "ON_DEMAND"
        case scheduled = "SCHEDULED"
        public var description: String { return self.rawValue }
    }

    public enum JobRunStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case aborted = "ABORTED"
        case canceled = "CANCELED"
        case failed = "FAILED"
        case inProgress = "IN_PROGRESS"
        case partiallySucceeded = "PARTIALLY_SUCCEEDED"
        case scheduled = "SCHEDULED"
        case success = "SUCCESS"
        case timedOut = "TIMED_OUT"
        public var description: String { return self.rawValue }
    }

    public enum JobType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case lineage = "LINEAGE"
        public var description: String { return self.rawValue }
    }

    public enum LineageEventProcessingStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case failed = "FAILED"
        case processing = "PROCESSING"
        case requested = "REQUESTED"
        case success = "SUCCESS"
        public var description: String { return self.rawValue }
    }

    public enum LineageImportStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case failed = "FAILED"
        case inProgress = "IN_PROGRESS"
        case partiallySucceeded = "PARTIALLY_SUCCEEDED"
        case success = "SUCCESS"
        public var description: String { return self.rawValue }
    }

    public enum ListingStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case active = "ACTIVE"
        case creating = "CREATING"
        case inactive = "INACTIVE"
        public var description: String { return self.rawValue }
    }

    public enum ManagedPolicyType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case addToProjectMemberPool = "ADD_TO_PROJECT_MEMBER_POOL"
        case createAssetType = "CREATE_ASSET_TYPE"
        case createDomainUnit = "CREATE_DOMAIN_UNIT"
        case createEnvironment = "CREATE_ENVIRONMENT"
        case createEnvironmentFromBlueprint = "CREATE_ENVIRONMENT_FROM_BLUEPRINT"
        case createEnvironmentProfile = "CREATE_ENVIRONMENT_PROFILE"
        case createFormType = "CREATE_FORM_TYPE"
        case createGlossary = "CREATE_GLOSSARY"
        case createProject = "CREATE_PROJECT"
        case createProjectFromProjectProfile = "CREATE_PROJECT_FROM_PROJECT_PROFILE"
        case delegateCreateEnvironmentProfile = "DELEGATE_CREATE_ENVIRONMENT_PROFILE"
        case overrideDomainUnitOwners = "OVERRIDE_DOMAIN_UNIT_OWNERS"
        case overrideProjectOwners = "OVERRIDE_PROJECT_OWNERS"
        public var description: String { return self.rawValue }
    }

    public enum MetadataGenerationRunStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case canceled = "CANCELED"
        case failed = "FAILED"
        case inProgress = "IN_PROGRESS"
        case submitted = "SUBMITTED"
        case succeeded = "SUCCEEDED"
        public var description: String { return self.rawValue }
    }

    public enum MetadataGenerationRunType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case businessDescriptions = "BUSINESS_DESCRIPTIONS"
        public var description: String { return self.rawValue }
    }

    public enum MetadataGenerationTargetType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case asset = "ASSET"
        public var description: String { return self.rawValue }
    }

    public enum NotificationResourceType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case project = "PROJECT"
        public var description: String { return self.rawValue }
    }

    public enum NotificationRole: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case domainOwner = "DOMAIN_OWNER"
        case projectContributor = "PROJECT_CONTRIBUTOR"
        case projectOwner = "PROJECT_OWNER"
        case projectSubscriber = "PROJECT_SUBSCRIBER"
        case projectViewer = "PROJECT_VIEWER"
        public var description: String { return self.rawValue }
    }

    public enum NotificationType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case event = "EVENT"
        case task = "TASK"
        public var description: String { return self.rawValue }
    }

    public enum OAuth2GrantType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case authorizationCode = "AUTHORIZATION_CODE"
        case clientCredentials = "CLIENT_CREDENTIALS"
        case jwtBearer = "JWT_BEARER"
        public var description: String { return self.rawValue }
    }

    public enum OpenLineageRunState: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case abort = "ABORT"
        case complete = "COMPLETE"
        case fail = "FAIL"
        case other = "OTHER"
        case running = "RUNNING"
        case start = "START"
        public var description: String { return self.rawValue }
    }

    public enum OverallDeploymentStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case failedDeployment = "FAILED_DEPLOYMENT"
        case failedValidation = "FAILED_VALIDATION"
        case inProgress = "IN_PROGRESS"
        case pendingDeployment = "PENDING_DEPLOYMENT"
        case successful = "SUCCESSFUL"
        public var description: String { return self.rawValue }
    }

    public enum ProjectDesignation: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case contributor = "CONTRIBUTOR"
        case owner = "OWNER"
        case projectCatalogSteward = "PROJECT_CATALOG_STEWARD"
        public var description: String { return self.rawValue }
    }

    public enum ProjectStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case active = "ACTIVE"
        case deleteFailed = "DELETE_FAILED"
        case deleting = "DELETING"
        case updateFailed = "UPDATE_FAILED"
        case updating = "UPDATING"
        public var description: String { return self.rawValue }
    }

    public enum RejectRuleBehavior: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case all = "ALL"
        case none = "NONE"
        public var description: String { return self.rawValue }
    }

    public enum RuleAction: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case createListingChangeSet = "CREATE_LISTING_CHANGE_SET"
        case createSubscriptionRequest = "CREATE_SUBSCRIPTION_REQUEST"
        public var description: String { return self.rawValue }
    }

    public enum RuleScopeSelectionMode: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case all = "ALL"
        case specific = "SPECIFIC"
        public var description: String { return self.rawValue }
    }

    public enum RuleTargetType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case domainUnit = "DOMAIN_UNIT"
        public var description: String { return self.rawValue }
    }

    public enum RuleType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case metadataFormEnforcement = "METADATA_FORM_ENFORCEMENT"
        public var description: String { return self.rawValue }
    }

    public enum SearchOutputAdditionalAttribute: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case forms = "FORMS"
        case timeSeriesDataPointForms = "TIME_SERIES_DATA_POINT_FORMS"
        public var description: String { return self.rawValue }
    }

    public enum SelfGrantStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case grantFailed = "GRANT_FAILED"
        case grantInProgress = "GRANT_IN_PROGRESS"
        case grantPending = "GRANT_PENDING"
        case granted = "GRANTED"
        case revokeFailed = "REVOKE_FAILED"
        case revokeInProgress = "REVOKE_IN_PROGRESS"
        case revokePending = "REVOKE_PENDING"
        public var description: String { return self.rawValue }
    }

    public enum SortFieldConnection: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case name = "NAME"
        public var description: String { return self.rawValue }
    }

    public enum SortFieldProject: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case name = "NAME"
        public var description: String { return self.rawValue }
    }

    public enum SortKey: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case createdAt = "CREATED_AT"
        case updatedAt = "UPDATED_AT"
        public var description: String { return self.rawValue }
    }

    public enum SortOrder: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case ascending = "ASCENDING"
        case descending = "DESCENDING"
        public var description: String { return self.rawValue }
    }

    public enum Status: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case disabled = "DISABLED"
        case enabled = "ENABLED"
        public var description: String { return self.rawValue }
    }

    public enum SubscriptionGrantOverallStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case completed = "COMPLETED"
        case grantAndRevokeFailed = "GRANT_AND_REVOKE_FAILED"
        case grantFailed = "GRANT_FAILED"
        case inProgress = "IN_PROGRESS"
        case inaccessible = "INACCESSIBLE"
        case pending = "PENDING"
        case revokeFailed = "REVOKE_FAILED"
        public var description: String { return self.rawValue }
    }

    public enum SubscriptionGrantStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case grantFailed = "GRANT_FAILED"
        case grantInProgress = "GRANT_IN_PROGRESS"
        case grantPending = "GRANT_PENDING"
        case granted = "GRANTED"
        case revokeFailed = "REVOKE_FAILED"
        case revokeInProgress = "REVOKE_IN_PROGRESS"
        case revokePending = "REVOKE_PENDING"
        case revoked = "REVOKED"
        public var description: String { return self.rawValue }
    }

    public enum SubscriptionRequestStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case accepted = "ACCEPTED"
        case pending = "PENDING"
        case rejected = "REJECTED"
        public var description: String { return self.rawValue }
    }

    public enum SubscriptionStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case approved = "APPROVED"
        case cancelled = "CANCELLED"
        case revoked = "REVOKED"
        public var description: String { return self.rawValue }
    }

    public enum TargetEntityType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case domainUnit = "DOMAIN_UNIT"
        case environmentBlueprintConfiguration = "ENVIRONMENT_BLUEPRINT_CONFIGURATION"
        case environmentProfile = "ENVIRONMENT_PROFILE"
        public var description: String { return self.rawValue }
    }

    public enum TaskStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case active = "ACTIVE"
        case inactive = "INACTIVE"
        public var description: String { return self.rawValue }
    }

    public enum TimeSeriesEntityType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case asset = "ASSET"
        case listing = "LISTING"
        public var description: String { return self.rawValue }
    }

    public enum Timezone: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case africaJohannesburg = "AFRICA_JOHANNESBURG"
        case americaMontreal = "AMERICA_MONTREAL"
        case americaSaoPaulo = "AMERICA_SAO_PAULO"
        case asiaBahrain = "ASIA_BAHRAIN"
        case asiaBangkok = "ASIA_BANGKOK"
        case asiaCalcutta = "ASIA_CALCUTTA"
        case asiaDubai = "ASIA_DUBAI"
        case asiaHongKong = "ASIA_HONG_KONG"
        case asiaJakarta = "ASIA_JAKARTA"
        case asiaKualaLumpur = "ASIA_KUALA_LUMPUR"
        case asiaSeoul = "ASIA_SEOUL"
        case asiaShanghai = "ASIA_SHANGHAI"
        case asiaSingapore = "ASIA_SINGAPORE"
        case asiaTaipei = "ASIA_TAIPEI"
        case asiaTokyo = "ASIA_TOKYO"
        case australiaMelbourne = "AUSTRALIA_MELBOURNE"
        case australiaSydney = "AUSTRALIA_SYDNEY"
        case canadaCentral = "CANADA_CENTRAL"
        case cet = "CET"
        case cst6cdt = "CST6CDT"
        case etcGmt = "ETC_GMT"
        case etcGmt0 = "ETC_GMT0"
        case etcGmtAdd0 = "ETC_GMT_ADD_0"
        case etcGmtAdd1 = "ETC_GMT_ADD_1"
        case etcGmtAdd10 = "ETC_GMT_ADD_10"
        case etcGmtAdd11 = "ETC_GMT_ADD_11"
        case etcGmtAdd12 = "ETC_GMT_ADD_12"
        case etcGmtAdd2 = "ETC_GMT_ADD_2"
        case etcGmtAdd3 = "ETC_GMT_ADD_3"
        case etcGmtAdd4 = "ETC_GMT_ADD_4"
        case etcGmtAdd5 = "ETC_GMT_ADD_5"
        case etcGmtAdd6 = "ETC_GMT_ADD_6"
        case etcGmtAdd7 = "ETC_GMT_ADD_7"
        case etcGmtAdd8 = "ETC_GMT_ADD_8"
        case etcGmtAdd9 = "ETC_GMT_ADD_9"
        case etcGmtNeg0 = "ETC_GMT_NEG_0"
        case etcGmtNeg1 = "ETC_GMT_NEG_1"
        case etcGmtNeg10 = "ETC_GMT_NEG_10"
        case etcGmtNeg11 = "ETC_GMT_NEG_11"
        case etcGmtNeg12 = "ETC_GMT_NEG_12"
        case etcGmtNeg13 = "ETC_GMT_NEG_13"
        case etcGmtNeg14 = "ETC_GMT_NEG_14"
        case etcGmtNeg2 = "ETC_GMT_NEG_2"
        case etcGmtNeg3 = "ETC_GMT_NEG_3"
        case etcGmtNeg4 = "ETC_GMT_NEG_4"
        case etcGmtNeg5 = "ETC_GMT_NEG_5"
        case etcGmtNeg6 = "ETC_GMT_NEG_6"
        case etcGmtNeg7 = "ETC_GMT_NEG_7"
        case etcGmtNeg8 = "ETC_GMT_NEG_8"
        case etcGmtNeg9 = "ETC_GMT_NEG_9"
        case europeDublin = "EUROPE_DUBLIN"
        case europeLondon = "EUROPE_LONDON"
        case europeParis = "EUROPE_PARIS"
        case europeStockholm = "EUROPE_STOCKHOLM"
        case europeZurich = "EUROPE_ZURICH"
        case israel = "ISRAEL"
        case mexicoGeneral = "MEXICO_GENERAL"
        case mst7mdt = "MST7MDT"
        case pacificAuckland = "PACIFIC_AUCKLAND"
        case usCentral = "US_CENTRAL"
        case usEastern = "US_EASTERN"
        case usMountain = "US_MOUNTAIN"
        case usPacific = "US_PACIFIC"
        case utc = "UTC"
        public var description: String { return self.rawValue }
    }

    public enum TypesSearchScope: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case assetType = "ASSET_TYPE"
        case formType = "FORM_TYPE"
        case lineageNodeType = "LINEAGE_NODE_TYPE"
        public var description: String { return self.rawValue }
    }

    public enum UserAssignment: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case automatic = "AUTOMATIC"
        case manual = "MANUAL"
        public var description: String { return self.rawValue }
    }

    public enum UserDesignation: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case projectCatalogConsumer = "PROJECT_CATALOG_CONSUMER"
        case projectCatalogSteward = "PROJECT_CATALOG_STEWARD"
        case projectCatalogViewer = "PROJECT_CATALOG_VIEWER"
        case projectContributor = "PROJECT_CONTRIBUTOR"
        case projectOwner = "PROJECT_OWNER"
        public var description: String { return self.rawValue }
    }

    public enum UserProfileStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case activated = "ACTIVATED"
        case assigned = "ASSIGNED"
        case deactivated = "DEACTIVATED"
        case notAssigned = "NOT_ASSIGNED"
        public var description: String { return self.rawValue }
    }

    public enum UserProfileType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case iam = "IAM"
        case sso = "SSO"
        public var description: String { return self.rawValue }
    }

    public enum UserSearchType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case datazoneIamUser = "DATAZONE_IAM_USER"
        case datazoneSsoUser = "DATAZONE_SSO_USER"
        case datazoneUser = "DATAZONE_USER"
        case ssoUser = "SSO_USER"
        public var description: String { return self.rawValue }
    }

    public enum UserType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case iamRole = "IAM_ROLE"
        case iamUser = "IAM_USER"
        case ssoUser = "SSO_USER"
        public var description: String { return self.rawValue }
    }

    public enum `Protocol`: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case athena = "ATHENA"
        case glueInteractiveSession = "GLUE_INTERACTIVE_SESSION"
        case https = "HTTPS"
        case jdbc = "JDBC"
        case livy = "LIVY"
        case odbc = "ODBC"
        case prism = "PRISM"
        public var description: String { return self.rawValue }
    }

    public enum AssetFilterConfiguration: AWSEncodableShape & AWSDecodableShape, Sendable {
        /// The column configuration of the asset filter.
        case columnConfiguration(ColumnFilterConfiguration)
        /// The row configuration of the asset filter.
        case rowConfiguration(RowFilterConfiguration)

        public init(from decoder: Decoder) throws {
            let container = try decoder.container(keyedBy: CodingKeys.self)
            guard container.allKeys.count == 1, let key = container.allKeys.first else {
                let context = DecodingError.Context(
                    codingPath: container.codingPath,
                    debugDescription: "Expected exactly one key, but got \(container.allKeys.count)"
                )
                throw DecodingError.dataCorrupted(context)
            }
            switch key {
            case .columnConfiguration:
                let value = try container.decode(ColumnFilterConfiguration.self, forKey: .columnConfiguration)
                self = .columnConfiguration(value)
            case .rowConfiguration:
                let value = try container.decode(RowFilterConfiguration.self, forKey: .rowConfiguration)
                self = .rowConfiguration(value)
            }
        }

        public func encode(to encoder: Encoder) throws {
            var container = encoder.container(keyedBy: CodingKeys.self)
            switch self {
            case .columnConfiguration(let value):
                try container.encode(value, forKey: .columnConfiguration)
            case .rowConfiguration(let value):
                try container.encode(value, forKey: .rowConfiguration)
            }
        }

        private enum CodingKeys: String, CodingKey {
            case columnConfiguration = "columnConfiguration"
            case rowConfiguration = "rowConfiguration"
        }
    }

    public enum AwsAccount: AWSEncodableShape & AWSDecodableShape, Sendable {
        /// The account ID of a project.
        case awsAccountId(String)
        /// The account ID path of a project.
        case awsAccountIdPath(String)

        public init(from decoder: Decoder) throws {
            let container = try decoder.container(keyedBy: CodingKeys.self)
            guard container.allKeys.count == 1, let key = container.allKeys.first else {
                let context = DecodingError.Context(
                    codingPath: container.codingPath,
                    debugDescription: "Expected exactly one key, but got \(container.allKeys.count)"
                )
                throw DecodingError.dataCorrupted(context)
            }
            switch key {
            case .awsAccountId:
                let value = try container.decode(String.self, forKey: .awsAccountId)
                self = .awsAccountId(value)
            case .awsAccountIdPath:
                let value = try container.decode(String.self, forKey: .awsAccountIdPath)
                self = .awsAccountIdPath(value)
            }
        }

        public func encode(to encoder: Encoder) throws {
            var container = encoder.container(keyedBy: CodingKeys.self)
            switch self {
            case .awsAccountId(let value):
                try container.encode(value, forKey: .awsAccountId)
            case .awsAccountIdPath(let value):
                try container.encode(value, forKey: .awsAccountIdPath)
            }
        }

        public func validate(name: String) throws {
            switch self {
            case .awsAccountId(let value):
                try self.validate(value, name: "awsAccountId", parent: name, pattern: "^\\d{12}$")
            case .awsAccountIdPath(let value):
                try self.validate(value, name: "awsAccountIdPath", parent: name, max: 2048)
                try self.validate(value, name: "awsAccountIdPath", parent: name, min: 1)
            }
        }

        private enum CodingKeys: String, CodingKey {
            case awsAccountId = "awsAccountId"
            case awsAccountIdPath = "awsAccountIdPath"
        }
    }

    public enum ConnectionPropertiesInput: AWSEncodableShape, Sendable {
        /// The Amazon Athena properties of a connection.
        case athenaProperties(AthenaPropertiesInput)
        /// The Amazon Web Services Glue properties of a connection.
        case glueProperties(GluePropertiesInput)
        /// The hyper pod properties of a connection.
        case hyperPodProperties(HyperPodPropertiesInput)
        /// The IAM properties of a connection.
        case iamProperties(IamPropertiesInput)
        /// The Amazon Redshift properties of a connection.
        case redshiftProperties(RedshiftPropertiesInput)
        /// The Spark EMR properties of a connection.
        case sparkEmrProperties(SparkEmrPropertiesInput)
        /// The Spark Amazon Web Services Glue properties of a connection.
        case sparkGlueProperties(SparkGluePropertiesInput)

        public func encode(to encoder: Encoder) throws {
            var container = encoder.container(keyedBy: CodingKeys.self)
            switch self {
            case .athenaProperties(let value):
                try container.encode(value, forKey: .athenaProperties)
            case .glueProperties(let value):
                try container.encode(value, forKey: .glueProperties)
            case .hyperPodProperties(let value):
                try container.encode(value, forKey: .hyperPodProperties)
            case .iamProperties(let value):
                try container.encode(value, forKey: .iamProperties)
            case .redshiftProperties(let value):
                try container.encode(value, forKey: .redshiftProperties)
            case .sparkEmrProperties(let value):
                try container.encode(value, forKey: .sparkEmrProperties)
            case .sparkGlueProperties(let value):
                try container.encode(value, forKey: .sparkGlueProperties)
            }
        }

        public func validate(name: String) throws {
            switch self {
            case .glueProperties(let value):
                try value.validate(name: "\(name).glueProperties")
            case .redshiftProperties(let value):
                try value.validate(name: "\(name).redshiftProperties")
            default:
                break
            }
        }

        private enum CodingKeys: String, CodingKey {
            case athenaProperties = "athenaProperties"
            case glueProperties = "glueProperties"
            case hyperPodProperties = "hyperPodProperties"
            case iamProperties = "iamProperties"
            case redshiftProperties = "redshiftProperties"
            case sparkEmrProperties = "sparkEmrProperties"
            case sparkGlueProperties = "sparkGlueProperties"
        }
    }

    public enum ConnectionPropertiesOutput: AWSDecodableShape, Sendable {
        /// The Amazon Athena properties of a connection.
        case athenaProperties(AthenaPropertiesOutput)
        /// The Amazon Web Services Glue properties of a connection.
        case glueProperties(GluePropertiesOutput)
        /// The hyper pod properties of a connection.
        case hyperPodProperties(HyperPodPropertiesOutput)
        /// The IAM properties of a connection.
        case iamProperties(IamPropertiesOutput)
        /// The Amazon Redshift properties of a connection.
        case redshiftProperties(RedshiftPropertiesOutput)
        /// The Spark EMR properties of a connection.
        case sparkEmrProperties(SparkEmrPropertiesOutput)
        /// The Spark Amazon Web Services Glue properties of a connection.
        case sparkGlueProperties(SparkGluePropertiesOutput)

        public init(from decoder: Decoder) throws {
            let container = try decoder.container(keyedBy: CodingKeys.self)
            guard container.allKeys.count == 1, let key = container.allKeys.first else {
                let context = DecodingError.Context(
                    codingPath: container.codingPath,
                    debugDescription: "Expected exactly one key, but got \(container.allKeys.count)"
                )
                throw DecodingError.dataCorrupted(context)
            }
            switch key {
            case .athenaProperties:
                let value = try container.decode(AthenaPropertiesOutput.self, forKey: .athenaProperties)
                self = .athenaProperties(value)
            case .glueProperties:
                let value = try container.decode(GluePropertiesOutput.self, forKey: .glueProperties)
                self = .glueProperties(value)
            case .hyperPodProperties:
                let value = try container.decode(HyperPodPropertiesOutput.self, forKey: .hyperPodProperties)
                self = .hyperPodProperties(value)
            case .iamProperties:
                let value = try container.decode(IamPropertiesOutput.self, forKey: .iamProperties)
                self = .iamProperties(value)
            case .redshiftProperties:
                let value = try container.decode(RedshiftPropertiesOutput.self, forKey: .redshiftProperties)
                self = .redshiftProperties(value)
            case .sparkEmrProperties:
                let value = try container.decode(SparkEmrPropertiesOutput.self, forKey: .sparkEmrProperties)
                self = .sparkEmrProperties(value)
            case .sparkGlueProperties:
                let value = try container.decode(SparkGluePropertiesOutput.self, forKey: .sparkGlueProperties)
                self = .sparkGlueProperties(value)
            }
        }

        private enum CodingKeys: String, CodingKey {
            case athenaProperties = "athenaProperties"
            case glueProperties = "glueProperties"
            case hyperPodProperties = "hyperPodProperties"
            case iamProperties = "iamProperties"
            case redshiftProperties = "redshiftProperties"
            case sparkEmrProperties = "sparkEmrProperties"
            case sparkGlueProperties = "sparkGlueProperties"
        }
    }

    public enum ConnectionPropertiesPatch: AWSEncodableShape, Sendable {
        /// The Amazon Athena properties of a connection properties patch.
        case athenaProperties(AthenaPropertiesPatch)
        /// The Amazon Web Services Glue properties of a connection properties patch.
        case glueProperties(GluePropertiesPatch)
        /// The IAM properties of a connection properties patch.
        case iamProperties(IamPropertiesPatch)
        /// The Amazon Redshift properties of a connection properties patch.
        case redshiftProperties(RedshiftPropertiesPatch)
        /// The Spark EMR properties of a connection properties patch.
        case sparkEmrProperties(SparkEmrPropertiesPatch)

        public func encode(to encoder: Encoder) throws {
            var container = encoder.container(keyedBy: CodingKeys.self)
            switch self {
            case .athenaProperties(let value):
                try container.encode(value, forKey: .athenaProperties)
            case .glueProperties(let value):
                try container.encode(value, forKey: .glueProperties)
            case .iamProperties(let value):
                try container.encode(value, forKey: .iamProperties)
            case .redshiftProperties(let value):
                try container.encode(value, forKey: .redshiftProperties)
            case .sparkEmrProperties(let value):
                try container.encode(value, forKey: .sparkEmrProperties)
            }
        }

        public func validate(name: String) throws {
            switch self {
            case .redshiftProperties(let value):
                try value.validate(name: "\(name).redshiftProperties")
            default:
                break
            }
        }

        private enum CodingKeys: String, CodingKey {
            case athenaProperties = "athenaProperties"
            case glueProperties = "glueProperties"
            case iamProperties = "iamProperties"
            case redshiftProperties = "redshiftProperties"
            case sparkEmrProperties = "sparkEmrProperties"
        }
    }

    public enum DataSourceConfigurationInput: AWSEncodableShape, Sendable {
        /// The configuration of the Amazon Web Services Glue data source.
        case glueRunConfiguration(GlueRunConfigurationInput)
        /// The configuration of the Amazon Redshift data source.
        case redshiftRunConfiguration(RedshiftRunConfigurationInput)
        /// The Amazon SageMaker run configuration.
        case sageMakerRunConfiguration(SageMakerRunConfigurationInput)

        public func encode(to encoder: Encoder) throws {
            var container = encoder.container(keyedBy: CodingKeys.self)
            switch self {
            case .glueRunConfiguration(let value):
                try container.encode(value, forKey: .glueRunConfiguration)
            case .redshiftRunConfiguration(let value):
                try container.encode(value, forKey: .redshiftRunConfiguration)
            case .sageMakerRunConfiguration(let value):
                try container.encode(value, forKey: .sageMakerRunConfiguration)
            }
        }

        public func validate(name: String) throws {
            switch self {
            case .sageMakerRunConfiguration(let value):
                try value.validate(name: "\(name).sageMakerRunConfiguration")
            default:
                break
            }
        }

        private enum CodingKeys: String, CodingKey {
            case glueRunConfiguration = "glueRunConfiguration"
            case redshiftRunConfiguration = "redshiftRunConfiguration"
            case sageMakerRunConfiguration = "sageMakerRunConfiguration"
        }
    }

    public enum DataSourceConfigurationOutput: AWSDecodableShape, Sendable {
        /// The configuration of the Amazon Web Services Glue data source.
        case glueRunConfiguration(GlueRunConfigurationOutput)
        /// The configuration of the Amazon Redshift data source.
        case redshiftRunConfiguration(RedshiftRunConfigurationOutput)
        /// The Amazon SageMaker run configuration.
        case sageMakerRunConfiguration(SageMakerRunConfigurationOutput)

        public init(from decoder: Decoder) throws {
            let container = try decoder.container(keyedBy: CodingKeys.self)
            guard container.allKeys.count == 1, let key = container.allKeys.first else {
                let context = DecodingError.Context(
                    codingPath: container.codingPath,
                    debugDescription: "Expected exactly one key, but got \(container.allKeys.count)"
                )
                throw DecodingError.dataCorrupted(context)
            }
            switch key {
            case .glueRunConfiguration:
                let value = try container.decode(GlueRunConfigurationOutput.self, forKey: .glueRunConfiguration)
                self = .glueRunConfiguration(value)
            case .redshiftRunConfiguration:
                let value = try container.decode(RedshiftRunConfigurationOutput.self, forKey: .redshiftRunConfiguration)
                self = .redshiftRunConfiguration(value)
            case .sageMakerRunConfiguration:
                let value = try container.decode(SageMakerRunConfigurationOutput.self, forKey: .sageMakerRunConfiguration)
                self = .sageMakerRunConfiguration(value)
            }
        }

        private enum CodingKeys: String, CodingKey {
            case glueRunConfiguration = "glueRunConfiguration"
            case redshiftRunConfiguration = "redshiftRunConfiguration"
            case sageMakerRunConfiguration = "sageMakerRunConfiguration"
        }
    }

    public enum DomainUnitOwnerProperties: AWSDecodableShape, Sendable {
        /// Indicates that the domain unit owner is a group.
        case group(DomainUnitGroupProperties)
        /// Indicates that the domain unit owner is a user.
        case user(DomainUnitUserProperties)

        public init(from decoder: Decoder) throws {
            let container = try decoder.container(keyedBy: CodingKeys.self)
            guard container.allKeys.count == 1, let key = container.allKeys.first else {
                let context = DecodingError.Context(
                    codingPath: container.codingPath,
                    debugDescription: "Expected exactly one key, but got \(container.allKeys.count)"
                )
                throw DecodingError.dataCorrupted(context)
            }
            switch key {
            case .group:
                let value = try container.decode(DomainUnitGroupProperties.self, forKey: .group)
                self = .group(value)
            case .user:
                let value = try container.decode(DomainUnitUserProperties.self, forKey: .user)
                self = .user(value)
            }
        }

        private enum CodingKeys: String, CodingKey {
            case group = "group"
            case user = "user"
        }
    }

    public enum FilterClause: AWSEncodableShape, Sendable {
        /// The 'and' search filter clause in Amazon DataZone.
        case and([FilterClause])
        /// A search filter in Amazon DataZone.
        case filter(Filter)
        /// The 'or' search filter clause in Amazon DataZone.
        case or([FilterClause])

        public func encode(to encoder: Encoder) throws {
            var container = encoder.container(keyedBy: CodingKeys.self)
            switch self {
            case .and(let value):
                try container.encode(value, forKey: .and)
            case .filter(let value):
                try container.encode(value, forKey: .filter)
            case .or(let value):
                try container.encode(value, forKey: .or)
            }
        }

        public func validate(name: String) throws {
            switch self {
            case .and(let value):
                try value.forEach {
                    try $0.validate(name: "\(name).and[]")
                }
                try self.validate(value, name: "and", parent: name, max: 100)
                try self.validate(value, name: "and", parent: name, min: 1)
            case .filter(let value):
                try value.validate(name: "\(name).filter")
            case .or(let value):
                try value.forEach {
                    try $0.validate(name: "\(name).or[]")
                }
                try self.validate(value, name: "or", parent: name, max: 100)
                try self.validate(value, name: "or", parent: name, min: 1)
            }
        }

        private enum CodingKeys: String, CodingKey {
            case and = "and"
            case filter = "filter"
            case or = "or"
        }
    }

    public enum ListingItem: AWSDecodableShape, Sendable {
        /// An asset published in an Amazon DataZone catalog.
        case assetListing(AssetListing)
        /// The data product listing.
        case dataProductListing(DataProductListing)

        public init(from decoder: Decoder) throws {
            let container = try decoder.container(keyedBy: CodingKeys.self)
            guard container.allKeys.count == 1, let key = container.allKeys.first else {
                let context = DecodingError.Context(
                    codingPath: container.codingPath,
                    debugDescription: "Expected exactly one key, but got \(container.allKeys.count)"
                )
                throw DecodingError.dataCorrupted(context)
            }
            switch key {
            case .assetListing:
                let value = try container.decode(AssetListing.self, forKey: .assetListing)
                self = .assetListing(value)
            case .dataProductListing:
                let value = try container.decode(DataProductListing.self, forKey: .dataProductListing)
                self = .dataProductListing(value)
            }
        }

        private enum CodingKeys: String, CodingKey {
            case assetListing = "assetListing"
            case dataProductListing = "dataProductListing"
        }
    }

    public enum Member: AWSEncodableShape, Sendable {
        /// The ID of the group of a project member.
        case groupIdentifier(String)
        /// The user ID of a project member.
        case userIdentifier(String)

        public func encode(to encoder: Encoder) throws {
            var container = encoder.container(keyedBy: CodingKeys.self)
            switch self {
            case .groupIdentifier(let value):
                try container.encode(value, forKey: .groupIdentifier)
            case .userIdentifier(let value):
                try container.encode(value, forKey: .userIdentifier)
            }
        }

        private enum CodingKeys: String, CodingKey {
            case groupIdentifier = "groupIdentifier"
            case userIdentifier = "userIdentifier"
        }
    }

    public enum MemberDetails: AWSDecodableShape, Sendable {
        /// The group details of a project member.
        case group(GroupDetails)
        /// The user details of a project member.
        case user(UserDetails)

        public init(from decoder: Decoder) throws {
            let container = try decoder.container(keyedBy: CodingKeys.self)
            guard container.allKeys.count == 1, let key = container.allKeys.first else {
                let context = DecodingError.Context(
                    codingPath: container.codingPath,
                    debugDescription: "Expected exactly one key, but got \(container.allKeys.count)"
                )
                throw DecodingError.dataCorrupted(context)
            }
            switch key {
            case .group:
                let value = try container.decode(GroupDetails.self, forKey: .group)
                self = .group(value)
            case .user:
                let value = try container.decode(UserDetails.self, forKey: .user)
                self = .user(value)
            }
        }

        private enum CodingKeys: String, CodingKey {
            case group = "group"
            case user = "user"
        }
    }

    public enum OwnerProperties: AWSEncodableShape, Sendable {
        /// Specifies that the domain unit owner is a group.
        case group(OwnerGroupProperties)
        /// Specifies that the domain unit owner is a user.
        case user(OwnerUserProperties)

        public func encode(to encoder: Encoder) throws {
            var container = encoder.container(keyedBy: CodingKeys.self)
            switch self {
            case .group(let value):
                try container.encode(value, forKey: .group)
            case .user(let value):
                try container.encode(value, forKey: .user)
            }
        }

        public func validate(name: String) throws {
            switch self {
            case .group(let value):
                try value.validate(name: "\(name).group")
            case .user(let value):
                try value.validate(name: "\(name).user")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case group = "group"
            case user = "user"
        }
    }

    public enum OwnerPropertiesOutput: AWSDecodableShape, Sendable {
        /// Specifies that the domain unit owner is a group.
        case group(OwnerGroupPropertiesOutput)
        /// Specifies that the domain unit owner is a user.
        case user(OwnerUserPropertiesOutput)

        public init(from decoder: Decoder) throws {
            let container = try decoder.container(keyedBy: CodingKeys.self)
            guard container.allKeys.count == 1, let key = container.allKeys.first else {
                let context = DecodingError.Context(
                    codingPath: container.codingPath,
                    debugDescription: "Expected exactly one key, but got \(container.allKeys.count)"
                )
                throw DecodingError.dataCorrupted(context)
            }
            switch key {
            case .group:
                let value = try container.decode(OwnerGroupPropertiesOutput.self, forKey: .group)
                self = .group(value)
            case .user:
                let value = try container.decode(OwnerUserPropertiesOutput.self, forKey: .user)
                self = .user(value)
            }
        }

        private enum CodingKeys: String, CodingKey {
            case group = "group"
            case user = "user"
        }
    }

    public enum PolicyGrantDetail: AWSEncodableShape & AWSDecodableShape, Sendable {
        /// Specifies that the policy grant is to be added to the members of the project.
        case addToProjectMemberPool(AddToProjectMemberPoolPolicyGrantDetail)
        /// Specifies that this is a create asset type policy.
        case createAssetType(CreateAssetTypePolicyGrantDetail)
        /// Specifies that this is a create domain unit policy.
        case createDomainUnit(CreateDomainUnitPolicyGrantDetail)
        /// Specifies that this is a create environment policy.
        case createEnvironment(Unit)
        case createEnvironmentFromBlueprint(Unit)
        /// Specifies that this is a create environment profile policy.
        case createEnvironmentProfile(CreateEnvironmentProfilePolicyGrantDetail)
        /// Specifies that this is a create form type policy.
        case createFormType(CreateFormTypePolicyGrantDetail)
        /// Specifies that this is a create glossary policy.
        case createGlossary(CreateGlossaryPolicyGrantDetail)
        /// Specifies that this is a create project policy.
        case createProject(CreateProjectPolicyGrantDetail)
        /// Specifies whether to create a project from project profile.
        case createProjectFromProjectProfile(CreateProjectFromProjectProfilePolicyGrantDetail)
        /// Specifies that this is the delegation of the create environment profile policy.
        case delegateCreateEnvironmentProfile(Unit)
        /// Specifies whether to override domain unit owners.
        case overrideDomainUnitOwners(OverrideDomainUnitOwnersPolicyGrantDetail)
        /// Specifies whether to override project owners.
        case overrideProjectOwners(OverrideProjectOwnersPolicyGrantDetail)

        public init(from decoder: Decoder) throws {
            let container = try decoder.container(keyedBy: CodingKeys.self)
            guard container.allKeys.count == 1, let key = container.allKeys.first else {
                let context = DecodingError.Context(
                    codingPath: container.codingPath,
                    debugDescription: "Expected exactly one key, but got \(container.allKeys.count)"
                )
                throw DecodingError.dataCorrupted(context)
            }
            switch key {
            case .addToProjectMemberPool:
                let value = try container.decode(AddToProjectMemberPoolPolicyGrantDetail.self, forKey: .addToProjectMemberPool)
                self = .addToProjectMemberPool(value)
            case .createAssetType:
                let value = try container.decode(CreateAssetTypePolicyGrantDetail.self, forKey: .createAssetType)
                self = .createAssetType(value)
            case .createDomainUnit:
                let value = try container.decode(CreateDomainUnitPolicyGrantDetail.self, forKey: .createDomainUnit)
                self = .createDomainUnit(value)
            case .createEnvironment:
                let value = try container.decode(Unit.self, forKey: .createEnvironment)
                self = .createEnvironment(value)
            case .createEnvironmentFromBlueprint:
                let value = try container.decode(Unit.self, forKey: .createEnvironmentFromBlueprint)
                self = .createEnvironmentFromBlueprint(value)
            case .createEnvironmentProfile:
                let value = try container.decode(CreateEnvironmentProfilePolicyGrantDetail.self, forKey: .createEnvironmentProfile)
                self = .createEnvironmentProfile(value)
            case .createFormType:
                let value = try container.decode(CreateFormTypePolicyGrantDetail.self, forKey: .createFormType)
                self = .createFormType(value)
            case .createGlossary:
                let value = try container.decode(CreateGlossaryPolicyGrantDetail.self, forKey: .createGlossary)
                self = .createGlossary(value)
            case .createProject:
                let value = try container.decode(CreateProjectPolicyGrantDetail.self, forKey: .createProject)
                self = .createProject(value)
            case .createProjectFromProjectProfile:
                let value = try container.decode(CreateProjectFromProjectProfilePolicyGrantDetail.self, forKey: .createProjectFromProjectProfile)
                self = .createProjectFromProjectProfile(value)
            case .delegateCreateEnvironmentProfile:
                let value = try container.decode(Unit.self, forKey: .delegateCreateEnvironmentProfile)
                self = .delegateCreateEnvironmentProfile(value)
            case .overrideDomainUnitOwners:
                let value = try container.decode(OverrideDomainUnitOwnersPolicyGrantDetail.self, forKey: .overrideDomainUnitOwners)
                self = .overrideDomainUnitOwners(value)
            case .overrideProjectOwners:
                let value = try container.decode(OverrideProjectOwnersPolicyGrantDetail.self, forKey: .overrideProjectOwners)
                self = .overrideProjectOwners(value)
            }
        }

        public func encode(to encoder: Encoder) throws {
            var container = encoder.container(keyedBy: CodingKeys.self)
            switch self {
            case .addToProjectMemberPool(let value):
                try container.encode(value, forKey: .addToProjectMemberPool)
            case .createAssetType(let value):
                try container.encode(value, forKey: .createAssetType)
            case .createDomainUnit(let value):
                try container.encode(value, forKey: .createDomainUnit)
            case .createEnvironment(let value):
                try container.encode(value, forKey: .createEnvironment)
            case .createEnvironmentFromBlueprint(let value):
                try container.encode(value, forKey: .createEnvironmentFromBlueprint)
            case .createEnvironmentProfile(let value):
                try container.encode(value, forKey: .createEnvironmentProfile)
            case .createFormType(let value):
                try container.encode(value, forKey: .createFormType)
            case .createGlossary(let value):
                try container.encode(value, forKey: .createGlossary)
            case .createProject(let value):
                try container.encode(value, forKey: .createProject)
            case .createProjectFromProjectProfile(let value):
                try container.encode(value, forKey: .createProjectFromProjectProfile)
            case .delegateCreateEnvironmentProfile(let value):
                try container.encode(value, forKey: .delegateCreateEnvironmentProfile)
            case .overrideDomainUnitOwners(let value):
                try container.encode(value, forKey: .overrideDomainUnitOwners)
            case .overrideProjectOwners(let value):
                try container.encode(value, forKey: .overrideProjectOwners)
            }
        }

        public func validate(name: String) throws {
            switch self {
            case .createEnvironmentProfile(let value):
                try value.validate(name: "\(name).createEnvironmentProfile")
            default:
                break
            }
        }

        private enum CodingKeys: String, CodingKey {
            case addToProjectMemberPool = "addToProjectMemberPool"
            case createAssetType = "createAssetType"
            case createDomainUnit = "createDomainUnit"
            case createEnvironment = "createEnvironment"
            case createEnvironmentFromBlueprint = "createEnvironmentFromBlueprint"
            case createEnvironmentProfile = "createEnvironmentProfile"
            case createFormType = "createFormType"
            case createGlossary = "createGlossary"
            case createProject = "createProject"
            case createProjectFromProjectProfile = "createProjectFromProjectProfile"
            case delegateCreateEnvironmentProfile = "delegateCreateEnvironmentProfile"
            case overrideDomainUnitOwners = "overrideDomainUnitOwners"
            case overrideProjectOwners = "overrideProjectOwners"
        }
    }

    public enum PolicyGrantPrincipal: AWSEncodableShape & AWSDecodableShape, Sendable {
        /// The domain unit of the policy grant principal.
        case domainUnit(DomainUnitPolicyGrantPrincipal)
        /// The group of the policy grant principal.
        case group(GroupPolicyGrantPrincipal)
        /// The project of the policy grant principal.
        case project(ProjectPolicyGrantPrincipal)
        /// The user of the policy grant principal.
        case user(UserPolicyGrantPrincipal)

        public init(from decoder: Decoder) throws {
            let container = try decoder.container(keyedBy: CodingKeys.self)
            guard container.allKeys.count == 1, let key = container.allKeys.first else {
                let context = DecodingError.Context(
                    codingPath: container.codingPath,
                    debugDescription: "Expected exactly one key, but got \(container.allKeys.count)"
                )
                throw DecodingError.dataCorrupted(context)
            }
            switch key {
            case .domainUnit:
                let value = try container.decode(DomainUnitPolicyGrantPrincipal.self, forKey: .domainUnit)
                self = .domainUnit(value)
            case .group:
                let value = try container.decode(GroupPolicyGrantPrincipal.self, forKey: .group)
                self = .group(value)
            case .project:
                let value = try container.decode(ProjectPolicyGrantPrincipal.self, forKey: .project)
                self = .project(value)
            case .user:
                let value = try container.decode(UserPolicyGrantPrincipal.self, forKey: .user)
                self = .user(value)
            }
        }

        public func encode(to encoder: Encoder) throws {
            var container = encoder.container(keyedBy: CodingKeys.self)
            switch self {
            case .domainUnit(let value):
                try container.encode(value, forKey: .domainUnit)
            case .group(let value):
                try container.encode(value, forKey: .group)
            case .project(let value):
                try container.encode(value, forKey: .project)
            case .user(let value):
                try container.encode(value, forKey: .user)
            }
        }

        public func validate(name: String) throws {
            switch self {
            case .domainUnit(let value):
                try value.validate(name: "\(name).domainUnit")
            case .group(let value):
                try value.validate(name: "\(name).group")
            case .project(let value):
                try value.validate(name: "\(name).project")
            case .user(let value):
                try value.validate(name: "\(name).user")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case domainUnit = "domainUnit"
            case group = "group"
            case project = "project"
            case user = "user"
        }
    }

    public enum RedshiftCredentials: AWSEncodableShape & AWSDecodableShape, Sendable {
        /// The secret ARN of the Amazon Redshift credentials of a connection.
        case secretArn(String)
        /// The username and password of the Amazon Redshift credentials of a connection.
        case usernamePassword(UsernamePassword)

        public init(from decoder: Decoder) throws {
            let container = try decoder.container(keyedBy: CodingKeys.self)
            guard container.allKeys.count == 1, let key = container.allKeys.first else {
                let context = DecodingError.Context(
                    codingPath: container.codingPath,
                    debugDescription: "Expected exactly one key, but got \(container.allKeys.count)"
                )
                throw DecodingError.dataCorrupted(context)
            }
            switch key {
            case .secretArn:
                let value = try container.decode(String.self, forKey: .secretArn)
                self = .secretArn(value)
            case .usernamePassword:
                let value = try container.decode(UsernamePassword.self, forKey: .usernamePassword)
                self = .usernamePassword(value)
            }
        }

        public func encode(to encoder: Encoder) throws {
            var container = encoder.container(keyedBy: CodingKeys.self)
            switch self {
            case .secretArn(let value):
                try container.encode(value, forKey: .secretArn)
            case .usernamePassword(let value):
                try container.encode(value, forKey: .usernamePassword)
            }
        }

        public func validate(name: String) throws {
            switch self {
            case .usernamePassword(let value):
                try value.validate(name: "\(name).usernamePassword")
            default:
                break
            }
        }

        private enum CodingKeys: String, CodingKey {
            case secretArn = "secretArn"
            case usernamePassword = "usernamePassword"
        }
    }

    public enum RedshiftStorage: AWSEncodableShape & AWSDecodableShape, Sendable {
        /// The details of the Amazon Redshift cluster source.
        case redshiftClusterSource(RedshiftClusterStorage)
        /// The details of the Amazon Redshift Serverless workgroup source.
        case redshiftServerlessSource(RedshiftServerlessStorage)

        public init(from decoder: Decoder) throws {
            let container = try decoder.container(keyedBy: CodingKeys.self)
            guard container.allKeys.count == 1, let key = container.allKeys.first else {
                let context = DecodingError.Context(
                    codingPath: container.codingPath,
                    debugDescription: "Expected exactly one key, but got \(container.allKeys.count)"
                )
                throw DecodingError.dataCorrupted(context)
            }
            switch key {
            case .redshiftClusterSource:
                let value = try container.decode(RedshiftClusterStorage.self, forKey: .redshiftClusterSource)
                self = .redshiftClusterSource(value)
            case .redshiftServerlessSource:
                let value = try container.decode(RedshiftServerlessStorage.self, forKey: .redshiftServerlessSource)
                self = .redshiftServerlessSource(value)
            }
        }

        public func encode(to encoder: Encoder) throws {
            var container = encoder.container(keyedBy: CodingKeys.self)
            switch self {
            case .redshiftClusterSource(let value):
                try container.encode(value, forKey: .redshiftClusterSource)
            case .redshiftServerlessSource(let value):
                try container.encode(value, forKey: .redshiftServerlessSource)
            }
        }

        private enum CodingKeys: String, CodingKey {
            case redshiftClusterSource = "redshiftClusterSource"
            case redshiftServerlessSource = "redshiftServerlessSource"
        }
    }

    public enum RedshiftStorageProperties: AWSEncodableShape & AWSDecodableShape, Sendable {
        /// The cluster name in the Amazon Redshift storage properties.
        case clusterName(String)
        /// The workgroup name in the Amazon Redshift storage properties.
        case workgroupName(String)

        public init(from decoder: Decoder) throws {
            let container = try decoder.container(keyedBy: CodingKeys.self)
            guard container.allKeys.count == 1, let key = container.allKeys.first else {
                let context = DecodingError.Context(
                    codingPath: container.codingPath,
                    debugDescription: "Expected exactly one key, but got \(container.allKeys.count)"
                )
                throw DecodingError.dataCorrupted(context)
            }
            switch key {
            case .clusterName:
                let value = try container.decode(String.self, forKey: .clusterName)
                self = .clusterName(value)
            case .workgroupName:
                let value = try container.decode(String.self, forKey: .workgroupName)
                self = .workgroupName(value)
            }
        }

        public func encode(to encoder: Encoder) throws {
            var container = encoder.container(keyedBy: CodingKeys.self)
            switch self {
            case .clusterName(let value):
                try container.encode(value, forKey: .clusterName)
            case .workgroupName(let value):
                try container.encode(value, forKey: .workgroupName)
            }
        }

        private enum CodingKeys: String, CodingKey {
            case clusterName = "clusterName"
            case workgroupName = "workgroupName"
        }
    }

    public enum Region: AWSEncodableShape & AWSDecodableShape, Sendable {
        /// The Amazon Web Services Region name.
        case regionName(String)
        /// The region name path.
        case regionNamePath(String)

        public init(from decoder: Decoder) throws {
            let container = try decoder.container(keyedBy: CodingKeys.self)
            guard container.allKeys.count == 1, let key = container.allKeys.first else {
                let context = DecodingError.Context(
                    codingPath: container.codingPath,
                    debugDescription: "Expected exactly one key, but got \(container.allKeys.count)"
                )
                throw DecodingError.dataCorrupted(context)
            }
            switch key {
            case .regionName:
                let value = try container.decode(String.self, forKey: .regionName)
                self = .regionName(value)
            case .regionNamePath:
                let value = try container.decode(String.self, forKey: .regionNamePath)
                self = .regionNamePath(value)
            }
        }

        public func encode(to encoder: Encoder) throws {
            var container = encoder.container(keyedBy: CodingKeys.self)
            switch self {
            case .regionName(let value):
                try container.encode(value, forKey: .regionName)
            case .regionNamePath(let value):
                try container.encode(value, forKey: .regionNamePath)
            }
        }

        public func validate(name: String) throws {
            switch self {
            case .regionName(let value):
                try self.validate(value, name: "regionName", parent: name, max: 16)
                try self.validate(value, name: "regionName", parent: name, min: 4)
                try self.validate(value, name: "regionName", parent: name, pattern: "^[a-z]{2}-?(iso|gov)?-{1}[a-z]*-{1}[0-9]$")
            case .regionNamePath(let value):
                try self.validate(value, name: "regionNamePath", parent: name, max: 2048)
                try self.validate(value, name: "regionNamePath", parent: name, min: 1)
            }
        }

        private enum CodingKeys: String, CodingKey {
            case regionName = "regionName"
            case regionNamePath = "regionNamePath"
        }
    }

    public enum RowFilter: AWSEncodableShape & AWSDecodableShape, Sendable {
        /// The 'and' clause of the row filter.
        case and([RowFilter])
        /// The expression of the row filter.
        case expression(RowFilterExpression)
        /// The 'or' clause of the row filter.
        case or([RowFilter])

        public init(from decoder: Decoder) throws {
            let container = try decoder.container(keyedBy: CodingKeys.self)
            guard container.allKeys.count == 1, let key = container.allKeys.first else {
                let context = DecodingError.Context(
                    codingPath: container.codingPath,
                    debugDescription: "Expected exactly one key, but got \(container.allKeys.count)"
                )
                throw DecodingError.dataCorrupted(context)
            }
            switch key {
            case .and:
                let value = try container.decode([RowFilter].self, forKey: .and)
                self = .and(value)
            case .expression:
                let value = try container.decode(RowFilterExpression.self, forKey: .expression)
                self = .expression(value)
            case .or:
                let value = try container.decode([RowFilter].self, forKey: .or)
                self = .or(value)
            }
        }

        public func encode(to encoder: Encoder) throws {
            var container = encoder.container(keyedBy: CodingKeys.self)
            switch self {
            case .and(let value):
                try container.encode(value, forKey: .and)
            case .expression(let value):
                try container.encode(value, forKey: .expression)
            case .or(let value):
                try container.encode(value, forKey: .or)
            }
        }

        private enum CodingKeys: String, CodingKey {
            case and = "and"
            case expression = "expression"
            case or = "or"
        }
    }

    public enum RowFilterExpression: AWSEncodableShape & AWSDecodableShape, Sendable {
        /// The 'equal to' clause of the row filter expression.
        case equalTo(EqualToExpression)
        /// The 'greater than' clause of the row filter expression.
        case greaterThan(GreaterThanExpression)
        /// The 'greater than or equal to' clause of the filter expression.
        case greaterThanOrEqualTo(GreaterThanOrEqualToExpression)
        /// The 'in' clause of the row filter expression.
        case `in`(InExpression)
        /// The 'is not null' clause of the row filter expression.
        case isNotNull(IsNotNullExpression)
        /// The 'is null' clause of the row filter expression.
        case isNull(IsNullExpression)
        /// The 'less than' clause of the row filter expression.
        case lessThan(LessThanExpression)
        /// The 'less than or equal to' clause of the row filter expression.
        case lessThanOrEqualTo(LessThanOrEqualToExpression)
        /// The 'like' clause of the row filter expression.
        case like(LikeExpression)
        /// The 'no equal to' clause of the row filter expression.
        case notEqualTo(NotEqualToExpression)
        /// The 'not in' clause of the row filter expression.
        case notIn(NotInExpression)
        /// The 'not like' clause of the row filter expression.
        case notLike(NotLikeExpression)

        public init(from decoder: Decoder) throws {
            let container = try decoder.container(keyedBy: CodingKeys.self)
            guard container.allKeys.count == 1, let key = container.allKeys.first else {
                let context = DecodingError.Context(
                    codingPath: container.codingPath,
                    debugDescription: "Expected exactly one key, but got \(container.allKeys.count)"
                )
                throw DecodingError.dataCorrupted(context)
            }
            switch key {
            case .equalTo:
                let value = try container.decode(EqualToExpression.self, forKey: .equalTo)
                self = .equalTo(value)
            case .greaterThan:
                let value = try container.decode(GreaterThanExpression.self, forKey: .greaterThan)
                self = .greaterThan(value)
            case .greaterThanOrEqualTo:
                let value = try container.decode(GreaterThanOrEqualToExpression.self, forKey: .greaterThanOrEqualTo)
                self = .greaterThanOrEqualTo(value)
            case .`in`:
                let value = try container.decode(InExpression.self, forKey: .`in`)
                self = .`in`(value)
            case .isNotNull:
                let value = try container.decode(IsNotNullExpression.self, forKey: .isNotNull)
                self = .isNotNull(value)
            case .isNull:
                let value = try container.decode(IsNullExpression.self, forKey: .isNull)
                self = .isNull(value)
            case .lessThan:
                let value = try container.decode(LessThanExpression.self, forKey: .lessThan)
                self = .lessThan(value)
            case .lessThanOrEqualTo:
                let value = try container.decode(LessThanOrEqualToExpression.self, forKey: .lessThanOrEqualTo)
                self = .lessThanOrEqualTo(value)
            case .like:
                let value = try container.decode(LikeExpression.self, forKey: .like)
                self = .like(value)
            case .notEqualTo:
                let value = try container.decode(NotEqualToExpression.self, forKey: .notEqualTo)
                self = .notEqualTo(value)
            case .notIn:
                let value = try container.decode(NotInExpression.self, forKey: .notIn)
                self = .notIn(value)
            case .notLike:
                let value = try container.decode(NotLikeExpression.self, forKey: .notLike)
                self = .notLike(value)
            }
        }

        public func encode(to encoder: Encoder) throws {
            var container = encoder.container(keyedBy: CodingKeys.self)
            switch self {
            case .equalTo(let value):
                try container.encode(value, forKey: .equalTo)
            case .greaterThan(let value):
                try container.encode(value, forKey: .greaterThan)
            case .greaterThanOrEqualTo(let value):
                try container.encode(value, forKey: .greaterThanOrEqualTo)
            case .`in`(let value):
                try container.encode(value, forKey: .`in`)
            case .isNotNull(let value):
                try container.encode(value, forKey: .isNotNull)
            case .isNull(let value):
                try container.encode(value, forKey: .isNull)
            case .lessThan(let value):
                try container.encode(value, forKey: .lessThan)
            case .lessThanOrEqualTo(let value):
                try container.encode(value, forKey: .lessThanOrEqualTo)
            case .like(let value):
                try container.encode(value, forKey: .like)
            case .notEqualTo(let value):
                try container.encode(value, forKey: .notEqualTo)
            case .notIn(let value):
                try container.encode(value, forKey: .notIn)
            case .notLike(let value):
                try container.encode(value, forKey: .notLike)
            }
        }

        private enum CodingKeys: String, CodingKey {
            case equalTo = "equalTo"
            case greaterThan = "greaterThan"
            case greaterThanOrEqualTo = "greaterThanOrEqualTo"
            case `in` = "in"
            case isNotNull = "isNotNull"
            case isNull = "isNull"
            case lessThan = "lessThan"
            case lessThanOrEqualTo = "lessThanOrEqualTo"
            case like = "like"
            case notEqualTo = "notEqualTo"
            case notIn = "notIn"
            case notLike = "notLike"
        }
    }

    public enum SearchInventoryResultItem: AWSDecodableShape, Sendable {
        /// The asset item included in the search results.
        case assetItem(AssetItem)
        /// The data product.
        case dataProductItem(DataProductResultItem)
        /// The glossary item included in the search results.
        case glossaryItem(GlossaryItem)
        /// The glossary term item included in the search results.
        case glossaryTermItem(GlossaryTermItem)

        public init(from decoder: Decoder) throws {
            let container = try decoder.container(keyedBy: CodingKeys.self)
            guard container.allKeys.count == 1, let key = container.allKeys.first else {
                let context = DecodingError.Context(
                    codingPath: container.codingPath,
                    debugDescription: "Expected exactly one key, but got \(container.allKeys.count)"
                )
                throw DecodingError.dataCorrupted(context)
            }
            switch key {
            case .assetItem:
                let value = try container.decode(AssetItem.self, forKey: .assetItem)
                self = .assetItem(value)
            case .dataProductItem:
                let value = try container.decode(DataProductResultItem.self, forKey: .dataProductItem)
                self = .dataProductItem(value)
            case .glossaryItem:
                let value = try container.decode(GlossaryItem.self, forKey: .glossaryItem)
                self = .glossaryItem(value)
            case .glossaryTermItem:
                let value = try container.decode(GlossaryTermItem.self, forKey: .glossaryTermItem)
                self = .glossaryTermItem(value)
            }
        }

        private enum CodingKeys: String, CodingKey {
            case assetItem = "assetItem"
            case dataProductItem = "dataProductItem"
            case glossaryItem = "glossaryItem"
            case glossaryTermItem = "glossaryTermItem"
        }
    }

    public enum SearchResultItem: AWSDecodableShape, Sendable {
        /// The asset listing included in the results of the SearchListings action.
        case assetListing(AssetListingItem)
        /// The data product listing.
        case dataProductListing(DataProductListingItem)

        public init(from decoder: Decoder) throws {
            let container = try decoder.container(keyedBy: CodingKeys.self)
            guard container.allKeys.count == 1, let key = container.allKeys.first else {
                let context = DecodingError.Context(
                    codingPath: container.codingPath,
                    debugDescription: "Expected exactly one key, but got \(container.allKeys.count)"
                )
                throw DecodingError.dataCorrupted(context)
            }
            switch key {
            case .assetListing:
                let value = try container.decode(AssetListingItem.self, forKey: .assetListing)
                self = .assetListing(value)
            case .dataProductListing:
                let value = try container.decode(DataProductListingItem.self, forKey: .dataProductListing)
                self = .dataProductListing(value)
            }
        }

        private enum CodingKeys: String, CodingKey {
            case assetListing = "assetListing"
            case dataProductListing = "dataProductListing"
        }
    }

    public enum SearchTypesResultItem: AWSDecodableShape, Sendable {
        /// The asset type included in the results of the SearchTypes action.
        case assetTypeItem(AssetTypeItem)
        /// The form type included in the results of the SearchTypes action.
        case formTypeItem(FormTypeData)
        /// The details of a data lineage node type.
        case lineageNodeTypeItem(LineageNodeTypeItem)

        public init(from decoder: Decoder) throws {
            let container = try decoder.container(keyedBy: CodingKeys.self)
            guard container.allKeys.count == 1, let key = container.allKeys.first else {
                let context = DecodingError.Context(
                    codingPath: container.codingPath,
                    debugDescription: "Expected exactly one key, but got \(container.allKeys.count)"
                )
                throw DecodingError.dataCorrupted(context)
            }
            switch key {
            case .assetTypeItem:
                let value = try container.decode(AssetTypeItem.self, forKey: .assetTypeItem)
                self = .assetTypeItem(value)
            case .formTypeItem:
                let value = try container.decode(FormTypeData.self, forKey: .formTypeItem)
                self = .formTypeItem(value)
            case .lineageNodeTypeItem:
                let value = try container.decode(LineageNodeTypeItem.self, forKey: .lineageNodeTypeItem)
                self = .lineageNodeTypeItem(value)
            }
        }

        private enum CodingKeys: String, CodingKey {
            case assetTypeItem = "assetTypeItem"
            case formTypeItem = "formTypeItem"
            case lineageNodeTypeItem = "lineageNodeTypeItem"
        }
    }

    public enum SelfGrantStatusOutput: AWSDecodableShape, Sendable {
        /// The details for the self granting status for a Glue data source.
        case glueSelfGrantStatus(GlueSelfGrantStatusOutput)
        /// The details for the self granting status for an Amazon Redshift data source.
        case redshiftSelfGrantStatus(RedshiftSelfGrantStatusOutput)

        public init(from decoder: Decoder) throws {
            let container = try decoder.container(keyedBy: CodingKeys.self)
            guard container.allKeys.count == 1, let key = container.allKeys.first else {
                let context = DecodingError.Context(
                    codingPath: container.codingPath,
                    debugDescription: "Expected exactly one key, but got \(container.allKeys.count)"
                )
                throw DecodingError.dataCorrupted(context)
            }
            switch key {
            case .glueSelfGrantStatus:
                let value = try container.decode(GlueSelfGrantStatusOutput.self, forKey: .glueSelfGrantStatus)
                self = .glueSelfGrantStatus(value)
            case .redshiftSelfGrantStatus:
                let value = try container.decode(RedshiftSelfGrantStatusOutput.self, forKey: .redshiftSelfGrantStatus)
                self = .redshiftSelfGrantStatus(value)
            }
        }

        private enum CodingKeys: String, CodingKey {
            case glueSelfGrantStatus = "glueSelfGrantStatus"
            case redshiftSelfGrantStatus = "redshiftSelfGrantStatus"
        }
    }

    public enum SubscribedListingItem: AWSDecodableShape, Sendable {
        /// The asset for which the subscription grant is created.
        case assetListing(SubscribedAssetListing)
        /// The data product listing.
        case productListing(SubscribedProductListing)

        public init(from decoder: Decoder) throws {
            let container = try decoder.container(keyedBy: CodingKeys.self)
            guard container.allKeys.count == 1, let key = container.allKeys.first else {
                let context = DecodingError.Context(
                    codingPath: container.codingPath,
                    debugDescription: "Expected exactly one key, but got \(container.allKeys.count)"
                )
                throw DecodingError.dataCorrupted(context)
            }
            switch key {
            case .assetListing:
                let value = try container.decode(SubscribedAssetListing.self, forKey: .assetListing)
                self = .assetListing(value)
            case .productListing:
                let value = try container.decode(SubscribedProductListing.self, forKey: .productListing)
                self = .productListing(value)
            }
        }

        private enum CodingKeys: String, CodingKey {
            case assetListing = "assetListing"
            case productListing = "productListing"
        }
    }

    public enum UserPolicyGrantPrincipal: AWSEncodableShape & AWSDecodableShape, Sendable {
        /// The all users grant filter of the user policy grant principal.
        case allUsersGrantFilter(AllUsersGrantFilter)
        /// The user ID of the user policy grant principal.
        case userIdentifier(String)

        public init(from decoder: Decoder) throws {
            let container = try decoder.container(keyedBy: CodingKeys.self)
            guard container.allKeys.count == 1, let key = container.allKeys.first else {
                let context = DecodingError.Context(
                    codingPath: container.codingPath,
                    debugDescription: "Expected exactly one key, but got \(container.allKeys.count)"
                )
                throw DecodingError.dataCorrupted(context)
            }
            switch key {
            case .allUsersGrantFilter:
                let value = try container.decode(AllUsersGrantFilter.self, forKey: .allUsersGrantFilter)
                self = .allUsersGrantFilter(value)
            case .userIdentifier:
                let value = try container.decode(String.self, forKey: .userIdentifier)
                self = .userIdentifier(value)
            }
        }

        public func encode(to encoder: Encoder) throws {
            var container = encoder.container(keyedBy: CodingKeys.self)
            switch self {
            case .allUsersGrantFilter(let value):
                try container.encode(value, forKey: .allUsersGrantFilter)
            case .userIdentifier(let value):
                try container.encode(value, forKey: .userIdentifier)
            }
        }

        public func validate(name: String) throws {
            switch self {
            case .userIdentifier(let value):
                try self.validate(value, name: "userIdentifier", parent: name, pattern: "(^([0-9a-f]{10}-|)[A-Fa-f0-9]{8}-[A-Fa-f0-9]{4}-[A-Fa-f0-9]{4}-[A-Fa-f0-9]{4}-[A-Fa-f0-9]{12}$|^[a-zA-Z_0-9+=,.@-]+$|^arn:aws:iam::\\d{12}:.+$)")
            default:
                break
            }
        }

        private enum CodingKeys: String, CodingKey {
            case allUsersGrantFilter = "allUsersGrantFilter"
            case userIdentifier = "userIdentifier"
        }
    }

    public enum UserProfileDetails: AWSDecodableShape, Sendable {
        /// The IAM details included in the user profile details.
        case iam(IamUserProfileDetails)
        /// The single sign-on details included in the user profile details.
        case sso(SsoUserProfileDetails)

        public init(from decoder: Decoder) throws {
            let container = try decoder.container(keyedBy: CodingKeys.self)
            guard container.allKeys.count == 1, let key = container.allKeys.first else {
                let context = DecodingError.Context(
                    codingPath: container.codingPath,
                    debugDescription: "Expected exactly one key, but got \(container.allKeys.count)"
                )
                throw DecodingError.dataCorrupted(context)
            }
            switch key {
            case .iam:
                let value = try container.decode(IamUserProfileDetails.self, forKey: .iam)
                self = .iam(value)
            case .sso:
                let value = try container.decode(SsoUserProfileDetails.self, forKey: .sso)
                self = .sso(value)
            }
        }

        private enum CodingKeys: String, CodingKey {
            case iam = "iam"
            case sso = "sso"
        }
    }

    // MARK: Shapes

    public struct AcceptChoice: AWSEncodableShape {
        /// The edit of the prediction.
        public let editedValue: String?
        /// Specifies the prediction (aka, the automatically generated piece of metadata) that can be accepted.
        public let predictionChoice: Int?
        /// Specifies the target (for example, a column name) where a prediction can be accepted.
        public let predictionTarget: String?

        @inlinable
        public init(editedValue: String? = nil, predictionChoice: Int? = nil, predictionTarget: String? = nil) {
            self.editedValue = editedValue
            self.predictionChoice = predictionChoice
            self.predictionTarget = predictionTarget
        }

        public func validate(name: String) throws {
            try self.validate(self.editedValue, name: "editedValue", parent: name, max: 5000)
            try self.validate(self.editedValue, name: "editedValue", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case editedValue = "editedValue"
            case predictionChoice = "predictionChoice"
            case predictionTarget = "predictionTarget"
        }
    }

    public struct AcceptPredictionsInput: AWSEncodableShape {
        /// Specifies the prediction (aka, the automatically generated piece of metadata) and the target (for example, a column name) that can be accepted.
        public let acceptChoices: [AcceptChoice]?
        /// Specifies the rule (or the conditions) under which a prediction can be accepted.
        public let acceptRule: AcceptRule?
        /// A unique, case-sensitive identifier to ensure idempotency of the request. This field is automatically populated if not provided.
        public let clientToken: String?
        /// The identifier of the Amazon DataZone domain.
        public let domainIdentifier: String
        /// The identifier of the asset.
        public let identifier: String
        /// The revision that is to be made to the asset.
        public let revision: String?

        @inlinable
        public init(acceptChoices: [AcceptChoice]? = nil, acceptRule: AcceptRule? = nil, clientToken: String? = AcceptPredictionsInput.idempotencyToken(), domainIdentifier: String, identifier: String, revision: String? = nil) {
            self.acceptChoices = acceptChoices
            self.acceptRule = acceptRule
            self.clientToken = clientToken
            self.domainIdentifier = domainIdentifier
            self.identifier = identifier
            self.revision = revision
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.acceptChoices, forKey: .acceptChoices)
            try container.encodeIfPresent(self.acceptRule, forKey: .acceptRule)
            try container.encodeIfPresent(self.clientToken, forKey: .clientToken)
            request.encodePath(self.domainIdentifier, key: "domainIdentifier")
            request.encodePath(self.identifier, key: "identifier")
            request.encodeQuery(self.revision, key: "revision")
        }

        public func validate(name: String) throws {
            try self.acceptChoices?.forEach {
                try $0.validate(name: "\(name).acceptChoices[]")
            }
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 128)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "^[\\x21-\\x7E]+$")
            try self.validate(self.domainIdentifier, name: "domainIdentifier", parent: name, pattern: "^dzd[-_][a-zA-Z0-9_-]{1,36}$")
            try self.validate(self.identifier, name: "identifier", parent: name, pattern: "^[a-zA-Z0-9_-]{1,36}$")
            try self.validate(self.revision, name: "revision", parent: name, max: 64)
            try self.validate(self.revision, name: "revision", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case acceptChoices = "acceptChoices"
            case acceptRule = "acceptRule"
            case clientToken = "clientToken"
        }
    }

    public struct AcceptPredictionsOutput: AWSDecodableShape {
        /// The ID of the asset.
        public let assetId: String
        /// The identifier of the Amazon DataZone domain.
        public let domainId: String
        /// The revision that is to be made to the asset.
        public let revision: String

        @inlinable
        public init(assetId: String, domainId: String, revision: String) {
            self.assetId = assetId
            self.domainId = domainId
            self.revision = revision
        }

        private enum CodingKeys: String, CodingKey {
            case assetId = "assetId"
            case domainId = "domainId"
            case revision = "revision"
        }
    }

    public struct AcceptRule: AWSEncodableShape {
        /// Specifies whether you want to accept the top prediction for all targets or none.
        public let rule: AcceptRuleBehavior?
        /// The confidence score that specifies the condition at which a prediction can be accepted.
        public let threshold: Float?

        @inlinable
        public init(rule: AcceptRuleBehavior? = nil, threshold: Float? = nil) {
            self.rule = rule
            self.threshold = threshold
        }

        private enum CodingKeys: String, CodingKey {
            case rule = "rule"
            case threshold = "threshold"
        }
    }

    public struct AcceptSubscriptionRequestInput: AWSEncodableShape {
        /// The asset scopes of the accept subscription request.
        public let assetScopes: [AcceptedAssetScope]?
        /// A description that specifies the reason for accepting the specified subscription request.
        public let decisionComment: String?
        /// The Amazon DataZone domain where the specified subscription request is being accepted.
        public let domainIdentifier: String
        /// The unique identifier of the subscription request that is to be accepted.
        public let identifier: String

        @inlinable
        public init(assetScopes: [AcceptedAssetScope]? = nil, decisionComment: String? = nil, domainIdentifier: String, identifier: String) {
            self.assetScopes = assetScopes
            self.decisionComment = decisionComment
            self.domainIdentifier = domainIdentifier
            self.identifier = identifier
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.assetScopes, forKey: .assetScopes)
            try container.encodeIfPresent(self.decisionComment, forKey: .decisionComment)
            request.encodePath(self.domainIdentifier, key: "domainIdentifier")
            request.encodePath(self.identifier, key: "identifier")
        }

        public func validate(name: String) throws {
            try self.assetScopes?.forEach {
                try $0.validate(name: "\(name).assetScopes[]")
            }
            try self.validate(self.decisionComment, name: "decisionComment", parent: name, max: 4096)
            try self.validate(self.decisionComment, name: "decisionComment", parent: name, min: 1)
            try self.validate(self.domainIdentifier, name: "domainIdentifier", parent: name, pattern: "^dzd[-_][a-zA-Z0-9_-]{1,36}$")
            try self.validate(self.identifier, name: "identifier", parent: name, pattern: "^[a-zA-Z0-9_-]{1,36}$")
        }

        private enum CodingKeys: String, CodingKey {
            case assetScopes = "assetScopes"
            case decisionComment = "decisionComment"
        }
    }

    public struct AcceptSubscriptionRequestOutput: AWSDecodableShape {
        /// The timestamp that specifies when the subscription request was accepted.
        public let createdAt: Date
        /// Specifies the Amazon DataZone user that accepted the specified subscription request.
        public let createdBy: String
        /// Specifies the reason for accepting the subscription request.
        public let decisionComment: String?
        /// The unique identifier of the Amazon DataZone domain where the specified subscription request was accepted.
        public let domainId: String
        /// The ID of the existing subscription.
        public let existingSubscriptionId: String?
        /// The identifier of the subscription request.
        public let id: String
        /// The metadata form in the subscription request.
        public let metadataForms: [FormOutput]?
        /// Specifies the reason for requesting a subscription to the asset.
        public let requestReason: String
        /// Specifes the ID of the Amazon DataZone user who reviewed the subscription request.
        public let reviewerId: String?
        /// Specifies the status of the subscription request.
        public let status: SubscriptionRequestStatus
        /// Specifies the asset for which the subscription request was created.
        public let subscribedListings: [SubscribedListing]
        /// Specifies the Amazon DataZone users who are subscribed to the asset specified in the subscription request.
        public let subscribedPrincipals: [SubscribedPrincipal]
        /// Specifies the timestamp when subscription request was updated.
        public let updatedAt: Date
        /// Specifies the Amazon DataZone user who updated the subscription request.
        public let updatedBy: String?

        @inlinable
        public init(createdAt: Date, createdBy: String, decisionComment: String? = nil, domainId: String, existingSubscriptionId: String? = nil, id: String, metadataForms: [FormOutput]? = nil, requestReason: String, reviewerId: String? = nil, status: SubscriptionRequestStatus, subscribedListings: [SubscribedListing], subscribedPrincipals: [SubscribedPrincipal], updatedAt: Date, updatedBy: String? = nil) {
            self.createdAt = createdAt
            self.createdBy = createdBy
            self.decisionComment = decisionComment
            self.domainId = domainId
            self.existingSubscriptionId = existingSubscriptionId
            self.id = id
            self.metadataForms = metadataForms
            self.requestReason = requestReason
            self.reviewerId = reviewerId
            self.status = status
            self.subscribedListings = subscribedListings
            self.subscribedPrincipals = subscribedPrincipals
            self.updatedAt = updatedAt
            self.updatedBy = updatedBy
        }

        private enum CodingKeys: String, CodingKey {
            case createdAt = "createdAt"
            case createdBy = "createdBy"
            case decisionComment = "decisionComment"
            case domainId = "domainId"
            case existingSubscriptionId = "existingSubscriptionId"
            case id = "id"
            case metadataForms = "metadataForms"
            case requestReason = "requestReason"
            case reviewerId = "reviewerId"
            case status = "status"
            case subscribedListings = "subscribedListings"
            case subscribedPrincipals = "subscribedPrincipals"
            case updatedAt = "updatedAt"
            case updatedBy = "updatedBy"
        }
    }

    public struct AcceptedAssetScope: AWSEncodableShape {
        /// The asset ID of the accepted asset scope.
        public let assetId: String
        /// The filter IDs of the accepted asset scope.
        public let filterIds: [String]

        @inlinable
        public init(assetId: String, filterIds: [String]) {
            self.assetId = assetId
            self.filterIds = filterIds
        }

        public func validate(name: String) throws {
            try self.validate(self.assetId, name: "assetId", parent: name, pattern: "^[a-zA-Z0-9_-]{1,36}$")
            try self.filterIds.forEach {
                try validate($0, name: "filterIds[]", parent: name, pattern: "^[a-zA-Z0-9_-]{1,36}$")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case assetId = "assetId"
            case filterIds = "filterIds"
        }
    }

    public struct AddEntityOwnerInput: AWSEncodableShape {
        /// A unique, case-sensitive identifier that is provided to ensure the idempotency of the request.
        public let clientToken: String?
        /// The ID of the domain in which you want to add the entity owner.
        public let domainIdentifier: String
        /// The ID of the entity to which you want to add an owner.
        public let entityIdentifier: String
        /// The type of an entity.
        public let entityType: DataZoneEntityType
        /// The owner that you want to add to the entity.
        public let owner: OwnerProperties

        @inlinable
        public init(clientToken: String? = AddEntityOwnerInput.idempotencyToken(), domainIdentifier: String, entityIdentifier: String, entityType: DataZoneEntityType, owner: OwnerProperties) {
            self.clientToken = clientToken
            self.domainIdentifier = domainIdentifier
            self.entityIdentifier = entityIdentifier
            self.entityType = entityType
            self.owner = owner
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.clientToken, forKey: .clientToken)
            request.encodePath(self.domainIdentifier, key: "domainIdentifier")
            request.encodePath(self.entityIdentifier, key: "entityIdentifier")
            request.encodePath(self.entityType, key: "entityType")
            try container.encode(self.owner, forKey: .owner)
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 128)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "^[\\x21-\\x7E]+$")
            try self.validate(self.domainIdentifier, name: "domainIdentifier", parent: name, pattern: "^dzd[-_][a-zA-Z0-9_-]{1,36}$")
            try self.owner.validate(name: "\(name).owner")
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "clientToken"
            case owner = "owner"
        }
    }

    public struct AddEntityOwnerOutput: AWSDecodableShape {
        public init() {}
    }

    public struct AddPolicyGrantInput: AWSEncodableShape {
        /// A unique, case-sensitive identifier that is provided to ensure the idempotency of the request.
        public let clientToken: String?
        /// The details of the policy grant.
        public let detail: PolicyGrantDetail
        /// The ID of the domain where you want to add a policy grant.
        public let domainIdentifier: String
        /// The ID of the entity (resource) to which you want to add a policy grant.
        public let entityIdentifier: String
        /// The type of entity (resource) to which the grant is added.
        public let entityType: TargetEntityType
        /// The type of policy that you want to grant.
        public let policyType: ManagedPolicyType
        /// The principal to whom the permissions are granted.
        public let principal: PolicyGrantPrincipal

        @inlinable
        public init(clientToken: String? = AddPolicyGrantInput.idempotencyToken(), detail: PolicyGrantDetail, domainIdentifier: String, entityIdentifier: String, entityType: TargetEntityType, policyType: ManagedPolicyType, principal: PolicyGrantPrincipal) {
            self.clientToken = clientToken
            self.detail = detail
            self.domainIdentifier = domainIdentifier
            self.entityIdentifier = entityIdentifier
            self.entityType = entityType
            self.policyType = policyType
            self.principal = principal
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.clientToken, forKey: .clientToken)
            try container.encode(self.detail, forKey: .detail)
            request.encodePath(self.domainIdentifier, key: "domainIdentifier")
            request.encodePath(self.entityIdentifier, key: "entityIdentifier")
            request.encodePath(self.entityType, key: "entityType")
            try container.encode(self.policyType, forKey: .policyType)
            try container.encode(self.principal, forKey: .principal)
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 128)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "^[\\x21-\\x7E]+$")
            try self.detail.validate(name: "\(name).detail")
            try self.validate(self.domainIdentifier, name: "domainIdentifier", parent: name, pattern: "^dzd[-_][a-zA-Z0-9_-]{1,36}$")
            try self.principal.validate(name: "\(name).principal")
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "clientToken"
            case detail = "detail"
            case policyType = "policyType"
            case principal = "principal"
        }
    }

    public struct AddPolicyGrantOutput: AWSDecodableShape {
        public init() {}
    }

    public struct AddToProjectMemberPoolPolicyGrantDetail: AWSEncodableShape & AWSDecodableShape {
        /// Specifies whether the policy grant is applied to child domain units.
        public let includeChildDomainUnits: Bool?

        @inlinable
        public init(includeChildDomainUnits: Bool? = nil) {
            self.includeChildDomainUnits = includeChildDomainUnits
        }

        private enum CodingKeys: String, CodingKey {
            case includeChildDomainUnits = "includeChildDomainUnits"
        }
    }

    public struct AllDomainUnitsGrantFilter: AWSEncodableShape & AWSDecodableShape {
        public init() {}
    }

    public struct AllUsersGrantFilter: AWSEncodableShape & AWSDecodableShape {
        public init() {}
    }

    public struct AssetFilterSummary: AWSDecodableShape {
        /// The ID of the data asset.
        public let assetId: String
        /// The timestamp at which the asset filter was created.
        public let createdAt: Date?
        /// The description of the asset filter.
        public let description: String?
        /// The ID of the domain where the asset filter lives.
        public let domainId: String
        /// The effective column names of the asset filter.
        public let effectiveColumnNames: [String]?
        /// The effective row filter of the asset filter.
        public let effectiveRowFilter: String?
        /// The error message that is displayed if the action does not succeed.
        public let errorMessage: String?
        /// The ID of the asset filter.
        public let id: String
        /// The name of the asset filter.
        public let name: String
        /// The status of the asset filter.
        public let status: FilterStatus?

        @inlinable
        public init(assetId: String, createdAt: Date? = nil, description: String? = nil, domainId: String, effectiveColumnNames: [String]? = nil, effectiveRowFilter: String? = nil, errorMessage: String? = nil, id: String, name: String, status: FilterStatus? = nil) {
            self.assetId = assetId
            self.createdAt = createdAt
            self.description = description
            self.domainId = domainId
            self.effectiveColumnNames = effectiveColumnNames
            self.effectiveRowFilter = effectiveRowFilter
            self.errorMessage = errorMessage
            self.id = id
            self.name = name
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case assetId = "assetId"
            case createdAt = "createdAt"
            case description = "description"
            case domainId = "domainId"
            case effectiveColumnNames = "effectiveColumnNames"
            case effectiveRowFilter = "effectiveRowFilter"
            case errorMessage = "errorMessage"
            case id = "id"
            case name = "name"
            case status = "status"
        }
    }

    public struct AssetInDataProductListingItem: AWSDecodableShape {
        /// The entity ID of the listing of the asset in a data product.
        public let entityId: String?
        /// The entity revision of the listing of the asset in a data product.
        public let entityRevision: String?
        /// The entity type of the listing of the asset in a data product.
        public let entityType: String?

        @inlinable
        public init(entityId: String? = nil, entityRevision: String? = nil, entityType: String? = nil) {
            self.entityId = entityId
            self.entityRevision = entityRevision
            self.entityType = entityType
        }

        private enum CodingKeys: String, CodingKey {
            case entityId = "entityId"
            case entityRevision = "entityRevision"
            case entityType = "entityType"
        }
    }

    public struct AssetItem: AWSDecodableShape {
        /// The additional attributes of a Amazon DataZone inventory asset.
        public let additionalAttributes: AssetItemAdditionalAttributes?
        /// The timestamp of when the Amazon DataZone inventory asset was created.
        public let createdAt: Date?
        /// The Amazon DataZone user who created the inventory asset.
        public let createdBy: String?
        /// The description of an Amazon DataZone inventory asset.
        public let description: String?
        /// The identifier of the Amazon DataZone domain in which the inventory asset exists.
        public let domainId: String
        /// The external identifier of the Amazon DataZone inventory asset.
        public let externalIdentifier: String?
        /// The timestamp of when the first revision of the inventory asset was created.
        public let firstRevisionCreatedAt: Date?
        /// The Amazon DataZone user who created the first revision of the inventory asset.
        public let firstRevisionCreatedBy: String?
        /// The glossary terms attached to the Amazon DataZone inventory asset.
        public let glossaryTerms: [String]?
        /// the identifier of the Amazon DataZone inventory asset.
        public let identifier: String
        /// The name of the Amazon DataZone inventory asset.
        public let name: String
        /// The identifier of the Amazon DataZone project that owns the inventory asset.
        public let owningProjectId: String
        /// The identifier of the asset type of the specified Amazon DataZone inventory asset.
        public let typeIdentifier: String
        /// The revision of the inventory asset type.
        public let typeRevision: String

        @inlinable
        public init(additionalAttributes: AssetItemAdditionalAttributes? = nil, createdAt: Date? = nil, createdBy: String? = nil, description: String? = nil, domainId: String, externalIdentifier: String? = nil, firstRevisionCreatedAt: Date? = nil, firstRevisionCreatedBy: String? = nil, glossaryTerms: [String]? = nil, identifier: String, name: String, owningProjectId: String, typeIdentifier: String, typeRevision: String) {
            self.additionalAttributes = additionalAttributes
            self.createdAt = createdAt
            self.createdBy = createdBy
            self.description = description
            self.domainId = domainId
            self.externalIdentifier = externalIdentifier
            self.firstRevisionCreatedAt = firstRevisionCreatedAt
            self.firstRevisionCreatedBy = firstRevisionCreatedBy
            self.glossaryTerms = glossaryTerms
            self.identifier = identifier
            self.name = name
            self.owningProjectId = owningProjectId
            self.typeIdentifier = typeIdentifier
            self.typeRevision = typeRevision
        }

        private enum CodingKeys: String, CodingKey {
            case additionalAttributes = "additionalAttributes"
            case createdAt = "createdAt"
            case createdBy = "createdBy"
            case description = "description"
            case domainId = "domainId"
            case externalIdentifier = "externalIdentifier"
            case firstRevisionCreatedAt = "firstRevisionCreatedAt"
            case firstRevisionCreatedBy = "firstRevisionCreatedBy"
            case glossaryTerms = "glossaryTerms"
            case identifier = "identifier"
            case name = "name"
            case owningProjectId = "owningProjectId"
            case typeIdentifier = "typeIdentifier"
            case typeRevision = "typeRevision"
        }
    }

    public struct AssetItemAdditionalAttributes: AWSDecodableShape {
        /// The forms included in the additional attributes of an inventory asset.
        public let formsOutput: [FormOutput]?
        /// The latest time series data points forms included in the additional attributes of an asset.
        public let latestTimeSeriesDataPointFormsOutput: [TimeSeriesDataPointSummaryFormOutput]?
        /// The read-only forms included in the additional attributes of an inventory asset.
        public let readOnlyFormsOutput: [FormOutput]?

        @inlinable
        public init(formsOutput: [FormOutput]? = nil, latestTimeSeriesDataPointFormsOutput: [TimeSeriesDataPointSummaryFormOutput]? = nil, readOnlyFormsOutput: [FormOutput]? = nil) {
            self.formsOutput = formsOutput
            self.latestTimeSeriesDataPointFormsOutput = latestTimeSeriesDataPointFormsOutput
            self.readOnlyFormsOutput = readOnlyFormsOutput
        }

        private enum CodingKeys: String, CodingKey {
            case formsOutput = "formsOutput"
            case latestTimeSeriesDataPointFormsOutput = "latestTimeSeriesDataPointFormsOutput"
            case readOnlyFormsOutput = "readOnlyFormsOutput"
        }
    }

    public struct AssetListing: AWSDecodableShape {
        /// The identifier of an asset published in an Amazon DataZone catalog.
        public let assetId: String?
        /// The revision of an asset published in an Amazon DataZone catalog.
        public let assetRevision: String?
        /// The type of an asset published in an Amazon DataZone catalog.
        public let assetType: String?
        /// The timestamp of when an asset published in an Amazon DataZone catalog was created.
        public let createdAt: Date?
        /// The metadata forms attached to an asset published in an Amazon DataZone catalog.
        public let forms: String?
        /// The glossary terms attached to an asset published in an Amazon DataZone catalog.
        public let glossaryTerms: [DetailedGlossaryTerm]?
        /// The latest time series data points forms included in the additional attributes of an asset.
        public let latestTimeSeriesDataPointForms: [TimeSeriesDataPointSummaryFormOutput]?
        /// The identifier of the project where an asset published in an Amazon DataZone catalog exists.
        public let owningProjectId: String?

        @inlinable
        public init(assetId: String? = nil, assetRevision: String? = nil, assetType: String? = nil, createdAt: Date? = nil, forms: String? = nil, glossaryTerms: [DetailedGlossaryTerm]? = nil, latestTimeSeriesDataPointForms: [TimeSeriesDataPointSummaryFormOutput]? = nil, owningProjectId: String? = nil) {
            self.assetId = assetId
            self.assetRevision = assetRevision
            self.assetType = assetType
            self.createdAt = createdAt
            self.forms = forms
            self.glossaryTerms = glossaryTerms
            self.latestTimeSeriesDataPointForms = latestTimeSeriesDataPointForms
            self.owningProjectId = owningProjectId
        }

        private enum CodingKeys: String, CodingKey {
            case assetId = "assetId"
            case assetRevision = "assetRevision"
            case assetType = "assetType"
            case createdAt = "createdAt"
            case forms = "forms"
            case glossaryTerms = "glossaryTerms"
            case latestTimeSeriesDataPointForms = "latestTimeSeriesDataPointForms"
            case owningProjectId = "owningProjectId"
        }
    }

    public struct AssetListingDetails: AWSDecodableShape {
        /// The identifier of an asset published in an Amazon DataZone catalog.
        public let listingId: String
        /// The status of an asset published in an Amazon DataZone catalog.
        public let listingStatus: ListingStatus

        @inlinable
        public init(listingId: String, listingStatus: ListingStatus) {
            self.listingId = listingId
            self.listingStatus = listingStatus
        }

        private enum CodingKeys: String, CodingKey {
            case listingId = "listingId"
            case listingStatus = "listingStatus"
        }
    }

    public struct AssetListingItem: AWSDecodableShape {
        /// The additional attributes of an asset published in an Amazon DataZone catalog.
        public let additionalAttributes: AssetListingItemAdditionalAttributes?
        /// The timestamp of when an asset published in an Amazon DataZone catalog was created.
        public let createdAt: Date?
        /// The description of an asset published in an Amazon DataZone catalog.
        public let description: String?
        /// The identifier of the inventory asset.
        public let entityId: String?
        /// The revision of the inventory asset.
        public let entityRevision: String?
        /// The type of the inventory asset.
        public let entityType: String?
        /// Glossary terms attached to the inventory asset.
        public let glossaryTerms: [DetailedGlossaryTerm]?
        /// The Amazon DataZone user who created the listing.
        public let listingCreatedBy: String?
        /// The identifier of the listing (asset published in Amazon DataZone catalog).
        public let listingId: String?
        /// The revision of the listing (asset published in Amazon DataZone catalog).
        public let listingRevision: String?
        /// The Amazon DataZone user who updated the listing.
        public let listingUpdatedBy: String?
        /// The name of the inventory asset.
        public let name: String?
        /// The identifier of the project that owns the inventory asset.
        public let owningProjectId: String?

        @inlinable
        public init(additionalAttributes: AssetListingItemAdditionalAttributes? = nil, createdAt: Date? = nil, description: String? = nil, entityId: String? = nil, entityRevision: String? = nil, entityType: String? = nil, glossaryTerms: [DetailedGlossaryTerm]? = nil, listingCreatedBy: String? = nil, listingId: String? = nil, listingRevision: String? = nil, listingUpdatedBy: String? = nil, name: String? = nil, owningProjectId: String? = nil) {
            self.additionalAttributes = additionalAttributes
            self.createdAt = createdAt
            self.description = description
            self.entityId = entityId
            self.entityRevision = entityRevision
            self.entityType = entityType
            self.glossaryTerms = glossaryTerms
            self.listingCreatedBy = listingCreatedBy
            self.listingId = listingId
            self.listingRevision = listingRevision
            self.listingUpdatedBy = listingUpdatedBy
            self.name = name
            self.owningProjectId = owningProjectId
        }

        private enum CodingKeys: String, CodingKey {
            case additionalAttributes = "additionalAttributes"
            case createdAt = "createdAt"
            case description = "description"
            case entityId = "entityId"
            case entityRevision = "entityRevision"
            case entityType = "entityType"
            case glossaryTerms = "glossaryTerms"
            case listingCreatedBy = "listingCreatedBy"
            case listingId = "listingId"
            case listingRevision = "listingRevision"
            case listingUpdatedBy = "listingUpdatedBy"
            case name = "name"
            case owningProjectId = "owningProjectId"
        }
    }

    public struct AssetListingItemAdditionalAttributes: AWSDecodableShape {
        /// The metadata forms that form additional attributes of the metadata asset.
        public let forms: String?
        /// The latest time series data points forms included in the additional attributes of an asset.
        public let latestTimeSeriesDataPointForms: [TimeSeriesDataPointSummaryFormOutput]?

        @inlinable
        public init(forms: String? = nil, latestTimeSeriesDataPointForms: [TimeSeriesDataPointSummaryFormOutput]? = nil) {
            self.forms = forms
            self.latestTimeSeriesDataPointForms = latestTimeSeriesDataPointForms
        }

        private enum CodingKeys: String, CodingKey {
            case forms = "forms"
            case latestTimeSeriesDataPointForms = "latestTimeSeriesDataPointForms"
        }
    }

    public struct AssetRevision: AWSDecodableShape {
        /// The timestamp of when an inventory asset revison was created.
        public let createdAt: Date?
        /// The Amazon DataZone user who created the asset revision.
        public let createdBy: String?
        /// The Amazon DataZone user who created the inventory asset.
        public let domainId: String?
        /// The identifier of the inventory asset revision.
        public let id: String?
        /// The revision details of the inventory asset.
        public let revision: String?

        @inlinable
        public init(createdAt: Date? = nil, createdBy: String? = nil, domainId: String? = nil, id: String? = nil, revision: String? = nil) {
            self.createdAt = createdAt
            self.createdBy = createdBy
            self.domainId = domainId
            self.id = id
            self.revision = revision
        }

        private enum CodingKeys: String, CodingKey {
            case createdAt = "createdAt"
            case createdBy = "createdBy"
            case domainId = "domainId"
            case id = "id"
            case revision = "revision"
        }
    }

    public struct AssetScope: AWSDecodableShape {
        /// The asset ID of the asset scope.
        public let assetId: String
        /// The error message of the asset scope.
        public let errorMessage: String?
        /// The filter IDs of the asset scope.
        public let filterIds: [String]
        /// The status of the asset scope.
        public let status: String

        @inlinable
        public init(assetId: String, errorMessage: String? = nil, filterIds: [String], status: String) {
            self.assetId = assetId
            self.errorMessage = errorMessage
            self.filterIds = filterIds
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case assetId = "assetId"
            case errorMessage = "errorMessage"
            case filterIds = "filterIds"
            case status = "status"
        }
    }

    public struct AssetTargetNameMap: AWSEncodableShape {
        /// The identifier of the inventory asset.
        public let assetId: String
        /// The target name in the asset target name map.
        public let targetName: String

        @inlinable
        public init(assetId: String, targetName: String) {
            self.assetId = assetId
            self.targetName = targetName
        }

        public func validate(name: String) throws {
            try self.validate(self.assetId, name: "assetId", parent: name, pattern: "^[a-zA-Z0-9_-]{1,36}$")
        }

        private enum CodingKeys: String, CodingKey {
            case assetId = "assetId"
            case targetName = "targetName"
        }
    }

    public struct AssetTypeItem: AWSDecodableShape {
        /// The timestamp of when the asset type was created.
        public let createdAt: Date?
        /// The Amazon DataZone user who created the asset type.
        public let createdBy: String?
        /// The description of the asset type.
        public let description: String?
        /// The identifier of the Amazon DataZone domain where the asset type exists.
        public let domainId: String
        /// The forms included in the details of the asset type.
        public let formsOutput: [String: FormEntryOutput]
        /// The name of the asset type.
        public let name: String
        /// The identifier of the Amazon DataZone domain where the asset type was originally created.
        public let originDomainId: String?
        /// The identifier of the Amazon DataZone project where the asset type exists.
        public let originProjectId: String?
        /// The identifier of the Amazon DataZone project that owns the asset type.
        public let owningProjectId: String
        /// The revision of the asset type.
        public let revision: String
        /// The timestamp of when the asset type was updated.
        public let updatedAt: Date?
        /// The Amazon DataZone user who updated the asset type.
        public let updatedBy: String?

        @inlinable
        public init(createdAt: Date? = nil, createdBy: String? = nil, description: String? = nil, domainId: String, formsOutput: [String: FormEntryOutput], name: String, originDomainId: String? = nil, originProjectId: String? = nil, owningProjectId: String, revision: String, updatedAt: Date? = nil, updatedBy: String? = nil) {
            self.createdAt = createdAt
            self.createdBy = createdBy
            self.description = description
            self.domainId = domainId
            self.formsOutput = formsOutput
            self.name = name
            self.originDomainId = originDomainId
            self.originProjectId = originProjectId
            self.owningProjectId = owningProjectId
            self.revision = revision
            self.updatedAt = updatedAt
            self.updatedBy = updatedBy
        }

        private enum CodingKeys: String, CodingKey {
            case createdAt = "createdAt"
            case createdBy = "createdBy"
            case description = "description"
            case domainId = "domainId"
            case formsOutput = "formsOutput"
            case name = "name"
            case originDomainId = "originDomainId"
            case originProjectId = "originProjectId"
            case owningProjectId = "owningProjectId"
            case revision = "revision"
            case updatedAt = "updatedAt"
            case updatedBy = "updatedBy"
        }
    }

    public struct AssetTypesForRule: AWSEncodableShape & AWSDecodableShape {
        /// The selection mode for the rule.
        public let selectionMode: RuleScopeSelectionMode
        /// The specific asset types that are included in the rule.
        public let specificAssetTypes: [String]?

        @inlinable
        public init(selectionMode: RuleScopeSelectionMode, specificAssetTypes: [String]? = nil) {
            self.selectionMode = selectionMode
            self.specificAssetTypes = specificAssetTypes
        }

        public func validate(name: String) throws {
            try self.specificAssetTypes?.forEach {
                try validate($0, name: "specificAssetTypes[]", parent: name, max: 513)
                try validate($0, name: "specificAssetTypes[]", parent: name, min: 1)
                try validate($0, name: "specificAssetTypes[]", parent: name, pattern: "^(?!\\.)[\\w\\.]*\\w$")
            }
            try self.validate(self.specificAssetTypes, name: "specificAssetTypes", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case selectionMode = "selectionMode"
            case specificAssetTypes = "specificAssetTypes"
        }
    }

    public struct AssociateEnvironmentRoleInput: AWSEncodableShape {
        /// The ID of the Amazon DataZone domain in which the environment role is associated.
        public let domainIdentifier: String
        /// The ID of the Amazon DataZone environment.
        public let environmentIdentifier: String
        /// The ARN of the environment role.
        public let environmentRoleArn: String

        @inlinable
        public init(domainIdentifier: String, environmentIdentifier: String, environmentRoleArn: String) {
            self.domainIdentifier = domainIdentifier
            self.environmentIdentifier = environmentIdentifier
            self.environmentRoleArn = environmentRoleArn
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.domainIdentifier, key: "domainIdentifier")
            request.encodePath(self.environmentIdentifier, key: "environmentIdentifier")
            request.encodePath(self.environmentRoleArn, key: "environmentRoleArn")
        }

        public func validate(name: String) throws {
            try self.validate(self.domainIdentifier, name: "domainIdentifier", parent: name, pattern: "^dzd[-_][a-zA-Z0-9_-]{1,36}$")
            try self.validate(self.environmentIdentifier, name: "environmentIdentifier", parent: name, pattern: "^[a-zA-Z0-9_-]{1,36}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct AssociateEnvironmentRoleOutput: AWSDecodableShape {
        public init() {}
    }

    public struct AthenaPropertiesInput: AWSEncodableShape {
        /// The Amazon Athena workgroup name of a connection.
        public let workgroupName: String?

        @inlinable
        public init(workgroupName: String? = nil) {
            self.workgroupName = workgroupName
        }

        private enum CodingKeys: String, CodingKey {
            case workgroupName = "workgroupName"
        }
    }

    public struct AthenaPropertiesOutput: AWSDecodableShape {
        /// The Amazon Athena workgroup name of a connection.
        public let workgroupName: String?

        @inlinable
        public init(workgroupName: String? = nil) {
            self.workgroupName = workgroupName
        }

        private enum CodingKeys: String, CodingKey {
            case workgroupName = "workgroupName"
        }
    }

    public struct AthenaPropertiesPatch: AWSEncodableShape {
        /// The Amazon Athena workgroup name of a connection.
        public let workgroupName: String?

        @inlinable
        public init(workgroupName: String? = nil) {
            self.workgroupName = workgroupName
        }

        private enum CodingKeys: String, CodingKey {
            case workgroupName = "workgroupName"
        }
    }

    public struct AuthenticationConfiguration: AWSDecodableShape {
        /// The authentication type of a connection.
        public let authenticationType: AuthenticationType?
        /// The oAuth2 properties of a connection.
        public let oAuth2Properties: OAuth2Properties?
        /// The secret ARN of a connection.
        public let secretArn: String?

        @inlinable
        public init(authenticationType: AuthenticationType? = nil, oAuth2Properties: OAuth2Properties? = nil, secretArn: String? = nil) {
            self.authenticationType = authenticationType
            self.oAuth2Properties = oAuth2Properties
            self.secretArn = secretArn
        }

        private enum CodingKeys: String, CodingKey {
            case authenticationType = "authenticationType"
            case oAuth2Properties = "oAuth2Properties"
            case secretArn = "secretArn"
        }
    }

    public struct AuthenticationConfigurationInput: AWSEncodableShape {
        /// The authentication type of a connection.
        public let authenticationType: AuthenticationType?
        /// The basic authentication credentials of a connection.
        public let basicAuthenticationCredentials: BasicAuthenticationCredentials?
        /// The custom authentication credentials of a connection.
        public let customAuthenticationCredentials: [String: String]?
        /// The KMS key ARN of a connection.
        public let kmsKeyArn: String?
        /// The oAuth2 properties of a connection.
        public let oAuth2Properties: OAuth2Properties?
        /// The secret ARN of a connection.
        public let secretArn: String?

        @inlinable
        public init(authenticationType: AuthenticationType? = nil, basicAuthenticationCredentials: BasicAuthenticationCredentials? = nil, customAuthenticationCredentials: [String: String]? = nil, kmsKeyArn: String? = nil, oAuth2Properties: OAuth2Properties? = nil, secretArn: String? = nil) {
            self.authenticationType = authenticationType
            self.basicAuthenticationCredentials = basicAuthenticationCredentials
            self.customAuthenticationCredentials = customAuthenticationCredentials
            self.kmsKeyArn = kmsKeyArn
            self.oAuth2Properties = oAuth2Properties
            self.secretArn = secretArn
        }

        private enum CodingKeys: String, CodingKey {
            case authenticationType = "authenticationType"
            case basicAuthenticationCredentials = "basicAuthenticationCredentials"
            case customAuthenticationCredentials = "customAuthenticationCredentials"
            case kmsKeyArn = "kmsKeyArn"
            case oAuth2Properties = "oAuth2Properties"
            case secretArn = "secretArn"
        }
    }

    public struct AuthenticationConfigurationPatch: AWSEncodableShape {
        /// The basic authentication credentials of a connection.
        public let basicAuthenticationCredentials: BasicAuthenticationCredentials?
        /// The secret ARN of a connection.
        public let secretArn: String?

        @inlinable
        public init(basicAuthenticationCredentials: BasicAuthenticationCredentials? = nil, secretArn: String? = nil) {
            self.basicAuthenticationCredentials = basicAuthenticationCredentials
            self.secretArn = secretArn
        }

        private enum CodingKeys: String, CodingKey {
            case basicAuthenticationCredentials = "basicAuthenticationCredentials"
            case secretArn = "secretArn"
        }
    }

    public struct AuthorizationCodeProperties: AWSEncodableShape & AWSDecodableShape {
        /// The authorization code of a connection.
        public let authorizationCode: String?
        /// The redirect URI of a connection.
        public let redirectUri: String?

        @inlinable
        public init(authorizationCode: String? = nil, redirectUri: String? = nil) {
            self.authorizationCode = authorizationCode
            self.redirectUri = redirectUri
        }

        private enum CodingKeys: String, CodingKey {
            case authorizationCode = "authorizationCode"
            case redirectUri = "redirectUri"
        }
    }

    public struct AwsConsoleLinkParameters: AWSEncodableShape & AWSDecodableShape {
        /// The URI of the console link specified as part of the environment action.
        public let uri: String?

        @inlinable
        public init(uri: String? = nil) {
            self.uri = uri
        }

        private enum CodingKeys: String, CodingKey {
            case uri = "uri"
        }
    }

    public struct AwsLocation: AWSEncodableShape & AWSDecodableShape {
        /// The access role of a connection.
        public let accessRole: String?
        /// The account ID of a connection.
        public let awsAccountId: String?
        /// The Region of a connection.
        public let awsRegion: String?
        /// The IAM connection ID of a connection.
        public let iamConnectionId: String?

        @inlinable
        public init(accessRole: String? = nil, awsAccountId: String? = nil, awsRegion: String? = nil, iamConnectionId: String? = nil) {
            self.accessRole = accessRole
            self.awsAccountId = awsAccountId
            self.awsRegion = awsRegion
            self.iamConnectionId = iamConnectionId
        }

        public func validate(name: String) throws {
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, pattern: "^\\d{12}$")
            try self.validate(self.awsRegion, name: "awsRegion", parent: name, pattern: "^[a-z]{2}-[a-z]{4,10}-\\d$")
            try self.validate(self.iamConnectionId, name: "iamConnectionId", parent: name, max: 128)
        }

        private enum CodingKeys: String, CodingKey {
            case accessRole = "accessRole"
            case awsAccountId = "awsAccountId"
            case awsRegion = "awsRegion"
            case iamConnectionId = "iamConnectionId"
        }
    }

    public struct BasicAuthenticationCredentials: AWSEncodableShape {
        /// The password for a connection.
        public let password: String?
        /// The user name for the connecion.
        public let userName: String?

        @inlinable
        public init(password: String? = nil, userName: String? = nil) {
            self.password = password
            self.userName = userName
        }

        private enum CodingKeys: String, CodingKey {
            case password = "password"
            case userName = "userName"
        }
    }

    public struct BusinessNameGenerationConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// Specifies whether the business name generation is enabled.
        public let enabled: Bool?

        @inlinable
        public init(enabled: Bool? = nil) {
            self.enabled = enabled
        }

        private enum CodingKeys: String, CodingKey {
            case enabled = "enabled"
        }
    }

    public struct CancelMetadataGenerationRunInput: AWSEncodableShape {
        /// The ID of the Amazon DataZone domain in which the metadata generation run is to be cancelled.
        public let domainIdentifier: String
        /// The ID of the metadata generation run.
        public let identifier: String

        @inlinable
        public init(domainIdentifier: String, identifier: String) {
            self.domainIdentifier = domainIdentifier
            self.identifier = identifier
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.domainIdentifier, key: "domainIdentifier")
            request.encodePath(self.identifier, key: "identifier")
        }

        public func validate(name: String) throws {
            try self.validate(self.domainIdentifier, name: "domainIdentifier", parent: name, pattern: "^dzd[-_][a-zA-Z0-9_-]{1,36}$")
            try self.validate(self.identifier, name: "identifier", parent: name, pattern: "^[a-zA-Z0-9_-]{1,36}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct CancelMetadataGenerationRunOutput: AWSDecodableShape {
        public init() {}
    }

    public struct CancelSubscriptionInput: AWSEncodableShape {
        /// The unique identifier of the Amazon DataZone domain where the subscription request is being cancelled.
        public let domainIdentifier: String
        /// The unique identifier of the subscription that is being cancelled.
        public let identifier: String

        @inlinable
        public init(domainIdentifier: String, identifier: String) {
            self.domainIdentifier = domainIdentifier
            self.identifier = identifier
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.domainIdentifier, key: "domainIdentifier")
            request.encodePath(self.identifier, key: "identifier")
        }

        public func validate(name: String) throws {
            try self.validate(self.domainIdentifier, name: "domainIdentifier", parent: name, pattern: "^dzd[-_][a-zA-Z0-9_-]{1,36}$")
            try self.validate(self.identifier, name: "identifier", parent: name, pattern: "^[a-zA-Z0-9_-]{1,36}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct CancelSubscriptionOutput: AWSDecodableShape {
        /// The timestamp that specifies when the request to cancel the subscription was created.
        public let createdAt: Date
        /// Specifies the Amazon DataZone user who is cancelling the subscription.
        public let createdBy: String
        /// The unique identifier of the Amazon DataZone domain where the subscription is being cancelled.
        public let domainId: String
        /// The identifier of the subscription.
        public let id: String
        /// Specifies whether the permissions to the asset are retained after the subscription is cancelled.
        public let retainPermissions: Bool?
        /// The status of the request to cancel the subscription.
        public let status: SubscriptionStatus
        /// The asset to which a subscription is being cancelled.
        public let subscribedListing: SubscribedListing
        /// The Amazon DataZone user who is made a subscriber to the specified asset by the subscription that is being cancelled.
        public let subscribedPrincipal: SubscribedPrincipal
        /// The unique ID of the subscripton request for the subscription that is being cancelled.
        public let subscriptionRequestId: String?
        /// The timestamp that specifies when the subscription was cancelled.
        public let updatedAt: Date
        /// The Amazon DataZone user that cancelled the subscription.
        public let updatedBy: String?

        @inlinable
        public init(createdAt: Date, createdBy: String, domainId: String, id: String, retainPermissions: Bool? = nil, status: SubscriptionStatus, subscribedListing: SubscribedListing, subscribedPrincipal: SubscribedPrincipal, subscriptionRequestId: String? = nil, updatedAt: Date, updatedBy: String? = nil) {
            self.createdAt = createdAt
            self.createdBy = createdBy
            self.domainId = domainId
            self.id = id
            self.retainPermissions = retainPermissions
            self.status = status
            self.subscribedListing = subscribedListing
            self.subscribedPrincipal = subscribedPrincipal
            self.subscriptionRequestId = subscriptionRequestId
            self.updatedAt = updatedAt
            self.updatedBy = updatedBy
        }

        private enum CodingKeys: String, CodingKey {
            case createdAt = "createdAt"
            case createdBy = "createdBy"
            case domainId = "domainId"
            case id = "id"
            case retainPermissions = "retainPermissions"
            case status = "status"
            case subscribedListing = "subscribedListing"
            case subscribedPrincipal = "subscribedPrincipal"
            case subscriptionRequestId = "subscriptionRequestId"
            case updatedAt = "updatedAt"
            case updatedBy = "updatedBy"
        }
    }

    public struct CloudFormationProperties: AWSDecodableShape {
        /// The template URL of the cloud formation provisioning properties of the environment blueprint.
        public let templateUrl: String

        @inlinable
        public init(templateUrl: String) {
            self.templateUrl = templateUrl
        }

        private enum CodingKeys: String, CodingKey {
            case templateUrl = "templateUrl"
        }
    }

    public struct ColumnFilterConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// Specifies whether to include column names.
        public let includedColumnNames: [String]?

        @inlinable
        public init(includedColumnNames: [String]? = nil) {
            self.includedColumnNames = includedColumnNames
        }

        private enum CodingKeys: String, CodingKey {
            case includedColumnNames = "includedColumnNames"
        }
    }

    public struct ConfigurableActionParameter: AWSDecodableShape {
        /// The key of the configurable action parameter.
        public let key: String?
        /// The value of the configurable action parameter.
        public let value: String?

        @inlinable
        public init(key: String? = nil, value: String? = nil) {
            self.key = key
            self.value = value
        }

        private enum CodingKeys: String, CodingKey {
            case key = "key"
            case value = "value"
        }
    }

    public struct ConfigurableEnvironmentAction: AWSDecodableShape {
        /// The authentication type of a configurable action of a Amazon DataZone environment.
        public let auth: ConfigurableActionTypeAuthorization?
        /// The parameters of a configurable action in a Amazon DataZone environment.
        public let parameters: [ConfigurableActionParameter]
        /// The type of a configurable action in a Amazon DataZone environment.
        public let type: String

        @inlinable
        public init(auth: ConfigurableActionTypeAuthorization? = nil, parameters: [ConfigurableActionParameter], type: String) {
            self.auth = auth
            self.parameters = parameters
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case auth = "auth"
            case parameters = "parameters"
            case type = "type"
        }
    }

    public struct ConnectionCredentials: AWSDecodableShape {
        /// The access key ID of a connection.
        public let accessKeyId: String?
        /// The expiration of the connection credentials.
        public let expiration: Date?
        /// The secret access key of a connection.
        public let secretAccessKey: String?
        /// The session token of a connection credentials.
        public let sessionToken: String?

        @inlinable
        public init(accessKeyId: String? = nil, expiration: Date? = nil, secretAccessKey: String? = nil, sessionToken: String? = nil) {
            self.accessKeyId = accessKeyId
            self.expiration = expiration
            self.secretAccessKey = secretAccessKey
            self.sessionToken = sessionToken
        }

        private enum CodingKeys: String, CodingKey {
            case accessKeyId = "accessKeyId"
            case expiration = "expiration"
            case secretAccessKey = "secretAccessKey"
            case sessionToken = "sessionToken"
        }
    }

    public struct ConnectionSummary: AWSDecodableShape {
        /// The ID of a connection.
        public let connectionId: String
        /// The domain ID of a connection.
        public let domainId: String
        /// The domain unit ID of a connection.
        public let domainUnitId: String
        /// The environment ID of a connection.
        public let environmentId: String?
        /// The connection name.
        public let name: String
        /// The connection physical endpoints.
        public let physicalEndpoints: [PhysicalEndpoint]
        /// The connection project ID.
        public let projectId: String?
        /// The connection props.
        public let props: ConnectionPropertiesOutput?
        /// The connection type.
        public let type: ConnectionType

        @inlinable
        public init(connectionId: String, domainId: String, domainUnitId: String, environmentId: String? = nil, name: String, physicalEndpoints: [PhysicalEndpoint], projectId: String? = nil, props: ConnectionPropertiesOutput? = nil, type: ConnectionType) {
            self.connectionId = connectionId
            self.domainId = domainId
            self.domainUnitId = domainUnitId
            self.environmentId = environmentId
            self.name = name
            self.physicalEndpoints = physicalEndpoints
            self.projectId = projectId
            self.props = props
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case connectionId = "connectionId"
            case domainId = "domainId"
            case domainUnitId = "domainUnitId"
            case environmentId = "environmentId"
            case name = "name"
            case physicalEndpoints = "physicalEndpoints"
            case projectId = "projectId"
            case props = "props"
            case type = "type"
        }
    }

    public struct CreateAssetFilterInput: AWSEncodableShape {
        /// The ID of the data asset.
        public let assetIdentifier: String
        /// A unique, case-sensitive identifier that is provided to ensure the idempotency of the request.
        public let clientToken: String?
        /// The configuration of the asset filter.
        public let configuration: AssetFilterConfiguration
        /// The description of the asset filter.
        public let description: String?
        /// The ID of the domain in which you want to create an asset filter.
        public let domainIdentifier: String
        /// The name of the asset filter.
        public let name: String

        @inlinable
        public init(assetIdentifier: String, clientToken: String? = CreateAssetFilterInput.idempotencyToken(), configuration: AssetFilterConfiguration, description: String? = nil, domainIdentifier: String, name: String) {
            self.assetIdentifier = assetIdentifier
            self.clientToken = clientToken
            self.configuration = configuration
            self.description = description
            self.domainIdentifier = domainIdentifier
            self.name = name
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.assetIdentifier, key: "assetIdentifier")
            try container.encodeIfPresent(self.clientToken, forKey: .clientToken)
            try container.encode(self.configuration, forKey: .configuration)
            try container.encodeIfPresent(self.description, forKey: .description)
            request.encodePath(self.domainIdentifier, key: "domainIdentifier")
            try container.encode(self.name, forKey: .name)
        }

        public func validate(name: String) throws {
            try self.validate(self.assetIdentifier, name: "assetIdentifier", parent: name, pattern: "^[a-zA-Z0-9_-]{1,36}$")
            try self.validate(self.description, name: "description", parent: name, max: 2048)
            try self.validate(self.domainIdentifier, name: "domainIdentifier", parent: name, pattern: "^dzd[-_][a-zA-Z0-9_-]{1,36}$")
            try self.validate(self.name, name: "name", parent: name, max: 64)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[\\w -]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "clientToken"
            case configuration = "configuration"
            case description = "description"
            case name = "name"
        }
    }

    public struct CreateAssetFilterOutput: AWSDecodableShape {
        /// The ID of the asset.
        public let assetId: String
        /// The configuration of the asset filter.
        public let configuration: AssetFilterConfiguration
        /// The timestamp at which the asset filter was created.
        public let createdAt: Date?
        /// The description of the asset filter.
        public let description: String?
        /// The ID of the domain where the asset filter is created.
        public let domainId: String
        /// The column names in the asset filter.
        public let effectiveColumnNames: [String]?
        /// The row filter in the asset filter.
        public let effectiveRowFilter: String?
        /// The error message that is displayed if the asset filter is not created successfully.
        public let errorMessage: String?
        /// The ID of the asset filter.
        public let id: String
        /// The name of the asset filter.
        public let name: String
        /// The status of the asset filter.
        public let status: FilterStatus?

        @inlinable
        public init(assetId: String, configuration: AssetFilterConfiguration, createdAt: Date? = nil, description: String? = nil, domainId: String, effectiveColumnNames: [String]? = nil, effectiveRowFilter: String? = nil, errorMessage: String? = nil, id: String, name: String, status: FilterStatus? = nil) {
            self.assetId = assetId
            self.configuration = configuration
            self.createdAt = createdAt
            self.description = description
            self.domainId = domainId
            self.effectiveColumnNames = effectiveColumnNames
            self.effectiveRowFilter = effectiveRowFilter
            self.errorMessage = errorMessage
            self.id = id
            self.name = name
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case assetId = "assetId"
            case configuration = "configuration"
            case createdAt = "createdAt"
            case description = "description"
            case domainId = "domainId"
            case effectiveColumnNames = "effectiveColumnNames"
            case effectiveRowFilter = "effectiveRowFilter"
            case errorMessage = "errorMessage"
            case id = "id"
            case name = "name"
            case status = "status"
        }
    }

    public struct CreateAssetInput: AWSEncodableShape {
        /// A unique, case-sensitive identifier that is provided to ensure the idempotency of the request.
        public let clientToken: String?
        /// Asset description.
        public let description: String?
        /// Amazon DataZone domain where the asset is created.
        public let domainIdentifier: String
        /// The external identifier of the asset.
        public let externalIdentifier: String?
        /// Metadata forms attached to the asset.
        public let formsInput: [FormInput]?
        /// Glossary terms attached to the asset.
        public let glossaryTerms: [String]?
        /// Asset name.
        public let name: String
        /// The unique identifier of the project that owns this asset.
        public let owningProjectIdentifier: String
        /// The configuration of the automatically generated business-friendly metadata for the asset.
        public let predictionConfiguration: PredictionConfiguration?
        /// The unique identifier of this asset's type.
        public let typeIdentifier: String
        /// The revision of this asset's type.
        public let typeRevision: String?

        @inlinable
        public init(clientToken: String? = CreateAssetInput.idempotencyToken(), description: String? = nil, domainIdentifier: String, externalIdentifier: String? = nil, formsInput: [FormInput]? = nil, glossaryTerms: [String]? = nil, name: String, owningProjectIdentifier: String, predictionConfiguration: PredictionConfiguration? = nil, typeIdentifier: String, typeRevision: String? = nil) {
            self.clientToken = clientToken
            self.description = description
            self.domainIdentifier = domainIdentifier
            self.externalIdentifier = externalIdentifier
            self.formsInput = formsInput
            self.glossaryTerms = glossaryTerms
            self.name = name
            self.owningProjectIdentifier = owningProjectIdentifier
            self.predictionConfiguration = predictionConfiguration
            self.typeIdentifier = typeIdentifier
            self.typeRevision = typeRevision
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.clientToken, forKey: .clientToken)
            try container.encodeIfPresent(self.description, forKey: .description)
            request.encodePath(self.domainIdentifier, key: "domainIdentifier")
            try container.encodeIfPresent(self.externalIdentifier, forKey: .externalIdentifier)
            try container.encodeIfPresent(self.formsInput, forKey: .formsInput)
            try container.encodeIfPresent(self.glossaryTerms, forKey: .glossaryTerms)
            try container.encode(self.name, forKey: .name)
            try container.encode(self.owningProjectIdentifier, forKey: .owningProjectIdentifier)
            try container.encodeIfPresent(self.predictionConfiguration, forKey: .predictionConfiguration)
            try container.encode(self.typeIdentifier, forKey: .typeIdentifier)
            try container.encodeIfPresent(self.typeRevision, forKey: .typeRevision)
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 128)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "^[\\x21-\\x7E]+$")
            try self.validate(self.description, name: "description", parent: name, max: 2048)
            try self.validate(self.domainIdentifier, name: "domainIdentifier", parent: name, pattern: "^dzd[-_][a-zA-Z0-9_-]{1,36}$")
            try self.validate(self.externalIdentifier, name: "externalIdentifier", parent: name, max: 600)
            try self.validate(self.externalIdentifier, name: "externalIdentifier", parent: name, min: 1)
            try self.formsInput?.forEach {
                try $0.validate(name: "\(name).formsInput[]")
            }
            try self.validate(self.formsInput, name: "formsInput", parent: name, max: 10)
            try self.glossaryTerms?.forEach {
                try validate($0, name: "glossaryTerms[]", parent: name, pattern: "^[a-zA-Z0-9_-]{1,36}$")
            }
            try self.validate(self.glossaryTerms, name: "glossaryTerms", parent: name, max: 20)
            try self.validate(self.glossaryTerms, name: "glossaryTerms", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, max: 256)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.owningProjectIdentifier, name: "owningProjectIdentifier", parent: name, pattern: "^[a-zA-Z0-9_-]{1,36}$")
            try self.validate(self.typeIdentifier, name: "typeIdentifier", parent: name, max: 513)
            try self.validate(self.typeIdentifier, name: "typeIdentifier", parent: name, min: 1)
            try self.validate(self.typeIdentifier, name: "typeIdentifier", parent: name, pattern: "^(?!\\.)[\\w\\.]*\\w$")
            try self.validate(self.typeRevision, name: "typeRevision", parent: name, max: 64)
            try self.validate(self.typeRevision, name: "typeRevision", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "clientToken"
            case description = "description"
            case externalIdentifier = "externalIdentifier"
            case formsInput = "formsInput"
            case glossaryTerms = "glossaryTerms"
            case name = "name"
            case owningProjectIdentifier = "owningProjectIdentifier"
            case predictionConfiguration = "predictionConfiguration"
            case typeIdentifier = "typeIdentifier"
            case typeRevision = "typeRevision"
        }
    }

    public struct CreateAssetOutput: AWSDecodableShape {
        /// The timestamp of when the asset was created.
        public let createdAt: Date?
        /// The Amazon DataZone user that created this asset in the catalog.
        public let createdBy: String?
        /// The description of the created asset.
        public let description: String?
        /// The ID of the Amazon DataZone domain in which the asset was created.
        public let domainId: String
        /// The external identifier of the asset.
        public let externalIdentifier: String?
        /// The timestamp of when the first revision of the asset took place.
        public let firstRevisionCreatedAt: Date?
        /// The Amazon DataZone user that made the first revision of the asset.
        public let firstRevisionCreatedBy: String?
        /// The metadata forms that are attached to the created asset.
        public let formsOutput: [FormOutput]
        /// The glossary terms that are attached to the created asset.
        public let glossaryTerms: [String]?
        /// The unique identifier of the created asset.
        public let id: String
        /// The latest data point that was imported into the time series form for the asset.
        public let latestTimeSeriesDataPointFormsOutput: [TimeSeriesDataPointSummaryFormOutput]?
        /// The details of an asset published in an Amazon DataZone catalog.
        public let listing: AssetListingDetails?
        /// The name of the created asset.
        public let name: String
        /// The ID of the Amazon DataZone project that owns the created asset.
        public let owningProjectId: String
        /// The configuration of the automatically generated business-friendly metadata for the asset.
        public let predictionConfiguration: PredictionConfiguration?
        /// The read-only metadata forms that are attached to the created asset.
        public let readOnlyFormsOutput: [FormOutput]?
        /// The revision of the asset.
        public let revision: String
        /// The identifier of the created asset type.
        public let typeIdentifier: String
        /// The revision type of the asset.
        public let typeRevision: String

        @inlinable
        public init(createdAt: Date? = nil, createdBy: String? = nil, description: String? = nil, domainId: String, externalIdentifier: String? = nil, firstRevisionCreatedAt: Date? = nil, firstRevisionCreatedBy: String? = nil, formsOutput: [FormOutput], glossaryTerms: [String]? = nil, id: String, latestTimeSeriesDataPointFormsOutput: [TimeSeriesDataPointSummaryFormOutput]? = nil, listing: AssetListingDetails? = nil, name: String, owningProjectId: String, predictionConfiguration: PredictionConfiguration? = nil, readOnlyFormsOutput: [FormOutput]? = nil, revision: String, typeIdentifier: String, typeRevision: String) {
            self.createdAt = createdAt
            self.createdBy = createdBy
            self.description = description
            self.domainId = domainId
            self.externalIdentifier = externalIdentifier
            self.firstRevisionCreatedAt = firstRevisionCreatedAt
            self.firstRevisionCreatedBy = firstRevisionCreatedBy
            self.formsOutput = formsOutput
            self.glossaryTerms = glossaryTerms
            self.id = id
            self.latestTimeSeriesDataPointFormsOutput = latestTimeSeriesDataPointFormsOutput
            self.listing = listing
            self.name = name
            self.owningProjectId = owningProjectId
            self.predictionConfiguration = predictionConfiguration
            self.readOnlyFormsOutput = readOnlyFormsOutput
            self.revision = revision
            self.typeIdentifier = typeIdentifier
            self.typeRevision = typeRevision
        }

        private enum CodingKeys: String, CodingKey {
            case createdAt = "createdAt"
            case createdBy = "createdBy"
            case description = "description"
            case domainId = "domainId"
            case externalIdentifier = "externalIdentifier"
            case firstRevisionCreatedAt = "firstRevisionCreatedAt"
            case firstRevisionCreatedBy = "firstRevisionCreatedBy"
            case formsOutput = "formsOutput"
            case glossaryTerms = "glossaryTerms"
            case id = "id"
            case latestTimeSeriesDataPointFormsOutput = "latestTimeSeriesDataPointFormsOutput"
            case listing = "listing"
            case name = "name"
            case owningProjectId = "owningProjectId"
            case predictionConfiguration = "predictionConfiguration"
            case readOnlyFormsOutput = "readOnlyFormsOutput"
            case revision = "revision"
            case typeIdentifier = "typeIdentifier"
            case typeRevision = "typeRevision"
        }
    }

    public struct CreateAssetRevisionInput: AWSEncodableShape {
        /// A unique, case-sensitive identifier that is provided to ensure the idempotency of the request.
        public let clientToken: String?
        /// The revised description of the asset.
        public let description: String?
        /// The unique identifier of the domain where the asset is being revised.
        public let domainIdentifier: String
        /// The metadata forms to be attached to the asset as part of asset revision.
        public let formsInput: [FormInput]?
        /// The glossary terms to be attached to the asset as part of asset revision.
        public let glossaryTerms: [String]?
        /// The identifier of the asset.
        public let identifier: String
        /// Te revised name of the asset.
        public let name: String
        /// The configuration of the automatically generated business-friendly metadata for the asset.
        public let predictionConfiguration: PredictionConfiguration?
        /// The revision type of the asset.
        public let typeRevision: String?

        @inlinable
        public init(clientToken: String? = CreateAssetRevisionInput.idempotencyToken(), description: String? = nil, domainIdentifier: String, formsInput: [FormInput]? = nil, glossaryTerms: [String]? = nil, identifier: String, name: String, predictionConfiguration: PredictionConfiguration? = nil, typeRevision: String? = nil) {
            self.clientToken = clientToken
            self.description = description
            self.domainIdentifier = domainIdentifier
            self.formsInput = formsInput
            self.glossaryTerms = glossaryTerms
            self.identifier = identifier
            self.name = name
            self.predictionConfiguration = predictionConfiguration
            self.typeRevision = typeRevision
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.clientToken, forKey: .clientToken)
            try container.encodeIfPresent(self.description, forKey: .description)
            request.encodePath(self.domainIdentifier, key: "domainIdentifier")
            try container.encodeIfPresent(self.formsInput, forKey: .formsInput)
            try container.encodeIfPresent(self.glossaryTerms, forKey: .glossaryTerms)
            request.encodePath(self.identifier, key: "identifier")
            try container.encode(self.name, forKey: .name)
            try container.encodeIfPresent(self.predictionConfiguration, forKey: .predictionConfiguration)
            try container.encodeIfPresent(self.typeRevision, forKey: .typeRevision)
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 128)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "^[\\x21-\\x7E]+$")
            try self.validate(self.description, name: "description", parent: name, max: 2048)
            try self.validate(self.domainIdentifier, name: "domainIdentifier", parent: name, pattern: "^dzd[-_][a-zA-Z0-9_-]{1,36}$")
            try self.formsInput?.forEach {
                try $0.validate(name: "\(name).formsInput[]")
            }
            try self.validate(self.formsInput, name: "formsInput", parent: name, max: 10)
            try self.glossaryTerms?.forEach {
                try validate($0, name: "glossaryTerms[]", parent: name, pattern: "^[a-zA-Z0-9_-]{1,36}$")
            }
            try self.validate(self.glossaryTerms, name: "glossaryTerms", parent: name, max: 20)
            try self.validate(self.glossaryTerms, name: "glossaryTerms", parent: name, min: 1)
            try self.validate(self.identifier, name: "identifier", parent: name, pattern: "^[a-zA-Z0-9_-]{1,36}$")
            try self.validate(self.name, name: "name", parent: name, max: 256)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.typeRevision, name: "typeRevision", parent: name, max: 64)
            try self.validate(self.typeRevision, name: "typeRevision", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "clientToken"
            case description = "description"
            case formsInput = "formsInput"
            case glossaryTerms = "glossaryTerms"
            case name = "name"
            case predictionConfiguration = "predictionConfiguration"
            case typeRevision = "typeRevision"
        }
    }

    public struct CreateAssetRevisionOutput: AWSDecodableShape {
        /// The timestamp of when the asset revision occured.
        public let createdAt: Date?
        /// The Amazon DataZone user who performed the asset revision.
        public let createdBy: String?
        /// The revised asset description.
        public let description: String?
        /// The unique identifier of the Amazon DataZone domain where the asset was revised.
        public let domainId: String
        /// The external identifier of the asset.
        public let externalIdentifier: String?
        /// The timestamp of when the first asset revision occured.
        public let firstRevisionCreatedAt: Date?
        /// The Amazon DataZone user who performed the first asset revision.
        public let firstRevisionCreatedBy: String?
        /// The metadata forms that were attached to the asset as part of the asset revision.
        public let formsOutput: [FormOutput]
        /// The glossary terms that were attached to the asset as part of asset revision.
        public let glossaryTerms: [String]?
        /// The unique identifier of the asset revision.
        public let id: String
        /// The latest data point that was imported into the time series form for the asset.
        public let latestTimeSeriesDataPointFormsOutput: [TimeSeriesDataPointSummaryFormOutput]?
        /// The details of an asset published in an Amazon DataZone catalog.
        public let listing: AssetListingDetails?
        /// The revised name of the asset.
        public let name: String
        /// The unique identifier of the revised project that owns the asset.
        public let owningProjectId: String
        /// The configuration of the automatically generated business-friendly metadata for the asset.
        public let predictionConfiguration: PredictionConfiguration?
        /// The read-only metadata forms that were attached to the asset as part of the asset revision.
        public let readOnlyFormsOutput: [FormOutput]?
        /// The revision of the asset.
        public let revision: String
        /// The identifier of the revision type.
        public let typeIdentifier: String
        /// The revision type of the asset.
        public let typeRevision: String

        @inlinable
        public init(createdAt: Date? = nil, createdBy: String? = nil, description: String? = nil, domainId: String, externalIdentifier: String? = nil, firstRevisionCreatedAt: Date? = nil, firstRevisionCreatedBy: String? = nil, formsOutput: [FormOutput], glossaryTerms: [String]? = nil, id: String, latestTimeSeriesDataPointFormsOutput: [TimeSeriesDataPointSummaryFormOutput]? = nil, listing: AssetListingDetails? = nil, name: String, owningProjectId: String, predictionConfiguration: PredictionConfiguration? = nil, readOnlyFormsOutput: [FormOutput]? = nil, revision: String, typeIdentifier: String, typeRevision: String) {
            self.createdAt = createdAt
            self.createdBy = createdBy
            self.description = description
            self.domainId = domainId
            self.externalIdentifier = externalIdentifier
            self.firstRevisionCreatedAt = firstRevisionCreatedAt
            self.firstRevisionCreatedBy = firstRevisionCreatedBy
            self.formsOutput = formsOutput
            self.glossaryTerms = glossaryTerms
            self.id = id
            self.latestTimeSeriesDataPointFormsOutput = latestTimeSeriesDataPointFormsOutput
            self.listing = listing
            self.name = name
            self.owningProjectId = owningProjectId
            self.predictionConfiguration = predictionConfiguration
            self.readOnlyFormsOutput = readOnlyFormsOutput
            self.revision = revision
            self.typeIdentifier = typeIdentifier
            self.typeRevision = typeRevision
        }

        private enum CodingKeys: String, CodingKey {
            case createdAt = "createdAt"
            case createdBy = "createdBy"
            case description = "description"
            case domainId = "domainId"
            case externalIdentifier = "externalIdentifier"
            case firstRevisionCreatedAt = "firstRevisionCreatedAt"
            case firstRevisionCreatedBy = "firstRevisionCreatedBy"
            case formsOutput = "formsOutput"
            case glossaryTerms = "glossaryTerms"
            case id = "id"
            case latestTimeSeriesDataPointFormsOutput = "latestTimeSeriesDataPointFormsOutput"
            case listing = "listing"
            case name = "name"
            case owningProjectId = "owningProjectId"
            case predictionConfiguration = "predictionConfiguration"
            case readOnlyFormsOutput = "readOnlyFormsOutput"
            case revision = "revision"
            case typeIdentifier = "typeIdentifier"
            case typeRevision = "typeRevision"
        }
    }

    public struct CreateAssetTypeInput: AWSEncodableShape {
        /// The descripton of the custom asset type.
        public let description: String?
        /// The unique identifier of the Amazon DataZone domain where the custom asset type is being created.
        public let domainIdentifier: String
        /// The metadata forms that are to be attached to the custom asset type.
        public let formsInput: [String: FormEntryInput]
        /// The name of the custom asset type.
        public let name: String
        /// The identifier of the Amazon DataZone project that is to own the custom asset type.
        public let owningProjectIdentifier: String

        @inlinable
        public init(description: String? = nil, domainIdentifier: String, formsInput: [String: FormEntryInput], name: String, owningProjectIdentifier: String) {
            self.description = description
            self.domainIdentifier = domainIdentifier
            self.formsInput = formsInput
            self.name = name
            self.owningProjectIdentifier = owningProjectIdentifier
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.description, forKey: .description)
            request.encodePath(self.domainIdentifier, key: "domainIdentifier")
            try container.encode(self.formsInput, forKey: .formsInput)
            try container.encode(self.name, forKey: .name)
            try container.encode(self.owningProjectIdentifier, forKey: .owningProjectIdentifier)
        }

        public func validate(name: String) throws {
            try self.validate(self.description, name: "description", parent: name, max: 2048)
            try self.validate(self.domainIdentifier, name: "domainIdentifier", parent: name, pattern: "^dzd[-_][a-zA-Z0-9_-]{1,36}$")
            try self.formsInput.forEach {
                try validate($0.key, name: "formsInput.key", parent: name, max: 128)
                try validate($0.key, name: "formsInput.key", parent: name, min: 1)
                try validate($0.key, name: "formsInput.key", parent: name, pattern: "^(?![0-9_])\\w+$|^_\\w*[a-zA-Z0-9]\\w*$")
                try $0.value.validate(name: "\(name).formsInput[\"\($0.key)\"]")
            }
            try self.validate(self.formsInput, name: "formsInput", parent: name, max: 10)
            try self.validate(self.name, name: "name", parent: name, max: 256)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[^\\.]*")
            try self.validate(self.owningProjectIdentifier, name: "owningProjectIdentifier", parent: name, pattern: "^[a-zA-Z0-9_-]{1,36}$")
        }

        private enum CodingKeys: String, CodingKey {
            case description = "description"
            case formsInput = "formsInput"
            case name = "name"
            case owningProjectIdentifier = "owningProjectIdentifier"
        }
    }

    public struct CreateAssetTypeOutput: AWSDecodableShape {
        /// The timestamp of when the asset type is to be created.
        public let createdAt: Date?
        /// The Amazon DataZone user who creates this custom asset type.
        public let createdBy: String?
        /// The description of the custom asset type.
        public let description: String?
        /// The ID of the Amazon DataZone domain in which the asset type was created.
        public let domainId: String
        /// The metadata forms that are attached to the asset type.
        public let formsOutput: [String: FormEntryOutput]
        /// The name of the asset type.
        public let name: String
        /// The ID of the Amazon DataZone domain where the asset type was originally created.
        public let originDomainId: String?
        /// The ID of the Amazon DataZone project where the asset type was originally created.
        public let originProjectId: String?
        /// The ID of the Amazon DataZone project that currently owns this asset type.
        public let owningProjectId: String?
        /// The revision of the custom asset type.
        public let revision: String
        /// The timestamp of when the custom type was created.
        public let updatedAt: Date?
        /// The Amazon DataZone user that created the custom asset type.
        public let updatedBy: String?

        @inlinable
        public init(createdAt: Date? = nil, createdBy: String? = nil, description: String? = nil, domainId: String, formsOutput: [String: FormEntryOutput], name: String, originDomainId: String? = nil, originProjectId: String? = nil, owningProjectId: String? = nil, revision: String, updatedAt: Date? = nil, updatedBy: String? = nil) {
            self.createdAt = createdAt
            self.createdBy = createdBy
            self.description = description
            self.domainId = domainId
            self.formsOutput = formsOutput
            self.name = name
            self.originDomainId = originDomainId
            self.originProjectId = originProjectId
            self.owningProjectId = owningProjectId
            self.revision = revision
            self.updatedAt = updatedAt
            self.updatedBy = updatedBy
        }

        private enum CodingKeys: String, CodingKey {
            case createdAt = "createdAt"
            case createdBy = "createdBy"
            case description = "description"
            case domainId = "domainId"
            case formsOutput = "formsOutput"
            case name = "name"
            case originDomainId = "originDomainId"
            case originProjectId = "originProjectId"
            case owningProjectId = "owningProjectId"
            case revision = "revision"
            case updatedAt = "updatedAt"
            case updatedBy = "updatedBy"
        }
    }

    public struct CreateAssetTypePolicyGrantDetail: AWSEncodableShape & AWSDecodableShape {
        /// Specifies whether the policy grant is applied to child domain units.
        public let includeChildDomainUnits: Bool?

        @inlinable
        public init(includeChildDomainUnits: Bool? = nil) {
            self.includeChildDomainUnits = includeChildDomainUnits
        }

        private enum CodingKeys: String, CodingKey {
            case includeChildDomainUnits = "includeChildDomainUnits"
        }
    }

    public struct CreateConnectionInput: AWSEncodableShape {
        /// The location where the connection is created.
        public let awsLocation: AwsLocation?
        /// A unique, case-sensitive identifier that is provided to ensure the idempotency of the request.
        public let clientToken: String?
        /// A connection description.
        public let description: String?
        /// The ID of the domain where the connection is created.
        public let domainIdentifier: String
        /// The ID of the environment where the connection is created.
        public let environmentIdentifier: String
        /// The connection name.
        public let name: String
        /// The connection props.
        public let props: ConnectionPropertiesInput?

        @inlinable
        public init(awsLocation: AwsLocation? = nil, clientToken: String? = CreateConnectionInput.idempotencyToken(), description: String? = nil, domainIdentifier: String, environmentIdentifier: String, name: String, props: ConnectionPropertiesInput? = nil) {
            self.awsLocation = awsLocation
            self.clientToken = clientToken
            self.description = description
            self.domainIdentifier = domainIdentifier
            self.environmentIdentifier = environmentIdentifier
            self.name = name
            self.props = props
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.awsLocation, forKey: .awsLocation)
            try container.encodeIfPresent(self.clientToken, forKey: .clientToken)
            try container.encodeIfPresent(self.description, forKey: .description)
            request.encodePath(self.domainIdentifier, key: "domainIdentifier")
            try container.encode(self.environmentIdentifier, forKey: .environmentIdentifier)
            try container.encode(self.name, forKey: .name)
            try container.encodeIfPresent(self.props, forKey: .props)
        }

        public func validate(name: String) throws {
            try self.awsLocation?.validate(name: "\(name).awsLocation")
            try self.validate(self.description, name: "description", parent: name, max: 2048)
            try self.validate(self.domainIdentifier, name: "domainIdentifier", parent: name, pattern: "^dzd[-_][a-zA-Z0-9_-]{1,36}$")
            try self.validate(self.environmentIdentifier, name: "environmentIdentifier", parent: name, pattern: "^[a-zA-Z0-9_-]{1,36}$")
            try self.validate(self.name, name: "name", parent: name, max: 64)
            try self.props?.validate(name: "\(name).props")
        }

        private enum CodingKeys: String, CodingKey {
            case awsLocation = "awsLocation"
            case clientToken = "clientToken"
            case description = "description"
            case environmentIdentifier = "environmentIdentifier"
            case name = "name"
            case props = "props"
        }
    }

    public struct CreateConnectionOutput: AWSDecodableShape {
        /// The ID of the connection.
        public let connectionId: String
        /// The connection description.
        public let description: String?
        /// The ID of the domain where the connection is created.
        public let domainId: String
        /// The ID of the domain unit where the connection is created.
        public let domainUnitId: String
        /// The ID of the environment where the connection is created.
        public let environmentId: String?
        /// The connection name.
        public let name: String
        /// The physical endpoints of the connection.
        public let physicalEndpoints: [PhysicalEndpoint]
        /// The ID of the project where the connection is created.
        public let projectId: String?
        /// The connection props.
        public let props: ConnectionPropertiesOutput?
        /// The connection type.
        public let type: ConnectionType

        @inlinable
        public init(connectionId: String, description: String? = nil, domainId: String, domainUnitId: String, environmentId: String? = nil, name: String, physicalEndpoints: [PhysicalEndpoint], projectId: String? = nil, props: ConnectionPropertiesOutput? = nil, type: ConnectionType) {
            self.connectionId = connectionId
            self.description = description
            self.domainId = domainId
            self.domainUnitId = domainUnitId
            self.environmentId = environmentId
            self.name = name
            self.physicalEndpoints = physicalEndpoints
            self.projectId = projectId
            self.props = props
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case connectionId = "connectionId"
            case description = "description"
            case domainId = "domainId"
            case domainUnitId = "domainUnitId"
            case environmentId = "environmentId"
            case name = "name"
            case physicalEndpoints = "physicalEndpoints"
            case projectId = "projectId"
            case props = "props"
            case type = "type"
        }
    }

    public struct CreateDataProductInput: AWSEncodableShape {
        /// A unique, case-sensitive identifier that is provided to ensure the idempotency of the request.
        public let clientToken: String?
        /// The description of the data product.
        public let description: String?
        /// The ID of the domain where the data product is created.
        public let domainIdentifier: String
        /// The metadata forms of the data product.
        public let formsInput: [FormInput]?
        /// The glossary terms of the data product.
        public let glossaryTerms: [String]?
        /// The data assets of the data product.
        public let items: [DataProductItem]?
        /// The name of the data product.
        public let name: String
        /// The ID of the owning project of the data product.
        public let owningProjectIdentifier: String

        @inlinable
        public init(clientToken: String? = CreateDataProductInput.idempotencyToken(), description: String? = nil, domainIdentifier: String, formsInput: [FormInput]? = nil, glossaryTerms: [String]? = nil, items: [DataProductItem]? = nil, name: String, owningProjectIdentifier: String) {
            self.clientToken = clientToken
            self.description = description
            self.domainIdentifier = domainIdentifier
            self.formsInput = formsInput
            self.glossaryTerms = glossaryTerms
            self.items = items
            self.name = name
            self.owningProjectIdentifier = owningProjectIdentifier
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.clientToken, forKey: .clientToken)
            try container.encodeIfPresent(self.description, forKey: .description)
            request.encodePath(self.domainIdentifier, key: "domainIdentifier")
            try container.encodeIfPresent(self.formsInput, forKey: .formsInput)
            try container.encodeIfPresent(self.glossaryTerms, forKey: .glossaryTerms)
            try container.encodeIfPresent(self.items, forKey: .items)
            try container.encode(self.name, forKey: .name)
            try container.encode(self.owningProjectIdentifier, forKey: .owningProjectIdentifier)
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 128)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "^[\\x21-\\x7E]+$")
            try self.validate(self.description, name: "description", parent: name, max: 4096)
            try self.validate(self.description, name: "description", parent: name, min: 1)
            try self.validate(self.domainIdentifier, name: "domainIdentifier", parent: name, pattern: "^dzd[-_][a-zA-Z0-9_-]{1,36}$")
            try self.formsInput?.forEach {
                try $0.validate(name: "\(name).formsInput[]")
            }
            try self.validate(self.formsInput, name: "formsInput", parent: name, max: 10)
            try self.glossaryTerms?.forEach {
                try validate($0, name: "glossaryTerms[]", parent: name, pattern: "^[a-zA-Z0-9_-]{1,36}$")
            }
            try self.validate(self.glossaryTerms, name: "glossaryTerms", parent: name, max: 20)
            try self.validate(self.glossaryTerms, name: "glossaryTerms", parent: name, min: 1)
            try self.items?.forEach {
                try $0.validate(name: "\(name).items[]")
            }
            try self.validate(self.items, name: "items", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, max: 64)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.owningProjectIdentifier, name: "owningProjectIdentifier", parent: name, pattern: "^[a-zA-Z0-9_-]{1,36}$")
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "clientToken"
            case description = "description"
            case formsInput = "formsInput"
            case glossaryTerms = "glossaryTerms"
            case items = "items"
            case name = "name"
            case owningProjectIdentifier = "owningProjectIdentifier"
        }
    }

    public struct CreateDataProductOutput: AWSDecodableShape {
        /// The timestamp at which the data product was created.
        public let createdAt: Date?
        /// The user who created the data product.
        public let createdBy: String?
        /// The description of the data product.
        public let description: String?
        /// The ID of the domain where the data product lives.
        public let domainId: String
        /// The timestamp at which the first revision of the data product was created.
        public let firstRevisionCreatedAt: Date?
        /// The user who created the first revision of the data product.
        public let firstRevisionCreatedBy: String?
        /// The metadata forms of the data product.
        public let formsOutput: [FormOutput]?
        /// The glossary terms of the data product.
        public let glossaryTerms: [String]?
        /// The ID of the data product.
        public let id: String
        /// The data assets of the data product.
        public let items: [DataProductItem]?
        /// The name of the data product.
        public let name: String
        /// The ID of the owning project of the data product.
        public let owningProjectId: String
        /// The revision of the data product.
        public let revision: String
        /// The status of the data product.
        public let status: DataProductStatus

        @inlinable
        public init(createdAt: Date? = nil, createdBy: String? = nil, description: String? = nil, domainId: String, firstRevisionCreatedAt: Date? = nil, firstRevisionCreatedBy: String? = nil, formsOutput: [FormOutput]? = nil, glossaryTerms: [String]? = nil, id: String, items: [DataProductItem]? = nil, name: String, owningProjectId: String, revision: String, status: DataProductStatus) {
            self.createdAt = createdAt
            self.createdBy = createdBy
            self.description = description
            self.domainId = domainId
            self.firstRevisionCreatedAt = firstRevisionCreatedAt
            self.firstRevisionCreatedBy = firstRevisionCreatedBy
            self.formsOutput = formsOutput
            self.glossaryTerms = glossaryTerms
            self.id = id
            self.items = items
            self.name = name
            self.owningProjectId = owningProjectId
            self.revision = revision
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case createdAt = "createdAt"
            case createdBy = "createdBy"
            case description = "description"
            case domainId = "domainId"
            case firstRevisionCreatedAt = "firstRevisionCreatedAt"
            case firstRevisionCreatedBy = "firstRevisionCreatedBy"
            case formsOutput = "formsOutput"
            case glossaryTerms = "glossaryTerms"
            case id = "id"
            case items = "items"
            case name = "name"
            case owningProjectId = "owningProjectId"
            case revision = "revision"
            case status = "status"
        }
    }

    public struct CreateDataProductRevisionInput: AWSEncodableShape {
        /// A unique, case-sensitive identifier that is provided to ensure the idempotency of the request.
        public let clientToken: String?
        /// The description of the data product revision.
        public let description: String?
        /// The ID of the domain where the data product revision is created.
        public let domainIdentifier: String
        /// The metadata forms of the data product revision.
        public let formsInput: [FormInput]?
        /// The glossary terms of the data product revision.
        public let glossaryTerms: [String]?
        /// The ID of the data product revision.
        public let identifier: String
        /// The data assets of the data product revision.
        public let items: [DataProductItem]?
        /// The name of the data product revision.
        public let name: String

        @inlinable
        public init(clientToken: String? = CreateDataProductRevisionInput.idempotencyToken(), description: String? = nil, domainIdentifier: String, formsInput: [FormInput]? = nil, glossaryTerms: [String]? = nil, identifier: String, items: [DataProductItem]? = nil, name: String) {
            self.clientToken = clientToken
            self.description = description
            self.domainIdentifier = domainIdentifier
            self.formsInput = formsInput
            self.glossaryTerms = glossaryTerms
            self.identifier = identifier
            self.items = items
            self.name = name
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.clientToken, forKey: .clientToken)
            try container.encodeIfPresent(self.description, forKey: .description)
            request.encodePath(self.domainIdentifier, key: "domainIdentifier")
            try container.encodeIfPresent(self.formsInput, forKey: .formsInput)
            try container.encodeIfPresent(self.glossaryTerms, forKey: .glossaryTerms)
            request.encodePath(self.identifier, key: "identifier")
            try container.encodeIfPresent(self.items, forKey: .items)
            try container.encode(self.name, forKey: .name)
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 128)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "^[\\x21-\\x7E]+$")
            try self.validate(self.description, name: "description", parent: name, max: 4096)
            try self.validate(self.description, name: "description", parent: name, min: 1)
            try self.validate(self.domainIdentifier, name: "domainIdentifier", parent: name, pattern: "^dzd[-_][a-zA-Z0-9_-]{1,36}$")
            try self.formsInput?.forEach {
                try $0.validate(name: "\(name).formsInput[]")
            }
            try self.validate(self.formsInput, name: "formsInput", parent: name, max: 10)
            try self.glossaryTerms?.forEach {
                try validate($0, name: "glossaryTerms[]", parent: name, pattern: "^[a-zA-Z0-9_-]{1,36}$")
            }
            try self.validate(self.glossaryTerms, name: "glossaryTerms", parent: name, max: 20)
            try self.validate(self.glossaryTerms, name: "glossaryTerms", parent: name, min: 1)
            try self.validate(self.identifier, name: "identifier", parent: name, pattern: "^[a-zA-Z0-9_-]{1,36}$")
            try self.items?.forEach {
                try $0.validate(name: "\(name).items[]")
            }
            try self.validate(self.items, name: "items", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, max: 64)
            try self.validate(self.name, name: "name", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "clientToken"
            case description = "description"
            case formsInput = "formsInput"
            case glossaryTerms = "glossaryTerms"
            case items = "items"
            case name = "name"
        }
    }

    public struct CreateDataProductRevisionOutput: AWSDecodableShape {
        /// The timestamp at which the data product revision is created.
        public let createdAt: Date?
        /// The user who created the data product revision.
        public let createdBy: String?
        /// The description of the data product revision.
        public let description: String?
        /// The ID of the domain where data product revision is created.
        public let domainId: String
        /// The timestamp at which the first revision of the data product is created.
        public let firstRevisionCreatedAt: Date?
        /// The user who created the first revision of the data product.
        public let firstRevisionCreatedBy: String?
        /// The metadata forms of the data product revision.
        public let formsOutput: [FormOutput]?
        /// The glossary terms of the data product revision.
        public let glossaryTerms: [String]?
        /// The ID of the data product revision.
        public let id: String
        /// The data assets of the data product revision.
        public let items: [DataProductItem]?
        /// The name of the data product revision.
        public let name: String
        /// The ID of the owning project of the data product revision.
        public let owningProjectId: String
        /// The revision of the data product revision.
        public let revision: String
        /// The status of the data product revision.
        public let status: DataProductStatus

        @inlinable
        public init(createdAt: Date? = nil, createdBy: String? = nil, description: String? = nil, domainId: String, firstRevisionCreatedAt: Date? = nil, firstRevisionCreatedBy: String? = nil, formsOutput: [FormOutput]? = nil, glossaryTerms: [String]? = nil, id: String, items: [DataProductItem]? = nil, name: String, owningProjectId: String, revision: String, status: DataProductStatus) {
            self.createdAt = createdAt
            self.createdBy = createdBy
            self.description = description
            self.domainId = domainId
            self.firstRevisionCreatedAt = firstRevisionCreatedAt
            self.firstRevisionCreatedBy = firstRevisionCreatedBy
            self.formsOutput = formsOutput
            self.glossaryTerms = glossaryTerms
            self.id = id
            self.items = items
            self.name = name
            self.owningProjectId = owningProjectId
            self.revision = revision
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case createdAt = "createdAt"
            case createdBy = "createdBy"
            case description = "description"
            case domainId = "domainId"
            case firstRevisionCreatedAt = "firstRevisionCreatedAt"
            case firstRevisionCreatedBy = "firstRevisionCreatedBy"
            case formsOutput = "formsOutput"
            case glossaryTerms = "glossaryTerms"
            case id = "id"
            case items = "items"
            case name = "name"
            case owningProjectId = "owningProjectId"
            case revision = "revision"
            case status = "status"
        }
    }

    public struct CreateDataSourceInput: AWSEncodableShape {
        /// The metadata forms that are to be attached to the assets that this data source works with.
        public let assetFormsInput: [FormInput]?
        /// A unique, case-sensitive identifier that is provided to ensure the idempotency of the request.
        public let clientToken: String?
        /// Specifies the configuration of the data source. It can be set to either glueRunConfiguration or redshiftRunConfiguration.
        public let configuration: DataSourceConfigurationInput?
        /// The ID of the connection.
        public let connectionIdentifier: String?
        /// The description of the data source.
        public let description: String?
        /// The ID of the Amazon DataZone domain where the data source is created.
        public let domainIdentifier: String
        /// Specifies whether the data source is enabled.
        public let enableSetting: EnableSetting?
        /// The unique identifier of the Amazon DataZone environment to which the data source publishes assets.
        public let environmentIdentifier: String?
        /// The name of the data source.
        public let name: String
        /// The identifier of the Amazon DataZone project in which you want to add this data source.
        public let projectIdentifier: String
        /// Specifies whether the assets that this data source creates in the inventory are to be also automatically published to the catalog.
        public let publishOnImport: Bool?
        /// Specifies whether the business name generation is to be enabled for this data source.
        public let recommendation: RecommendationConfiguration?
        /// The schedule of the data source runs.
        public let schedule: ScheduleConfiguration?
        /// The type of the data source. In Amazon DataZone, you can use data sources to import technical metadata of assets (data) from the source databases or data warehouses into Amazon DataZone. In the current release of Amazon DataZone, you can create and run data sources for Amazon Web Services Glue and Amazon Redshift.
        public let type: String

        @inlinable
        public init(assetFormsInput: [FormInput]? = nil, clientToken: String? = CreateDataSourceInput.idempotencyToken(), configuration: DataSourceConfigurationInput? = nil, connectionIdentifier: String? = nil, description: String? = nil, domainIdentifier: String, enableSetting: EnableSetting? = nil, environmentIdentifier: String? = nil, name: String, projectIdentifier: String, publishOnImport: Bool? = nil, recommendation: RecommendationConfiguration? = nil, schedule: ScheduleConfiguration? = nil, type: String) {
            self.assetFormsInput = assetFormsInput
            self.clientToken = clientToken
            self.configuration = configuration
            self.connectionIdentifier = connectionIdentifier
            self.description = description
            self.domainIdentifier = domainIdentifier
            self.enableSetting = enableSetting
            self.environmentIdentifier = environmentIdentifier
            self.name = name
            self.projectIdentifier = projectIdentifier
            self.publishOnImport = publishOnImport
            self.recommendation = recommendation
            self.schedule = schedule
            self.type = type
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.assetFormsInput, forKey: .assetFormsInput)
            try container.encodeIfPresent(self.clientToken, forKey: .clientToken)
            try container.encodeIfPresent(self.configuration, forKey: .configuration)
            try container.encodeIfPresent(self.connectionIdentifier, forKey: .connectionIdentifier)
            try container.encodeIfPresent(self.description, forKey: .description)
            request.encodePath(self.domainIdentifier, key: "domainIdentifier")
            try container.encodeIfPresent(self.enableSetting, forKey: .enableSetting)
            try container.encodeIfPresent(self.environmentIdentifier, forKey: .environmentIdentifier)
            try container.encode(self.name, forKey: .name)
            try container.encode(self.projectIdentifier, forKey: .projectIdentifier)
            try container.encodeIfPresent(self.publishOnImport, forKey: .publishOnImport)
            try container.encodeIfPresent(self.recommendation, forKey: .recommendation)
            try container.encodeIfPresent(self.schedule, forKey: .schedule)
            try container.encode(self.type, forKey: .type)
        }

        public func validate(name: String) throws {
            try self.assetFormsInput?.forEach {
                try $0.validate(name: "\(name).assetFormsInput[]")
            }
            try self.validate(self.assetFormsInput, name: "assetFormsInput", parent: name, max: 10)
            try self.configuration?.validate(name: "\(name).configuration")
            try self.validate(self.description, name: "description", parent: name, max: 2048)
            try self.validate(self.domainIdentifier, name: "domainIdentifier", parent: name, pattern: "^dzd[-_][a-zA-Z0-9_-]{1,36}$")
            try self.validate(self.name, name: "name", parent: name, max: 256)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.schedule?.validate(name: "\(name).schedule")
            try self.validate(self.type, name: "type", parent: name, max: 256)
            try self.validate(self.type, name: "type", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case assetFormsInput = "assetFormsInput"
            case clientToken = "clientToken"
            case configuration = "configuration"
            case connectionIdentifier = "connectionIdentifier"
            case description = "description"
            case enableSetting = "enableSetting"
            case environmentIdentifier = "environmentIdentifier"
            case name = "name"
            case projectIdentifier = "projectIdentifier"
            case publishOnImport = "publishOnImport"
            case recommendation = "recommendation"
            case schedule = "schedule"
            case type = "type"
        }
    }

    public struct CreateDataSourceOutput: AWSDecodableShape {
        /// The metadata forms attached to the assets that this data source creates.
        public let assetFormsOutput: [FormOutput]?
        /// Specifies the configuration of the data source. It can be set to either glueRunConfiguration or redshiftRunConfiguration.
        public let configuration: DataSourceConfigurationOutput?
        /// The ID of the connection.
        public let connectionId: String?
        /// The timestamp of when the data source was created.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var createdAt: Date?
        /// The description of the data source.
        public let description: String?
        /// The ID of the Amazon DataZone domain in which the data source is created.
        public let domainId: String
        /// Specifies whether the data source is enabled.
        public let enableSetting: EnableSetting?
        /// The unique identifier of the Amazon DataZone environment to which the data source publishes assets.
        public let environmentId: String?
        /// Specifies the error message that is returned if the operation cannot be successfully completed.
        public let errorMessage: DataSourceErrorMessage?
        /// The unique identifier of the data source.
        public let id: String
        /// The timestamp that specifies when the data source was last run.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var lastRunAt: Date?
        /// Specifies the error message that is returned if the operation cannot be successfully completed.
        public let lastRunErrorMessage: DataSourceErrorMessage?
        /// The status of the last run of this data source.
        public let lastRunStatus: DataSourceRunStatus?
        /// The name of the data source.
        public let name: String
        /// The ID of the Amazon DataZone project to which the data source is added.
        public let projectId: String
        /// Specifies whether the assets that this data source creates in the inventory are to be also automatically published to the catalog.
        public let publishOnImport: Bool?
        /// Specifies whether the business name generation is to be enabled for this data source.
        public let recommendation: RecommendationConfiguration?
        /// The schedule of the data source runs.
        public let schedule: ScheduleConfiguration?
        /// The status of the data source.
        public let status: DataSourceStatus?
        /// The type of the data source.
        public let type: String?
        /// The timestamp of when the data source was updated.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var updatedAt: Date?

        @inlinable
        public init(assetFormsOutput: [FormOutput]? = nil, configuration: DataSourceConfigurationOutput? = nil, connectionId: String? = nil, createdAt: Date? = nil, description: String? = nil, domainId: String, enableSetting: EnableSetting? = nil, environmentId: String? = nil, errorMessage: DataSourceErrorMessage? = nil, id: String, lastRunAt: Date? = nil, lastRunErrorMessage: DataSourceErrorMessage? = nil, lastRunStatus: DataSourceRunStatus? = nil, name: String, projectId: String, publishOnImport: Bool? = nil, recommendation: RecommendationConfiguration? = nil, schedule: ScheduleConfiguration? = nil, status: DataSourceStatus? = nil, type: String? = nil, updatedAt: Date? = nil) {
            self.assetFormsOutput = assetFormsOutput
            self.configuration = configuration
            self.connectionId = connectionId
            self.createdAt = createdAt
            self.description = description
            self.domainId = domainId
            self.enableSetting = enableSetting
            self.environmentId = environmentId
            self.errorMessage = errorMessage
            self.id = id
            self.lastRunAt = lastRunAt
            self.lastRunErrorMessage = lastRunErrorMessage
            self.lastRunStatus = lastRunStatus
            self.name = name
            self.projectId = projectId
            self.publishOnImport = publishOnImport
            self.recommendation = recommendation
            self.schedule = schedule
            self.status = status
            self.type = type
            self.updatedAt = updatedAt
        }

        private enum CodingKeys: String, CodingKey {
            case assetFormsOutput = "assetFormsOutput"
            case configuration = "configuration"
            case connectionId = "connectionId"
            case createdAt = "createdAt"
            case description = "description"
            case domainId = "domainId"
            case enableSetting = "enableSetting"
            case environmentId = "environmentId"
            case errorMessage = "errorMessage"
            case id = "id"
            case lastRunAt = "lastRunAt"
            case lastRunErrorMessage = "lastRunErrorMessage"
            case lastRunStatus = "lastRunStatus"
            case name = "name"
            case projectId = "projectId"
            case publishOnImport = "publishOnImport"
            case recommendation = "recommendation"
            case schedule = "schedule"
            case status = "status"
            case type = "type"
            case updatedAt = "updatedAt"
        }
    }

    public struct CreateDomainInput: AWSEncodableShape {
        /// A unique, case-sensitive identifier that is provided to ensure the idempotency of the request.
        public let clientToken: String?
        /// The description of the Amazon DataZone domain.
        public let description: String?
        /// The domain execution role that is created when an Amazon DataZone domain is created. The domain execution role is created in the Amazon Web Services account that houses the Amazon DataZone domain.
        public let domainExecutionRole: String
        /// The version of the domain that is created.
        public let domainVersion: DomainVersion?
        /// The identifier of the Amazon Web Services Key Management Service (KMS) key that is used to encrypt the Amazon DataZone domain, metadata, and reporting data.
        public let kmsKeyIdentifier: String?
        /// The name of the Amazon DataZone domain.
        public let name: String
        /// The service role of the domain that is created.
        public let serviceRole: String?
        /// The single-sign on configuration of the Amazon DataZone domain.
        public let singleSignOn: SingleSignOn?
        /// The tags specified for the Amazon DataZone domain.
        public let tags: [String: String]?

        @inlinable
        public init(clientToken: String? = CreateDomainInput.idempotencyToken(), description: String? = nil, domainExecutionRole: String, domainVersion: DomainVersion? = nil, kmsKeyIdentifier: String? = nil, name: String, serviceRole: String? = nil, singleSignOn: SingleSignOn? = nil, tags: [String: String]? = nil) {
            self.clientToken = clientToken
            self.description = description
            self.domainExecutionRole = domainExecutionRole
            self.domainVersion = domainVersion
            self.kmsKeyIdentifier = kmsKeyIdentifier
            self.name = name
            self.serviceRole = serviceRole
            self.singleSignOn = singleSignOn
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.validate(self.domainExecutionRole, name: "domainExecutionRole", parent: name, pattern: "^arn:aws[^:]*:iam::\\d{12}:(role|role/service-role)/[\\w+=,.@-]*$")
            try self.validate(self.kmsKeyIdentifier, name: "kmsKeyIdentifier", parent: name, max: 1024)
            try self.validate(self.kmsKeyIdentifier, name: "kmsKeyIdentifier", parent: name, min: 1)
            try self.validate(self.kmsKeyIdentifier, name: "kmsKeyIdentifier", parent: name, pattern: "^arn:aws(|-cn|-us-gov):kms:[a-zA-Z0-9-]*:[0-9]{12}:key/[a-zA-Z0-9-]{36}$")
            try self.validate(self.serviceRole, name: "serviceRole", parent: name, pattern: "^arn:aws[^:]*:iam::\\d{12}:(role|role/service-role)/[\\w+=,.@-]*$")
            try self.tags?.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.key, name: "tags.key", parent: name, pattern: "^[\\w \\.:/=+@-]+$")
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, pattern: "^[\\w \\.:/=+@-]*$")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "clientToken"
            case description = "description"
            case domainExecutionRole = "domainExecutionRole"
            case domainVersion = "domainVersion"
            case kmsKeyIdentifier = "kmsKeyIdentifier"
            case name = "name"
            case serviceRole = "serviceRole"
            case singleSignOn = "singleSignOn"
            case tags = "tags"
        }
    }

    public struct CreateDomainOutput: AWSDecodableShape {
        /// The ARN of the Amazon DataZone domain.
        public let arn: String?
        /// The description of the Amazon DataZone domain.
        public let description: String?
        /// The domain execution role that is created when an Amazon DataZone domain is created. The domain execution role is created in the Amazon Web Services account that houses the Amazon DataZone domain.
        public let domainExecutionRole: String?
        /// The version of the domain that is created.
        public let domainVersion: DomainVersion?
        /// The identifier of the Amazon DataZone domain.
        public let id: String
        /// The identifier of the Amazon Web Services Key Management Service (KMS) key that is used to encrypt the Amazon DataZone domain, metadata, and reporting data.
        public let kmsKeyIdentifier: String?
        /// The name of the Amazon DataZone domain.
        public let name: String?
        /// The URL of the data portal for this Amazon DataZone domain.
        public let portalUrl: String?
        /// The ID of the root domain unit.
        public let rootDomainUnitId: String?
        /// Te service role of the domain that is created.
        public let serviceRole: String?
        /// The single-sign on configuration of the Amazon DataZone domain.
        public let singleSignOn: SingleSignOn?
        /// The status of the Amazon DataZone domain.
        public let status: DomainStatus?
        /// The tags specified for the Amazon DataZone domain.
        public let tags: [String: String]?

        @inlinable
        public init(arn: String? = nil, description: String? = nil, domainExecutionRole: String? = nil, domainVersion: DomainVersion? = nil, id: String, kmsKeyIdentifier: String? = nil, name: String? = nil, portalUrl: String? = nil, rootDomainUnitId: String? = nil, serviceRole: String? = nil, singleSignOn: SingleSignOn? = nil, status: DomainStatus? = nil, tags: [String: String]? = nil) {
            self.arn = arn
            self.description = description
            self.domainExecutionRole = domainExecutionRole
            self.domainVersion = domainVersion
            self.id = id
            self.kmsKeyIdentifier = kmsKeyIdentifier
            self.name = name
            self.portalUrl = portalUrl
            self.rootDomainUnitId = rootDomainUnitId
            self.serviceRole = serviceRole
            self.singleSignOn = singleSignOn
            self.status = status
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case description = "description"
            case domainExecutionRole = "domainExecutionRole"
            case domainVersion = "domainVersion"
            case id = "id"
            case kmsKeyIdentifier = "kmsKeyIdentifier"
            case name = "name"
            case portalUrl = "portalUrl"
            case rootDomainUnitId = "rootDomainUnitId"
            case serviceRole = "serviceRole"
            case singleSignOn = "singleSignOn"
            case status = "status"
            case tags = "tags"
        }
    }

    public struct CreateDomainUnitInput: AWSEncodableShape {
        /// A unique, case-sensitive identifier that is provided to ensure the idempotency of the request.
        public let clientToken: String?
        /// The description of the domain unit.
        public let description: String?
        /// The ID of the domain where you want to crate a domain unit.
        public let domainIdentifier: String
        /// The name of the domain unit.
        public let name: String
        /// The ID of the parent domain unit.
        public let parentDomainUnitIdentifier: String

        @inlinable
        public init(clientToken: String? = CreateDomainUnitInput.idempotencyToken(), description: String? = nil, domainIdentifier: String, name: String, parentDomainUnitIdentifier: String) {
            self.clientToken = clientToken
            self.description = description
            self.domainIdentifier = domainIdentifier
            self.name = name
            self.parentDomainUnitIdentifier = parentDomainUnitIdentifier
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.clientToken, forKey: .clientToken)
            try container.encodeIfPresent(self.description, forKey: .description)
            request.encodePath(self.domainIdentifier, key: "domainIdentifier")
            try container.encode(self.name, forKey: .name)
            try container.encode(self.parentDomainUnitIdentifier, forKey: .parentDomainUnitIdentifier)
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 128)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "^[\\x21-\\x7E]+$")
            try self.validate(self.description, name: "description", parent: name, max: 2048)
            try self.validate(self.domainIdentifier, name: "domainIdentifier", parent: name, pattern: "^dzd[-_][a-zA-Z0-9_-]{1,36}$")
            try self.validate(self.name, name: "name", parent: name, max: 128)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[\\w -]+$")
            try self.validate(self.parentDomainUnitIdentifier, name: "parentDomainUnitIdentifier", parent: name, max: 256)
            try self.validate(self.parentDomainUnitIdentifier, name: "parentDomainUnitIdentifier", parent: name, min: 1)
            try self.validate(self.parentDomainUnitIdentifier, name: "parentDomainUnitIdentifier", parent: name, pattern: "^[a-z0-9_\\-]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "clientToken"
            case description = "description"
            case name = "name"
            case parentDomainUnitIdentifier = "parentDomainUnitIdentifier"
        }
    }

    public struct CreateDomainUnitOutput: AWSDecodableShape {
        /// The IDs of the ancestor domain units.
        public let ancestorDomainUnitIds: [String]
        /// The timestamp at which the domain unit was created.
        public let createdAt: Date?
        /// The user who created the domain unit.
        public let createdBy: String?
        /// The description of the domain unit.
        public let description: String?
        /// The ID of the domain where the domain unit was created.
        public let domainId: String
        /// The ID of the domain unit.
        public let id: String
        /// The name of the domain unit.
        public let name: String
        /// The owners of the domain unit.
        public let owners: [DomainUnitOwnerProperties]
        /// The ID of the parent domain unit.
        public let parentDomainUnitId: String?

        @inlinable
        public init(ancestorDomainUnitIds: [String], createdAt: Date? = nil, createdBy: String? = nil, description: String? = nil, domainId: String, id: String, name: String, owners: [DomainUnitOwnerProperties], parentDomainUnitId: String? = nil) {
            self.ancestorDomainUnitIds = ancestorDomainUnitIds
            self.createdAt = createdAt
            self.createdBy = createdBy
            self.description = description
            self.domainId = domainId
            self.id = id
            self.name = name
            self.owners = owners
            self.parentDomainUnitId = parentDomainUnitId
        }

        private enum CodingKeys: String, CodingKey {
            case ancestorDomainUnitIds = "ancestorDomainUnitIds"
            case createdAt = "createdAt"
            case createdBy = "createdBy"
            case description = "description"
            case domainId = "domainId"
            case id = "id"
            case name = "name"
            case owners = "owners"
            case parentDomainUnitId = "parentDomainUnitId"
        }
    }

    public struct CreateDomainUnitPolicyGrantDetail: AWSEncodableShape & AWSDecodableShape {
        /// Specifies whether the policy grant is applied to child domain units.
        public let includeChildDomainUnits: Bool?

        @inlinable
        public init(includeChildDomainUnits: Bool? = nil) {
            self.includeChildDomainUnits = includeChildDomainUnits
        }

        private enum CodingKeys: String, CodingKey {
            case includeChildDomainUnits = "includeChildDomainUnits"
        }
    }

    public struct CreateEnvironmentActionInput: AWSEncodableShape {
        /// The description of the environment action that is being created in the environment.
        public let description: String?
        /// The ID of the Amazon DataZone domain in which the environment action is created.
        public let domainIdentifier: String
        /// The ID of the environment in which the environment action is created.
        public let environmentIdentifier: String
        /// The name of the environment action.
        public let name: String
        /// The parameters of the environment action.
        public let parameters: ActionParameters

        @inlinable
        public init(description: String? = nil, domainIdentifier: String, environmentIdentifier: String, name: String, parameters: ActionParameters) {
            self.description = description
            self.domainIdentifier = domainIdentifier
            self.environmentIdentifier = environmentIdentifier
            self.name = name
            self.parameters = parameters
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.description, forKey: .description)
            request.encodePath(self.domainIdentifier, key: "domainIdentifier")
            request.encodePath(self.environmentIdentifier, key: "environmentIdentifier")
            try container.encode(self.name, forKey: .name)
            try container.encode(self.parameters, forKey: .parameters)
        }

        public func validate(name: String) throws {
            try self.validate(self.domainIdentifier, name: "domainIdentifier", parent: name, pattern: "^dzd[-_][a-zA-Z0-9_-]{1,36}$")
            try self.validate(self.environmentIdentifier, name: "environmentIdentifier", parent: name, pattern: "^[a-zA-Z0-9_-]{1,36}$")
        }

        private enum CodingKeys: String, CodingKey {
            case description = "description"
            case name = "name"
            case parameters = "parameters"
        }
    }

    public struct CreateEnvironmentActionOutput: AWSDecodableShape {
        /// The description of the environment action.
        public let description: String?
        /// The ID of the domain in which the environment action is created.
        public let domainId: String
        /// The ID of the environment in which the environment is created.
        public let environmentId: String
        /// The ID of the environment action.
        public let id: String
        /// The name of the environment action.
        public let name: String
        /// The parameters of the environment action.
        public let parameters: ActionParameters

        @inlinable
        public init(description: String? = nil, domainId: String, environmentId: String, id: String, name: String, parameters: ActionParameters) {
            self.description = description
            self.domainId = domainId
            self.environmentId = environmentId
            self.id = id
            self.name = name
            self.parameters = parameters
        }

        private enum CodingKeys: String, CodingKey {
            case description = "description"
            case domainId = "domainId"
            case environmentId = "environmentId"
            case id = "id"
            case name = "name"
            case parameters = "parameters"
        }
    }

    public struct CreateEnvironmentInput: AWSEncodableShape {
        /// The deployment order of the environment.
        public let deploymentOrder: Int?
        /// The description of the Amazon DataZone environment.
        public let description: String?
        /// The identifier of the Amazon DataZone domain in which the environment is created.
        public let domainIdentifier: String
        /// The ID of the account in which the environment is being created.
        public let environmentAccountIdentifier: String?
        /// The region of the account in which the environment is being created.
        public let environmentAccountRegion: String?
        /// The ID of the blueprint with which the environment is being created.
        public let environmentBlueprintIdentifier: String?
        /// The configuration ID of the environment.
        public let environmentConfigurationId: String?
        /// The identifier of the environment profile that is used to create this Amazon DataZone environment.
        public let environmentProfileIdentifier: String
        /// The glossary terms that can be used in this Amazon DataZone environment.
        public let glossaryTerms: [String]?
        /// The name of the Amazon DataZone environment.
        public let name: String
        /// The identifier of the Amazon DataZone project in which this environment is created.
        public let projectIdentifier: String
        /// The user parameters of this Amazon DataZone environment.
        public let userParameters: [EnvironmentParameter]?

        @inlinable
        public init(deploymentOrder: Int? = nil, description: String? = nil, domainIdentifier: String, environmentAccountIdentifier: String? = nil, environmentAccountRegion: String? = nil, environmentBlueprintIdentifier: String? = nil, environmentConfigurationId: String? = nil, environmentProfileIdentifier: String, glossaryTerms: [String]? = nil, name: String, projectIdentifier: String, userParameters: [EnvironmentParameter]? = nil) {
            self.deploymentOrder = deploymentOrder
            self.description = description
            self.domainIdentifier = domainIdentifier
            self.environmentAccountIdentifier = environmentAccountIdentifier
            self.environmentAccountRegion = environmentAccountRegion
            self.environmentBlueprintIdentifier = environmentBlueprintIdentifier
            self.environmentConfigurationId = environmentConfigurationId
            self.environmentProfileIdentifier = environmentProfileIdentifier
            self.glossaryTerms = glossaryTerms
            self.name = name
            self.projectIdentifier = projectIdentifier
            self.userParameters = userParameters
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.deploymentOrder, forKey: .deploymentOrder)
            try container.encodeIfPresent(self.description, forKey: .description)
            request.encodePath(self.domainIdentifier, key: "domainIdentifier")
            try container.encodeIfPresent(self.environmentAccountIdentifier, forKey: .environmentAccountIdentifier)
            try container.encodeIfPresent(self.environmentAccountRegion, forKey: .environmentAccountRegion)
            try container.encodeIfPresent(self.environmentBlueprintIdentifier, forKey: .environmentBlueprintIdentifier)
            try container.encodeIfPresent(self.environmentConfigurationId, forKey: .environmentConfigurationId)
            try container.encode(self.environmentProfileIdentifier, forKey: .environmentProfileIdentifier)
            try container.encodeIfPresent(self.glossaryTerms, forKey: .glossaryTerms)
            try container.encode(self.name, forKey: .name)
            try container.encode(self.projectIdentifier, forKey: .projectIdentifier)
            try container.encodeIfPresent(self.userParameters, forKey: .userParameters)
        }

        public func validate(name: String) throws {
            try self.validate(self.domainIdentifier, name: "domainIdentifier", parent: name, pattern: "^dzd[-_][a-zA-Z0-9_-]{1,36}$")
            try self.validate(self.environmentProfileIdentifier, name: "environmentProfileIdentifier", parent: name, pattern: "^[a-zA-Z0-9_-]{0,36}$")
            try self.glossaryTerms?.forEach {
                try validate($0, name: "glossaryTerms[]", parent: name, pattern: "^[a-zA-Z0-9_-]{1,36}$")
            }
            try self.validate(self.glossaryTerms, name: "glossaryTerms", parent: name, max: 20)
            try self.validate(self.glossaryTerms, name: "glossaryTerms", parent: name, min: 1)
            try self.validate(self.projectIdentifier, name: "projectIdentifier", parent: name, pattern: "^[a-zA-Z0-9_-]{1,36}$")
        }

        private enum CodingKeys: String, CodingKey {
            case deploymentOrder = "deploymentOrder"
            case description = "description"
            case environmentAccountIdentifier = "environmentAccountIdentifier"
            case environmentAccountRegion = "environmentAccountRegion"
            case environmentBlueprintIdentifier = "environmentBlueprintIdentifier"
            case environmentConfigurationId = "environmentConfigurationId"
            case environmentProfileIdentifier = "environmentProfileIdentifier"
            case glossaryTerms = "glossaryTerms"
            case name = "name"
            case projectIdentifier = "projectIdentifier"
            case userParameters = "userParameters"
        }
    }

    public struct CreateEnvironmentOutput: AWSDecodableShape {
        /// The Amazon Web Services account in which the Amazon DataZone environment is created.
        public let awsAccountId: String?
        /// The Amazon Web Services region in which the Amazon DataZone environment is created.
        public let awsAccountRegion: String?
        /// The timestamp of when the environment was created.
        public let createdAt: Date?
        /// The Amazon DataZone user who created this environment.
        public let createdBy: String
        /// The deployment properties of this Amazon DataZone environment.
        public let deploymentProperties: DeploymentProperties?
        /// The description of this Amazon DataZone environment.
        public let description: String?
        /// The identifier of the Amazon DataZone domain in which the environment is created.
        public let domainId: String
        /// The configurable actions of this Amazon DataZone environment.
        public let environmentActions: [ConfigurableEnvironmentAction]?
        /// The ID of the blueprint with which this Amazon DataZone environment was created.
        public let environmentBlueprintId: String?
        /// The configuration ID of the environment.
        public let environmentConfigurationId: String?
        /// The ID of the environment profile with which this Amazon DataZone environment was created.
        public let environmentProfileId: String?
        /// The glossary terms that can be used in this Amazon DataZone environment.
        public let glossaryTerms: [String]?
        /// The ID of this Amazon DataZone environment.
        public let id: String?
        /// The details of the last deployment of this Amazon DataZone environment.
        public let lastDeployment: Deployment?
        /// The name of this environment.
        public let name: String
        /// The ID of the Amazon DataZone project in which this environment is created.
        public let projectId: String
        /// The provider of this Amazon DataZone environment.
        public let provider: String
        /// The provisioned resources of this Amazon DataZone environment.
        public let provisionedResources: [Resource]?
        /// The provisioning properties of this Amazon DataZone environment.
        public let provisioningProperties: ProvisioningProperties?
        /// The status of this Amazon DataZone environment.
        public let status: EnvironmentStatus?
        /// The timestamp of when this environment was updated.
        public let updatedAt: Date?
        /// The user parameters of this Amazon DataZone environment.
        public let userParameters: [CustomParameter]?

        @inlinable
        public init(awsAccountId: String? = nil, awsAccountRegion: String? = nil, createdAt: Date? = nil, createdBy: String, deploymentProperties: DeploymentProperties? = nil, description: String? = nil, domainId: String, environmentActions: [ConfigurableEnvironmentAction]? = nil, environmentBlueprintId: String? = nil, environmentConfigurationId: String? = nil, environmentProfileId: String? = nil, glossaryTerms: [String]? = nil, id: String? = nil, lastDeployment: Deployment? = nil, name: String, projectId: String, provider: String, provisionedResources: [Resource]? = nil, provisioningProperties: ProvisioningProperties? = nil, status: EnvironmentStatus? = nil, updatedAt: Date? = nil, userParameters: [CustomParameter]? = nil) {
            self.awsAccountId = awsAccountId
            self.awsAccountRegion = awsAccountRegion
            self.createdAt = createdAt
            self.createdBy = createdBy
            self.deploymentProperties = deploymentProperties
            self.description = description
            self.domainId = domainId
            self.environmentActions = environmentActions
            self.environmentBlueprintId = environmentBlueprintId
            self.environmentConfigurationId = environmentConfigurationId
            self.environmentProfileId = environmentProfileId
            self.glossaryTerms = glossaryTerms
            self.id = id
            self.lastDeployment = lastDeployment
            self.name = name
            self.projectId = projectId
            self.provider = provider
            self.provisionedResources = provisionedResources
            self.provisioningProperties = provisioningProperties
            self.status = status
            self.updatedAt = updatedAt
            self.userParameters = userParameters
        }

        private enum CodingKeys: String, CodingKey {
            case awsAccountId = "awsAccountId"
            case awsAccountRegion = "awsAccountRegion"
            case createdAt = "createdAt"
            case createdBy = "createdBy"
            case deploymentProperties = "deploymentProperties"
            case description = "description"
            case domainId = "domainId"
            case environmentActions = "environmentActions"
            case environmentBlueprintId = "environmentBlueprintId"
            case environmentConfigurationId = "environmentConfigurationId"
            case environmentProfileId = "environmentProfileId"
            case glossaryTerms = "glossaryTerms"
            case id = "id"
            case lastDeployment = "lastDeployment"
            case name = "name"
            case projectId = "projectId"
            case provider = "provider"
            case provisionedResources = "provisionedResources"
            case provisioningProperties = "provisioningProperties"
            case status = "status"
            case updatedAt = "updatedAt"
            case userParameters = "userParameters"
        }
    }

    public struct CreateEnvironmentProfileInput: AWSEncodableShape {
        /// The Amazon Web Services account in which the Amazon DataZone environment is created.
        public let awsAccountId: String?
        /// The Amazon Web Services region in which this environment profile is created.
        public let awsAccountRegion: String?
        /// The description of this Amazon DataZone environment profile.
        public let description: String?
        /// The ID of the Amazon DataZone domain in which this environment profile is created.
        public let domainIdentifier: String
        /// The ID of the blueprint with which this environment profile is created.
        public let environmentBlueprintIdentifier: String
        /// The name of this Amazon DataZone environment profile.
        public let name: String
        /// The identifier of the project in which to create the environment profile.
        public let projectIdentifier: String
        /// The user parameters of this Amazon DataZone environment profile.
        public let userParameters: [EnvironmentParameter]?

        @inlinable
        public init(awsAccountId: String? = nil, awsAccountRegion: String? = nil, description: String? = nil, domainIdentifier: String, environmentBlueprintIdentifier: String, name: String, projectIdentifier: String, userParameters: [EnvironmentParameter]? = nil) {
            self.awsAccountId = awsAccountId
            self.awsAccountRegion = awsAccountRegion
            self.description = description
            self.domainIdentifier = domainIdentifier
            self.environmentBlueprintIdentifier = environmentBlueprintIdentifier
            self.name = name
            self.projectIdentifier = projectIdentifier
            self.userParameters = userParameters
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.awsAccountId, forKey: .awsAccountId)
            try container.encodeIfPresent(self.awsAccountRegion, forKey: .awsAccountRegion)
            try container.encodeIfPresent(self.description, forKey: .description)
            request.encodePath(self.domainIdentifier, key: "domainIdentifier")
            try container.encode(self.environmentBlueprintIdentifier, forKey: .environmentBlueprintIdentifier)
            try container.encode(self.name, forKey: .name)
            try container.encode(self.projectIdentifier, forKey: .projectIdentifier)
            try container.encodeIfPresent(self.userParameters, forKey: .userParameters)
        }

        public func validate(name: String) throws {
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, pattern: "^\\d{12}$")
            try self.validate(self.awsAccountRegion, name: "awsAccountRegion", parent: name, pattern: "^[a-z]{2}-[a-z]{4,10}-\\d$")
            try self.validate(self.description, name: "description", parent: name, max: 2048)
            try self.validate(self.domainIdentifier, name: "domainIdentifier", parent: name, pattern: "^dzd[-_][a-zA-Z0-9_-]{1,36}$")
            try self.validate(self.environmentBlueprintIdentifier, name: "environmentBlueprintIdentifier", parent: name, pattern: "^[a-zA-Z0-9_-]{1,36}$")
            try self.validate(self.name, name: "name", parent: name, max: 64)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[\\w -]+$")
            try self.validate(self.projectIdentifier, name: "projectIdentifier", parent: name, pattern: "^[a-zA-Z0-9_-]{1,36}$")
        }

        private enum CodingKeys: String, CodingKey {
            case awsAccountId = "awsAccountId"
            case awsAccountRegion = "awsAccountRegion"
            case description = "description"
            case environmentBlueprintIdentifier = "environmentBlueprintIdentifier"
            case name = "name"
            case projectIdentifier = "projectIdentifier"
            case userParameters = "userParameters"
        }
    }

    public struct CreateEnvironmentProfileOutput: AWSDecodableShape {
        /// The Amazon Web Services account ID in which this Amazon DataZone environment profile is created.
        public let awsAccountId: String?
        /// The Amazon Web Services region in which this Amazon DataZone environment profile is created.
        public let awsAccountRegion: String?
        /// The timestamp of when this environment profile was created.
        public let createdAt: Date?
        /// The Amazon DataZone user who created this environment profile.
        public let createdBy: String
        /// The description of this Amazon DataZone environment profile.
        public let description: String?
        /// The ID of the Amazon DataZone domain in which this environment profile is created.
        public let domainId: String
        /// The ID of the blueprint with which this environment profile is created.
        public let environmentBlueprintId: String
        /// The ID of this Amazon DataZone environment profile.
        public let id: String
        /// The name of this Amazon DataZone environment profile.
        public let name: String
        /// The ID of the Amazon DataZone project in which this environment profile is created.
        public let projectId: String?
        /// The timestamp of when this environment profile was updated.
        public let updatedAt: Date?
        /// The user parameters of this Amazon DataZone environment profile.
        public let userParameters: [CustomParameter]?

        @inlinable
        public init(awsAccountId: String? = nil, awsAccountRegion: String? = nil, createdAt: Date? = nil, createdBy: String, description: String? = nil, domainId: String, environmentBlueprintId: String, id: String, name: String, projectId: String? = nil, updatedAt: Date? = nil, userParameters: [CustomParameter]? = nil) {
            self.awsAccountId = awsAccountId
            self.awsAccountRegion = awsAccountRegion
            self.createdAt = createdAt
            self.createdBy = createdBy
            self.description = description
            self.domainId = domainId
            self.environmentBlueprintId = environmentBlueprintId
            self.id = id
            self.name = name
            self.projectId = projectId
            self.updatedAt = updatedAt
            self.userParameters = userParameters
        }

        private enum CodingKeys: String, CodingKey {
            case awsAccountId = "awsAccountId"
            case awsAccountRegion = "awsAccountRegion"
            case createdAt = "createdAt"
            case createdBy = "createdBy"
            case description = "description"
            case domainId = "domainId"
            case environmentBlueprintId = "environmentBlueprintId"
            case id = "id"
            case name = "name"
            case projectId = "projectId"
            case updatedAt = "updatedAt"
            case userParameters = "userParameters"
        }
    }

    public struct CreateEnvironmentProfilePolicyGrantDetail: AWSEncodableShape & AWSDecodableShape {
        /// The ID of the domain unit.
        public let domainUnitId: String?

        @inlinable
        public init(domainUnitId: String? = nil) {
            self.domainUnitId = domainUnitId
        }

        public func validate(name: String) throws {
            try self.validate(self.domainUnitId, name: "domainUnitId", parent: name, max: 256)
            try self.validate(self.domainUnitId, name: "domainUnitId", parent: name, min: 1)
            try self.validate(self.domainUnitId, name: "domainUnitId", parent: name, pattern: "^[a-z0-9_\\-]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case domainUnitId = "domainUnitId"
        }
    }

    public struct CreateFormTypeInput: AWSEncodableShape {
        /// The description of this Amazon DataZone metadata form type.
        public let description: String?
        /// The ID of the Amazon DataZone domain in which this metadata form type is created.
        public let domainIdentifier: String
        /// The model of this Amazon DataZone metadata form type.
        public let model: Model
        /// The name of this Amazon DataZone metadata form type.
        public let name: String
        /// The ID of the Amazon DataZone project that owns this metadata form type.
        public let owningProjectIdentifier: String
        /// The status of this Amazon DataZone metadata form type.
        public let status: FormTypeStatus?

        @inlinable
        public init(description: String? = nil, domainIdentifier: String, model: Model, name: String, owningProjectIdentifier: String, status: FormTypeStatus? = nil) {
            self.description = description
            self.domainIdentifier = domainIdentifier
            self.model = model
            self.name = name
            self.owningProjectIdentifier = owningProjectIdentifier
            self.status = status
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.description, forKey: .description)
            request.encodePath(self.domainIdentifier, key: "domainIdentifier")
            try container.encode(self.model, forKey: .model)
            try container.encode(self.name, forKey: .name)
            try container.encode(self.owningProjectIdentifier, forKey: .owningProjectIdentifier)
            try container.encodeIfPresent(self.status, forKey: .status)
        }

        public func validate(name: String) throws {
            try self.validate(self.description, name: "description", parent: name, max: 2048)
            try self.validate(self.domainIdentifier, name: "domainIdentifier", parent: name, pattern: "^dzd[-_][a-zA-Z0-9_-]{1,36}$")
            try self.model.validate(name: "\(name).model")
            try self.validate(self.name, name: "name", parent: name, max: 128)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^(amazon.datazone.)?(?![0-9_])\\w+$|^_\\w*[a-zA-Z0-9]\\w*$")
            try self.validate(self.owningProjectIdentifier, name: "owningProjectIdentifier", parent: name, pattern: "^[a-zA-Z0-9_-]{1,36}$")
        }

        private enum CodingKeys: String, CodingKey {
            case description = "description"
            case model = "model"
            case name = "name"
            case owningProjectIdentifier = "owningProjectIdentifier"
            case status = "status"
        }
    }

    public struct CreateFormTypeOutput: AWSDecodableShape {
        /// The description of this Amazon DataZone metadata form type.
        public let description: String?
        /// The ID of the Amazon DataZone domain in which this metadata form type is created.
        public let domainId: String
        /// The name of this Amazon DataZone metadata form type.
        public let name: String
        /// The ID of the Amazon DataZone domain in which this metadata form type was originally created.
        public let originDomainId: String?
        /// The ID of the project in which this Amazon DataZone metadata form type was originally created.
        public let originProjectId: String?
        /// The ID of the project that owns this Amazon DataZone metadata form type.
        public let owningProjectId: String?
        /// The revision of this Amazon DataZone metadata form type.
        public let revision: String

        @inlinable
        public init(description: String? = nil, domainId: String, name: String, originDomainId: String? = nil, originProjectId: String? = nil, owningProjectId: String? = nil, revision: String) {
            self.description = description
            self.domainId = domainId
            self.name = name
            self.originDomainId = originDomainId
            self.originProjectId = originProjectId
            self.owningProjectId = owningProjectId
            self.revision = revision
        }

        private enum CodingKeys: String, CodingKey {
            case description = "description"
            case domainId = "domainId"
            case name = "name"
            case originDomainId = "originDomainId"
            case originProjectId = "originProjectId"
            case owningProjectId = "owningProjectId"
            case revision = "revision"
        }
    }

    public struct CreateFormTypePolicyGrantDetail: AWSEncodableShape & AWSDecodableShape {
        /// Specifies whether the policy grant is applied to child domain units.
        public let includeChildDomainUnits: Bool?

        @inlinable
        public init(includeChildDomainUnits: Bool? = nil) {
            self.includeChildDomainUnits = includeChildDomainUnits
        }

        private enum CodingKeys: String, CodingKey {
            case includeChildDomainUnits = "includeChildDomainUnits"
        }
    }

    public struct CreateGlossaryInput: AWSEncodableShape {
        /// A unique, case-sensitive identifier that is provided to ensure the idempotency of the request.
        public let clientToken: String?
        /// The description of this business glossary.
        public let description: String?
        /// The ID of the Amazon DataZone domain in which this business glossary is created.
        public let domainIdentifier: String
        /// The name of this business glossary.
        public let name: String
        /// The ID of the project that currently owns business glossary.
        public let owningProjectIdentifier: String
        /// The status of this business glossary.
        public let status: GlossaryStatus?

        @inlinable
        public init(clientToken: String? = CreateGlossaryInput.idempotencyToken(), description: String? = nil, domainIdentifier: String, name: String, owningProjectIdentifier: String, status: GlossaryStatus? = nil) {
            self.clientToken = clientToken
            self.description = description
            self.domainIdentifier = domainIdentifier
            self.name = name
            self.owningProjectIdentifier = owningProjectIdentifier
            self.status = status
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.clientToken, forKey: .clientToken)
            try container.encodeIfPresent(self.description, forKey: .description)
            request.encodePath(self.domainIdentifier, key: "domainIdentifier")
            try container.encode(self.name, forKey: .name)
            try container.encode(self.owningProjectIdentifier, forKey: .owningProjectIdentifier)
            try container.encodeIfPresent(self.status, forKey: .status)
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 128)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "^[\\x21-\\x7E]+$")
            try self.validate(self.description, name: "description", parent: name, max: 4096)
            try self.validate(self.domainIdentifier, name: "domainIdentifier", parent: name, pattern: "^dzd[-_][a-zA-Z0-9_-]{1,36}$")
            try self.validate(self.name, name: "name", parent: name, max: 256)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.owningProjectIdentifier, name: "owningProjectIdentifier", parent: name, pattern: "^[a-zA-Z0-9_-]{1,36}$")
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "clientToken"
            case description = "description"
            case name = "name"
            case owningProjectIdentifier = "owningProjectIdentifier"
            case status = "status"
        }
    }

    public struct CreateGlossaryOutput: AWSDecodableShape {
        /// The description of this business glossary.
        public let description: String?
        /// The ID of the Amazon DataZone domain in which this business glossary is created.
        public let domainId: String
        /// The ID of this business glossary.
        public let id: String
        /// The name of this business glossary.
        public let name: String
        /// The ID of the project that currently owns this business glossary.
        public let owningProjectId: String
        /// The status of this business glossary.
        public let status: GlossaryStatus?

        @inlinable
        public init(description: String? = nil, domainId: String, id: String, name: String, owningProjectId: String, status: GlossaryStatus? = nil) {
            self.description = description
            self.domainId = domainId
            self.id = id
            self.name = name
            self.owningProjectId = owningProjectId
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case description = "description"
            case domainId = "domainId"
            case id = "id"
            case name = "name"
            case owningProjectId = "owningProjectId"
            case status = "status"
        }
    }

    public struct CreateGlossaryPolicyGrantDetail: AWSEncodableShape & AWSDecodableShape {
        /// Specifies whether the policy grant is applied to child domain units.
        public let includeChildDomainUnits: Bool?

        @inlinable
        public init(includeChildDomainUnits: Bool? = nil) {
            self.includeChildDomainUnits = includeChildDomainUnits
        }

        private enum CodingKeys: String, CodingKey {
            case includeChildDomainUnits = "includeChildDomainUnits"
        }
    }

    public struct CreateGlossaryTermInput: AWSEncodableShape {
        /// A unique, case-sensitive identifier that is provided to ensure the idempotency of the request.
        public let clientToken: String?
        /// The ID of the Amazon DataZone domain in which this business glossary term is created.
        public let domainIdentifier: String
        /// The ID of the business glossary in which this term is created.
        public let glossaryIdentifier: String
        /// The long description of this business glossary term.
        public let longDescription: String?
        /// The name of this business glossary term.
        public let name: String
        /// The short description of this business glossary term.
        public let shortDescription: String?
        /// The status of this business glossary term.
        public let status: GlossaryTermStatus?
        /// The term relations of this business glossary term.
        public let termRelations: TermRelations?

        @inlinable
        public init(clientToken: String? = CreateGlossaryTermInput.idempotencyToken(), domainIdentifier: String, glossaryIdentifier: String, longDescription: String? = nil, name: String, shortDescription: String? = nil, status: GlossaryTermStatus? = nil, termRelations: TermRelations? = nil) {
            self.clientToken = clientToken
            self.domainIdentifier = domainIdentifier
            self.glossaryIdentifier = glossaryIdentifier
            self.longDescription = longDescription
            self.name = name
            self.shortDescription = shortDescription
            self.status = status
            self.termRelations = termRelations
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.clientToken, forKey: .clientToken)
            request.encodePath(self.domainIdentifier, key: "domainIdentifier")
            try container.encode(self.glossaryIdentifier, forKey: .glossaryIdentifier)
            try container.encodeIfPresent(self.longDescription, forKey: .longDescription)
            try container.encode(self.name, forKey: .name)
            try container.encodeIfPresent(self.shortDescription, forKey: .shortDescription)
            try container.encodeIfPresent(self.status, forKey: .status)
            try container.encodeIfPresent(self.termRelations, forKey: .termRelations)
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 128)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "^[\\x21-\\x7E]+$")
            try self.validate(self.domainIdentifier, name: "domainIdentifier", parent: name, pattern: "^dzd[-_][a-zA-Z0-9_-]{1,36}$")
            try self.validate(self.glossaryIdentifier, name: "glossaryIdentifier", parent: name, pattern: "^[a-zA-Z0-9_-]{1,36}$")
            try self.validate(self.longDescription, name: "longDescription", parent: name, max: 4096)
            try self.validate(self.name, name: "name", parent: name, max: 256)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.shortDescription, name: "shortDescription", parent: name, max: 1024)
            try self.termRelations?.validate(name: "\(name).termRelations")
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "clientToken"
            case glossaryIdentifier = "glossaryIdentifier"
            case longDescription = "longDescription"
            case name = "name"
            case shortDescription = "shortDescription"
            case status = "status"
            case termRelations = "termRelations"
        }
    }

    public struct CreateGlossaryTermOutput: AWSDecodableShape {
        /// The ID of the Amazon DataZone domain in which this business glossary term is created.
        public let domainId: String
        /// The ID of the business glossary in which this term is created.
        public let glossaryId: String
        /// The ID of this business glossary term.
        public let id: String
        /// The long description of this business glossary term.
        public let longDescription: String?
        /// The name of this business glossary term.
        public let name: String
        /// The short description of this business glossary term.
        public let shortDescription: String?
        /// The status of this business glossary term.
        public let status: GlossaryTermStatus
        /// The term relations of this business glossary term.
        public let termRelations: TermRelations?

        @inlinable
        public init(domainId: String, glossaryId: String, id: String, longDescription: String? = nil, name: String, shortDescription: String? = nil, status: GlossaryTermStatus, termRelations: TermRelations? = nil) {
            self.domainId = domainId
            self.glossaryId = glossaryId
            self.id = id
            self.longDescription = longDescription
            self.name = name
            self.shortDescription = shortDescription
            self.status = status
            self.termRelations = termRelations
        }

        private enum CodingKeys: String, CodingKey {
            case domainId = "domainId"
            case glossaryId = "glossaryId"
            case id = "id"
            case longDescription = "longDescription"
            case name = "name"
            case shortDescription = "shortDescription"
            case status = "status"
            case termRelations = "termRelations"
        }
    }

    public struct CreateGroupProfileInput: AWSEncodableShape {
        ///  A unique, case-sensitive identifier that is provided to ensure the idempotency of the request.
        public let clientToken: String?
        /// The identifier of the Amazon DataZone domain in which the group profile is created.
        public let domainIdentifier: String
        /// The identifier of the group for which the group profile is created.
        public let groupIdentifier: String

        @inlinable
        public init(clientToken: String? = CreateGroupProfileInput.idempotencyToken(), domainIdentifier: String, groupIdentifier: String) {
            self.clientToken = clientToken
            self.domainIdentifier = domainIdentifier
            self.groupIdentifier = groupIdentifier
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.clientToken, forKey: .clientToken)
            request.encodePath(self.domainIdentifier, key: "domainIdentifier")
            try container.encode(self.groupIdentifier, forKey: .groupIdentifier)
        }

        public func validate(name: String) throws {
            try self.validate(self.domainIdentifier, name: "domainIdentifier", parent: name, pattern: "^dzd[-_][a-zA-Z0-9_-]{1,36}$")
            try self.validate(self.groupIdentifier, name: "groupIdentifier", parent: name, pattern: "(^([0-9a-f]{10}-|)[A-Fa-f0-9]{8}-[A-Fa-f0-9]{4}-[A-Fa-f0-9]{4}-[A-Fa-f0-9]{4}-[A-Fa-f0-9]{12}$|[\\p{L}\\p{M}\\p{S}\\p{N}\\p{P}\\t\\n\\r  ]+)")
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "clientToken"
            case groupIdentifier = "groupIdentifier"
        }
    }

    public struct CreateGroupProfileOutput: AWSDecodableShape {
        /// The identifier of the Amazon DataZone domain in which the group profile is created.
        public let domainId: String?
        /// The name of the group for which group profile is created.
        public let groupName: String?
        /// The identifier of the group profile.
        public let id: String?
        /// The status of the group profile.
        public let status: GroupProfileStatus?

        @inlinable
        public init(domainId: String? = nil, groupName: String? = nil, id: String? = nil, status: GroupProfileStatus? = nil) {
            self.domainId = domainId
            self.groupName = groupName
            self.id = id
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case domainId = "domainId"
            case groupName = "groupName"
            case id = "id"
            case status = "status"
        }
    }

    public struct CreateListingChangeSetInput: AWSEncodableShape {
        /// Specifies whether to publish or unpublish a listing.
        public let action: ChangeAction
        /// A unique, case-sensitive identifier that is provided to ensure the idempotency of the request.
        public let clientToken: String?
        /// The ID of the Amazon DataZone domain.
        public let domainIdentifier: String
        /// The ID of the asset.
        public let entityIdentifier: String
        /// The revision of an asset.
        public let entityRevision: String?
        /// The type of an entity.
        public let entityType: EntityType

        @inlinable
        public init(action: ChangeAction, clientToken: String? = CreateListingChangeSetInput.idempotencyToken(), domainIdentifier: String, entityIdentifier: String, entityRevision: String? = nil, entityType: EntityType) {
            self.action = action
            self.clientToken = clientToken
            self.domainIdentifier = domainIdentifier
            self.entityIdentifier = entityIdentifier
            self.entityRevision = entityRevision
            self.entityType = entityType
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encode(self.action, forKey: .action)
            try container.encodeIfPresent(self.clientToken, forKey: .clientToken)
            request.encodePath(self.domainIdentifier, key: "domainIdentifier")
            try container.encode(self.entityIdentifier, forKey: .entityIdentifier)
            try container.encodeIfPresent(self.entityRevision, forKey: .entityRevision)
            try container.encode(self.entityType, forKey: .entityType)
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 128)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "^[\\x21-\\x7E]+$")
            try self.validate(self.domainIdentifier, name: "domainIdentifier", parent: name, pattern: "^dzd[-_][a-zA-Z0-9_-]{1,36}$")
            try self.validate(self.entityIdentifier, name: "entityIdentifier", parent: name, pattern: "^[a-zA-Z0-9_-]{1,36}$")
            try self.validate(self.entityRevision, name: "entityRevision", parent: name, max: 64)
            try self.validate(self.entityRevision, name: "entityRevision", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case action = "action"
            case clientToken = "clientToken"
            case entityIdentifier = "entityIdentifier"
            case entityRevision = "entityRevision"
            case entityType = "entityType"
        }
    }

    public struct CreateListingChangeSetOutput: AWSDecodableShape {
        /// The ID of the listing (a record of an asset at a given time).
        public let listingId: String
        /// The revision of a listing.
        public let listingRevision: String
        /// Specifies the status of the listing.
        public let status: ListingStatus

        @inlinable
        public init(listingId: String, listingRevision: String, status: ListingStatus) {
            self.listingId = listingId
            self.listingRevision = listingRevision
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case listingId = "listingId"
            case listingRevision = "listingRevision"
            case status = "status"
        }
    }

    public struct CreateProjectFromProjectProfilePolicyGrantDetail: AWSEncodableShape & AWSDecodableShape {
        /// Specifies whether to include child domain units when creating a project from project profile policy grant details
        public let includeChildDomainUnits: Bool?
        /// Specifies project profiles when creating a project from project profile policy grant details
        public let projectProfiles: [String]?

        @inlinable
        public init(includeChildDomainUnits: Bool? = nil, projectProfiles: [String]? = nil) {
            self.includeChildDomainUnits = includeChildDomainUnits
            self.projectProfiles = projectProfiles
        }

        private enum CodingKeys: String, CodingKey {
            case includeChildDomainUnits = "includeChildDomainUnits"
            case projectProfiles = "projectProfiles"
        }
    }

    public struct CreateProjectInput: AWSEncodableShape {
        /// The description of the Amazon DataZone project.
        public let description: String?
        /// The ID of the Amazon DataZone domain in which this project is created.
        public let domainIdentifier: String
        /// The ID of the domain unit. This parameter is not required and if it is not specified, then the project is created at the root domain unit level.
        public let domainUnitId: String?
        /// The glossary terms that can be used in this Amazon DataZone project.
        public let glossaryTerms: [String]?
        /// The name of the Amazon DataZone project.
        public let name: String
        /// The ID of the project profile.
        public let projectProfileId: String?
        /// The user parameters of the project.
        public let userParameters: [EnvironmentConfigurationUserParameter]?

        @inlinable
        public init(description: String? = nil, domainIdentifier: String, domainUnitId: String? = nil, glossaryTerms: [String]? = nil, name: String, projectProfileId: String? = nil, userParameters: [EnvironmentConfigurationUserParameter]? = nil) {
            self.description = description
            self.domainIdentifier = domainIdentifier
            self.domainUnitId = domainUnitId
            self.glossaryTerms = glossaryTerms
            self.name = name
            self.projectProfileId = projectProfileId
            self.userParameters = userParameters
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.description, forKey: .description)
            request.encodePath(self.domainIdentifier, key: "domainIdentifier")
            try container.encodeIfPresent(self.domainUnitId, forKey: .domainUnitId)
            try container.encodeIfPresent(self.glossaryTerms, forKey: .glossaryTerms)
            try container.encode(self.name, forKey: .name)
            try container.encodeIfPresent(self.projectProfileId, forKey: .projectProfileId)
            try container.encodeIfPresent(self.userParameters, forKey: .userParameters)
        }

        public func validate(name: String) throws {
            try self.validate(self.description, name: "description", parent: name, max: 2048)
            try self.validate(self.domainIdentifier, name: "domainIdentifier", parent: name, pattern: "^dzd[-_][a-zA-Z0-9_-]{1,36}$")
            try self.validate(self.domainUnitId, name: "domainUnitId", parent: name, max: 256)
            try self.validate(self.domainUnitId, name: "domainUnitId", parent: name, min: 1)
            try self.validate(self.domainUnitId, name: "domainUnitId", parent: name, pattern: "^[a-z0-9_\\-]+$")
            try self.glossaryTerms?.forEach {
                try validate($0, name: "glossaryTerms[]", parent: name, pattern: "^[a-zA-Z0-9_-]{1,36}$")
            }
            try self.validate(self.glossaryTerms, name: "glossaryTerms", parent: name, max: 20)
            try self.validate(self.glossaryTerms, name: "glossaryTerms", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, max: 64)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[\\w -]+$")
            try self.validate(self.projectProfileId, name: "projectProfileId", parent: name, pattern: "^[a-zA-Z0-9_-]{1,36}$")
            try self.userParameters?.forEach {
                try $0.validate(name: "\(name).userParameters[]")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case description = "description"
            case domainUnitId = "domainUnitId"
            case glossaryTerms = "glossaryTerms"
            case name = "name"
            case projectProfileId = "projectProfileId"
            case userParameters = "userParameters"
        }
    }

    public struct CreateProjectMembershipInput: AWSEncodableShape {
        /// The designation of the project membership.
        public let designation: UserDesignation
        /// The ID of the Amazon DataZone domain in which project membership is created.
        public let domainIdentifier: String
        /// The project member whose project membership was created.
        public let member: Member
        /// The ID of the project for which this project membership was created.
        public let projectIdentifier: String

        @inlinable
        public init(designation: UserDesignation, domainIdentifier: String, member: Member, projectIdentifier: String) {
            self.designation = designation
            self.domainIdentifier = domainIdentifier
            self.member = member
            self.projectIdentifier = projectIdentifier
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encode(self.designation, forKey: .designation)
            request.encodePath(self.domainIdentifier, key: "domainIdentifier")
            try container.encode(self.member, forKey: .member)
            request.encodePath(self.projectIdentifier, key: "projectIdentifier")
        }

        public func validate(name: String) throws {
            try self.validate(self.domainIdentifier, name: "domainIdentifier", parent: name, pattern: "^dzd[-_][a-zA-Z0-9_-]{1,36}$")
            try self.validate(self.projectIdentifier, name: "projectIdentifier", parent: name, pattern: "^[a-zA-Z0-9_-]{1,36}$")
        }

        private enum CodingKeys: String, CodingKey {
            case designation = "designation"
            case member = "member"
        }
    }

    public struct CreateProjectMembershipOutput: AWSDecodableShape {
        public init() {}
    }

    public struct CreateProjectOutput: AWSDecodableShape {
        /// The timestamp of when the project was created.
        public let createdAt: Date?
        /// The Amazon DataZone user who created the project.
        public let createdBy: String
        /// The description of the project.
        public let description: String?
        /// The identifier of the Amazon DataZone domain in which the project was created.
        public let domainId: String
        /// The ID of the domain unit.
        public let domainUnitId: String?
        /// The environment deployment details.
        public let environmentDeploymentDetails: EnvironmentDeploymentDetails?
        /// Specifies the error message that is returned if the operation cannot be successfully completed.
        public let failureReasons: [ProjectDeletionError]?
        /// The glossary terms that can be used in the project.
        public let glossaryTerms: [String]?
        /// The ID of the Amazon DataZone project.
        public let id: String
        /// The timestamp of when the project was last updated.
        public let lastUpdatedAt: Date?
        /// The name of the project.
        public let name: String
        /// The project profile ID.
        public let projectProfileId: String?
        /// The status of the Amazon DataZone project that was created.
        public let projectStatus: ProjectStatus?
        /// The user parameters of the project.
        public let userParameters: [EnvironmentConfigurationUserParameter]?

        @inlinable
        public init(createdAt: Date? = nil, createdBy: String, description: String? = nil, domainId: String, domainUnitId: String? = nil, environmentDeploymentDetails: EnvironmentDeploymentDetails? = nil, failureReasons: [ProjectDeletionError]? = nil, glossaryTerms: [String]? = nil, id: String, lastUpdatedAt: Date? = nil, name: String, projectProfileId: String? = nil, projectStatus: ProjectStatus? = nil, userParameters: [EnvironmentConfigurationUserParameter]? = nil) {
            self.createdAt = createdAt
            self.createdBy = createdBy
            self.description = description
            self.domainId = domainId
            self.domainUnitId = domainUnitId
            self.environmentDeploymentDetails = environmentDeploymentDetails
            self.failureReasons = failureReasons
            self.glossaryTerms = glossaryTerms
            self.id = id
            self.lastUpdatedAt = lastUpdatedAt
            self.name = name
            self.projectProfileId = projectProfileId
            self.projectStatus = projectStatus
            self.userParameters = userParameters
        }

        private enum CodingKeys: String, CodingKey {
            case createdAt = "createdAt"
            case createdBy = "createdBy"
            case description = "description"
            case domainId = "domainId"
            case domainUnitId = "domainUnitId"
            case environmentDeploymentDetails = "environmentDeploymentDetails"
            case failureReasons = "failureReasons"
            case glossaryTerms = "glossaryTerms"
            case id = "id"
            case lastUpdatedAt = "lastUpdatedAt"
            case name = "name"
            case projectProfileId = "projectProfileId"
            case projectStatus = "projectStatus"
            case userParameters = "userParameters"
        }
    }

    public struct CreateProjectPolicyGrantDetail: AWSEncodableShape & AWSDecodableShape {
        /// Specifies whether the policy grant is applied to child domain units.
        public let includeChildDomainUnits: Bool?

        @inlinable
        public init(includeChildDomainUnits: Bool? = nil) {
            self.includeChildDomainUnits = includeChildDomainUnits
        }

        private enum CodingKeys: String, CodingKey {
            case includeChildDomainUnits = "includeChildDomainUnits"
        }
    }

    public struct CreateProjectProfileInput: AWSEncodableShape {
        /// A description of a project profile.
        public let description: String?
        /// A domain ID of the project profile.
        public let domainIdentifier: String
        /// A domain unit ID of the project profile.
        public let domainUnitIdentifier: String?
        /// Environment configurations of the project profile.
        public let environmentConfigurations: [EnvironmentConfiguration]?
        /// Project profile name.
        public let name: String
        /// Project profile status.
        public let status: Status?

        @inlinable
        public init(description: String? = nil, domainIdentifier: String, domainUnitIdentifier: String? = nil, environmentConfigurations: [EnvironmentConfiguration]? = nil, name: String, status: Status? = nil) {
            self.description = description
            self.domainIdentifier = domainIdentifier
            self.domainUnitIdentifier = domainUnitIdentifier
            self.environmentConfigurations = environmentConfigurations
            self.name = name
            self.status = status
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.description, forKey: .description)
            request.encodePath(self.domainIdentifier, key: "domainIdentifier")
            try container.encodeIfPresent(self.domainUnitIdentifier, forKey: .domainUnitIdentifier)
            try container.encodeIfPresent(self.environmentConfigurations, forKey: .environmentConfigurations)
            try container.encode(self.name, forKey: .name)
            try container.encodeIfPresent(self.status, forKey: .status)
        }

        public func validate(name: String) throws {
            try self.validate(self.description, name: "description", parent: name, max: 2048)
            try self.validate(self.domainIdentifier, name: "domainIdentifier", parent: name, pattern: "^dzd[-_][a-zA-Z0-9_-]{1,36}$")
            try self.validate(self.domainUnitIdentifier, name: "domainUnitIdentifier", parent: name, max: 256)
            try self.validate(self.domainUnitIdentifier, name: "domainUnitIdentifier", parent: name, min: 1)
            try self.validate(self.domainUnitIdentifier, name: "domainUnitIdentifier", parent: name, pattern: "^[a-z0-9_\\-]+$")
            try self.environmentConfigurations?.forEach {
                try $0.validate(name: "\(name).environmentConfigurations[]")
            }
            try self.validate(self.name, name: "name", parent: name, max: 64)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[\\w -]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case description = "description"
            case domainUnitIdentifier = "domainUnitIdentifier"
            case environmentConfigurations = "environmentConfigurations"
            case name = "name"
            case status = "status"
        }
    }

    public struct CreateProjectProfileOutput: AWSDecodableShape {
        /// A timestamp at which a project profile is created.
        public let createdAt: Date?
        /// A user who created a project profile.
        public let createdBy: String
        /// A project profile description.
        public let description: String?
        /// The ID of the domain where a project profile is created.
        public let domainId: String
        /// The ID of the domain unit where a project profile is created.
        public let domainUnitId: String?
        /// Environment configurations of a project profile.
        public let environmentConfigurations: [EnvironmentConfiguration]?
        /// Project profile ID.
        public let id: String
        /// A timestamp when a project profile was last updated.
        public let lastUpdatedAt: Date?
        /// Project profile name.
        public let name: String
        /// Project profile status.
        public let status: Status?

        @inlinable
        public init(createdAt: Date? = nil, createdBy: String, description: String? = nil, domainId: String, domainUnitId: String? = nil, environmentConfigurations: [EnvironmentConfiguration]? = nil, id: String, lastUpdatedAt: Date? = nil, name: String, status: Status? = nil) {
            self.createdAt = createdAt
            self.createdBy = createdBy
            self.description = description
            self.domainId = domainId
            self.domainUnitId = domainUnitId
            self.environmentConfigurations = environmentConfigurations
            self.id = id
            self.lastUpdatedAt = lastUpdatedAt
            self.name = name
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case createdAt = "createdAt"
            case createdBy = "createdBy"
            case description = "description"
            case domainId = "domainId"
            case domainUnitId = "domainUnitId"
            case environmentConfigurations = "environmentConfigurations"
            case id = "id"
            case lastUpdatedAt = "lastUpdatedAt"
            case name = "name"
            case status = "status"
        }
    }

    public struct CreateRuleInput: AWSEncodableShape {
        /// The action of the rule.
        public let action: RuleAction
        /// A unique, case-sensitive identifier that is provided to ensure the idempotency of the request.
        public let clientToken: String?
        /// The description of the rule.
        public let description: String?
        /// The detail of the rule.
        public let detail: RuleDetail
        /// The ID of the domain where the rule is created.
        public let domainIdentifier: String
        /// The name of the rule.
        public let name: String
        /// The scope of the rule.
        public let scope: RuleScope
        /// The target of the rule.
        public let target: RuleTarget

        @inlinable
        public init(action: RuleAction, clientToken: String? = CreateRuleInput.idempotencyToken(), description: String? = nil, detail: RuleDetail, domainIdentifier: String, name: String, scope: RuleScope, target: RuleTarget) {
            self.action = action
            self.clientToken = clientToken
            self.description = description
            self.detail = detail
            self.domainIdentifier = domainIdentifier
            self.name = name
            self.scope = scope
            self.target = target
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encode(self.action, forKey: .action)
            try container.encodeIfPresent(self.clientToken, forKey: .clientToken)
            try container.encodeIfPresent(self.description, forKey: .description)
            try container.encode(self.detail, forKey: .detail)
            request.encodePath(self.domainIdentifier, key: "domainIdentifier")
            try container.encode(self.name, forKey: .name)
            try container.encode(self.scope, forKey: .scope)
            try container.encode(self.target, forKey: .target)
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 128)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "^[\\x21-\\x7E]+$")
            try self.validate(self.description, name: "description", parent: name, max: 2048)
            try self.detail.validate(name: "\(name).detail")
            try self.validate(self.domainIdentifier, name: "domainIdentifier", parent: name, pattern: "^dzd[-_][a-zA-Z0-9_-]{1,36}$")
            try self.validate(self.name, name: "name", parent: name, max: 256)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[\\w -]+$")
            try self.scope.validate(name: "\(name).scope")
            try self.target.validate(name: "\(name).target")
        }

        private enum CodingKeys: String, CodingKey {
            case action = "action"
            case clientToken = "clientToken"
            case description = "description"
            case detail = "detail"
            case name = "name"
            case scope = "scope"
            case target = "target"
        }
    }

    public struct CreateRuleOutput: AWSDecodableShape {
        /// The action of the rule.
        public let action: RuleAction
        /// The timestamp at which the rule is created.
        public let createdAt: Date
        /// The user who creates the rule.
        public let createdBy: String
        /// The description of the rule.
        public let description: String?
        /// The detail of the rule.
        public let detail: RuleDetail
        /// The ID of the rule.
        public let identifier: String
        /// The name of the rule.
        public let name: String
        /// The type of the rule.
        public let ruleType: RuleType
        /// The scope of the rule.
        public let scope: RuleScope
        /// The target of the rule.
        public let target: RuleTarget
        /// The target type of the rule.
        public let targetType: RuleTargetType?

        @inlinable
        public init(action: RuleAction, createdAt: Date, createdBy: String, description: String? = nil, detail: RuleDetail, identifier: String, name: String, ruleType: RuleType, scope: RuleScope, target: RuleTarget, targetType: RuleTargetType? = nil) {
            self.action = action
            self.createdAt = createdAt
            self.createdBy = createdBy
            self.description = description
            self.detail = detail
            self.identifier = identifier
            self.name = name
            self.ruleType = ruleType
            self.scope = scope
            self.target = target
            self.targetType = targetType
        }

        private enum CodingKeys: String, CodingKey {
            case action = "action"
            case createdAt = "createdAt"
            case createdBy = "createdBy"
            case description = "description"
            case detail = "detail"
            case identifier = "identifier"
            case name = "name"
            case ruleType = "ruleType"
            case scope = "scope"
            case target = "target"
            case targetType = "targetType"
        }
    }

    public struct CreateSubscriptionGrantInput: AWSEncodableShape {
        /// The names of the assets for which the subscription grant is created.
        public let assetTargetNames: [AssetTargetNameMap]?
        /// A unique, case-sensitive identifier that is provided to ensure the idempotency of the request.
        public let clientToken: String?
        /// The ID of the Amazon DataZone domain in which the subscription grant is created.
        public let domainIdentifier: String
        /// The ID of the environment in which the subscription grant is created.
        public let environmentIdentifier: String
        /// The entity to which the subscription is to be granted.
        public let grantedEntity: GrantedEntityInput
        /// The ID of the subscription target for which the subscription grant is created.
        public let subscriptionTargetIdentifier: String?

        @inlinable
        public init(assetTargetNames: [AssetTargetNameMap]? = nil, clientToken: String? = CreateSubscriptionGrantInput.idempotencyToken(), domainIdentifier: String, environmentIdentifier: String, grantedEntity: GrantedEntityInput, subscriptionTargetIdentifier: String? = nil) {
            self.assetTargetNames = assetTargetNames
            self.clientToken = clientToken
            self.domainIdentifier = domainIdentifier
            self.environmentIdentifier = environmentIdentifier
            self.grantedEntity = grantedEntity
            self.subscriptionTargetIdentifier = subscriptionTargetIdentifier
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.assetTargetNames, forKey: .assetTargetNames)
            try container.encodeIfPresent(self.clientToken, forKey: .clientToken)
            request.encodePath(self.domainIdentifier, key: "domainIdentifier")
            try container.encode(self.environmentIdentifier, forKey: .environmentIdentifier)
            try container.encode(self.grantedEntity, forKey: .grantedEntity)
            try container.encodeIfPresent(self.subscriptionTargetIdentifier, forKey: .subscriptionTargetIdentifier)
        }

        public func validate(name: String) throws {
            try self.assetTargetNames?.forEach {
                try $0.validate(name: "\(name).assetTargetNames[]")
            }
            try self.validate(self.domainIdentifier, name: "domainIdentifier", parent: name, pattern: "^dzd[-_][a-zA-Z0-9_-]{1,36}$")
            try self.validate(self.environmentIdentifier, name: "environmentIdentifier", parent: name, pattern: "^[a-zA-Z0-9_-]{1,36}$")
            try self.grantedEntity.validate(name: "\(name).grantedEntity")
            try self.validate(self.subscriptionTargetIdentifier, name: "subscriptionTargetIdentifier", parent: name, pattern: "^[a-zA-Z0-9_-]{1,36}$")
        }

        private enum CodingKeys: String, CodingKey {
            case assetTargetNames = "assetTargetNames"
            case clientToken = "clientToken"
            case environmentIdentifier = "environmentIdentifier"
            case grantedEntity = "grantedEntity"
            case subscriptionTargetIdentifier = "subscriptionTargetIdentifier"
        }
    }

    public struct CreateSubscriptionGrantOutput: AWSDecodableShape {
        /// The assets for which the subscription grant is created.
        public let assets: [SubscribedAsset]?
        /// A timestamp of when the subscription grant is created.
        public let createdAt: Date
        /// The Amazon DataZone user who created the subscription grant.
        public let createdBy: String
        /// The ID of the Amazon DataZone domain in which the subscription grant is created.
        public let domainId: String
        /// The entity to which the subscription is granted.
        public let grantedEntity: GrantedEntity
        /// The ID of the subscription grant.
        public let id: String
        /// The status of the subscription grant.
        public let status: SubscriptionGrantOverallStatus
        /// The identifier of the subscription grant.
        public let subscriptionId: String?
        /// The ID of the subscription target for which the subscription grant is created.
        public let subscriptionTargetId: String
        /// A timestamp of when the subscription grant was updated.
        public let updatedAt: Date
        /// The Amazon DataZone user who updated the subscription grant.
        public let updatedBy: String?

        @inlinable
        public init(assets: [SubscribedAsset]? = nil, createdAt: Date, createdBy: String, domainId: String, grantedEntity: GrantedEntity, id: String, status: SubscriptionGrantOverallStatus, subscriptionTargetId: String, updatedAt: Date, updatedBy: String? = nil) {
            self.assets = assets
            self.createdAt = createdAt
            self.createdBy = createdBy
            self.domainId = domainId
            self.grantedEntity = grantedEntity
            self.id = id
            self.status = status
            self.subscriptionId = nil
            self.subscriptionTargetId = subscriptionTargetId
            self.updatedAt = updatedAt
            self.updatedBy = updatedBy
        }

        @available(*, deprecated, message: "Members subscriptionId have been deprecated")
        @inlinable
        public init(assets: [SubscribedAsset]? = nil, createdAt: Date, createdBy: String, domainId: String, grantedEntity: GrantedEntity, id: String, status: SubscriptionGrantOverallStatus, subscriptionId: String? = nil, subscriptionTargetId: String, updatedAt: Date, updatedBy: String? = nil) {
            self.assets = assets
            self.createdAt = createdAt
            self.createdBy = createdBy
            self.domainId = domainId
            self.grantedEntity = grantedEntity
            self.id = id
            self.status = status
            self.subscriptionId = subscriptionId
            self.subscriptionTargetId = subscriptionTargetId
            self.updatedAt = updatedAt
            self.updatedBy = updatedBy
        }

        private enum CodingKeys: String, CodingKey {
            case assets = "assets"
            case createdAt = "createdAt"
            case createdBy = "createdBy"
            case domainId = "domainId"
            case grantedEntity = "grantedEntity"
            case id = "id"
            case status = "status"
            case subscriptionId = "subscriptionId"
            case subscriptionTargetId = "subscriptionTargetId"
            case updatedAt = "updatedAt"
            case updatedBy = "updatedBy"
        }
    }

    public struct CreateSubscriptionRequestInput: AWSEncodableShape {
        /// A unique, case-sensitive identifier that is provided to ensure the idempotency of the request.
        public let clientToken: String?
        /// The ID of the Amazon DataZone domain in which the subscription request is created.
        public let domainIdentifier: String
        /// The metadata form included in the subscription request.
        public let metadataForms: [FormInput]?
        /// The reason for the subscription request.
        public let requestReason: String
        /// The published asset for which the subscription grant is to be created.
        public let subscribedListings: [SubscribedListingInput]
        /// The Amazon DataZone principals for whom the subscription request is created.
        public let subscribedPrincipals: [SubscribedPrincipalInput]

        @inlinable
        public init(clientToken: String? = CreateSubscriptionRequestInput.idempotencyToken(), domainIdentifier: String, metadataForms: [FormInput]? = nil, requestReason: String, subscribedListings: [SubscribedListingInput], subscribedPrincipals: [SubscribedPrincipalInput]) {
            self.clientToken = clientToken
            self.domainIdentifier = domainIdentifier
            self.metadataForms = metadataForms
            self.requestReason = requestReason
            self.subscribedListings = subscribedListings
            self.subscribedPrincipals = subscribedPrincipals
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.clientToken, forKey: .clientToken)
            request.encodePath(self.domainIdentifier, key: "domainIdentifier")
            try container.encodeIfPresent(self.metadataForms, forKey: .metadataForms)
            try container.encode(self.requestReason, forKey: .requestReason)
            try container.encode(self.subscribedListings, forKey: .subscribedListings)
            try container.encode(self.subscribedPrincipals, forKey: .subscribedPrincipals)
        }

        public func validate(name: String) throws {
            try self.validate(self.domainIdentifier, name: "domainIdentifier", parent: name, pattern: "^dzd[-_][a-zA-Z0-9_-]{1,36}$")
            try self.metadataForms?.forEach {
                try $0.validate(name: "\(name).metadataForms[]")
            }
            try self.validate(self.requestReason, name: "requestReason", parent: name, max: 4096)
            try self.validate(self.requestReason, name: "requestReason", parent: name, min: 1)
            try self.subscribedListings.forEach {
                try $0.validate(name: "\(name).subscribedListings[]")
            }
            try self.validate(self.subscribedListings, name: "subscribedListings", parent: name, max: 1)
            try self.validate(self.subscribedListings, name: "subscribedListings", parent: name, min: 1)
            try self.subscribedPrincipals.forEach {
                try $0.validate(name: "\(name).subscribedPrincipals[]")
            }
            try self.validate(self.subscribedPrincipals, name: "subscribedPrincipals", parent: name, max: 1)
            try self.validate(self.subscribedPrincipals, name: "subscribedPrincipals", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "clientToken"
            case metadataForms = "metadataForms"
            case requestReason = "requestReason"
            case subscribedListings = "subscribedListings"
            case subscribedPrincipals = "subscribedPrincipals"
        }
    }

    public struct CreateSubscriptionRequestOutput: AWSDecodableShape {
        /// A timestamp of when the subscription request is created.
        public let createdAt: Date
        /// The Amazon DataZone user who created the subscription request.
        public let createdBy: String
        /// The decision comment of the subscription request.
        public let decisionComment: String?
        /// The ID of the Amazon DataZone domain in whcih the subscription request is created.
        public let domainId: String
        /// The ID of the existing subscription.
        public let existingSubscriptionId: String?
        /// The ID of the subscription request.
        public let id: String
        /// The metadata form included in the subscription request.
        public let metadataForms: [FormOutput]?
        /// The reason for the subscription request.
        public let requestReason: String
        /// The ID of the reviewer of the subscription request.
        public let reviewerId: String?
        /// The status of the subscription request.
        public let status: SubscriptionRequestStatus
        /// The published asset for which the subscription grant is to be created.
        public let subscribedListings: [SubscribedListing]
        /// The subscribed principals of the subscription request.
        public let subscribedPrincipals: [SubscribedPrincipal]
        /// The timestamp of when the subscription request was updated.
        public let updatedAt: Date
        /// The Amazon DataZone user who updated the subscription request.
        public let updatedBy: String?

        @inlinable
        public init(createdAt: Date, createdBy: String, decisionComment: String? = nil, domainId: String, existingSubscriptionId: String? = nil, id: String, metadataForms: [FormOutput]? = nil, requestReason: String, reviewerId: String? = nil, status: SubscriptionRequestStatus, subscribedListings: [SubscribedListing], subscribedPrincipals: [SubscribedPrincipal], updatedAt: Date, updatedBy: String? = nil) {
            self.createdAt = createdAt
            self.createdBy = createdBy
            self.decisionComment = decisionComment
            self.domainId = domainId
            self.existingSubscriptionId = existingSubscriptionId
            self.id = id
            self.metadataForms = metadataForms
            self.requestReason = requestReason
            self.reviewerId = reviewerId
            self.status = status
            self.subscribedListings = subscribedListings
            self.subscribedPrincipals = subscribedPrincipals
            self.updatedAt = updatedAt
            self.updatedBy = updatedBy
        }

        private enum CodingKeys: String, CodingKey {
            case createdAt = "createdAt"
            case createdBy = "createdBy"
            case decisionComment = "decisionComment"
            case domainId = "domainId"
            case existingSubscriptionId = "existingSubscriptionId"
            case id = "id"
            case metadataForms = "metadataForms"
            case requestReason = "requestReason"
            case reviewerId = "reviewerId"
            case status = "status"
            case subscribedListings = "subscribedListings"
            case subscribedPrincipals = "subscribedPrincipals"
            case updatedAt = "updatedAt"
            case updatedBy = "updatedBy"
        }
    }

    public struct CreateSubscriptionTargetInput: AWSEncodableShape {
        /// The asset types that can be included in the subscription target.
        public let applicableAssetTypes: [String]
        /// The authorized principals of the subscription target.
        public let authorizedPrincipals: [String]
        /// A unique, case-sensitive identifier that is provided to ensure the idempotency of the request.
        public let clientToken: String?
        /// The ID of the Amazon DataZone domain in which subscription target is created.
        public let domainIdentifier: String
        /// The ID of the environment in which subscription target is created.
        public let environmentIdentifier: String
        /// The manage access role that is used to create the subscription target.
        public let manageAccessRole: String
        /// The name of the subscription target.
        public let name: String
        /// The provider of the subscription target.
        public let provider: String?
        /// The configuration of the subscription target.
        public let subscriptionTargetConfig: [SubscriptionTargetForm]
        /// The type of the subscription target.
        public let type: String

        @inlinable
        public init(applicableAssetTypes: [String], authorizedPrincipals: [String], clientToken: String? = CreateSubscriptionTargetInput.idempotencyToken(), domainIdentifier: String, environmentIdentifier: String, manageAccessRole: String, name: String, provider: String? = nil, subscriptionTargetConfig: [SubscriptionTargetForm], type: String) {
            self.applicableAssetTypes = applicableAssetTypes
            self.authorizedPrincipals = authorizedPrincipals
            self.clientToken = clientToken
            self.domainIdentifier = domainIdentifier
            self.environmentIdentifier = environmentIdentifier
            self.manageAccessRole = manageAccessRole
            self.name = name
            self.provider = provider
            self.subscriptionTargetConfig = subscriptionTargetConfig
            self.type = type
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encode(self.applicableAssetTypes, forKey: .applicableAssetTypes)
            try container.encode(self.authorizedPrincipals, forKey: .authorizedPrincipals)
            try container.encodeIfPresent(self.clientToken, forKey: .clientToken)
            request.encodePath(self.domainIdentifier, key: "domainIdentifier")
            request.encodePath(self.environmentIdentifier, key: "environmentIdentifier")
            try container.encode(self.manageAccessRole, forKey: .manageAccessRole)
            try container.encode(self.name, forKey: .name)
            try container.encodeIfPresent(self.provider, forKey: .provider)
            try container.encode(self.subscriptionTargetConfig, forKey: .subscriptionTargetConfig)
            try container.encode(self.type, forKey: .type)
        }

        public func validate(name: String) throws {
            try self.applicableAssetTypes.forEach {
                try validate($0, name: "applicableAssetTypes[]", parent: name, max: 256)
                try validate($0, name: "applicableAssetTypes[]", parent: name, min: 1)
                try validate($0, name: "applicableAssetTypes[]", parent: name, pattern: "^[^\\.]*")
            }
            try self.authorizedPrincipals.forEach {
                try validate($0, name: "authorizedPrincipals[]", parent: name, pattern: "^[a-zA-Z0-9:/._-]*$")
            }
            try self.validate(self.authorizedPrincipals, name: "authorizedPrincipals", parent: name, max: 20)
            try self.validate(self.authorizedPrincipals, name: "authorizedPrincipals", parent: name, min: 1)
            try self.validate(self.domainIdentifier, name: "domainIdentifier", parent: name, pattern: "^dzd[-_][a-zA-Z0-9_-]{1,36}$")
            try self.validate(self.environmentIdentifier, name: "environmentIdentifier", parent: name, pattern: "^[a-zA-Z0-9_-]{1,36}$")
            try self.validate(self.manageAccessRole, name: "manageAccessRole", parent: name, pattern: "^arn:aws(|-cn|-us-gov):iam::\\d{12}:(role|role/service-role)/[\\w+=,.@-]*$")
            try self.validate(self.name, name: "name", parent: name, max: 256)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.subscriptionTargetConfig.forEach {
                try $0.validate(name: "\(name).subscriptionTargetConfig[]")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case applicableAssetTypes = "applicableAssetTypes"
            case authorizedPrincipals = "authorizedPrincipals"
            case clientToken = "clientToken"
            case manageAccessRole = "manageAccessRole"
            case name = "name"
            case provider = "provider"
            case subscriptionTargetConfig = "subscriptionTargetConfig"
            case type = "type"
        }
    }

    public struct CreateSubscriptionTargetOutput: AWSDecodableShape {
        /// The asset types that can be included in the subscription target.
        public let applicableAssetTypes: [String]
        /// The authorised principals of the subscription target.
        public let authorizedPrincipals: [String]
        /// The timestamp of when the subscription target was created.
        public let createdAt: Date
        /// The Amazon DataZone user who created the subscription target.
        public let createdBy: String
        /// The ID of the Amazon DataZone domain in which the subscription target was created.
        public let domainId: String
        /// The ID of the environment in which the subscription target was created.
        public let environmentId: String
        /// The ID of the subscription target.
        public let id: String
        /// The manage access role with which the subscription target was created.
        public let manageAccessRole: String?
        /// The name of the subscription target.
        public let name: String
        /// ???
        public let projectId: String
        /// The provider of the subscription target.
        public let provider: String
        /// The configuration of the subscription target.
        public let subscriptionTargetConfig: [SubscriptionTargetForm]
        /// The type of the subscription target.
        public let type: String
        /// The timestamp of when the subscription target was updated.
        public let updatedAt: Date?
        /// The Amazon DataZone user who updated the subscription target.
        public let updatedBy: String?

        @inlinable
        public init(applicableAssetTypes: [String], authorizedPrincipals: [String], createdAt: Date, createdBy: String, domainId: String, environmentId: String, id: String, manageAccessRole: String? = nil, name: String, projectId: String, provider: String, subscriptionTargetConfig: [SubscriptionTargetForm], type: String, updatedAt: Date? = nil, updatedBy: String? = nil) {
            self.applicableAssetTypes = applicableAssetTypes
            self.authorizedPrincipals = authorizedPrincipals
            self.createdAt = createdAt
            self.createdBy = createdBy
            self.domainId = domainId
            self.environmentId = environmentId
            self.id = id
            self.manageAccessRole = manageAccessRole
            self.name = name
            self.projectId = projectId
            self.provider = provider
            self.subscriptionTargetConfig = subscriptionTargetConfig
            self.type = type
            self.updatedAt = updatedAt
            self.updatedBy = updatedBy
        }

        private enum CodingKeys: String, CodingKey {
            case applicableAssetTypes = "applicableAssetTypes"
            case authorizedPrincipals = "authorizedPrincipals"
            case createdAt = "createdAt"
            case createdBy = "createdBy"
            case domainId = "domainId"
            case environmentId = "environmentId"
            case id = "id"
            case manageAccessRole = "manageAccessRole"
            case name = "name"
            case projectId = "projectId"
            case provider = "provider"
            case subscriptionTargetConfig = "subscriptionTargetConfig"
            case type = "type"
            case updatedAt = "updatedAt"
            case updatedBy = "updatedBy"
        }
    }

    public struct CreateUserProfileInput: AWSEncodableShape {
        /// A unique, case-sensitive identifier that is provided to ensure the idempotency of the request.
        public let clientToken: String?
        /// The identifier of the Amazon DataZone domain in which a user profile is created.
        public let domainIdentifier: String
        /// The identifier of the user for which the user profile is created.
        public let userIdentifier: String
        /// The user type of the user for which the user profile is created.
        public let userType: UserType?

        @inlinable
        public init(clientToken: String? = CreateUserProfileInput.idempotencyToken(), domainIdentifier: String, userIdentifier: String, userType: UserType? = nil) {
            self.clientToken = clientToken
            self.domainIdentifier = domainIdentifier
            self.userIdentifier = userIdentifier
            self.userType = userType
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.clientToken, forKey: .clientToken)
            request.encodePath(self.domainIdentifier, key: "domainIdentifier")
            try container.encode(self.userIdentifier, forKey: .userIdentifier)
            try container.encodeIfPresent(self.userType, forKey: .userType)
        }

        public func validate(name: String) throws {
            try self.validate(self.domainIdentifier, name: "domainIdentifier", parent: name, pattern: "^dzd[-_][a-zA-Z0-9_-]{1,36}$")
            try self.validate(self.userIdentifier, name: "userIdentifier", parent: name, pattern: "(^([0-9a-f]{10}-|)[A-Fa-f0-9]{8}-[A-Fa-f0-9]{4}-[A-Fa-f0-9]{4}-[A-Fa-f0-9]{4}-[A-Fa-f0-9]{12}$|^[a-zA-Z_0-9+=,.@-]+$|^arn:aws:iam::\\d{12}:.+$)")
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "clientToken"
            case userIdentifier = "userIdentifier"
            case userType = "userType"
        }
    }

    public struct CreateUserProfileOutput: AWSDecodableShape {
        public let details: UserProfileDetails?
        /// The identifier of the Amazon DataZone domain in which a user profile is created.
        public let domainId: String?
        /// The identifier of the user profile.
        public let id: String?
        /// The status of the user profile.
        public let status: UserProfileStatus?
        /// The type of the user profile.
        public let type: UserProfileType?

        @inlinable
        public init(details: UserProfileDetails? = nil, domainId: String? = nil, id: String? = nil, status: UserProfileStatus? = nil, type: UserProfileType? = nil) {
            self.details = details
            self.domainId = domainId
            self.id = id
            self.status = status
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case details = "details"
            case domainId = "domainId"
            case id = "id"
            case status = "status"
            case type = "type"
        }
    }

    public struct CustomParameter: AWSDecodableShape {
        /// The default value of the parameter.
        public let defaultValue: String?
        /// The description of the parameter.
        public let description: String?
        /// The filed type of the parameter.
        public let fieldType: String
        /// Specifies whether the parameter is editable.
        public let isEditable: Bool?
        /// Specifies whether the custom parameter is optional.
        public let isOptional: Bool?
        /// The key name of the parameter.
        public let keyName: String

        @inlinable
        public init(defaultValue: String? = nil, description: String? = nil, fieldType: String, isEditable: Bool? = nil, isOptional: Bool? = nil, keyName: String) {
            self.defaultValue = defaultValue
            self.description = description
            self.fieldType = fieldType
            self.isEditable = isEditable
            self.isOptional = isOptional
            self.keyName = keyName
        }

        private enum CodingKeys: String, CodingKey {
            case defaultValue = "defaultValue"
            case description = "description"
            case fieldType = "fieldType"
            case isEditable = "isEditable"
            case isOptional = "isOptional"
            case keyName = "keyName"
        }
    }

    public struct DataProductItem: AWSEncodableShape & AWSDecodableShape {
        /// The glossary terms of the data product.
        public let glossaryTerms: [String]?
        /// The ID of the data product.
        public let identifier: String
        /// The type of the data product.
        public let itemType: DataProductItemType
        /// The revision of the data product.
        public let revision: String?

        @inlinable
        public init(glossaryTerms: [String]? = nil, identifier: String, itemType: DataProductItemType, revision: String? = nil) {
            self.glossaryTerms = glossaryTerms
            self.identifier = identifier
            self.itemType = itemType
            self.revision = revision
        }

        public func validate(name: String) throws {
            try self.glossaryTerms?.forEach {
                try validate($0, name: "glossaryTerms[]", parent: name, pattern: "^[a-zA-Z0-9_-]{1,36}$")
            }
            try self.validate(self.glossaryTerms, name: "glossaryTerms", parent: name, max: 2)
            try self.validate(self.glossaryTerms, name: "glossaryTerms", parent: name, min: 1)
            try self.validate(self.identifier, name: "identifier", parent: name, pattern: "^[a-zA-Z0-9_-]{1,36}$")
            try self.validate(self.revision, name: "revision", parent: name, max: 64)
            try self.validate(self.revision, name: "revision", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case glossaryTerms = "glossaryTerms"
            case identifier = "identifier"
            case itemType = "itemType"
            case revision = "revision"
        }
    }

    public struct DataProductListing: AWSDecodableShape {
        /// The timestamp at which the data product listing was created.
        public let createdAt: Date?
        /// The ID of the data product listing.
        public let dataProductId: String?
        /// The revision of the data product listing.
        public let dataProductRevision: String?
        /// The metadata forms of the data product listing.
        public let forms: String?
        /// The glossary terms of the data product listing.
        public let glossaryTerms: [DetailedGlossaryTerm]?
        /// The data assets of the data product listing.
        public let items: [ListingSummary]?
        /// The ID of the owning project of the data product listing.
        public let owningProjectId: String?

        @inlinable
        public init(createdAt: Date? = nil, dataProductId: String? = nil, dataProductRevision: String? = nil, forms: String? = nil, glossaryTerms: [DetailedGlossaryTerm]? = nil, items: [ListingSummary]? = nil, owningProjectId: String? = nil) {
            self.createdAt = createdAt
            self.dataProductId = dataProductId
            self.dataProductRevision = dataProductRevision
            self.forms = forms
            self.glossaryTerms = glossaryTerms
            self.items = items
            self.owningProjectId = owningProjectId
        }

        private enum CodingKeys: String, CodingKey {
            case createdAt = "createdAt"
            case dataProductId = "dataProductId"
            case dataProductRevision = "dataProductRevision"
            case forms = "forms"
            case glossaryTerms = "glossaryTerms"
            case items = "items"
            case owningProjectId = "owningProjectId"
        }
    }

    public struct DataProductListingItem: AWSDecodableShape {
        /// The additional attributes of the asset of the data product.
        public let additionalAttributes: DataProductListingItemAdditionalAttributes?
        /// The timestamp at which the asset of the data product listing was created.
        public let createdAt: Date?
        /// The description of the asset of the asset of the data product.
        public let description: String?
        /// The entity ID of the asset of the asset of the data product.
        public let entityId: String?
        /// The revision of the asset of the asset of the data product.
        public let entityRevision: String?
        /// The glossary terms of the asset of the asset of the data product.
        public let glossaryTerms: [DetailedGlossaryTerm]?
        /// The data of the asset of the data product.
        public let items: [ListingSummaryItem]?
        /// The timestamp at which the listing was created.
        public let listingCreatedBy: String?
        /// The ID of the listing.
        public let listingId: String?
        /// The revision of the listing.
        public let listingRevision: String?
        /// The user who updated the listing.
        public let listingUpdatedBy: String?
        /// The name of the asset of the data product.
        public let name: String?
        /// The ID of the owning project of the asset of the data product.
        public let owningProjectId: String?

        @inlinable
        public init(additionalAttributes: DataProductListingItemAdditionalAttributes? = nil, createdAt: Date? = nil, description: String? = nil, entityId: String? = nil, entityRevision: String? = nil, glossaryTerms: [DetailedGlossaryTerm]? = nil, items: [ListingSummaryItem]? = nil, listingCreatedBy: String? = nil, listingId: String? = nil, listingRevision: String? = nil, listingUpdatedBy: String? = nil, name: String? = nil, owningProjectId: String? = nil) {
            self.additionalAttributes = additionalAttributes
            self.createdAt = createdAt
            self.description = description
            self.entityId = entityId
            self.entityRevision = entityRevision
            self.glossaryTerms = glossaryTerms
            self.items = items
            self.listingCreatedBy = listingCreatedBy
            self.listingId = listingId
            self.listingRevision = listingRevision
            self.listingUpdatedBy = listingUpdatedBy
            self.name = name
            self.owningProjectId = owningProjectId
        }

        private enum CodingKeys: String, CodingKey {
            case additionalAttributes = "additionalAttributes"
            case createdAt = "createdAt"
            case description = "description"
            case entityId = "entityId"
            case entityRevision = "entityRevision"
            case glossaryTerms = "glossaryTerms"
            case items = "items"
            case listingCreatedBy = "listingCreatedBy"
            case listingId = "listingId"
            case listingRevision = "listingRevision"
            case listingUpdatedBy = "listingUpdatedBy"
            case name = "name"
            case owningProjectId = "owningProjectId"
        }
    }

    public struct DataProductListingItemAdditionalAttributes: AWSDecodableShape {
        /// The metadata forms of the asset of the data product.
        public let forms: String?

        @inlinable
        public init(forms: String? = nil) {
            self.forms = forms
        }

        private enum CodingKeys: String, CodingKey {
            case forms = "forms"
        }
    }

    public struct DataProductResultItem: AWSDecodableShape {
        /// The timestamp at which the data product was created.
        public let createdAt: Date?
        /// The user who created the data product.
        public let createdBy: String?
        /// The description of the data product.
        public let description: String?
        /// The ID of the domain where the data product lives.
        public let domainId: String
        /// The timestamp at which first revision of the data product was created.
        public let firstRevisionCreatedAt: Date?
        /// The user who created the first revision of the data product.
        public let firstRevisionCreatedBy: String?
        /// The glossary terms of the data product.
        public let glossaryTerms: [String]?
        /// The ID of the data product.
        public let id: String
        /// The name of the data product.
        public let name: String
        /// The ID of the owning project of the data product.
        public let owningProjectId: String

        @inlinable
        public init(createdAt: Date? = nil, createdBy: String? = nil, description: String? = nil, domainId: String, firstRevisionCreatedAt: Date? = nil, firstRevisionCreatedBy: String? = nil, glossaryTerms: [String]? = nil, id: String, name: String, owningProjectId: String) {
            self.createdAt = createdAt
            self.createdBy = createdBy
            self.description = description
            self.domainId = domainId
            self.firstRevisionCreatedAt = firstRevisionCreatedAt
            self.firstRevisionCreatedBy = firstRevisionCreatedBy
            self.glossaryTerms = glossaryTerms
            self.id = id
            self.name = name
            self.owningProjectId = owningProjectId
        }

        private enum CodingKeys: String, CodingKey {
            case createdAt = "createdAt"
            case createdBy = "createdBy"
            case description = "description"
            case domainId = "domainId"
            case firstRevisionCreatedAt = "firstRevisionCreatedAt"
            case firstRevisionCreatedBy = "firstRevisionCreatedBy"
            case glossaryTerms = "glossaryTerms"
            case id = "id"
            case name = "name"
            case owningProjectId = "owningProjectId"
        }
    }

    public struct DataProductRevision: AWSDecodableShape {
        /// The timestamp at which the data product revision was created.
        public let createdAt: Date?
        /// The user who created the data product revision.
        public let createdBy: String?
        /// The ID of the domain where the data product revision lives.
        public let domainId: String?
        /// The ID of the data product revision.
        public let id: String?
        /// The data product revision.
        public let revision: String?

        @inlinable
        public init(createdAt: Date? = nil, createdBy: String? = nil, domainId: String? = nil, id: String? = nil, revision: String? = nil) {
            self.createdAt = createdAt
            self.createdBy = createdBy
            self.domainId = domainId
            self.id = id
            self.revision = revision
        }

        private enum CodingKeys: String, CodingKey {
            case createdAt = "createdAt"
            case createdBy = "createdBy"
            case domainId = "domainId"
            case id = "id"
            case revision = "revision"
        }
    }

    public struct DataSourceErrorMessage: AWSDecodableShape {
        /// The details of the error message that is returned if the operation cannot be successfully completed.
        public let errorDetail: String?
        /// The type of the error message that is returned if the operation cannot be successfully completed.
        public let errorType: DataSourceErrorType

        @inlinable
        public init(errorDetail: String? = nil, errorType: DataSourceErrorType) {
            self.errorDetail = errorDetail
            self.errorType = errorType
        }

        private enum CodingKeys: String, CodingKey {
            case errorDetail = "errorDetail"
            case errorType = "errorType"
        }
    }

    public struct DataSourceRunActivity: AWSDecodableShape {
        /// The timestamp of when data source run activity was created.
        @CustomCoding<ISO8601DateCoder>
        public var createdAt: Date
        /// The identifier of the asset included in the data source run activity.
        public let dataAssetId: String?
        /// The status of the asset included in the data source run activity.
        public let dataAssetStatus: DataAssetActivityStatus
        /// The database included in the data source run activity.
        public let database: String
        /// The identifier of the data source for the data source run activity.
        public let dataSourceRunId: String
        public let errorMessage: DataSourceErrorMessage?
        /// The data lineage summary.
        public let lineageSummary: LineageInfo?
        /// The project ID included in the data source run activity.
        public let projectId: String
        /// The technical description included in the data source run activity.
        public let technicalDescription: String?
        /// The technical name included in the data source run activity.
        public let technicalName: String
        /// The timestamp of when data source run activity was updated.
        @CustomCoding<ISO8601DateCoder>
        public var updatedAt: Date

        @inlinable
        public init(createdAt: Date, dataAssetId: String? = nil, dataAssetStatus: DataAssetActivityStatus, database: String, dataSourceRunId: String, errorMessage: DataSourceErrorMessage? = nil, lineageSummary: LineageInfo? = nil, projectId: String, technicalDescription: String? = nil, technicalName: String, updatedAt: Date) {
            self.createdAt = createdAt
            self.dataAssetId = dataAssetId
            self.dataAssetStatus = dataAssetStatus
            self.database = database
            self.dataSourceRunId = dataSourceRunId
            self.errorMessage = errorMessage
            self.lineageSummary = lineageSummary
            self.projectId = projectId
            self.technicalDescription = technicalDescription
            self.technicalName = technicalName
            self.updatedAt = updatedAt
        }

        private enum CodingKeys: String, CodingKey {
            case createdAt = "createdAt"
            case dataAssetId = "dataAssetId"
            case dataAssetStatus = "dataAssetStatus"
            case database = "database"
            case dataSourceRunId = "dataSourceRunId"
            case errorMessage = "errorMessage"
            case lineageSummary = "lineageSummary"
            case projectId = "projectId"
            case technicalDescription = "technicalDescription"
            case technicalName = "technicalName"
            case updatedAt = "updatedAt"
        }
    }

    public struct DataSourceRunLineageSummary: AWSDecodableShape {
        /// The import status that's part of the run lineage summary of a data source.
        public let importStatus: LineageImportStatus?

        @inlinable
        public init(importStatus: LineageImportStatus? = nil) {
            self.importStatus = importStatus
        }

        private enum CodingKeys: String, CodingKey {
            case importStatus = "importStatus"
        }
    }

    public struct DataSourceRunSummary: AWSDecodableShape {
        /// The timestamp of when a data source run was created.
        @CustomCoding<ISO8601DateCoder>
        public var createdAt: Date
        /// The identifier of the data source of the data source run.
        public let dataSourceId: String
        public let errorMessage: DataSourceErrorMessage?
        /// The identifier of the data source run.
        public let id: String
        /// The run lineage summary of a data source.
        public let lineageSummary: DataSourceRunLineageSummary?
        /// The project ID of the data source run.
        public let projectId: String
        public let runStatisticsForAssets: RunStatisticsForAssets?
        /// The timestamp of when a data source run was started.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var startedAt: Date?
        /// The status of the data source run.
        public let status: DataSourceRunStatus
        /// The timestamp of when a data source run was stopped.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var stoppedAt: Date?
        /// The type of the data source run.
        public let type: DataSourceRunType
        /// The timestamp of when a data source run was updated.
        @CustomCoding<ISO8601DateCoder>
        public var updatedAt: Date

        @inlinable
        public init(createdAt: Date, dataSourceId: String, errorMessage: DataSourceErrorMessage? = nil, id: String, lineageSummary: DataSourceRunLineageSummary? = nil, projectId: String, runStatisticsForAssets: RunStatisticsForAssets? = nil, startedAt: Date? = nil, status: DataSourceRunStatus, stoppedAt: Date? = nil, type: DataSourceRunType, updatedAt: Date) {
            self.createdAt = createdAt
            self.dataSourceId = dataSourceId
            self.errorMessage = errorMessage
            self.id = id
            self.lineageSummary = lineageSummary
            self.projectId = projectId
            self.runStatisticsForAssets = runStatisticsForAssets
            self.startedAt = startedAt
            self.status = status
            self.stoppedAt = stoppedAt
            self.type = type
            self.updatedAt = updatedAt
        }

        private enum CodingKeys: String, CodingKey {
            case createdAt = "createdAt"
            case dataSourceId = "dataSourceId"
            case errorMessage = "errorMessage"
            case id = "id"
            case lineageSummary = "lineageSummary"
            case projectId = "projectId"
            case runStatisticsForAssets = "runStatisticsForAssets"
            case startedAt = "startedAt"
            case status = "status"
            case stoppedAt = "stoppedAt"
            case type = "type"
            case updatedAt = "updatedAt"
        }
    }

    public struct DataSourceSummary: AWSDecodableShape {
        /// The connection ID that's part of the data source summary.
        public let connectionId: String?
        /// The timestamp of when the data source was created.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var createdAt: Date?
        /// The ID of the data source.
        public let dataSourceId: String
        /// The data source description.
        public let description: String?
        /// The ID of the Amazon DataZone domain in which the data source exists.
        public let domainId: String
        /// Specifies whether the data source is enabled.
        public let enableSetting: EnableSetting?
        /// The ID of the environment in which the data source exists.
        public let environmentId: String?
        /// The count of the assets created during the last data source run.
        public let lastRunAssetCount: Int?
        /// The timestamp of when the data source run was last performed.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var lastRunAt: Date?
        public let lastRunErrorMessage: DataSourceErrorMessage?
        /// The status of the last data source run.
        public let lastRunStatus: DataSourceRunStatus?
        /// The name of the data source.
        public let name: String
        public let schedule: ScheduleConfiguration?
        /// The status of the data source.
        public let status: DataSourceStatus
        /// The type of the data source.
        public let type: String
        /// The timestamp of when the data source was updated.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var updatedAt: Date?

        @inlinable
        public init(connectionId: String? = nil, createdAt: Date? = nil, dataSourceId: String, description: String? = nil, domainId: String, enableSetting: EnableSetting? = nil, environmentId: String? = nil, lastRunAssetCount: Int? = nil, lastRunAt: Date? = nil, lastRunErrorMessage: DataSourceErrorMessage? = nil, lastRunStatus: DataSourceRunStatus? = nil, name: String, schedule: ScheduleConfiguration? = nil, status: DataSourceStatus, type: String, updatedAt: Date? = nil) {
            self.connectionId = connectionId
            self.createdAt = createdAt
            self.dataSourceId = dataSourceId
            self.description = description
            self.domainId = domainId
            self.enableSetting = enableSetting
            self.environmentId = environmentId
            self.lastRunAssetCount = lastRunAssetCount
            self.lastRunAt = lastRunAt
            self.lastRunErrorMessage = lastRunErrorMessage
            self.lastRunStatus = lastRunStatus
            self.name = name
            self.schedule = schedule
            self.status = status
            self.type = type
            self.updatedAt = updatedAt
        }

        private enum CodingKeys: String, CodingKey {
            case connectionId = "connectionId"
            case createdAt = "createdAt"
            case dataSourceId = "dataSourceId"
            case description = "description"
            case domainId = "domainId"
            case enableSetting = "enableSetting"
            case environmentId = "environmentId"
            case lastRunAssetCount = "lastRunAssetCount"
            case lastRunAt = "lastRunAt"
            case lastRunErrorMessage = "lastRunErrorMessage"
            case lastRunStatus = "lastRunStatus"
            case name = "name"
            case schedule = "schedule"
            case status = "status"
            case type = "type"
            case updatedAt = "updatedAt"
        }
    }

    public struct DeleteAssetFilterInput: AWSEncodableShape {
        /// The ID of the data asset.
        public let assetIdentifier: String
        /// The ID of the domain where you want to delete an asset filter.
        public let domainIdentifier: String
        /// The ID of the asset filter that you want to delete.
        public let identifier: String

        @inlinable
        public init(assetIdentifier: String, domainIdentifier: String, identifier: String) {
            self.assetIdentifier = assetIdentifier
            self.domainIdentifier = domainIdentifier
            self.identifier = identifier
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.assetIdentifier, key: "assetIdentifier")
            request.encodePath(self.domainIdentifier, key: "domainIdentifier")
            request.encodePath(self.identifier, key: "identifier")
        }

        public func validate(name: String) throws {
            try self.validate(self.assetIdentifier, name: "assetIdentifier", parent: name, pattern: "^[a-zA-Z0-9_-]{1,36}$")
            try self.validate(self.domainIdentifier, name: "domainIdentifier", parent: name, pattern: "^dzd[-_][a-zA-Z0-9_-]{1,36}$")
            try self.validate(self.identifier, name: "identifier", parent: name, pattern: "^[a-zA-Z0-9_-]{1,36}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteAssetInput: AWSEncodableShape {
        /// The ID of the Amazon DataZone domain in which the asset is deleted.
        public let domainIdentifier: String
        /// The identifier of the asset that is deleted.
        public let identifier: String

        @inlinable
        public init(domainIdentifier: String, identifier: String) {
            self.domainIdentifier = domainIdentifier
            self.identifier = identifier
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.domainIdentifier, key: "domainIdentifier")
            request.encodePath(self.identifier, key: "identifier")
        }

        public func validate(name: String) throws {
            try self.validate(self.domainIdentifier, name: "domainIdentifier", parent: name, pattern: "^dzd[-_][a-zA-Z0-9_-]{1,36}$")
            try self.validate(self.identifier, name: "identifier", parent: name, pattern: "^[a-zA-Z0-9_-]{1,36}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteAssetOutput: AWSDecodableShape {
        public init() {}
    }

    public struct DeleteAssetTypeInput: AWSEncodableShape {
        /// The ID of the Amazon DataZone domain in which the asset type is deleted.
        public let domainIdentifier: String
        /// The identifier of the asset type that is deleted.
        public let identifier: String

        @inlinable
        public init(domainIdentifier: String, identifier: String) {
            self.domainIdentifier = domainIdentifier
            self.identifier = identifier
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.domainIdentifier, key: "domainIdentifier")
            request.encodePath(self.identifier, key: "identifier")
        }

        public func validate(name: String) throws {
            try self.validate(self.domainIdentifier, name: "domainIdentifier", parent: name, pattern: "^dzd[-_][a-zA-Z0-9_-]{1,36}$")
            try self.validate(self.identifier, name: "identifier", parent: name, max: 513)
            try self.validate(self.identifier, name: "identifier", parent: name, min: 1)
            try self.validate(self.identifier, name: "identifier", parent: name, pattern: "^(?!\\.)[\\w\\.]*\\w$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteAssetTypeOutput: AWSDecodableShape {
        public init() {}
    }

    public struct DeleteConnectionInput: AWSEncodableShape {
        /// The ID of the domain where the connection is deleted.
        public let domainIdentifier: String
        /// The ID of the connection that is deleted.
        public let identifier: String

        @inlinable
        public init(domainIdentifier: String, identifier: String) {
            self.domainIdentifier = domainIdentifier
            self.identifier = identifier
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.domainIdentifier, key: "domainIdentifier")
            request.encodePath(self.identifier, key: "identifier")
        }

        public func validate(name: String) throws {
            try self.validate(self.domainIdentifier, name: "domainIdentifier", parent: name, pattern: "^dzd[-_][a-zA-Z0-9_-]{1,36}$")
            try self.validate(self.identifier, name: "identifier", parent: name, max: 128)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteConnectionOutput: AWSDecodableShape {
        /// The status of the action.
        public let status: String?

        @inlinable
        public init(status: String? = nil) {
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case status = "status"
        }
    }

    public struct DeleteDataProductInput: AWSEncodableShape {
        /// The ID of the Amazon DataZone domain in which the data product is deleted.
        public let domainIdentifier: String
        /// The identifier of the data product that is deleted.
        public let identifier: String

        @inlinable
        public init(domainIdentifier: String, identifier: String) {
            self.domainIdentifier = domainIdentifier
            self.identifier = identifier
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.domainIdentifier, key: "domainIdentifier")
            request.encodePath(self.identifier, key: "identifier")
        }

        public func validate(name: String) throws {
            try self.validate(self.domainIdentifier, name: "domainIdentifier", parent: name, pattern: "^dzd[-_][a-zA-Z0-9_-]{1,36}$")
            try self.validate(self.identifier, name: "identifier", parent: name, pattern: "^[a-zA-Z0-9_-]{1,36}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteDataProductOutput: AWSDecodableShape {
        public init() {}
    }

    public struct DeleteDataSourceInput: AWSEncodableShape {
        /// A unique, case-sensitive identifier that is provided to ensure the idempotency of the request.
        public let clientToken: String?
        /// The ID of the Amazon DataZone domain in which the data source is deleted.
        public let domainIdentifier: String
        /// The identifier of the data source that is deleted.
        public let identifier: String
        /// Specifies that the granted permissions are retained in case of a self-subscribe functionality failure for a data source.
        public let retainPermissionsOnRevokeFailure: Bool?

        @inlinable
        public init(domainIdentifier: String, identifier: String, retainPermissionsOnRevokeFailure: Bool? = nil) {
            self.clientToken = DeleteDataSourceInput.idempotencyToken()
            self.domainIdentifier = domainIdentifier
            self.identifier = identifier
            self.retainPermissionsOnRevokeFailure = retainPermissionsOnRevokeFailure
        }

        @available(*, deprecated, message: "Members clientToken have been deprecated")
        @inlinable
        public init(clientToken: String? = DeleteDataSourceInput.idempotencyToken(), domainIdentifier: String, identifier: String, retainPermissionsOnRevokeFailure: Bool? = nil) {
            self.clientToken = clientToken
            self.domainIdentifier = domainIdentifier
            self.identifier = identifier
            self.retainPermissionsOnRevokeFailure = retainPermissionsOnRevokeFailure
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.clientToken, key: "clientToken")
            request.encodePath(self.domainIdentifier, key: "domainIdentifier")
            request.encodePath(self.identifier, key: "identifier")
            request.encodeQuery(self.retainPermissionsOnRevokeFailure, key: "retainPermissionsOnRevokeFailure")
        }

        public func validate(name: String) throws {
            try self.validate(self.domainIdentifier, name: "domainIdentifier", parent: name, pattern: "^dzd[-_][a-zA-Z0-9_-]{1,36}$")
            try self.validate(self.identifier, name: "identifier", parent: name, pattern: "^[a-zA-Z0-9_-]{1,36}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteDataSourceOutput: AWSDecodableShape {
        /// The asset data forms associated with this data source.
        public let assetFormsOutput: [FormOutput]?
        /// The configuration of the data source that is deleted.
        public let configuration: DataSourceConfigurationOutput?
        /// The ID of the connection that is deleted.
        public let connectionId: String?
        /// The timestamp of when this data source was created.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var createdAt: Date?
        /// The description of the data source that is deleted.
        public let description: String?
        /// The ID of the Amazon DataZone domain in which the data source is deleted.
        public let domainId: String
        /// The enable setting of the data source that specifies whether the data source is enabled or disabled.
        public let enableSetting: EnableSetting?
        /// The ID of the environemnt associated with this data source.
        public let environmentId: String?
        /// Specifies the error message that is returned if the operation cannot be successfully completed.
        public let errorMessage: DataSourceErrorMessage?
        /// The ID of the data source that is deleted.
        public let id: String
        /// The timestamp of when the data source was last run.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var lastRunAt: Date?
        /// Specifies the error message that is returned if the operation cannot be successfully completed.
        public let lastRunErrorMessage: DataSourceErrorMessage?
        /// The status of the last run of this data source.
        public let lastRunStatus: DataSourceRunStatus?
        /// The name of the data source that is deleted.
        public let name: String
        /// The ID of the project in which this data source exists and from which it's deleted.
        public let projectId: String
        /// Specifies whether the assets that this data source creates in the inventory are to be also automatically published to the catalog.
        public let publishOnImport: Bool?
        /// Specifies that the granted permissions are retained in case of a self-subscribe functionality failure for a data source.
        public let retainPermissionsOnRevokeFailure: Bool?
        /// The schedule of runs for this data source.
        public let schedule: ScheduleConfiguration?
        /// Specifies the status of the self-granting functionality.
        public let selfGrantStatus: SelfGrantStatusOutput?
        /// The status of this data source.
        public let status: DataSourceStatus?
        /// The type of this data source.
        public let type: String?
        /// The timestamp of when this data source was updated.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var updatedAt: Date?

        @inlinable
        public init(assetFormsOutput: [FormOutput]? = nil, configuration: DataSourceConfigurationOutput? = nil, connectionId: String? = nil, createdAt: Date? = nil, description: String? = nil, domainId: String, enableSetting: EnableSetting? = nil, environmentId: String? = nil, errorMessage: DataSourceErrorMessage? = nil, id: String, lastRunAt: Date? = nil, lastRunErrorMessage: DataSourceErrorMessage? = nil, lastRunStatus: DataSourceRunStatus? = nil, name: String, projectId: String, publishOnImport: Bool? = nil, retainPermissionsOnRevokeFailure: Bool? = nil, schedule: ScheduleConfiguration? = nil, selfGrantStatus: SelfGrantStatusOutput? = nil, status: DataSourceStatus? = nil, type: String? = nil, updatedAt: Date? = nil) {
            self.assetFormsOutput = assetFormsOutput
            self.configuration = configuration
            self.connectionId = connectionId
            self.createdAt = createdAt
            self.description = description
            self.domainId = domainId
            self.enableSetting = enableSetting
            self.environmentId = environmentId
            self.errorMessage = errorMessage
            self.id = id
            self.lastRunAt = lastRunAt
            self.lastRunErrorMessage = lastRunErrorMessage
            self.lastRunStatus = lastRunStatus
            self.name = name
            self.projectId = projectId
            self.publishOnImport = publishOnImport
            self.retainPermissionsOnRevokeFailure = retainPermissionsOnRevokeFailure
            self.schedule = schedule
            self.selfGrantStatus = selfGrantStatus
            self.status = status
            self.type = type
            self.updatedAt = updatedAt
        }

        private enum CodingKeys: String, CodingKey {
            case assetFormsOutput = "assetFormsOutput"
            case configuration = "configuration"
            case connectionId = "connectionId"
            case createdAt = "createdAt"
            case description = "description"
            case domainId = "domainId"
            case enableSetting = "enableSetting"
            case environmentId = "environmentId"
            case errorMessage = "errorMessage"
            case id = "id"
            case lastRunAt = "lastRunAt"
            case lastRunErrorMessage = "lastRunErrorMessage"
            case lastRunStatus = "lastRunStatus"
            case name = "name"
            case projectId = "projectId"
            case publishOnImport = "publishOnImport"
            case retainPermissionsOnRevokeFailure = "retainPermissionsOnRevokeFailure"
            case schedule = "schedule"
            case selfGrantStatus = "selfGrantStatus"
            case status = "status"
            case type = "type"
            case updatedAt = "updatedAt"
        }
    }

    public struct DeleteDomainInput: AWSEncodableShape {
        /// A unique, case-sensitive identifier that is provided to ensure the idempotency of the request.
        public let clientToken: String?
        /// The identifier of the Amazon Web Services domain that is to be deleted.
        public let identifier: String
        /// Specifies the optional flag to delete all child entities within the domain.
        public let skipDeletionCheck: Bool?

        @inlinable
        public init(clientToken: String? = DeleteDomainInput.idempotencyToken(), identifier: String, skipDeletionCheck: Bool? = nil) {
            self.clientToken = clientToken
            self.identifier = identifier
            self.skipDeletionCheck = skipDeletionCheck
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.clientToken, key: "clientToken")
            request.encodePath(self.identifier, key: "identifier")
            request.encodeQuery(self.skipDeletionCheck, key: "skipDeletionCheck")
        }

        public func validate(name: String) throws {
            try self.validate(self.identifier, name: "identifier", parent: name, pattern: "^dzd[-_][a-zA-Z0-9_-]{1,36}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteDomainOutput: AWSDecodableShape {
        /// The status of the domain.
        public let status: DomainStatus

        @inlinable
        public init(status: DomainStatus) {
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case status = "status"
        }
    }

    public struct DeleteDomainUnitInput: AWSEncodableShape {
        /// The ID of the domain where you want to delete a domain unit.
        public let domainIdentifier: String
        /// The ID of the domain unit that you want to delete.
        public let identifier: String

        @inlinable
        public init(domainIdentifier: String, identifier: String) {
            self.domainIdentifier = domainIdentifier
            self.identifier = identifier
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.domainIdentifier, key: "domainIdentifier")
            request.encodePath(self.identifier, key: "identifier")
        }

        public func validate(name: String) throws {
            try self.validate(self.domainIdentifier, name: "domainIdentifier", parent: name, pattern: "^dzd[-_][a-zA-Z0-9_-]{1,36}$")
            try self.validate(self.identifier, name: "identifier", parent: name, max: 256)
            try self.validate(self.identifier, name: "identifier", parent: name, min: 1)
            try self.validate(self.identifier, name: "identifier", parent: name, pattern: "^[a-z0-9_\\-]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteDomainUnitOutput: AWSDecodableShape {
        public init() {}
    }

    public struct DeleteEnvironmentActionInput: AWSEncodableShape {
        /// The ID of the Amazon DataZone domain in which an environment action is deleted.
        public let domainIdentifier: String
        /// The ID of the environment where an environment action is deleted.
        public let environmentIdentifier: String
        /// The ID of the environment action that is deleted.
        public let identifier: String

        @inlinable
        public init(domainIdentifier: String, environmentIdentifier: String, identifier: String) {
            self.domainIdentifier = domainIdentifier
            self.environmentIdentifier = environmentIdentifier
            self.identifier = identifier
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.domainIdentifier, key: "domainIdentifier")
            request.encodePath(self.environmentIdentifier, key: "environmentIdentifier")
            request.encodePath(self.identifier, key: "identifier")
        }

        public func validate(name: String) throws {
            try self.validate(self.domainIdentifier, name: "domainIdentifier", parent: name, pattern: "^dzd[-_][a-zA-Z0-9_-]{1,36}$")
            try self.validate(self.environmentIdentifier, name: "environmentIdentifier", parent: name, pattern: "^[a-zA-Z0-9_-]{1,36}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteEnvironmentBlueprintConfigurationInput: AWSEncodableShape {
        /// The ID of the Amazon DataZone domain in which the blueprint configuration is deleted.
        public let domainIdentifier: String
        /// The ID of the blueprint the configuration of which is deleted.
        public let environmentBlueprintIdentifier: String

        @inlinable
        public init(domainIdentifier: String, environmentBlueprintIdentifier: String) {
            self.domainIdentifier = domainIdentifier
            self.environmentBlueprintIdentifier = environmentBlueprintIdentifier
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.domainIdentifier, key: "domainIdentifier")
            request.encodePath(self.environmentBlueprintIdentifier, key: "environmentBlueprintIdentifier")
        }

        public func validate(name: String) throws {
            try self.validate(self.domainIdentifier, name: "domainIdentifier", parent: name, pattern: "^dzd[-_][a-zA-Z0-9_-]{1,36}$")
            try self.validate(self.environmentBlueprintIdentifier, name: "environmentBlueprintIdentifier", parent: name, pattern: "^[a-zA-Z0-9_-]{1,36}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteEnvironmentBlueprintConfigurationOutput: AWSDecodableShape {
        public init() {}
    }

    public struct DeleteEnvironmentInput: AWSEncodableShape {
        /// The ID of the Amazon DataZone domain in which the environment is deleted.
        public let domainIdentifier: String
        /// The identifier of the environment that is to be deleted.
        public let identifier: String

        @inlinable
        public init(domainIdentifier: String, identifier: String) {
            self.domainIdentifier = domainIdentifier
            self.identifier = identifier
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.domainIdentifier, key: "domainIdentifier")
            request.encodePath(self.identifier, key: "identifier")
        }

        public func validate(name: String) throws {
            try self.validate(self.domainIdentifier, name: "domainIdentifier", parent: name, pattern: "^dzd[-_][a-zA-Z0-9_-]{1,36}$")
            try self.validate(self.identifier, name: "identifier", parent: name, pattern: "^[a-zA-Z0-9_-]{1,36}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteEnvironmentProfileInput: AWSEncodableShape {
        /// The ID of the Amazon DataZone domain in which the environment profile is deleted.
        public let domainIdentifier: String
        /// The ID of the environment profile that is deleted.
        public let identifier: String

        @inlinable
        public init(domainIdentifier: String, identifier: String) {
            self.domainIdentifier = domainIdentifier
            self.identifier = identifier
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.domainIdentifier, key: "domainIdentifier")
            request.encodePath(self.identifier, key: "identifier")
        }

        public func validate(name: String) throws {
            try self.validate(self.domainIdentifier, name: "domainIdentifier", parent: name, pattern: "^dzd[-_][a-zA-Z0-9_-]{1,36}$")
            try self.validate(self.identifier, name: "identifier", parent: name, pattern: "^[a-zA-Z0-9_-]{0,36}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteFormTypeInput: AWSEncodableShape {
        /// The ID of the Amazon DataZone domain in which the metadata form type is deleted.
        public let domainIdentifier: String
        /// The ID of the metadata form type that is deleted.
        public let formTypeIdentifier: String

        @inlinable
        public init(domainIdentifier: String, formTypeIdentifier: String) {
            self.domainIdentifier = domainIdentifier
            self.formTypeIdentifier = formTypeIdentifier
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.domainIdentifier, key: "domainIdentifier")
            request.encodePath(self.formTypeIdentifier, key: "formTypeIdentifier")
        }

        public func validate(name: String) throws {
            try self.validate(self.domainIdentifier, name: "domainIdentifier", parent: name, pattern: "^dzd[-_][a-zA-Z0-9_-]{1,36}$")
            try self.validate(self.formTypeIdentifier, name: "formTypeIdentifier", parent: name, max: 385)
            try self.validate(self.formTypeIdentifier, name: "formTypeIdentifier", parent: name, min: 1)
            try self.validate(self.formTypeIdentifier, name: "formTypeIdentifier", parent: name, pattern: "^(?!\\.)[\\w\\.]*\\w$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteFormTypeOutput: AWSDecodableShape {
        public init() {}
    }

    public struct DeleteGlossaryInput: AWSEncodableShape {
        /// The ID of the Amazon DataZone domain in which the business glossary is deleted.
        public let domainIdentifier: String
        /// The ID of the business glossary that is deleted.
        public let identifier: String

        @inlinable
        public init(domainIdentifier: String, identifier: String) {
            self.domainIdentifier = domainIdentifier
            self.identifier = identifier
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.domainIdentifier, key: "domainIdentifier")
            request.encodePath(self.identifier, key: "identifier")
        }

        public func validate(name: String) throws {
            try self.validate(self.domainIdentifier, name: "domainIdentifier", parent: name, pattern: "^dzd[-_][a-zA-Z0-9_-]{1,36}$")
            try self.validate(self.identifier, name: "identifier", parent: name, pattern: "^[a-zA-Z0-9_-]{1,36}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteGlossaryOutput: AWSDecodableShape {
        public init() {}
    }

    public struct DeleteGlossaryTermInput: AWSEncodableShape {
        /// The ID of the Amazon DataZone domain in which the business glossary term is deleted.
        public let domainIdentifier: String
        /// The ID of the business glossary term that is deleted.
        public let identifier: String

        @inlinable
        public init(domainIdentifier: String, identifier: String) {
            self.domainIdentifier = domainIdentifier
            self.identifier = identifier
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.domainIdentifier, key: "domainIdentifier")
            request.encodePath(self.identifier, key: "identifier")
        }

        public func validate(name: String) throws {
            try self.validate(self.domainIdentifier, name: "domainIdentifier", parent: name, pattern: "^dzd[-_][a-zA-Z0-9_-]{1,36}$")
            try self.validate(self.identifier, name: "identifier", parent: name, pattern: "^[a-zA-Z0-9_-]{1,36}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteGlossaryTermOutput: AWSDecodableShape {
        public init() {}
    }

    public struct DeleteListingInput: AWSEncodableShape {
        /// The ID of the Amazon DataZone domain.
        public let domainIdentifier: String
        /// The ID of the listing to be deleted.
        public let identifier: String

        @inlinable
        public init(domainIdentifier: String, identifier: String) {
            self.domainIdentifier = domainIdentifier
            self.identifier = identifier
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.domainIdentifier, key: "domainIdentifier")
            request.encodePath(self.identifier, key: "identifier")
        }

        public func validate(name: String) throws {
            try self.validate(self.domainIdentifier, name: "domainIdentifier", parent: name, pattern: "^dzd[-_][a-zA-Z0-9_-]{1,36}$")
            try self.validate(self.identifier, name: "identifier", parent: name, pattern: "^[a-zA-Z0-9_-]{1,36}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteListingOutput: AWSDecodableShape {
        public init() {}
    }

    public struct DeleteProjectInput: AWSEncodableShape {
        /// The ID of the Amazon DataZone domain in which the project is deleted.
        public let domainIdentifier: String
        /// The identifier of the project that is to be deleted.
        public let identifier: String
        /// Specifies the optional flag to delete all child entities within the project.
        public let skipDeletionCheck: Bool?

        @inlinable
        public init(domainIdentifier: String, identifier: String, skipDeletionCheck: Bool? = nil) {
            self.domainIdentifier = domainIdentifier
            self.identifier = identifier
            self.skipDeletionCheck = skipDeletionCheck
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.domainIdentifier, key: "domainIdentifier")
            request.encodePath(self.identifier, key: "identifier")
            request.encodeQuery(self.skipDeletionCheck, key: "skipDeletionCheck")
        }

        public func validate(name: String) throws {
            try self.validate(self.domainIdentifier, name: "domainIdentifier", parent: name, pattern: "^dzd[-_][a-zA-Z0-9_-]{1,36}$")
            try self.validate(self.identifier, name: "identifier", parent: name, pattern: "^[a-zA-Z0-9_-]{1,36}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteProjectMembershipInput: AWSEncodableShape {
        /// The ID of the Amazon DataZone domain where project membership is deleted.
        public let domainIdentifier: String
        /// The project member whose project membership is deleted.
        public let member: Member
        /// The ID of the Amazon DataZone project the membership to which is deleted.
        public let projectIdentifier: String

        @inlinable
        public init(domainIdentifier: String, member: Member, projectIdentifier: String) {
            self.domainIdentifier = domainIdentifier
            self.member = member
            self.projectIdentifier = projectIdentifier
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.domainIdentifier, key: "domainIdentifier")
            try container.encode(self.member, forKey: .member)
            request.encodePath(self.projectIdentifier, key: "projectIdentifier")
        }

        public func validate(name: String) throws {
            try self.validate(self.domainIdentifier, name: "domainIdentifier", parent: name, pattern: "^dzd[-_][a-zA-Z0-9_-]{1,36}$")
            try self.validate(self.projectIdentifier, name: "projectIdentifier", parent: name, pattern: "^[a-zA-Z0-9_-]{1,36}$")
        }

        private enum CodingKeys: String, CodingKey {
            case member = "member"
        }
    }

    public struct DeleteProjectMembershipOutput: AWSDecodableShape {
        public init() {}
    }

    public struct DeleteProjectOutput: AWSDecodableShape {
        public init() {}
    }

    public struct DeleteProjectProfileInput: AWSEncodableShape {
        /// The ID of the domain where a project profile is deleted.
        public let domainIdentifier: String
        /// The ID of the project profile that is deleted.
        public let identifier: String

        @inlinable
        public init(domainIdentifier: String, identifier: String) {
            self.domainIdentifier = domainIdentifier
            self.identifier = identifier
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.domainIdentifier, key: "domainIdentifier")
            request.encodePath(self.identifier, key: "identifier")
        }

        public func validate(name: String) throws {
            try self.validate(self.domainIdentifier, name: "domainIdentifier", parent: name, pattern: "^dzd[-_][a-zA-Z0-9_-]{1,36}$")
            try self.validate(self.identifier, name: "identifier", parent: name, pattern: "^[a-zA-Z0-9_-]{1,36}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteProjectProfileOutput: AWSDecodableShape {
        public init() {}
    }

    public struct DeleteRuleInput: AWSEncodableShape {
        /// The ID of the domain that where the rule is to be deleted.
        public let domainIdentifier: String
        /// The ID of the rule that is to be deleted.
        public let identifier: String

        @inlinable
        public init(domainIdentifier: String, identifier: String) {
            self.domainIdentifier = domainIdentifier
            self.identifier = identifier
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.domainIdentifier, key: "domainIdentifier")
            request.encodePath(self.identifier, key: "identifier")
        }

        public func validate(name: String) throws {
            try self.validate(self.domainIdentifier, name: "domainIdentifier", parent: name, pattern: "^dzd[-_][a-zA-Z0-9_-]{1,36}$")
            try self.validate(self.identifier, name: "identifier", parent: name, pattern: "^[a-zA-Z0-9_-]{1,36}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteRuleOutput: AWSDecodableShape {
        public init() {}
    }

    public struct DeleteSubscriptionGrantInput: AWSEncodableShape {
        /// The ID of the Amazon DataZone domain where the subscription grant is deleted.
        public let domainIdentifier: String
        /// The ID of the subscription grant that is deleted.
        public let identifier: String

        @inlinable
        public init(domainIdentifier: String, identifier: String) {
            self.domainIdentifier = domainIdentifier
            self.identifier = identifier
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.domainIdentifier, key: "domainIdentifier")
            request.encodePath(self.identifier, key: "identifier")
        }

        public func validate(name: String) throws {
            try self.validate(self.domainIdentifier, name: "domainIdentifier", parent: name, pattern: "^dzd[-_][a-zA-Z0-9_-]{1,36}$")
            try self.validate(self.identifier, name: "identifier", parent: name, pattern: "^[a-zA-Z0-9_-]{1,36}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteSubscriptionGrantOutput: AWSDecodableShape {
        /// The assets for which the subsctiption grant that is deleted gave access.
        public let assets: [SubscribedAsset]?
        /// The timestamp of when the subscription grant that is deleted was created.
        public let createdAt: Date
        /// The Amazon DataZone user who created the subscription grant that is deleted.
        public let createdBy: String
        /// The ID of the Amazon DataZone domain in which the subscription grant is deleted.
        public let domainId: String
        /// The entity to which the subscription is deleted.
        public let grantedEntity: GrantedEntity
        /// The ID of the subscription grant that is deleted.
        public let id: String
        /// The status of the subscription grant that is deleted.
        public let status: SubscriptionGrantOverallStatus
        /// The identifier of the subsctiption whose subscription grant is to be deleted.
        public let subscriptionId: String?
        /// The ID of the subscription target associated with the subscription grant that is deleted.
        public let subscriptionTargetId: String
        /// The timestamp of when the subscription grant that is deleted was updated.
        public let updatedAt: Date
        /// The Amazon DataZone user who updated the subscription grant that is deleted.
        public let updatedBy: String?

        @inlinable
        public init(assets: [SubscribedAsset]? = nil, createdAt: Date, createdBy: String, domainId: String, grantedEntity: GrantedEntity, id: String, status: SubscriptionGrantOverallStatus, subscriptionTargetId: String, updatedAt: Date, updatedBy: String? = nil) {
            self.assets = assets
            self.createdAt = createdAt
            self.createdBy = createdBy
            self.domainId = domainId
            self.grantedEntity = grantedEntity
            self.id = id
            self.status = status
            self.subscriptionId = nil
            self.subscriptionTargetId = subscriptionTargetId
            self.updatedAt = updatedAt
            self.updatedBy = updatedBy
        }

        @available(*, deprecated, message: "Members subscriptionId have been deprecated")
        @inlinable
        public init(assets: [SubscribedAsset]? = nil, createdAt: Date, createdBy: String, domainId: String, grantedEntity: GrantedEntity, id: String, status: SubscriptionGrantOverallStatus, subscriptionId: String? = nil, subscriptionTargetId: String, updatedAt: Date, updatedBy: String? = nil) {
            self.assets = assets
            self.createdAt = createdAt
            self.createdBy = createdBy
            self.domainId = domainId
            self.grantedEntity = grantedEntity
            self.id = id
            self.status = status
            self.subscriptionId = subscriptionId
            self.subscriptionTargetId = subscriptionTargetId
            self.updatedAt = updatedAt
            self.updatedBy = updatedBy
        }

        private enum CodingKeys: String, CodingKey {
            case assets = "assets"
            case createdAt = "createdAt"
            case createdBy = "createdBy"
            case domainId = "domainId"
            case grantedEntity = "grantedEntity"
            case id = "id"
            case status = "status"
            case subscriptionId = "subscriptionId"
            case subscriptionTargetId = "subscriptionTargetId"
            case updatedAt = "updatedAt"
            case updatedBy = "updatedBy"
        }
    }

    public struct DeleteSubscriptionRequestInput: AWSEncodableShape {
        /// The ID of the Amazon DataZone domain in which the subscription request is deleted.
        public let domainIdentifier: String
        /// The ID of the subscription request that is deleted.
        public let identifier: String

        @inlinable
        public init(domainIdentifier: String, identifier: String) {
            self.domainIdentifier = domainIdentifier
            self.identifier = identifier
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.domainIdentifier, key: "domainIdentifier")
            request.encodePath(self.identifier, key: "identifier")
        }

        public func validate(name: String) throws {
            try self.validate(self.domainIdentifier, name: "domainIdentifier", parent: name, pattern: "^dzd[-_][a-zA-Z0-9_-]{1,36}$")
            try self.validate(self.identifier, name: "identifier", parent: name, pattern: "^[a-zA-Z0-9_-]{1,36}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteSubscriptionTargetInput: AWSEncodableShape {
        /// The ID of the Amazon DataZone domain in which the subscription target is deleted.
        public let domainIdentifier: String
        /// The ID of the Amazon DataZone environment in which the subscription target is deleted.
        public let environmentIdentifier: String
        /// The ID of the subscription target that is deleted.
        public let identifier: String

        @inlinable
        public init(domainIdentifier: String, environmentIdentifier: String, identifier: String) {
            self.domainIdentifier = domainIdentifier
            self.environmentIdentifier = environmentIdentifier
            self.identifier = identifier
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.domainIdentifier, key: "domainIdentifier")
            request.encodePath(self.environmentIdentifier, key: "environmentIdentifier")
            request.encodePath(self.identifier, key: "identifier")
        }

        public func validate(name: String) throws {
            try self.validate(self.domainIdentifier, name: "domainIdentifier", parent: name, pattern: "^dzd[-_][a-zA-Z0-9_-]{1,36}$")
            try self.validate(self.environmentIdentifier, name: "environmentIdentifier", parent: name, pattern: "^[a-zA-Z0-9_-]{1,36}$")
            try self.validate(self.identifier, name: "identifier", parent: name, pattern: "^[a-zA-Z0-9_-]{1,36}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteTimeSeriesDataPointsInput: AWSEncodableShape {
        /// A unique, case-sensitive identifier to ensure idempotency of the request. This field is automatically populated if not provided.
        public let clientToken: String?
        /// The ID of the Amazon DataZone domain that houses the asset for which you want to delete a time series form.
        public let domainIdentifier: String
        /// The ID of the asset for which you want to delete a time series form.
        public let entityIdentifier: String
        /// The type of the asset for which you want to delete a time series form.
        public let entityType: TimeSeriesEntityType
        /// The name of the time series form that you want to delete.
        public let formName: String

        @inlinable
        public init(clientToken: String? = DeleteTimeSeriesDataPointsInput.idempotencyToken(), domainIdentifier: String, entityIdentifier: String, entityType: TimeSeriesEntityType, formName: String) {
            self.clientToken = clientToken
            self.domainIdentifier = domainIdentifier
            self.entityIdentifier = entityIdentifier
            self.entityType = entityType
            self.formName = formName
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.clientToken, key: "clientToken")
            request.encodePath(self.domainIdentifier, key: "domainIdentifier")
            request.encodePath(self.entityIdentifier, key: "entityIdentifier")
            request.encodePath(self.entityType, key: "entityType")
            request.encodeQuery(self.formName, key: "formName")
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 128)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "^[\\x21-\\x7E]+$")
            try self.validate(self.domainIdentifier, name: "domainIdentifier", parent: name, pattern: "^dzd[-_][a-zA-Z0-9_-]{1,36}$")
            try self.validate(self.entityIdentifier, name: "entityIdentifier", parent: name, pattern: "^[a-zA-Z0-9_-]{1,36}$")
            try self.validate(self.formName, name: "formName", parent: name, max: 128)
            try self.validate(self.formName, name: "formName", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteTimeSeriesDataPointsOutput: AWSDecodableShape {
        public init() {}
    }

    public struct Deployment: AWSDecodableShape {
        /// The identifier of the last deployment of the environment.
        public let deploymentId: String?
        /// The status of the last deployment of the environment.
        public let deploymentStatus: DeploymentStatus?
        /// The type of the last deployment of the environment.
        public let deploymentType: DeploymentType?
        /// The failure reason of the last deployment of the environment.
        public let failureReason: EnvironmentError?
        /// Specifies whether the last deployment of the environment is complete.
        public let isDeploymentComplete: Bool?
        /// The messages of the last deployment of the environment.
        public let messages: [String]?

        @inlinable
        public init(deploymentId: String? = nil, deploymentStatus: DeploymentStatus? = nil, deploymentType: DeploymentType? = nil, failureReason: EnvironmentError? = nil, isDeploymentComplete: Bool? = nil, messages: [String]? = nil) {
            self.deploymentId = deploymentId
            self.deploymentStatus = deploymentStatus
            self.deploymentType = deploymentType
            self.failureReason = failureReason
            self.isDeploymentComplete = isDeploymentComplete
            self.messages = messages
        }

        private enum CodingKeys: String, CodingKey {
            case deploymentId = "deploymentId"
            case deploymentStatus = "deploymentStatus"
            case deploymentType = "deploymentType"
            case failureReason = "failureReason"
            case isDeploymentComplete = "isDeploymentComplete"
            case messages = "messages"
        }
    }

    public struct DeploymentProperties: AWSDecodableShape {
        /// The end timeout of the environment blueprint deployment.
        public let endTimeoutMinutes: Int?
        /// The start timeout of the environment blueprint deployment.
        public let startTimeoutMinutes: Int?

        @inlinable
        public init(endTimeoutMinutes: Int? = nil, startTimeoutMinutes: Int? = nil) {
            self.endTimeoutMinutes = endTimeoutMinutes
            self.startTimeoutMinutes = startTimeoutMinutes
        }

        private enum CodingKeys: String, CodingKey {
            case endTimeoutMinutes = "endTimeoutMinutes"
            case startTimeoutMinutes = "startTimeoutMinutes"
        }
    }

    public struct DetailedGlossaryTerm: AWSDecodableShape {
        /// The name of a glossary term attached to the inventory asset.
        public let name: String?
        /// The shoft description of a glossary term attached to the inventory asset.
        public let shortDescription: String?

        @inlinable
        public init(name: String? = nil, shortDescription: String? = nil) {
            self.name = name
            self.shortDescription = shortDescription
        }

        private enum CodingKeys: String, CodingKey {
            case name = "name"
            case shortDescription = "shortDescription"
        }
    }

    public struct DisassociateEnvironmentRoleInput: AWSEncodableShape {
        /// The ID of the Amazon DataZone domain in which an environment role is disassociated.
        public let domainIdentifier: String
        /// The ID of the environment.
        public let environmentIdentifier: String
        /// The ARN of the environment role.
        public let environmentRoleArn: String

        @inlinable
        public init(domainIdentifier: String, environmentIdentifier: String, environmentRoleArn: String) {
            self.domainIdentifier = domainIdentifier
            self.environmentIdentifier = environmentIdentifier
            self.environmentRoleArn = environmentRoleArn
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.domainIdentifier, key: "domainIdentifier")
            request.encodePath(self.environmentIdentifier, key: "environmentIdentifier")
            request.encodePath(self.environmentRoleArn, key: "environmentRoleArn")
        }

        public func validate(name: String) throws {
            try self.validate(self.domainIdentifier, name: "domainIdentifier", parent: name, pattern: "^dzd[-_][a-zA-Z0-9_-]{1,36}$")
            try self.validate(self.environmentIdentifier, name: "environmentIdentifier", parent: name, pattern: "^[a-zA-Z0-9_-]{1,36}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DisassociateEnvironmentRoleOutput: AWSDecodableShape {
        public init() {}
    }

    public struct DomainSummary: AWSDecodableShape {
        /// The ARN of the Amazon DataZone domain.
        public let arn: String
        /// A timestamp of when a Amazon DataZone domain was created.
        public let createdAt: Date
        /// A description of an Amazon DataZone domain.
        public let description: String?
        /// The domain version.
        public let domainVersion: DomainVersion?
        /// The ID of the Amazon DataZone domain.
        public let id: String
        /// A timestamp of when a Amazon DataZone domain was last updated.
        public let lastUpdatedAt: Date?
        /// The identifier of the Amazon Web Services account that manages the domain.
        public let managedAccountId: String
        /// A name of an Amazon DataZone domain.
        public let name: String
        /// The data portal URL for the Amazon DataZone domain.
        public let portalUrl: String?
        /// The status of the Amazon DataZone domain.
        public let status: DomainStatus

        @inlinable
        public init(arn: String, createdAt: Date, description: String? = nil, domainVersion: DomainVersion? = nil, id: String, lastUpdatedAt: Date? = nil, managedAccountId: String, name: String, portalUrl: String? = nil, status: DomainStatus) {
            self.arn = arn
            self.createdAt = createdAt
            self.description = description
            self.domainVersion = domainVersion
            self.id = id
            self.lastUpdatedAt = lastUpdatedAt
            self.managedAccountId = managedAccountId
            self.name = name
            self.portalUrl = portalUrl
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case createdAt = "createdAt"
            case description = "description"
            case domainVersion = "domainVersion"
            case id = "id"
            case lastUpdatedAt = "lastUpdatedAt"
            case managedAccountId = "managedAccountId"
            case name = "name"
            case portalUrl = "portalUrl"
            case status = "status"
        }
    }

    public struct DomainUnitFilterForProject: AWSEncodableShape & AWSDecodableShape {
        /// The domain unit ID to use in the filter.
        public let domainUnit: String
        /// Specifies whether to include child domain units.
        public let includeChildDomainUnits: Bool?

        @inlinable
        public init(domainUnit: String, includeChildDomainUnits: Bool? = nil) {
            self.domainUnit = domainUnit
            self.includeChildDomainUnits = includeChildDomainUnits
        }

        public func validate(name: String) throws {
            try self.validate(self.domainUnit, name: "domainUnit", parent: name, max: 256)
            try self.validate(self.domainUnit, name: "domainUnit", parent: name, min: 1)
            try self.validate(self.domainUnit, name: "domainUnit", parent: name, pattern: "^[a-z0-9_\\-]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case domainUnit = "domainUnit"
            case includeChildDomainUnits = "includeChildDomainUnits"
        }
    }

    public struct DomainUnitGroupProperties: AWSDecodableShape {
        /// The ID of the domain unit group.
        public let groupId: String?

        @inlinable
        public init(groupId: String? = nil) {
            self.groupId = groupId
        }

        private enum CodingKeys: String, CodingKey {
            case groupId = "groupId"
        }
    }

    public struct DomainUnitPolicyGrantPrincipal: AWSEncodableShape & AWSDecodableShape {
        /// Specifes the designation of the domain unit users.
        public let domainUnitDesignation: DomainUnitDesignation
        /// The grant filter for the domain unit.
        public let domainUnitGrantFilter: DomainUnitGrantFilter?
        /// The ID of the domain unit.
        public let domainUnitIdentifier: String?

        @inlinable
        public init(domainUnitDesignation: DomainUnitDesignation, domainUnitGrantFilter: DomainUnitGrantFilter? = nil, domainUnitIdentifier: String? = nil) {
            self.domainUnitDesignation = domainUnitDesignation
            self.domainUnitGrantFilter = domainUnitGrantFilter
            self.domainUnitIdentifier = domainUnitIdentifier
        }

        public func validate(name: String) throws {
            try self.validate(self.domainUnitIdentifier, name: "domainUnitIdentifier", parent: name, max: 256)
            try self.validate(self.domainUnitIdentifier, name: "domainUnitIdentifier", parent: name, min: 1)
            try self.validate(self.domainUnitIdentifier, name: "domainUnitIdentifier", parent: name, pattern: "^[a-z0-9_\\-]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case domainUnitDesignation = "domainUnitDesignation"
            case domainUnitGrantFilter = "domainUnitGrantFilter"
            case domainUnitIdentifier = "domainUnitIdentifier"
        }
    }

    public struct DomainUnitSummary: AWSDecodableShape {
        /// The ID of the domain unit summary.
        public let id: String
        /// The name of the domain unit summary.
        public let name: String

        @inlinable
        public init(id: String, name: String) {
            self.id = id
            self.name = name
        }

        private enum CodingKeys: String, CodingKey {
            case id = "id"
            case name = "name"
        }
    }

    public struct DomainUnitTarget: AWSEncodableShape & AWSDecodableShape {
        /// The ID of the domain unit.
        public let domainUnitId: String
        /// Specifies whether to apply a rule to the child domain units.
        public let includeChildDomainUnits: Bool?

        @inlinable
        public init(domainUnitId: String, includeChildDomainUnits: Bool? = nil) {
            self.domainUnitId = domainUnitId
            self.includeChildDomainUnits = includeChildDomainUnits
        }

        public func validate(name: String) throws {
            try self.validate(self.domainUnitId, name: "domainUnitId", parent: name, max: 256)
            try self.validate(self.domainUnitId, name: "domainUnitId", parent: name, min: 1)
            try self.validate(self.domainUnitId, name: "domainUnitId", parent: name, pattern: "^[a-z0-9_\\-]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case domainUnitId = "domainUnitId"
            case includeChildDomainUnits = "includeChildDomainUnits"
        }
    }

    public struct DomainUnitUserProperties: AWSDecodableShape {
        /// The ID of teh domain unit user.
        public let userId: String?

        @inlinable
        public init(userId: String? = nil) {
            self.userId = userId
        }

        private enum CodingKeys: String, CodingKey {
            case userId = "userId"
        }
    }

    public struct EnvironmentActionSummary: AWSDecodableShape {
        /// The environment action description.
        public let description: String?
        /// The Amazon DataZone domain ID of the environment action.
        public let domainId: String
        /// The environment ID of the environment action.
        public let environmentId: String
        /// The ID of the environment action.
        public let id: String
        /// The name of the environment action.
        public let name: String
        /// The parameters of the environment action.
        public let parameters: ActionParameters

        @inlinable
        public init(description: String? = nil, domainId: String, environmentId: String, id: String, name: String, parameters: ActionParameters) {
            self.description = description
            self.domainId = domainId
            self.environmentId = environmentId
            self.id = id
            self.name = name
            self.parameters = parameters
        }

        private enum CodingKeys: String, CodingKey {
            case description = "description"
            case domainId = "domainId"
            case environmentId = "environmentId"
            case id = "id"
            case name = "name"
            case parameters = "parameters"
        }
    }

    public struct EnvironmentBlueprintConfigurationItem: AWSDecodableShape {
        /// The timestamp of when an environment blueprint was created.
        public let createdAt: Date?
        /// The identifier of the Amazon DataZone domain in which an environment blueprint exists.
        public let domainId: String
        /// The enabled Amazon Web Services Regions specified in a blueprint configuration.
        public let enabledRegions: [String]?
        /// The identifier of the environment blueprint.
        public let environmentBlueprintId: String
        /// The environment role permission boundary.
        public let environmentRolePermissionBoundary: String?
        /// The ARN of the manage access role specified in the environment blueprint configuration.
        public let manageAccessRoleArn: String?
        /// The provisioning configuration of a blueprint.
        public let provisioningConfigurations: [ProvisioningConfiguration]?
        /// The ARN of the provisioning role specified in the environment blueprint configuration.
        public let provisioningRoleArn: String?
        /// The regional parameters of the environment blueprint.
        public let regionalParameters: [String: [String: String]]?
        /// The timestamp of when the environment blueprint was updated.
        public let updatedAt: Date?

        @inlinable
        public init(createdAt: Date? = nil, domainId: String, enabledRegions: [String]? = nil, environmentBlueprintId: String, environmentRolePermissionBoundary: String? = nil, manageAccessRoleArn: String? = nil, provisioningConfigurations: [ProvisioningConfiguration]? = nil, provisioningRoleArn: String? = nil, regionalParameters: [String: [String: String]]? = nil, updatedAt: Date? = nil) {
            self.createdAt = createdAt
            self.domainId = domainId
            self.enabledRegions = enabledRegions
            self.environmentBlueprintId = environmentBlueprintId
            self.environmentRolePermissionBoundary = environmentRolePermissionBoundary
            self.manageAccessRoleArn = manageAccessRoleArn
            self.provisioningConfigurations = provisioningConfigurations
            self.provisioningRoleArn = provisioningRoleArn
            self.regionalParameters = regionalParameters
            self.updatedAt = updatedAt
        }

        private enum CodingKeys: String, CodingKey {
            case createdAt = "createdAt"
            case domainId = "domainId"
            case enabledRegions = "enabledRegions"
            case environmentBlueprintId = "environmentBlueprintId"
            case environmentRolePermissionBoundary = "environmentRolePermissionBoundary"
            case manageAccessRoleArn = "manageAccessRoleArn"
            case provisioningConfigurations = "provisioningConfigurations"
            case provisioningRoleArn = "provisioningRoleArn"
            case regionalParameters = "regionalParameters"
            case updatedAt = "updatedAt"
        }
    }

    public struct EnvironmentBlueprintSummary: AWSDecodableShape {
        /// The timestamp of when an environment blueprint was created.
        public let createdAt: Date?
        /// The description of a blueprint.
        public let description: String?
        /// The identifier of the blueprint.
        public let id: String
        /// The name of the blueprint.
        public let name: String
        /// The provider of the blueprint.
        public let provider: String
        /// The provisioning properties of the blueprint.
        public let provisioningProperties: ProvisioningProperties
        /// The timestamp of when the blueprint was enabled.
        public let updatedAt: Date?

        @inlinable
        public init(createdAt: Date? = nil, description: String? = nil, id: String, name: String, provider: String, provisioningProperties: ProvisioningProperties, updatedAt: Date? = nil) {
            self.createdAt = createdAt
            self.description = description
            self.id = id
            self.name = name
            self.provider = provider
            self.provisioningProperties = provisioningProperties
            self.updatedAt = updatedAt
        }

        private enum CodingKeys: String, CodingKey {
            case createdAt = "createdAt"
            case description = "description"
            case id = "id"
            case name = "name"
            case provider = "provider"
            case provisioningProperties = "provisioningProperties"
            case updatedAt = "updatedAt"
        }
    }

    public struct EnvironmentConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The Amazon Web Services account of the environment.
        public let awsAccount: AwsAccount
        /// The Amazon Web Services Region of the environment.
        public let awsRegion: Region
        /// The configuration parameters of the environment.
        public let configurationParameters: EnvironmentConfigurationParametersDetails?
        /// The deployment mode of the environment.
        public let deploymentMode: DeploymentMode?
        /// The deployment order of the environment.
        public let deploymentOrder: Int?
        /// The environment description.
        public let description: String?
        /// The environment blueprint ID.
        public let environmentBlueprintId: String
        /// The environment ID.
        public let id: String?
        /// The environment name.
        public let name: String

        @inlinable
        public init(awsAccount: AwsAccount, awsRegion: Region, configurationParameters: EnvironmentConfigurationParametersDetails? = nil, deploymentMode: DeploymentMode? = nil, deploymentOrder: Int? = nil, description: String? = nil, environmentBlueprintId: String, id: String? = nil, name: String) {
            self.awsAccount = awsAccount
            self.awsRegion = awsRegion
            self.configurationParameters = configurationParameters
            self.deploymentMode = deploymentMode
            self.deploymentOrder = deploymentOrder
            self.description = description
            self.environmentBlueprintId = environmentBlueprintId
            self.id = id
            self.name = name
        }

        public func validate(name: String) throws {
            try self.awsAccount.validate(name: "\(name).awsAccount")
            try self.awsRegion.validate(name: "\(name).awsRegion")
            try self.configurationParameters?.validate(name: "\(name).configurationParameters")
            try self.validate(self.deploymentOrder, name: "deploymentOrder", parent: name, max: 16)
            try self.validate(self.deploymentOrder, name: "deploymentOrder", parent: name, min: 0)
            try self.validate(self.description, name: "description", parent: name, max: 2048)
            try self.validate(self.environmentBlueprintId, name: "environmentBlueprintId", parent: name, pattern: "^[a-zA-Z0-9_-]{1,36}$")
            try self.validate(self.id, name: "id", parent: name, pattern: "^[a-zA-Z0-9_-]{1,36}$")
            try self.validate(self.name, name: "name", parent: name, max: 64)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[\\w -]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case awsAccount = "awsAccount"
            case awsRegion = "awsRegion"
            case configurationParameters = "configurationParameters"
            case deploymentMode = "deploymentMode"
            case deploymentOrder = "deploymentOrder"
            case description = "description"
            case environmentBlueprintId = "environmentBlueprintId"
            case id = "id"
            case name = "name"
        }
    }

    public struct EnvironmentConfigurationParameter: AWSEncodableShape & AWSDecodableShape {
        /// Specifies whether the environment parameter is editable.
        public let isEditable: Bool?
        /// The name of the environment configuration parameter.
        public let name: String?
        /// The value of the environment configuration parameter.
        public let value: String?

        @inlinable
        public init(isEditable: Bool? = nil, name: String? = nil, value: String? = nil) {
            self.isEditable = isEditable
            self.name = name
            self.value = value
        }

        public func validate(name: String) throws {
            try self.validate(self.name, name: "name", parent: name, pattern: "^[a-zA-Z_][a-zA-Z0-9_]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case isEditable = "isEditable"
            case name = "name"
            case value = "value"
        }
    }

    public struct EnvironmentConfigurationParametersDetails: AWSEncodableShape & AWSDecodableShape {
        /// The parameter overrides.
        public let parameterOverrides: [EnvironmentConfigurationParameter]?
        /// The resolved environment configuration parameters.
        public let resolvedParameters: [EnvironmentConfigurationParameter]?
        /// Ssm path environment configuration parameters.
        public let ssmPath: String?

        @inlinable
        public init(parameterOverrides: [EnvironmentConfigurationParameter]? = nil, resolvedParameters: [EnvironmentConfigurationParameter]? = nil, ssmPath: String? = nil) {
            self.parameterOverrides = parameterOverrides
            self.resolvedParameters = resolvedParameters
            self.ssmPath = ssmPath
        }

        public func validate(name: String) throws {
            try self.parameterOverrides?.forEach {
                try $0.validate(name: "\(name).parameterOverrides[]")
            }
            try self.resolvedParameters?.forEach {
                try $0.validate(name: "\(name).resolvedParameters[]")
            }
            try self.validate(self.ssmPath, name: "ssmPath", parent: name, max: 2048)
            try self.validate(self.ssmPath, name: "ssmPath", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case parameterOverrides = "parameterOverrides"
            case resolvedParameters = "resolvedParameters"
            case ssmPath = "ssmPath"
        }
    }

    public struct EnvironmentConfigurationUserParameter: AWSEncodableShape & AWSDecodableShape {
        /// The environment configuration name.
        public let environmentConfigurationName: String?
        /// The ID of the environment.
        public let environmentId: String?
        /// The environment parameters.
        public let environmentParameters: [EnvironmentParameter]?

        @inlinable
        public init(environmentConfigurationName: String? = nil, environmentId: String? = nil, environmentParameters: [EnvironmentParameter]? = nil) {
            self.environmentConfigurationName = environmentConfigurationName
            self.environmentId = environmentId
            self.environmentParameters = environmentParameters
        }

        public func validate(name: String) throws {
            try self.validate(self.environmentConfigurationName, name: "environmentConfigurationName", parent: name, max: 64)
            try self.validate(self.environmentConfigurationName, name: "environmentConfigurationName", parent: name, min: 1)
            try self.validate(self.environmentConfigurationName, name: "environmentConfigurationName", parent: name, pattern: "^[\\w -]+$")
            try self.validate(self.environmentId, name: "environmentId", parent: name, pattern: "^[a-zA-Z0-9_-]{1,36}$")
        }

        private enum CodingKeys: String, CodingKey {
            case environmentConfigurationName = "environmentConfigurationName"
            case environmentId = "environmentId"
            case environmentParameters = "environmentParameters"
        }
    }

    public struct EnvironmentDeploymentDetails: AWSEncodableShape & AWSDecodableShape {
        /// Environment failure reasons.
        public let environmentFailureReasons: [String: [EnvironmentError]]?
        /// The overall deployment status of the environment.
        public let overallDeploymentStatus: OverallDeploymentStatus?

        @inlinable
        public init(environmentFailureReasons: [String: [EnvironmentError]]? = nil, overallDeploymentStatus: OverallDeploymentStatus? = nil) {
            self.environmentFailureReasons = environmentFailureReasons
            self.overallDeploymentStatus = overallDeploymentStatus
        }

        private enum CodingKeys: String, CodingKey {
            case environmentFailureReasons = "environmentFailureReasons"
            case overallDeploymentStatus = "overallDeploymentStatus"
        }
    }

    public struct EnvironmentError: AWSEncodableShape & AWSDecodableShape {
        /// The error code for the failure reason for the environment deployment.
        public let code: String?
        /// The error message for the failure reason for the environment deployment.
        public let message: String

        @inlinable
        public init(code: String? = nil, message: String) {
            self.code = code
            self.message = message
        }

        private enum CodingKeys: String, CodingKey {
            case code = "code"
            case message = "message"
        }
    }

    public struct EnvironmentParameter: AWSEncodableShape & AWSDecodableShape {
        /// The name of an environment profile parameter.
        public let name: String?
        /// The value of an environment profile parameter.
        public let value: String?

        @inlinable
        public init(name: String? = nil, value: String? = nil) {
            self.name = name
            self.value = value
        }

        private enum CodingKeys: String, CodingKey {
            case name = "name"
            case value = "value"
        }
    }

    public struct EnvironmentProfileSummary: AWSDecodableShape {
        /// The identifier of an Amazon Web Services account in which an environment profile exists.
        public let awsAccountId: String?
        /// The Amazon Web Services Region in which an environment profile exists.
        public let awsAccountRegion: String?
        /// The timestamp of when an environment profile was created.
        public let createdAt: Date?
        /// The Amazon DataZone user who created the environment profile.
        public let createdBy: String
        /// The description of the environment profile.
        public let description: String?
        /// The identifier of the Amazon DataZone domain in which the environment profile exists.
        public let domainId: String
        /// The identifier of a blueprint with which an environment profile is created.
        public let environmentBlueprintId: String
        /// The identifier of the environment profile.
        public let id: String
        /// The name of the environment profile.
        public let name: String
        /// The identifier of a project in which an environment profile exists.
        public let projectId: String?
        /// The timestamp of when the environment profile was updated.
        public let updatedAt: Date?

        @inlinable
        public init(awsAccountId: String? = nil, awsAccountRegion: String? = nil, createdAt: Date? = nil, createdBy: String, description: String? = nil, domainId: String, environmentBlueprintId: String, id: String, name: String, projectId: String? = nil, updatedAt: Date? = nil) {
            self.awsAccountId = awsAccountId
            self.awsAccountRegion = awsAccountRegion
            self.createdAt = createdAt
            self.createdBy = createdBy
            self.description = description
            self.domainId = domainId
            self.environmentBlueprintId = environmentBlueprintId
            self.id = id
            self.name = name
            self.projectId = projectId
            self.updatedAt = updatedAt
        }

        private enum CodingKeys: String, CodingKey {
            case awsAccountId = "awsAccountId"
            case awsAccountRegion = "awsAccountRegion"
            case createdAt = "createdAt"
            case createdBy = "createdBy"
            case description = "description"
            case domainId = "domainId"
            case environmentBlueprintId = "environmentBlueprintId"
            case id = "id"
            case name = "name"
            case projectId = "projectId"
            case updatedAt = "updatedAt"
        }
    }

    public struct EnvironmentSummary: AWSDecodableShape {
        /// The identifier of the Amazon Web Services account in which an environment exists.
        public let awsAccountId: String?
        /// The Amazon Web Services Region in which an environment exists.
        public let awsAccountRegion: String?
        /// The timestamp of when the environment was created.
        public let createdAt: Date?
        /// The Amazon DataZone user who created the environment.
        public let createdBy: String
        /// The description of the environment.
        public let description: String?
        /// The identifier of the Amazon DataZone domain in which the environment exists.
        public let domainId: String
        /// The configuration ID with which the environment is created.
        public let environmentConfigurationId: String?
        /// The identifier of the environment profile with which the environment was created.
        public let environmentProfileId: String?
        /// The identifier of the environment.
        public let id: String?
        /// The name of the environment.
        public let name: String
        /// The identifier of the project in which the environment exists.
        public let projectId: String
        /// The provider of the environment.
        public let provider: String
        /// The status of the environment.
        public let status: EnvironmentStatus?
        /// The timestamp of when the environment was updated.
        public let updatedAt: Date?

        @inlinable
        public init(awsAccountId: String? = nil, awsAccountRegion: String? = nil, createdAt: Date? = nil, createdBy: String, description: String? = nil, domainId: String, environmentConfigurationId: String? = nil, environmentProfileId: String? = nil, id: String? = nil, name: String, projectId: String, provider: String, status: EnvironmentStatus? = nil, updatedAt: Date? = nil) {
            self.awsAccountId = awsAccountId
            self.awsAccountRegion = awsAccountRegion
            self.createdAt = createdAt
            self.createdBy = createdBy
            self.description = description
            self.domainId = domainId
            self.environmentConfigurationId = environmentConfigurationId
            self.environmentProfileId = environmentProfileId
            self.id = id
            self.name = name
            self.projectId = projectId
            self.provider = provider
            self.status = status
            self.updatedAt = updatedAt
        }

        private enum CodingKeys: String, CodingKey {
            case awsAccountId = "awsAccountId"
            case awsAccountRegion = "awsAccountRegion"
            case createdAt = "createdAt"
            case createdBy = "createdBy"
            case description = "description"
            case domainId = "domainId"
            case environmentConfigurationId = "environmentConfigurationId"
            case environmentProfileId = "environmentProfileId"
            case id = "id"
            case name = "name"
            case projectId = "projectId"
            case provider = "provider"
            case status = "status"
            case updatedAt = "updatedAt"
        }
    }

    public struct EqualToExpression: AWSEncodableShape & AWSDecodableShape {
        /// The name of the column.
        public let columnName: String
        /// The value that might be equal to an expression.
        public let value: String

        @inlinable
        public init(columnName: String, value: String) {
            self.columnName = columnName
            self.value = value
        }

        private enum CodingKeys: String, CodingKey {
            case columnName = "columnName"
            case value = "value"
        }
    }

    public struct FailureCause: AWSEncodableShape & AWSDecodableShape {
        /// The description of the error message.
        public let message: String?

        @inlinable
        public init(message: String? = nil) {
            self.message = message
        }

        private enum CodingKeys: String, CodingKey {
            case message = "message"
        }
    }

    public struct Filter: AWSEncodableShape {
        /// A search filter attribute in Amazon DataZone.
        public let attribute: String
        /// A search filter value in Amazon DataZone.
        public let value: String

        @inlinable
        public init(attribute: String, value: String) {
            self.attribute = attribute
            self.value = value
        }

        public func validate(name: String) throws {
            try self.validate(self.attribute, name: "attribute", parent: name, max: 128)
            try self.validate(self.attribute, name: "attribute", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case attribute = "attribute"
            case value = "value"
        }
    }

    public struct FilterExpression: AWSEncodableShape & AWSDecodableShape {
        /// The search filter expression.
        public let expression: String
        /// The search filter explresison type.
        public let type: FilterExpressionType

        @inlinable
        public init(expression: String, type: FilterExpressionType) {
            self.expression = expression
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case expression = "expression"
            case type = "type"
        }
    }

    public struct FormEntryInput: AWSEncodableShape {
        /// Specifies whether a form entry is required.
        public let required: Bool?
        /// The type ID of the form entry.
        public let typeIdentifier: String
        /// The type revision of the form entry.
        public let typeRevision: String

        @inlinable
        public init(required: Bool? = nil, typeIdentifier: String, typeRevision: String) {
            self.required = required
            self.typeIdentifier = typeIdentifier
            self.typeRevision = typeRevision
        }

        public func validate(name: String) throws {
            try self.validate(self.typeIdentifier, name: "typeIdentifier", parent: name, max: 385)
            try self.validate(self.typeIdentifier, name: "typeIdentifier", parent: name, min: 1)
            try self.validate(self.typeIdentifier, name: "typeIdentifier", parent: name, pattern: "^(?!\\.)[\\w\\.]*\\w$")
            try self.validate(self.typeRevision, name: "typeRevision", parent: name, max: 64)
            try self.validate(self.typeRevision, name: "typeRevision", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case required = "required"
            case typeIdentifier = "typeIdentifier"
            case typeRevision = "typeRevision"
        }
    }

    public struct FormEntryOutput: AWSDecodableShape {
        /// Specifies whether a form entry is required.
        public let required: Bool?
        /// The name of the type of the form entry.
        public let typeName: String
        /// The type revision of the form entry.
        public let typeRevision: String

        @inlinable
        public init(required: Bool? = nil, typeName: String, typeRevision: String) {
            self.required = required
            self.typeName = typeName
            self.typeRevision = typeRevision
        }

        private enum CodingKeys: String, CodingKey {
            case required = "required"
            case typeName = "typeName"
            case typeRevision = "typeRevision"
        }
    }

    public struct FormInput: AWSEncodableShape {
        /// The content of the metadata form.
        public let content: String?
        /// The name of the metadata form.
        public let formName: String
        /// The ID of the metadata form type.
        public let typeIdentifier: String?
        /// The revision of the metadata form type.
        public let typeRevision: String?

        @inlinable
        public init(content: String? = nil, formName: String, typeIdentifier: String? = nil, typeRevision: String? = nil) {
            self.content = content
            self.formName = formName
            self.typeIdentifier = typeIdentifier
            self.typeRevision = typeRevision
        }

        public func validate(name: String) throws {
            try self.validate(self.formName, name: "formName", parent: name, max: 128)
            try self.validate(self.formName, name: "formName", parent: name, min: 1)
            try self.validate(self.formName, name: "formName", parent: name, pattern: "^(?![0-9_])\\w+$|^_\\w*[a-zA-Z0-9]\\w*$")
            try self.validate(self.typeIdentifier, name: "typeIdentifier", parent: name, max: 385)
            try self.validate(self.typeIdentifier, name: "typeIdentifier", parent: name, min: 1)
            try self.validate(self.typeIdentifier, name: "typeIdentifier", parent: name, pattern: "^(?!\\.)[\\w\\.]*\\w$")
            try self.validate(self.typeRevision, name: "typeRevision", parent: name, max: 64)
            try self.validate(self.typeRevision, name: "typeRevision", parent: name, min: 1)
            try self.validate(self.typeRevision, name: "typeRevision", parent: name, pattern: "^[a-zA-Z0-9_-]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case content = "content"
            case formName = "formName"
            case typeIdentifier = "typeIdentifier"
            case typeRevision = "typeRevision"
        }
    }

    public struct FormOutput: AWSDecodableShape {
        /// The content of the metadata form.
        public let content: String?
        /// The name of the metadata form.
        public let formName: String
        /// The name of the metadata form type.
        public let typeName: String?
        /// The revision of the metadata form type.
        public let typeRevision: String?

        @inlinable
        public init(content: String? = nil, formName: String, typeName: String? = nil, typeRevision: String? = nil) {
            self.content = content
            self.formName = formName
            self.typeName = typeName
            self.typeRevision = typeRevision
        }

        private enum CodingKeys: String, CodingKey {
            case content = "content"
            case formName = "formName"
            case typeName = "typeName"
            case typeRevision = "typeRevision"
        }
    }

    public struct FormTypeData: AWSDecodableShape {
        /// The timestamp of when the metadata form type was created.
        public let createdAt: Date?
        /// The Amazon DataZone user who created teh metadata form type.
        public let createdBy: String?
        /// The description of the metadata form type.
        public let description: String?
        /// The identifier of the Amazon DataZone domain in which the form type exists.
        public let domainId: String
        /// The imports specified in the form type.
        public let imports: [Import]?
        /// The model of the form type.
        public let model: Model?
        /// The name of the form type.
        public let name: String
        /// The identifier of the Amazon DataZone domain in which the form type was originally created.
        public let originDomainId: String?
        /// The identifier of the project in which the form type was originally created.
        public let originProjectId: String?
        /// The identifier of the project that owns the form type.
        public let owningProjectId: String?
        /// The revision of the form type.
        public let revision: String
        /// The status of the form type.
        public let status: FormTypeStatus?

        @inlinable
        public init(createdAt: Date? = nil, createdBy: String? = nil, description: String? = nil, domainId: String, imports: [Import]? = nil, model: Model? = nil, name: String, originDomainId: String? = nil, originProjectId: String? = nil, owningProjectId: String? = nil, revision: String, status: FormTypeStatus? = nil) {
            self.createdAt = createdAt
            self.createdBy = createdBy
            self.description = description
            self.domainId = domainId
            self.imports = imports
            self.model = model
            self.name = name
            self.originDomainId = originDomainId
            self.originProjectId = originProjectId
            self.owningProjectId = owningProjectId
            self.revision = revision
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case createdAt = "createdAt"
            case createdBy = "createdBy"
            case description = "description"
            case domainId = "domainId"
            case imports = "imports"
            case model = "model"
            case name = "name"
            case originDomainId = "originDomainId"
            case originProjectId = "originProjectId"
            case owningProjectId = "owningProjectId"
            case revision = "revision"
            case status = "status"
        }
    }

    public struct GetAssetFilterInput: AWSEncodableShape {
        /// The ID of the data asset.
        public let assetIdentifier: String
        /// The ID of the domain where you want to get an asset filter.
        public let domainIdentifier: String
        /// The ID of the asset filter.
        public let identifier: String

        @inlinable
        public init(assetIdentifier: String, domainIdentifier: String, identifier: String) {
            self.assetIdentifier = assetIdentifier
            self.domainIdentifier = domainIdentifier
            self.identifier = identifier
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.assetIdentifier, key: "assetIdentifier")
            request.encodePath(self.domainIdentifier, key: "domainIdentifier")
            request.encodePath(self.identifier, key: "identifier")
        }

        public func validate(name: String) throws {
            try self.validate(self.assetIdentifier, name: "assetIdentifier", parent: name, pattern: "^[a-zA-Z0-9_-]{1,36}$")
            try self.validate(self.domainIdentifier, name: "domainIdentifier", parent: name, pattern: "^dzd[-_][a-zA-Z0-9_-]{1,36}$")
            try self.validate(self.identifier, name: "identifier", parent: name, pattern: "^[a-zA-Z0-9_-]{1,36}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetAssetFilterOutput: AWSDecodableShape {
        /// The ID of the data asset.
        public let assetId: String
        /// The configuration of the asset filter.
        public let configuration: AssetFilterConfiguration
        /// The timestamp at which the asset filter was created.
        public let createdAt: Date?
        /// The description of the asset filter.
        public let description: String?
        /// The ID of the domain where you want to get an asset filter.
        public let domainId: String
        /// The column names of the asset filter.
        public let effectiveColumnNames: [String]?
        /// The row filter of the asset filter.
        public let effectiveRowFilter: String?
        /// The error message that is displayed if the action does not complete successfully.
        public let errorMessage: String?
        /// The ID of the asset filter.
        public let id: String
        /// The name of the asset filter.
        public let name: String
        /// The status of the asset filter.
        public let status: FilterStatus?

        @inlinable
        public init(assetId: String, configuration: AssetFilterConfiguration, createdAt: Date? = nil, description: String? = nil, domainId: String, effectiveColumnNames: [String]? = nil, effectiveRowFilter: String? = nil, errorMessage: String? = nil, id: String, name: String, status: FilterStatus? = nil) {
            self.assetId = assetId
            self.configuration = configuration
            self.createdAt = createdAt
            self.description = description
            self.domainId = domainId
            self.effectiveColumnNames = effectiveColumnNames
            self.effectiveRowFilter = effectiveRowFilter
            self.errorMessage = errorMessage
            self.id = id
            self.name = name
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case assetId = "assetId"
            case configuration = "configuration"
            case createdAt = "createdAt"
            case description = "description"
            case domainId = "domainId"
            case effectiveColumnNames = "effectiveColumnNames"
            case effectiveRowFilter = "effectiveRowFilter"
            case errorMessage = "errorMessage"
            case id = "id"
            case name = "name"
            case status = "status"
        }
    }

    public struct GetAssetInput: AWSEncodableShape {
        /// The ID of the Amazon DataZone domain to which the asset belongs.
        public let domainIdentifier: String
        /// The ID of the Amazon DataZone asset.
        public let identifier: String
        /// The revision of the Amazon DataZone asset.
        public let revision: String?

        @inlinable
        public init(domainIdentifier: String, identifier: String, revision: String? = nil) {
            self.domainIdentifier = domainIdentifier
            self.identifier = identifier
            self.revision = revision
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.domainIdentifier, key: "domainIdentifier")
            request.encodePath(self.identifier, key: "identifier")
            request.encodeQuery(self.revision, key: "revision")
        }

        public func validate(name: String) throws {
            try self.validate(self.domainIdentifier, name: "domainIdentifier", parent: name, pattern: "^dzd[-_][a-zA-Z0-9_-]{1,36}$")
            try self.validate(self.identifier, name: "identifier", parent: name, pattern: "^[a-zA-Z0-9_-]{1,36}$")
            try self.validate(self.revision, name: "revision", parent: name, max: 64)
            try self.validate(self.revision, name: "revision", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetAssetOutput: AWSDecodableShape {
        /// The timestamp of when the asset was created.
        public let createdAt: Date?
        /// The Amazon DataZone user who created the asset.
        public let createdBy: String?
        /// The description of the Amazon DataZone asset.
        public let description: String?
        /// The ID of the Amazon DataZone domain to which the asset belongs.
        public let domainId: String
        /// The external ID of the asset.
        public let externalIdentifier: String?
        /// The timestamp of when the first revision of the asset was created.
        public let firstRevisionCreatedAt: Date?
        /// The Amazon DataZone user who created the first revision of the asset.
        public let firstRevisionCreatedBy: String?
        /// The metadata forms attached to the asset.
        public let formsOutput: [FormOutput]
        /// The business glossary terms attached to the asset.
        public let glossaryTerms: [String]?
        /// The ID of the asset.
        public let id: String
        /// The latest data point that was imported into the time series form for the asset.
        public let latestTimeSeriesDataPointFormsOutput: [TimeSeriesDataPointSummaryFormOutput]?
        /// The listing of the asset.
        public let listing: AssetListingDetails?
        /// The name of the asset.
        public let name: String
        /// The ID of the project that owns the asset.
        public let owningProjectId: String
        /// The read-only metadata forms attached to the asset.
        public let readOnlyFormsOutput: [FormOutput]?
        /// The revision of the asset.
        public let revision: String
        /// The ID of the asset type.
        public let typeIdentifier: String
        /// The revision of the asset type.
        public let typeRevision: String

        @inlinable
        public init(createdAt: Date? = nil, createdBy: String? = nil, description: String? = nil, domainId: String, externalIdentifier: String? = nil, firstRevisionCreatedAt: Date? = nil, firstRevisionCreatedBy: String? = nil, formsOutput: [FormOutput], glossaryTerms: [String]? = nil, id: String, latestTimeSeriesDataPointFormsOutput: [TimeSeriesDataPointSummaryFormOutput]? = nil, listing: AssetListingDetails? = nil, name: String, owningProjectId: String, readOnlyFormsOutput: [FormOutput]? = nil, revision: String, typeIdentifier: String, typeRevision: String) {
            self.createdAt = createdAt
            self.createdBy = createdBy
            self.description = description
            self.domainId = domainId
            self.externalIdentifier = externalIdentifier
            self.firstRevisionCreatedAt = firstRevisionCreatedAt
            self.firstRevisionCreatedBy = firstRevisionCreatedBy
            self.formsOutput = formsOutput
            self.glossaryTerms = glossaryTerms
            self.id = id
            self.latestTimeSeriesDataPointFormsOutput = latestTimeSeriesDataPointFormsOutput
            self.listing = listing
            self.name = name
            self.owningProjectId = owningProjectId
            self.readOnlyFormsOutput = readOnlyFormsOutput
            self.revision = revision
            self.typeIdentifier = typeIdentifier
            self.typeRevision = typeRevision
        }

        private enum CodingKeys: String, CodingKey {
            case createdAt = "createdAt"
            case createdBy = "createdBy"
            case description = "description"
            case domainId = "domainId"
            case externalIdentifier = "externalIdentifier"
            case firstRevisionCreatedAt = "firstRevisionCreatedAt"
            case firstRevisionCreatedBy = "firstRevisionCreatedBy"
            case formsOutput = "formsOutput"
            case glossaryTerms = "glossaryTerms"
            case id = "id"
            case latestTimeSeriesDataPointFormsOutput = "latestTimeSeriesDataPointFormsOutput"
            case listing = "listing"
            case name = "name"
            case owningProjectId = "owningProjectId"
            case readOnlyFormsOutput = "readOnlyFormsOutput"
            case revision = "revision"
            case typeIdentifier = "typeIdentifier"
            case typeRevision = "typeRevision"
        }
    }

    public struct GetAssetTypeInput: AWSEncodableShape {
        /// The ID of the Amazon DataZone domain in which the asset type exists.
        public let domainIdentifier: String
        /// The ID of the asset type.
        public let identifier: String
        /// The revision of the asset type.
        public let revision: String?

        @inlinable
        public init(domainIdentifier: String, identifier: String, revision: String? = nil) {
            self.domainIdentifier = domainIdentifier
            self.identifier = identifier
            self.revision = revision
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.domainIdentifier, key: "domainIdentifier")
            request.encodePath(self.identifier, key: "identifier")
            request.encodeQuery(self.revision, key: "revision")
        }

        public func validate(name: String) throws {
            try self.validate(self.domainIdentifier, name: "domainIdentifier", parent: name, pattern: "^dzd[-_][a-zA-Z0-9_-]{1,36}$")
            try self.validate(self.identifier, name: "identifier", parent: name, max: 513)
            try self.validate(self.identifier, name: "identifier", parent: name, min: 1)
            try self.validate(self.identifier, name: "identifier", parent: name, pattern: "^(?!\\.)[\\w\\.]*\\w$")
            try self.validate(self.revision, name: "revision", parent: name, max: 64)
            try self.validate(self.revision, name: "revision", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetAssetTypeOutput: AWSDecodableShape {
        /// The timestamp of when the asset type was created.
        public let createdAt: Date?
        /// The Amazon DataZone user who created the asset type.
        public let createdBy: String?
        /// The description of the asset type.
        public let description: String?
        /// The ID of the Amazon DataZone domain in which the asset type exists.
        public let domainId: String
        /// The metadata forms attached to the asset type.
        public let formsOutput: [String: FormEntryOutput]
        /// The name of the asset type.
        public let name: String
        /// The ID of the Amazon DataZone domain in which the asset type was originally created.
        public let originDomainId: String?
        /// The ID of the Amazon DataZone project in which the asset type was originally created.
        public let originProjectId: String?
        /// The ID of the Amazon DataZone project that owns the asset type.
        public let owningProjectId: String
        /// The revision of the asset type.
        public let revision: String
        /// The timestamp of when the asset type was updated.
        public let updatedAt: Date?
        /// The Amazon DataZone user that updated the asset type.
        public let updatedBy: String?

        @inlinable
        public init(createdAt: Date? = nil, createdBy: String? = nil, description: String? = nil, domainId: String, formsOutput: [String: FormEntryOutput], name: String, originDomainId: String? = nil, originProjectId: String? = nil, owningProjectId: String, revision: String, updatedAt: Date? = nil, updatedBy: String? = nil) {
            self.createdAt = createdAt
            self.createdBy = createdBy
            self.description = description
            self.domainId = domainId
            self.formsOutput = formsOutput
            self.name = name
            self.originDomainId = originDomainId
            self.originProjectId = originProjectId
            self.owningProjectId = owningProjectId
            self.revision = revision
            self.updatedAt = updatedAt
            self.updatedBy = updatedBy
        }

        private enum CodingKeys: String, CodingKey {
            case createdAt = "createdAt"
            case createdBy = "createdBy"
            case description = "description"
            case domainId = "domainId"
            case formsOutput = "formsOutput"
            case name = "name"
            case originDomainId = "originDomainId"
            case originProjectId = "originProjectId"
            case owningProjectId = "owningProjectId"
            case revision = "revision"
            case updatedAt = "updatedAt"
            case updatedBy = "updatedBy"
        }
    }

    public struct GetConnectionInput: AWSEncodableShape {
        /// The ID of the domain where we get the connection.
        public let domainIdentifier: String
        /// The connection ID.
        public let identifier: String
        /// Specifies whether a connection has a secret.
        public let withSecret: Bool?

        @inlinable
        public init(domainIdentifier: String, identifier: String, withSecret: Bool? = nil) {
            self.domainIdentifier = domainIdentifier
            self.identifier = identifier
            self.withSecret = withSecret
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.domainIdentifier, key: "domainIdentifier")
            request.encodePath(self.identifier, key: "identifier")
            request.encodeQuery(self.withSecret, key: "withSecret")
        }

        public func validate(name: String) throws {
            try self.validate(self.domainIdentifier, name: "domainIdentifier", parent: name, pattern: "^dzd[-_][a-zA-Z0-9_-]{1,36}$")
            try self.validate(self.identifier, name: "identifier", parent: name, max: 128)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetConnectionOutput: AWSDecodableShape {
        /// Connection credentials.
        public let connectionCredentials: ConnectionCredentials?
        /// The ID of the connection.
        public let connectionId: String
        /// Connection description.
        public let description: String?
        /// The domain ID of the connection.
        public let domainId: String
        /// The domain unit ID of the connection.
        public let domainUnitId: String
        /// The ID of the environment.
        public let environmentId: String?
        /// The environment user role.
        public let environmentUserRole: String?
        /// The name of the connection.
        public let name: String
        /// The physical endpoints of the connection.
        public let physicalEndpoints: [PhysicalEndpoint]
        /// The ID of the project.
        public let projectId: String?
        /// Connection props.
        public let props: ConnectionPropertiesOutput?
        /// The type of the connection.
        public let type: ConnectionType

        @inlinable
        public init(connectionCredentials: ConnectionCredentials? = nil, connectionId: String, description: String? = nil, domainId: String, domainUnitId: String, environmentId: String? = nil, environmentUserRole: String? = nil, name: String, physicalEndpoints: [PhysicalEndpoint], projectId: String? = nil, props: ConnectionPropertiesOutput? = nil, type: ConnectionType) {
            self.connectionCredentials = connectionCredentials
            self.connectionId = connectionId
            self.description = description
            self.domainId = domainId
            self.domainUnitId = domainUnitId
            self.environmentId = environmentId
            self.environmentUserRole = environmentUserRole
            self.name = name
            self.physicalEndpoints = physicalEndpoints
            self.projectId = projectId
            self.props = props
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case connectionCredentials = "connectionCredentials"
            case connectionId = "connectionId"
            case description = "description"
            case domainId = "domainId"
            case domainUnitId = "domainUnitId"
            case environmentId = "environmentId"
            case environmentUserRole = "environmentUserRole"
            case name = "name"
            case physicalEndpoints = "physicalEndpoints"
            case projectId = "projectId"
            case props = "props"
            case type = "type"
        }
    }

    public struct GetDataProductInput: AWSEncodableShape {
        /// The ID of the domain where the data product lives.
        public let domainIdentifier: String
        /// The ID of the data product.
        public let identifier: String
        /// The revision of the data product.
        public let revision: String?

        @inlinable
        public init(domainIdentifier: String, identifier: String, revision: String? = nil) {
            self.domainIdentifier = domainIdentifier
            self.identifier = identifier
            self.revision = revision
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.domainIdentifier, key: "domainIdentifier")
            request.encodePath(self.identifier, key: "identifier")
            request.encodeQuery(self.revision, key: "revision")
        }

        public func validate(name: String) throws {
            try self.validate(self.domainIdentifier, name: "domainIdentifier", parent: name, pattern: "^dzd[-_][a-zA-Z0-9_-]{1,36}$")
            try self.validate(self.identifier, name: "identifier", parent: name, pattern: "^[a-zA-Z0-9_-]{1,36}$")
            try self.validate(self.revision, name: "revision", parent: name, max: 64)
            try self.validate(self.revision, name: "revision", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetDataProductOutput: AWSDecodableShape {
        /// The timestamp at which the data product is created.
        public let createdAt: Date?
        /// The user who created the data product.
        public let createdBy: String?
        /// The description of the data product.
        public let description: String?
        /// The ID of the domain where the data product lives.
        public let domainId: String
        /// The timestamp at which the first revision of the data product is created.
        public let firstRevisionCreatedAt: Date?
        /// The user who created the first revision of the data product.
        public let firstRevisionCreatedBy: String?
        /// The metadata forms of the data product.
        public let formsOutput: [FormOutput]?
        /// The glossary terms of the data product.
        public let glossaryTerms: [String]?
        /// The ID of the data product.
        public let id: String
        /// The data assets of the data product.
        public let items: [DataProductItem]?
        /// The name of the data product.
        public let name: String
        /// The ID of the owning project of the data product.
        public let owningProjectId: String
        /// The revision of the data product.
        public let revision: String
        /// The status of the data product.
        public let status: DataProductStatus

        @inlinable
        public init(createdAt: Date? = nil, createdBy: String? = nil, description: String? = nil, domainId: String, firstRevisionCreatedAt: Date? = nil, firstRevisionCreatedBy: String? = nil, formsOutput: [FormOutput]? = nil, glossaryTerms: [String]? = nil, id: String, items: [DataProductItem]? = nil, name: String, owningProjectId: String, revision: String, status: DataProductStatus) {
            self.createdAt = createdAt
            self.createdBy = createdBy
            self.description = description
            self.domainId = domainId
            self.firstRevisionCreatedAt = firstRevisionCreatedAt
            self.firstRevisionCreatedBy = firstRevisionCreatedBy
            self.formsOutput = formsOutput
            self.glossaryTerms = glossaryTerms
            self.id = id
            self.items = items
            self.name = name
            self.owningProjectId = owningProjectId
            self.revision = revision
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case createdAt = "createdAt"
            case createdBy = "createdBy"
            case description = "description"
            case domainId = "domainId"
            case firstRevisionCreatedAt = "firstRevisionCreatedAt"
            case firstRevisionCreatedBy = "firstRevisionCreatedBy"
            case formsOutput = "formsOutput"
            case glossaryTerms = "glossaryTerms"
            case id = "id"
            case items = "items"
            case name = "name"
            case owningProjectId = "owningProjectId"
            case revision = "revision"
            case status = "status"
        }
    }

    public struct GetDataSourceInput: AWSEncodableShape {
        /// The ID of the Amazon DataZone domain in which the data source exists.
        public let domainIdentifier: String
        /// The ID of the Amazon DataZone data source.
        public let identifier: String

        @inlinable
        public init(domainIdentifier: String, identifier: String) {
            self.domainIdentifier = domainIdentifier
            self.identifier = identifier
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.domainIdentifier, key: "domainIdentifier")
            request.encodePath(self.identifier, key: "identifier")
        }

        public func validate(name: String) throws {
            try self.validate(self.domainIdentifier, name: "domainIdentifier", parent: name, pattern: "^dzd[-_][a-zA-Z0-9_-]{1,36}$")
            try self.validate(self.identifier, name: "identifier", parent: name, pattern: "^[a-zA-Z0-9_-]{1,36}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetDataSourceOutput: AWSDecodableShape {
        /// The metadata forms attached to the assets created by this data source.
        public let assetFormsOutput: [FormOutput]?
        /// The configuration of the data source.
        public let configuration: DataSourceConfigurationOutput?
        /// The ID of the connection.
        public let connectionId: String?
        /// The timestamp of when the data source was created.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var createdAt: Date?
        /// The description of the data source.
        public let description: String?
        /// The ID of the Amazon DataZone domain in which the data source exists.
        public let domainId: String
        /// Specifies whether this data source is enabled or not.
        public let enableSetting: EnableSetting?
        /// The ID of the environment where this data source creates and publishes assets,
        public let environmentId: String?
        /// Specifies the error message that is returned if the operation cannot be successfully completed.
        public let errorMessage: DataSourceErrorMessage?
        /// The ID of the data source.
        public let id: String
        /// The number of assets created by the data source during its last run.
        public let lastRunAssetCount: Int?
        /// The timestamp of the last run of the data source.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var lastRunAt: Date?
        /// Specifies the error message that is returned if the operation cannot be successfully completed.
        public let lastRunErrorMessage: DataSourceErrorMessage?
        /// The status of the last run of the data source.
        public let lastRunStatus: DataSourceRunStatus?
        /// The name of the data source.
        public let name: String
        /// The ID of the project where the data source creates and publishes assets.
        public let projectId: String
        /// Specifies whether the assets that this data source creates in the inventory are to be also automatically published to the catalog.
        public let publishOnImport: Bool?
        /// The recommendation configuration of the data source.
        public let recommendation: RecommendationConfiguration?
        /// The schedule of the data source runs.
        public let schedule: ScheduleConfiguration?
        /// Specifies the status of the self-granting functionality.
        public let selfGrantStatus: SelfGrantStatusOutput?
        /// The status of the data source.
        public let status: DataSourceStatus?
        /// The type of the data source.
        public let type: String?
        /// The timestamp of when the data source was updated.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var updatedAt: Date?

        @inlinable
        public init(assetFormsOutput: [FormOutput]? = nil, configuration: DataSourceConfigurationOutput? = nil, connectionId: String? = nil, createdAt: Date? = nil, description: String? = nil, domainId: String, enableSetting: EnableSetting? = nil, environmentId: String? = nil, errorMessage: DataSourceErrorMessage? = nil, id: String, lastRunAssetCount: Int? = nil, lastRunAt: Date? = nil, lastRunErrorMessage: DataSourceErrorMessage? = nil, lastRunStatus: DataSourceRunStatus? = nil, name: String, projectId: String, publishOnImport: Bool? = nil, recommendation: RecommendationConfiguration? = nil, schedule: ScheduleConfiguration? = nil, selfGrantStatus: SelfGrantStatusOutput? = nil, status: DataSourceStatus? = nil, type: String? = nil, updatedAt: Date? = nil) {
            self.assetFormsOutput = assetFormsOutput
            self.configuration = configuration
            self.connectionId = connectionId
            self.createdAt = createdAt
            self.description = description
            self.domainId = domainId
            self.enableSetting = enableSetting
            self.environmentId = environmentId
            self.errorMessage = errorMessage
            self.id = id
            self.lastRunAssetCount = lastRunAssetCount
            self.lastRunAt = lastRunAt
            self.lastRunErrorMessage = lastRunErrorMessage
            self.lastRunStatus = lastRunStatus
            self.name = name
            self.projectId = projectId
            self.publishOnImport = publishOnImport
            self.recommendation = recommendation
            self.schedule = schedule
            self.selfGrantStatus = selfGrantStatus
            self.status = status
            self.type = type
            self.updatedAt = updatedAt
        }

        private enum CodingKeys: String, CodingKey {
            case assetFormsOutput = "assetFormsOutput"
            case configuration = "configuration"
            case connectionId = "connectionId"
            case createdAt = "createdAt"
            case description = "description"
            case domainId = "domainId"
            case enableSetting = "enableSetting"
            case environmentId = "environmentId"
            case errorMessage = "errorMessage"
            case id = "id"
            case lastRunAssetCount = "lastRunAssetCount"
            case lastRunAt = "lastRunAt"
            case lastRunErrorMessage = "lastRunErrorMessage"
            case lastRunStatus = "lastRunStatus"
            case name = "name"
            case projectId = "projectId"
            case publishOnImport = "publishOnImport"
            case recommendation = "recommendation"
            case schedule = "schedule"
            case selfGrantStatus = "selfGrantStatus"
            case status = "status"
            case type = "type"
            case updatedAt = "updatedAt"
        }
    }

    public struct GetDataSourceRunInput: AWSEncodableShape {
        /// The ID of the domain in which this data source run was performed.
        public let domainIdentifier: String
        /// The ID of the data source run.
        public let identifier: String

        @inlinable
        public init(domainIdentifier: String, identifier: String) {
            self.domainIdentifier = domainIdentifier
            self.identifier = identifier
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.domainIdentifier, key: "domainIdentifier")
            request.encodePath(self.identifier, key: "identifier")
        }

        public func validate(name: String) throws {
            try self.validate(self.domainIdentifier, name: "domainIdentifier", parent: name, pattern: "^dzd[-_][a-zA-Z0-9_-]{1,36}$")
            try self.validate(self.identifier, name: "identifier", parent: name, pattern: "^[a-zA-Z0-9_-]{1,36}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetDataSourceRunOutput: AWSDecodableShape {
        /// The timestamp of when the data source run was created.
        @CustomCoding<ISO8601DateCoder>
        public var createdAt: Date
        /// The configuration snapshot of the data source run.
        public let dataSourceConfigurationSnapshot: String?
        /// The ID of the data source for this data source run.
        public let dataSourceId: String
        /// The ID of the domain in which this data source run was performed.
        public let domainId: String
        /// Specifies the error message that is returned if the operation cannot be successfully completed.
        public let errorMessage: DataSourceErrorMessage?
        /// The ID of the data source run.
        public let id: String
        /// The summary of the data lineage.
        public let lineageSummary: DataSourceRunLineageSummary?
        /// The ID of the project in which this data source run occured.
        public let projectId: String
        /// The asset statistics from this data source run.
        public let runStatisticsForAssets: RunStatisticsForAssets?
        /// The timestamp of when this data source run started.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var startedAt: Date?
        /// The status of this data source run.
        public let status: DataSourceRunStatus
        /// The timestamp of when this data source run stopped.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var stoppedAt: Date?
        /// The type of this data source run.
        public let type: DataSourceRunType
        /// The timestamp of when this data source run was updated.
        @CustomCoding<ISO8601DateCoder>
        public var updatedAt: Date

        @inlinable
        public init(createdAt: Date, dataSourceConfigurationSnapshot: String? = nil, dataSourceId: String, domainId: String, errorMessage: DataSourceErrorMessage? = nil, id: String, lineageSummary: DataSourceRunLineageSummary? = nil, projectId: String, runStatisticsForAssets: RunStatisticsForAssets? = nil, startedAt: Date? = nil, status: DataSourceRunStatus, stoppedAt: Date? = nil, type: DataSourceRunType, updatedAt: Date) {
            self.createdAt = createdAt
            self.dataSourceConfigurationSnapshot = dataSourceConfigurationSnapshot
            self.dataSourceId = dataSourceId
            self.domainId = domainId
            self.errorMessage = errorMessage
            self.id = id
            self.lineageSummary = lineageSummary
            self.projectId = projectId
            self.runStatisticsForAssets = runStatisticsForAssets
            self.startedAt = startedAt
            self.status = status
            self.stoppedAt = stoppedAt
            self.type = type
            self.updatedAt = updatedAt
        }

        private enum CodingKeys: String, CodingKey {
            case createdAt = "createdAt"
            case dataSourceConfigurationSnapshot = "dataSourceConfigurationSnapshot"
            case dataSourceId = "dataSourceId"
            case domainId = "domainId"
            case errorMessage = "errorMessage"
            case id = "id"
            case lineageSummary = "lineageSummary"
            case projectId = "projectId"
            case runStatisticsForAssets = "runStatisticsForAssets"
            case startedAt = "startedAt"
            case status = "status"
            case stoppedAt = "stoppedAt"
            case type = "type"
            case updatedAt = "updatedAt"
        }
    }

    public struct GetDomainInput: AWSEncodableShape {
        /// The identifier of the specified Amazon DataZone domain.
        public let identifier: String

        @inlinable
        public init(identifier: String) {
            self.identifier = identifier
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.identifier, key: "identifier")
        }

        public func validate(name: String) throws {
            try self.validate(self.identifier, name: "identifier", parent: name, pattern: "^dzd[-_][a-zA-Z0-9_-]{1,36}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetDomainOutput: AWSDecodableShape {
        /// The ARN of the specified Amazon DataZone domain.
        public let arn: String?
        /// The timestamp of when the Amazon DataZone domain was created.
        public let createdAt: Date?
        /// The description of the Amazon DataZone domain.
        public let description: String?
        /// The domain execution role with which the Amazon DataZone domain is created.
        public let domainExecutionRole: String
        /// The version of the domain.
        public let domainVersion: DomainVersion?
        /// The identifier of the specified Amazon DataZone domain.
        public let id: String
        /// The identifier of the Amazon Web Services Key Management Service (KMS) key that is used to encrypt the Amazon DataZone domain, metadata, and reporting data.
        public let kmsKeyIdentifier: String?
        /// The timestamp of when the Amazon DataZone domain was last updated.
        public let lastUpdatedAt: Date?
        /// The name of the Amazon DataZone domain.
        public let name: String?
        /// The URL of the data portal for this Amazon DataZone domain.
        public let portalUrl: String?
        /// The ID of the root domain in Amazon Datazone.
        public let rootDomainUnitId: String?
        /// The service role of the domain.
        public let serviceRole: String?
        /// The single sing-on option of the specified Amazon DataZone domain.
        public let singleSignOn: SingleSignOn?
        /// The status of the specified Amazon DataZone domain.
        public let status: DomainStatus
        /// The tags specified for the Amazon DataZone domain.
        public let tags: [String: String]?

        @inlinable
        public init(arn: String? = nil, createdAt: Date? = nil, description: String? = nil, domainExecutionRole: String, domainVersion: DomainVersion? = nil, id: String, kmsKeyIdentifier: String? = nil, lastUpdatedAt: Date? = nil, name: String? = nil, portalUrl: String? = nil, rootDomainUnitId: String? = nil, serviceRole: String? = nil, singleSignOn: SingleSignOn? = nil, status: DomainStatus, tags: [String: String]? = nil) {
            self.arn = arn
            self.createdAt = createdAt
            self.description = description
            self.domainExecutionRole = domainExecutionRole
            self.domainVersion = domainVersion
            self.id = id
            self.kmsKeyIdentifier = kmsKeyIdentifier
            self.lastUpdatedAt = lastUpdatedAt
            self.name = name
            self.portalUrl = portalUrl
            self.rootDomainUnitId = rootDomainUnitId
            self.serviceRole = serviceRole
            self.singleSignOn = singleSignOn
            self.status = status
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case createdAt = "createdAt"
            case description = "description"
            case domainExecutionRole = "domainExecutionRole"
            case domainVersion = "domainVersion"
            case id = "id"
            case kmsKeyIdentifier = "kmsKeyIdentifier"
            case lastUpdatedAt = "lastUpdatedAt"
            case name = "name"
            case portalUrl = "portalUrl"
            case rootDomainUnitId = "rootDomainUnitId"
            case serviceRole = "serviceRole"
            case singleSignOn = "singleSignOn"
            case status = "status"
            case tags = "tags"
        }
    }

    public struct GetDomainUnitInput: AWSEncodableShape {
        /// The ID of the domain where you want to get a domain unit.
        public let domainIdentifier: String
        /// The identifier of the domain unit that you want to get.
        public let identifier: String

        @inlinable
        public init(domainIdentifier: String, identifier: String) {
            self.domainIdentifier = domainIdentifier
            self.identifier = identifier
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.domainIdentifier, key: "domainIdentifier")
            request.encodePath(self.identifier, key: "identifier")
        }

        public func validate(name: String) throws {
            try self.validate(self.domainIdentifier, name: "domainIdentifier", parent: name, pattern: "^dzd[-_][a-zA-Z0-9_-]{1,36}$")
            try self.validate(self.identifier, name: "identifier", parent: name, max: 256)
            try self.validate(self.identifier, name: "identifier", parent: name, min: 1)
            try self.validate(self.identifier, name: "identifier", parent: name, pattern: "^[a-z0-9_\\-]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetDomainUnitOutput: AWSDecodableShape {
        /// The time stamp at which the domain unit was created.
        public let createdAt: Date?
        /// The user who created the domain unit.
        public let createdBy: String?
        /// The description of the domain unit.
        public let description: String?
        /// The ID of the domain in which the domain unit lives.
        public let domainId: String
        /// The ID of the domain unit.
        public let id: String
        /// The timestamp at which the domain unit was last updated.
        public let lastUpdatedAt: Date?
        /// The user who last updated the domain unit.
        public let lastUpdatedBy: String?
        /// The name of the domain unit.
        public let name: String
        /// The owners of the domain unit.
        public let owners: [DomainUnitOwnerProperties]
        /// The ID of the parent domain unit.
        public let parentDomainUnitId: String?

        @inlinable
        public init(createdAt: Date? = nil, createdBy: String? = nil, description: String? = nil, domainId: String, id: String, lastUpdatedAt: Date? = nil, lastUpdatedBy: String? = nil, name: String, owners: [DomainUnitOwnerProperties], parentDomainUnitId: String? = nil) {
            self.createdAt = createdAt
            self.createdBy = createdBy
            self.description = description
            self.domainId = domainId
            self.id = id
            self.lastUpdatedAt = lastUpdatedAt
            self.lastUpdatedBy = lastUpdatedBy
            self.name = name
            self.owners = owners
            self.parentDomainUnitId = parentDomainUnitId
        }

        private enum CodingKeys: String, CodingKey {
            case createdAt = "createdAt"
            case createdBy = "createdBy"
            case description = "description"
            case domainId = "domainId"
            case id = "id"
            case lastUpdatedAt = "lastUpdatedAt"
            case lastUpdatedBy = "lastUpdatedBy"
            case name = "name"
            case owners = "owners"
            case parentDomainUnitId = "parentDomainUnitId"
        }
    }

    public struct GetEnvironmentActionInput: AWSEncodableShape {
        /// The ID of the Amazon DataZone domain in which the GetEnvironmentAction API is invoked.
        public let domainIdentifier: String
        /// The environment ID of the environment action.
        public let environmentIdentifier: String
        /// The ID of the environment action
        public let identifier: String

        @inlinable
        public init(domainIdentifier: String, environmentIdentifier: String, identifier: String) {
            self.domainIdentifier = domainIdentifier
            self.environmentIdentifier = environmentIdentifier
            self.identifier = identifier
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.domainIdentifier, key: "domainIdentifier")
            request.encodePath(self.environmentIdentifier, key: "environmentIdentifier")
            request.encodePath(self.identifier, key: "identifier")
        }

        public func validate(name: String) throws {
            try self.validate(self.domainIdentifier, name: "domainIdentifier", parent: name, pattern: "^dzd[-_][a-zA-Z0-9_-]{1,36}$")
            try self.validate(self.environmentIdentifier, name: "environmentIdentifier", parent: name, pattern: "^[a-zA-Z0-9_-]{1,36}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetEnvironmentActionOutput: AWSDecodableShape {
        /// The description of the environment action.
        public let description: String?
        /// The ID of the Amazon DataZone domain in which the environment action lives.
        public let domainId: String
        /// The environment ID of the environment action.
        public let environmentId: String
        /// The ID of the environment action.
        public let id: String
        /// The name of the environment action.
        public let name: String
        /// The parameters of the environment action.
        public let parameters: ActionParameters

        @inlinable
        public init(description: String? = nil, domainId: String, environmentId: String, id: String, name: String, parameters: ActionParameters) {
            self.description = description
            self.domainId = domainId
            self.environmentId = environmentId
            self.id = id
            self.name = name
            self.parameters = parameters
        }

        private enum CodingKeys: String, CodingKey {
            case description = "description"
            case domainId = "domainId"
            case environmentId = "environmentId"
            case id = "id"
            case name = "name"
            case parameters = "parameters"
        }
    }

    public struct GetEnvironmentBlueprintConfigurationInput: AWSEncodableShape {
        /// The ID of the Amazon DataZone domain where this blueprint exists.
        public let domainIdentifier: String
        /// He ID of the blueprint.
        public let environmentBlueprintIdentifier: String

        @inlinable
        public init(domainIdentifier: String, environmentBlueprintIdentifier: String) {
            self.domainIdentifier = domainIdentifier
            self.environmentBlueprintIdentifier = environmentBlueprintIdentifier
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.domainIdentifier, key: "domainIdentifier")
            request.encodePath(self.environmentBlueprintIdentifier, key: "environmentBlueprintIdentifier")
        }

        public func validate(name: String) throws {
            try self.validate(self.domainIdentifier, name: "domainIdentifier", parent: name, pattern: "^dzd[-_][a-zA-Z0-9_-]{1,36}$")
            try self.validate(self.environmentBlueprintIdentifier, name: "environmentBlueprintIdentifier", parent: name, pattern: "^[a-zA-Z0-9_-]{1,36}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetEnvironmentBlueprintConfigurationOutput: AWSDecodableShape {
        /// The timestamp of when this blueprint was created.
        public let createdAt: Date?
        /// The ID of the Amazon DataZone domain where this blueprint exists.
        public let domainId: String
        /// The Amazon Web Services regions in which this blueprint is enabled.
        public let enabledRegions: [String]?
        /// The ID of the blueprint.
        public let environmentBlueprintId: String
        /// The environment role permissions boundary.
        public let environmentRolePermissionBoundary: String?
        /// The ARN of the manage access role with which this blueprint is created.
        public let manageAccessRoleArn: String?
        /// The provisioning configuration of a blueprint.
        public let provisioningConfigurations: [ProvisioningConfiguration]?
        /// The ARN of the provisioning role with which this blueprint is created.
        public let provisioningRoleArn: String?
        /// The regional parameters of the blueprint.
        public let regionalParameters: [String: [String: String]]?
        /// The timestamp of when this blueprint was upated.
        public let updatedAt: Date?

        @inlinable
        public init(createdAt: Date? = nil, domainId: String, enabledRegions: [String]? = nil, environmentBlueprintId: String, environmentRolePermissionBoundary: String? = nil, manageAccessRoleArn: String? = nil, provisioningConfigurations: [ProvisioningConfiguration]? = nil, provisioningRoleArn: String? = nil, regionalParameters: [String: [String: String]]? = nil, updatedAt: Date? = nil) {
            self.createdAt = createdAt
            self.domainId = domainId
            self.enabledRegions = enabledRegions
            self.environmentBlueprintId = environmentBlueprintId
            self.environmentRolePermissionBoundary = environmentRolePermissionBoundary
            self.manageAccessRoleArn = manageAccessRoleArn
            self.provisioningConfigurations = provisioningConfigurations
            self.provisioningRoleArn = provisioningRoleArn
            self.regionalParameters = regionalParameters
            self.updatedAt = updatedAt
        }

        private enum CodingKeys: String, CodingKey {
            case createdAt = "createdAt"
            case domainId = "domainId"
            case enabledRegions = "enabledRegions"
            case environmentBlueprintId = "environmentBlueprintId"
            case environmentRolePermissionBoundary = "environmentRolePermissionBoundary"
            case manageAccessRoleArn = "manageAccessRoleArn"
            case provisioningConfigurations = "provisioningConfigurations"
            case provisioningRoleArn = "provisioningRoleArn"
            case regionalParameters = "regionalParameters"
            case updatedAt = "updatedAt"
        }
    }

    public struct GetEnvironmentBlueprintInput: AWSEncodableShape {
        /// The identifier of the domain in which this blueprint exists.
        public let domainIdentifier: String
        /// The ID of this Amazon DataZone blueprint.
        public let identifier: String

        @inlinable
        public init(domainIdentifier: String, identifier: String) {
            self.domainIdentifier = domainIdentifier
            self.identifier = identifier
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.domainIdentifier, key: "domainIdentifier")
            request.encodePath(self.identifier, key: "identifier")
        }

        public func validate(name: String) throws {
            try self.validate(self.domainIdentifier, name: "domainIdentifier", parent: name, pattern: "^dzd[-_][a-zA-Z0-9_-]{1,36}$")
            try self.validate(self.identifier, name: "identifier", parent: name, pattern: "^[a-zA-Z0-9_-]{1,36}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetEnvironmentBlueprintOutput: AWSDecodableShape {
        /// A timestamp of when this blueprint was created.
        public let createdAt: Date?
        /// The deployment properties of this Amazon DataZone blueprint.
        public let deploymentProperties: DeploymentProperties?
        /// The description of this Amazon DataZone blueprint.
        public let description: String?
        /// The glossary terms attached to this Amazon DataZone blueprint.
        public let glossaryTerms: [String]?
        /// The ID of this Amazon DataZone blueprint.
        public let id: String
        /// The name of this Amazon DataZone blueprint.
        public let name: String
        /// The provider of this Amazon DataZone blueprint.
        public let provider: String
        /// The provisioning properties of this Amazon DataZone blueprint.
        public let provisioningProperties: ProvisioningProperties
        /// The timestamp of when this blueprint was updated.
        public let updatedAt: Date?
        /// The user parameters of this blueprint.
        public let userParameters: [CustomParameter]?

        @inlinable
        public init(createdAt: Date? = nil, deploymentProperties: DeploymentProperties? = nil, description: String? = nil, glossaryTerms: [String]? = nil, id: String, name: String, provider: String, provisioningProperties: ProvisioningProperties, updatedAt: Date? = nil, userParameters: [CustomParameter]? = nil) {
            self.createdAt = createdAt
            self.deploymentProperties = deploymentProperties
            self.description = description
            self.glossaryTerms = glossaryTerms
            self.id = id
            self.name = name
            self.provider = provider
            self.provisioningProperties = provisioningProperties
            self.updatedAt = updatedAt
            self.userParameters = userParameters
        }

        private enum CodingKeys: String, CodingKey {
            case createdAt = "createdAt"
            case deploymentProperties = "deploymentProperties"
            case description = "description"
            case glossaryTerms = "glossaryTerms"
            case id = "id"
            case name = "name"
            case provider = "provider"
            case provisioningProperties = "provisioningProperties"
            case updatedAt = "updatedAt"
            case userParameters = "userParameters"
        }
    }

    public struct GetEnvironmentCredentialsInput: AWSEncodableShape {
        /// The ID of the Amazon DataZone domain in which this environment and its credentials exist.
        public let domainIdentifier: String
        /// The ID of the environment whose credentials this operation gets.
        public let environmentIdentifier: String

        @inlinable
        public init(domainIdentifier: String, environmentIdentifier: String) {
            self.domainIdentifier = domainIdentifier
            self.environmentIdentifier = environmentIdentifier
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.domainIdentifier, key: "domainIdentifier")
            request.encodePath(self.environmentIdentifier, key: "environmentIdentifier")
        }

        public func validate(name: String) throws {
            try self.validate(self.domainIdentifier, name: "domainIdentifier", parent: name, pattern: "^dzd[-_][a-zA-Z0-9_-]{1,36}$")
            try self.validate(self.environmentIdentifier, name: "environmentIdentifier", parent: name, pattern: "^[a-zA-Z0-9_-]{1,36}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetEnvironmentCredentialsOutput: AWSDecodableShape {
        /// The access key ID of the environment.
        public let accessKeyId: String?
        /// The expiration timestamp of the environment credentials.
        public let expiration: Date?
        /// The secret access key of the environment credentials.
        public let secretAccessKey: String?
        /// The session token of the environment credentials.
        public let sessionToken: String?

        @inlinable
        public init(accessKeyId: String? = nil, expiration: Date? = nil, secretAccessKey: String? = nil, sessionToken: String? = nil) {
            self.accessKeyId = accessKeyId
            self.expiration = expiration
            self.secretAccessKey = secretAccessKey
            self.sessionToken = sessionToken
        }

        private enum CodingKeys: String, CodingKey {
            case accessKeyId = "accessKeyId"
            case expiration = "expiration"
            case secretAccessKey = "secretAccessKey"
            case sessionToken = "sessionToken"
        }
    }

    public struct GetEnvironmentInput: AWSEncodableShape {
        /// The ID of the Amazon DataZone domain where the environment exists.
        public let domainIdentifier: String
        /// The ID of the Amazon DataZone environment.
        public let identifier: String

        @inlinable
        public init(domainIdentifier: String, identifier: String) {
            self.domainIdentifier = domainIdentifier
            self.identifier = identifier
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.domainIdentifier, key: "domainIdentifier")
            request.encodePath(self.identifier, key: "identifier")
        }

        public func validate(name: String) throws {
            try self.validate(self.domainIdentifier, name: "domainIdentifier", parent: name, pattern: "^dzd[-_][a-zA-Z0-9_-]{1,36}$")
            try self.validate(self.identifier, name: "identifier", parent: name, pattern: "^[a-zA-Z0-9_-]{1,36}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetEnvironmentOutput: AWSDecodableShape {
        /// The ID of the Amazon Web Services account where the environment exists.
        public let awsAccountId: String?
        /// The Amazon Web Services region where the environment exists.
        public let awsAccountRegion: String?
        /// The timestamp of when the environment was created.
        public let createdAt: Date?
        /// The Amazon DataZone user who created the environment.
        public let createdBy: String
        /// The deployment properties of the environment.
        public let deploymentProperties: DeploymentProperties?
        /// The description of the environment.
        public let description: String?
        /// The ID of the Amazon DataZone domain where the environment exists.
        public let domainId: String
        /// The actions of the environment.
        public let environmentActions: [ConfigurableEnvironmentAction]?
        /// The blueprint with which the environment is created.
        public let environmentBlueprintId: String?
        /// The configuration ID that is used to create the environment.
        public let environmentConfigurationId: String?
        /// The ID of the environment profile with which the environment is created.
        public let environmentProfileId: String?
        /// The business glossary terms that can be used in this environment.
        public let glossaryTerms: [String]?
        /// The ID of the environment.
        public let id: String?
        /// The details of the last deployment of the environment.
        public let lastDeployment: Deployment?
        /// The name of the environment.
        public let name: String
        /// The ID of the Amazon DataZone project in which this environment is created.
        public let projectId: String
        /// The provider of this Amazon DataZone environment.
        public let provider: String
        /// The provisioned resources of this Amazon DataZone environment.
        public let provisionedResources: [Resource]?
        /// The provisioning properties of this Amazon DataZone environment.
        public let provisioningProperties: ProvisioningProperties?
        /// The status of this Amazon DataZone environment.
        public let status: EnvironmentStatus?
        /// The timestamp of when this environment was updated.
        public let updatedAt: Date?
        /// The user parameters of this Amazon DataZone environment.
        public let userParameters: [CustomParameter]?

        @inlinable
        public init(awsAccountId: String? = nil, awsAccountRegion: String? = nil, createdAt: Date? = nil, createdBy: String, deploymentProperties: DeploymentProperties? = nil, description: String? = nil, domainId: String, environmentActions: [ConfigurableEnvironmentAction]? = nil, environmentBlueprintId: String? = nil, environmentConfigurationId: String? = nil, environmentProfileId: String? = nil, glossaryTerms: [String]? = nil, id: String? = nil, lastDeployment: Deployment? = nil, name: String, projectId: String, provider: String, provisionedResources: [Resource]? = nil, provisioningProperties: ProvisioningProperties? = nil, status: EnvironmentStatus? = nil, updatedAt: Date? = nil, userParameters: [CustomParameter]? = nil) {
            self.awsAccountId = awsAccountId
            self.awsAccountRegion = awsAccountRegion
            self.createdAt = createdAt
            self.createdBy = createdBy
            self.deploymentProperties = deploymentProperties
            self.description = description
            self.domainId = domainId
            self.environmentActions = environmentActions
            self.environmentBlueprintId = environmentBlueprintId
            self.environmentConfigurationId = environmentConfigurationId
            self.environmentProfileId = environmentProfileId
            self.glossaryTerms = glossaryTerms
            self.id = id
            self.lastDeployment = lastDeployment
            self.name = name
            self.projectId = projectId
            self.provider = provider
            self.provisionedResources = provisionedResources
            self.provisioningProperties = provisioningProperties
            self.status = status
            self.updatedAt = updatedAt
            self.userParameters = userParameters
        }

        private enum CodingKeys: String, CodingKey {
            case awsAccountId = "awsAccountId"
            case awsAccountRegion = "awsAccountRegion"
            case createdAt = "createdAt"
            case createdBy = "createdBy"
            case deploymentProperties = "deploymentProperties"
            case description = "description"
            case domainId = "domainId"
            case environmentActions = "environmentActions"
            case environmentBlueprintId = "environmentBlueprintId"
            case environmentConfigurationId = "environmentConfigurationId"
            case environmentProfileId = "environmentProfileId"
            case glossaryTerms = "glossaryTerms"
            case id = "id"
            case lastDeployment = "lastDeployment"
            case name = "name"
            case projectId = "projectId"
            case provider = "provider"
            case provisionedResources = "provisionedResources"
            case provisioningProperties = "provisioningProperties"
            case status = "status"
            case updatedAt = "updatedAt"
            case userParameters = "userParameters"
        }
    }

    public struct GetEnvironmentProfileInput: AWSEncodableShape {
        /// The ID of the Amazon DataZone domain in which this environment profile exists.
        public let domainIdentifier: String
        /// The ID of the environment profile.
        public let identifier: String

        @inlinable
        public init(domainIdentifier: String, identifier: String) {
            self.domainIdentifier = domainIdentifier
            self.identifier = identifier
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.domainIdentifier, key: "domainIdentifier")
            request.encodePath(self.identifier, key: "identifier")
        }

        public func validate(name: String) throws {
            try self.validate(self.domainIdentifier, name: "domainIdentifier", parent: name, pattern: "^dzd[-_][a-zA-Z0-9_-]{1,36}$")
            try self.validate(self.identifier, name: "identifier", parent: name, pattern: "^[a-zA-Z0-9_-]{0,36}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetEnvironmentProfileOutput: AWSDecodableShape {
        /// The ID of the Amazon Web Services account where this environment profile exists.
        public let awsAccountId: String?
        /// The Amazon Web Services region where this environment profile exists.
        public let awsAccountRegion: String?
        /// The timestamp of when this environment profile was created.
        public let createdAt: Date?
        /// The Amazon DataZone user who created this environment profile.
        public let createdBy: String
        /// The description of the environment profile.
        public let description: String?
        /// The ID of the Amazon DataZone domain in which this environment profile exists.
        public let domainId: String
        /// The ID of the blueprint with which this environment profile is created.
        public let environmentBlueprintId: String
        /// The ID of the environment profile.
        public let id: String
        /// The name of the environment profile.
        public let name: String
        /// The ID of the Amazon DataZone project in which this environment profile is created.
        public let projectId: String?
        /// The timestamp of when this environment profile was upated.
        public let updatedAt: Date?
        /// The user parameters of the environment profile.
        public let userParameters: [CustomParameter]?

        @inlinable
        public init(awsAccountId: String? = nil, awsAccountRegion: String? = nil, createdAt: Date? = nil, createdBy: String, description: String? = nil, domainId: String, environmentBlueprintId: String, id: String, name: String, projectId: String? = nil, updatedAt: Date? = nil, userParameters: [CustomParameter]? = nil) {
            self.awsAccountId = awsAccountId
            self.awsAccountRegion = awsAccountRegion
            self.createdAt = createdAt
            self.createdBy = createdBy
            self.description = description
            self.domainId = domainId
            self.environmentBlueprintId = environmentBlueprintId
            self.id = id
            self.name = name
            self.projectId = projectId
            self.updatedAt = updatedAt
            self.userParameters = userParameters
        }

        private enum CodingKeys: String, CodingKey {
            case awsAccountId = "awsAccountId"
            case awsAccountRegion = "awsAccountRegion"
            case createdAt = "createdAt"
            case createdBy = "createdBy"
            case description = "description"
            case domainId = "domainId"
            case environmentBlueprintId = "environmentBlueprintId"
            case id = "id"
            case name = "name"
            case projectId = "projectId"
            case updatedAt = "updatedAt"
            case userParameters = "userParameters"
        }
    }

    public struct GetFormTypeInput: AWSEncodableShape {
        /// The ID of the Amazon DataZone domain in which this metadata form type exists.
        public let domainIdentifier: String
        /// The ID of the metadata form type.
        public let formTypeIdentifier: String
        /// The revision of this metadata form type.
        public let revision: String?

        @inlinable
        public init(domainIdentifier: String, formTypeIdentifier: String, revision: String? = nil) {
            self.domainIdentifier = domainIdentifier
            self.formTypeIdentifier = formTypeIdentifier
            self.revision = revision
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.domainIdentifier, key: "domainIdentifier")
            request.encodePath(self.formTypeIdentifier, key: "formTypeIdentifier")
            request.encodeQuery(self.revision, key: "revision")
        }

        public func validate(name: String) throws {
            try self.validate(self.domainIdentifier, name: "domainIdentifier", parent: name, pattern: "^dzd[-_][a-zA-Z0-9_-]{1,36}$")
            try self.validate(self.formTypeIdentifier, name: "formTypeIdentifier", parent: name, max: 385)
            try self.validate(self.formTypeIdentifier, name: "formTypeIdentifier", parent: name, min: 1)
            try self.validate(self.formTypeIdentifier, name: "formTypeIdentifier", parent: name, pattern: "^(?!\\.)[\\w\\.]*\\w$")
            try self.validate(self.revision, name: "revision", parent: name, max: 64)
            try self.validate(self.revision, name: "revision", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetFormTypeOutput: AWSDecodableShape {
        /// The timestamp of when this metadata form type was created.
        public let createdAt: Date?
        /// The Amazon DataZone user who created this metadata form type.
        public let createdBy: String?
        /// The description of the metadata form type.
        public let description: String?
        /// The ID of the Amazon DataZone domain in which this metadata form type exists.
        public let domainId: String
        /// The imports of the metadata form type.
        public let imports: [Import]?
        /// The model of the metadata form type.
        public let model: Model
        /// The name of the metadata form type.
        public let name: String
        /// The ID of the Amazon DataZone domain in which the metadata form type was originally created.
        public let originDomainId: String?
        /// The ID of the project in which this metadata form type was originally created.
        public let originProjectId: String?
        /// The ID of the project that owns this metadata form type.
        public let owningProjectId: String?
        /// The revision of the metadata form type.
        public let revision: String
        /// The status of the metadata form type.
        public let status: FormTypeStatus?

        @inlinable
        public init(createdAt: Date? = nil, createdBy: String? = nil, description: String? = nil, domainId: String, imports: [Import]? = nil, model: Model, name: String, originDomainId: String? = nil, originProjectId: String? = nil, owningProjectId: String? = nil, revision: String, status: FormTypeStatus? = nil) {
            self.createdAt = createdAt
            self.createdBy = createdBy
            self.description = description
            self.domainId = domainId
            self.imports = imports
            self.model = model
            self.name = name
            self.originDomainId = originDomainId
            self.originProjectId = originProjectId
            self.owningProjectId = owningProjectId
            self.revision = revision
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case createdAt = "createdAt"
            case createdBy = "createdBy"
            case description = "description"
            case domainId = "domainId"
            case imports = "imports"
            case model = "model"
            case name = "name"
            case originDomainId = "originDomainId"
            case originProjectId = "originProjectId"
            case owningProjectId = "owningProjectId"
            case revision = "revision"
            case status = "status"
        }
    }

    public struct GetGlossaryInput: AWSEncodableShape {
        /// The ID of the Amazon DataZone domain in which this business glossary exists.
        public let domainIdentifier: String
        /// The ID of the business glossary.
        public let identifier: String

        @inlinable
        public init(domainIdentifier: String, identifier: String) {
            self.domainIdentifier = domainIdentifier
            self.identifier = identifier
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.domainIdentifier, key: "domainIdentifier")
            request.encodePath(self.identifier, key: "identifier")
        }

        public func validate(name: String) throws {
            try self.validate(self.domainIdentifier, name: "domainIdentifier", parent: name, pattern: "^dzd[-_][a-zA-Z0-9_-]{1,36}$")
            try self.validate(self.identifier, name: "identifier", parent: name, pattern: "^[a-zA-Z0-9_-]{1,36}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetGlossaryOutput: AWSDecodableShape {
        /// The timestamp of when this business glossary was created.
        public let createdAt: Date?
        /// The Amazon DataZone user who created this business glossary.
        public let createdBy: String?
        /// The description of the business glossary.
        public let description: String?
        /// The ID of the Amazon DataZone domain in which this business glossary exists.
        public let domainId: String
        /// The ID of the business glossary.
        public let id: String
        /// The name of the business glossary.
        public let name: String
        /// The ID of the project that owns this business glossary.
        public let owningProjectId: String
        /// The status of the business glossary.
        public let status: GlossaryStatus
        /// The timestamp of when the business glossary was updated.
        public let updatedAt: Date?
        /// The Amazon DataZone user who updated the business glossary.
        public let updatedBy: String?

        @inlinable
        public init(createdAt: Date? = nil, createdBy: String? = nil, description: String? = nil, domainId: String, id: String, name: String, owningProjectId: String, status: GlossaryStatus, updatedAt: Date? = nil, updatedBy: String? = nil) {
            self.createdAt = createdAt
            self.createdBy = createdBy
            self.description = description
            self.domainId = domainId
            self.id = id
            self.name = name
            self.owningProjectId = owningProjectId
            self.status = status
            self.updatedAt = updatedAt
            self.updatedBy = updatedBy
        }

        private enum CodingKeys: String, CodingKey {
            case createdAt = "createdAt"
            case createdBy = "createdBy"
            case description = "description"
            case domainId = "domainId"
            case id = "id"
            case name = "name"
            case owningProjectId = "owningProjectId"
            case status = "status"
            case updatedAt = "updatedAt"
            case updatedBy = "updatedBy"
        }
    }

    public struct GetGlossaryTermInput: AWSEncodableShape {
        /// The ID of the Amazon DataZone domain in which this business glossary term exists.
        public let domainIdentifier: String
        /// The ID of the business glossary term.
        public let identifier: String

        @inlinable
        public init(domainIdentifier: String, identifier: String) {
            self.domainIdentifier = domainIdentifier
            self.identifier = identifier
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.domainIdentifier, key: "domainIdentifier")
            request.encodePath(self.identifier, key: "identifier")
        }

        public func validate(name: String) throws {
            try self.validate(self.domainIdentifier, name: "domainIdentifier", parent: name, pattern: "^dzd[-_][a-zA-Z0-9_-]{1,36}$")
            try self.validate(self.identifier, name: "identifier", parent: name, pattern: "^[a-zA-Z0-9_-]{1,36}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetGlossaryTermOutput: AWSDecodableShape {
        /// The timestamp of when the business glossary term was created.
        public let createdAt: Date?
        /// The Amazon DataZone user who created the business glossary.
        public let createdBy: String?
        /// The ID of the Amazon DataZone domain in which this business glossary term exists.
        public let domainId: String
        /// The ID of the business glossary to which this term belongs.
        public let glossaryId: String
        /// The ID of the business glossary term.
        public let id: String
        /// The long description of the business glossary term.
        public let longDescription: String?
        /// The name of the business glossary term.
        public let name: String
        /// The short decription of the business glossary term.
        public let shortDescription: String?
        /// The status of the business glossary term.
        public let status: GlossaryTermStatus
        /// The relations of the business glossary term.
        public let termRelations: TermRelations?
        /// The timestamp of when the business glossary term was updated.
        public let updatedAt: Date?
        /// The Amazon DataZone user who updated the business glossary term.
        public let updatedBy: String?

        @inlinable
        public init(createdAt: Date? = nil, createdBy: String? = nil, domainId: String, glossaryId: String, id: String, longDescription: String? = nil, name: String, shortDescription: String? = nil, status: GlossaryTermStatus, termRelations: TermRelations? = nil, updatedAt: Date? = nil, updatedBy: String? = nil) {
            self.createdAt = createdAt
            self.createdBy = createdBy
            self.domainId = domainId
            self.glossaryId = glossaryId
            self.id = id
            self.longDescription = longDescription
            self.name = name
            self.shortDescription = shortDescription
            self.status = status
            self.termRelations = termRelations
            self.updatedAt = updatedAt
            self.updatedBy = updatedBy
        }

        private enum CodingKeys: String, CodingKey {
            case createdAt = "createdAt"
            case createdBy = "createdBy"
            case domainId = "domainId"
            case glossaryId = "glossaryId"
            case id = "id"
            case longDescription = "longDescription"
            case name = "name"
            case shortDescription = "shortDescription"
            case status = "status"
            case termRelations = "termRelations"
            case updatedAt = "updatedAt"
            case updatedBy = "updatedBy"
        }
    }

    public struct GetGroupProfileInput: AWSEncodableShape {
        /// The identifier of the Amazon DataZone domain in which the group profile exists.
        public let domainIdentifier: String
        /// The identifier of the group profile.
        public let groupIdentifier: String

        @inlinable
        public init(domainIdentifier: String, groupIdentifier: String) {
            self.domainIdentifier = domainIdentifier
            self.groupIdentifier = groupIdentifier
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.domainIdentifier, key: "domainIdentifier")
            request.encodePath(self.groupIdentifier, key: "groupIdentifier")
        }

        public func validate(name: String) throws {
            try self.validate(self.domainIdentifier, name: "domainIdentifier", parent: name, pattern: "^dzd[-_][a-zA-Z0-9_-]{1,36}$")
            try self.validate(self.groupIdentifier, name: "groupIdentifier", parent: name, pattern: "(^([0-9a-f]{10}-|)[A-Fa-f0-9]{8}-[A-Fa-f0-9]{4}-[A-Fa-f0-9]{4}-[A-Fa-f0-9]{4}-[A-Fa-f0-9]{12}$|[\\p{L}\\p{M}\\p{S}\\p{N}\\p{P}\\t\\n\\r  ]+)")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetGroupProfileOutput: AWSDecodableShape {
        /// The identifier of the Amazon DataZone domain in which the group profile exists.
        public let domainId: String?
        /// The name of the group for which the specified group profile exists.
        public let groupName: String?
        /// The identifier of the group profile.
        public let id: String?
        /// The identifier of the group profile.
        public let status: GroupProfileStatus?

        @inlinable
        public init(domainId: String? = nil, groupName: String? = nil, id: String? = nil, status: GroupProfileStatus? = nil) {
            self.domainId = domainId
            self.groupName = groupName
            self.id = id
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case domainId = "domainId"
            case groupName = "groupName"
            case id = "id"
            case status = "status"
        }
    }

    public struct GetIamPortalLoginUrlInput: AWSEncodableShape {
        /// the ID of the Amazon DataZone domain the data portal of which you want to get.
        public let domainIdentifier: String

        @inlinable
        public init(domainIdentifier: String) {
            self.domainIdentifier = domainIdentifier
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.domainIdentifier, key: "domainIdentifier")
        }

        public func validate(name: String) throws {
            try self.validate(self.domainIdentifier, name: "domainIdentifier", parent: name, pattern: "^dzd[-_][a-zA-Z0-9_-]{1,36}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetIamPortalLoginUrlOutput: AWSDecodableShape {
        /// The data portal URL of the specified Amazon DataZone domain.
        public let authCodeUrl: String?
        /// The ID of the user profile.
        public let userProfileId: String

        @inlinable
        public init(authCodeUrl: String? = nil, userProfileId: String) {
            self.authCodeUrl = authCodeUrl
            self.userProfileId = userProfileId
        }

        private enum CodingKeys: String, CodingKey {
            case authCodeUrl = "authCodeUrl"
            case userProfileId = "userProfileId"
        }
    }

    public struct GetJobRunInput: AWSEncodableShape {
        /// The ID of the domain.
        public let domainIdentifier: String
        /// The ID of the job run.
        public let identifier: String

        @inlinable
        public init(domainIdentifier: String, identifier: String) {
            self.domainIdentifier = domainIdentifier
            self.identifier = identifier
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.domainIdentifier, key: "domainIdentifier")
            request.encodePath(self.identifier, key: "identifier")
        }

        public func validate(name: String) throws {
            try self.validate(self.domainIdentifier, name: "domainIdentifier", parent: name, pattern: "^dzd[-_][a-zA-Z0-9_-]{1,36}$")
            try self.validate(self.identifier, name: "identifier", parent: name, pattern: "^[a-zA-Z0-9_-]{1,36}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetJobRunOutput: AWSDecodableShape {
        /// The timestamp of when the job run was created.
        public let createdAt: Date?
        /// The user who created the job run.
        public let createdBy: String?
        /// The details of the job run.
        public let details: JobRunDetails?
        /// The ID of the domain.
        public let domainId: String?
        /// The timestamp of when the job run ended.
        public let endTime: Date?
        /// The error generated if the action is not completed successfully.
        public let error: JobRunError?
        /// The ID of the job run.
        public let id: String?
        /// The ID of the job run.
        public let jobId: String?
        /// The type of the job run.
        public let jobType: JobType?
        /// The mode of the job run.
        public let runMode: JobRunMode?
        /// The timestamp of when the job run started.
        public let startTime: Date?
        /// The status of the job run.
        public let status: JobRunStatus?

        @inlinable
        public init(createdAt: Date? = nil, createdBy: String? = nil, details: JobRunDetails? = nil, domainId: String? = nil, endTime: Date? = nil, error: JobRunError? = nil, id: String? = nil, jobId: String? = nil, jobType: JobType? = nil, runMode: JobRunMode? = nil, startTime: Date? = nil, status: JobRunStatus? = nil) {
            self.createdAt = createdAt
            self.createdBy = createdBy
            self.details = details
            self.domainId = domainId
            self.endTime = endTime
            self.error = error
            self.id = id
            self.jobId = jobId
            self.jobType = jobType
            self.runMode = runMode
            self.startTime = startTime
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case createdAt = "createdAt"
            case createdBy = "createdBy"
            case details = "details"
            case domainId = "domainId"
            case endTime = "endTime"
            case error = "error"
            case id = "id"
            case jobId = "jobId"
            case jobType = "jobType"
            case runMode = "runMode"
            case startTime = "startTime"
            case status = "status"
        }
    }

    public struct GetLineageEventInput: AWSEncodableShape {
        /// The ID of the domain.
        public let domainIdentifier: String
        /// The ID of the lineage event.
        public let identifier: String

        @inlinable
        public init(domainIdentifier: String, identifier: String) {
            self.domainIdentifier = domainIdentifier
            self.identifier = identifier
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.domainIdentifier, key: "domainIdentifier")
            request.encodePath(self.identifier, key: "identifier")
        }

        public func validate(name: String) throws {
            try self.validate(self.domainIdentifier, name: "domainIdentifier", parent: name, pattern: "^dzd[-_][a-zA-Z0-9_-]{1,36}$")
            try self.validate(self.identifier, name: "identifier", parent: name, pattern: "^[a-z0-9]{14}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetLineageEventOutput: AWSDecodableShape {
        public static let _options: AWSShapeOptions = [.rawPayload]
        /// The timestamp of when the lineage event was created.
        @OptionalCustomCoding<HTTPHeaderDateCoder>
        public var createdAt: Date?
        /// The user who created the lineage event.
        public let createdBy: String?
        /// The ID of the domain.
        public let domainId: String?
        /// The lineage event details.
        public let event: AWSHTTPBody
        /// The time of the lineage event.
        @OptionalCustomCoding<HTTPHeaderDateCoder>
        public var eventTime: Date?
        /// The ID of the lineage event.
        public let id: String?
        /// The progressing status of the lineage event.
        public let processingStatus: LineageEventProcessingStatus?

        @inlinable
        public init(createdAt: Date? = nil, createdBy: String? = nil, domainId: String? = nil, event: AWSHTTPBody, eventTime: Date? = nil, id: String? = nil, processingStatus: LineageEventProcessingStatus? = nil) {
            self.createdAt = createdAt
            self.createdBy = createdBy
            self.domainId = domainId
            self.event = event
            self.eventTime = eventTime
            self.id = id
            self.processingStatus = processingStatus
        }

        public init(from decoder: Decoder) throws {
            let response = decoder.userInfo[.awsResponse]! as! ResponseDecodingContainer
            let container = try decoder.singleValueContainer()
            self.createdAt = try response.decodeHeaderIfPresent(Date.self, key: "Created-At")
            self.createdBy = try response.decodeHeaderIfPresent(String.self, key: "Created-By")
            self.domainId = try response.decodeHeaderIfPresent(String.self, key: "Domain-Id")
            self.event = try container.decode(AWSHTTPBody.self)
            self.eventTime = try response.decodeHeaderIfPresent(Date.self, key: "Event-Time")
            self.id = try response.decodeHeaderIfPresent(String.self, key: "Id")
            self.processingStatus = try response.decodeHeaderIfPresent(LineageEventProcessingStatus.self, key: "Processing-Status")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetLineageNodeInput: AWSEncodableShape {
        /// The ID of the domain in which you want to get the data lineage node.
        public let domainIdentifier: String
        /// The event time stamp for which you want to get the data lineage node.
        public let eventTimestamp: Date?
        /// The ID of the data lineage node that you want to get. Both, a lineage node identifier generated by Amazon DataZone and a sourceIdentifier of the lineage node are supported. If sourceIdentifier is greater than 1800 characters, you can use lineage node identifier generated by Amazon DataZone to get the node details.
        public let identifier: String

        @inlinable
        public init(domainIdentifier: String, eventTimestamp: Date? = nil, identifier: String) {
            self.domainIdentifier = domainIdentifier
            self.eventTimestamp = eventTimestamp
            self.identifier = identifier
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.domainIdentifier, key: "domainIdentifier")
            request.encodeQuery(self.eventTimestamp, key: "timestamp")
            request.encodePath(self.identifier, key: "identifier")
        }

        public func validate(name: String) throws {
            try self.validate(self.domainIdentifier, name: "domainIdentifier", parent: name, pattern: "^dzd[-_][a-zA-Z0-9_-]{1,36}$")
            try self.validate(self.identifier, name: "identifier", parent: name, max: 2086)
            try self.validate(self.identifier, name: "identifier", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetLineageNodeOutput: AWSDecodableShape {
        /// The timestamp at which the data lineage node was created.
        public let createdAt: Date?
        /// The user who created the data lineage node.
        public let createdBy: String?
        /// The description of the data lineage node.
        public let description: String?
        /// The ID of the domain where you're getting the data lineage node.
        public let domainId: String
        /// The downsteam nodes of the specified data lineage node.
        public let downstreamNodes: [LineageNodeReference]?
        /// The timestamp of the event described in the data lineage node.
        public let eventTimestamp: Date?
        /// The metadata of the specified data lineage node.
        public let formsOutput: [FormOutput]?
        /// The ID of the data lineage node.
        public let id: String
        /// The name of the data lineage node.
        public let name: String?
        /// The source identifier of the data lineage node.
        public let sourceIdentifier: String?
        /// The name of the type of the specified data lineage node.
        public let typeName: String
        /// The revision type of the specified data lineage node.
        public let typeRevision: String?
        /// The timestamp at which the data lineage node was updated.
        public let updatedAt: Date?
        /// The user who updated the data lineage node.
        public let updatedBy: String?
        /// The upstream nodes of the specified data lineage node.
        public let upstreamNodes: [LineageNodeReference]?

        @inlinable
        public init(createdAt: Date? = nil, createdBy: String? = nil, description: String? = nil, domainId: String, downstreamNodes: [LineageNodeReference]? = nil, eventTimestamp: Date? = nil, formsOutput: [FormOutput]? = nil, id: String, name: String? = nil, sourceIdentifier: String? = nil, typeName: String, typeRevision: String? = nil, updatedAt: Date? = nil, updatedBy: String? = nil, upstreamNodes: [LineageNodeReference]? = nil) {
            self.createdAt = createdAt
            self.createdBy = createdBy
            self.description = description
            self.domainId = domainId
            self.downstreamNodes = downstreamNodes
            self.eventTimestamp = eventTimestamp
            self.formsOutput = formsOutput
            self.id = id
            self.name = name
            self.sourceIdentifier = sourceIdentifier
            self.typeName = typeName
            self.typeRevision = typeRevision
            self.updatedAt = updatedAt
            self.updatedBy = updatedBy
            self.upstreamNodes = upstreamNodes
        }

        private enum CodingKeys: String, CodingKey {
            case createdAt = "createdAt"
            case createdBy = "createdBy"
            case description = "description"
            case domainId = "domainId"
            case downstreamNodes = "downstreamNodes"
            case eventTimestamp = "eventTimestamp"
            case formsOutput = "formsOutput"
            case id = "id"
            case name = "name"
            case sourceIdentifier = "sourceIdentifier"
            case typeName = "typeName"
            case typeRevision = "typeRevision"
            case updatedAt = "updatedAt"
            case updatedBy = "updatedBy"
            case upstreamNodes = "upstreamNodes"
        }
    }

    public struct GetListingInput: AWSEncodableShape {
        /// The ID of the Amazon DataZone domain.
        public let domainIdentifier: String
        /// The ID of the listing.
        public let identifier: String
        /// The revision of the listing.
        public let listingRevision: String?

        @inlinable
        public init(domainIdentifier: String, identifier: String, listingRevision: String? = nil) {
            self.domainIdentifier = domainIdentifier
            self.identifier = identifier
            self.listingRevision = listingRevision
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.domainIdentifier, key: "domainIdentifier")
            request.encodePath(self.identifier, key: "identifier")
            request.encodeQuery(self.listingRevision, key: "listingRevision")
        }

        public func validate(name: String) throws {
            try self.validate(self.domainIdentifier, name: "domainIdentifier", parent: name, pattern: "^dzd[-_][a-zA-Z0-9_-]{1,36}$")
            try self.validate(self.identifier, name: "identifier", parent: name, pattern: "^[a-zA-Z0-9_-]{1,36}$")
            try self.validate(self.listingRevision, name: "listingRevision", parent: name, max: 64)
            try self.validate(self.listingRevision, name: "listingRevision", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetListingOutput: AWSDecodableShape {
        /// The timestamp of when the listing was created.
        public let createdAt: Date?
        /// The Amazon DataZone user who created the listing.
        public let createdBy: String?
        /// The description of the listing.
        public let description: String?
        /// The ID of the Amazon DataZone domain.
        public let domainId: String
        /// The ID of the listing.
        public let id: String
        /// The details of a listing.
        public let item: ListingItem?
        /// The revision of a listing.
        public let listingRevision: String
        /// The name of the listing.
        public let name: String?
        /// The status of the listing.
        public let status: ListingStatus?
        /// The timestamp of when the listing was updated.
        public let updatedAt: Date?
        /// The Amazon DataZone user who updated the listing.
        public let updatedBy: String?

        @inlinable
        public init(createdAt: Date? = nil, createdBy: String? = nil, description: String? = nil, domainId: String, id: String, item: ListingItem? = nil, listingRevision: String, name: String? = nil, status: ListingStatus? = nil, updatedAt: Date? = nil, updatedBy: String? = nil) {
            self.createdAt = createdAt
            self.createdBy = createdBy
            self.description = description
            self.domainId = domainId
            self.id = id
            self.item = item
            self.listingRevision = listingRevision
            self.name = name
            self.status = status
            self.updatedAt = updatedAt
            self.updatedBy = updatedBy
        }

        private enum CodingKeys: String, CodingKey {
            case createdAt = "createdAt"
            case createdBy = "createdBy"
            case description = "description"
            case domainId = "domainId"
            case id = "id"
            case item = "item"
            case listingRevision = "listingRevision"
            case name = "name"
            case status = "status"
            case updatedAt = "updatedAt"
            case updatedBy = "updatedBy"
        }
    }

    public struct GetMetadataGenerationRunInput: AWSEncodableShape {
        /// The ID of the Amazon DataZone domain the metadata generation run of which you want to get.
        public let domainIdentifier: String
        /// The identifier of the metadata generation run.
        public let identifier: String

        @inlinable
        public init(domainIdentifier: String, identifier: String) {
            self.domainIdentifier = domainIdentifier
            self.identifier = identifier
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.domainIdentifier, key: "domainIdentifier")
            request.encodePath(self.identifier, key: "identifier")
        }

        public func validate(name: String) throws {
            try self.validate(self.domainIdentifier, name: "domainIdentifier", parent: name, pattern: "^dzd[-_][a-zA-Z0-9_-]{1,36}$")
            try self.validate(self.identifier, name: "identifier", parent: name, pattern: "^[a-zA-Z0-9_-]{1,36}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetMetadataGenerationRunOutput: AWSDecodableShape {
        /// The timestamp of when the metadata generation run was start.
        public let createdAt: Date?
        /// The Amazon DataZone user who started the metadata generation run.
        public let createdBy: String?
        /// The ID of the Amazon DataZone domain the metadata generation run of which you want to get.
        public let domainId: String
        /// The ID of the metadata generation run.
        public let id: String
        /// The ID of the project that owns the assets for which you're running metadata generation.
        public let owningProjectId: String
        /// The status of the metadata generation run.
        public let status: MetadataGenerationRunStatus?
        /// The asset for which you're generating metadata.
        public let target: MetadataGenerationRunTarget?
        /// The type of metadata generation run.
        public let type: MetadataGenerationRunType?

        @inlinable
        public init(createdAt: Date? = nil, createdBy: String? = nil, domainId: String, id: String, owningProjectId: String, status: MetadataGenerationRunStatus? = nil, target: MetadataGenerationRunTarget? = nil, type: MetadataGenerationRunType? = nil) {
            self.createdAt = createdAt
            self.createdBy = createdBy
            self.domainId = domainId
            self.id = id
            self.owningProjectId = owningProjectId
            self.status = status
            self.target = target
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case createdAt = "createdAt"
            case createdBy = "createdBy"
            case domainId = "domainId"
            case id = "id"
            case owningProjectId = "owningProjectId"
            case status = "status"
            case target = "target"
            case type = "type"
        }
    }

    public struct GetProjectInput: AWSEncodableShape {
        /// The ID of the Amazon DataZone domain in which the project exists.
        public let domainIdentifier: String
        /// The ID of the project.
        public let identifier: String

        @inlinable
        public init(domainIdentifier: String, identifier: String) {
            self.domainIdentifier = domainIdentifier
            self.identifier = identifier
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.domainIdentifier, key: "domainIdentifier")
            request.encodePath(self.identifier, key: "identifier")
        }

        public func validate(name: String) throws {
            try self.validate(self.domainIdentifier, name: "domainIdentifier", parent: name, pattern: "^dzd[-_][a-zA-Z0-9_-]{1,36}$")
            try self.validate(self.identifier, name: "identifier", parent: name, pattern: "^[a-zA-Z0-9_-]{1,36}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetProjectOutput: AWSDecodableShape {
        /// The timestamp of when the project was created.
        public let createdAt: Date?
        /// The Amazon DataZone user who created the project.
        public let createdBy: String
        /// The description of the project.
        public let description: String?
        /// The ID of the Amazon DataZone domain in which the project exists.
        public let domainId: String
        /// The ID of the domain unit.
        public let domainUnitId: String?
        /// The environment deployment status of a project.
        public let environmentDeploymentDetails: EnvironmentDeploymentDetails?
        /// Specifies the error message that is returned if the operation cannot be successfully completed.
        public let failureReasons: [ProjectDeletionError]?
        /// The business glossary terms that can be used in the project.
        public let glossaryTerms: [String]?
        /// &gt;The ID of the project.
        public let id: String
        /// The timestamp of when the project was last updated.
        public let lastUpdatedAt: Date?
        /// The name of the project.
        public let name: String
        /// The ID of the project profile of a project.
        public let projectProfileId: String?
        /// The status of the project.
        public let projectStatus: ProjectStatus?
        /// The user parameters of a project.
        public let userParameters: [EnvironmentConfigurationUserParameter]?

        @inlinable
        public init(createdAt: Date? = nil, createdBy: String, description: String? = nil, domainId: String, domainUnitId: String? = nil, environmentDeploymentDetails: EnvironmentDeploymentDetails? = nil, failureReasons: [ProjectDeletionError]? = nil, glossaryTerms: [String]? = nil, id: String, lastUpdatedAt: Date? = nil, name: String, projectProfileId: String? = nil, projectStatus: ProjectStatus? = nil, userParameters: [EnvironmentConfigurationUserParameter]? = nil) {
            self.createdAt = createdAt
            self.createdBy = createdBy
            self.description = description
            self.domainId = domainId
            self.domainUnitId = domainUnitId
            self.environmentDeploymentDetails = environmentDeploymentDetails
            self.failureReasons = failureReasons
            self.glossaryTerms = glossaryTerms
            self.id = id
            self.lastUpdatedAt = lastUpdatedAt
            self.name = name
            self.projectProfileId = projectProfileId
            self.projectStatus = projectStatus
            self.userParameters = userParameters
        }

        private enum CodingKeys: String, CodingKey {
            case createdAt = "createdAt"
            case createdBy = "createdBy"
            case description = "description"
            case domainId = "domainId"
            case domainUnitId = "domainUnitId"
            case environmentDeploymentDetails = "environmentDeploymentDetails"
            case failureReasons = "failureReasons"
            case glossaryTerms = "glossaryTerms"
            case id = "id"
            case lastUpdatedAt = "lastUpdatedAt"
            case name = "name"
            case projectProfileId = "projectProfileId"
            case projectStatus = "projectStatus"
            case userParameters = "userParameters"
        }
    }

    public struct GetProjectProfileInput: AWSEncodableShape {
        /// The ID of the domain.
        public let domainIdentifier: String
        /// The ID of the project profile.
        public let identifier: String

        @inlinable
        public init(domainIdentifier: String, identifier: String) {
            self.domainIdentifier = domainIdentifier
            self.identifier = identifier
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.domainIdentifier, key: "domainIdentifier")
            request.encodePath(self.identifier, key: "identifier")
        }

        public func validate(name: String) throws {
            try self.validate(self.domainIdentifier, name: "domainIdentifier", parent: name, pattern: "^dzd[-_][a-zA-Z0-9_-]{1,36}$")
            try self.validate(self.identifier, name: "identifier", parent: name, pattern: "^[a-zA-Z0-9_-]{1,36}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetProjectProfileOutput: AWSDecodableShape {
        /// The timestamp of when the project profile was created.
        public let createdAt: Date?
        /// The user who created the project profile.
        public let createdBy: String
        /// The description of the project profile.
        public let description: String?
        /// The ID of the domain of the project profile.
        public let domainId: String
        /// The ID of the domain unit of the project profile.
        public let domainUnitId: String?
        /// The environment configurations of the project profile.
        public let environmentConfigurations: [EnvironmentConfiguration]?
        /// The ID of the project profile.
        public let id: String
        /// The timestamp of when project profile was last updated.
        public let lastUpdatedAt: Date?
        /// The name of the project profile.
        public let name: String
        /// The status of the project profile.
        public let status: Status?

        @inlinable
        public init(createdAt: Date? = nil, createdBy: String, description: String? = nil, domainId: String, domainUnitId: String? = nil, environmentConfigurations: [EnvironmentConfiguration]? = nil, id: String, lastUpdatedAt: Date? = nil, name: String, status: Status? = nil) {
            self.createdAt = createdAt
            self.createdBy = createdBy
            self.description = description
            self.domainId = domainId
            self.domainUnitId = domainUnitId
            self.environmentConfigurations = environmentConfigurations
            self.id = id
            self.lastUpdatedAt = lastUpdatedAt
            self.name = name
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case createdAt = "createdAt"
            case createdBy = "createdBy"
            case description = "description"
            case domainId = "domainId"
            case domainUnitId = "domainUnitId"
            case environmentConfigurations = "environmentConfigurations"
            case id = "id"
            case lastUpdatedAt = "lastUpdatedAt"
            case name = "name"
            case status = "status"
        }
    }

    public struct GetRuleInput: AWSEncodableShape {
        /// The ID of the domain where the GetRule action is to be invoked.
        public let domainIdentifier: String
        /// The ID of the rule.
        public let identifier: String
        /// The revision of the rule.
        public let revision: String?

        @inlinable
        public init(domainIdentifier: String, identifier: String, revision: String? = nil) {
            self.domainIdentifier = domainIdentifier
            self.identifier = identifier
            self.revision = revision
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.domainIdentifier, key: "domainIdentifier")
            request.encodePath(self.identifier, key: "identifier")
            request.encodeQuery(self.revision, key: "revision")
        }

        public func validate(name: String) throws {
            try self.validate(self.domainIdentifier, name: "domainIdentifier", parent: name, pattern: "^dzd[-_][a-zA-Z0-9_-]{1,36}$")
            try self.validate(self.identifier, name: "identifier", parent: name, pattern: "^[a-zA-Z0-9_-]{1,36}$")
            try self.validate(self.revision, name: "revision", parent: name, max: 64)
            try self.validate(self.revision, name: "revision", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetRuleOutput: AWSDecodableShape {
        /// The action of the rule.
        public let action: RuleAction
        /// The timestamp at which the rule was created.
        public let createdAt: Date
        /// The user who created the rule.
        public let createdBy: String
        /// The description of the rule.
        public let description: String?
        /// The detail of the rule.
        public let detail: RuleDetail
        /// The ID of the rule.
        public let identifier: String
        /// The timestamp at which the rule was last updated.
        public let lastUpdatedBy: String
        /// The name of the rule.
        public let name: String
        /// The revision of the rule.
        public let revision: String
        /// The type of the rule.
        public let ruleType: RuleType
        /// The scope of the rule.
        public let scope: RuleScope
        /// The target of the rule.
        public let target: RuleTarget
        /// The target type of the rule.
        public let targetType: RuleTargetType?
        /// The timestamp at which the rule was last updated.
        public let updatedAt: Date

        @inlinable
        public init(action: RuleAction, createdAt: Date, createdBy: String, description: String? = nil, detail: RuleDetail, identifier: String, lastUpdatedBy: String, name: String, revision: String, ruleType: RuleType, scope: RuleScope, target: RuleTarget, targetType: RuleTargetType? = nil, updatedAt: Date) {
            self.action = action
            self.createdAt = createdAt
            self.createdBy = createdBy
            self.description = description
            self.detail = detail
            self.identifier = identifier
            self.lastUpdatedBy = lastUpdatedBy
            self.name = name
            self.revision = revision
            self.ruleType = ruleType
            self.scope = scope
            self.target = target
            self.targetType = targetType
            self.updatedAt = updatedAt
        }

        private enum CodingKeys: String, CodingKey {
            case action = "action"
            case createdAt = "createdAt"
            case createdBy = "createdBy"
            case description = "description"
            case detail = "detail"
            case identifier = "identifier"
            case lastUpdatedBy = "lastUpdatedBy"
            case name = "name"
            case revision = "revision"
            case ruleType = "ruleType"
            case scope = "scope"
            case target = "target"
            case targetType = "targetType"
            case updatedAt = "updatedAt"
        }
    }

    public struct GetSubscriptionGrantInput: AWSEncodableShape {
        /// The ID of the Amazon DataZone domain in which the subscription grant exists.
        public let domainIdentifier: String
        /// The ID of the subscription grant.
        public let identifier: String

        @inlinable
        public init(domainIdentifier: String, identifier: String) {
            self.domainIdentifier = domainIdentifier
            self.identifier = identifier
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.domainIdentifier, key: "domainIdentifier")
            request.encodePath(self.identifier, key: "identifier")
        }

        public func validate(name: String) throws {
            try self.validate(self.domainIdentifier, name: "domainIdentifier", parent: name, pattern: "^dzd[-_][a-zA-Z0-9_-]{1,36}$")
            try self.validate(self.identifier, name: "identifier", parent: name, pattern: "^[a-zA-Z0-9_-]{1,36}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetSubscriptionGrantOutput: AWSDecodableShape {
        /// The assets for which the subscription grant is created.
        public let assets: [SubscribedAsset]?
        /// The timestamp of when the subscription grant is created.
        public let createdAt: Date
        /// The Amazon DataZone user who created the subscription grant.
        public let createdBy: String
        /// The ID of the Amazon DataZone domain in which the subscription grant exists.
        public let domainId: String
        /// The entity to which the subscription is granted.
        public let grantedEntity: GrantedEntity
        /// The ID of the subscription grant.
        public let id: String
        /// The status of the subscription grant.
        public let status: SubscriptionGrantOverallStatus
        /// The identifier of the subscription.
        public let subscriptionId: String?
        /// The subscription target ID associated with the subscription grant.
        public let subscriptionTargetId: String
        /// The timestamp of when the subscription grant was upated.
        public let updatedAt: Date
        /// The Amazon DataZone user who updated the subscription grant.
        public let updatedBy: String?

        @inlinable
        public init(assets: [SubscribedAsset]? = nil, createdAt: Date, createdBy: String, domainId: String, grantedEntity: GrantedEntity, id: String, status: SubscriptionGrantOverallStatus, subscriptionTargetId: String, updatedAt: Date, updatedBy: String? = nil) {
            self.assets = assets
            self.createdAt = createdAt
            self.createdBy = createdBy
            self.domainId = domainId
            self.grantedEntity = grantedEntity
            self.id = id
            self.status = status
            self.subscriptionId = nil
            self.subscriptionTargetId = subscriptionTargetId
            self.updatedAt = updatedAt
            self.updatedBy = updatedBy
        }

        @available(*, deprecated, message: "Members subscriptionId have been deprecated")
        @inlinable
        public init(assets: [SubscribedAsset]? = nil, createdAt: Date, createdBy: String, domainId: String, grantedEntity: GrantedEntity, id: String, status: SubscriptionGrantOverallStatus, subscriptionId: String? = nil, subscriptionTargetId: String, updatedAt: Date, updatedBy: String? = nil) {
            self.assets = assets
            self.createdAt = createdAt
            self.createdBy = createdBy
            self.domainId = domainId
            self.grantedEntity = grantedEntity
            self.id = id
            self.status = status
            self.subscriptionId = subscriptionId
            self.subscriptionTargetId = subscriptionTargetId
            self.updatedAt = updatedAt
            self.updatedBy = updatedBy
        }

        private enum CodingKeys: String, CodingKey {
            case assets = "assets"
            case createdAt = "createdAt"
            case createdBy = "createdBy"
            case domainId = "domainId"
            case grantedEntity = "grantedEntity"
            case id = "id"
            case status = "status"
            case subscriptionId = "subscriptionId"
            case subscriptionTargetId = "subscriptionTargetId"
            case updatedAt = "updatedAt"
            case updatedBy = "updatedBy"
        }
    }

    public struct GetSubscriptionInput: AWSEncodableShape {
        /// The ID of the Amazon DataZone domain in which the subscription exists.
        public let domainIdentifier: String
        /// The ID of the subscription.
        public let identifier: String

        @inlinable
        public init(domainIdentifier: String, identifier: String) {
            self.domainIdentifier = domainIdentifier
            self.identifier = identifier
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.domainIdentifier, key: "domainIdentifier")
            request.encodePath(self.identifier, key: "identifier")
        }

        public func validate(name: String) throws {
            try self.validate(self.domainIdentifier, name: "domainIdentifier", parent: name, pattern: "^dzd[-_][a-zA-Z0-9_-]{1,36}$")
            try self.validate(self.identifier, name: "identifier", parent: name, pattern: "^[a-zA-Z0-9_-]{1,36}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetSubscriptionOutput: AWSDecodableShape {
        /// The timestamp of when the subscription was created.
        public let createdAt: Date
        /// The Amazon DataZone user who created the subscription.
        public let createdBy: String
        /// The ID of the Amazon DataZone domain in which the subscription exists.
        public let domainId: String
        /// The ID of the subscription.
        public let id: String
        /// The retain permissions of the subscription.
        public let retainPermissions: Bool?
        /// The status of the subscription.
        public let status: SubscriptionStatus
        /// The details of the published asset for which the subscription grant is created.
        public let subscribedListing: SubscribedListing
        /// The principal that owns the subscription.
        public let subscribedPrincipal: SubscribedPrincipal
        /// The ID of the subscription request.
        public let subscriptionRequestId: String?
        /// The timestamp of when the subscription was updated.
        public let updatedAt: Date
        /// The Amazon DataZone user who updated the subscription.
        public let updatedBy: String?

        @inlinable
        public init(createdAt: Date, createdBy: String, domainId: String, id: String, retainPermissions: Bool? = nil, status: SubscriptionStatus, subscribedListing: SubscribedListing, subscribedPrincipal: SubscribedPrincipal, subscriptionRequestId: String? = nil, updatedAt: Date, updatedBy: String? = nil) {
            self.createdAt = createdAt
            self.createdBy = createdBy
            self.domainId = domainId
            self.id = id
            self.retainPermissions = retainPermissions
            self.status = status
            self.subscribedListing = subscribedListing
            self.subscribedPrincipal = subscribedPrincipal
            self.subscriptionRequestId = subscriptionRequestId
            self.updatedAt = updatedAt
            self.updatedBy = updatedBy
        }

        private enum CodingKeys: String, CodingKey {
            case createdAt = "createdAt"
            case createdBy = "createdBy"
            case domainId = "domainId"
            case id = "id"
            case retainPermissions = "retainPermissions"
            case status = "status"
            case subscribedListing = "subscribedListing"
            case subscribedPrincipal = "subscribedPrincipal"
            case subscriptionRequestId = "subscriptionRequestId"
            case updatedAt = "updatedAt"
            case updatedBy = "updatedBy"
        }
    }

    public struct GetSubscriptionRequestDetailsInput: AWSEncodableShape {
        /// The identifier of the Amazon DataZone domain in which to get the subscription request details.
        public let domainIdentifier: String
        /// The identifier of the subscription request the details of which to get.
        public let identifier: String

        @inlinable
        public init(domainIdentifier: String, identifier: String) {
            self.domainIdentifier = domainIdentifier
            self.identifier = identifier
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.domainIdentifier, key: "domainIdentifier")
            request.encodePath(self.identifier, key: "identifier")
        }

        public func validate(name: String) throws {
            try self.validate(self.domainIdentifier, name: "domainIdentifier", parent: name, pattern: "^dzd[-_][a-zA-Z0-9_-]{1,36}$")
            try self.validate(self.identifier, name: "identifier", parent: name, pattern: "^[a-zA-Z0-9_-]{1,36}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetSubscriptionRequestDetailsOutput: AWSDecodableShape {
        /// The timestamp of when the specified subscription request was created.
        public let createdAt: Date
        /// The Amazon DataZone user who created the subscription request.
        public let createdBy: String
        /// The decision comment of the subscription request.
        public let decisionComment: String?
        /// The Amazon DataZone domain of the subscription request.
        public let domainId: String
        /// The ID of the existing subscription.
        public let existingSubscriptionId: String?
        /// The identifier of the subscription request.
        public let id: String
        /// The metadata forms included in the subscription request.
        public let metadataForms: [FormOutput]?
        /// The reason for the subscription request.
        public let requestReason: String
        /// The identifier of the Amazon DataZone user who reviewed the subscription request.
        public let reviewerId: String?
        /// The status of the subscription request.
        public let status: SubscriptionRequestStatus
        /// The subscribed listings in the subscription request.
        public let subscribedListings: [SubscribedListing]
        /// The subscribed principals in the subscription request.
        public let subscribedPrincipals: [SubscribedPrincipal]
        /// The timestamp of when the subscription request was updated.
        public let updatedAt: Date
        /// The Amazon DataZone user who updated the subscription request.
        public let updatedBy: String?

        @inlinable
        public init(createdAt: Date, createdBy: String, decisionComment: String? = nil, domainId: String, existingSubscriptionId: String? = nil, id: String, metadataForms: [FormOutput]? = nil, requestReason: String, reviewerId: String? = nil, status: SubscriptionRequestStatus, subscribedListings: [SubscribedListing], subscribedPrincipals: [SubscribedPrincipal], updatedAt: Date, updatedBy: String? = nil) {
            self.createdAt = createdAt
            self.createdBy = createdBy
            self.decisionComment = decisionComment
            self.domainId = domainId
            self.existingSubscriptionId = existingSubscriptionId
            self.id = id
            self.metadataForms = metadataForms
            self.requestReason = requestReason
            self.reviewerId = reviewerId
            self.status = status
            self.subscribedListings = subscribedListings
            self.subscribedPrincipals = subscribedPrincipals
            self.updatedAt = updatedAt
            self.updatedBy = updatedBy
        }

        private enum CodingKeys: String, CodingKey {
            case createdAt = "createdAt"
            case createdBy = "createdBy"
            case decisionComment = "decisionComment"
            case domainId = "domainId"
            case existingSubscriptionId = "existingSubscriptionId"
            case id = "id"
            case metadataForms = "metadataForms"
            case requestReason = "requestReason"
            case reviewerId = "reviewerId"
            case status = "status"
            case subscribedListings = "subscribedListings"
            case subscribedPrincipals = "subscribedPrincipals"
            case updatedAt = "updatedAt"
            case updatedBy = "updatedBy"
        }
    }

    public struct GetSubscriptionTargetInput: AWSEncodableShape {
        /// The ID of the Amazon DataZone domain in which the subscription target exists.
        public let domainIdentifier: String
        /// The ID of the environment associated with the subscription target.
        public let environmentIdentifier: String
        /// The ID of the subscription target.
        public let identifier: String

        @inlinable
        public init(domainIdentifier: String, environmentIdentifier: String, identifier: String) {
            self.domainIdentifier = domainIdentifier
            self.environmentIdentifier = environmentIdentifier
            self.identifier = identifier
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.domainIdentifier, key: "domainIdentifier")
            request.encodePath(self.environmentIdentifier, key: "environmentIdentifier")
            request.encodePath(self.identifier, key: "identifier")
        }

        public func validate(name: String) throws {
            try self.validate(self.domainIdentifier, name: "domainIdentifier", parent: name, pattern: "^dzd[-_][a-zA-Z0-9_-]{1,36}$")
            try self.validate(self.environmentIdentifier, name: "environmentIdentifier", parent: name, pattern: "^[a-zA-Z0-9_-]{1,36}$")
            try self.validate(self.identifier, name: "identifier", parent: name, pattern: "^[a-zA-Z0-9_-]{1,36}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetSubscriptionTargetOutput: AWSDecodableShape {
        /// The asset types associated with the subscription target.
        public let applicableAssetTypes: [String]
        /// The authorized principals of the subscription target.
        public let authorizedPrincipals: [String]
        /// The timestamp of when the subscription target was created.
        public let createdAt: Date
        /// The Amazon DataZone user who created the subscription target.
        public let createdBy: String
        /// The ID of the Amazon DataZone domain in which the subscription target exists.
        public let domainId: String
        /// The ID of the environment associated with the subscription target.
        public let environmentId: String
        /// The ID of the subscription target.
        public let id: String
        /// The manage access role with which the subscription target was created.
        public let manageAccessRole: String?
        /// The name of the subscription target.
        public let name: String
        /// The ID of the project associated with the subscription target.
        public let projectId: String
        /// The provider of the subscription target.
        public let provider: String
        /// The configuration of teh subscription target.
        public let subscriptionTargetConfig: [SubscriptionTargetForm]
        /// The type of the subscription target.
        public let type: String
        /// The timestamp of when the subscription target was updated.
        public let updatedAt: Date?
        /// The Amazon DataZone user who updated the subscription target.
        public let updatedBy: String?

        @inlinable
        public init(applicableAssetTypes: [String], authorizedPrincipals: [String], createdAt: Date, createdBy: String, domainId: String, environmentId: String, id: String, manageAccessRole: String? = nil, name: String, projectId: String, provider: String, subscriptionTargetConfig: [SubscriptionTargetForm], type: String, updatedAt: Date? = nil, updatedBy: String? = nil) {
            self.applicableAssetTypes = applicableAssetTypes
            self.authorizedPrincipals = authorizedPrincipals
            self.createdAt = createdAt
            self.createdBy = createdBy
            self.domainId = domainId
            self.environmentId = environmentId
            self.id = id
            self.manageAccessRole = manageAccessRole
            self.name = name
            self.projectId = projectId
            self.provider = provider
            self.subscriptionTargetConfig = subscriptionTargetConfig
            self.type = type
            self.updatedAt = updatedAt
            self.updatedBy = updatedBy
        }

        private enum CodingKeys: String, CodingKey {
            case applicableAssetTypes = "applicableAssetTypes"
            case authorizedPrincipals = "authorizedPrincipals"
            case createdAt = "createdAt"
            case createdBy = "createdBy"
            case domainId = "domainId"
            case environmentId = "environmentId"
            case id = "id"
            case manageAccessRole = "manageAccessRole"
            case name = "name"
            case projectId = "projectId"
            case provider = "provider"
            case subscriptionTargetConfig = "subscriptionTargetConfig"
            case type = "type"
            case updatedAt = "updatedAt"
            case updatedBy = "updatedBy"
        }
    }

    public struct GetTimeSeriesDataPointInput: AWSEncodableShape {
        /// The ID of the Amazon DataZone domain that houses the asset for which you want to get the data point.
        public let domainIdentifier: String
        /// The ID of the asset for which you want to get the data point.
        public let entityIdentifier: String
        /// The type of the asset for which you want to get the data point.
        public let entityType: TimeSeriesEntityType
        /// The name of the time series form that houses the data point that you want to get.
        public let formName: String
        /// The ID of the data point that you want to get.
        public let identifier: String

        @inlinable
        public init(domainIdentifier: String, entityIdentifier: String, entityType: TimeSeriesEntityType, formName: String, identifier: String) {
            self.domainIdentifier = domainIdentifier
            self.entityIdentifier = entityIdentifier
            self.entityType = entityType
            self.formName = formName
            self.identifier = identifier
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.domainIdentifier, key: "domainIdentifier")
            request.encodePath(self.entityIdentifier, key: "entityIdentifier")
            request.encodePath(self.entityType, key: "entityType")
            request.encodeQuery(self.formName, key: "formName")
            request.encodePath(self.identifier, key: "identifier")
        }

        public func validate(name: String) throws {
            try self.validate(self.domainIdentifier, name: "domainIdentifier", parent: name, pattern: "^dzd[-_][a-zA-Z0-9_-]{1,36}$")
            try self.validate(self.entityIdentifier, name: "entityIdentifier", parent: name, pattern: "^[a-zA-Z0-9_-]{1,36}$")
            try self.validate(self.formName, name: "formName", parent: name, max: 128)
            try self.validate(self.formName, name: "formName", parent: name, min: 1)
            try self.validate(self.identifier, name: "identifier", parent: name, pattern: "^[a-zA-Z0-9_-]{1,36}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetTimeSeriesDataPointOutput: AWSDecodableShape {
        /// The ID of the Amazon DataZone domain that houses the asset data point that you want to get.
        public let domainId: String?
        /// The ID of the asset for which you want to get the data point.
        public let entityId: String?
        /// The type of the asset for which you want to get the data point.
        public let entityType: TimeSeriesEntityType?
        /// The time series form that houses the data point that you want to get.
        public let form: TimeSeriesDataPointFormOutput?
        /// The name of the time series form that houses the data point that you want to get.
        public let formName: String?

        @inlinable
        public init(domainId: String? = nil, entityId: String? = nil, entityType: TimeSeriesEntityType? = nil, form: TimeSeriesDataPointFormOutput? = nil, formName: String? = nil) {
            self.domainId = domainId
            self.entityId = entityId
            self.entityType = entityType
            self.form = form
            self.formName = formName
        }

        private enum CodingKeys: String, CodingKey {
            case domainId = "domainId"
            case entityId = "entityId"
            case entityType = "entityType"
            case form = "form"
            case formName = "formName"
        }
    }

    public struct GetUserProfileInput: AWSEncodableShape {
        /// the ID of the Amazon DataZone domain the data portal of which you want to get.
        public let domainIdentifier: String
        /// The type of the user profile.
        public let type: UserProfileType?
        /// The identifier of the user for which you want to get the user profile.
        public let userIdentifier: String

        @inlinable
        public init(domainIdentifier: String, type: UserProfileType? = nil, userIdentifier: String) {
            self.domainIdentifier = domainIdentifier
            self.type = type
            self.userIdentifier = userIdentifier
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.domainIdentifier, key: "domainIdentifier")
            request.encodeQuery(self.type, key: "type")
            request.encodePath(self.userIdentifier, key: "userIdentifier")
        }

        public func validate(name: String) throws {
            try self.validate(self.domainIdentifier, name: "domainIdentifier", parent: name, pattern: "^dzd[-_][a-zA-Z0-9_-]{1,36}$")
            try self.validate(self.userIdentifier, name: "userIdentifier", parent: name, pattern: "(^([0-9a-f]{10}-|)[A-Fa-f0-9]{8}-[A-Fa-f0-9]{4}-[A-Fa-f0-9]{4}-[A-Fa-f0-9]{4}-[A-Fa-f0-9]{12}$|^[a-zA-Z_0-9+=,.@-]+$|^arn:aws:iam::\\d{12}:.+$)")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetUserProfileOutput: AWSDecodableShape {
        public let details: UserProfileDetails?
        /// the identifier of the Amazon DataZone domain of which you want to get the user profile.
        public let domainId: String?
        /// The identifier of the user profile.
        public let id: String?
        /// The status of the user profile.
        public let status: UserProfileStatus?
        /// The type of the user profile.
        public let type: UserProfileType?

        @inlinable
        public init(details: UserProfileDetails? = nil, domainId: String? = nil, id: String? = nil, status: UserProfileStatus? = nil, type: UserProfileType? = nil) {
            self.details = details
            self.domainId = domainId
            self.id = id
            self.status = status
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case details = "details"
            case domainId = "domainId"
            case id = "id"
            case status = "status"
            case type = "type"
        }
    }

    public struct GlossaryItem: AWSDecodableShape {
        /// The timestamp of when the glossary was created.
        public let createdAt: Date?
        /// The Amazon DataZone user who created the glossary.
        public let createdBy: String?
        /// The business glossary description.
        public let description: String?
        /// The identifier of the Amazon DataZone domain in which the business glossary exists.
        public let domainId: String
        /// The identifier of the glossary.
        public let id: String
        /// The name of the glossary.
        public let name: String
        /// The identifier of the project that owns the business glosary.
        public let owningProjectId: String
        /// The business glossary status.
        public let status: GlossaryStatus
        /// The timestamp of when the business glossary was updated.
        public let updatedAt: Date?
        /// The Amazon DataZone user who updated the business glossary.
        public let updatedBy: String?

        @inlinable
        public init(createdAt: Date? = nil, createdBy: String? = nil, description: String? = nil, domainId: String, id: String, name: String, owningProjectId: String, status: GlossaryStatus, updatedAt: Date? = nil, updatedBy: String? = nil) {
            self.createdAt = createdAt
            self.createdBy = createdBy
            self.description = description
            self.domainId = domainId
            self.id = id
            self.name = name
            self.owningProjectId = owningProjectId
            self.status = status
            self.updatedAt = updatedAt
            self.updatedBy = updatedBy
        }

        private enum CodingKeys: String, CodingKey {
            case createdAt = "createdAt"
            case createdBy = "createdBy"
            case description = "description"
            case domainId = "domainId"
            case id = "id"
            case name = "name"
            case owningProjectId = "owningProjectId"
            case status = "status"
            case updatedAt = "updatedAt"
            case updatedBy = "updatedBy"
        }
    }

    public struct GlossaryTermItem: AWSDecodableShape {
        /// The timestamp of when a business glossary term was created.
        public let createdAt: Date?
        /// The Amazon DataZone user who created the business glossary.
        public let createdBy: String?
        /// The identifier of the Amazon DataZone domain in which the business glossary exists.
        public let domainId: String
        /// The identifier of the business glossary to which the term belongs.
        public let glossaryId: String
        /// The identifier of the business glossary term.
        public let id: String
        /// The long description of the business glossary term.
        public let longDescription: String?
        /// The name of the business glossary term.
        public let name: String
        /// The short description of the business glossary term.
        public let shortDescription: String?
        /// The status of the business glossary term.
        public let status: GlossaryTermStatus
        /// The relations of the business glossary term.
        public let termRelations: TermRelations?
        /// The timestamp of when a business glossary term was updated.
        public let updatedAt: Date?
        /// The Amazon DataZone user who updated the business glossary term.
        public let updatedBy: String?

        @inlinable
        public init(createdAt: Date? = nil, createdBy: String? = nil, domainId: String, glossaryId: String, id: String, longDescription: String? = nil, name: String, shortDescription: String? = nil, status: GlossaryTermStatus, termRelations: TermRelations? = nil, updatedAt: Date? = nil, updatedBy: String? = nil) {
            self.createdAt = createdAt
            self.createdBy = createdBy
            self.domainId = domainId
            self.glossaryId = glossaryId
            self.id = id
            self.longDescription = longDescription
            self.name = name
            self.shortDescription = shortDescription
            self.status = status
            self.termRelations = termRelations
            self.updatedAt = updatedAt
            self.updatedBy = updatedBy
        }

        private enum CodingKeys: String, CodingKey {
            case createdAt = "createdAt"
            case createdBy = "createdBy"
            case domainId = "domainId"
            case glossaryId = "glossaryId"
            case id = "id"
            case longDescription = "longDescription"
            case name = "name"
            case shortDescription = "shortDescription"
            case status = "status"
            case termRelations = "termRelations"
            case updatedAt = "updatedAt"
            case updatedBy = "updatedBy"
        }
    }

    public struct GlueConnection: AWSDecodableShape {
        /// The Amazon Athena properties of the Amazon Web Services Glue connection.
        public let athenaProperties: [String: String]?
        /// The authentication configuration of the Amazon Web Services Glue connection.
        public let authenticationConfiguration: AuthenticationConfiguration?
        /// The compatible compute environments of the Amazon Web Services Glue connection.
        public let compatibleComputeEnvironments: [ComputeEnvironments]?
        /// The properties of the Amazon Web Services Glue connection.
        public let connectionProperties: [String: String]?
        /// The connection schema version of the Amazon Web Services Glue connection.
        public let connectionSchemaVersion: Int?
        /// The type of the Amazon Web Services Glue connection.
        public let connectionType: ConnectionType?
        /// The creation time of the Amazon Web Services Glue connection.
        public let creationTime: Date?
        /// The description of the Amazon Web Services Glue connection.
        public let description: String?
        /// The last validation time of the Amazon Web Services Glue connection.
        public let lastConnectionValidationTime: Date?
        /// The user who last updated the Amazon Web Services Glue connection.
        public let lastUpdatedBy: String?
        /// The timestamp at which the Amazon Web Services Glue connection was last updated.
        public let lastUpdatedTime: Date?
        /// The match criteria of the Amazon Web Services Glue connection.
        public let matchCriteria: [String]?
        /// The name of the Amazon Web Services Glue connection.
        public let name: String?
        /// The physical connection requirements of the Amazon Web Services Glue connection.
        public let physicalConnectionRequirements: PhysicalConnectionRequirements?
        /// The Python properties of the Amazon Web Services Glue connection.
        public let pythonProperties: [String: String]?
        /// The Spark properties of the Amazon Web Services Glue connection.
        public let sparkProperties: [String: String]?
        /// The status of the Amazon Web Services Glue connection.
        public let status: ConnectionStatus?
        /// The status reason of the Amazon Web Services Glue connection.
        public let statusReason: String?

        @inlinable
        public init(athenaProperties: [String: String]? = nil, authenticationConfiguration: AuthenticationConfiguration? = nil, compatibleComputeEnvironments: [ComputeEnvironments]? = nil, connectionProperties: [String: String]? = nil, connectionSchemaVersion: Int? = nil, connectionType: ConnectionType? = nil, creationTime: Date? = nil, description: String? = nil, lastConnectionValidationTime: Date? = nil, lastUpdatedBy: String? = nil, lastUpdatedTime: Date? = nil, matchCriteria: [String]? = nil, name: String? = nil, physicalConnectionRequirements: PhysicalConnectionRequirements? = nil, pythonProperties: [String: String]? = nil, sparkProperties: [String: String]? = nil, status: ConnectionStatus? = nil, statusReason: String? = nil) {
            self.athenaProperties = athenaProperties
            self.authenticationConfiguration = authenticationConfiguration
            self.compatibleComputeEnvironments = compatibleComputeEnvironments
            self.connectionProperties = connectionProperties
            self.connectionSchemaVersion = connectionSchemaVersion
            self.connectionType = connectionType
            self.creationTime = creationTime
            self.description = description
            self.lastConnectionValidationTime = lastConnectionValidationTime
            self.lastUpdatedBy = lastUpdatedBy
            self.lastUpdatedTime = lastUpdatedTime
            self.matchCriteria = matchCriteria
            self.name = name
            self.physicalConnectionRequirements = physicalConnectionRequirements
            self.pythonProperties = pythonProperties
            self.sparkProperties = sparkProperties
            self.status = status
            self.statusReason = statusReason
        }

        private enum CodingKeys: String, CodingKey {
            case athenaProperties = "athenaProperties"
            case authenticationConfiguration = "authenticationConfiguration"
            case compatibleComputeEnvironments = "compatibleComputeEnvironments"
            case connectionProperties = "connectionProperties"
            case connectionSchemaVersion = "connectionSchemaVersion"
            case connectionType = "connectionType"
            case creationTime = "creationTime"
            case description = "description"
            case lastConnectionValidationTime = "lastConnectionValidationTime"
            case lastUpdatedBy = "lastUpdatedBy"
            case lastUpdatedTime = "lastUpdatedTime"
            case matchCriteria = "matchCriteria"
            case name = "name"
            case physicalConnectionRequirements = "physicalConnectionRequirements"
            case pythonProperties = "pythonProperties"
            case sparkProperties = "sparkProperties"
            case status = "status"
            case statusReason = "statusReason"
        }
    }

    public struct GlueConnectionInput: AWSEncodableShape {
        /// The Amazon Athena properties of the Amazon Web Services Glue connection.
        public let athenaProperties: [String: String]?
        /// The authentication configuration of the Amazon Web Services Glue connection.
        public let authenticationConfiguration: AuthenticationConfigurationInput?
        /// The connection properties of the Amazon Web Services Glue connection.
        public let connectionProperties: [String: String]?
        /// The connection type of the Amazon Web Services Glue connection.
        public let connectionType: GlueConnectionType?
        /// The description of the Amazon Web Services Glue connection.
        public let description: String?
        /// The match criteria of the Amazon Web Services Glue connection.
        public let matchCriteria: String?
        /// The name of the Amazon Web Services Glue connection.
        public let name: String?
        /// The physical connection requirements for the Amazon Web Services Glue connection.
        public let physicalConnectionRequirements: PhysicalConnectionRequirements?
        /// The Python properties of the Amazon Web Services Glue connection.
        public let pythonProperties: [String: String]?
        /// The Spark properties of the Amazon Web Services Glue connection.
        public let sparkProperties: [String: String]?
        /// Speciefies whether to validate credentials of the Amazon Web Services Glue connection.
        public let validateCredentials: Bool?
        /// Speciefies whether to validate for compute environments of the Amazon Web Services Glue connection.
        public let validateForComputeEnvironments: [ComputeEnvironments]?

        @inlinable
        public init(athenaProperties: [String: String]? = nil, authenticationConfiguration: AuthenticationConfigurationInput? = nil, connectionProperties: [String: String]? = nil, connectionType: GlueConnectionType? = nil, description: String? = nil, matchCriteria: String? = nil, name: String? = nil, physicalConnectionRequirements: PhysicalConnectionRequirements? = nil, pythonProperties: [String: String]? = nil, sparkProperties: [String: String]? = nil, validateCredentials: Bool? = nil, validateForComputeEnvironments: [ComputeEnvironments]? = nil) {
            self.athenaProperties = athenaProperties
            self.authenticationConfiguration = authenticationConfiguration
            self.connectionProperties = connectionProperties
            self.connectionType = connectionType
            self.description = description
            self.matchCriteria = matchCriteria
            self.name = name
            self.physicalConnectionRequirements = physicalConnectionRequirements
            self.pythonProperties = pythonProperties
            self.sparkProperties = sparkProperties
            self.validateCredentials = validateCredentials
            self.validateForComputeEnvironments = validateForComputeEnvironments
        }

        public func validate(name: String) throws {
            try self.physicalConnectionRequirements?.validate(name: "\(name).physicalConnectionRequirements")
            try self.validate(self.validateForComputeEnvironments, name: "validateForComputeEnvironments", parent: name, max: 50)
            try self.validate(self.validateForComputeEnvironments, name: "validateForComputeEnvironments", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case athenaProperties = "athenaProperties"
            case authenticationConfiguration = "authenticationConfiguration"
            case connectionProperties = "connectionProperties"
            case connectionType = "connectionType"
            case description = "description"
            case matchCriteria = "matchCriteria"
            case name = "name"
            case physicalConnectionRequirements = "physicalConnectionRequirements"
            case pythonProperties = "pythonProperties"
            case sparkProperties = "sparkProperties"
            case validateCredentials = "validateCredentials"
            case validateForComputeEnvironments = "validateForComputeEnvironments"
        }
    }

    public struct GlueConnectionPatch: AWSEncodableShape {
        /// The authentication configuration of the Amazon Web Services Glue connection patch.
        public let authenticationConfiguration: AuthenticationConfigurationPatch?
        /// The properties of the Amazon Web Services Glue connection patch.
        public let connectionProperties: [String: String]?
        /// The description of the Amazon Web Services Glue connection patch.
        public let description: String?

        @inlinable
        public init(authenticationConfiguration: AuthenticationConfigurationPatch? = nil, connectionProperties: [String: String]? = nil, description: String? = nil) {
            self.authenticationConfiguration = authenticationConfiguration
            self.connectionProperties = connectionProperties
            self.description = description
        }

        private enum CodingKeys: String, CodingKey {
            case authenticationConfiguration = "authenticationConfiguration"
            case connectionProperties = "connectionProperties"
            case description = "description"
        }
    }

    public struct GlueOAuth2Credentials: AWSEncodableShape & AWSDecodableShape {
        /// The access token of a connection.
        public let accessToken: String?
        /// The jwt token of the connection.
        public let jwtToken: String?
        /// The refresh token of the connection.
        public let refreshToken: String?
        /// The user managed client application client secret of the connection.
        public let userManagedClientApplicationClientSecret: String?

        @inlinable
        public init(accessToken: String? = nil, jwtToken: String? = nil, refreshToken: String? = nil, userManagedClientApplicationClientSecret: String? = nil) {
            self.accessToken = accessToken
            self.jwtToken = jwtToken
            self.refreshToken = refreshToken
            self.userManagedClientApplicationClientSecret = userManagedClientApplicationClientSecret
        }

        private enum CodingKeys: String, CodingKey {
            case accessToken = "accessToken"
            case jwtToken = "jwtToken"
            case refreshToken = "refreshToken"
            case userManagedClientApplicationClientSecret = "userManagedClientApplicationClientSecret"
        }
    }

    public struct GluePropertiesInput: AWSEncodableShape {
        /// The Amazon Web Services Glue connection.
        public let glueConnectionInput: GlueConnectionInput?

        @inlinable
        public init(glueConnectionInput: GlueConnectionInput? = nil) {
            self.glueConnectionInput = glueConnectionInput
        }

        public func validate(name: String) throws {
            try self.glueConnectionInput?.validate(name: "\(name).glueConnectionInput")
        }

        private enum CodingKeys: String, CodingKey {
            case glueConnectionInput = "glueConnectionInput"
        }
    }

    public struct GluePropertiesOutput: AWSDecodableShape {
        /// The error message generated if the action is not completed successfully.
        public let errorMessage: String?
        /// The status of a connection.
        public let status: ConnectionStatus?

        @inlinable
        public init(errorMessage: String? = nil, status: ConnectionStatus? = nil) {
            self.errorMessage = errorMessage
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case errorMessage = "errorMessage"
            case status = "status"
        }
    }

    public struct GluePropertiesPatch: AWSEncodableShape {
        /// The Amazon Web Services Glue properties patch of a connection.
        public let glueConnectionInput: GlueConnectionPatch?

        @inlinable
        public init(glueConnectionInput: GlueConnectionPatch? = nil) {
            self.glueConnectionInput = glueConnectionInput
        }

        private enum CodingKeys: String, CodingKey {
            case glueConnectionInput = "glueConnectionInput"
        }
    }

    public struct GlueRunConfigurationInput: AWSEncodableShape {
        /// Specifies whether to automatically import data quality metrics as part of the data source run.
        public let autoImportDataQualityResult: Bool?
        /// The catalog name in the Amazon Web Services Glue run configuration.
        public let catalogName: String?
        /// The data access role included in the configuration details of the Amazon Web Services Glue data source.
        public let dataAccessRole: String?
        /// The relational filter configurations included in the configuration details of the Amazon Web Services Glue data source.
        public let relationalFilterConfigurations: [RelationalFilterConfiguration]

        @inlinable
        public init(autoImportDataQualityResult: Bool? = nil, catalogName: String? = nil, dataAccessRole: String? = nil, relationalFilterConfigurations: [RelationalFilterConfiguration]) {
            self.autoImportDataQualityResult = autoImportDataQualityResult
            self.catalogName = catalogName
            self.dataAccessRole = dataAccessRole
            self.relationalFilterConfigurations = relationalFilterConfigurations
        }

        private enum CodingKeys: String, CodingKey {
            case autoImportDataQualityResult = "autoImportDataQualityResult"
            case catalogName = "catalogName"
            case dataAccessRole = "dataAccessRole"
            case relationalFilterConfigurations = "relationalFilterConfigurations"
        }
    }

    public struct GlueRunConfigurationOutput: AWSDecodableShape {
        /// The Amazon Web Services account ID included in the configuration details of the Amazon Web Services Glue data source.
        public let accountId: String?
        /// Specifies whether to automatically import data quality metrics as part of the data source run.
        public let autoImportDataQualityResult: Bool?
        /// The catalog name in the Amazon Web Services Glue run configuration.
        public let catalogName: String?
        /// The data access role included in the configuration details of the Amazon Web Services Glue data source.
        public let dataAccessRole: String?
        /// The Amazon Web Services region included in the configuration details of the Amazon Web Services Glue data source.
        public let region: String?
        /// The relational filter configurations included in the configuration details of the Amazon Web Services Glue data source.
        public let relationalFilterConfigurations: [RelationalFilterConfiguration]

        @inlinable
        public init(accountId: String? = nil, autoImportDataQualityResult: Bool? = nil, catalogName: String? = nil, dataAccessRole: String? = nil, region: String? = nil, relationalFilterConfigurations: [RelationalFilterConfiguration]) {
            self.accountId = accountId
            self.autoImportDataQualityResult = autoImportDataQualityResult
            self.catalogName = catalogName
            self.dataAccessRole = dataAccessRole
            self.region = region
            self.relationalFilterConfigurations = relationalFilterConfigurations
        }

        private enum CodingKeys: String, CodingKey {
            case accountId = "accountId"
            case autoImportDataQualityResult = "autoImportDataQualityResult"
            case catalogName = "catalogName"
            case dataAccessRole = "dataAccessRole"
            case region = "region"
            case relationalFilterConfigurations = "relationalFilterConfigurations"
        }
    }

    public struct GlueSelfGrantStatusOutput: AWSDecodableShape {
        /// The details for the self granting status for a Glue data source.
        public let selfGrantStatusDetails: [SelfGrantStatusDetail]

        @inlinable
        public init(selfGrantStatusDetails: [SelfGrantStatusDetail]) {
            self.selfGrantStatusDetails = selfGrantStatusDetails
        }

        private enum CodingKeys: String, CodingKey {
            case selfGrantStatusDetails = "selfGrantStatusDetails"
        }
    }

    public struct GreaterThanExpression: AWSEncodableShape & AWSDecodableShape {
        /// The name of the column.
        public let columnName: String
        /// The value that might be greater than an expression.
        public let value: String

        @inlinable
        public init(columnName: String, value: String) {
            self.columnName = columnName
            self.value = value
        }

        private enum CodingKeys: String, CodingKey {
            case columnName = "columnName"
            case value = "value"
        }
    }

    public struct GreaterThanOrEqualToExpression: AWSEncodableShape & AWSDecodableShape {
        /// The name of the column.
        public let columnName: String
        /// The value that might be greater than or equal to an expression.
        public let value: String

        @inlinable
        public init(columnName: String, value: String) {
            self.columnName = columnName
            self.value = value
        }

        private enum CodingKeys: String, CodingKey {
            case columnName = "columnName"
            case value = "value"
        }
    }

    public struct GroupDetails: AWSDecodableShape {
        /// The identifier of the group in Amazon DataZone.
        public let groupId: String

        @inlinable
        public init(groupId: String) {
            self.groupId = groupId
        }

        private enum CodingKeys: String, CodingKey {
            case groupId = "groupId"
        }
    }

    public struct GroupProfileSummary: AWSDecodableShape {
        /// The ID of the Amazon DataZone domain of a group profile.
        public let domainId: String?
        /// The group name of a group profile.
        public let groupName: String?
        /// The ID of a group profile.
        public let id: String?
        /// The status of a group profile.
        public let status: GroupProfileStatus?

        @inlinable
        public init(domainId: String? = nil, groupName: String? = nil, id: String? = nil, status: GroupProfileStatus? = nil) {
            self.domainId = domainId
            self.groupName = groupName
            self.id = id
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case domainId = "domainId"
            case groupName = "groupName"
            case id = "id"
            case status = "status"
        }
    }

    public struct HyperPodPropertiesInput: AWSEncodableShape {
        /// The cluster name the hyper pod properties.
        public let clusterName: String

        @inlinable
        public init(clusterName: String) {
            self.clusterName = clusterName
        }

        private enum CodingKeys: String, CodingKey {
            case clusterName = "clusterName"
        }
    }

    public struct HyperPodPropertiesOutput: AWSDecodableShape {
        /// The cluster ARN of the hyper pod properties.
        public let clusterArn: String?
        /// The cluster name the hyper pod properties.
        public let clusterName: String
        /// The orchestrator of the hyper pod properties.
        public let orchestrator: HyperPodOrchestrator?

        @inlinable
        public init(clusterArn: String? = nil, clusterName: String, orchestrator: HyperPodOrchestrator? = nil) {
            self.clusterArn = clusterArn
            self.clusterName = clusterName
            self.orchestrator = orchestrator
        }

        private enum CodingKeys: String, CodingKey {
            case clusterArn = "clusterArn"
            case clusterName = "clusterName"
            case orchestrator = "orchestrator"
        }
    }

    public struct IamPropertiesInput: AWSEncodableShape {
        /// Specifies whether Amazon Web Services Glue lineage sync is enabled for a connection.
        public let glueLineageSyncEnabled: Bool?

        @inlinable
        public init(glueLineageSyncEnabled: Bool? = nil) {
            self.glueLineageSyncEnabled = glueLineageSyncEnabled
        }

        private enum CodingKeys: String, CodingKey {
            case glueLineageSyncEnabled = "glueLineageSyncEnabled"
        }
    }

    public struct IamPropertiesOutput: AWSDecodableShape {
        /// The environment ID of the connection.
        public let environmentId: String?
        /// Specifies whether Amazon Web Services Glue lineage sync is enabled for a connection.
        public let glueLineageSyncEnabled: Bool?

        @inlinable
        public init(environmentId: String? = nil, glueLineageSyncEnabled: Bool? = nil) {
            self.environmentId = environmentId
            self.glueLineageSyncEnabled = glueLineageSyncEnabled
        }

        private enum CodingKeys: String, CodingKey {
            case environmentId = "environmentId"
            case glueLineageSyncEnabled = "glueLineageSyncEnabled"
        }
    }

    public struct IamPropertiesPatch: AWSEncodableShape {
        /// Specifies whether Amazon Web Services Glue lineage sync is enabled for a connection.
        public let glueLineageSyncEnabled: Bool?

        @inlinable
        public init(glueLineageSyncEnabled: Bool? = nil) {
            self.glueLineageSyncEnabled = glueLineageSyncEnabled
        }

        private enum CodingKeys: String, CodingKey {
            case glueLineageSyncEnabled = "glueLineageSyncEnabled"
        }
    }

    public struct IamUserProfileDetails: AWSDecodableShape {
        /// The ARN of an IAM user profile in Amazon DataZone.
        public let arn: String?

        @inlinable
        public init(arn: String? = nil) {
            self.arn = arn
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
        }
    }

    public struct Import: AWSDecodableShape {
        /// The name of the import.
        public let name: String
        /// The revision of the import.
        public let revision: String

        @inlinable
        public init(name: String, revision: String) {
            self.name = name
            self.revision = revision
        }

        private enum CodingKeys: String, CodingKey {
            case name = "name"
            case revision = "revision"
        }
    }

    public struct InExpression: AWSEncodableShape & AWSDecodableShape {
        /// The name of the column.
        public let columnName: String
        /// The values that might be in the expression.
        public let values: [String]

        @inlinable
        public init(columnName: String, values: [String]) {
            self.columnName = columnName
            self.values = values
        }

        private enum CodingKeys: String, CodingKey {
            case columnName = "columnName"
            case values = "values"
        }
    }

    public struct IsNotNullExpression: AWSEncodableShape & AWSDecodableShape {
        /// The name of the column.
        public let columnName: String

        @inlinable
        public init(columnName: String) {
            self.columnName = columnName
        }

        private enum CodingKeys: String, CodingKey {
            case columnName = "columnName"
        }
    }

    public struct IsNullExpression: AWSEncodableShape & AWSDecodableShape {
        /// The name of the column.
        public let columnName: String

        @inlinable
        public init(columnName: String) {
            self.columnName = columnName
        }

        private enum CodingKeys: String, CodingKey {
            case columnName = "columnName"
        }
    }

    public struct JobRunError: AWSDecodableShape {
        /// The job run error message.
        public let message: String

        @inlinable
        public init(message: String) {
            self.message = message
        }

        private enum CodingKeys: String, CodingKey {
            case message = "message"
        }
    }

    public struct JobRunSummary: AWSDecodableShape {
        /// The timestamp at which job run was created.
        public let createdAt: Date?
        /// The user who created the job run.
        public let createdBy: String?
        /// The domain ID of the job run.
        public let domainId: String?
        /// The end time of a job run.
        public let endTime: Date?
        /// The error of a job run.
        public let error: JobRunError?
        /// The job ID of a job run.
        public let jobId: String?
        /// The job type of a job run.
        public let jobType: JobType?
        /// The run ID of a job run.
        public let runId: String?
        /// The run mode of a job run.
        public let runMode: JobRunMode?
        /// The start time of a job run.
        public let startTime: Date?
        /// The status of a job run.
        public let status: JobRunStatus?

        @inlinable
        public init(createdAt: Date? = nil, createdBy: String? = nil, domainId: String? = nil, endTime: Date? = nil, error: JobRunError? = nil, jobId: String? = nil, jobType: JobType? = nil, runId: String? = nil, runMode: JobRunMode? = nil, startTime: Date? = nil, status: JobRunStatus? = nil) {
            self.createdAt = createdAt
            self.createdBy = createdBy
            self.domainId = domainId
            self.endTime = endTime
            self.error = error
            self.jobId = jobId
            self.jobType = jobType
            self.runId = runId
            self.runMode = runMode
            self.startTime = startTime
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case createdAt = "createdAt"
            case createdBy = "createdBy"
            case domainId = "domainId"
            case endTime = "endTime"
            case error = "error"
            case jobId = "jobId"
            case jobType = "jobType"
            case runId = "runId"
            case runMode = "runMode"
            case startTime = "startTime"
            case status = "status"
        }
    }

    public struct LakeFormationConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// Specifies certain Amazon S3 locations if you do not want Amazon DataZone to automatically register them in hybrid mode.
        public let locationRegistrationExcludeS3Locations: [String]?
        /// The role that is used to manage read/write access to the chosen Amazon S3 bucket(s) for Data Lake using Amazon Web Services Lake Formation hybrid access mode.
        public let locationRegistrationRole: String?

        @inlinable
        public init(locationRegistrationExcludeS3Locations: [String]? = nil, locationRegistrationRole: String? = nil) {
            self.locationRegistrationExcludeS3Locations = locationRegistrationExcludeS3Locations
            self.locationRegistrationRole = locationRegistrationRole
        }

        public func validate(name: String) throws {
            try self.locationRegistrationExcludeS3Locations?.forEach {
                try validate($0, name: "locationRegistrationExcludeS3Locations[]", parent: name, max: 1024)
                try validate($0, name: "locationRegistrationExcludeS3Locations[]", parent: name, min: 1)
                try validate($0, name: "locationRegistrationExcludeS3Locations[]", parent: name, pattern: "^s3://.+$")
            }
            try self.validate(self.locationRegistrationExcludeS3Locations, name: "locationRegistrationExcludeS3Locations", parent: name, max: 20)
            try self.validate(self.locationRegistrationRole, name: "locationRegistrationRole", parent: name, pattern: "^arn:aws[^:]*:iam::\\d{12}:(role|role/service-role)/[\\w+=,.@-]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case locationRegistrationExcludeS3Locations = "locationRegistrationExcludeS3Locations"
            case locationRegistrationRole = "locationRegistrationRole"
        }
    }

    public struct LessThanExpression: AWSEncodableShape & AWSDecodableShape {
        /// The name of the column.
        public let columnName: String
        /// The value that might be less than the expression.
        public let value: String

        @inlinable
        public init(columnName: String, value: String) {
            self.columnName = columnName
            self.value = value
        }

        private enum CodingKeys: String, CodingKey {
            case columnName = "columnName"
            case value = "value"
        }
    }

    public struct LessThanOrEqualToExpression: AWSEncodableShape & AWSDecodableShape {
        /// The name of the column.
        public let columnName: String
        /// The value that might be less than or equal to an expression.
        public let value: String

        @inlinable
        public init(columnName: String, value: String) {
            self.columnName = columnName
            self.value = value
        }

        private enum CodingKeys: String, CodingKey {
            case columnName = "columnName"
            case value = "value"
        }
    }

    public struct LikeExpression: AWSEncodableShape & AWSDecodableShape {
        /// The name of the column.
        public let columnName: String
        /// The value that might be like the expression.
        public let value: String

        @inlinable
        public init(columnName: String, value: String) {
            self.columnName = columnName
            self.value = value
        }

        private enum CodingKeys: String, CodingKey {
            case columnName = "columnName"
            case value = "value"
        }
    }

    public struct LineageEventSummary: AWSDecodableShape {
        /// The timestamp at which data lineage event was created.
        public let createdAt: Date?
        /// The user who created the data lineage event.
        public let createdBy: String?
        /// The domain ID of the lineage event.
        public let domainId: String?
        /// The summary of the data lineate event.
        public let eventSummary: EventSummary?
        /// The time of the data lineage event.
        public let eventTime: Date?
        /// The ID of the data lineage event.
        public let id: String?
        /// The processing status of the data lineage event.
        public let processingStatus: LineageEventProcessingStatus?

        @inlinable
        public init(createdAt: Date? = nil, createdBy: String? = nil, domainId: String? = nil, eventSummary: EventSummary? = nil, eventTime: Date? = nil, id: String? = nil, processingStatus: LineageEventProcessingStatus? = nil) {
            self.createdAt = createdAt
            self.createdBy = createdBy
            self.domainId = domainId
            self.eventSummary = eventSummary
            self.eventTime = eventTime
            self.id = id
            self.processingStatus = processingStatus
        }

        private enum CodingKeys: String, CodingKey {
            case createdAt = "createdAt"
            case createdBy = "createdBy"
            case domainId = "domainId"
            case eventSummary = "eventSummary"
            case eventTime = "eventTime"
            case id = "id"
            case processingStatus = "processingStatus"
        }
    }

    public struct LineageInfo: AWSDecodableShape {
        /// The data lineage error message.
        public let errorMessage: String?
        /// The data lineage event ID.
        public let eventId: String?
        /// The data lineage event status.
        public let eventStatus: LineageEventProcessingStatus?

        @inlinable
        public init(errorMessage: String? = nil, eventId: String? = nil, eventStatus: LineageEventProcessingStatus? = nil) {
            self.errorMessage = errorMessage
            self.eventId = eventId
            self.eventStatus = eventStatus
        }

        private enum CodingKeys: String, CodingKey {
            case errorMessage = "errorMessage"
            case eventId = "eventId"
            case eventStatus = "eventStatus"
        }
    }

    public struct LineageNodeReference: AWSDecodableShape {
        /// The event timestamp of the data lineage node.
        public let eventTimestamp: Date?
        /// The ID of the data lineage node.
        public let id: String?

        @inlinable
        public init(eventTimestamp: Date? = nil, id: String? = nil) {
            self.eventTimestamp = eventTimestamp
            self.id = id
        }

        private enum CodingKeys: String, CodingKey {
            case eventTimestamp = "eventTimestamp"
            case id = "id"
        }
    }

    public struct LineageNodeSummary: AWSDecodableShape {
        /// The timestamp at which the data lineage node was created.
        public let createdAt: Date?
        /// The user who created the data lineage node.
        public let createdBy: String?
        /// The description of the data lineage node.
        public let description: String?
        /// The ID of the domain of the data lineage node.
        public let domainId: String
        /// The event timestamp of the data lineage node.
        public let eventTimestamp: Date?
        /// The ID of the data lineage node.
        public let id: String
        /// The name of the data lineage node.
        public let name: String?
        /// The alternate ID of the data lineage node.
        public let sourceIdentifier: String?
        /// The name of the type of the data lineage node.
        public let typeName: String
        /// The type of the revision of the data lineage node.
        public let typeRevision: String?
        /// The timestamp at which the data lineage node was updated.
        public let updatedAt: Date?
        /// The user who updated the data lineage node.
        public let updatedBy: String?

        @inlinable
        public init(createdAt: Date? = nil, createdBy: String? = nil, description: String? = nil, domainId: String, eventTimestamp: Date? = nil, id: String, name: String? = nil, sourceIdentifier: String? = nil, typeName: String, typeRevision: String? = nil, updatedAt: Date? = nil, updatedBy: String? = nil) {
            self.createdAt = createdAt
            self.createdBy = createdBy
            self.description = description
            self.domainId = domainId
            self.eventTimestamp = eventTimestamp
            self.id = id
            self.name = name
            self.sourceIdentifier = sourceIdentifier
            self.typeName = typeName
            self.typeRevision = typeRevision
            self.updatedAt = updatedAt
            self.updatedBy = updatedBy
        }

        private enum CodingKeys: String, CodingKey {
            case createdAt = "createdAt"
            case createdBy = "createdBy"
            case description = "description"
            case domainId = "domainId"
            case eventTimestamp = "eventTimestamp"
            case id = "id"
            case name = "name"
            case sourceIdentifier = "sourceIdentifier"
            case typeName = "typeName"
            case typeRevision = "typeRevision"
            case updatedAt = "updatedAt"
            case updatedBy = "updatedBy"
        }
    }

    public struct LineageNodeTypeItem: AWSDecodableShape {
        /// The timestamp at which the data lineage node type was created.
        public let createdAt: Date?
        /// The user who created the data lineage node type.
        public let createdBy: String?
        /// The description of the data lineage node type.
        public let description: String?
        /// The ID of the domain where the data lineage node type lives.
        public let domainId: String
        /// The forms output of the data lineage node type.
        public let formsOutput: [String: FormEntryOutput]
        /// The name of the data lineage node type.
        public let name: String?
        /// The revision of the data lineage node type.
        public let revision: String
        /// The timestamp at which the data lineage node type was updated.
        public let updatedAt: Date?
        /// The user who updated the data lineage node type.
        public let updatedBy: String?

        @inlinable
        public init(createdAt: Date? = nil, createdBy: String? = nil, description: String? = nil, domainId: String, formsOutput: [String: FormEntryOutput], name: String? = nil, revision: String, updatedAt: Date? = nil, updatedBy: String? = nil) {
            self.createdAt = createdAt
            self.createdBy = createdBy
            self.description = description
            self.domainId = domainId
            self.formsOutput = formsOutput
            self.name = name
            self.revision = revision
            self.updatedAt = updatedAt
            self.updatedBy = updatedBy
        }

        private enum CodingKeys: String, CodingKey {
            case createdAt = "createdAt"
            case createdBy = "createdBy"
            case description = "description"
            case domainId = "domainId"
            case formsOutput = "formsOutput"
            case name = "name"
            case revision = "revision"
            case updatedAt = "updatedAt"
            case updatedBy = "updatedBy"
        }
    }

    public struct LineageRunDetails: AWSDecodableShape {
        /// The SQL query run details of a data lineage run.
        public let sqlQueryRunDetails: LineageSqlQueryRunDetails?

        @inlinable
        public init(sqlQueryRunDetails: LineageSqlQueryRunDetails? = nil) {
            self.sqlQueryRunDetails = sqlQueryRunDetails
        }

        private enum CodingKeys: String, CodingKey {
            case sqlQueryRunDetails = "sqlQueryRunDetails"
        }
    }

    public struct LineageSqlQueryRunDetails: AWSDecodableShape {
        /// The error message of the SQL query run details of a data lineage run.
        public let errorMessages: [String]?
        /// The number of queries that failed in the SQL query run details of a data lineage run.
        public let numQueriesFailed: Int?
        /// The query end time in the SQL query run details of a data lineage run.
        public let queryEndTime: Date?
        /// The query start time in the SQL query run details of a data lineage run.
        public let queryStartTime: Date?
        /// The total queries processed in the SQL query run details of a data lineage run.
        public let totalQueriesProcessed: Int?

        @inlinable
        public init(errorMessages: [String]? = nil, numQueriesFailed: Int? = nil, queryEndTime: Date? = nil, queryStartTime: Date? = nil, totalQueriesProcessed: Int? = nil) {
            self.errorMessages = errorMessages
            self.numQueriesFailed = numQueriesFailed
            self.queryEndTime = queryEndTime
            self.queryStartTime = queryStartTime
            self.totalQueriesProcessed = totalQueriesProcessed
        }

        private enum CodingKeys: String, CodingKey {
            case errorMessages = "errorMessages"
            case numQueriesFailed = "numQueriesFailed"
            case queryEndTime = "queryEndTime"
            case queryStartTime = "queryStartTime"
            case totalQueriesProcessed = "totalQueriesProcessed"
        }
    }

    public struct LineageSyncSchedule: AWSEncodableShape & AWSDecodableShape {
        /// The lineage sync schedule.
        public let schedule: String?

        @inlinable
        public init(schedule: String? = nil) {
            self.schedule = schedule
        }

        private enum CodingKeys: String, CodingKey {
            case schedule = "schedule"
        }
    }

    public struct ListAssetFiltersInput: AWSEncodableShape {
        /// The ID of the data asset.
        public let assetIdentifier: String
        /// The ID of the domain where you want to list asset filters.
        public let domainIdentifier: String
        /// The maximum number of asset filters to return in a single call to ListAssetFilters. When the number of asset filters to be listed is greater than the value of MaxResults, the response contains a NextToken value that you can use in a subsequent call to ListAssetFilters to list the next set of asset filters.
        public let maxResults: Int?
        /// When the number of asset filters is greater than the default value for the MaxResults parameter, or if you explicitly specify a value for MaxResults that is less than the number of asset filters, the response includes a pagination token named NextToken. You can specify this NextToken value in a subsequent call to ListAssetFilters to list the next set of asset filters.
        public let nextToken: String?
        /// The status of the asset filter.
        public let status: FilterStatus?

        @inlinable
        public init(assetIdentifier: String, domainIdentifier: String, maxResults: Int? = nil, nextToken: String? = nil, status: FilterStatus? = nil) {
            self.assetIdentifier = assetIdentifier
            self.domainIdentifier = domainIdentifier
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.status = status
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.assetIdentifier, key: "assetIdentifier")
            request.encodePath(self.domainIdentifier, key: "domainIdentifier")
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
            request.encodeQuery(self.status, key: "status")
        }

        public func validate(name: String) throws {
            try self.validate(self.assetIdentifier, name: "assetIdentifier", parent: name, pattern: "^[a-zA-Z0-9_-]{1,36}$")
            try self.validate(self.domainIdentifier, name: "domainIdentifier", parent: name, pattern: "^dzd[-_][a-zA-Z0-9_-]{1,36}$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 50)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 8192)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListAssetFiltersOutput: AWSDecodableShape {
        /// The results of the ListAssetFilters action.
        public let items: [AssetFilterSummary]
        /// When the number of asset filters is greater than the default value for the MaxResults parameter, or if you explicitly specify a value for MaxResults that is less than the number of asset filters, the response includes a pagination token named NextToken. You can specify this NextToken value in a subsequent call to ListAssetFilters to list the next set of asset filters.
        public let nextToken: String?

        @inlinable
        public init(items: [AssetFilterSummary], nextToken: String? = nil) {
            self.items = items
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case items = "items"
            case nextToken = "nextToken"
        }
    }

    public struct ListAssetRevisionsInput: AWSEncodableShape {
        /// The identifier of the domain.
        public let domainIdentifier: String
        /// The identifier of the asset.
        public let identifier: String
        /// The maximum number of revisions to return in a single call to ListAssetRevisions. When the number of revisions to be listed is greater than the value of MaxResults, the response contains a NextToken value that you can use in a subsequent call to ListAssetRevisions to list the next set of revisions.
        public let maxResults: Int?
        /// When the number of revisions is greater than the default value for the MaxResults parameter, or if you explicitly specify a value for MaxResults that is less than the number of revisions, the response includes a pagination token named NextToken. You can specify this NextToken value in a subsequent call to ListAssetRevisions to list the next set of revisions.
        public let nextToken: String?

        @inlinable
        public init(domainIdentifier: String, identifier: String, maxResults: Int? = nil, nextToken: String? = nil) {
            self.domainIdentifier = domainIdentifier
            self.identifier = identifier
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.domainIdentifier, key: "domainIdentifier")
            request.encodePath(self.identifier, key: "identifier")
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
        }

        public func validate(name: String) throws {
            try self.validate(self.domainIdentifier, name: "domainIdentifier", parent: name, pattern: "^dzd[-_][a-zA-Z0-9_-]{1,36}$")
            try self.validate(self.identifier, name: "identifier", parent: name, pattern: "^[a-zA-Z0-9_-]{1,36}$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 50)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 8192)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListAssetRevisionsOutput: AWSDecodableShape {
        /// The results of the ListAssetRevisions action.
        public let items: [AssetRevision]?
        /// When the number of revisions is greater than the default value for the MaxResults parameter, or if you explicitly specify a value for MaxResults that is less than the number of revisions, the response includes a pagination token named NextToken. You can specify this NextToken value in a subsequent call to ListAssetRevisions to list the next set of revisions.
        public let nextToken: String?

        @inlinable
        public init(items: [AssetRevision]? = nil, nextToken: String? = nil) {
            self.items = items
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case items = "items"
            case nextToken = "nextToken"
        }
    }

    public struct ListConnectionsInput: AWSEncodableShape {
        /// The ID of the domain where you want to list connections.
        public let domainIdentifier: String
        /// The ID of the environment where you want to list connections.
        public let environmentIdentifier: String?
        /// The maximum number of connections to return in a single call to ListConnections. When the number of connections to be listed is greater than the value of MaxResults, the response contains a NextToken value that you can use in a subsequent call to ListConnections to list the next set of connections.
        public let maxResults: Int?
        /// The name of the connection.
        public let name: String?
        /// When the number of connections is greater than the default value for the MaxResults parameter, or if you explicitly specify a value for MaxResults that is less than the number of connections, the response includes a pagination token named NextToken. You can specify this NextToken value in a subsequent call to ListConnections to list the next set of connections.
        public let nextToken: String?
        /// The ID of the project where you want to list connections.
        public let projectIdentifier: String
        /// Specifies how you want to sort the listed connections.
        public let sortBy: SortFieldConnection?
        /// Specifies the sort order for the listed connections.
        public let sortOrder: SortOrder?
        /// The type of connection.
        public let type: ConnectionType?

        @inlinable
        public init(domainIdentifier: String, environmentIdentifier: String? = nil, maxResults: Int? = nil, name: String? = nil, nextToken: String? = nil, projectIdentifier: String, sortBy: SortFieldConnection? = nil, sortOrder: SortOrder? = nil, type: ConnectionType? = nil) {
            self.domainIdentifier = domainIdentifier
            self.environmentIdentifier = environmentIdentifier
            self.maxResults = maxResults
            self.name = name
            self.nextToken = nextToken
            self.projectIdentifier = projectIdentifier
            self.sortBy = sortBy
            self.sortOrder = sortOrder
            self.type = type
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.domainIdentifier, key: "domainIdentifier")
            request.encodeQuery(self.environmentIdentifier, key: "environmentIdentifier")
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.name, key: "name")
            request.encodeQuery(self.nextToken, key: "nextToken")
            request.encodeQuery(self.projectIdentifier, key: "projectIdentifier")
            request.encodeQuery(self.sortBy, key: "sortBy")
            request.encodeQuery(self.sortOrder, key: "sortOrder")
            request.encodeQuery(self.type, key: "type")
        }

        public func validate(name: String) throws {
            try self.validate(self.domainIdentifier, name: "domainIdentifier", parent: name, pattern: "^dzd[-_][a-zA-Z0-9_-]{1,36}$")
            try self.validate(self.environmentIdentifier, name: "environmentIdentifier", parent: name, pattern: "^[a-zA-Z0-9_-]{1,36}$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 50)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, max: 64)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 8192)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.projectIdentifier, name: "projectIdentifier", parent: name, pattern: "^[a-zA-Z0-9_-]{1,36}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListConnectionsOutput: AWSDecodableShape {
        /// The results of the ListConnections action.
        public let items: [ConnectionSummary]
        /// When the number of connections is greater than the default value for the MaxResults parameter, or if you explicitly specify a value for MaxResults that is less than the number of connections, the response includes a pagination token named NextToken. You can specify this NextToken value in a subsequent call to ListConnections to list the next set of connections.
        public let nextToken: String?

        @inlinable
        public init(items: [ConnectionSummary], nextToken: String? = nil) {
            self.items = items
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case items = "items"
            case nextToken = "nextToken"
        }
    }

    public struct ListDataProductRevisionsInput: AWSEncodableShape {
        /// The ID of the domain of the data product revisions that you want to list.
        public let domainIdentifier: String
        /// The ID of the data product revision.
        public let identifier: String
        /// The maximum number of asset filters to return in a single call to ListDataProductRevisions. When the number of data product revisions to be listed is greater than the value of MaxResults, the response contains a NextToken value that you can use in a subsequent call to ListDataProductRevisions to list the next set of data product revisions.
        public let maxResults: Int?
        /// When the number of data product revisions is greater than the default value for the MaxResults parameter, or if you explicitly specify a value for MaxResults that is less than the number of data product revisions, the response includes a pagination token named NextToken. You can specify this NextToken value in a subsequent call to ListDataProductRevisions to list the next set of data product revisions.
        public let nextToken: String?

        @inlinable
        public init(domainIdentifier: String, identifier: String, maxResults: Int? = nil, nextToken: String? = nil) {
            self.domainIdentifier = domainIdentifier
            self.identifier = identifier
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.domainIdentifier, key: "domainIdentifier")
            request.encodePath(self.identifier, key: "identifier")
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
        }

        public func validate(name: String) throws {
            try self.validate(self.domainIdentifier, name: "domainIdentifier", parent: name, pattern: "^dzd[-_][a-zA-Z0-9_-]{1,36}$")
            try self.validate(self.identifier, name: "identifier", parent: name, pattern: "^[a-zA-Z0-9_-]{1,36}$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 50)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 8192)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListDataProductRevisionsOutput: AWSDecodableShape {
        /// The results of the ListDataProductRevisions action.
        public let items: [DataProductRevision]
        /// When the number of data product revisions is greater than the default value for the MaxResults parameter, or if you explicitly specify a value for MaxResults that is less than the number of data product revisions, the response includes a pagination token named NextToken. You can specify this NextToken value in a subsequent call to ListDataProductRevisions to list the next set of data product revisions.
        public let nextToken: String?

        @inlinable
        public init(items: [DataProductRevision], nextToken: String? = nil) {
            self.items = items
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case items = "items"
            case nextToken = "nextToken"
        }
    }

    public struct ListDataSourceRunActivitiesInput: AWSEncodableShape {
        /// The identifier of the Amazon DataZone domain in which to list data source run activities.
        public let domainIdentifier: String
        /// The identifier of the data source run.
        public let identifier: String
        /// The maximum number of activities to return in a single call to ListDataSourceRunActivities. When the number of activities to be listed is greater than the value of MaxResults, the response contains a NextToken value that you can use in a subsequent call to ListDataSourceRunActivities to list the next set of activities.
        public let maxResults: Int?
        /// When the number of activities is greater than the default value for the MaxResults parameter, or if you explicitly specify a value for MaxResults that is less than the number of activities, the response includes a pagination token named NextToken. You can specify this NextToken value in a subsequent call to ListDataSourceRunActivities to list the next set of activities.
        public let nextToken: String?
        /// The status of the data source run.
        public let status: DataAssetActivityStatus?

        @inlinable
        public init(domainIdentifier: String, identifier: String, maxResults: Int? = nil, nextToken: String? = nil, status: DataAssetActivityStatus? = nil) {
            self.domainIdentifier = domainIdentifier
            self.identifier = identifier
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.status = status
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.domainIdentifier, key: "domainIdentifier")
            request.encodePath(self.identifier, key: "identifier")
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
            request.encodeQuery(self.status, key: "status")
        }

        public func validate(name: String) throws {
            try self.validate(self.domainIdentifier, name: "domainIdentifier", parent: name, pattern: "^dzd[-_][a-zA-Z0-9_-]{1,36}$")
            try self.validate(self.identifier, name: "identifier", parent: name, pattern: "^[a-zA-Z0-9_-]{1,36}$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 50)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 8192)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListDataSourceRunActivitiesOutput: AWSDecodableShape {
        /// The results of the ListDataSourceRunActivities action.
        public let items: [DataSourceRunActivity]
        /// When the number of activities is greater than the default value for the MaxResults parameter, or if you explicitly specify a value for MaxResults that is less than the number of activities, the response includes a pagination token named NextToken. You can specify this NextToken value in a subsequent call to ListDataSourceRunActivities to list the next set of activities.
        public let nextToken: String?

        @inlinable
        public init(items: [DataSourceRunActivity], nextToken: String? = nil) {
            self.items = items
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case items = "items"
            case nextToken = "nextToken"
        }
    }

    public struct ListDataSourceRunsInput: AWSEncodableShape {
        /// The identifier of the data source.
        public let dataSourceIdentifier: String
        /// The identifier of the Amazon DataZone domain in which to invoke the ListDataSourceRuns action.
        public let domainIdentifier: String
        /// The maximum number of runs to return in a single call to ListDataSourceRuns. When the number of runs to be listed is greater than the value of MaxResults, the response contains a NextToken value that you can use in a subsequent call to ListDataSourceRuns to list the next set of runs.
        public let maxResults: Int?
        /// When the number of runs is greater than the default value for the MaxResults parameter, or if you explicitly specify a value for MaxResults that is less than the number of runs, the response includes a pagination token named NextToken. You can specify this NextToken value in a subsequent call to ListDataSourceRuns to list the next set of runs.
        public let nextToken: String?
        /// The status of the data source.
        public let status: DataSourceRunStatus?

        @inlinable
        public init(dataSourceIdentifier: String, domainIdentifier: String, maxResults: Int? = nil, nextToken: String? = nil, status: DataSourceRunStatus? = nil) {
            self.dataSourceIdentifier = dataSourceIdentifier
            self.domainIdentifier = domainIdentifier
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.status = status
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.dataSourceIdentifier, key: "dataSourceIdentifier")
            request.encodePath(self.domainIdentifier, key: "domainIdentifier")
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
            request.encodeQuery(self.status, key: "status")
        }

        public func validate(name: String) throws {
            try self.validate(self.dataSourceIdentifier, name: "dataSourceIdentifier", parent: name, pattern: "^[a-zA-Z0-9_-]{1,36}$")
            try self.validate(self.domainIdentifier, name: "domainIdentifier", parent: name, pattern: "^dzd[-_][a-zA-Z0-9_-]{1,36}$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 50)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 8192)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListDataSourceRunsOutput: AWSDecodableShape {
        /// The results of the ListDataSourceRuns action.
        public let items: [DataSourceRunSummary]
        /// When the number of runs is greater than the default value for the MaxResults parameter, or if you explicitly specify a value for MaxResults that is less than the number of runs, the response includes a pagination token named NextToken. You can specify this NextToken value in a subsequent call to ListDataSourceRuns to list the next set of runs.
        public let nextToken: String?

        @inlinable
        public init(items: [DataSourceRunSummary], nextToken: String? = nil) {
            self.items = items
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case items = "items"
            case nextToken = "nextToken"
        }
    }

    public struct ListDataSourcesInput: AWSEncodableShape {
        /// The ID of the connection.
        public let connectionIdentifier: String?
        /// The identifier of the Amazon DataZone domain in which to list the data sources.
        public let domainIdentifier: String
        /// The identifier of the environment in which to list the data sources.
        public let environmentIdentifier: String?
        /// The maximum number of data sources to return in a single call to ListDataSources. When the number of data sources to be listed is greater than the value of MaxResults, the response contains a NextToken value that you can use in a subsequent call to ListDataSources to list the next set of data sources.
        public let maxResults: Int?
        /// The name of the data source.
        public let name: String?
        /// When the number of data sources is greater than the default value for the MaxResults parameter, or if you explicitly specify a value for MaxResults that is less than the number of data sources, the response includes a pagination token named NextToken. You can specify this NextToken value in a subsequent call to ListDataSources to list the next set of data sources.
        public let nextToken: String?
        /// The identifier of the project in which to list data sources.
        public let projectIdentifier: String
        /// The status of the data source.
        public let status: DataSourceStatus?
        /// The type of the data source.
        public let type: String?

        @inlinable
        public init(connectionIdentifier: String? = nil, domainIdentifier: String, environmentIdentifier: String? = nil, maxResults: Int? = nil, name: String? = nil, nextToken: String? = nil, projectIdentifier: String, status: DataSourceStatus? = nil, type: String? = nil) {
            self.connectionIdentifier = connectionIdentifier
            self.domainIdentifier = domainIdentifier
            self.environmentIdentifier = environmentIdentifier
            self.maxResults = maxResults
            self.name = name
            self.nextToken = nextToken
            self.projectIdentifier = projectIdentifier
            self.status = status
            self.type = type
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.connectionIdentifier, key: "connectionIdentifier")
            request.encodePath(self.domainIdentifier, key: "domainIdentifier")
            request.encodeQuery(self.environmentIdentifier, key: "environmentIdentifier")
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.name, key: "name")
            request.encodeQuery(self.nextToken, key: "nextToken")
            request.encodeQuery(self.projectIdentifier, key: "projectIdentifier")
            request.encodeQuery(self.status, key: "status")
            request.encodeQuery(self.type, key: "type")
        }

        public func validate(name: String) throws {
            try self.validate(self.domainIdentifier, name: "domainIdentifier", parent: name, pattern: "^dzd[-_][a-zA-Z0-9_-]{1,36}$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 50)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, max: 256)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 8192)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.type, name: "type", parent: name, max: 256)
            try self.validate(self.type, name: "type", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListDataSourcesOutput: AWSDecodableShape {
        /// The results of the ListDataSources action.
        public let items: [DataSourceSummary]
        /// When the number of data sources is greater than the default value for the MaxResults parameter, or if you explicitly specify a value for MaxResults that is less than the number of data sources, the response includes a pagination token named NextToken. You can specify this NextToken value in a subsequent call to ListDataSources to list the next set of data sources.
        public let nextToken: String?

        @inlinable
        public init(items: [DataSourceSummary], nextToken: String? = nil) {
            self.items = items
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case items = "items"
            case nextToken = "nextToken"
        }
    }

    public struct ListDomainUnitsForParentInput: AWSEncodableShape {
        /// The ID of the domain in which you want to list domain units for a parent domain unit.
        public let domainIdentifier: String
        /// The maximum number of domain units to return in a single call to ListDomainUnitsForParent. When the number of domain units to be listed is greater than the value of MaxResults, the response contains a NextToken value that you can use in a subsequent call to ListDomainUnitsForParent to list the next set of domain units.
        public let maxResults: Int?
        /// When the number of domain units is greater than the default value for the MaxResults parameter, or if you explicitly specify a value for MaxResults that is less than the number of domain units, the response includes a pagination token named NextToken. You can specify this NextToken value in a subsequent call to ListDomainUnitsForParent to list the next set of domain units.
        public let nextToken: String?
        /// The ID of the parent domain unit.
        public let parentDomainUnitIdentifier: String

        @inlinable
        public init(domainIdentifier: String, maxResults: Int? = nil, nextToken: String? = nil, parentDomainUnitIdentifier: String) {
            self.domainIdentifier = domainIdentifier
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.parentDomainUnitIdentifier = parentDomainUnitIdentifier
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.domainIdentifier, key: "domainIdentifier")
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
            request.encodeQuery(self.parentDomainUnitIdentifier, key: "parentDomainUnitIdentifier")
        }

        public func validate(name: String) throws {
            try self.validate(self.domainIdentifier, name: "domainIdentifier", parent: name, pattern: "^dzd[-_][a-zA-Z0-9_-]{1,36}$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 25)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 8192)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.parentDomainUnitIdentifier, name: "parentDomainUnitIdentifier", parent: name, max: 256)
            try self.validate(self.parentDomainUnitIdentifier, name: "parentDomainUnitIdentifier", parent: name, min: 1)
            try self.validate(self.parentDomainUnitIdentifier, name: "parentDomainUnitIdentifier", parent: name, pattern: "^[a-z0-9_\\-]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListDomainUnitsForParentOutput: AWSDecodableShape {
        /// The results returned by this action.
        public let items: [DomainUnitSummary]
        /// When the number of domain units is greater than the default value for the MaxResults parameter, or if you explicitly specify a value for MaxResults that is less than the number of domain units, the response includes a pagination token named NextToken. You can specify this NextToken value in a subsequent call to ListDomainUnitsForParent to list the next set of domain units.
        public let nextToken: String?

        @inlinable
        public init(items: [DomainUnitSummary], nextToken: String? = nil) {
            self.items = items
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case items = "items"
            case nextToken = "nextToken"
        }
    }

    public struct ListDomainsInput: AWSEncodableShape {
        /// The maximum number of domains to return in a single call to ListDomains. When the number of domains to be listed is greater than the value of MaxResults, the response contains a NextToken value that you can use in a subsequent call to ListDomains to list the next set of domains.
        public let maxResults: Int?
        /// When the number of domains is greater than the default value for the MaxResults parameter, or if you explicitly specify a value for MaxResults that is less than the number of domains, the response includes a pagination token named NextToken. You can specify this NextToken value in a subsequent call to ListDomains to list the next set of domains.
        public let nextToken: String?
        /// The status of the data source.
        public let status: DomainStatus?

        @inlinable
        public init(maxResults: Int? = nil, nextToken: String? = nil, status: DomainStatus? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.status = status
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
            request.encodeQuery(self.status, key: "status")
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 25)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 8192)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListDomainsOutput: AWSDecodableShape {
        /// The results of the ListDomains action.
        public let items: [DomainSummary]
        /// When the number of domains is greater than the default value for the MaxResults parameter, or if you explicitly specify a value for MaxResults that is less than the number of domains, the response includes a pagination token named NextToken. You can specify this NextToken value in a subsequent call to ListDomains to list the next set of domains.
        public let nextToken: String?

        @inlinable
        public init(items: [DomainSummary], nextToken: String? = nil) {
            self.items = items
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case items = "items"
            case nextToken = "nextToken"
        }
    }

    public struct ListEntityOwnersInput: AWSEncodableShape {
        /// The ID of the domain where you want to list entity owners.
        public let domainIdentifier: String
        /// The ID of the entity that you want to list.
        public let entityIdentifier: String
        /// The type of the entity that you want to list.
        public let entityType: DataZoneEntityType
        /// The maximum number of entities to return in a single call to ListEntityOwners. When the number of entities to be listed is greater than the value of MaxResults, the response contains a NextToken value that you can use in a subsequent call to ListEntityOwners to list the next set of entities.
        public let maxResults: Int?
        /// When the number of entities is greater than the default value for the MaxResults parameter, or if you explicitly specify a value for MaxResults that is less than the number of entities, the response includes a pagination token named NextToken. You can specify this NextToken value in a subsequent call to ListEntityOwners to list the next set of entities.
        public let nextToken: String?

        @inlinable
        public init(domainIdentifier: String, entityIdentifier: String, entityType: DataZoneEntityType, maxResults: Int? = nil, nextToken: String? = nil) {
            self.domainIdentifier = domainIdentifier
            self.entityIdentifier = entityIdentifier
            self.entityType = entityType
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.domainIdentifier, key: "domainIdentifier")
            request.encodePath(self.entityIdentifier, key: "entityIdentifier")
            request.encodePath(self.entityType, key: "entityType")
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
        }

        public func validate(name: String) throws {
            try self.validate(self.domainIdentifier, name: "domainIdentifier", parent: name, pattern: "^dzd[-_][a-zA-Z0-9_-]{1,36}$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 25)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 8192)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListEntityOwnersOutput: AWSDecodableShape {
        /// When the number of entities is greater than the default value for the MaxResults parameter, or if you explicitly specify a value for MaxResults that is less than the number of entities, the response includes a pagination token named NextToken. You can specify this NextToken value in a subsequent call to ListEntityOwners to list the next set of entities.
        public let nextToken: String?
        /// The owners of the entity.
        public let owners: [OwnerPropertiesOutput]

        @inlinable
        public init(nextToken: String? = nil, owners: [OwnerPropertiesOutput]) {
            self.nextToken = nextToken
            self.owners = owners
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "nextToken"
            case owners = "owners"
        }
    }

    public struct ListEnvironmentActionsInput: AWSEncodableShape {
        /// The ID of the Amazon DataZone domain in which the environment actions are listed.
        public let domainIdentifier: String
        /// The ID of the envrironment whose environment actions are listed.
        public let environmentIdentifier: String
        /// The maximum number of environment actions to return in a single call to ListEnvironmentActions. When the number of environment actions to be listed is greater than the value of MaxResults, the response contains a NextToken value that you can use in a subsequent call to ListEnvironmentActions to list the next set of environment actions.
        public let maxResults: Int?
        /// When the number of environment actions is greater than the default value for the MaxResults parameter, or if you explicitly specify a value for MaxResults that is less than the number of environment actions, the response includes a pagination token named NextToken. You can specify this NextToken value in a subsequent call to ListEnvironmentActions to list the next set of environment actions.
        public let nextToken: String?

        @inlinable
        public init(domainIdentifier: String, environmentIdentifier: String, maxResults: Int? = nil, nextToken: String? = nil) {
            self.domainIdentifier = domainIdentifier
            self.environmentIdentifier = environmentIdentifier
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.domainIdentifier, key: "domainIdentifier")
            request.encodePath(self.environmentIdentifier, key: "environmentIdentifier")
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
        }

        public func validate(name: String) throws {
            try self.validate(self.domainIdentifier, name: "domainIdentifier", parent: name, pattern: "^dzd[-_][a-zA-Z0-9_-]{1,36}$")
            try self.validate(self.environmentIdentifier, name: "environmentIdentifier", parent: name, pattern: "^[a-zA-Z0-9_-]{1,36}$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 50)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 8192)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListEnvironmentActionsOutput: AWSDecodableShape {
        /// The results of ListEnvironmentActions.
        public let items: [EnvironmentActionSummary]?
        /// When the number of environment actions is greater than the default value for the MaxResults parameter, or if you explicitly specify a value for MaxResults that is less than the number of environment actions, the response includes a pagination token named NextToken. You can specify this NextToken value in a subsequent call to ListEnvironmentActions to list the next set of environment actions.
        public let nextToken: String?

        @inlinable
        public init(items: [EnvironmentActionSummary]? = nil, nextToken: String? = nil) {
            self.items = items
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case items = "items"
            case nextToken = "nextToken"
        }
    }

    public struct ListEnvironmentBlueprintConfigurationsInput: AWSEncodableShape {
        /// The identifier of the Amazon DataZone domain.
        public let domainIdentifier: String
        /// The maximum number of blueprint configurations to return in a single call to ListEnvironmentBlueprintConfigurations. When the number of configurations to be listed is greater than the value of MaxResults, the response contains a NextToken value that you can use in a subsequent call to ListEnvironmentBlueprintConfigurations to list the next set of configurations.
        public let maxResults: Int?
        /// When the number of blueprint configurations is greater than the default value for the MaxResults parameter, or if you explicitly specify a value for MaxResults that is less than the number of configurations, the response includes a pagination token named NextToken. You can specify this NextToken value in a subsequent call to ListEnvironmentBlueprintConfigurations to list the next set of configurations.
        public let nextToken: String?

        @inlinable
        public init(domainIdentifier: String, maxResults: Int? = nil, nextToken: String? = nil) {
            self.domainIdentifier = domainIdentifier
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.domainIdentifier, key: "domainIdentifier")
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
        }

        public func validate(name: String) throws {
            try self.validate(self.domainIdentifier, name: "domainIdentifier", parent: name, pattern: "^dzd[-_][a-zA-Z0-9_-]{1,36}$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 50)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 8192)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListEnvironmentBlueprintConfigurationsOutput: AWSDecodableShape {
        /// The results of the ListEnvironmentBlueprintConfigurations action.
        public let items: [EnvironmentBlueprintConfigurationItem]?
        /// When the number of blueprint configurations is greater than the default value for the MaxResults parameter, or if you explicitly specify a value for MaxResults that is less than the number of configurations, the response includes a pagination token named NextToken. You can specify this NextToken value in a subsequent call to ListEnvironmentBlueprintConfigurations to list the next set of configurations.
        public let nextToken: String?

        @inlinable
        public init(items: [EnvironmentBlueprintConfigurationItem]? = nil, nextToken: String? = nil) {
            self.items = items
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case items = "items"
            case nextToken = "nextToken"
        }
    }

    public struct ListEnvironmentBlueprintsInput: AWSEncodableShape {
        /// The identifier of the Amazon DataZone domain.
        public let domainIdentifier: String
        /// Specifies whether the environment blueprint is managed by Amazon DataZone.
        public let managed: Bool?
        /// The maximum number of blueprints to return in a single call to ListEnvironmentBlueprints. When the number of blueprints to be listed is greater than the value of MaxResults, the response contains a NextToken value that you can use in a subsequent call to ListEnvironmentBlueprints to list the next set of blueprints.
        public let maxResults: Int?
        /// The name of the Amazon DataZone environment.
        public let name: String?
        /// When the number of blueprints in the environment is greater than the default value for the MaxResults parameter, or if you explicitly specify a value for MaxResults that is less than the number of blueprints in the environment, the response includes a pagination token named NextToken. You can specify this NextToken value in a subsequent call to ListEnvironmentBlueprintsto list the next set of blueprints.
        public let nextToken: String?

        @inlinable
        public init(domainIdentifier: String, managed: Bool? = nil, maxResults: Int? = nil, name: String? = nil, nextToken: String? = nil) {
            self.domainIdentifier = domainIdentifier
            self.managed = managed
            self.maxResults = maxResults
            self.name = name
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.domainIdentifier, key: "domainIdentifier")
            request.encodeQuery(self.managed, key: "managed")
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.name, key: "name")
            request.encodeQuery(self.nextToken, key: "nextToken")
        }

        public func validate(name: String) throws {
            try self.validate(self.domainIdentifier, name: "domainIdentifier", parent: name, pattern: "^dzd[-_][a-zA-Z0-9_-]{1,36}$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 50)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, max: 64)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[\\w -]+$")
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 8192)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListEnvironmentBlueprintsOutput: AWSDecodableShape {
        /// The results of the ListEnvironmentBlueprints action.
        public let items: [EnvironmentBlueprintSummary]
        /// When the number of blueprints in the environment is greater than the default value for the MaxResults parameter, or if you explicitly specify a value for MaxResults that is less than the number of blueprints in the environment, the response includes a pagination token named NextToken. You can specify this NextToken value in a subsequent call to ListEnvironmentBlueprintsto list the next set of blueprints.
        public let nextToken: String?

        @inlinable
        public init(items: [EnvironmentBlueprintSummary], nextToken: String? = nil) {
            self.items = items
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case items = "items"
            case nextToken = "nextToken"
        }
    }

    public struct ListEnvironmentProfilesInput: AWSEncodableShape {
        /// The identifier of the Amazon Web Services account where you want to list environment profiles.
        public let awsAccountId: String?
        /// The Amazon Web Services region where you want to list environment profiles.
        public let awsAccountRegion: String?
        /// The identifier of the Amazon DataZone domain.
        public let domainIdentifier: String
        /// The identifier of the blueprint that was used to create the environment profiles that you want to list.
        public let environmentBlueprintIdentifier: String?
        /// The maximum number of environment profiles to return in a single call to ListEnvironmentProfiles. When the number of environment profiles to be listed is greater than the value of MaxResults, the response contains a NextToken value that you can use in a subsequent call to ListEnvironmentProfiles to list the next set of environment profiles.
        public let maxResults: Int?
        public let name: String?
        /// When the number of environment profiles is greater than the default value for the MaxResults parameter, or if you explicitly specify a value for MaxResults that is less than the number of environment profiles, the response includes a pagination token named NextToken. You can specify this NextToken value in a subsequent call to ListEnvironmentProfiles to list the next set of environment profiles.
        public let nextToken: String?
        /// The identifier of the Amazon DataZone project.
        public let projectIdentifier: String?

        @inlinable
        public init(awsAccountId: String? = nil, awsAccountRegion: String? = nil, domainIdentifier: String, environmentBlueprintIdentifier: String? = nil, maxResults: Int? = nil, name: String? = nil, nextToken: String? = nil, projectIdentifier: String? = nil) {
            self.awsAccountId = awsAccountId
            self.awsAccountRegion = awsAccountRegion
            self.domainIdentifier = domainIdentifier
            self.environmentBlueprintIdentifier = environmentBlueprintIdentifier
            self.maxResults = maxResults
            self.name = name
            self.nextToken = nextToken
            self.projectIdentifier = projectIdentifier
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.awsAccountId, key: "awsAccountId")
            request.encodeQuery(self.awsAccountRegion, key: "awsAccountRegion")
            request.encodePath(self.domainIdentifier, key: "domainIdentifier")
            request.encodeQuery(self.environmentBlueprintIdentifier, key: "environmentBlueprintIdentifier")
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.name, key: "name")
            request.encodeQuery(self.nextToken, key: "nextToken")
            request.encodeQuery(self.projectIdentifier, key: "projectIdentifier")
        }

        public func validate(name: String) throws {
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, pattern: "^\\d{12}$")
            try self.validate(self.awsAccountRegion, name: "awsAccountRegion", parent: name, pattern: "^[a-z]{2}-[a-z]{4,10}-\\d$")
            try self.validate(self.domainIdentifier, name: "domainIdentifier", parent: name, pattern: "^dzd[-_][a-zA-Z0-9_-]{1,36}$")
            try self.validate(self.environmentBlueprintIdentifier, name: "environmentBlueprintIdentifier", parent: name, pattern: "^[a-zA-Z0-9_-]{1,36}$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 50)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, max: 64)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[\\w -]+$")
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 8192)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.projectIdentifier, name: "projectIdentifier", parent: name, pattern: "^[a-zA-Z0-9_-]{1,36}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListEnvironmentProfilesOutput: AWSDecodableShape {
        /// The results of the ListEnvironmentProfiles action.
        public let items: [EnvironmentProfileSummary]
        /// When the number of environment profiles is greater than the default value for the MaxResults parameter, or if you explicitly specify a value for MaxResults that is less than the number of environment profiles, the response includes a pagination token named NextToken. You can specify this NextToken value in a subsequent call to ListEnvironmentProfiles to list the next set of environment profiles.
        public let nextToken: String?

        @inlinable
        public init(items: [EnvironmentProfileSummary], nextToken: String? = nil) {
            self.items = items
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case items = "items"
            case nextToken = "nextToken"
        }
    }

    public struct ListEnvironmentsInput: AWSEncodableShape {
        /// The identifier of the Amazon Web Services account where you want to list environments.
        public let awsAccountId: String?
        /// The Amazon Web Services region where you want to list environments.
        public let awsAccountRegion: String?
        /// The identifier of the Amazon DataZone domain.
        public let domainIdentifier: String
        /// The identifier of the Amazon DataZone blueprint.
        public let environmentBlueprintIdentifier: String?
        /// The identifier of the environment profile.
        public let environmentProfileIdentifier: String?
        /// The maximum number of environments to return in a single call to ListEnvironments. When the number of environments to be listed is greater than the value of MaxResults, the response contains a NextToken value that you can use in a subsequent call to ListEnvironments to list the next set of environments.
        public let maxResults: Int?
        /// The name of the environment.
        public let name: String?
        /// When the number of environments is greater than the default value for the MaxResults parameter, or if you explicitly specify a value for MaxResults that is less than the number of environments, the response includes a pagination token named NextToken. You can specify this NextToken value in a subsequent call to ListEnvironments to list the next set of environments.
        public let nextToken: String?
        /// The identifier of the Amazon DataZone project.
        public let projectIdentifier: String
        /// The provider of the environment.
        public let provider: String?
        /// The status of the environments that you want to list.
        public let status: EnvironmentStatus?

        @inlinable
        public init(awsAccountId: String? = nil, awsAccountRegion: String? = nil, domainIdentifier: String, environmentBlueprintIdentifier: String? = nil, environmentProfileIdentifier: String? = nil, maxResults: Int? = nil, name: String? = nil, nextToken: String? = nil, projectIdentifier: String, provider: String? = nil, status: EnvironmentStatus? = nil) {
            self.awsAccountId = awsAccountId
            self.awsAccountRegion = awsAccountRegion
            self.domainIdentifier = domainIdentifier
            self.environmentBlueprintIdentifier = environmentBlueprintIdentifier
            self.environmentProfileIdentifier = environmentProfileIdentifier
            self.maxResults = maxResults
            self.name = name
            self.nextToken = nextToken
            self.projectIdentifier = projectIdentifier
            self.provider = provider
            self.status = status
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.awsAccountId, key: "awsAccountId")
            request.encodeQuery(self.awsAccountRegion, key: "awsAccountRegion")
            request.encodePath(self.domainIdentifier, key: "domainIdentifier")
            request.encodeQuery(self.environmentBlueprintIdentifier, key: "environmentBlueprintIdentifier")
            request.encodeQuery(self.environmentProfileIdentifier, key: "environmentProfileIdentifier")
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.name, key: "name")
            request.encodeQuery(self.nextToken, key: "nextToken")
            request.encodeQuery(self.projectIdentifier, key: "projectIdentifier")
            request.encodeQuery(self.provider, key: "provider")
            request.encodeQuery(self.status, key: "status")
        }

        public func validate(name: String) throws {
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, pattern: "^\\d{12}$")
            try self.validate(self.awsAccountRegion, name: "awsAccountRegion", parent: name, pattern: "^[a-z]{2}-[a-z]{4,10}-\\d$")
            try self.validate(self.domainIdentifier, name: "domainIdentifier", parent: name, pattern: "^dzd[-_][a-zA-Z0-9_-]{1,36}$")
            try self.validate(self.environmentBlueprintIdentifier, name: "environmentBlueprintIdentifier", parent: name, pattern: "^[a-zA-Z0-9_-]{1,36}$")
            try self.validate(self.environmentProfileIdentifier, name: "environmentProfileIdentifier", parent: name, pattern: "^[a-zA-Z0-9_-]{0,36}$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 50)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 8192)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.projectIdentifier, name: "projectIdentifier", parent: name, pattern: "^[a-zA-Z0-9_-]{1,36}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListEnvironmentsOutput: AWSDecodableShape {
        /// The results of the ListEnvironments action.
        public let items: [EnvironmentSummary]
        /// When the number of environments is greater than the default value for the MaxResults parameter, or if you explicitly specify a value for MaxResults that is less than the number of environments, the response includes a pagination token named NextToken. You can specify this NextToken value in a subsequent call to ListEnvironments to list the next set of environments.
        public let nextToken: String?

        @inlinable
        public init(items: [EnvironmentSummary], nextToken: String? = nil) {
            self.items = items
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case items = "items"
            case nextToken = "nextToken"
        }
    }

    public struct ListJobRunsInput: AWSEncodableShape {
        /// The ID of the domain where you want to list job runs.
        public let domainIdentifier: String
        /// The ID of the job run.
        public let jobIdentifier: String
        /// The maximum number of job runs to return in a single call to ListJobRuns. When the number of job runs to be listed is greater than the value of MaxResults, the response contains a NextToken value that you can use in a subsequent call to ListJobRuns to list the next set of job runs.
        public let maxResults: Int?
        /// When the number of job runs is greater than the default value for the MaxResults parameter, or if you explicitly specify a value for MaxResults that is less than the number of job runs, the response includes a pagination token named NextToken. You can specify this NextToken value in a subsequent call to ListJobRuns to list the next set of job runs.
        public let nextToken: String?
        /// Specifies the order in which job runs are to be sorted.
        public let sortOrder: SortOrder?
        /// The status of a job run.
        public let status: JobRunStatus?

        @inlinable
        public init(domainIdentifier: String, jobIdentifier: String, maxResults: Int? = nil, nextToken: String? = nil, sortOrder: SortOrder? = nil, status: JobRunStatus? = nil) {
            self.domainIdentifier = domainIdentifier
            self.jobIdentifier = jobIdentifier
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.sortOrder = sortOrder
            self.status = status
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.domainIdentifier, key: "domainIdentifier")
            request.encodePath(self.jobIdentifier, key: "jobIdentifier")
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
            request.encodeQuery(self.sortOrder, key: "sortOrder")
            request.encodeQuery(self.status, key: "status")
        }

        public func validate(name: String) throws {
            try self.validate(self.domainIdentifier, name: "domainIdentifier", parent: name, pattern: "^dzd[-_][a-zA-Z0-9_-]{1,36}$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 50)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 8192)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListJobRunsOutput: AWSDecodableShape {
        /// The results of the ListJobRuns action.
        public let items: [JobRunSummary]?
        /// When the number of job runs is greater than the default value for the MaxResults parameter, or if you explicitly specify a value for MaxResults that is less than the number of job runs, the response includes a pagination token named NextToken. You can specify this NextToken value in a subsequent call to ListJobRuns to list the next set of job runs.
        public let nextToken: String?

        @inlinable
        public init(items: [JobRunSummary]? = nil, nextToken: String? = nil) {
            self.items = items
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case items = "items"
            case nextToken = "nextToken"
        }
    }

    public struct ListLineageEventsInput: AWSEncodableShape {
        /// The ID of the domain where you want to list lineage events.
        public let domainIdentifier: String
        /// The maximum number of lineage events to return in a single call to ListLineageEvents. When the number of lineage events to be listed is greater than the value of MaxResults, the response contains a NextToken value that you can use in a subsequent call to ListLineageEvents to list the next set of lineage events.
        public let maxResults: Int?
        /// When the number of lineage events is greater than the default value for the MaxResults parameter, or if you explicitly specify a value for MaxResults that is less than the number of lineage events, the response includes a pagination token named NextToken. You can specify this NextToken value in a subsequent call to ListLineageEvents to list the next set of lineage events.
        public let nextToken: String?
        /// The processing status of a lineage event.
        public let processingStatus: LineageEventProcessingStatus?
        /// The sort order of the lineage events.
        public let sortOrder: SortOrder?
        /// The after timestamp of a lineage event.
        public let timestampAfter: Date?
        /// The before timestamp of a lineage event.
        public let timestampBefore: Date?

        @inlinable
        public init(domainIdentifier: String, maxResults: Int? = nil, nextToken: String? = nil, processingStatus: LineageEventProcessingStatus? = nil, sortOrder: SortOrder? = nil, timestampAfter: Date? = nil, timestampBefore: Date? = nil) {
            self.domainIdentifier = domainIdentifier
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.processingStatus = processingStatus
            self.sortOrder = sortOrder
            self.timestampAfter = timestampAfter
            self.timestampBefore = timestampBefore
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.domainIdentifier, key: "domainIdentifier")
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
            request.encodeQuery(self.processingStatus, key: "processingStatus")
            request.encodeQuery(self.sortOrder, key: "sortOrder")
            request.encodeQuery(self.timestampAfter, key: "timestampAfter")
            request.encodeQuery(self.timestampBefore, key: "timestampBefore")
        }

        public func validate(name: String) throws {
            try self.validate(self.domainIdentifier, name: "domainIdentifier", parent: name, pattern: "^dzd[-_][a-zA-Z0-9_-]{1,36}$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 50)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 8192)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListLineageEventsOutput: AWSDecodableShape {
        /// The results of the ListLineageEvents action.
        public let items: [LineageEventSummary]?
        /// When the number of lineage events is greater than the default value for the MaxResults parameter, or if you explicitly specify a value for MaxResults that is less than the number of lineage events, the response includes a pagination token named NextToken. You can specify this NextToken value in a subsequent call to ListLineageEvents to list the next set of lineage events.
        public let nextToken: String?

        @inlinable
        public init(items: [LineageEventSummary]? = nil, nextToken: String? = nil) {
            self.items = items
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case items = "items"
            case nextToken = "nextToken"
        }
    }

    public struct ListLineageNodeHistoryInput: AWSEncodableShape {
        /// The direction of the data lineage node refers to the lineage node having neighbors in that direction. For example, if direction is UPSTREAM, the ListLineageNodeHistory API responds with historical versions with upstream neighbors only.
        public let direction: EdgeDirection?
        /// The ID of the domain where you want to list the history of the specified data lineage node.
        public let domainIdentifier: String
        /// Specifies whether the action is to return data lineage node history from the time after the event timestamp.
        public let eventTimestampGTE: Date?
        /// Specifies whether the action is to return data lineage node history from the time prior of the event timestamp.
        public let eventTimestampLTE: Date?
        /// The ID of the data lineage node whose history you want to list.
        public let identifier: String
        /// The maximum number of history items to return in a single call to ListLineageNodeHistory. When the number of memberships to be listed is greater than the value of MaxResults, the response contains a NextToken value that you can use in a subsequent call to ListLineageNodeHistory to list the next set of items.
        public let maxResults: Int?
        /// When the number of history items is greater than the default value for the MaxResults parameter, or if you explicitly specify a value for MaxResults that is less than the number of items, the response includes a pagination token named NextToken. You can specify this NextToken value in a subsequent call to ListLineageNodeHistory to list the next set of items.
        public let nextToken: String?
        /// The order by which you want data lineage node history to be sorted.
        public let sortOrder: SortOrder?

        @inlinable
        public init(direction: EdgeDirection? = nil, domainIdentifier: String, eventTimestampGTE: Date? = nil, eventTimestampLTE: Date? = nil, identifier: String, maxResults: Int? = nil, nextToken: String? = nil, sortOrder: SortOrder? = nil) {
            self.direction = direction
            self.domainIdentifier = domainIdentifier
            self.eventTimestampGTE = eventTimestampGTE
            self.eventTimestampLTE = eventTimestampLTE
            self.identifier = identifier
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.sortOrder = sortOrder
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.direction, key: "direction")
            request.encodePath(self.domainIdentifier, key: "domainIdentifier")
            request.encodeQuery(self.eventTimestampGTE, key: "timestampGTE")
            request.encodeQuery(self.eventTimestampLTE, key: "timestampLTE")
            request.encodePath(self.identifier, key: "identifier")
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
            request.encodeQuery(self.sortOrder, key: "sortOrder")
        }

        public func validate(name: String) throws {
            try self.validate(self.domainIdentifier, name: "domainIdentifier", parent: name, pattern: "^dzd[-_][a-zA-Z0-9_-]{1,36}$")
            try self.validate(self.identifier, name: "identifier", parent: name, max: 2086)
            try self.validate(self.identifier, name: "identifier", parent: name, min: 1)
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 50)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 8192)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListLineageNodeHistoryOutput: AWSDecodableShape {
        /// When the number of history items is greater than the default value for the MaxResults parameter, or if you explicitly specify a value for MaxResults that is less than the number of items, the response includes a pagination token named NextToken. You can specify this NextToken value in a subsequent call to ListLineageNodeHistory to list the next set of items.
        public let nextToken: String?
        /// The nodes returned by the ListLineageNodeHistory action.
        public let nodes: [LineageNodeSummary]?

        @inlinable
        public init(nextToken: String? = nil, nodes: [LineageNodeSummary]? = nil) {
            self.nextToken = nextToken
            self.nodes = nodes
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "nextToken"
            case nodes = "nodes"
        }
    }

    public struct ListMetadataGenerationRunsInput: AWSEncodableShape {
        /// The ID of the Amazon DataZone domain where you want to list metadata generation runs.
        public let domainIdentifier: String
        /// The maximum number of metadata generation runs to return in a single call to ListMetadataGenerationRuns. When the number of metadata generation runs to be listed is greater than the value of MaxResults, the response contains a NextToken value that you can use in a subsequent call to ListMetadataGenerationRuns to list the next set of revisions.
        public let maxResults: Int?
        /// When the number of metadata generation runs is greater than the default value for the MaxResults parameter, or if you explicitly specify a value for MaxResults that is less than the number of metadata generation runs, the response includes a pagination token named NextToken. You can specify this NextToken value in a subsequent call to ListMetadataGenerationRuns to list the next set of revisions.
        public let nextToken: String?
        /// The status of the metadata generation runs.
        public let status: MetadataGenerationRunStatus?
        /// The type of the metadata generation runs.
        public let type: MetadataGenerationRunType?

        @inlinable
        public init(domainIdentifier: String, maxResults: Int? = nil, nextToken: String? = nil, status: MetadataGenerationRunStatus? = nil, type: MetadataGenerationRunType? = nil) {
            self.domainIdentifier = domainIdentifier
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.status = status
            self.type = type
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.domainIdentifier, key: "domainIdentifier")
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
            request.encodeQuery(self.status, key: "status")
            request.encodeQuery(self.type, key: "type")
        }

        public func validate(name: String) throws {
            try self.validate(self.domainIdentifier, name: "domainIdentifier", parent: name, pattern: "^dzd[-_][a-zA-Z0-9_-]{1,36}$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 50)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 8192)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListMetadataGenerationRunsOutput: AWSDecodableShape {
        /// The results of the ListMetadataGenerationRuns action.
        public let items: [MetadataGenerationRunItem]?
        /// When the number of metadata generation runs is greater than the default value for the MaxResults parameter, or if you explicitly specify a value for MaxResults that is less than the number of metadata generation runs, the response includes a pagination token named NextToken. You can specify this NextToken value in a subsequent call to ListMetadataGenerationRuns to list the next set of revisions.
        public let nextToken: String?

        @inlinable
        public init(items: [MetadataGenerationRunItem]? = nil, nextToken: String? = nil) {
            self.items = items
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case items = "items"
            case nextToken = "nextToken"
        }
    }

    public struct ListNotificationsInput: AWSEncodableShape {
        /// The time after which you want to list notifications.
        public let afterTimestamp: Date?
        /// The time before which you want to list notifications.
        public let beforeTimestamp: Date?
        /// The identifier of the Amazon DataZone domain.
        public let domainIdentifier: String
        /// The maximum number of notifications to return in a single call to ListNotifications. When the number of notifications to be listed is greater than the value of MaxResults, the response contains a NextToken value that you can use in a subsequent call to ListNotifications to list the next set of notifications.
        public let maxResults: Int?
        /// When the number of notifications is greater than the default value for the MaxResults parameter, or if you explicitly specify a value for MaxResults that is less than the number of notifications, the response includes a pagination token named NextToken. You can specify this NextToken value in a subsequent call to ListNotifications to list the next set of notifications.
        public let nextToken: String?
        /// The subjects of notifications.
        public let subjects: [String]?
        /// The task status of notifications.
        public let taskStatus: TaskStatus?
        /// The type of notifications.
        public let type: NotificationType

        @inlinable
        public init(afterTimestamp: Date? = nil, beforeTimestamp: Date? = nil, domainIdentifier: String, maxResults: Int? = nil, nextToken: String? = nil, subjects: [String]? = nil, taskStatus: TaskStatus? = nil, type: NotificationType) {
            self.afterTimestamp = afterTimestamp
            self.beforeTimestamp = beforeTimestamp
            self.domainIdentifier = domainIdentifier
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.subjects = subjects
            self.taskStatus = taskStatus
            self.type = type
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.afterTimestamp, key: "afterTimestamp")
            request.encodeQuery(self.beforeTimestamp, key: "beforeTimestamp")
            request.encodePath(self.domainIdentifier, key: "domainIdentifier")
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
            request.encodeQuery(self.subjects, key: "subjects")
            request.encodeQuery(self.taskStatus, key: "taskStatus")
            request.encodeQuery(self.type, key: "type")
        }

        public func validate(name: String) throws {
            try self.validate(self.domainIdentifier, name: "domainIdentifier", parent: name, pattern: "^dzd[-_][a-zA-Z0-9_-]{1,36}$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 50)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 8192)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListNotificationsOutput: AWSDecodableShape {
        /// When the number of notifications is greater than the default value for the MaxResults parameter, or if you explicitly specify a value for MaxResults that is less than the number of notifications, the response includes a pagination token named NextToken. You can specify this NextToken value in a subsequent call to ListNotifications to list the next set of notifications.
        public let nextToken: String?
        /// The results of the ListNotifications action.
        public let notifications: [NotificationOutput]?

        @inlinable
        public init(nextToken: String? = nil, notifications: [NotificationOutput]? = nil) {
            self.nextToken = nextToken
            self.notifications = notifications
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "nextToken"
            case notifications = "notifications"
        }
    }

    public struct ListPolicyGrantsInput: AWSEncodableShape {
        /// The ID of the domain where you want to list policy grants.
        public let domainIdentifier: String
        /// The ID of the entity for which you want to list policy grants.
        public let entityIdentifier: String
        /// The type of entity for which you want to list policy grants.
        public let entityType: TargetEntityType
        /// The maximum number of grants to return in a single call to ListPolicyGrants. When the number of grants to be listed is greater than the value of MaxResults, the response contains a NextToken value that you can use in a subsequent call to ListPolicyGrants to list the next set of grants.
        public let maxResults: Int?
        /// When the number of grants is greater than the default value for the MaxResults parameter, or if you explicitly specify a value for MaxResults that is less than the number of grants, the response includes a pagination token named NextToken. You can specify this NextToken value in a subsequent call to ListPolicyGrants to list the next set of grants.
        public let nextToken: String?
        /// The type of policy that you want to list.
        public let policyType: ManagedPolicyType

        @inlinable
        public init(domainIdentifier: String, entityIdentifier: String, entityType: TargetEntityType, maxResults: Int? = nil, nextToken: String? = nil, policyType: ManagedPolicyType) {
            self.domainIdentifier = domainIdentifier
            self.entityIdentifier = entityIdentifier
            self.entityType = entityType
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.policyType = policyType
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.domainIdentifier, key: "domainIdentifier")
            request.encodePath(self.entityIdentifier, key: "entityIdentifier")
            request.encodePath(self.entityType, key: "entityType")
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
            request.encodeQuery(self.policyType, key: "policyType")
        }

        public func validate(name: String) throws {
            try self.validate(self.domainIdentifier, name: "domainIdentifier", parent: name, pattern: "^dzd[-_][a-zA-Z0-9_-]{1,36}$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 25)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 8192)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListPolicyGrantsOutput: AWSDecodableShape {
        /// The results of this action - the listed grants.
        public let grantList: [PolicyGrantMember]
        /// When the number of grants is greater than the default value for the MaxResults parameter, or if you explicitly specify a value for MaxResults that is less than the number of grants, the response includes a pagination token named NextToken. You can specify this NextToken value in a subsequent call to ListPolicyGrants to list the next set of grants.
        public let nextToken: String?

        @inlinable
        public init(grantList: [PolicyGrantMember], nextToken: String? = nil) {
            self.grantList = grantList
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case grantList = "grantList"
            case nextToken = "nextToken"
        }
    }

    public struct ListProjectMembershipsInput: AWSEncodableShape {
        /// The identifier of the Amazon DataZone domain in which you want to list project memberships.
        public let domainIdentifier: String
        /// The maximum number of memberships to return in a single call to ListProjectMemberships. When the number of memberships to be listed is greater than the value of MaxResults, the response contains a NextToken value that you can use in a subsequent call to ListProjectMemberships to list the next set of memberships.
        public let maxResults: Int?
        /// When the number of memberships is greater than the default value for the MaxResults parameter, or if you explicitly specify a value for MaxResults that is less than the number of memberships, the response includes a pagination token named NextToken. You can specify this NextToken value in a subsequent call to ListProjectMemberships to list the next set of memberships.
        public let nextToken: String?
        /// The identifier of the project whose memberships you want to list.
        public let projectIdentifier: String
        /// The method by which you want to sort the project memberships.
        public let sortBy: SortFieldProject?
        /// The sort order of the project memberships.
        public let sortOrder: SortOrder?

        @inlinable
        public init(domainIdentifier: String, maxResults: Int? = nil, nextToken: String? = nil, projectIdentifier: String, sortBy: SortFieldProject? = nil, sortOrder: SortOrder? = nil) {
            self.domainIdentifier = domainIdentifier
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.projectIdentifier = projectIdentifier
            self.sortBy = sortBy
            self.sortOrder = sortOrder
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.domainIdentifier, key: "domainIdentifier")
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
            request.encodePath(self.projectIdentifier, key: "projectIdentifier")
            request.encodeQuery(self.sortBy, key: "sortBy")
            request.encodeQuery(self.sortOrder, key: "sortOrder")
        }

        public func validate(name: String) throws {
            try self.validate(self.domainIdentifier, name: "domainIdentifier", parent: name, pattern: "^dzd[-_][a-zA-Z0-9_-]{1,36}$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 50)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 8192)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.projectIdentifier, name: "projectIdentifier", parent: name, pattern: "^[a-zA-Z0-9_-]{1,36}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListProjectMembershipsOutput: AWSDecodableShape {
        /// The members of the project.
        public let members: [ProjectMember]
        /// When the number of memberships is greater than the default value for the MaxResults parameter, or if you explicitly specify a value for MaxResults that is less than the number of memberships, the response includes a pagination token named NextToken. You can specify this NextToken value in a subsequent call to ListProjectMemberships to list the next set of memberships.
        public let nextToken: String?

        @inlinable
        public init(members: [ProjectMember], nextToken: String? = nil) {
            self.members = members
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case members = "members"
            case nextToken = "nextToken"
        }
    }

    public struct ListProjectProfilesInput: AWSEncodableShape {
        /// The ID of the domain where you want to list project profiles.
        public let domainIdentifier: String
        /// The maximum number of project profiles to return in a single call to ListProjectProfiles. When the number of project profiles to be listed is greater than the value of MaxResults, the response contains a NextToken value that you can use in a subsequent call to ListProjectProfiles to list the next set of project profiles.
        public let maxResults: Int?
        /// The name of a project profile.
        public let name: String?
        /// When the number of project profiles is greater than the default value for the MaxResults parameter, or if you explicitly specify a value for MaxResults that is less than the number of project profiles, the response includes a pagination token named NextToken. You can specify this NextToken value in a subsequent call to ListProjectProfiles to list the next set of project profiles.
        public let nextToken: String?
        /// Specifies by what to sort project profiles.
        public let sortBy: SortFieldProject?
        /// Specifies the sort order of the project profiles.
        public let sortOrder: SortOrder?

        @inlinable
        public init(domainIdentifier: String, maxResults: Int? = nil, name: String? = nil, nextToken: String? = nil, sortBy: SortFieldProject? = nil, sortOrder: SortOrder? = nil) {
            self.domainIdentifier = domainIdentifier
            self.maxResults = maxResults
            self.name = name
            self.nextToken = nextToken
            self.sortBy = sortBy
            self.sortOrder = sortOrder
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.domainIdentifier, key: "domainIdentifier")
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.name, key: "name")
            request.encodeQuery(self.nextToken, key: "nextToken")
            request.encodeQuery(self.sortBy, key: "sortBy")
            request.encodeQuery(self.sortOrder, key: "sortOrder")
        }

        public func validate(name: String) throws {
            try self.validate(self.domainIdentifier, name: "domainIdentifier", parent: name, pattern: "^dzd[-_][a-zA-Z0-9_-]{1,36}$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 50)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, max: 64)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[\\w -]+$")
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 8192)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListProjectProfilesOutput: AWSDecodableShape {
        /// The results of the ListProjectProfiles action.
        public let items: [ProjectProfileSummary]?
        /// When the number of project profiles is greater than the default value for the MaxResults parameter, or if you explicitly specify a value for MaxResults that is less than the number of project profiles, the response includes a pagination token named NextToken. You can specify this NextToken value in a subsequent call to ListProjectProfiles to list the next set of project profiles.
        public let nextToken: String?

        @inlinable
        public init(items: [ProjectProfileSummary]? = nil, nextToken: String? = nil) {
            self.items = items
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case items = "items"
            case nextToken = "nextToken"
        }
    }

    public struct ListProjectsInput: AWSEncodableShape {
        /// The identifier of the Amazon DataZone domain.
        public let domainIdentifier: String
        /// The identifier of a group.
        public let groupIdentifier: String?
        /// The maximum number of projects to return in a single call to ListProjects. When the number of projects to be listed is greater than the value of MaxResults, the response contains a NextToken value that you can use in a subsequent call to ListProjects to list the next set of projects.
        public let maxResults: Int?
        /// The name of the project.
        public let name: String?
        /// When the number of projects is greater than the default value for the MaxResults parameter, or if you explicitly specify a value for MaxResults that is less than the number of projects, the response includes a pagination token named NextToken. You can specify this NextToken value in a subsequent call to ListProjects to list the next set of projects.
        public let nextToken: String?
        /// The identifier of the Amazon DataZone user.
        public let userIdentifier: String?

        @inlinable
        public init(domainIdentifier: String, groupIdentifier: String? = nil, maxResults: Int? = nil, name: String? = nil, nextToken: String? = nil, userIdentifier: String? = nil) {
            self.domainIdentifier = domainIdentifier
            self.groupIdentifier = groupIdentifier
            self.maxResults = maxResults
            self.name = name
            self.nextToken = nextToken
            self.userIdentifier = userIdentifier
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.domainIdentifier, key: "domainIdentifier")
            request.encodeQuery(self.groupIdentifier, key: "groupIdentifier")
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.name, key: "name")
            request.encodeQuery(self.nextToken, key: "nextToken")
            request.encodeQuery(self.userIdentifier, key: "userIdentifier")
        }

        public func validate(name: String) throws {
            try self.validate(self.domainIdentifier, name: "domainIdentifier", parent: name, pattern: "^dzd[-_][a-zA-Z0-9_-]{1,36}$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 50)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, max: 64)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[\\w -]+$")
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 8192)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListProjectsOutput: AWSDecodableShape {
        /// The results of the ListProjects action.
        public let items: [ProjectSummary]?
        /// When the number of projects is greater than the default value for the MaxResults parameter, or if you explicitly specify a value for MaxResults that is less than the number of projects, the response includes a pagination token named NextToken. You can specify this NextToken value in a subsequent call to ListProjects to list the next set of projects.
        public let nextToken: String?

        @inlinable
        public init(items: [ProjectSummary]? = nil, nextToken: String? = nil) {
            self.items = items
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case items = "items"
            case nextToken = "nextToken"
        }
    }

    public struct ListRulesInput: AWSEncodableShape {
        /// The action of the rule.
        public let action: RuleAction?
        /// The asset types of the rule.
        public let assetTypes: [String]?
        /// The data product of the rule.
        public let dataProduct: Bool?
        /// The ID of the domain in which the rules are to be listed.
        public let domainIdentifier: String
        /// Specifies whether to include cascading rules in the results.
        public let includeCascaded: Bool?
        /// The maximum number of rules to return in a single call to ListRules. When the number of rules to be listed is greater than the value of MaxResults, the response contains a NextToken value that you can use in a subsequent call to ListRules to list the next set of rules.
        public let maxResults: Int?
        /// When the number of rules is greater than the default value for the MaxResults parameter, or if you explicitly specify a value for MaxResults that is less than the number of rules, the response includes a pagination token named NextToken. You can specify this NextToken value in a subsequent call to ListRules to list the next set of rules.
        public let nextToken: String?
        /// The IDs of projects in which rules are to be listed.
        public let projectIds: [String]?
        /// The type of the rule.
        public let ruleType: RuleType?
        /// The target ID of the rule.
        public let targetIdentifier: String
        /// The target type of the rule.
        public let targetType: RuleTargetType

        @inlinable
        public init(action: RuleAction? = nil, assetTypes: [String]? = nil, dataProduct: Bool? = nil, domainIdentifier: String, includeCascaded: Bool? = nil, maxResults: Int? = nil, nextToken: String? = nil, projectIds: [String]? = nil, ruleType: RuleType? = nil, targetIdentifier: String, targetType: RuleTargetType) {
            self.action = action
            self.assetTypes = assetTypes
            self.dataProduct = dataProduct
            self.domainIdentifier = domainIdentifier
            self.includeCascaded = includeCascaded
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.projectIds = projectIds
            self.ruleType = ruleType
            self.targetIdentifier = targetIdentifier
            self.targetType = targetType
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.action, key: "ruleAction")
            request.encodeQuery(self.assetTypes, key: "assetTypes")
            request.encodeQuery(self.dataProduct, key: "dataProduct")
            request.encodePath(self.domainIdentifier, key: "domainIdentifier")
            request.encodeQuery(self.includeCascaded, key: "includeCascaded")
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
            request.encodeQuery(self.projectIds, key: "projectIds")
            request.encodeQuery(self.ruleType, key: "ruleType")
            request.encodePath(self.targetIdentifier, key: "targetIdentifier")
            request.encodePath(self.targetType, key: "targetType")
        }

        public func validate(name: String) throws {
            try self.assetTypes?.forEach {
                try validate($0, name: "assetTypes[]", parent: name, max: 513)
                try validate($0, name: "assetTypes[]", parent: name, min: 1)
                try validate($0, name: "assetTypes[]", parent: name, pattern: "^(?!\\.)[\\w\\.]*\\w$")
            }
            try self.validate(self.domainIdentifier, name: "domainIdentifier", parent: name, pattern: "^dzd[-_][a-zA-Z0-9_-]{1,36}$")
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 8192)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.projectIds?.forEach {
                try validate($0, name: "projectIds[]", parent: name, pattern: "^[a-zA-Z0-9_-]{1,36}$")
            }
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListRulesOutput: AWSDecodableShape {
        /// The results of the ListRules action.
        public let items: [RuleSummary]
        /// When the number of rules is greater than the default value for the MaxResults parameter, or if you explicitly specify a value for MaxResults that is less than the number of rules, the response includes a pagination token named NextToken. You can specify this NextToken value in a subsequent call to ListRules to list the next set of rules.
        public let nextToken: String?

        @inlinable
        public init(items: [RuleSummary], nextToken: String? = nil) {
            self.items = items
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case items = "items"
            case nextToken = "nextToken"
        }
    }

    public struct ListSubscriptionGrantsInput: AWSEncodableShape {
        /// The identifier of the Amazon DataZone domain.
        public let domainIdentifier: String
        /// The identifier of the Amazon DataZone environment.
        public let environmentId: String?
        /// The maximum number of subscription grants to return in a single call to ListSubscriptionGrants. When the number of subscription grants to be listed is greater than the value of MaxResults, the response contains a NextToken value that you can use in a subsequent call to ListSubscriptionGrants to list the next set of subscription grants.
        public let maxResults: Int?
        /// When the number of subscription grants is greater than the default value for the MaxResults parameter, or if you explicitly specify a value for MaxResults that is less than the number of subscription grants, the response includes a pagination token named NextToken. You can specify this NextToken value in a subsequent call to ListSubscriptionGrants to list the next set of subscription grants.
        public let nextToken: String?
        /// The ID of the owning project of the subscription grants.
        public let owningProjectId: String?
        /// Specifies the way of sorting the results of this action.
        public let sortBy: SortKey?
        /// Specifies the sort order of this action.
        public let sortOrder: SortOrder?
        /// The identifier of the subscribed listing.
        public let subscribedListingId: String?
        /// The identifier of the subscription.
        public let subscriptionId: String?
        /// The identifier of the subscription target.
        public let subscriptionTargetId: String?

        @inlinable
        public init(domainIdentifier: String, environmentId: String? = nil, maxResults: Int? = nil, nextToken: String? = nil, owningProjectId: String? = nil, sortBy: SortKey? = nil, sortOrder: SortOrder? = nil, subscribedListingId: String? = nil, subscriptionId: String? = nil, subscriptionTargetId: String? = nil) {
            self.domainIdentifier = domainIdentifier
            self.environmentId = environmentId
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.owningProjectId = owningProjectId
            self.sortBy = sortBy
            self.sortOrder = sortOrder
            self.subscribedListingId = subscribedListingId
            self.subscriptionId = subscriptionId
            self.subscriptionTargetId = subscriptionTargetId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.domainIdentifier, key: "domainIdentifier")
            request.encodeQuery(self.environmentId, key: "environmentId")
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
            request.encodeQuery(self.owningProjectId, key: "owningProjectId")
            request.encodeQuery(self.sortBy, key: "sortBy")
            request.encodeQuery(self.sortOrder, key: "sortOrder")
            request.encodeQuery(self.subscribedListingId, key: "subscribedListingId")
            request.encodeQuery(self.subscriptionId, key: "subscriptionId")
            request.encodeQuery(self.subscriptionTargetId, key: "subscriptionTargetId")
        }

        public func validate(name: String) throws {
            try self.validate(self.domainIdentifier, name: "domainIdentifier", parent: name, pattern: "^dzd[-_][a-zA-Z0-9_-]{1,36}$")
            try self.validate(self.environmentId, name: "environmentId", parent: name, pattern: "^[a-zA-Z0-9_-]{1,36}$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 50)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 8192)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.owningProjectId, name: "owningProjectId", parent: name, pattern: "^[a-zA-Z0-9_-]{1,36}$")
            try self.validate(self.subscribedListingId, name: "subscribedListingId", parent: name, pattern: "^[a-zA-Z0-9_-]{1,36}$")
            try self.validate(self.subscriptionId, name: "subscriptionId", parent: name, pattern: "^[a-zA-Z0-9_-]{1,36}$")
            try self.validate(self.subscriptionTargetId, name: "subscriptionTargetId", parent: name, pattern: "^[a-zA-Z0-9_-]{1,36}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListSubscriptionGrantsOutput: AWSDecodableShape {
        /// The results of the ListSubscriptionGrants action.
        public let items: [SubscriptionGrantSummary]
        /// When the number of subscription grants is greater than the default value for the MaxResults parameter, or if you explicitly specify a value for MaxResults that is less than the number of subscription grants, the response includes a pagination token named NextToken. You can specify this NextToken value in a subsequent call to ListSubscriptionGrants to list the next set of subscription grants.
        public let nextToken: String?

        @inlinable
        public init(items: [SubscriptionGrantSummary], nextToken: String? = nil) {
            self.items = items
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case items = "items"
            case nextToken = "nextToken"
        }
    }

    public struct ListSubscriptionRequestsInput: AWSEncodableShape {
        /// The identifier of the subscription request approver's project.
        public let approverProjectId: String?
        /// The identifier of the Amazon DataZone domain.
        public let domainIdentifier: String
        /// The maximum number of subscription requests to return in a single call to ListSubscriptionRequests. When the number of subscription requests to be listed is greater than the value of MaxResults, the response contains a NextToken value that you can use in a subsequent call to ListSubscriptionRequests to list the next set of subscription requests.
        public let maxResults: Int?
        /// When the number of subscription requests is greater than the default value for the MaxResults parameter, or if you explicitly specify a value for MaxResults that is less than the number of subscription requests, the response includes a pagination token named NextToken. You can specify this NextToken value in a subsequent call to ListSubscriptionRequests to list the next set of subscription requests.
        public let nextToken: String?
        /// The identifier of the project for the subscription requests.
        public let owningProjectId: String?
        /// Specifies the way to sort the results of this action.
        public let sortBy: SortKey?
        /// Specifies the sort order for the results of this action.
        public let sortOrder: SortOrder?
        /// Specifies the status of the subscription requests.  This is not a required parameter, but if not specified, by default, Amazon DataZone returns only PENDING subscription requests.
        public let status: SubscriptionRequestStatus?
        /// The identifier of the subscribed listing.
        public let subscribedListingId: String?

        @inlinable
        public init(approverProjectId: String? = nil, domainIdentifier: String, maxResults: Int? = nil, nextToken: String? = nil, owningProjectId: String? = nil, sortBy: SortKey? = nil, sortOrder: SortOrder? = nil, status: SubscriptionRequestStatus? = nil, subscribedListingId: String? = nil) {
            self.approverProjectId = approverProjectId
            self.domainIdentifier = domainIdentifier
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.owningProjectId = owningProjectId
            self.sortBy = sortBy
            self.sortOrder = sortOrder
            self.status = status
            self.subscribedListingId = subscribedListingId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.approverProjectId, key: "approverProjectId")
            request.encodePath(self.domainIdentifier, key: "domainIdentifier")
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
            request.encodeQuery(self.owningProjectId, key: "owningProjectId")
            request.encodeQuery(self.sortBy, key: "sortBy")
            request.encodeQuery(self.sortOrder, key: "sortOrder")
            request.encodeQuery(self.status, key: "status")
            request.encodeQuery(self.subscribedListingId, key: "subscribedListingId")
        }

        public func validate(name: String) throws {
            try self.validate(self.approverProjectId, name: "approverProjectId", parent: name, pattern: "^[a-zA-Z0-9_-]{1,36}$")
            try self.validate(self.domainIdentifier, name: "domainIdentifier", parent: name, pattern: "^dzd[-_][a-zA-Z0-9_-]{1,36}$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 50)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 8192)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.owningProjectId, name: "owningProjectId", parent: name, pattern: "^[a-zA-Z0-9_-]{1,36}$")
            try self.validate(self.subscribedListingId, name: "subscribedListingId", parent: name, pattern: "^[a-zA-Z0-9_-]{1,36}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListSubscriptionRequestsOutput: AWSDecodableShape {
        /// The results of the ListSubscriptionRequests action.
        public let items: [SubscriptionRequestSummary]
        /// When the number of subscription requests is greater than the default value for the MaxResults parameter, or if you explicitly specify a value for MaxResults that is less than the number of subscription requests, the response includes a pagination token named NextToken. You can specify this NextToken value in a subsequent call to ListSubscriptionRequests to list the next set of subscription requests.
        public let nextToken: String?

        @inlinable
        public init(items: [SubscriptionRequestSummary], nextToken: String? = nil) {
            self.items = items
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case items = "items"
            case nextToken = "nextToken"
        }
    }

    public struct ListSubscriptionTargetsInput: AWSEncodableShape {
        /// The identifier of the Amazon DataZone domain where you want to list subscription targets.
        public let domainIdentifier: String
        /// The identifier of the environment where you want to list subscription targets.
        public let environmentIdentifier: String
        /// The maximum number of subscription targets to return in a single call to ListSubscriptionTargets. When the number of subscription targets to be listed is greater than the value of MaxResults, the response contains a NextToken value that you can use in a subsequent call to ListSubscriptionTargets to list the next set of subscription targets.
        public let maxResults: Int?
        /// When the number of subscription targets is greater than the default value for the MaxResults parameter, or if you explicitly specify a value for MaxResults that is less than the number of subscription targets, the response includes a pagination token named NextToken. You can specify this NextToken value in a subsequent call to ListSubscriptionTargets to list the next set of subscription targets.
        public let nextToken: String?
        /// Specifies the way in which the results of this action are to be sorted.
        public let sortBy: SortKey?
        /// Specifies the sort order for the results of this action.
        public let sortOrder: SortOrder?

        @inlinable
        public init(domainIdentifier: String, environmentIdentifier: String, maxResults: Int? = nil, nextToken: String? = nil, sortBy: SortKey? = nil, sortOrder: SortOrder? = nil) {
            self.domainIdentifier = domainIdentifier
            self.environmentIdentifier = environmentIdentifier
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.sortBy = sortBy
            self.sortOrder = sortOrder
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.domainIdentifier, key: "domainIdentifier")
            request.encodePath(self.environmentIdentifier, key: "environmentIdentifier")
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
            request.encodeQuery(self.sortBy, key: "sortBy")
            request.encodeQuery(self.sortOrder, key: "sortOrder")
        }

        public func validate(name: String) throws {
            try self.validate(self.domainIdentifier, name: "domainIdentifier", parent: name, pattern: "^dzd[-_][a-zA-Z0-9_-]{1,36}$")
            try self.validate(self.environmentIdentifier, name: "environmentIdentifier", parent: name, pattern: "^[a-zA-Z0-9_-]{1,36}$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 50)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 8192)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListSubscriptionTargetsOutput: AWSDecodableShape {
        /// The results of the ListSubscriptionTargets action.
        public let items: [SubscriptionTargetSummary]
        /// When the number of subscription targets is greater than the default value for the MaxResults parameter, or if you explicitly specify a value for MaxResults that is less than the number of subscription targets, the response includes a pagination token named NextToken. You can specify this NextToken value in a subsequent call to ListSubscriptionTargets to list the next set of subscription targets.
        public let nextToken: String?

        @inlinable
        public init(items: [SubscriptionTargetSummary], nextToken: String? = nil) {
            self.items = items
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case items = "items"
            case nextToken = "nextToken"
        }
    }

    public struct ListSubscriptionsInput: AWSEncodableShape {
        /// The identifier of the project for the subscription's approver.
        public let approverProjectId: String?
        /// The identifier of the Amazon DataZone domain.
        public let domainIdentifier: String
        /// The maximum number of subscriptions to return in a single call to ListSubscriptions. When the number of subscriptions to be listed is greater than the value of MaxResults, the response contains a NextToken value that you can use in a subsequent call to ListSubscriptions to list the next set of Subscriptions.
        public let maxResults: Int?
        /// When the number of subscriptions is greater than the default value for the MaxResults parameter, or if you explicitly specify a value for MaxResults that is less than the number of subscriptions, the response includes a pagination token named NextToken. You can specify this NextToken value in a subsequent call to ListSubscriptions to list the next set of subscriptions.
        public let nextToken: String?
        /// The identifier of the owning project.
        public let owningProjectId: String?
        /// Specifies the way in which the results of this action are to be sorted.
        public let sortBy: SortKey?
        /// Specifies the sort order for the results of this action.
        public let sortOrder: SortOrder?
        /// The status of the subscriptions that you want to list.  This is not a required parameter, but if not provided, by default, Amazon DataZone returns only APPROVED subscriptions.
        public let status: SubscriptionStatus?
        /// The identifier of the subscribed listing for the subscriptions that you want to list.
        public let subscribedListingId: String?
        /// The identifier of the subscription request for the subscriptions that you want to list.
        public let subscriptionRequestIdentifier: String?

        @inlinable
        public init(approverProjectId: String? = nil, domainIdentifier: String, maxResults: Int? = nil, nextToken: String? = nil, owningProjectId: String? = nil, sortBy: SortKey? = nil, sortOrder: SortOrder? = nil, status: SubscriptionStatus? = nil, subscribedListingId: String? = nil, subscriptionRequestIdentifier: String? = nil) {
            self.approverProjectId = approverProjectId
            self.domainIdentifier = domainIdentifier
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.owningProjectId = owningProjectId
            self.sortBy = sortBy
            self.sortOrder = sortOrder
            self.status = status
            self.subscribedListingId = subscribedListingId
            self.subscriptionRequestIdentifier = subscriptionRequestIdentifier
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.approverProjectId, key: "approverProjectId")
            request.encodePath(self.domainIdentifier, key: "domainIdentifier")
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
            request.encodeQuery(self.owningProjectId, key: "owningProjectId")
            request.encodeQuery(self.sortBy, key: "sortBy")
            request.encodeQuery(self.sortOrder, key: "sortOrder")
            request.encodeQuery(self.status, key: "status")
            request.encodeQuery(self.subscribedListingId, key: "subscribedListingId")
            request.encodeQuery(self.subscriptionRequestIdentifier, key: "subscriptionRequestIdentifier")
        }

        public func validate(name: String) throws {
            try self.validate(self.approverProjectId, name: "approverProjectId", parent: name, pattern: "^[a-zA-Z0-9_-]{1,36}$")
            try self.validate(self.domainIdentifier, name: "domainIdentifier", parent: name, pattern: "^dzd[-_][a-zA-Z0-9_-]{1,36}$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 50)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 8192)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.owningProjectId, name: "owningProjectId", parent: name, pattern: "^[a-zA-Z0-9_-]{1,36}$")
            try self.validate(self.subscribedListingId, name: "subscribedListingId", parent: name, pattern: "^[a-zA-Z0-9_-]{1,36}$")
            try self.validate(self.subscriptionRequestIdentifier, name: "subscriptionRequestIdentifier", parent: name, pattern: "^[a-zA-Z0-9_-]{1,36}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListSubscriptionsOutput: AWSDecodableShape {
        /// The results of the ListSubscriptions action.
        public let items: [SubscriptionSummary]
        /// When the number of subscriptions is greater than the default value for the MaxResults parameter, or if you explicitly specify a value for MaxResults that is less than the number of subscriptions, the response includes a pagination token named NextToken. You can specify this NextToken value in a subsequent call to ListSubscriptions to list the next set of subscriptions.
        public let nextToken: String?

        @inlinable
        public init(items: [SubscriptionSummary], nextToken: String? = nil) {
            self.items = items
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case items = "items"
            case nextToken = "nextToken"
        }
    }

    public struct ListTagsForResourceRequest: AWSEncodableShape {
        /// The ARN of the resource whose tags you want to list.
        public let resourceArn: String

        @inlinable
        public init(resourceArn: String) {
            self.resourceArn = resourceArn
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.resourceArn, key: "resourceArn")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListTagsForResourceResponse: AWSDecodableShape {
        /// The tags of the specified resource.
        public let tags: [String: String]?

        @inlinable
        public init(tags: [String: String]? = nil) {
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case tags = "tags"
        }
    }

    public struct ListTimeSeriesDataPointsInput: AWSEncodableShape {
        /// The ID of the Amazon DataZone domain that houses the assets for which you want to list time series data points.
        public let domainIdentifier: String
        /// The timestamp at which the data points that you wanted to list ended.
        public let endedAt: Date?
        /// The ID of the asset for which you want to list data points.
        public let entityIdentifier: String
        /// The type of the asset for which you want to list data points.
        public let entityType: TimeSeriesEntityType
        /// The name of the time series data points form.
        public let formName: String
        /// The maximum number of data points to return in a single call to ListTimeSeriesDataPoints. When the number of data points to be listed is greater than the value of MaxResults, the response contains a NextToken value that you can use in a subsequent call to ListTimeSeriesDataPoints to list the next set of data points.
        public let maxResults: Int?
        /// When the number of data points is greater than the default value for the MaxResults parameter, or if you explicitly specify a value for MaxResults that is less than the number of data points, the response includes a pagination token named NextToken. You can specify this NextToken value in a subsequent call to ListTimeSeriesDataPoints to list the next set of data points.
        public let nextToken: String?
        /// The timestamp at which the data points that you want to list started.
        public let startedAt: Date?

        @inlinable
        public init(domainIdentifier: String, endedAt: Date? = nil, entityIdentifier: String, entityType: TimeSeriesEntityType, formName: String, maxResults: Int? = nil, nextToken: String? = nil, startedAt: Date? = nil) {
            self.domainIdentifier = domainIdentifier
            self.endedAt = endedAt
            self.entityIdentifier = entityIdentifier
            self.entityType = entityType
            self.formName = formName
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.startedAt = startedAt
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.domainIdentifier, key: "domainIdentifier")
            request.encodeQuery(self.endedAt, key: "endedAt")
            request.encodePath(self.entityIdentifier, key: "entityIdentifier")
            request.encodePath(self.entityType, key: "entityType")
            request.encodeQuery(self.formName, key: "formName")
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
            request.encodeQuery(self.startedAt, key: "startedAt")
        }

        public func validate(name: String) throws {
            try self.validate(self.domainIdentifier, name: "domainIdentifier", parent: name, pattern: "^dzd[-_][a-zA-Z0-9_-]{1,36}$")
            try self.validate(self.entityIdentifier, name: "entityIdentifier", parent: name, pattern: "^[a-zA-Z0-9_-]{1,36}$")
            try self.validate(self.formName, name: "formName", parent: name, max: 128)
            try self.validate(self.formName, name: "formName", parent: name, min: 1)
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 50)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 8192)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListTimeSeriesDataPointsOutput: AWSDecodableShape {
        /// The results of the ListTimeSeriesDataPoints action.
        public let items: [TimeSeriesDataPointSummaryFormOutput]?
        /// When the number of data points is greater than the default value for the MaxResults parameter, or if you explicitly specify a value for MaxResults that is less than the number of data points, the response includes a pagination token named NextToken. You can specify this NextToken value in a subsequent call to ListTimeSeriesDataPoints to list the next set of data points.
        public let nextToken: String?

        @inlinable
        public init(items: [TimeSeriesDataPointSummaryFormOutput]? = nil, nextToken: String? = nil) {
            self.items = items
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case items = "items"
            case nextToken = "nextToken"
        }
    }

    public struct ListingRevision: AWSDecodableShape {
        /// An identifier of a revision of an asset published in a Amazon DataZone catalog.
        public let id: String
        /// The details of a revision of an asset published in a Amazon DataZone catalog.
        public let revision: String

        @inlinable
        public init(id: String, revision: String) {
            self.id = id
            self.revision = revision
        }

        private enum CodingKeys: String, CodingKey {
            case id = "id"
            case revision = "revision"
        }
    }

    public struct ListingRevisionInput: AWSEncodableShape {
        /// An identifier of revision to be made to an asset published in a Amazon DataZone catalog.
        public let identifier: String
        /// The details of a revision to be made to an asset published in a Amazon DataZone catalog.
        public let revision: String

        @inlinable
        public init(identifier: String, revision: String) {
            self.identifier = identifier
            self.revision = revision
        }

        public func validate(name: String) throws {
            try self.validate(self.identifier, name: "identifier", parent: name, pattern: "^[a-zA-Z0-9_-]{1,36}$")
            try self.validate(self.revision, name: "revision", parent: name, max: 64)
            try self.validate(self.revision, name: "revision", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case identifier = "identifier"
            case revision = "revision"
        }
    }

    public struct ListingSummary: AWSDecodableShape {
        /// The glossary terms of the data product.
        public let glossaryTerms: [DetailedGlossaryTerm]?
        /// The ID of the data product listing.
        public let listingId: String?
        /// The revision of the data product listing.
        public let listingRevision: String?

        @inlinable
        public init(glossaryTerms: [DetailedGlossaryTerm]? = nil, listingId: String? = nil, listingRevision: String? = nil) {
            self.glossaryTerms = glossaryTerms
            self.listingId = listingId
            self.listingRevision = listingRevision
        }

        private enum CodingKeys: String, CodingKey {
            case glossaryTerms = "glossaryTerms"
            case listingId = "listingId"
            case listingRevision = "listingRevision"
        }
    }

    public struct ListingSummaryItem: AWSDecodableShape {
        /// The glossary terms of the data product listing.
        public let glossaryTerms: [DetailedGlossaryTerm]?
        /// The ID of the data product listing.
        public let listingId: String?
        /// The revision of the data product listing.
        public let listingRevision: String?

        @inlinable
        public init(glossaryTerms: [DetailedGlossaryTerm]? = nil, listingId: String? = nil, listingRevision: String? = nil) {
            self.glossaryTerms = glossaryTerms
            self.listingId = listingId
            self.listingRevision = listingRevision
        }

        private enum CodingKeys: String, CodingKey {
            case glossaryTerms = "glossaryTerms"
            case listingId = "listingId"
            case listingRevision = "listingRevision"
        }
    }

    public struct MetadataFormEnforcementDetail: AWSEncodableShape & AWSDecodableShape {
        /// The required metadata forms.
        public let requiredMetadataForms: [MetadataFormReference]?

        @inlinable
        public init(requiredMetadataForms: [MetadataFormReference]? = nil) {
            self.requiredMetadataForms = requiredMetadataForms
        }

        public func validate(name: String) throws {
            try self.requiredMetadataForms?.forEach {
                try $0.validate(name: "\(name).requiredMetadataForms[]")
            }
            try self.validate(self.requiredMetadataForms, name: "requiredMetadataForms", parent: name, max: 5)
            try self.validate(self.requiredMetadataForms, name: "requiredMetadataForms", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case requiredMetadataForms = "requiredMetadataForms"
        }
    }

    public struct MetadataFormReference: AWSEncodableShape & AWSDecodableShape {
        /// The type ID of the metadata form reference.
        public let typeIdentifier: String
        /// The type revision of the metadata form reference.
        public let typeRevision: String

        @inlinable
        public init(typeIdentifier: String, typeRevision: String) {
            self.typeIdentifier = typeIdentifier
            self.typeRevision = typeRevision
        }

        public func validate(name: String) throws {
            try self.validate(self.typeIdentifier, name: "typeIdentifier", parent: name, max: 385)
            try self.validate(self.typeIdentifier, name: "typeIdentifier", parent: name, min: 1)
            try self.validate(self.typeIdentifier, name: "typeIdentifier", parent: name, pattern: "^(?!\\.)[\\w\\.]*\\w$")
            try self.validate(self.typeRevision, name: "typeRevision", parent: name, max: 64)
            try self.validate(self.typeRevision, name: "typeRevision", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case typeIdentifier = "typeIdentifier"
            case typeRevision = "typeRevision"
        }
    }

    public struct MetadataFormSummary: AWSDecodableShape {
        /// The form name of the metadata form.
        public let formName: String?
        /// The type name of the metadata form.
        public let typeName: String
        /// The type revision of the metadata form.
        public let typeRevision: String

        @inlinable
        public init(formName: String? = nil, typeName: String, typeRevision: String) {
            self.formName = formName
            self.typeName = typeName
            self.typeRevision = typeRevision
        }

        private enum CodingKeys: String, CodingKey {
            case formName = "formName"
            case typeName = "typeName"
            case typeRevision = "typeRevision"
        }
    }

    public struct MetadataGenerationRunItem: AWSDecodableShape {
        /// The timestamp at which the metadata generation run was created.
        public let createdAt: Date?
        /// The user who created the metadata generation run.
        public let createdBy: String?
        /// The ID of the Amazon DataZone domain in which the metadata generation run was created.
        public let domainId: String
        /// The ID of the metadata generation run.
        public let id: String
        /// The ID of the project that owns the asset for which the metadata generation was ran.
        public let owningProjectId: String
        /// The status of the metadata generation run.
        public let status: MetadataGenerationRunStatus?
        /// The asset for which metadata was generated.
        public let target: MetadataGenerationRunTarget?
        /// The type of the metadata generation run.
        public let type: MetadataGenerationRunType?

        @inlinable
        public init(createdAt: Date? = nil, createdBy: String? = nil, domainId: String, id: String, owningProjectId: String, status: MetadataGenerationRunStatus? = nil, target: MetadataGenerationRunTarget? = nil, type: MetadataGenerationRunType? = nil) {
            self.createdAt = createdAt
            self.createdBy = createdBy
            self.domainId = domainId
            self.id = id
            self.owningProjectId = owningProjectId
            self.status = status
            self.target = target
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case createdAt = "createdAt"
            case createdBy = "createdBy"
            case domainId = "domainId"
            case id = "id"
            case owningProjectId = "owningProjectId"
            case status = "status"
            case target = "target"
            case type = "type"
        }
    }

    public struct MetadataGenerationRunTarget: AWSEncodableShape & AWSDecodableShape {
        /// The ID of the metadata generation run's target.
        public let identifier: String
        /// The revision of the asset for which metadata was generated.
        public let revision: String?
        /// The type of the asset for which metadata was generated.
        public let type: MetadataGenerationTargetType

        @inlinable
        public init(identifier: String, revision: String? = nil, type: MetadataGenerationTargetType) {
            self.identifier = identifier
            self.revision = revision
            self.type = type
        }

        public func validate(name: String) throws {
            try self.validate(self.revision, name: "revision", parent: name, max: 64)
            try self.validate(self.revision, name: "revision", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case identifier = "identifier"
            case revision = "revision"
            case type = "type"
        }
    }

    public struct NameIdentifier: AWSDecodableShape {
        /// The name in the name identifier.
        public let name: String?
        /// The namespace in the name identifier.
        public let namespace: String?

        @inlinable
        public init(name: String? = nil, namespace: String? = nil) {
            self.name = name
            self.namespace = namespace
        }

        private enum CodingKeys: String, CodingKey {
            case name = "name"
            case namespace = "namespace"
        }
    }

    public struct NotEqualToExpression: AWSEncodableShape & AWSDecodableShape {
        /// The name of the column.
        public let columnName: String
        /// The value that might not be equal to the expression.
        public let value: String

        @inlinable
        public init(columnName: String, value: String) {
            self.columnName = columnName
            self.value = value
        }

        private enum CodingKeys: String, CodingKey {
            case columnName = "columnName"
            case value = "value"
        }
    }

    public struct NotInExpression: AWSEncodableShape & AWSDecodableShape {
        /// The name of the column.
        public let columnName: String
        /// The value that might not be in the expression.
        public let values: [String]

        @inlinable
        public init(columnName: String, values: [String]) {
            self.columnName = columnName
            self.values = values
        }

        private enum CodingKeys: String, CodingKey {
            case columnName = "columnName"
            case values = "values"
        }
    }

    public struct NotLikeExpression: AWSEncodableShape & AWSDecodableShape {
        /// The name of the column.
        public let columnName: String
        /// The value that might not be like the expression.
        public let value: String

        @inlinable
        public init(columnName: String, value: String) {
            self.columnName = columnName
            self.value = value
        }

        private enum CodingKeys: String, CodingKey {
            case columnName = "columnName"
            case value = "value"
        }
    }

    public struct NotificationOutput: AWSDecodableShape {
        /// The action link included in the notification.
        public let actionLink: String
        /// The timestamp of when a notification was created.
        public let creationTimestamp: Date
        /// The identifier of a Amazon DataZone domain in which the notification exists.
        public let domainIdentifier: String
        /// The identifier of the notification.
        public let identifier: String
        /// The timestamp of when the notification was last updated.
        public let lastUpdatedTimestamp: Date
        /// The message included in the notification.
        public let message: String
        /// The metadata included in the notification.
        public let metadata: [String: String]?
        /// The status included in the notification.
        public let status: TaskStatus?
        /// The title of the notification.
        public let title: String
        /// The topic of the notification.
        public let topic: Topic
        /// The type of the notification.
        public let type: NotificationType

        @inlinable
        public init(actionLink: String, creationTimestamp: Date, domainIdentifier: String, identifier: String, lastUpdatedTimestamp: Date, message: String, metadata: [String: String]? = nil, status: TaskStatus? = nil, title: String, topic: Topic, type: NotificationType) {
            self.actionLink = actionLink
            self.creationTimestamp = creationTimestamp
            self.domainIdentifier = domainIdentifier
            self.identifier = identifier
            self.lastUpdatedTimestamp = lastUpdatedTimestamp
            self.message = message
            self.metadata = metadata
            self.status = status
            self.title = title
            self.topic = topic
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case actionLink = "actionLink"
            case creationTimestamp = "creationTimestamp"
            case domainIdentifier = "domainIdentifier"
            case identifier = "identifier"
            case lastUpdatedTimestamp = "lastUpdatedTimestamp"
            case message = "message"
            case metadata = "metadata"
            case status = "status"
            case title = "title"
            case topic = "topic"
            case type = "type"
        }
    }

    public struct NotificationResource: AWSDecodableShape {
        /// The ID of the resource mentioned in a notification.
        public let id: String
        /// The name of the resource mentioned in a notification.
        public let name: String?
        /// The type of the resource mentioned in a notification.
        public let type: NotificationResourceType

        @inlinable
        public init(id: String, name: String? = nil, type: NotificationResourceType) {
            self.id = id
            self.name = name
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case id = "id"
            case name = "name"
            case type = "type"
        }
    }

    public struct OAuth2ClientApplication: AWSEncodableShape & AWSDecodableShape {
        /// The Amazon Web Services managed client application reference in the OAuth2Client application.
        public let aWSManagedClientApplicationReference: String?
        /// The user managed client application client ID in the OAuth2Client application.
        public let userManagedClientApplicationClientId: String?

        @inlinable
        public init(aWSManagedClientApplicationReference: String? = nil, userManagedClientApplicationClientId: String? = nil) {
            self.aWSManagedClientApplicationReference = aWSManagedClientApplicationReference
            self.userManagedClientApplicationClientId = userManagedClientApplicationClientId
        }

        private enum CodingKeys: String, CodingKey {
            case aWSManagedClientApplicationReference = "aWSManagedClientApplicationReference"
            case userManagedClientApplicationClientId = "userManagedClientApplicationClientId"
        }
    }

    public struct OAuth2Properties: AWSEncodableShape & AWSDecodableShape {
        /// The authorization code properties of the OAuth2 properties.
        public let authorizationCodeProperties: AuthorizationCodeProperties?
        /// The OAuth2 client application of the OAuth2 properties.
        public let oAuth2ClientApplication: OAuth2ClientApplication?
        /// The OAuth2 credentials of the OAuth2 properties.
        public let oAuth2Credentials: GlueOAuth2Credentials?
        /// The OAuth2 grant type of the OAuth2 properties.
        public let oAuth2GrantType: OAuth2GrantType?
        /// The OAuth2 token URL of the OAuth2 properties.
        public let tokenUrl: String?
        /// The OAuth2 token URL parameter map of the OAuth2 properties.
        public let tokenUrlParametersMap: [String: String]?

        @inlinable
        public init(authorizationCodeProperties: AuthorizationCodeProperties? = nil, oAuth2ClientApplication: OAuth2ClientApplication? = nil, oAuth2Credentials: GlueOAuth2Credentials? = nil, oAuth2GrantType: OAuth2GrantType? = nil, tokenUrl: String? = nil, tokenUrlParametersMap: [String: String]? = nil) {
            self.authorizationCodeProperties = authorizationCodeProperties
            self.oAuth2ClientApplication = oAuth2ClientApplication
            self.oAuth2Credentials = oAuth2Credentials
            self.oAuth2GrantType = oAuth2GrantType
            self.tokenUrl = tokenUrl
            self.tokenUrlParametersMap = tokenUrlParametersMap
        }

        private enum CodingKeys: String, CodingKey {
            case authorizationCodeProperties = "authorizationCodeProperties"
            case oAuth2ClientApplication = "oAuth2ClientApplication"
            case oAuth2Credentials = "oAuth2Credentials"
            case oAuth2GrantType = "oAuth2GrantType"
            case tokenUrl = "tokenUrl"
            case tokenUrlParametersMap = "tokenUrlParametersMap"
        }
    }

    public struct OpenLineageRunEventSummary: AWSDecodableShape {
        /// The event type of the open lineage run event summary.
        public let eventType: OpenLineageRunState?
        /// The inputs of the open lineage run event summary.
        public let inputs: [NameIdentifier]?
        /// The job of the open lineage run event summary.
        public let job: NameIdentifier?
        /// The outputs of the open lineage run event summary.
        public let outputs: [NameIdentifier]?
        /// The runID of the open lineage run event summary.
        public let runId: String?

        @inlinable
        public init(eventType: OpenLineageRunState? = nil, inputs: [NameIdentifier]? = nil, job: NameIdentifier? = nil, outputs: [NameIdentifier]? = nil, runId: String? = nil) {
            self.eventType = eventType
            self.inputs = inputs
            self.job = job
            self.outputs = outputs
            self.runId = runId
        }

        private enum CodingKeys: String, CodingKey {
            case eventType = "eventType"
            case inputs = "inputs"
            case job = "job"
            case outputs = "outputs"
            case runId = "runId"
        }
    }

    public struct OverrideDomainUnitOwnersPolicyGrantDetail: AWSEncodableShape & AWSDecodableShape {
        /// Specifies whether the policy is inherited by child domain units.
        public let includeChildDomainUnits: Bool?

        @inlinable
        public init(includeChildDomainUnits: Bool? = nil) {
            self.includeChildDomainUnits = includeChildDomainUnits
        }

        private enum CodingKeys: String, CodingKey {
            case includeChildDomainUnits = "includeChildDomainUnits"
        }
    }

    public struct OverrideProjectOwnersPolicyGrantDetail: AWSEncodableShape & AWSDecodableShape {
        /// Specifies whether the policy is inherited by child domain units.
        public let includeChildDomainUnits: Bool?

        @inlinable
        public init(includeChildDomainUnits: Bool? = nil) {
            self.includeChildDomainUnits = includeChildDomainUnits
        }

        private enum CodingKeys: String, CodingKey {
            case includeChildDomainUnits = "includeChildDomainUnits"
        }
    }

    public struct OwnerGroupProperties: AWSEncodableShape {
        /// The ID of the domain unit owners group.
        public let groupIdentifier: String

        @inlinable
        public init(groupIdentifier: String) {
            self.groupIdentifier = groupIdentifier
        }

        public func validate(name: String) throws {
            try self.validate(self.groupIdentifier, name: "groupIdentifier", parent: name, pattern: "(^([0-9a-f]{10}-|)[A-Fa-f0-9]{8}-[A-Fa-f0-9]{4}-[A-Fa-f0-9]{4}-[A-Fa-f0-9]{4}-[A-Fa-f0-9]{12}$|[\\p{L}\\p{M}\\p{S}\\p{N}\\p{P}\\t\\n\\r  ]+)")
        }

        private enum CodingKeys: String, CodingKey {
            case groupIdentifier = "groupIdentifier"
        }
    }

    public struct OwnerGroupPropertiesOutput: AWSDecodableShape {
        /// The ID of the domain unit owners group.
        public let groupId: String?

        @inlinable
        public init(groupId: String? = nil) {
            self.groupId = groupId
        }

        private enum CodingKeys: String, CodingKey {
            case groupId = "groupId"
        }
    }

    public struct OwnerUserProperties: AWSEncodableShape {
        /// The ID of the owner user.
        public let userIdentifier: String

        @inlinable
        public init(userIdentifier: String) {
            self.userIdentifier = userIdentifier
        }

        public func validate(name: String) throws {
            try self.validate(self.userIdentifier, name: "userIdentifier", parent: name, pattern: "(^([0-9a-f]{10}-|)[A-Fa-f0-9]{8}-[A-Fa-f0-9]{4}-[A-Fa-f0-9]{4}-[A-Fa-f0-9]{4}-[A-Fa-f0-9]{12}$|^[a-zA-Z_0-9+=,.@-]+$|^arn:aws:iam::\\d{12}:.+$)")
        }

        private enum CodingKeys: String, CodingKey {
            case userIdentifier = "userIdentifier"
        }
    }

    public struct OwnerUserPropertiesOutput: AWSDecodableShape {
        /// The ID of the owner user.
        public let userId: String?

        @inlinable
        public init(userId: String? = nil) {
            self.userId = userId
        }

        private enum CodingKeys: String, CodingKey {
            case userId = "userId"
        }
    }

    public struct PhysicalConnectionRequirements: AWSEncodableShape & AWSDecodableShape {
        /// The availability zone of the physical connection requirements of a connection.
        public let availabilityZone: String?
        /// The group ID list of the physical connection requirements of a connection.
        public let securityGroupIdList: [String]?
        /// The subnet ID of the physical connection requirements of a connection.
        public let subnetId: String?
        /// The subnet ID list of the physical connection requirements of a connection.
        public let subnetIdList: [String]?

        @inlinable
        public init(availabilityZone: String? = nil, securityGroupIdList: [String]? = nil, subnetId: String? = nil, subnetIdList: [String]? = nil) {
            self.availabilityZone = availabilityZone
            self.securityGroupIdList = securityGroupIdList
            self.subnetId = subnetId
            self.subnetIdList = subnetIdList
        }

        public func validate(name: String) throws {
            try self.validate(self.securityGroupIdList, name: "securityGroupIdList", parent: name, max: 50)
            try self.validate(self.subnetId, name: "subnetId", parent: name, max: 32)
            try self.validate(self.subnetId, name: "subnetId", parent: name, pattern: "^subnet-[a-z0-9]+$")
            try self.subnetIdList?.forEach {
                try validate($0, name: "subnetIdList[]", parent: name, max: 32)
                try validate($0, name: "subnetIdList[]", parent: name, pattern: "^subnet-[a-z0-9]+$")
            }
            try self.validate(self.subnetIdList, name: "subnetIdList", parent: name, max: 50)
            try self.validate(self.subnetIdList, name: "subnetIdList", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case availabilityZone = "availabilityZone"
            case securityGroupIdList = "securityGroupIdList"
            case subnetId = "subnetId"
            case subnetIdList = "subnetIdList"
        }
    }

    public struct PhysicalEndpoint: AWSDecodableShape {
        /// The location of a connection.
        public let awsLocation: AwsLocation?
        /// The Amazon Web Services Glue connection.
        public let glueConnection: GlueConnection?
        /// The Amazon Web Services Glue connection name.
        public let glueConnectionName: String?
        /// The host in the physical endpoints of a connection.
        public let host: String?
        /// The port in the physical endpoints of a connection.
        public let port: Int?
        /// The protocol in the physical endpoints of a connection.
        public let `protocol`: `Protocol`?
        /// The stage in the physical endpoints of a connection.
        public let stage: String?

        @inlinable
        public init(awsLocation: AwsLocation? = nil, glueConnection: GlueConnection? = nil, glueConnectionName: String? = nil, host: String? = nil, port: Int? = nil, protocol: `Protocol`? = nil, stage: String? = nil) {
            self.awsLocation = awsLocation
            self.glueConnection = glueConnection
            self.glueConnectionName = glueConnectionName
            self.host = host
            self.port = port
            self.`protocol` = `protocol`
            self.stage = stage
        }

        private enum CodingKeys: String, CodingKey {
            case awsLocation = "awsLocation"
            case glueConnection = "glueConnection"
            case glueConnectionName = "glueConnectionName"
            case host = "host"
            case port = "port"
            case `protocol` = "protocol"
            case stage = "stage"
        }
    }

    public struct PolicyGrantMember: AWSDecodableShape {
        /// Specifies the timestamp at which policy grant member was created.
        public let createdAt: Date?
        /// Specifies the user who created the policy grant member.
        public let createdBy: String?
        /// The details of the policy grant member.
        public let detail: PolicyGrantDetail?
        /// The principal of the policy grant member.
        public let principal: PolicyGrantPrincipal?

        @inlinable
        public init(createdAt: Date? = nil, createdBy: String? = nil, detail: PolicyGrantDetail? = nil, principal: PolicyGrantPrincipal? = nil) {
            self.createdAt = createdAt
            self.createdBy = createdBy
            self.detail = detail
            self.principal = principal
        }

        private enum CodingKeys: String, CodingKey {
            case createdAt = "createdAt"
            case createdBy = "createdBy"
            case detail = "detail"
            case principal = "principal"
        }
    }

    public struct PostLineageEventInput: AWSEncodableShape {
        /// A unique, case-sensitive identifier that is provided to ensure the idempotency of the request.
        public let clientToken: String?
        /// The ID of the domain where you want to post a data lineage event.
        public let domainIdentifier: String
        /// The data lineage event that you want to post. Only open-lineage run event are supported as events.
        public let event: AWSHTTPBody

        @inlinable
        public init(clientToken: String? = PostLineageEventInput.idempotencyToken(), domainIdentifier: String, event: AWSHTTPBody) {
            self.clientToken = clientToken
            self.domainIdentifier = domainIdentifier
            self.event = event
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.singleValueContainer()
            request.encodeHeader(self.clientToken, key: "Client-Token")
            request.encodePath(self.domainIdentifier, key: "domainIdentifier")
            try container.encode(self.event)
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 128)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "^[\\x21-\\x7E]+$")
            try self.validate(self.domainIdentifier, name: "domainIdentifier", parent: name, pattern: "^dzd[-_][a-zA-Z0-9_-]{1,36}$")
            try self.validate(self.event, name: "event", parent: name, max: 300000)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct PostLineageEventOutput: AWSDecodableShape {
        /// The ID of the domain.
        public let domainId: String?
        /// The ID of the lineage event.
        public let id: String?

        @inlinable
        public init(domainId: String? = nil, id: String? = nil) {
            self.domainId = domainId
            self.id = id
        }

        private enum CodingKeys: String, CodingKey {
            case domainId = "domainId"
            case id = "id"
        }
    }

    public struct PostTimeSeriesDataPointsInput: AWSEncodableShape {
        /// A unique, case-sensitive identifier that is provided to ensure the idempotency of the request.
        public let clientToken: String?
        /// The ID of the Amazon DataZone domain in which you want to post time series data points.
        public let domainIdentifier: String
        /// The ID of the asset for which you want to post time series data points.
        public let entityIdentifier: String
        /// The type of the asset for which you want to post data points.
        public let entityType: TimeSeriesEntityType
        /// The forms that contain the data points that you want to post.
        public let forms: [TimeSeriesDataPointFormInput]

        @inlinable
        public init(clientToken: String? = PostTimeSeriesDataPointsInput.idempotencyToken(), domainIdentifier: String, entityIdentifier: String, entityType: TimeSeriesEntityType, forms: [TimeSeriesDataPointFormInput]) {
            self.clientToken = clientToken
            self.domainIdentifier = domainIdentifier
            self.entityIdentifier = entityIdentifier
            self.entityType = entityType
            self.forms = forms
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.clientToken, forKey: .clientToken)
            request.encodePath(self.domainIdentifier, key: "domainIdentifier")
            request.encodePath(self.entityIdentifier, key: "entityIdentifier")
            request.encodePath(self.entityType, key: "entityType")
            try container.encode(self.forms, forKey: .forms)
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 128)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "^[\\x21-\\x7E]+$")
            try self.validate(self.domainIdentifier, name: "domainIdentifier", parent: name, pattern: "^dzd[-_][a-zA-Z0-9_-]{1,36}$")
            try self.validate(self.entityIdentifier, name: "entityIdentifier", parent: name, pattern: "^[a-zA-Z0-9_-]{1,36}$")
            try self.forms.forEach {
                try $0.validate(name: "\(name).forms[]")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "clientToken"
            case forms = "forms"
        }
    }

    public struct PostTimeSeriesDataPointsOutput: AWSDecodableShape {
        /// The ID of the Amazon DataZone domain in which you want to post time series data points.
        public let domainId: String?
        /// The ID of the asset for which you want to post time series data points.
        public let entityId: String?
        /// The type of the asset for which you want to post data points.
        public let entityType: TimeSeriesEntityType?
        /// The forms that contain the data points that you have posted.
        public let forms: [TimeSeriesDataPointFormOutput]?

        @inlinable
        public init(domainId: String? = nil, entityId: String? = nil, entityType: TimeSeriesEntityType? = nil, forms: [TimeSeriesDataPointFormOutput]? = nil) {
            self.domainId = domainId
            self.entityId = entityId
            self.entityType = entityType
            self.forms = forms
        }

        private enum CodingKeys: String, CodingKey {
            case domainId = "domainId"
            case entityId = "entityId"
            case entityType = "entityType"
            case forms = "forms"
        }
    }

    public struct PredictionConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The business name generation mechanism.
        public let businessNameGeneration: BusinessNameGenerationConfiguration?

        @inlinable
        public init(businessNameGeneration: BusinessNameGenerationConfiguration? = nil) {
            self.businessNameGeneration = businessNameGeneration
        }

        private enum CodingKeys: String, CodingKey {
            case businessNameGeneration = "businessNameGeneration"
        }
    }

    public struct ProjectDeletionError: AWSDecodableShape {
        /// The code of the project deletion error.
        public let code: String?
        /// The message of the project deletion error.
        public let message: String?

        @inlinable
        public init(code: String? = nil, message: String? = nil) {
            self.code = code
            self.message = message
        }

        private enum CodingKeys: String, CodingKey {
            case code = "code"
            case message = "message"
        }
    }

    public struct ProjectMember: AWSDecodableShape {
        /// The designated role of a project member.
        public let designation: UserDesignation
        /// The membership details of a project member.
        public let memberDetails: MemberDetails

        @inlinable
        public init(designation: UserDesignation, memberDetails: MemberDetails) {
            self.designation = designation
            self.memberDetails = memberDetails
        }

        private enum CodingKeys: String, CodingKey {
            case designation = "designation"
            case memberDetails = "memberDetails"
        }
    }

    public struct ProjectPolicyGrantPrincipal: AWSEncodableShape & AWSDecodableShape {
        /// The project designation of the project policy grant principal.
        public let projectDesignation: ProjectDesignation
        /// The project grant filter of the project policy grant principal.
        public let projectGrantFilter: ProjectGrantFilter?
        /// The project ID of the project policy grant principal.
        public let projectIdentifier: String?

        @inlinable
        public init(projectDesignation: ProjectDesignation, projectGrantFilter: ProjectGrantFilter? = nil, projectIdentifier: String? = nil) {
            self.projectDesignation = projectDesignation
            self.projectGrantFilter = projectGrantFilter
            self.projectIdentifier = projectIdentifier
        }

        public func validate(name: String) throws {
            try self.projectGrantFilter?.validate(name: "\(name).projectGrantFilter")
            try self.validate(self.projectIdentifier, name: "projectIdentifier", parent: name, pattern: "^[a-zA-Z0-9_-]{1,36}$")
        }

        private enum CodingKeys: String, CodingKey {
            case projectDesignation = "projectDesignation"
            case projectGrantFilter = "projectGrantFilter"
            case projectIdentifier = "projectIdentifier"
        }
    }

    public struct ProjectProfileSummary: AWSDecodableShape {
        /// The timestamp of when the project profile was created.
        public let createdAt: Date?
        /// The user who created the project profile.
        public let createdBy: String
        /// The description of the project profile.
        public let description: String?
        /// The domain ID of the project profile.
        public let domainId: String
        /// The domain unit ID of the project profile.
        public let domainUnitId: String?
        /// The ID of the project profile.
        public let id: String
        /// The timestamp at which a project profile was last updated.
        public let lastUpdatedAt: Date?
        /// The name of a project profile.
        public let name: String
        /// The status of a project profile.
        public let status: Status?

        @inlinable
        public init(createdAt: Date? = nil, createdBy: String, description: String? = nil, domainId: String, domainUnitId: String? = nil, id: String, lastUpdatedAt: Date? = nil, name: String, status: Status? = nil) {
            self.createdAt = createdAt
            self.createdBy = createdBy
            self.description = description
            self.domainId = domainId
            self.domainUnitId = domainUnitId
            self.id = id
            self.lastUpdatedAt = lastUpdatedAt
            self.name = name
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case createdAt = "createdAt"
            case createdBy = "createdBy"
            case description = "description"
            case domainId = "domainId"
            case domainUnitId = "domainUnitId"
            case id = "id"
            case lastUpdatedAt = "lastUpdatedAt"
            case name = "name"
            case status = "status"
        }
    }

    public struct ProjectSummary: AWSDecodableShape {
        /// The timestamp of when a project was created.
        public let createdAt: Date?
        /// The Amazon DataZone user who created the project.
        public let createdBy: String
        /// The description of a project.
        public let description: String?
        /// The identifier of a Amazon DataZone domain where the project exists.
        public let domainId: String
        /// The ID of the domain unit.
        public let domainUnitId: String?
        /// Specifies the error message that is returned if the operation cannot be successfully completed.
        public let failureReasons: [ProjectDeletionError]?
        /// The identifier of a project.
        public let id: String
        /// The name of a project.
        public let name: String
        /// The status of the project.
        public let projectStatus: ProjectStatus?
        /// The timestamp of when the project was updated.
        public let updatedAt: Date?

        @inlinable
        public init(createdAt: Date? = nil, createdBy: String, description: String? = nil, domainId: String, domainUnitId: String? = nil, failureReasons: [ProjectDeletionError]? = nil, id: String, name: String, projectStatus: ProjectStatus? = nil, updatedAt: Date? = nil) {
            self.createdAt = createdAt
            self.createdBy = createdBy
            self.description = description
            self.domainId = domainId
            self.domainUnitId = domainUnitId
            self.failureReasons = failureReasons
            self.id = id
            self.name = name
            self.projectStatus = projectStatus
            self.updatedAt = updatedAt
        }

        private enum CodingKeys: String, CodingKey {
            case createdAt = "createdAt"
            case createdBy = "createdBy"
            case description = "description"
            case domainId = "domainId"
            case domainUnitId = "domainUnitId"
            case failureReasons = "failureReasons"
            case id = "id"
            case name = "name"
            case projectStatus = "projectStatus"
            case updatedAt = "updatedAt"
        }
    }

    public struct ProjectsForRule: AWSEncodableShape & AWSDecodableShape {
        /// The selection mode of the rule.
        public let selectionMode: RuleScopeSelectionMode
        /// The specific projects in which the rule is created.
        public let specificProjects: [String]?

        @inlinable
        public init(selectionMode: RuleScopeSelectionMode, specificProjects: [String]? = nil) {
            self.selectionMode = selectionMode
            self.specificProjects = specificProjects
        }

        public func validate(name: String) throws {
            try self.specificProjects?.forEach {
                try validate($0, name: "specificProjects[]", parent: name, pattern: "^[a-zA-Z0-9_-]{1,36}$")
            }
            try self.validate(self.specificProjects, name: "specificProjects", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case selectionMode = "selectionMode"
            case specificProjects = "specificProjects"
        }
    }

    public struct PutEnvironmentBlueprintConfigurationInput: AWSEncodableShape {
        /// The identifier of the Amazon DataZone domain.
        public let domainIdentifier: String
        /// Specifies the enabled Amazon Web Services Regions.
        public let enabledRegions: [String]
        /// The identifier of the environment blueprint.
        public let environmentBlueprintIdentifier: String
        /// The environment role permissions boundary.
        public let environmentRolePermissionBoundary: String?
        /// The ARN of the manage access role.
        public let manageAccessRoleArn: String?
        /// The provisioning configuration of a blueprint.
        public let provisioningConfigurations: [ProvisioningConfiguration]?
        /// The ARN of the provisioning role.
        public let provisioningRoleArn: String?
        /// The regional parameters in the environment blueprint.
        public let regionalParameters: [String: [String: String]]?

        @inlinable
        public init(domainIdentifier: String, enabledRegions: [String], environmentBlueprintIdentifier: String, environmentRolePermissionBoundary: String? = nil, manageAccessRoleArn: String? = nil, provisioningConfigurations: [ProvisioningConfiguration]? = nil, provisioningRoleArn: String? = nil, regionalParameters: [String: [String: String]]? = nil) {
            self.domainIdentifier = domainIdentifier
            self.enabledRegions = enabledRegions
            self.environmentBlueprintIdentifier = environmentBlueprintIdentifier
            self.environmentRolePermissionBoundary = environmentRolePermissionBoundary
            self.manageAccessRoleArn = manageAccessRoleArn
            self.provisioningConfigurations = provisioningConfigurations
            self.provisioningRoleArn = provisioningRoleArn
            self.regionalParameters = regionalParameters
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.domainIdentifier, key: "domainIdentifier")
            try container.encode(self.enabledRegions, forKey: .enabledRegions)
            request.encodePath(self.environmentBlueprintIdentifier, key: "environmentBlueprintIdentifier")
            try container.encodeIfPresent(self.environmentRolePermissionBoundary, forKey: .environmentRolePermissionBoundary)
            try container.encodeIfPresent(self.manageAccessRoleArn, forKey: .manageAccessRoleArn)
            try container.encodeIfPresent(self.provisioningConfigurations, forKey: .provisioningConfigurations)
            try container.encodeIfPresent(self.provisioningRoleArn, forKey: .provisioningRoleArn)
            try container.encodeIfPresent(self.regionalParameters, forKey: .regionalParameters)
        }

        public func validate(name: String) throws {
            try self.validate(self.domainIdentifier, name: "domainIdentifier", parent: name, pattern: "^dzd[-_][a-zA-Z0-9_-]{1,36}$")
            try self.enabledRegions.forEach {
                try validate($0, name: "enabledRegions[]", parent: name, max: 16)
                try validate($0, name: "enabledRegions[]", parent: name, min: 4)
                try validate($0, name: "enabledRegions[]", parent: name, pattern: "^[a-z]{2}-?(iso|gov)?-{1}[a-z]*-{1}[0-9]$")
            }
            try self.validate(self.environmentBlueprintIdentifier, name: "environmentBlueprintIdentifier", parent: name, pattern: "^[a-zA-Z0-9_-]{1,36}$")
            try self.validate(self.environmentRolePermissionBoundary, name: "environmentRolePermissionBoundary", parent: name, pattern: "^arn:aws[^:]*:iam::(aws|\\d{12}):policy/[\\w+=,.@-]*$")
            try self.validate(self.manageAccessRoleArn, name: "manageAccessRoleArn", parent: name, pattern: "^arn:aws[^:]*:iam::\\d{12}:(role|role/service-role)/[\\w+=,.@-]*$")
            try self.provisioningConfigurations?.forEach {
                try $0.validate(name: "\(name).provisioningConfigurations[]")
            }
            try self.validate(self.provisioningRoleArn, name: "provisioningRoleArn", parent: name, pattern: "^arn:aws[^:]*:iam::\\d{12}:(role|role/service-role)/[\\w+=,.@-]*$")
            try self.regionalParameters?.forEach {
                try validate($0.key, name: "regionalParameters.key", parent: name, max: 16)
                try validate($0.key, name: "regionalParameters.key", parent: name, min: 4)
                try validate($0.key, name: "regionalParameters.key", parent: name, pattern: "^[a-z]{2}-?(iso|gov)?-{1}[a-z]*-{1}[0-9]$")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case enabledRegions = "enabledRegions"
            case environmentRolePermissionBoundary = "environmentRolePermissionBoundary"
            case manageAccessRoleArn = "manageAccessRoleArn"
            case provisioningConfigurations = "provisioningConfigurations"
            case provisioningRoleArn = "provisioningRoleArn"
            case regionalParameters = "regionalParameters"
        }
    }

    public struct PutEnvironmentBlueprintConfigurationOutput: AWSDecodableShape {
        /// The timestamp of when the environment blueprint was created.
        public let createdAt: Date?
        /// The identifier of the Amazon DataZone domain.
        public let domainId: String
        /// Specifies the enabled Amazon Web Services Regions.
        public let enabledRegions: [String]?
        /// The identifier of the environment blueprint.
        public let environmentBlueprintId: String
        /// The environment role permissions boundary.
        public let environmentRolePermissionBoundary: String?
        /// The ARN of the manage access role.
        public let manageAccessRoleArn: String?
        /// The provisioning configuration of a blueprint.
        public let provisioningConfigurations: [ProvisioningConfiguration]?
        /// The ARN of the provisioning role.
        public let provisioningRoleArn: String?
        /// The regional parameters in the environment blueprint.
        public let regionalParameters: [String: [String: String]]?
        /// The timestamp of when the environment blueprint was updated.
        public let updatedAt: Date?

        @inlinable
        public init(createdAt: Date? = nil, domainId: String, enabledRegions: [String]? = nil, environmentBlueprintId: String, environmentRolePermissionBoundary: String? = nil, manageAccessRoleArn: String? = nil, provisioningConfigurations: [ProvisioningConfiguration]? = nil, provisioningRoleArn: String? = nil, regionalParameters: [String: [String: String]]? = nil, updatedAt: Date? = nil) {
            self.createdAt = createdAt
            self.domainId = domainId
            self.enabledRegions = enabledRegions
            self.environmentBlueprintId = environmentBlueprintId
            self.environmentRolePermissionBoundary = environmentRolePermissionBoundary
            self.manageAccessRoleArn = manageAccessRoleArn
            self.provisioningConfigurations = provisioningConfigurations
            self.provisioningRoleArn = provisioningRoleArn
            self.regionalParameters = regionalParameters
            self.updatedAt = updatedAt
        }

        private enum CodingKeys: String, CodingKey {
            case createdAt = "createdAt"
            case domainId = "domainId"
            case enabledRegions = "enabledRegions"
            case environmentBlueprintId = "environmentBlueprintId"
            case environmentRolePermissionBoundary = "environmentRolePermissionBoundary"
            case manageAccessRoleArn = "manageAccessRoleArn"
            case provisioningConfigurations = "provisioningConfigurations"
            case provisioningRoleArn = "provisioningRoleArn"
            case regionalParameters = "regionalParameters"
            case updatedAt = "updatedAt"
        }
    }

    public struct RecommendationConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// Specifies whether automatic business name generation is to be enabled or not as part of the recommendation configuration.
        public let enableBusinessNameGeneration: Bool?

        @inlinable
        public init(enableBusinessNameGeneration: Bool? = nil) {
            self.enableBusinessNameGeneration = enableBusinessNameGeneration
        }

        private enum CodingKeys: String, CodingKey {
            case enableBusinessNameGeneration = "enableBusinessNameGeneration"
        }
    }

    public struct RedshiftClusterStorage: AWSEncodableShape & AWSDecodableShape {
        /// The name of an Amazon Redshift cluster.
        public let clusterName: String

        @inlinable
        public init(clusterName: String) {
            self.clusterName = clusterName
        }

        private enum CodingKeys: String, CodingKey {
            case clusterName = "clusterName"
        }
    }

    public struct RedshiftCredentialConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The ARN of a secret manager for an Amazon Redshift cluster.
        public let secretManagerArn: String

        @inlinable
        public init(secretManagerArn: String) {
            self.secretManagerArn = secretManagerArn
        }

        private enum CodingKeys: String, CodingKey {
            case secretManagerArn = "secretManagerArn"
        }
    }

    public struct RedshiftLineageSyncConfigurationInput: AWSEncodableShape {
        /// Specifies whether the Amaon Redshift lineage sync configuration is enabled.
        public let enabled: Bool?
        /// The schedule of the Amaon Redshift lineage sync configuration.
        public let schedule: LineageSyncSchedule?

        @inlinable
        public init(enabled: Bool? = nil, schedule: LineageSyncSchedule? = nil) {
            self.enabled = enabled
            self.schedule = schedule
        }

        private enum CodingKeys: String, CodingKey {
            case enabled = "enabled"
            case schedule = "schedule"
        }
    }

    public struct RedshiftLineageSyncConfigurationOutput: AWSDecodableShape {
        /// Specifies whether the Amaon Redshift lineage sync configuration is enabled.
        public let enabled: Bool?
        /// The lineage job ID of the Amaon Redshift lineage sync configuration.
        public let lineageJobId: String?
        /// The schedule of teh Amaon Redshift lineage sync configuration.
        public let schedule: LineageSyncSchedule?

        @inlinable
        public init(enabled: Bool? = nil, lineageJobId: String? = nil, schedule: LineageSyncSchedule? = nil) {
            self.enabled = enabled
            self.lineageJobId = lineageJobId
            self.schedule = schedule
        }

        private enum CodingKeys: String, CodingKey {
            case enabled = "enabled"
            case lineageJobId = "lineageJobId"
            case schedule = "schedule"
        }
    }

    public struct RedshiftPropertiesInput: AWSEncodableShape {
        /// The Amaon Redshift credentials.
        public let credentials: RedshiftCredentials?
        /// The Amazon Redshift database name.
        public let databaseName: String?
        /// The Amazon Redshift host.
        public let host: String?
        /// The lineage sync of the Amazon Redshift.
        public let lineageSync: RedshiftLineageSyncConfigurationInput?
        /// The Amaon Redshift port.
        public let port: Int?
        /// The Amazon Redshift storage.
        public let storage: RedshiftStorageProperties?

        @inlinable
        public init(credentials: RedshiftCredentials? = nil, databaseName: String? = nil, host: String? = nil, lineageSync: RedshiftLineageSyncConfigurationInput? = nil, port: Int? = nil, storage: RedshiftStorageProperties? = nil) {
            self.credentials = credentials
            self.databaseName = databaseName
            self.host = host
            self.lineageSync = lineageSync
            self.port = port
            self.storage = storage
        }

        public func validate(name: String) throws {
            try self.credentials?.validate(name: "\(name).credentials")
        }

        private enum CodingKeys: String, CodingKey {
            case credentials = "credentials"
            case databaseName = "databaseName"
            case host = "host"
            case lineageSync = "lineageSync"
            case port = "port"
            case storage = "storage"
        }
    }

    public struct RedshiftPropertiesOutput: AWSDecodableShape {
        /// The Amazon Redshift credentials.
        public let credentials: RedshiftCredentials?
        /// The Amazon Redshift database name.
        public let databaseName: String?
        /// Specifies whether Amaon Redshift properties has a provisioned secret.
        public let isProvisionedSecret: Bool?
        /// The jdbcIam URL of the Amazon Redshift properties.
        public let jdbcIamUrl: String?
        /// The jdbcURL of the Amazon Redshift properties.
        public let jdbcUrl: String?
        /// The lineage syn of the Amazon Redshift properties.
        public let lineageSync: RedshiftLineageSyncConfigurationOutput?
        /// The redshiftTempDir of the Amazon Redshift properties.
        public let redshiftTempDir: String?
        /// The status in the Amazon Redshift properties.
        public let status: ConnectionStatus?
        /// The storage in the Amazon Redshift properties.
        public let storage: RedshiftStorageProperties?

        @inlinable
        public init(credentials: RedshiftCredentials? = nil, databaseName: String? = nil, isProvisionedSecret: Bool? = nil, jdbcIamUrl: String? = nil, jdbcUrl: String? = nil, lineageSync: RedshiftLineageSyncConfigurationOutput? = nil, redshiftTempDir: String? = nil, status: ConnectionStatus? = nil, storage: RedshiftStorageProperties? = nil) {
            self.credentials = credentials
            self.databaseName = databaseName
            self.isProvisionedSecret = isProvisionedSecret
            self.jdbcIamUrl = jdbcIamUrl
            self.jdbcUrl = jdbcUrl
            self.lineageSync = lineageSync
            self.redshiftTempDir = redshiftTempDir
            self.status = status
            self.storage = storage
        }

        private enum CodingKeys: String, CodingKey {
            case credentials = "credentials"
            case databaseName = "databaseName"
            case isProvisionedSecret = "isProvisionedSecret"
            case jdbcIamUrl = "jdbcIamUrl"
            case jdbcUrl = "jdbcUrl"
            case lineageSync = "lineageSync"
            case redshiftTempDir = "redshiftTempDir"
            case status = "status"
            case storage = "storage"
        }
    }

    public struct RedshiftPropertiesPatch: AWSEncodableShape {
        /// The credentials in the Amazon Redshift properties patch.
        public let credentials: RedshiftCredentials?
        /// The name in the Amazon Redshift properties patch.
        public let databaseName: String?
        /// The host in the Amazon Redshift properties patch.
        public let host: String?
        /// The lineage sync in the Amazon Redshift properties patch.
        public let lineageSync: RedshiftLineageSyncConfigurationInput?
        /// The port in the Amazon Redshift properties patch.
        public let port: Int?
        /// The storage in the Amazon Redshift properties patch.
        public let storage: RedshiftStorageProperties?

        @inlinable
        public init(credentials: RedshiftCredentials? = nil, databaseName: String? = nil, host: String? = nil, lineageSync: RedshiftLineageSyncConfigurationInput? = nil, port: Int? = nil, storage: RedshiftStorageProperties? = nil) {
            self.credentials = credentials
            self.databaseName = databaseName
            self.host = host
            self.lineageSync = lineageSync
            self.port = port
            self.storage = storage
        }

        public func validate(name: String) throws {
            try self.credentials?.validate(name: "\(name).credentials")
        }

        private enum CodingKeys: String, CodingKey {
            case credentials = "credentials"
            case databaseName = "databaseName"
            case host = "host"
            case lineageSync = "lineageSync"
            case port = "port"
            case storage = "storage"
        }
    }

    public struct RedshiftRunConfigurationInput: AWSEncodableShape {
        /// The data access role included in the configuration details of the Amazon Redshift data source.
        public let dataAccessRole: String?
        public let redshiftCredentialConfiguration: RedshiftCredentialConfiguration?
        public let redshiftStorage: RedshiftStorage?
        /// The relational filger configurations included in the configuration details of the Amazon Redshift data source.
        public let relationalFilterConfigurations: [RelationalFilterConfiguration]

        @inlinable
        public init(dataAccessRole: String? = nil, redshiftCredentialConfiguration: RedshiftCredentialConfiguration? = nil, redshiftStorage: RedshiftStorage? = nil, relationalFilterConfigurations: [RelationalFilterConfiguration]) {
            self.dataAccessRole = dataAccessRole
            self.redshiftCredentialConfiguration = redshiftCredentialConfiguration
            self.redshiftStorage = redshiftStorage
            self.relationalFilterConfigurations = relationalFilterConfigurations
        }

        private enum CodingKeys: String, CodingKey {
            case dataAccessRole = "dataAccessRole"
            case redshiftCredentialConfiguration = "redshiftCredentialConfiguration"
            case redshiftStorage = "redshiftStorage"
            case relationalFilterConfigurations = "relationalFilterConfigurations"
        }
    }

    public struct RedshiftRunConfigurationOutput: AWSDecodableShape {
        /// The ID of the Amazon Web Services account included in the configuration details of the Amazon Redshift data source.
        public let accountId: String?
        /// The data access role included in the configuration details of the Amazon Redshift data source.
        public let dataAccessRole: String?
        public let redshiftCredentialConfiguration: RedshiftCredentialConfiguration?
        public let redshiftStorage: RedshiftStorage
        /// The Amazon Web Services region included in the configuration details of the Amazon Redshift data source.
        public let region: String?
        /// The relational filger configurations included in the configuration details of the Amazon Redshift data source.
        public let relationalFilterConfigurations: [RelationalFilterConfiguration]

        @inlinable
        public init(accountId: String? = nil, dataAccessRole: String? = nil, redshiftCredentialConfiguration: RedshiftCredentialConfiguration? = nil, redshiftStorage: RedshiftStorage, region: String? = nil, relationalFilterConfigurations: [RelationalFilterConfiguration]) {
            self.accountId = accountId
            self.dataAccessRole = dataAccessRole
            self.redshiftCredentialConfiguration = redshiftCredentialConfiguration
            self.redshiftStorage = redshiftStorage
            self.region = region
            self.relationalFilterConfigurations = relationalFilterConfigurations
        }

        private enum CodingKeys: String, CodingKey {
            case accountId = "accountId"
            case dataAccessRole = "dataAccessRole"
            case redshiftCredentialConfiguration = "redshiftCredentialConfiguration"
            case redshiftStorage = "redshiftStorage"
            case region = "region"
            case relationalFilterConfigurations = "relationalFilterConfigurations"
        }
    }

    public struct RedshiftSelfGrantStatusOutput: AWSDecodableShape {
        /// The details for the self granting status for an Amazon Redshift data source.
        public let selfGrantStatusDetails: [SelfGrantStatusDetail]

        @inlinable
        public init(selfGrantStatusDetails: [SelfGrantStatusDetail]) {
            self.selfGrantStatusDetails = selfGrantStatusDetails
        }

        private enum CodingKeys: String, CodingKey {
            case selfGrantStatusDetails = "selfGrantStatusDetails"
        }
    }

    public struct RedshiftServerlessStorage: AWSEncodableShape & AWSDecodableShape {
        /// The name of the Amazon Redshift Serverless workgroup.
        public let workgroupName: String

        @inlinable
        public init(workgroupName: String) {
            self.workgroupName = workgroupName
        }

        private enum CodingKeys: String, CodingKey {
            case workgroupName = "workgroupName"
        }
    }

    public struct RejectChoice: AWSEncodableShape {
        /// Specifies the the automatically generated business metadata that can be rejected.
        public let predictionChoices: [Int]?
        /// Specifies the target (for example, a column name) where a prediction can be rejected.
        public let predictionTarget: String?

        @inlinable
        public init(predictionChoices: [Int]? = nil, predictionTarget: String? = nil) {
            self.predictionChoices = predictionChoices
            self.predictionTarget = predictionTarget
        }

        private enum CodingKeys: String, CodingKey {
            case predictionChoices = "predictionChoices"
            case predictionTarget = "predictionTarget"
        }
    }

    public struct RejectPredictionsInput: AWSEncodableShape {
        /// A unique, case-sensitive identifier that is provided to ensure the idempotency of the request.
        public let clientToken: String?
        /// The identifier of the Amazon DataZone domain.
        public let domainIdentifier: String
        /// The identifier of the prediction.
        public let identifier: String
        /// Specifies the prediction (aka, the automatically generated piece of metadata) and the target (for example, a column name) that can be rejected.
        public let rejectChoices: [RejectChoice]?
        /// Specifies the rule (or the conditions) under which a prediction can be rejected.
        public let rejectRule: RejectRule?
        /// The revision that is to be made to the asset.
        public let revision: String?

        @inlinable
        public init(clientToken: String? = RejectPredictionsInput.idempotencyToken(), domainIdentifier: String, identifier: String, rejectChoices: [RejectChoice]? = nil, rejectRule: RejectRule? = nil, revision: String? = nil) {
            self.clientToken = clientToken
            self.domainIdentifier = domainIdentifier
            self.identifier = identifier
            self.rejectChoices = rejectChoices
            self.rejectRule = rejectRule
            self.revision = revision
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.clientToken, forKey: .clientToken)
            request.encodePath(self.domainIdentifier, key: "domainIdentifier")
            request.encodePath(self.identifier, key: "identifier")
            try container.encodeIfPresent(self.rejectChoices, forKey: .rejectChoices)
            try container.encodeIfPresent(self.rejectRule, forKey: .rejectRule)
            request.encodeQuery(self.revision, key: "revision")
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 128)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "^[\\x21-\\x7E]+$")
            try self.validate(self.domainIdentifier, name: "domainIdentifier", parent: name, pattern: "^dzd[-_][a-zA-Z0-9_-]{1,36}$")
            try self.validate(self.identifier, name: "identifier", parent: name, pattern: "^[a-zA-Z0-9_-]{1,36}$")
            try self.validate(self.revision, name: "revision", parent: name, max: 64)
            try self.validate(self.revision, name: "revision", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "clientToken"
            case rejectChoices = "rejectChoices"
            case rejectRule = "rejectRule"
        }
    }

    public struct RejectPredictionsOutput: AWSDecodableShape {
        /// The ID of the asset.
        public let assetId: String
        /// The revision that is to be made to the asset.
        public let assetRevision: String
        /// The ID of the Amazon DataZone domain.
        public let domainId: String

        @inlinable
        public init(assetId: String, assetRevision: String, domainId: String) {
            self.assetId = assetId
            self.assetRevision = assetRevision
            self.domainId = domainId
        }

        private enum CodingKeys: String, CodingKey {
            case assetId = "assetId"
            case assetRevision = "assetRevision"
            case domainId = "domainId"
        }
    }

    public struct RejectRule: AWSEncodableShape {
        /// Specifies whether you want to reject the top prediction for all targets or none.
        public let rule: RejectRuleBehavior?
        /// The confidence score that specifies the condition at which a prediction can be rejected.
        public let threshold: Float?

        @inlinable
        public init(rule: RejectRuleBehavior? = nil, threshold: Float? = nil) {
            self.rule = rule
            self.threshold = threshold
        }

        private enum CodingKeys: String, CodingKey {
            case rule = "rule"
            case threshold = "threshold"
        }
    }

    public struct RejectSubscriptionRequestInput: AWSEncodableShape {
        /// The decision comment of the rejected subscription request.
        public let decisionComment: String?
        /// The identifier of the Amazon DataZone domain in which the subscription request was rejected.
        public let domainIdentifier: String
        /// The identifier of the subscription request that was rejected.
        public let identifier: String

        @inlinable
        public init(decisionComment: String? = nil, domainIdentifier: String, identifier: String) {
            self.decisionComment = decisionComment
            self.domainIdentifier = domainIdentifier
            self.identifier = identifier
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.decisionComment, forKey: .decisionComment)
            request.encodePath(self.domainIdentifier, key: "domainIdentifier")
            request.encodePath(self.identifier, key: "identifier")
        }

        public func validate(name: String) throws {
            try self.validate(self.decisionComment, name: "decisionComment", parent: name, max: 4096)
            try self.validate(self.decisionComment, name: "decisionComment", parent: name, min: 1)
            try self.validate(self.domainIdentifier, name: "domainIdentifier", parent: name, pattern: "^dzd[-_][a-zA-Z0-9_-]{1,36}$")
            try self.validate(self.identifier, name: "identifier", parent: name, pattern: "^[a-zA-Z0-9_-]{1,36}$")
        }

        private enum CodingKeys: String, CodingKey {
            case decisionComment = "decisionComment"
        }
    }

    public struct RejectSubscriptionRequestOutput: AWSDecodableShape {
        /// The timestamp of when the subscription request was rejected.
        public let createdAt: Date
        /// The timestamp of when the subscription request was rejected.
        public let createdBy: String
        /// The decision comment of the rejected subscription request.
        public let decisionComment: String?
        /// The identifier of the Amazon DataZone domain in which the subscription request was rejected.
        public let domainId: String
        /// The ID of the existing subscription.
        public let existingSubscriptionId: String?
        /// The identifier of the subscription request that was rejected.
        public let id: String
        /// Metadata forms included in the subscription request.
        public let metadataForms: [FormOutput]?
        /// The reason for the subscription request.
        public let requestReason: String
        /// The identifier of the subscription request reviewer.
        public let reviewerId: String?
        /// The status of the subscription request.
        public let status: SubscriptionRequestStatus
        /// The subscribed listings of the subscription request.
        public let subscribedListings: [SubscribedListing]
        /// The subscribed principals of the subscription request.
        public let subscribedPrincipals: [SubscribedPrincipal]
        /// The timestamp of when the subscription request was updated.
        public let updatedAt: Date
        /// The Amazon DataZone user who updated the subscription request.
        public let updatedBy: String?

        @inlinable
        public init(createdAt: Date, createdBy: String, decisionComment: String? = nil, domainId: String, existingSubscriptionId: String? = nil, id: String, metadataForms: [FormOutput]? = nil, requestReason: String, reviewerId: String? = nil, status: SubscriptionRequestStatus, subscribedListings: [SubscribedListing], subscribedPrincipals: [SubscribedPrincipal], updatedAt: Date, updatedBy: String? = nil) {
            self.createdAt = createdAt
            self.createdBy = createdBy
            self.decisionComment = decisionComment
            self.domainId = domainId
            self.existingSubscriptionId = existingSubscriptionId
            self.id = id
            self.metadataForms = metadataForms
            self.requestReason = requestReason
            self.reviewerId = reviewerId
            self.status = status
            self.subscribedListings = subscribedListings
            self.subscribedPrincipals = subscribedPrincipals
            self.updatedAt = updatedAt
            self.updatedBy = updatedBy
        }

        private enum CodingKeys: String, CodingKey {
            case createdAt = "createdAt"
            case createdBy = "createdBy"
            case decisionComment = "decisionComment"
            case domainId = "domainId"
            case existingSubscriptionId = "existingSubscriptionId"
            case id = "id"
            case metadataForms = "metadataForms"
            case requestReason = "requestReason"
            case reviewerId = "reviewerId"
            case status = "status"
            case subscribedListings = "subscribedListings"
            case subscribedPrincipals = "subscribedPrincipals"
            case updatedAt = "updatedAt"
            case updatedBy = "updatedBy"
        }
    }

    public struct RelationalFilterConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The database name specified in the relational filter configuration for the data source.
        public let databaseName: String
        /// The filter expressions specified in the relational filter configuration for the data source.
        public let filterExpressions: [FilterExpression]?
        /// The schema name specified in the relational filter configuration for the data source.
        public let schemaName: String?

        @inlinable
        public init(databaseName: String, filterExpressions: [FilterExpression]? = nil, schemaName: String? = nil) {
            self.databaseName = databaseName
            self.filterExpressions = filterExpressions
            self.schemaName = schemaName
        }

        private enum CodingKeys: String, CodingKey {
            case databaseName = "databaseName"
            case filterExpressions = "filterExpressions"
            case schemaName = "schemaName"
        }
    }

    public struct RemoveEntityOwnerInput: AWSEncodableShape {
        /// A unique, case-sensitive identifier that is provided to ensure the idempotency of the request.
        public let clientToken: String?
        /// The ID of the domain where you want to remove an owner from an entity.
        public let domainIdentifier: String
        /// The ID of the entity from which you want to remove an owner.
        public let entityIdentifier: String
        /// The type of the entity from which you want to remove an owner.
        public let entityType: DataZoneEntityType
        /// The owner that you want to remove from an entity.
        public let owner: OwnerProperties

        @inlinable
        public init(clientToken: String? = RemoveEntityOwnerInput.idempotencyToken(), domainIdentifier: String, entityIdentifier: String, entityType: DataZoneEntityType, owner: OwnerProperties) {
            self.clientToken = clientToken
            self.domainIdentifier = domainIdentifier
            self.entityIdentifier = entityIdentifier
            self.entityType = entityType
            self.owner = owner
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.clientToken, forKey: .clientToken)
            request.encodePath(self.domainIdentifier, key: "domainIdentifier")
            request.encodePath(self.entityIdentifier, key: "entityIdentifier")
            request.encodePath(self.entityType, key: "entityType")
            try container.encode(self.owner, forKey: .owner)
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 128)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "^[\\x21-\\x7E]+$")
            try self.validate(self.domainIdentifier, name: "domainIdentifier", parent: name, pattern: "^dzd[-_][a-zA-Z0-9_-]{1,36}$")
            try self.owner.validate(name: "\(name).owner")
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "clientToken"
            case owner = "owner"
        }
    }

    public struct RemoveEntityOwnerOutput: AWSDecodableShape {
        public init() {}
    }

    public struct RemovePolicyGrantInput: AWSEncodableShape {
        /// A unique, case-sensitive identifier that is provided to ensure the idempotency of the request.
        public let clientToken: String?
        /// The ID of the domain where you want to remove a policy grant.
        public let domainIdentifier: String
        /// The ID of the entity from which you want to remove a policy grant.
        public let entityIdentifier: String
        /// The type of the entity from which you want to remove a policy grant.
        public let entityType: TargetEntityType
        /// The type of the policy that you want to remove.
        public let policyType: ManagedPolicyType
        /// The principal from which you want to remove a policy grant.
        public let principal: PolicyGrantPrincipal

        @inlinable
        public init(clientToken: String? = RemovePolicyGrantInput.idempotencyToken(), domainIdentifier: String, entityIdentifier: String, entityType: TargetEntityType, policyType: ManagedPolicyType, principal: PolicyGrantPrincipal) {
            self.clientToken = clientToken
            self.domainIdentifier = domainIdentifier
            self.entityIdentifier = entityIdentifier
            self.entityType = entityType
            self.policyType = policyType
            self.principal = principal
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.clientToken, forKey: .clientToken)
            request.encodePath(self.domainIdentifier, key: "domainIdentifier")
            request.encodePath(self.entityIdentifier, key: "entityIdentifier")
            request.encodePath(self.entityType, key: "entityType")
            try container.encode(self.policyType, forKey: .policyType)
            try container.encode(self.principal, forKey: .principal)
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 128)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "^[\\x21-\\x7E]+$")
            try self.validate(self.domainIdentifier, name: "domainIdentifier", parent: name, pattern: "^dzd[-_][a-zA-Z0-9_-]{1,36}$")
            try self.principal.validate(name: "\(name).principal")
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "clientToken"
            case policyType = "policyType"
            case principal = "principal"
        }
    }

    public struct RemovePolicyGrantOutput: AWSDecodableShape {
        public init() {}
    }

    public struct Resource: AWSDecodableShape {
        /// The name of a provisioned resource of this Amazon DataZone environment.
        public let name: String?
        /// The provider of a provisioned resource of this Amazon DataZone environment.
        public let provider: String?
        /// The type of a provisioned resource of this Amazon DataZone environment.
        public let type: String
        /// The value of a provisioned resource of this Amazon DataZone environment.
        public let value: String

        @inlinable
        public init(name: String? = nil, provider: String? = nil, type: String, value: String) {
            self.name = name
            self.provider = provider
            self.type = type
            self.value = value
        }

        private enum CodingKeys: String, CodingKey {
            case name = "name"
            case provider = "provider"
            case type = "type"
            case value = "value"
        }
    }

    public struct RevokeSubscriptionInput: AWSEncodableShape {
        /// The identifier of the Amazon DataZone domain where you want to revoke a subscription.
        public let domainIdentifier: String
        /// The identifier of the revoked subscription.
        public let identifier: String
        /// Specifies whether permissions are retained when the subscription is revoked.
        public let retainPermissions: Bool?

        @inlinable
        public init(domainIdentifier: String, identifier: String, retainPermissions: Bool? = nil) {
            self.domainIdentifier = domainIdentifier
            self.identifier = identifier
            self.retainPermissions = retainPermissions
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.domainIdentifier, key: "domainIdentifier")
            request.encodePath(self.identifier, key: "identifier")
            try container.encodeIfPresent(self.retainPermissions, forKey: .retainPermissions)
        }

        public func validate(name: String) throws {
            try self.validate(self.domainIdentifier, name: "domainIdentifier", parent: name, pattern: "^dzd[-_][a-zA-Z0-9_-]{1,36}$")
            try self.validate(self.identifier, name: "identifier", parent: name, pattern: "^[a-zA-Z0-9_-]{1,36}$")
        }

        private enum CodingKeys: String, CodingKey {
            case retainPermissions = "retainPermissions"
        }
    }

    public struct RevokeSubscriptionOutput: AWSDecodableShape {
        /// The timestamp of when the subscription was revoked.
        public let createdAt: Date
        /// The identifier of the user who revoked the subscription.
        public let createdBy: String
        /// The identifier of the Amazon DataZone domain where you want to revoke a subscription.
        public let domainId: String
        /// The identifier of the revoked subscription.
        public let id: String
        /// Specifies whether permissions are retained when the subscription is revoked.
        public let retainPermissions: Bool?
        /// The status of the revoked subscription.
        public let status: SubscriptionStatus
        /// The subscribed listing of the revoked subscription.
        public let subscribedListing: SubscribedListing
        /// The subscribed principal of the revoked subscription.
        public let subscribedPrincipal: SubscribedPrincipal
        /// The identifier of the subscription request for the revoked subscription.
        public let subscriptionRequestId: String?
        /// The timestamp of when the subscription was revoked.
        public let updatedAt: Date
        /// The Amazon DataZone user who revoked the subscription.
        public let updatedBy: String?

        @inlinable
        public init(createdAt: Date, createdBy: String, domainId: String, id: String, retainPermissions: Bool? = nil, status: SubscriptionStatus, subscribedListing: SubscribedListing, subscribedPrincipal: SubscribedPrincipal, subscriptionRequestId: String? = nil, updatedAt: Date, updatedBy: String? = nil) {
            self.createdAt = createdAt
            self.createdBy = createdBy
            self.domainId = domainId
            self.id = id
            self.retainPermissions = retainPermissions
            self.status = status
            self.subscribedListing = subscribedListing
            self.subscribedPrincipal = subscribedPrincipal
            self.subscriptionRequestId = subscriptionRequestId
            self.updatedAt = updatedAt
            self.updatedBy = updatedBy
        }

        private enum CodingKeys: String, CodingKey {
            case createdAt = "createdAt"
            case createdBy = "createdBy"
            case domainId = "domainId"
            case id = "id"
            case retainPermissions = "retainPermissions"
            case status = "status"
            case subscribedListing = "subscribedListing"
            case subscribedPrincipal = "subscribedPrincipal"
            case subscriptionRequestId = "subscriptionRequestId"
            case updatedAt = "updatedAt"
            case updatedBy = "updatedBy"
        }
    }

    public struct RowFilterConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The row filter.
        public let rowFilter: RowFilter
        /// Specifies whether the row filter is sensitive.
        public let sensitive: Bool?

        @inlinable
        public init(rowFilter: RowFilter, sensitive: Bool? = nil) {
            self.rowFilter = rowFilter
            self.sensitive = sensitive
        }

        private enum CodingKeys: String, CodingKey {
            case rowFilter = "rowFilter"
            case sensitive = "sensitive"
        }
    }

    public struct RuleScope: AWSEncodableShape & AWSDecodableShape {
        /// The asset type included in the rule scope.
        public let assetType: AssetTypesForRule?
        /// The data product included in the rule scope.
        public let dataProduct: Bool?
        /// The project included in the rule scope.
        public let project: ProjectsForRule?

        @inlinable
        public init(assetType: AssetTypesForRule? = nil, dataProduct: Bool? = nil, project: ProjectsForRule? = nil) {
            self.assetType = assetType
            self.dataProduct = dataProduct
            self.project = project
        }

        public func validate(name: String) throws {
            try self.assetType?.validate(name: "\(name).assetType")
            try self.project?.validate(name: "\(name).project")
        }

        private enum CodingKeys: String, CodingKey {
            case assetType = "assetType"
            case dataProduct = "dataProduct"
            case project = "project"
        }
    }

    public struct RuleSummary: AWSDecodableShape {
        /// The action of the rule.
        public let action: RuleAction?
        /// The ID of the rule.
        public let identifier: String?
        /// The timestamp at which the rule was last updated.
        public let lastUpdatedBy: String?
        /// The name of the rule.
        public let name: String?
        /// The revision of the rule.
        public let revision: String?
        /// The type of the rule.
        public let ruleType: RuleType?
        /// The scope of the rule.
        public let scope: RuleScope?
        /// The target of the rule.
        public let target: RuleTarget?
        /// The target type of the rule.
        public let targetType: RuleTargetType?
        /// The timestamp at which the rule was last updated.
        public let updatedAt: Date?

        @inlinable
        public init(action: RuleAction? = nil, identifier: String? = nil, lastUpdatedBy: String? = nil, name: String? = nil, revision: String? = nil, ruleType: RuleType? = nil, scope: RuleScope? = nil, target: RuleTarget? = nil, targetType: RuleTargetType? = nil, updatedAt: Date? = nil) {
            self.action = action
            self.identifier = identifier
            self.lastUpdatedBy = lastUpdatedBy
            self.name = name
            self.revision = revision
            self.ruleType = ruleType
            self.scope = scope
            self.target = target
            self.targetType = targetType
            self.updatedAt = updatedAt
        }

        private enum CodingKeys: String, CodingKey {
            case action = "action"
            case identifier = "identifier"
            case lastUpdatedBy = "lastUpdatedBy"
            case name = "name"
            case revision = "revision"
            case ruleType = "ruleType"
            case scope = "scope"
            case target = "target"
            case targetType = "targetType"
            case updatedAt = "updatedAt"
        }
    }

    public struct RunStatisticsForAssets: AWSDecodableShape {
        /// The added statistic for the data source run.
        public let added: Int?
        /// The failed statistic for the data source run.
        public let failed: Int?
        /// The skipped statistic for the data source run.
        public let skipped: Int?
        /// The unchanged statistic for the data source run.
        public let unchanged: Int?
        /// The updated statistic for the data source run.
        public let updated: Int?

        @inlinable
        public init(added: Int? = nil, failed: Int? = nil, skipped: Int? = nil, unchanged: Int? = nil, updated: Int? = nil) {
            self.added = added
            self.failed = failed
            self.skipped = skipped
            self.unchanged = unchanged
            self.updated = updated
        }

        private enum CodingKeys: String, CodingKey {
            case added = "added"
            case failed = "failed"
            case skipped = "skipped"
            case unchanged = "unchanged"
            case updated = "updated"
        }
    }

    public struct SageMakerRunConfigurationInput: AWSEncodableShape {
        /// The tracking assets of the Amazon SageMaker run.
        public let trackingAssets: [String: [String]]

        @inlinable
        public init(trackingAssets: [String: [String]]) {
            self.trackingAssets = trackingAssets
        }

        public func validate(name: String) throws {
            try self.trackingAssets.forEach {
                try validate($0.key, name: "trackingAssets.key", parent: name, max: 64)
                try validate($0.key, name: "trackingAssets.key", parent: name, min: 1)
                try validate($0.value, name: "trackingAssets[\"\($0.key)\"]", parent: name, max: 500)
            }
            try self.validate(self.trackingAssets, name: "trackingAssets", parent: name, max: 1)
            try self.validate(self.trackingAssets, name: "trackingAssets", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case trackingAssets = "trackingAssets"
        }
    }

    public struct SageMakerRunConfigurationOutput: AWSDecodableShape {
        /// The Amazon SageMaker account ID.
        public let accountId: String?
        /// The Amazon SageMaker Region.
        public let region: String?
        /// The tracking assets of the Amazon SageMaker.
        public let trackingAssets: [String: [String]]

        @inlinable
        public init(accountId: String? = nil, region: String? = nil, trackingAssets: [String: [String]]) {
            self.accountId = accountId
            self.region = region
            self.trackingAssets = trackingAssets
        }

        private enum CodingKeys: String, CodingKey {
            case accountId = "accountId"
            case region = "region"
            case trackingAssets = "trackingAssets"
        }
    }

    public struct ScheduleConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The schedule of the data source runs.
        public let schedule: String?
        /// The timezone of the data source run.
        public let timezone: Timezone?

        @inlinable
        public init(schedule: String? = nil, timezone: Timezone? = nil) {
            self.schedule = schedule
            self.timezone = timezone
        }

        public func validate(name: String) throws {
            try self.validate(self.schedule, name: "schedule", parent: name, max: 256)
            try self.validate(self.schedule, name: "schedule", parent: name, min: 1)
            try self.validate(self.schedule, name: "schedule", parent: name, pattern: "cron\\((\\b[0-5]?[0-9]\\b) (\\b2[0-3]\\b|\\b[0-1]?[0-9]\\b) ([-?*,/\\dLW]){1,83} ([-*,/\\d]|[a-zA-Z]{3}){1,23} ([-?#*,/\\dL]|[a-zA-Z]{3}){1,13} ([^\\)]+)\\)")
        }

        private enum CodingKeys: String, CodingKey {
            case schedule = "schedule"
            case timezone = "timezone"
        }
    }

    public struct SearchGroupProfilesInput: AWSEncodableShape {
        /// The identifier of the Amazon DataZone domain in which you want to search group profiles.
        public let domainIdentifier: String
        /// The group type for which to search.
        public let groupType: GroupSearchType
        /// The maximum number of results to return in a single call to SearchGroupProfiles. When the number of results to be listed is greater than the value of MaxResults, the response contains a NextToken value that you can use in a subsequent call to SearchGroupProfiles to list the next set of results.
        public let maxResults: Int?
        /// When the number of results is greater than the default value for the MaxResults parameter, or if you explicitly specify a value for MaxResults that is less than the number of results, the response includes a pagination token named NextToken. You can specify this NextToken value in a subsequent call to SearchGroupProfiles to list the next set of results.
        public let nextToken: String?
        /// Specifies the text for which to search.
        public let searchText: String?

        @inlinable
        public init(domainIdentifier: String, groupType: GroupSearchType, maxResults: Int? = nil, nextToken: String? = nil, searchText: String? = nil) {
            self.domainIdentifier = domainIdentifier
            self.groupType = groupType
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.searchText = searchText
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.domainIdentifier, key: "domainIdentifier")
            try container.encode(self.groupType, forKey: .groupType)
            try container.encodeIfPresent(self.maxResults, forKey: .maxResults)
            try container.encodeIfPresent(self.nextToken, forKey: .nextToken)
            try container.encodeIfPresent(self.searchText, forKey: .searchText)
        }

        public func validate(name: String) throws {
            try self.validate(self.domainIdentifier, name: "domainIdentifier", parent: name, pattern: "^dzd[-_][a-zA-Z0-9_-]{1,36}$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 50)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 8192)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.searchText, name: "searchText", parent: name, max: 1024)
        }

        private enum CodingKeys: String, CodingKey {
            case groupType = "groupType"
            case maxResults = "maxResults"
            case nextToken = "nextToken"
            case searchText = "searchText"
        }
    }

    public struct SearchGroupProfilesOutput: AWSDecodableShape {
        /// The results of the SearchGroupProfiles action.
        public let items: [GroupProfileSummary]?
        /// When the number of results is greater than the default value for the MaxResults parameter, or if you explicitly specify a value for MaxResults that is less than the number of results, the response includes a pagination token named NextToken. You can specify this NextToken value in a subsequent call to SearchGroupProfiles to list the next set of results.
        public let nextToken: String?

        @inlinable
        public init(items: [GroupProfileSummary]? = nil, nextToken: String? = nil) {
            self.items = items
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case items = "items"
            case nextToken = "nextToken"
        }
    }

    public struct SearchInItem: AWSEncodableShape {
        /// The search attribute.
        public let attribute: String

        @inlinable
        public init(attribute: String) {
            self.attribute = attribute
        }

        public func validate(name: String) throws {
            try self.validate(self.attribute, name: "attribute", parent: name, max: 128)
            try self.validate(self.attribute, name: "attribute", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case attribute = "attribute"
        }
    }

    public struct SearchInput: AWSEncodableShape {
        /// Specifies additional attributes for the Search action.
        public let additionalAttributes: [SearchOutputAdditionalAttribute]?
        /// The identifier of the Amazon DataZone domain.
        public let domainIdentifier: String
        /// Specifies the search filters.
        public let filters: FilterClause?
        /// The maximum number of results to return in a single call to Search. When the number of results to be listed is greater than the value of MaxResults, the response contains a NextToken value that you can use in a subsequent call to Search to list the next set of results.
        public let maxResults: Int?
        /// When the number of results is greater than the default value for the MaxResults parameter, or if you explicitly specify a value for MaxResults that is less than the number of results, the response includes a pagination token named NextToken. You can specify this NextToken value in a subsequent call to Search to list the next set of results.
        public let nextToken: String?
        /// The identifier of the owning project specified for the search.
        public let owningProjectIdentifier: String?
        /// The details of the search.
        public let searchIn: [SearchInItem]?
        /// The scope of the search.
        public let searchScope: InventorySearchScope
        /// Specifies the text for which to search.
        public let searchText: String?
        /// Specifies the way in which the search results are to be sorted.
        public let sort: SearchSort?

        @inlinable
        public init(additionalAttributes: [SearchOutputAdditionalAttribute]? = nil, domainIdentifier: String, filters: FilterClause? = nil, maxResults: Int? = nil, nextToken: String? = nil, owningProjectIdentifier: String? = nil, searchIn: [SearchInItem]? = nil, searchScope: InventorySearchScope, searchText: String? = nil, sort: SearchSort? = nil) {
            self.additionalAttributes = additionalAttributes
            self.domainIdentifier = domainIdentifier
            self.filters = filters
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.owningProjectIdentifier = owningProjectIdentifier
            self.searchIn = searchIn
            self.searchScope = searchScope
            self.searchText = searchText
            self.sort = sort
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.additionalAttributes, forKey: .additionalAttributes)
            request.encodePath(self.domainIdentifier, key: "domainIdentifier")
            try container.encodeIfPresent(self.filters, forKey: .filters)
            try container.encodeIfPresent(self.maxResults, forKey: .maxResults)
            try container.encodeIfPresent(self.nextToken, forKey: .nextToken)
            try container.encodeIfPresent(self.owningProjectIdentifier, forKey: .owningProjectIdentifier)
            try container.encodeIfPresent(self.searchIn, forKey: .searchIn)
            try container.encode(self.searchScope, forKey: .searchScope)
            try container.encodeIfPresent(self.searchText, forKey: .searchText)
            try container.encodeIfPresent(self.sort, forKey: .sort)
        }

        public func validate(name: String) throws {
            try self.validate(self.domainIdentifier, name: "domainIdentifier", parent: name, pattern: "^dzd[-_][a-zA-Z0-9_-]{1,36}$")
            try self.filters?.validate(name: "\(name).filters")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 50)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 8192)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.owningProjectIdentifier, name: "owningProjectIdentifier", parent: name, pattern: "^[a-zA-Z0-9_-]{1,36}$")
            try self.searchIn?.forEach {
                try $0.validate(name: "\(name).searchIn[]")
            }
            try self.validate(self.searchIn, name: "searchIn", parent: name, max: 10)
            try self.validate(self.searchIn, name: "searchIn", parent: name, min: 1)
            try self.validate(self.searchText, name: "searchText", parent: name, max: 4096)
            try self.validate(self.searchText, name: "searchText", parent: name, min: 1)
            try self.sort?.validate(name: "\(name).sort")
        }

        private enum CodingKeys: String, CodingKey {
            case additionalAttributes = "additionalAttributes"
            case filters = "filters"
            case maxResults = "maxResults"
            case nextToken = "nextToken"
            case owningProjectIdentifier = "owningProjectIdentifier"
            case searchIn = "searchIn"
            case searchScope = "searchScope"
            case searchText = "searchText"
            case sort = "sort"
        }
    }

    public struct SearchListingsInput: AWSEncodableShape {
        /// Specifies additional attributes for the search.
        public let additionalAttributes: [SearchOutputAdditionalAttribute]?
        /// The identifier of the domain in which to search listings.
        public let domainIdentifier: String
        /// Specifies the filters for the search of listings.
        public let filters: FilterClause?
        /// The maximum number of results to return in a single call to SearchListings. When the number of results to be listed is greater than the value of MaxResults, the response contains a NextToken value that you can use in a subsequent call to SearchListings to list the next set of results.
        public let maxResults: Int?
        /// When the number of results is greater than the default value for the MaxResults parameter, or if you explicitly specify a value for MaxResults that is less than the number of results, the response includes a pagination token named NextToken. You can specify this NextToken value in a subsequent call to SearchListings to list the next set of results.
        public let nextToken: String?
        /// The details of the search.
        public let searchIn: [SearchInItem]?
        /// Specifies the text for which to search.
        public let searchText: String?
        /// Specifies the way for sorting the search results.
        public let sort: SearchSort?

        @inlinable
        public init(additionalAttributes: [SearchOutputAdditionalAttribute]? = nil, domainIdentifier: String, filters: FilterClause? = nil, maxResults: Int? = nil, nextToken: String? = nil, searchIn: [SearchInItem]? = nil, searchText: String? = nil, sort: SearchSort? = nil) {
            self.additionalAttributes = additionalAttributes
            self.domainIdentifier = domainIdentifier
            self.filters = filters
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.searchIn = searchIn
            self.searchText = searchText
            self.sort = sort
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.additionalAttributes, forKey: .additionalAttributes)
            request.encodePath(self.domainIdentifier, key: "domainIdentifier")
            try container.encodeIfPresent(self.filters, forKey: .filters)
            try container.encodeIfPresent(self.maxResults, forKey: .maxResults)
            try container.encodeIfPresent(self.nextToken, forKey: .nextToken)
            try container.encodeIfPresent(self.searchIn, forKey: .searchIn)
            try container.encodeIfPresent(self.searchText, forKey: .searchText)
            try container.encodeIfPresent(self.sort, forKey: .sort)
        }

        public func validate(name: String) throws {
            try self.validate(self.domainIdentifier, name: "domainIdentifier", parent: name, pattern: "^dzd[-_][a-zA-Z0-9_-]{1,36}$")
            try self.filters?.validate(name: "\(name).filters")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 50)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 8192)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.searchIn?.forEach {
                try $0.validate(name: "\(name).searchIn[]")
            }
            try self.validate(self.searchIn, name: "searchIn", parent: name, max: 10)
            try self.validate(self.searchIn, name: "searchIn", parent: name, min: 1)
            try self.sort?.validate(name: "\(name).sort")
        }

        private enum CodingKeys: String, CodingKey {
            case additionalAttributes = "additionalAttributes"
            case filters = "filters"
            case maxResults = "maxResults"
            case nextToken = "nextToken"
            case searchIn = "searchIn"
            case searchText = "searchText"
            case sort = "sort"
        }
    }

    public struct SearchListingsOutput: AWSDecodableShape {
        /// The results of the SearchListings action.
        public let items: [SearchResultItem]?
        /// When the number of results is greater than the default value for the MaxResults parameter, or if you explicitly specify a value for MaxResults that is less than the number of results, the response includes a pagination token named NextToken. You can specify this NextToken value in a subsequent call to SearchListings to list the next set of results.
        public let nextToken: String?
        /// Total number of search results.
        public let totalMatchCount: Int?

        @inlinable
        public init(items: [SearchResultItem]? = nil, nextToken: String? = nil, totalMatchCount: Int? = nil) {
            self.items = items
            self.nextToken = nextToken
            self.totalMatchCount = totalMatchCount
        }

        private enum CodingKeys: String, CodingKey {
            case items = "items"
            case nextToken = "nextToken"
            case totalMatchCount = "totalMatchCount"
        }
    }

    public struct SearchOutput: AWSDecodableShape {
        /// The results of the Search action.
        public let items: [SearchInventoryResultItem]?
        /// When the number of results is greater than the default value for the MaxResults parameter, or if you explicitly specify a value for MaxResults that is less than the number of results, the response includes a pagination token named NextToken. You can specify this NextToken value in a subsequent call to Search to list the next set of results.
        public let nextToken: String?
        /// Total number of search results.
        public let totalMatchCount: Int?

        @inlinable
        public init(items: [SearchInventoryResultItem]? = nil, nextToken: String? = nil, totalMatchCount: Int? = nil) {
            self.items = items
            self.nextToken = nextToken
            self.totalMatchCount = totalMatchCount
        }

        private enum CodingKeys: String, CodingKey {
            case items = "items"
            case nextToken = "nextToken"
            case totalMatchCount = "totalMatchCount"
        }
    }

    public struct SearchSort: AWSEncodableShape {
        /// The attribute detail of the way to sort search results.
        public let attribute: String
        /// The order detail of the wya to sort search results.
        public let order: SortOrder?

        @inlinable
        public init(attribute: String, order: SortOrder? = nil) {
            self.attribute = attribute
            self.order = order
        }

        public func validate(name: String) throws {
            try self.validate(self.attribute, name: "attribute", parent: name, max: 128)
            try self.validate(self.attribute, name: "attribute", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case attribute = "attribute"
            case order = "order"
        }
    }

    public struct SearchTypesInput: AWSEncodableShape {
        /// The identifier of the Amazon DataZone domain in which to invoke the SearchTypes action.
        public let domainIdentifier: String
        /// The filters for the SearchTypes action.
        public let filters: FilterClause?
        /// Specifies whether the search is managed.
        public let managed: Bool
        /// The maximum number of results to return in a single call to SearchTypes. When the number of results to be listed is greater than the value of MaxResults, the response contains a NextToken value that you can use in a subsequent call to SearchTypes to list the next set of results.
        public let maxResults: Int?
        /// When the number of results is greater than the default value for the MaxResults parameter, or if you explicitly specify a value for MaxResults that is less than the number of results, the response includes a pagination token named NextToken. You can specify this NextToken value in a subsequent call to SearchTypes to list the next set of results.
        public let nextToken: String?
        /// The details of the search.
        public let searchIn: [SearchInItem]?
        /// Specifies the scope of the search for types.
        public let searchScope: TypesSearchScope
        /// Specifies the text for which to search.
        public let searchText: String?
        /// The specifies the way to sort the SearchTypes results.
        public let sort: SearchSort?

        @inlinable
        public init(domainIdentifier: String, filters: FilterClause? = nil, managed: Bool, maxResults: Int? = nil, nextToken: String? = nil, searchIn: [SearchInItem]? = nil, searchScope: TypesSearchScope, searchText: String? = nil, sort: SearchSort? = nil) {
            self.domainIdentifier = domainIdentifier
            self.filters = filters
            self.managed = managed
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.searchIn = searchIn
            self.searchScope = searchScope
            self.searchText = searchText
            self.sort = sort
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.domainIdentifier, key: "domainIdentifier")
            try container.encodeIfPresent(self.filters, forKey: .filters)
            try container.encode(self.managed, forKey: .managed)
            try container.encodeIfPresent(self.maxResults, forKey: .maxResults)
            try container.encodeIfPresent(self.nextToken, forKey: .nextToken)
            try container.encodeIfPresent(self.searchIn, forKey: .searchIn)
            try container.encode(self.searchScope, forKey: .searchScope)
            try container.encodeIfPresent(self.searchText, forKey: .searchText)
            try container.encodeIfPresent(self.sort, forKey: .sort)
        }

        public func validate(name: String) throws {
            try self.validate(self.domainIdentifier, name: "domainIdentifier", parent: name, pattern: "^dzd[-_][a-zA-Z0-9_-]{1,36}$")
            try self.filters?.validate(name: "\(name).filters")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 50)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 8192)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.searchIn?.forEach {
                try $0.validate(name: "\(name).searchIn[]")
            }
            try self.validate(self.searchIn, name: "searchIn", parent: name, max: 10)
            try self.validate(self.searchIn, name: "searchIn", parent: name, min: 1)
            try self.validate(self.searchText, name: "searchText", parent: name, max: 4096)
            try self.validate(self.searchText, name: "searchText", parent: name, min: 1)
            try self.sort?.validate(name: "\(name).sort")
        }

        private enum CodingKeys: String, CodingKey {
            case filters = "filters"
            case managed = "managed"
            case maxResults = "maxResults"
            case nextToken = "nextToken"
            case searchIn = "searchIn"
            case searchScope = "searchScope"
            case searchText = "searchText"
            case sort = "sort"
        }
    }

    public struct SearchTypesOutput: AWSDecodableShape {
        /// The results of the SearchTypes action.
        public let items: [SearchTypesResultItem]?
        /// When the number of results is greater than the default value for the MaxResults parameter, or if you explicitly specify a value for MaxResults that is less than the number of results, the response includes a pagination token named NextToken. You can specify this NextToken value in a subsequent call to SearchTypes to list the next set of results.
        public let nextToken: String?
        /// Total number of search results.
        public let totalMatchCount: Int?

        @inlinable
        public init(items: [SearchTypesResultItem]? = nil, nextToken: String? = nil, totalMatchCount: Int? = nil) {
            self.items = items
            self.nextToken = nextToken
            self.totalMatchCount = totalMatchCount
        }

        private enum CodingKeys: String, CodingKey {
            case items = "items"
            case nextToken = "nextToken"
            case totalMatchCount = "totalMatchCount"
        }
    }

    public struct SearchUserProfilesInput: AWSEncodableShape {
        /// The identifier of the Amazon DataZone domain in which you want to search user profiles.
        public let domainIdentifier: String
        /// The maximum number of results to return in a single call to SearchUserProfiles. When the number of results to be listed is greater than the value of MaxResults, the response contains a NextToken value that you can use in a subsequent call to SearchUserProfiles to list the next set of results.
        public let maxResults: Int?
        /// When the number of results is greater than the default value for the MaxResults parameter, or if you explicitly specify a value for MaxResults that is less than the number of results, the response includes a pagination token named NextToken. You can specify this NextToken value in a subsequent call to SearchUserProfiles to list the next set of results.
        public let nextToken: String?
        /// Specifies the text for which to search.
        public let searchText: String?
        /// Specifies the user type for the SearchUserProfiles action.
        public let userType: UserSearchType

        @inlinable
        public init(domainIdentifier: String, maxResults: Int? = nil, nextToken: String? = nil, searchText: String? = nil, userType: UserSearchType) {
            self.domainIdentifier = domainIdentifier
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.searchText = searchText
            self.userType = userType
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.domainIdentifier, key: "domainIdentifier")
            try container.encodeIfPresent(self.maxResults, forKey: .maxResults)
            try container.encodeIfPresent(self.nextToken, forKey: .nextToken)
            try container.encodeIfPresent(self.searchText, forKey: .searchText)
            try container.encode(self.userType, forKey: .userType)
        }

        public func validate(name: String) throws {
            try self.validate(self.domainIdentifier, name: "domainIdentifier", parent: name, pattern: "^dzd[-_][a-zA-Z0-9_-]{1,36}$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 50)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 8192)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.searchText, name: "searchText", parent: name, max: 1024)
        }

        private enum CodingKeys: String, CodingKey {
            case maxResults = "maxResults"
            case nextToken = "nextToken"
            case searchText = "searchText"
            case userType = "userType"
        }
    }

    public struct SearchUserProfilesOutput: AWSDecodableShape {
        /// The results of the SearchUserProfiles action.
        public let items: [UserProfileSummary]?
        /// When the number of results is greater than the default value for the MaxResults parameter, or if you explicitly specify a value for MaxResults that is less than the number of results, the response includes a pagination token named NextToken. You can specify this NextToken value in a subsequent call to SearchUserProfiles to list the next set of results.
        public let nextToken: String?

        @inlinable
        public init(items: [UserProfileSummary]? = nil, nextToken: String? = nil) {
            self.items = items
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case items = "items"
            case nextToken = "nextToken"
        }
    }

    public struct SelfGrantStatusDetail: AWSDecodableShape {
        /// The name of the database used for the data source.
        public let databaseName: String
        /// The reason for why the operation failed.
        public let failureCause: String?
        /// The name of the schema used in the data source.
        public let schemaName: String?
        /// The self granting status of the data source.
        public let status: SelfGrantStatus

        @inlinable
        public init(databaseName: String, failureCause: String? = nil, schemaName: String? = nil, status: SelfGrantStatus) {
            self.databaseName = databaseName
            self.failureCause = failureCause
            self.schemaName = schemaName
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case databaseName = "databaseName"
            case failureCause = "failureCause"
            case schemaName = "schemaName"
            case status = "status"
        }
    }

    public struct SingleSignOn: AWSEncodableShape & AWSDecodableShape {
        /// The ARN of the IDC instance.
        public let idcInstanceArn: String?
        /// The type of single sign-on in Amazon DataZone.
        public let type: AuthType?
        /// The single sign-on user assignment in Amazon DataZone.
        public let userAssignment: UserAssignment?

        @inlinable
        public init(idcInstanceArn: String? = nil, type: AuthType? = nil, userAssignment: UserAssignment? = nil) {
            self.idcInstanceArn = idcInstanceArn
            self.type = type
            self.userAssignment = userAssignment
        }

        private enum CodingKeys: String, CodingKey {
            case idcInstanceArn = "idcInstanceArn"
            case type = "type"
            case userAssignment = "userAssignment"
        }
    }

    public struct SparkEmrPropertiesInput: AWSEncodableShape {
        /// The compute ARN of Spark EMR.
        public let computeArn: String?
        /// The instance profile ARN of Spark EMR.
        public let instanceProfileArn: String?
        /// The java virtual env of the Spark EMR.
        public let javaVirtualEnv: String?
        /// The log URI of the Spark EMR.
        public let logUri: String?
        /// The Python virtual env of the Spark EMR.
        public let pythonVirtualEnv: String?
        /// The runtime role of the Spark EMR.
        public let runtimeRole: String?
        /// The certificates S3 URI of the Spark EMR.
        public let trustedCertificatesS3Uri: String?

        @inlinable
        public init(computeArn: String? = nil, instanceProfileArn: String? = nil, javaVirtualEnv: String? = nil, logUri: String? = nil, pythonVirtualEnv: String? = nil, runtimeRole: String? = nil, trustedCertificatesS3Uri: String? = nil) {
            self.computeArn = computeArn
            self.instanceProfileArn = instanceProfileArn
            self.javaVirtualEnv = javaVirtualEnv
            self.logUri = logUri
            self.pythonVirtualEnv = pythonVirtualEnv
            self.runtimeRole = runtimeRole
            self.trustedCertificatesS3Uri = trustedCertificatesS3Uri
        }

        private enum CodingKeys: String, CodingKey {
            case computeArn = "computeArn"
            case instanceProfileArn = "instanceProfileArn"
            case javaVirtualEnv = "javaVirtualEnv"
            case logUri = "logUri"
            case pythonVirtualEnv = "pythonVirtualEnv"
            case runtimeRole = "runtimeRole"
            case trustedCertificatesS3Uri = "trustedCertificatesS3Uri"
        }
    }

    public struct SparkEmrPropertiesOutput: AWSDecodableShape {
        /// The compute ARN of the Spark EMR.
        public let computeArn: String?
        /// The credentials of the Spark EMR.
        public let credentials: UsernamePassword?
        /// The credential expiration of the Spark EMR.
        public let credentialsExpiration: Date?
        /// The governance type of the Spark EMR.
        public let governanceType: GovernanceType?
        /// The instance profile ARN of the Spark EMR.
        public let instanceProfileArn: String?
        /// The Java virtual env of the Spark EMR.
        public let javaVirtualEnv: String?
        /// The livy endpoint of the Spark EMR.
        public let livyEndpoint: String?
        /// The log URI of the Spark EMR.
        public let logUri: String?
        /// The Python virtual env of the Spark EMR.
        public let pythonVirtualEnv: String?
        /// The runtime role of the Spark EMR.
        public let runtimeRole: String?
        /// The trusted certificate S3 URL of the Spark EMR.
        public let trustedCertificatesS3Uri: String?

        @inlinable
        public init(computeArn: String? = nil, credentials: UsernamePassword? = nil, credentialsExpiration: Date? = nil, governanceType: GovernanceType? = nil, instanceProfileArn: String? = nil, javaVirtualEnv: String? = nil, livyEndpoint: String? = nil, logUri: String? = nil, pythonVirtualEnv: String? = nil, runtimeRole: String? = nil, trustedCertificatesS3Uri: String? = nil) {
            self.computeArn = computeArn
            self.credentials = credentials
            self.credentialsExpiration = credentialsExpiration
            self.governanceType = governanceType
            self.instanceProfileArn = instanceProfileArn
            self.javaVirtualEnv = javaVirtualEnv
            self.livyEndpoint = livyEndpoint
            self.logUri = logUri
            self.pythonVirtualEnv = pythonVirtualEnv
            self.runtimeRole = runtimeRole
            self.trustedCertificatesS3Uri = trustedCertificatesS3Uri
        }

        private enum CodingKeys: String, CodingKey {
            case computeArn = "computeArn"
            case credentials = "credentials"
            case credentialsExpiration = "credentialsExpiration"
            case governanceType = "governanceType"
            case instanceProfileArn = "instanceProfileArn"
            case javaVirtualEnv = "javaVirtualEnv"
            case livyEndpoint = "livyEndpoint"
            case logUri = "logUri"
            case pythonVirtualEnv = "pythonVirtualEnv"
            case runtimeRole = "runtimeRole"
            case trustedCertificatesS3Uri = "trustedCertificatesS3Uri"
        }
    }

    public struct SparkEmrPropertiesPatch: AWSEncodableShape {
        /// The compute ARN in the Spark EMR properties patch.
        public let computeArn: String?
        /// The instance profile ARN in the Spark EMR properties patch.
        public let instanceProfileArn: String?
        /// The Java virtual evn in the Spark EMR properties patch.
        public let javaVirtualEnv: String?
        /// The log URI in the Spark EMR properties patch.
        public let logUri: String?
        /// The Python virtual env in the Spark EMR properties patch.
        public let pythonVirtualEnv: String?
        /// The runtime role in the Spark EMR properties patch.
        public let runtimeRole: String?
        /// The trusted certificates S3 URI in the Spark EMR properties patch.
        public let trustedCertificatesS3Uri: String?

        @inlinable
        public init(computeArn: String? = nil, instanceProfileArn: String? = nil, javaVirtualEnv: String? = nil, logUri: String? = nil, pythonVirtualEnv: String? = nil, runtimeRole: String? = nil, trustedCertificatesS3Uri: String? = nil) {
            self.computeArn = computeArn
            self.instanceProfileArn = instanceProfileArn
            self.javaVirtualEnv = javaVirtualEnv
            self.logUri = logUri
            self.pythonVirtualEnv = pythonVirtualEnv
            self.runtimeRole = runtimeRole
            self.trustedCertificatesS3Uri = trustedCertificatesS3Uri
        }

        private enum CodingKeys: String, CodingKey {
            case computeArn = "computeArn"
            case instanceProfileArn = "instanceProfileArn"
            case javaVirtualEnv = "javaVirtualEnv"
            case logUri = "logUri"
            case pythonVirtualEnv = "pythonVirtualEnv"
            case runtimeRole = "runtimeRole"
            case trustedCertificatesS3Uri = "trustedCertificatesS3Uri"
        }
    }

    public struct SparkGlueArgs: AWSEncodableShape & AWSDecodableShape {
        /// The connection in the Spark Amazon Web Services Glue args.
        public let connection: String?

        @inlinable
        public init(connection: String? = nil) {
            self.connection = connection
        }

        private enum CodingKeys: String, CodingKey {
            case connection = "connection"
        }
    }

    public struct SparkGluePropertiesInput: AWSEncodableShape {
        /// The additional args in the Spark Amazon Web Services Glue properties.
        public let additionalArgs: SparkGlueArgs?
        /// The Amazon Web Services Glue connection name in the Spark Amazon Web Services Glue properties.
        public let glueConnectionName: String?
        /// The Amazon Web Services Glue version in the Spark Amazon Web Services Glue properties.
        public let glueVersion: String?
        /// The idle timeout in the Spark Amazon Web Services Glue properties.
        public let idleTimeout: Int?
        /// The Java virtual env in the Spark Amazon Web Services Glue properties.
        public let javaVirtualEnv: String?
        /// The number of workers in the Spark Amazon Web Services Glue properties.
        public let numberOfWorkers: Int?
        /// The Python virtual env in the Spark Amazon Web Services Glue properties.
        public let pythonVirtualEnv: String?
        /// The worker type in the Spark Amazon Web Services Glue properties.
        public let workerType: String?

        @inlinable
        public init(additionalArgs: SparkGlueArgs? = nil, glueConnectionName: String? = nil, glueVersion: String? = nil, idleTimeout: Int? = nil, javaVirtualEnv: String? = nil, numberOfWorkers: Int? = nil, pythonVirtualEnv: String? = nil, workerType: String? = nil) {
            self.additionalArgs = additionalArgs
            self.glueConnectionName = glueConnectionName
            self.glueVersion = glueVersion
            self.idleTimeout = idleTimeout
            self.javaVirtualEnv = javaVirtualEnv
            self.numberOfWorkers = numberOfWorkers
            self.pythonVirtualEnv = pythonVirtualEnv
            self.workerType = workerType
        }

        private enum CodingKeys: String, CodingKey {
            case additionalArgs = "additionalArgs"
            case glueConnectionName = "glueConnectionName"
            case glueVersion = "glueVersion"
            case idleTimeout = "idleTimeout"
            case javaVirtualEnv = "javaVirtualEnv"
            case numberOfWorkers = "numberOfWorkers"
            case pythonVirtualEnv = "pythonVirtualEnv"
            case workerType = "workerType"
        }
    }

    public struct SparkGluePropertiesOutput: AWSDecodableShape {
        /// The additional args in the Spark Amazon Web Services Glue properties.
        public let additionalArgs: SparkGlueArgs?
        /// The Amazon Web Services Glue connection name in the Spark Amazon Web Services Glue properties.
        public let glueConnectionName: String?
        /// The Amazon Web Services Glue version in the Spark Amazon Web Services Glue properties.
        public let glueVersion: String?
        /// The idle timeout in the Spark Amazon Web Services Glue properties.
        public let idleTimeout: Int?
        /// The Java virtual env in the Spark Amazon Web Services Glue properties.
        public let javaVirtualEnv: String?
        /// The number of workers in the Spark Amazon Web Services Glue properties.
        public let numberOfWorkers: Int?
        /// The Python virtual env in the Spark Amazon Web Services Glue properties.
        public let pythonVirtualEnv: String?
        /// The worker type in the Spark Amazon Web Services Glue properties.
        public let workerType: String?

        @inlinable
        public init(additionalArgs: SparkGlueArgs? = nil, glueConnectionName: String? = nil, glueVersion: String? = nil, idleTimeout: Int? = nil, javaVirtualEnv: String? = nil, numberOfWorkers: Int? = nil, pythonVirtualEnv: String? = nil, workerType: String? = nil) {
            self.additionalArgs = additionalArgs
            self.glueConnectionName = glueConnectionName
            self.glueVersion = glueVersion
            self.idleTimeout = idleTimeout
            self.javaVirtualEnv = javaVirtualEnv
            self.numberOfWorkers = numberOfWorkers
            self.pythonVirtualEnv = pythonVirtualEnv
            self.workerType = workerType
        }

        private enum CodingKeys: String, CodingKey {
            case additionalArgs = "additionalArgs"
            case glueConnectionName = "glueConnectionName"
            case glueVersion = "glueVersion"
            case idleTimeout = "idleTimeout"
            case javaVirtualEnv = "javaVirtualEnv"
            case numberOfWorkers = "numberOfWorkers"
            case pythonVirtualEnv = "pythonVirtualEnv"
            case workerType = "workerType"
        }
    }

    public struct SsoUserProfileDetails: AWSDecodableShape {
        /// The first name included in the single sign-on details of the user profile.
        public let firstName: String?
        /// The last name included in the single sign-on details of the user profile.
        public let lastName: String?
        /// The username included in the single sign-on details of the user profile.
        public let username: String?

        @inlinable
        public init(firstName: String? = nil, lastName: String? = nil, username: String? = nil) {
            self.firstName = firstName
            self.lastName = lastName
            self.username = username
        }

        private enum CodingKeys: String, CodingKey {
            case firstName = "firstName"
            case lastName = "lastName"
            case username = "username"
        }
    }

    public struct StartDataSourceRunInput: AWSEncodableShape {
        /// A unique, case-sensitive identifier that is provided to ensure the idempotency of the request.
        public let clientToken: String?
        /// The identifier of the data source.
        public let dataSourceIdentifier: String
        /// The identifier of the Amazon DataZone domain in which to start a data source run.
        public let domainIdentifier: String

        @inlinable
        public init(clientToken: String? = StartDataSourceRunInput.idempotencyToken(), dataSourceIdentifier: String, domainIdentifier: String) {
            self.clientToken = clientToken
            self.dataSourceIdentifier = dataSourceIdentifier
            self.domainIdentifier = domainIdentifier
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.clientToken, forKey: .clientToken)
            request.encodePath(self.dataSourceIdentifier, key: "dataSourceIdentifier")
            request.encodePath(self.domainIdentifier, key: "domainIdentifier")
        }

        public func validate(name: String) throws {
            try self.validate(self.dataSourceIdentifier, name: "dataSourceIdentifier", parent: name, pattern: "^[a-zA-Z0-9_-]{1,36}$")
            try self.validate(self.domainIdentifier, name: "domainIdentifier", parent: name, pattern: "^dzd[-_][a-zA-Z0-9_-]{1,36}$")
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "clientToken"
        }
    }

    public struct StartDataSourceRunOutput: AWSDecodableShape {
        /// The timestamp of when data source run was created.
        @CustomCoding<ISO8601DateCoder>
        public var createdAt: Date
        /// The configuration snapshot of the data source that is being run.
        public let dataSourceConfigurationSnapshot: String?
        /// The identifier of the data source.
        public let dataSourceId: String
        /// The identifier of the Amazon DataZone domain in which to start a data source run.
        public let domainId: String
        /// Specifies the error message that is returned if the operation cannot be successfully completed.
        public let errorMessage: DataSourceErrorMessage?
        /// The identifier of the data source run.
        public let id: String
        /// The identifier of the project.
        public let projectId: String
        /// Specifies run statistics for assets.
        public let runStatisticsForAssets: RunStatisticsForAssets?
        /// The timestamp of when the data source run was started.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var startedAt: Date?
        /// The status of the data source run.
        public let status: DataSourceRunStatus
        /// The timestamp of when the data source run was stopped.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var stoppedAt: Date?
        /// The type of the data source run.
        public let type: DataSourceRunType
        /// The timestamp of when the data source run was updated.
        @CustomCoding<ISO8601DateCoder>
        public var updatedAt: Date

        @inlinable
        public init(createdAt: Date, dataSourceConfigurationSnapshot: String? = nil, dataSourceId: String, domainId: String, errorMessage: DataSourceErrorMessage? = nil, id: String, projectId: String, runStatisticsForAssets: RunStatisticsForAssets? = nil, startedAt: Date? = nil, status: DataSourceRunStatus, stoppedAt: Date? = nil, type: DataSourceRunType, updatedAt: Date) {
            self.createdAt = createdAt
            self.dataSourceConfigurationSnapshot = dataSourceConfigurationSnapshot
            self.dataSourceId = dataSourceId
            self.domainId = domainId
            self.errorMessage = errorMessage
            self.id = id
            self.projectId = projectId
            self.runStatisticsForAssets = runStatisticsForAssets
            self.startedAt = startedAt
            self.status = status
            self.stoppedAt = stoppedAt
            self.type = type
            self.updatedAt = updatedAt
        }

        private enum CodingKeys: String, CodingKey {
            case createdAt = "createdAt"
            case dataSourceConfigurationSnapshot = "dataSourceConfigurationSnapshot"
            case dataSourceId = "dataSourceId"
            case domainId = "domainId"
            case errorMessage = "errorMessage"
            case id = "id"
            case projectId = "projectId"
            case runStatisticsForAssets = "runStatisticsForAssets"
            case startedAt = "startedAt"
            case status = "status"
            case stoppedAt = "stoppedAt"
            case type = "type"
            case updatedAt = "updatedAt"
        }
    }

    public struct StartMetadataGenerationRunInput: AWSEncodableShape {
        /// A unique, case-sensitive identifier to ensure idempotency of the request. This field is automatically populated if not provided.
        public let clientToken: String?
        /// The ID of the Amazon DataZone domain where you want to start a metadata generation run.
        public let domainIdentifier: String
        /// The ID of the project that owns the asset for which you want to start a metadata generation run.
        public let owningProjectIdentifier: String
        /// The asset for which you want to start a metadata generation run.
        public let target: MetadataGenerationRunTarget
        /// The type of the metadata generation run.
        public let type: MetadataGenerationRunType

        @inlinable
        public init(clientToken: String? = StartMetadataGenerationRunInput.idempotencyToken(), domainIdentifier: String, owningProjectIdentifier: String, target: MetadataGenerationRunTarget, type: MetadataGenerationRunType) {
            self.clientToken = clientToken
            self.domainIdentifier = domainIdentifier
            self.owningProjectIdentifier = owningProjectIdentifier
            self.target = target
            self.type = type
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.clientToken, forKey: .clientToken)
            request.encodePath(self.domainIdentifier, key: "domainIdentifier")
            try container.encode(self.owningProjectIdentifier, forKey: .owningProjectIdentifier)
            try container.encode(self.target, forKey: .target)
            try container.encode(self.type, forKey: .type)
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 128)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "^[\\x21-\\x7E]+$")
            try self.validate(self.domainIdentifier, name: "domainIdentifier", parent: name, pattern: "^dzd[-_][a-zA-Z0-9_-]{1,36}$")
            try self.validate(self.owningProjectIdentifier, name: "owningProjectIdentifier", parent: name, pattern: "^[a-zA-Z0-9_-]{1,36}$")
            try self.target.validate(name: "\(name).target")
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "clientToken"
            case owningProjectIdentifier = "owningProjectIdentifier"
            case target = "target"
            case type = "type"
        }
    }

    public struct StartMetadataGenerationRunOutput: AWSDecodableShape {
        /// The timestamp at which the metadata generation run was started.
        public let createdAt: Date?
        /// The ID of the user who started the metadata generation run.
        public let createdBy: String?
        /// The ID of the Amazon DataZone domain in which the metadata generation run was started.
        public let domainId: String
        /// The ID of the metadata generation run.
        public let id: String
        /// The ID of the project that owns the asset for which the metadata generation run was started.
        public let owningProjectId: String?
        /// The status of the metadata generation run.
        public let status: MetadataGenerationRunStatus?
        /// The type of the metadata generation run.
        public let type: MetadataGenerationRunType?

        @inlinable
        public init(createdAt: Date? = nil, createdBy: String? = nil, domainId: String, id: String, owningProjectId: String? = nil, status: MetadataGenerationRunStatus? = nil, type: MetadataGenerationRunType? = nil) {
            self.createdAt = createdAt
            self.createdBy = createdBy
            self.domainId = domainId
            self.id = id
            self.owningProjectId = owningProjectId
            self.status = status
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case createdAt = "createdAt"
            case createdBy = "createdBy"
            case domainId = "domainId"
            case id = "id"
            case owningProjectId = "owningProjectId"
            case status = "status"
            case type = "type"
        }
    }

    public struct SubscribedAsset: AWSDecodableShape {
        /// The identifier of the asset for which the subscription grant is created.
        public let assetId: String
        /// The revision of the asset for which the subscription grant is created.
        public let assetRevision: String
        /// The asset scope of the subscribed asset.
        public let assetScope: AssetScope?
        /// The failure cause included in the details of the asset for which the subscription grant is created.
        public let failureCause: FailureCause?
        /// The failure timestamp included in the details of the asset for which the subscription grant is created.
        public let failureTimestamp: Date?
        /// The timestamp of when the subscription grant to the asset is created.
        public let grantedTimestamp: Date?
        /// The status of the asset for which the subscription grant is created.
        public let status: SubscriptionGrantStatus
        /// The target name of the asset for which the subscription grant is created.
        public let targetName: String?

        @inlinable
        public init(assetId: String, assetRevision: String, assetScope: AssetScope? = nil, failureCause: FailureCause? = nil, failureTimestamp: Date? = nil, grantedTimestamp: Date? = nil, status: SubscriptionGrantStatus, targetName: String? = nil) {
            self.assetId = assetId
            self.assetRevision = assetRevision
            self.assetScope = assetScope
            self.failureCause = failureCause
            self.failureTimestamp = failureTimestamp
            self.grantedTimestamp = grantedTimestamp
            self.status = status
            self.targetName = targetName
        }

        private enum CodingKeys: String, CodingKey {
            case assetId = "assetId"
            case assetRevision = "assetRevision"
            case assetScope = "assetScope"
            case failureCause = "failureCause"
            case failureTimestamp = "failureTimestamp"
            case grantedTimestamp = "grantedTimestamp"
            case status = "status"
            case targetName = "targetName"
        }
    }

    public struct SubscribedAssetListing: AWSDecodableShape {
        /// The asset scope of the subscribed asset listing.
        public let assetScope: AssetScope?
        /// The identifier of the published asset for which the subscription grant is created.
        public let entityId: String?
        /// The revision of the published asset for which the subscription grant is created.
        public let entityRevision: String?
        /// The type of the published asset for which the subscription grant is created.
        public let entityType: String?
        /// The forms attached to the published asset for which the subscription grant is created.
        public let forms: String?
        /// The glossary terms attached to the published asset for which the subscription grant is created.
        public let glossaryTerms: [DetailedGlossaryTerm]?

        @inlinable
        public init(assetScope: AssetScope? = nil, entityId: String? = nil, entityRevision: String? = nil, entityType: String? = nil, forms: String? = nil, glossaryTerms: [DetailedGlossaryTerm]? = nil) {
            self.assetScope = assetScope
            self.entityId = entityId
            self.entityRevision = entityRevision
            self.entityType = entityType
            self.forms = forms
            self.glossaryTerms = glossaryTerms
        }

        private enum CodingKeys: String, CodingKey {
            case assetScope = "assetScope"
            case entityId = "entityId"
            case entityRevision = "entityRevision"
            case entityType = "entityType"
            case forms = "forms"
            case glossaryTerms = "glossaryTerms"
        }
    }

    public struct SubscribedListing: AWSDecodableShape {
        /// The description of the published asset for which the subscription grant is created.
        public let description: String
        /// The identifier of the published asset for which the subscription grant is created.
        public let id: String
        /// The published asset for which the subscription grant is created.
        public let item: SubscribedListingItem
        /// The name of the published asset for which the subscription grant is created.
        public let name: String
        /// The identifier of the project of the published asset for which the subscription grant is created.
        public let ownerProjectId: String
        /// The name of the project that owns the published asset for which the subscription grant is created.
        public let ownerProjectName: String?
        /// The revision of the published asset for which the subscription grant is created.
        public let revision: String?

        @inlinable
        public init(description: String, id: String, item: SubscribedListingItem, name: String, ownerProjectId: String, ownerProjectName: String? = nil, revision: String? = nil) {
            self.description = description
            self.id = id
            self.item = item
            self.name = name
            self.ownerProjectId = ownerProjectId
            self.ownerProjectName = ownerProjectName
            self.revision = revision
        }

        private enum CodingKeys: String, CodingKey {
            case description = "description"
            case id = "id"
            case item = "item"
            case name = "name"
            case ownerProjectId = "ownerProjectId"
            case ownerProjectName = "ownerProjectName"
            case revision = "revision"
        }
    }

    public struct SubscribedListingInput: AWSEncodableShape {
        /// The identifier of the published asset for which the subscription grant is to be created.
        public let identifier: String

        @inlinable
        public init(identifier: String) {
            self.identifier = identifier
        }

        public func validate(name: String) throws {
            try self.validate(self.identifier, name: "identifier", parent: name, pattern: "^[a-zA-Z0-9_-]{1,36}$")
        }

        private enum CodingKeys: String, CodingKey {
            case identifier = "identifier"
        }
    }

    public struct SubscribedProductListing: AWSDecodableShape {
        /// The data assets of the data product listing.
        public let assetListings: [AssetInDataProductListingItem]?
        /// The description of the data product listing.
        public let description: String?
        /// The ID of the data product listing.
        public let entityId: String?
        /// The revision of the data product listing.
        public let entityRevision: String?
        /// The glossary terms of the data product listing.
        public let glossaryTerms: [DetailedGlossaryTerm]?
        /// The name of the data product listing.
        public let name: String?

        @inlinable
        public init(assetListings: [AssetInDataProductListingItem]? = nil, description: String? = nil, entityId: String? = nil, entityRevision: String? = nil, glossaryTerms: [DetailedGlossaryTerm]? = nil, name: String? = nil) {
            self.assetListings = assetListings
            self.description = description
            self.entityId = entityId
            self.entityRevision = entityRevision
            self.glossaryTerms = glossaryTerms
            self.name = name
        }

        private enum CodingKeys: String, CodingKey {
            case assetListings = "assetListings"
            case description = "description"
            case entityId = "entityId"
            case entityRevision = "entityRevision"
            case glossaryTerms = "glossaryTerms"
            case name = "name"
        }
    }

    public struct SubscribedProject: AWSDecodableShape {
        /// The identifier of the project that has the subscription grant.
        public let id: String?
        /// The name of the project that has the subscription grant.
        public let name: String?

        @inlinable
        public init(id: String? = nil, name: String? = nil) {
            self.id = id
            self.name = name
        }

        private enum CodingKeys: String, CodingKey {
            case id = "id"
            case name = "name"
        }
    }

    public struct SubscribedProjectInput: AWSEncodableShape {
        /// The identifier of the project that is to be given a subscription grant.
        public let identifier: String?

        @inlinable
        public init(identifier: String? = nil) {
            self.identifier = identifier
        }

        public func validate(name: String) throws {
            try self.validate(self.identifier, name: "identifier", parent: name, pattern: "^[a-zA-Z0-9_-]{1,36}$")
        }

        private enum CodingKeys: String, CodingKey {
            case identifier = "identifier"
        }
    }

    public struct SubscriptionGrantSummary: AWSDecodableShape {
        /// The assets included in the subscription grant.
        public let assets: [SubscribedAsset]?
        /// The timestamp of when a subscription grant was created.
        public let createdAt: Date
        /// The datazone user who created the subscription grant.
        public let createdBy: String
        /// The identifier of the Amazon DataZone domain in which a subscription grant exists.
        public let domainId: String
        /// The entity to which the subscription is granted.
        public let grantedEntity: GrantedEntity
        /// The identifier of the subscription grant.
        public let id: String
        /// The status of the subscription grant.
        public let status: SubscriptionGrantOverallStatus
        /// The ID of the subscription.
        public let subscriptionId: String?
        /// The identifier of the target of the subscription grant.
        public let subscriptionTargetId: String
        /// The timestampf of when the subscription grant was updated.
        public let updatedAt: Date
        /// The Amazon DataZone user who updated the subscription grant.
        public let updatedBy: String?

        @inlinable
        public init(assets: [SubscribedAsset]? = nil, createdAt: Date, createdBy: String, domainId: String, grantedEntity: GrantedEntity, id: String, status: SubscriptionGrantOverallStatus, subscriptionTargetId: String, updatedAt: Date, updatedBy: String? = nil) {
            self.assets = assets
            self.createdAt = createdAt
            self.createdBy = createdBy
            self.domainId = domainId
            self.grantedEntity = grantedEntity
            self.id = id
            self.status = status
            self.subscriptionId = nil
            self.subscriptionTargetId = subscriptionTargetId
            self.updatedAt = updatedAt
            self.updatedBy = updatedBy
        }

        @available(*, deprecated, message: "Members subscriptionId have been deprecated")
        @inlinable
        public init(assets: [SubscribedAsset]? = nil, createdAt: Date, createdBy: String, domainId: String, grantedEntity: GrantedEntity, id: String, status: SubscriptionGrantOverallStatus, subscriptionId: String? = nil, subscriptionTargetId: String, updatedAt: Date, updatedBy: String? = nil) {
            self.assets = assets
            self.createdAt = createdAt
            self.createdBy = createdBy
            self.domainId = domainId
            self.grantedEntity = grantedEntity
            self.id = id
            self.status = status
            self.subscriptionId = subscriptionId
            self.subscriptionTargetId = subscriptionTargetId
            self.updatedAt = updatedAt
            self.updatedBy = updatedBy
        }

        private enum CodingKeys: String, CodingKey {
            case assets = "assets"
            case createdAt = "createdAt"
            case createdBy = "createdBy"
            case domainId = "domainId"
            case grantedEntity = "grantedEntity"
            case id = "id"
            case status = "status"
            case subscriptionId = "subscriptionId"
            case subscriptionTargetId = "subscriptionTargetId"
            case updatedAt = "updatedAt"
            case updatedBy = "updatedBy"
        }
    }

    public struct SubscriptionRequestSummary: AWSDecodableShape {
        /// The timestamp of when a subscription request was created.
        public let createdAt: Date
        /// The Amazon DataZone user who created the subscription request.
        public let createdBy: String
        /// The decision comment of the subscription request.
        public let decisionComment: String?
        /// The identifier of the Amazon DataZone domain in which a subscription request exists.
        public let domainId: String
        /// The ID of the existing subscription.
        public let existingSubscriptionId: String?
        /// The identifier of the subscription request.
        public let id: String
        /// The summary of the metadata forms.
        public let metadataFormsSummary: [MetadataFormSummary]?
        /// The reason for the subscription request.
        public let requestReason: String
        /// The identifier of the subscription request reviewer.
        public let reviewerId: String?
        /// The status of the subscription request.
        public let status: SubscriptionRequestStatus
        /// The listings included in the subscription request.
        public let subscribedListings: [SubscribedListing]
        /// The principals included in the subscription request.
        public let subscribedPrincipals: [SubscribedPrincipal]
        /// The timestamp of when the subscription request was updated.
        public let updatedAt: Date
        /// The identifier of the Amazon DataZone user who updated the subscription request.
        public let updatedBy: String?

        @inlinable
        public init(createdAt: Date, createdBy: String, decisionComment: String? = nil, domainId: String, existingSubscriptionId: String? = nil, id: String, metadataFormsSummary: [MetadataFormSummary]? = nil, requestReason: String, reviewerId: String? = nil, status: SubscriptionRequestStatus, subscribedListings: [SubscribedListing], subscribedPrincipals: [SubscribedPrincipal], updatedAt: Date, updatedBy: String? = nil) {
            self.createdAt = createdAt
            self.createdBy = createdBy
            self.decisionComment = decisionComment
            self.domainId = domainId
            self.existingSubscriptionId = existingSubscriptionId
            self.id = id
            self.metadataFormsSummary = metadataFormsSummary
            self.requestReason = requestReason
            self.reviewerId = reviewerId
            self.status = status
            self.subscribedListings = subscribedListings
            self.subscribedPrincipals = subscribedPrincipals
            self.updatedAt = updatedAt
            self.updatedBy = updatedBy
        }

        private enum CodingKeys: String, CodingKey {
            case createdAt = "createdAt"
            case createdBy = "createdBy"
            case decisionComment = "decisionComment"
            case domainId = "domainId"
            case existingSubscriptionId = "existingSubscriptionId"
            case id = "id"
            case metadataFormsSummary = "metadataFormsSummary"
            case requestReason = "requestReason"
            case reviewerId = "reviewerId"
            case status = "status"
            case subscribedListings = "subscribedListings"
            case subscribedPrincipals = "subscribedPrincipals"
            case updatedAt = "updatedAt"
            case updatedBy = "updatedBy"
        }
    }

    public struct SubscriptionSummary: AWSDecodableShape {
        /// The timestamp of when the subscription was created.
        public let createdAt: Date
        /// The Amazon DataZone user who created the subscription.
        public let createdBy: String
        /// The identifier of the Amazon DataZone domain in which a subscription exists.
        public let domainId: String
        /// The identifier of the subscription.
        public let id: String
        /// The retain permissions included in the subscription.
        public let retainPermissions: Bool?
        /// The status of the subscription.
        public let status: SubscriptionStatus
        /// The listing included in the subscription.
        public let subscribedListing: SubscribedListing
        /// The principal included in the subscription.
        public let subscribedPrincipal: SubscribedPrincipal
        /// The identifier of the subscription request for the subscription.
        public let subscriptionRequestId: String?
        /// The timestamp of when the subscription was updated.
        public let updatedAt: Date
        /// The Amazon DataZone user who updated the subscription.
        public let updatedBy: String?

        @inlinable
        public init(createdAt: Date, createdBy: String, domainId: String, id: String, retainPermissions: Bool? = nil, status: SubscriptionStatus, subscribedListing: SubscribedListing, subscribedPrincipal: SubscribedPrincipal, subscriptionRequestId: String? = nil, updatedAt: Date, updatedBy: String? = nil) {
            self.createdAt = createdAt
            self.createdBy = createdBy
            self.domainId = domainId
            self.id = id
            self.retainPermissions = retainPermissions
            self.status = status
            self.subscribedListing = subscribedListing
            self.subscribedPrincipal = subscribedPrincipal
            self.subscriptionRequestId = subscriptionRequestId
            self.updatedAt = updatedAt
            self.updatedBy = updatedBy
        }

        private enum CodingKeys: String, CodingKey {
            case createdAt = "createdAt"
            case createdBy = "createdBy"
            case domainId = "domainId"
            case id = "id"
            case retainPermissions = "retainPermissions"
            case status = "status"
            case subscribedListing = "subscribedListing"
            case subscribedPrincipal = "subscribedPrincipal"
            case subscriptionRequestId = "subscriptionRequestId"
            case updatedAt = "updatedAt"
            case updatedBy = "updatedBy"
        }
    }

    public struct SubscriptionTargetForm: AWSEncodableShape & AWSDecodableShape {
        /// The content of the subscription target configuration.
        public let content: String
        /// The form name included in the subscription target configuration.
        public let formName: String

        @inlinable
        public init(content: String, formName: String) {
            self.content = content
            self.formName = formName
        }

        public func validate(name: String) throws {
            try self.validate(self.formName, name: "formName", parent: name, max: 128)
            try self.validate(self.formName, name: "formName", parent: name, min: 1)
            try self.validate(self.formName, name: "formName", parent: name, pattern: "^(?![0-9_])\\w+$|^_\\w*[a-zA-Z0-9]\\w*$")
        }

        private enum CodingKeys: String, CodingKey {
            case content = "content"
            case formName = "formName"
        }
    }

    public struct SubscriptionTargetSummary: AWSDecodableShape {
        /// The asset types included in the subscription target.
        public let applicableAssetTypes: [String]
        /// The authorized principals included in the subscription target.
        public let authorizedPrincipals: [String]
        /// The timestamp of when the subscription target was created.
        public let createdAt: Date
        /// The Amazon DataZone user who created the subscription target.
        public let createdBy: String
        /// The identifier of the Amazon DataZone domain in which the subscription target exists.
        public let domainId: String
        /// The identifier of the environment of the subscription target.
        public let environmentId: String
        /// The identifier of the subscription target.
        public let id: String
        /// The manage access role specified in the subscription target.
        public let manageAccessRole: String?
        /// The name of the subscription target.
        public let name: String
        /// The identifier of the project specified in the subscription target.
        public let projectId: String
        /// The provider of the subscription target.
        public let provider: String
        /// The configuration of the subscription target.
        public let subscriptionTargetConfig: [SubscriptionTargetForm]
        /// The type of the subscription target.
        public let type: String
        /// The timestamp of when the subscription target was updated.
        public let updatedAt: Date?
        /// The Amazon DataZone user who updated the subscription target.
        public let updatedBy: String?

        @inlinable
        public init(applicableAssetTypes: [String], authorizedPrincipals: [String], createdAt: Date, createdBy: String, domainId: String, environmentId: String, id: String, manageAccessRole: String? = nil, name: String, projectId: String, provider: String, subscriptionTargetConfig: [SubscriptionTargetForm], type: String, updatedAt: Date? = nil, updatedBy: String? = nil) {
            self.applicableAssetTypes = applicableAssetTypes
            self.authorizedPrincipals = authorizedPrincipals
            self.createdAt = createdAt
            self.createdBy = createdBy
            self.domainId = domainId
            self.environmentId = environmentId
            self.id = id
            self.manageAccessRole = manageAccessRole
            self.name = name
            self.projectId = projectId
            self.provider = provider
            self.subscriptionTargetConfig = subscriptionTargetConfig
            self.type = type
            self.updatedAt = updatedAt
            self.updatedBy = updatedBy
        }

        private enum CodingKeys: String, CodingKey {
            case applicableAssetTypes = "applicableAssetTypes"
            case authorizedPrincipals = "authorizedPrincipals"
            case createdAt = "createdAt"
            case createdBy = "createdBy"
            case domainId = "domainId"
            case environmentId = "environmentId"
            case id = "id"
            case manageAccessRole = "manageAccessRole"
            case name = "name"
            case projectId = "projectId"
            case provider = "provider"
            case subscriptionTargetConfig = "subscriptionTargetConfig"
            case type = "type"
            case updatedAt = "updatedAt"
            case updatedBy = "updatedBy"
        }
    }

    public struct TagResourceRequest: AWSEncodableShape {
        /// The ARN of the resource to be tagged in Amazon DataZone.
        public let resourceArn: String
        /// Specifies the tags for the TagResource action.
        public let tags: [String: String]

        @inlinable
        public init(resourceArn: String, tags: [String: String]) {
            self.resourceArn = resourceArn
            self.tags = tags
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.resourceArn, key: "resourceArn")
            try container.encode(self.tags, forKey: .tags)
        }

        public func validate(name: String) throws {
            try self.tags.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.key, name: "tags.key", parent: name, pattern: "^[\\w \\.:/=+@-]+$")
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, pattern: "^[\\w \\.:/=+@-]*$")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case tags = "tags"
        }
    }

    public struct TagResourceResponse: AWSDecodableShape {
        public init() {}
    }

    public struct TermRelations: AWSEncodableShape & AWSDecodableShape {
        /// The classifies of the term relations.
        public let classifies: [String]?
        /// The isA property of the term relations.
        public let isA: [String]?

        @inlinable
        public init(classifies: [String]? = nil, isA: [String]? = nil) {
            self.classifies = classifies
            self.isA = isA
        }

        public func validate(name: String) throws {
            try self.classifies?.forEach {
                try validate($0, name: "classifies[]", parent: name, pattern: "^[a-zA-Z0-9_-]{1,36}$")
            }
            try self.validate(self.classifies, name: "classifies", parent: name, max: 20)
            try self.validate(self.classifies, name: "classifies", parent: name, min: 1)
            try self.isA?.forEach {
                try validate($0, name: "isA[]", parent: name, pattern: "^[a-zA-Z0-9_-]{1,36}$")
            }
            try self.validate(self.isA, name: "isA", parent: name, max: 20)
            try self.validate(self.isA, name: "isA", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case classifies = "classifies"
            case isA = "isA"
        }
    }

    public struct TimeSeriesDataPointFormInput: AWSEncodableShape {
        /// The content of the time series data points form.
        public let content: String?
        /// The name of the time series data points form.
        public let formName: String
        /// The timestamp of the time series data points form.
        public let timestamp: Date
        /// The ID of the type of the time series data points form.
        public let typeIdentifier: String
        /// The revision type of the time series data points form.
        public let typeRevision: String?

        @inlinable
        public init(content: String? = nil, formName: String, timestamp: Date, typeIdentifier: String, typeRevision: String? = nil) {
            self.content = content
            self.formName = formName
            self.timestamp = timestamp
            self.typeIdentifier = typeIdentifier
            self.typeRevision = typeRevision
        }

        public func validate(name: String) throws {
            try self.validate(self.formName, name: "formName", parent: name, max: 128)
            try self.validate(self.formName, name: "formName", parent: name, min: 1)
            try self.validate(self.typeIdentifier, name: "typeIdentifier", parent: name, max: 385)
            try self.validate(self.typeIdentifier, name: "typeIdentifier", parent: name, min: 1)
            try self.validate(self.typeIdentifier, name: "typeIdentifier", parent: name, pattern: "^(?!\\.)[\\w\\.]*\\w$")
            try self.validate(self.typeRevision, name: "typeRevision", parent: name, max: 64)
            try self.validate(self.typeRevision, name: "typeRevision", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case content = "content"
            case formName = "formName"
            case timestamp = "timestamp"
            case typeIdentifier = "typeIdentifier"
            case typeRevision = "typeRevision"
        }
    }

    public struct TimeSeriesDataPointFormOutput: AWSDecodableShape {
        /// The content of the time series data points form.
        public let content: String?
        /// The name of the time series data points form.
        public let formName: String
        /// The ID of the time series data points form.
        public let id: String?
        /// The timestamp of the time series data points form.
        public let timestamp: Date
        /// The ID of the type of the time series data points form.
        public let typeIdentifier: String
        /// The revision type of the time series data points form.
        public let typeRevision: String?

        @inlinable
        public init(content: String? = nil, formName: String, id: String? = nil, timestamp: Date, typeIdentifier: String, typeRevision: String? = nil) {
            self.content = content
            self.formName = formName
            self.id = id
            self.timestamp = timestamp
            self.typeIdentifier = typeIdentifier
            self.typeRevision = typeRevision
        }

        private enum CodingKeys: String, CodingKey {
            case content = "content"
            case formName = "formName"
            case id = "id"
            case timestamp = "timestamp"
            case typeIdentifier = "typeIdentifier"
            case typeRevision = "typeRevision"
        }
    }

    public struct TimeSeriesDataPointSummaryFormOutput: AWSDecodableShape {
        /// The content of the summary of the time series data points form.
        public let contentSummary: String?
        /// The name of the time series data points summary form.
        public let formName: String
        /// The ID of the time series data points summary form.
        public let id: String?
        /// The timestamp of the time series data points summary form.
        public let timestamp: Date
        /// The type ID of the time series data points summary form.
        public let typeIdentifier: String
        /// The type revision of the time series data points summary form.
        public let typeRevision: String?

        @inlinable
        public init(contentSummary: String? = nil, formName: String, id: String? = nil, timestamp: Date, typeIdentifier: String, typeRevision: String? = nil) {
            self.contentSummary = contentSummary
            self.formName = formName
            self.id = id
            self.timestamp = timestamp
            self.typeIdentifier = typeIdentifier
            self.typeRevision = typeRevision
        }

        private enum CodingKeys: String, CodingKey {
            case contentSummary = "contentSummary"
            case formName = "formName"
            case id = "id"
            case timestamp = "timestamp"
            case typeIdentifier = "typeIdentifier"
            case typeRevision = "typeRevision"
        }
    }

    public struct Topic: AWSDecodableShape {
        public let resource: NotificationResource
        /// The role of the resource mentioned in a notification.
        public let role: NotificationRole
        /// The subject of the resource mentioned in a notification.
        public let subject: String

        @inlinable
        public init(resource: NotificationResource, role: NotificationRole, subject: String) {
            self.resource = resource
            self.role = role
            self.subject = subject
        }

        private enum CodingKeys: String, CodingKey {
            case resource = "resource"
            case role = "role"
            case subject = "subject"
        }
    }

    public struct Unit: AWSEncodableShape & AWSDecodableShape {
        public init() {}
    }

    public struct UntagResourceRequest: AWSEncodableShape {
        /// The ARN of the resource to be untagged in Amazon DataZone.
        public let resourceArn: String
        /// Specifies the tag keys for the UntagResource action.
        public let tagKeys: [String]

        @inlinable
        public init(resourceArn: String, tagKeys: [String]) {
            self.resourceArn = resourceArn
            self.tagKeys = tagKeys
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.resourceArn, key: "resourceArn")
            request.encodeQuery(self.tagKeys, key: "tagKeys")
        }

        public func validate(name: String) throws {
            try self.tagKeys.forEach {
                try validate($0, name: "tagKeys[]", parent: name, max: 128)
                try validate($0, name: "tagKeys[]", parent: name, min: 1)
                try validate($0, name: "tagKeys[]", parent: name, pattern: "^[\\w \\.:/=+@-]+$")
            }
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct UntagResourceResponse: AWSDecodableShape {
        public init() {}
    }

    public struct UpdateAssetFilterInput: AWSEncodableShape {
        /// The ID of the data asset.
        public let assetIdentifier: String
        /// The configuration of the asset filter.
        public let configuration: AssetFilterConfiguration?
        /// The description of the asset filter.
        public let description: String?
        /// The ID of the domain where you want to update an asset filter.
        public let domainIdentifier: String
        /// The ID of the asset filter.
        public let identifier: String
        /// The name of the asset filter.
        public let name: String?

        @inlinable
        public init(assetIdentifier: String, configuration: AssetFilterConfiguration? = nil, description: String? = nil, domainIdentifier: String, identifier: String, name: String? = nil) {
            self.assetIdentifier = assetIdentifier
            self.configuration = configuration
            self.description = description
            self.domainIdentifier = domainIdentifier
            self.identifier = identifier
            self.name = name
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.assetIdentifier, key: "assetIdentifier")
            try container.encodeIfPresent(self.configuration, forKey: .configuration)
            try container.encodeIfPresent(self.description, forKey: .description)
            request.encodePath(self.domainIdentifier, key: "domainIdentifier")
            request.encodePath(self.identifier, key: "identifier")
            try container.encodeIfPresent(self.name, forKey: .name)
        }

        public func validate(name: String) throws {
            try self.validate(self.assetIdentifier, name: "assetIdentifier", parent: name, pattern: "^[a-zA-Z0-9_-]{1,36}$")
            try self.validate(self.description, name: "description", parent: name, max: 2048)
            try self.validate(self.domainIdentifier, name: "domainIdentifier", parent: name, pattern: "^dzd[-_][a-zA-Z0-9_-]{1,36}$")
            try self.validate(self.identifier, name: "identifier", parent: name, pattern: "^[a-zA-Z0-9_-]{1,36}$")
        }

        private enum CodingKeys: String, CodingKey {
            case configuration = "configuration"
            case description = "description"
            case name = "name"
        }
    }

    public struct UpdateAssetFilterOutput: AWSDecodableShape {
        /// The ID of the data asset.
        public let assetId: String
        /// The configuration of the asset filter.
        public let configuration: AssetFilterConfiguration
        /// The timestamp at which the asset filter was created.
        public let createdAt: Date?
        /// The description of the asset filter.
        public let description: String?
        /// The ID of the domain where the asset filter was created.
        public let domainId: String
        /// The column names of the asset filter.
        public let effectiveColumnNames: [String]?
        /// The row filter of the asset filter.
        public let effectiveRowFilter: String?
        /// The error message that is displayed if the action is not completed successfully.
        public let errorMessage: String?
        /// The ID of the asset filter.
        public let id: String
        /// The name of the asset filter.
        public let name: String
        /// The status of the asset filter.
        public let status: FilterStatus?

        @inlinable
        public init(assetId: String, configuration: AssetFilterConfiguration, createdAt: Date? = nil, description: String? = nil, domainId: String, effectiveColumnNames: [String]? = nil, effectiveRowFilter: String? = nil, errorMessage: String? = nil, id: String, name: String, status: FilterStatus? = nil) {
            self.assetId = assetId
            self.configuration = configuration
            self.createdAt = createdAt
            self.description = description
            self.domainId = domainId
            self.effectiveColumnNames = effectiveColumnNames
            self.effectiveRowFilter = effectiveRowFilter
            self.errorMessage = errorMessage
            self.id = id
            self.name = name
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case assetId = "assetId"
            case configuration = "configuration"
            case createdAt = "createdAt"
            case description = "description"
            case domainId = "domainId"
            case effectiveColumnNames = "effectiveColumnNames"
            case effectiveRowFilter = "effectiveRowFilter"
            case errorMessage = "errorMessage"
            case id = "id"
            case name = "name"
            case status = "status"
        }
    }

    public struct UpdateConnectionInput: AWSEncodableShape {
        /// The location where a connection is to be updated.
        public let awsLocation: AwsLocation?
        /// The description of a connection.
        public let description: String?
        /// The ID of the domain where a connection is to be updated.
        public let domainIdentifier: String
        /// The ID of the connection to be updated.
        public let identifier: String
        /// The connection props.
        public let props: ConnectionPropertiesPatch?

        @inlinable
        public init(awsLocation: AwsLocation? = nil, description: String? = nil, domainIdentifier: String, identifier: String, props: ConnectionPropertiesPatch? = nil) {
            self.awsLocation = awsLocation
            self.description = description
            self.domainIdentifier = domainIdentifier
            self.identifier = identifier
            self.props = props
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.awsLocation, forKey: .awsLocation)
            try container.encodeIfPresent(self.description, forKey: .description)
            request.encodePath(self.domainIdentifier, key: "domainIdentifier")
            request.encodePath(self.identifier, key: "identifier")
            try container.encodeIfPresent(self.props, forKey: .props)
        }

        public func validate(name: String) throws {
            try self.awsLocation?.validate(name: "\(name).awsLocation")
            try self.validate(self.description, name: "description", parent: name, max: 2048)
            try self.validate(self.domainIdentifier, name: "domainIdentifier", parent: name, pattern: "^dzd[-_][a-zA-Z0-9_-]{1,36}$")
            try self.validate(self.identifier, name: "identifier", parent: name, max: 128)
            try self.props?.validate(name: "\(name).props")
        }

        private enum CodingKeys: String, CodingKey {
            case awsLocation = "awsLocation"
            case description = "description"
            case props = "props"
        }
    }

    public struct UpdateConnectionOutput: AWSDecodableShape {
        /// The ID of the connection.
        public let connectionId: String
        /// The connection description.
        public let description: String?
        /// The ID of the domain where a connection is to be updated.
        public let domainId: String
        /// The ID of the domain unit where a connection is to be updated.
        public let domainUnitId: String
        /// The ID of the environment where a connection is to be updated.
        public let environmentId: String?
        /// The name of the connection.
        public let name: String
        /// The physical endpoints of the connection.
        public let physicalEndpoints: [PhysicalEndpoint]
        /// The project ID of the connection.
        public let projectId: String?
        /// The connection props.
        public let props: ConnectionPropertiesOutput?
        /// The connection type.
        public let type: ConnectionType

        @inlinable
        public init(connectionId: String, description: String? = nil, domainId: String, domainUnitId: String, environmentId: String? = nil, name: String, physicalEndpoints: [PhysicalEndpoint], projectId: String? = nil, props: ConnectionPropertiesOutput? = nil, type: ConnectionType) {
            self.connectionId = connectionId
            self.description = description
            self.domainId = domainId
            self.domainUnitId = domainUnitId
            self.environmentId = environmentId
            self.name = name
            self.physicalEndpoints = physicalEndpoints
            self.projectId = projectId
            self.props = props
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case connectionId = "connectionId"
            case description = "description"
            case domainId = "domainId"
            case domainUnitId = "domainUnitId"
            case environmentId = "environmentId"
            case name = "name"
            case physicalEndpoints = "physicalEndpoints"
            case projectId = "projectId"
            case props = "props"
            case type = "type"
        }
    }

    public struct UpdateDataSourceInput: AWSEncodableShape {
        /// The asset forms to be updated as part of the UpdateDataSource action.
        public let assetFormsInput: [FormInput]?
        /// The configuration to be updated as part of the UpdateDataSource action.
        public let configuration: DataSourceConfigurationInput?
        /// The description to be updated as part of the UpdateDataSource action.
        public let description: String?
        /// The identifier of the domain in which to update a data source.
        public let domainIdentifier: String
        /// The enable setting to be updated as part of the UpdateDataSource action.
        public let enableSetting: EnableSetting?
        /// The identifier of the data source to be updated.
        public let identifier: String
        /// The name to be updated as part of the UpdateDataSource action.
        public let name: String?
        /// The publish on import setting to be updated as part of the UpdateDataSource action.
        public let publishOnImport: Bool?
        /// The recommendation to be updated as part of the UpdateDataSource action.
        public let recommendation: RecommendationConfiguration?
        /// Specifies that the granted permissions are retained in case of a self-subscribe functionality failure for a data source.
        public let retainPermissionsOnRevokeFailure: Bool?
        /// The schedule to be updated as part of the UpdateDataSource action.
        public let schedule: ScheduleConfiguration?

        @inlinable
        public init(assetFormsInput: [FormInput]? = nil, configuration: DataSourceConfigurationInput? = nil, description: String? = nil, domainIdentifier: String, enableSetting: EnableSetting? = nil, identifier: String, name: String? = nil, publishOnImport: Bool? = nil, recommendation: RecommendationConfiguration? = nil, retainPermissionsOnRevokeFailure: Bool? = nil, schedule: ScheduleConfiguration? = nil) {
            self.assetFormsInput = assetFormsInput
            self.configuration = configuration
            self.description = description
            self.domainIdentifier = domainIdentifier
            self.enableSetting = enableSetting
            self.identifier = identifier
            self.name = name
            self.publishOnImport = publishOnImport
            self.recommendation = recommendation
            self.retainPermissionsOnRevokeFailure = retainPermissionsOnRevokeFailure
            self.schedule = schedule
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.assetFormsInput, forKey: .assetFormsInput)
            try container.encodeIfPresent(self.configuration, forKey: .configuration)
            try container.encodeIfPresent(self.description, forKey: .description)
            request.encodePath(self.domainIdentifier, key: "domainIdentifier")
            try container.encodeIfPresent(self.enableSetting, forKey: .enableSetting)
            request.encodePath(self.identifier, key: "identifier")
            try container.encodeIfPresent(self.name, forKey: .name)
            try container.encodeIfPresent(self.publishOnImport, forKey: .publishOnImport)
            try container.encodeIfPresent(self.recommendation, forKey: .recommendation)
            try container.encodeIfPresent(self.retainPermissionsOnRevokeFailure, forKey: .retainPermissionsOnRevokeFailure)
            try container.encodeIfPresent(self.schedule, forKey: .schedule)
        }

        public func validate(name: String) throws {
            try self.assetFormsInput?.forEach {
                try $0.validate(name: "\(name).assetFormsInput[]")
            }
            try self.validate(self.assetFormsInput, name: "assetFormsInput", parent: name, max: 10)
            try self.configuration?.validate(name: "\(name).configuration")
            try self.validate(self.description, name: "description", parent: name, max: 2048)
            try self.validate(self.domainIdentifier, name: "domainIdentifier", parent: name, pattern: "^dzd[-_][a-zA-Z0-9_-]{1,36}$")
            try self.validate(self.identifier, name: "identifier", parent: name, pattern: "^[a-zA-Z0-9_-]{1,36}$")
            try self.validate(self.name, name: "name", parent: name, max: 256)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.schedule?.validate(name: "\(name).schedule")
        }

        private enum CodingKeys: String, CodingKey {
            case assetFormsInput = "assetFormsInput"
            case configuration = "configuration"
            case description = "description"
            case enableSetting = "enableSetting"
            case name = "name"
            case publishOnImport = "publishOnImport"
            case recommendation = "recommendation"
            case retainPermissionsOnRevokeFailure = "retainPermissionsOnRevokeFailure"
            case schedule = "schedule"
        }
    }

    public struct UpdateDataSourceOutput: AWSDecodableShape {
        /// The asset forms to be updated as part of the UpdateDataSource action.
        public let assetFormsOutput: [FormOutput]?
        /// The configuration to be updated as part of the UpdateDataSource action.
        public let configuration: DataSourceConfigurationOutput?
        /// The connection ID.
        public let connectionId: String?
        /// The timestamp of when the data source was updated.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var createdAt: Date?
        /// The description to be updated as part of the UpdateDataSource action.
        public let description: String?
        /// The identifier of the Amazon DataZone domain in which a data source is to be updated.
        public let domainId: String
        /// The enable setting to be updated as part of the UpdateDataSource action.
        public let enableSetting: EnableSetting?
        /// The identifier of the environment in which a data source is to be updated.
        public let environmentId: String?
        /// Specifies the error message that is returned if the operation cannot be successfully completed.
        public let errorMessage: DataSourceErrorMessage?
        /// The identifier of the data source to be updated.
        public let id: String
        /// The timestamp of when the data source was last run.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var lastRunAt: Date?
        /// The last run error message of the data source.
        public let lastRunErrorMessage: DataSourceErrorMessage?
        /// The last run status of the data source.
        public let lastRunStatus: DataSourceRunStatus?
        /// The name to be updated as part of the UpdateDataSource action.
        public let name: String
        /// The identifier of the project where data source is to be updated.
        public let projectId: String
        /// The publish on import setting to be updated as part of the UpdateDataSource action.
        public let publishOnImport: Bool?
        /// The recommendation to be updated as part of the UpdateDataSource action.
        public let recommendation: RecommendationConfiguration?
        /// Specifies that the granted permissions are retained in case of a self-subscribe functionality failure for a data source.
        public let retainPermissionsOnRevokeFailure: Bool?
        /// The schedule to be updated as part of the UpdateDataSource action.
        public let schedule: ScheduleConfiguration?
        /// Specifies the status of the self-granting functionality.
        public let selfGrantStatus: SelfGrantStatusOutput?
        /// The status to be updated as part of the UpdateDataSource action.
        public let status: DataSourceStatus?
        /// The type to be updated as part of the UpdateDataSource action.
        public let type: String?
        /// The timestamp of when the data source was updated.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var updatedAt: Date?

        @inlinable
        public init(assetFormsOutput: [FormOutput]? = nil, configuration: DataSourceConfigurationOutput? = nil, connectionId: String? = nil, createdAt: Date? = nil, description: String? = nil, domainId: String, enableSetting: EnableSetting? = nil, environmentId: String? = nil, errorMessage: DataSourceErrorMessage? = nil, id: String, lastRunAt: Date? = nil, lastRunErrorMessage: DataSourceErrorMessage? = nil, lastRunStatus: DataSourceRunStatus? = nil, name: String, projectId: String, publishOnImport: Bool? = nil, recommendation: RecommendationConfiguration? = nil, retainPermissionsOnRevokeFailure: Bool? = nil, schedule: ScheduleConfiguration? = nil, selfGrantStatus: SelfGrantStatusOutput? = nil, status: DataSourceStatus? = nil, type: String? = nil, updatedAt: Date? = nil) {
            self.assetFormsOutput = assetFormsOutput
            self.configuration = configuration
            self.connectionId = connectionId
            self.createdAt = createdAt
            self.description = description
            self.domainId = domainId
            self.enableSetting = enableSetting
            self.environmentId = environmentId
            self.errorMessage = errorMessage
            self.id = id
            self.lastRunAt = lastRunAt
            self.lastRunErrorMessage = lastRunErrorMessage
            self.lastRunStatus = lastRunStatus
            self.name = name
            self.projectId = projectId
            self.publishOnImport = publishOnImport
            self.recommendation = recommendation
            self.retainPermissionsOnRevokeFailure = retainPermissionsOnRevokeFailure
            self.schedule = schedule
            self.selfGrantStatus = selfGrantStatus
            self.status = status
            self.type = type
            self.updatedAt = updatedAt
        }

        private enum CodingKeys: String, CodingKey {
            case assetFormsOutput = "assetFormsOutput"
            case configuration = "configuration"
            case connectionId = "connectionId"
            case createdAt = "createdAt"
            case description = "description"
            case domainId = "domainId"
            case enableSetting = "enableSetting"
            case environmentId = "environmentId"
            case errorMessage = "errorMessage"
            case id = "id"
            case lastRunAt = "lastRunAt"
            case lastRunErrorMessage = "lastRunErrorMessage"
            case lastRunStatus = "lastRunStatus"
            case name = "name"
            case projectId = "projectId"
            case publishOnImport = "publishOnImport"
            case recommendation = "recommendation"
            case retainPermissionsOnRevokeFailure = "retainPermissionsOnRevokeFailure"
            case schedule = "schedule"
            case selfGrantStatus = "selfGrantStatus"
            case status = "status"
            case type = "type"
            case updatedAt = "updatedAt"
        }
    }

    public struct UpdateDomainInput: AWSEncodableShape {
        /// A unique, case-sensitive identifier that is provided to ensure the idempotency of the request.
        public let clientToken: String?
        /// The description to be updated as part of the UpdateDomain action.
        public let description: String?
        /// The domain execution role to be updated as part of the UpdateDomain action.
        public let domainExecutionRole: String?
        /// The ID of the Amazon Web Services domain that is to be updated.
        public let identifier: String
        /// The name to be updated as part of the UpdateDomain action.
        public let name: String?
        /// The service role of the domain.
        public let serviceRole: String?
        /// The single sign-on option to be updated as part of the UpdateDomain action.
        public let singleSignOn: SingleSignOn?

        @inlinable
        public init(clientToken: String? = UpdateDomainInput.idempotencyToken(), description: String? = nil, domainExecutionRole: String? = nil, identifier: String, name: String? = nil, serviceRole: String? = nil, singleSignOn: SingleSignOn? = nil) {
            self.clientToken = clientToken
            self.description = description
            self.domainExecutionRole = domainExecutionRole
            self.identifier = identifier
            self.name = name
            self.serviceRole = serviceRole
            self.singleSignOn = singleSignOn
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.clientToken, key: "clientToken")
            try container.encodeIfPresent(self.description, forKey: .description)
            try container.encodeIfPresent(self.domainExecutionRole, forKey: .domainExecutionRole)
            request.encodePath(self.identifier, key: "identifier")
            try container.encodeIfPresent(self.name, forKey: .name)
            try container.encodeIfPresent(self.serviceRole, forKey: .serviceRole)
            try container.encodeIfPresent(self.singleSignOn, forKey: .singleSignOn)
        }

        public func validate(name: String) throws {
            try self.validate(self.domainExecutionRole, name: "domainExecutionRole", parent: name, pattern: "^arn:aws[^:]*:iam::\\d{12}:(role|role/service-role)/[\\w+=,.@-]*$")
            try self.validate(self.identifier, name: "identifier", parent: name, pattern: "^dzd[-_][a-zA-Z0-9_-]{1,36}$")
            try self.validate(self.serviceRole, name: "serviceRole", parent: name, pattern: "^arn:aws[^:]*:iam::\\d{12}:(role|role/service-role)/[\\w+=,.@-]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case description = "description"
            case domainExecutionRole = "domainExecutionRole"
            case name = "name"
            case serviceRole = "serviceRole"
            case singleSignOn = "singleSignOn"
        }
    }

    public struct UpdateDomainOutput: AWSDecodableShape {
        /// The description to be updated as part of the UpdateDomain action.
        public let description: String?
        /// The domain execution role to be updated as part of the UpdateDomain action.
        public let domainExecutionRole: String?
        /// The identifier of the Amazon DataZone domain.
        public let id: String
        /// Specifies the timestamp of when the domain was last updated.
        public let lastUpdatedAt: Date?
        /// The name to be updated as part of the UpdateDomain action.
        public let name: String?
        /// The ID of the root domain unit.
        public let rootDomainUnitId: String?
        /// The service role of the domain.
        public let serviceRole: String?
        /// The single sign-on option of the Amazon DataZone domain.
        public let singleSignOn: SingleSignOn?

        @inlinable
        public init(description: String? = nil, domainExecutionRole: String? = nil, id: String, lastUpdatedAt: Date? = nil, name: String? = nil, rootDomainUnitId: String? = nil, serviceRole: String? = nil, singleSignOn: SingleSignOn? = nil) {
            self.description = description
            self.domainExecutionRole = domainExecutionRole
            self.id = id
            self.lastUpdatedAt = lastUpdatedAt
            self.name = name
            self.rootDomainUnitId = rootDomainUnitId
            self.serviceRole = serviceRole
            self.singleSignOn = singleSignOn
        }

        private enum CodingKeys: String, CodingKey {
            case description = "description"
            case domainExecutionRole = "domainExecutionRole"
            case id = "id"
            case lastUpdatedAt = "lastUpdatedAt"
            case name = "name"
            case rootDomainUnitId = "rootDomainUnitId"
            case serviceRole = "serviceRole"
            case singleSignOn = "singleSignOn"
        }
    }

    public struct UpdateDomainUnitInput: AWSEncodableShape {
        /// The description of the domain unit that you want to update.
        public let description: String?
        /// The ID of the domain where you want to update a domain unit.
        public let domainIdentifier: String
        /// The ID of the domain unit that you want to update.
        public let identifier: String
        /// The name of the domain unit that you want to update.
        public let name: String?

        @inlinable
        public init(description: String? = nil, domainIdentifier: String, identifier: String, name: String? = nil) {
            self.description = description
            self.domainIdentifier = domainIdentifier
            self.identifier = identifier
            self.name = name
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.description, forKey: .description)
            request.encodePath(self.domainIdentifier, key: "domainIdentifier")
            request.encodePath(self.identifier, key: "identifier")
            try container.encodeIfPresent(self.name, forKey: .name)
        }

        public func validate(name: String) throws {
            try self.validate(self.description, name: "description", parent: name, max: 2048)
            try self.validate(self.domainIdentifier, name: "domainIdentifier", parent: name, pattern: "^dzd[-_][a-zA-Z0-9_-]{1,36}$")
            try self.validate(self.identifier, name: "identifier", parent: name, max: 256)
            try self.validate(self.identifier, name: "identifier", parent: name, min: 1)
            try self.validate(self.identifier, name: "identifier", parent: name, pattern: "^[a-z0-9_\\-]+$")
            try self.validate(self.name, name: "name", parent: name, max: 128)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[\\w -]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case description = "description"
            case name = "name"
        }
    }

    public struct UpdateDomainUnitOutput: AWSDecodableShape {
        /// The time stamp at which the domain unit that you want to update was created.
        public let createdAt: Date?
        /// The user who created the domain unit that you want to update.
        public let createdBy: String?
        /// The description of the domain unit that you want to update.
        public let description: String?
        /// The ID of the domain where you want to update the domain unit.
        public let domainId: String
        /// The ID of the domain unit that you want to update.
        public let id: String
        /// The timestamp at which the domain unit was last updated.
        public let lastUpdatedAt: Date?
        /// The user who last updated the domain unit.
        public let lastUpdatedBy: String?
        /// The name of the domain unit that you want to update.
        public let name: String
        /// The owners of the domain unit that you want to update.
        public let owners: [DomainUnitOwnerProperties]
        /// The ID of the parent domain unit.
        public let parentDomainUnitId: String?

        @inlinable
        public init(createdAt: Date? = nil, createdBy: String? = nil, description: String? = nil, domainId: String, id: String, lastUpdatedAt: Date? = nil, lastUpdatedBy: String? = nil, name: String, owners: [DomainUnitOwnerProperties], parentDomainUnitId: String? = nil) {
            self.createdAt = createdAt
            self.createdBy = createdBy
            self.description = description
            self.domainId = domainId
            self.id = id
            self.lastUpdatedAt = lastUpdatedAt
            self.lastUpdatedBy = lastUpdatedBy
            self.name = name
            self.owners = owners
            self.parentDomainUnitId = parentDomainUnitId
        }

        private enum CodingKeys: String, CodingKey {
            case createdAt = "createdAt"
            case createdBy = "createdBy"
            case description = "description"
            case domainId = "domainId"
            case id = "id"
            case lastUpdatedAt = "lastUpdatedAt"
            case lastUpdatedBy = "lastUpdatedBy"
            case name = "name"
            case owners = "owners"
            case parentDomainUnitId = "parentDomainUnitId"
        }
    }

    public struct UpdateEnvironmentActionInput: AWSEncodableShape {
        /// The description of the environment action.
        public let description: String?
        /// The domain ID of the environment action.
        public let domainIdentifier: String
        /// The environment ID of the environment action.
        public let environmentIdentifier: String
        /// The ID of the environment action.
        public let identifier: String
        /// The name of the environment action.
        public let name: String?
        /// The parameters of the environment action.
        public let parameters: ActionParameters?

        @inlinable
        public init(description: String? = nil, domainIdentifier: String, environmentIdentifier: String, identifier: String, name: String? = nil, parameters: ActionParameters? = nil) {
            self.description = description
            self.domainIdentifier = domainIdentifier
            self.environmentIdentifier = environmentIdentifier
            self.identifier = identifier
            self.name = name
            self.parameters = parameters
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.description, forKey: .description)
            request.encodePath(self.domainIdentifier, key: "domainIdentifier")
            request.encodePath(self.environmentIdentifier, key: "environmentIdentifier")
            request.encodePath(self.identifier, key: "identifier")
            try container.encodeIfPresent(self.name, forKey: .name)
            try container.encodeIfPresent(self.parameters, forKey: .parameters)
        }

        public func validate(name: String) throws {
            try self.validate(self.domainIdentifier, name: "domainIdentifier", parent: name, pattern: "^dzd[-_][a-zA-Z0-9_-]{1,36}$")
            try self.validate(self.environmentIdentifier, name: "environmentIdentifier", parent: name, pattern: "^[a-zA-Z0-9_-]{1,36}$")
        }

        private enum CodingKeys: String, CodingKey {
            case description = "description"
            case name = "name"
            case parameters = "parameters"
        }
    }

    public struct UpdateEnvironmentActionOutput: AWSDecodableShape {
        /// The description of the environment action.
        public let description: String?
        /// The domain ID of the environment action.
        public let domainId: String
        /// The environment ID of the environment action.
        public let environmentId: String
        /// The ID of the environment action.
        public let id: String
        /// The name of the environment action.
        public let name: String
        /// The parameters of the environment action.
        public let parameters: ActionParameters

        @inlinable
        public init(description: String? = nil, domainId: String, environmentId: String, id: String, name: String, parameters: ActionParameters) {
            self.description = description
            self.domainId = domainId
            self.environmentId = environmentId
            self.id = id
            self.name = name
            self.parameters = parameters
        }

        private enum CodingKeys: String, CodingKey {
            case description = "description"
            case domainId = "domainId"
            case environmentId = "environmentId"
            case id = "id"
            case name = "name"
            case parameters = "parameters"
        }
    }

    public struct UpdateEnvironmentInput: AWSEncodableShape {
        /// The blueprint version to which the environment should be updated. You can only specify the following string for this parameter: latest.
        public let blueprintVersion: String?
        /// The description to be updated as part of the UpdateEnvironment action.
        public let description: String?
        /// The identifier of the domain in which the environment is to be updated.
        public let domainIdentifier: String
        /// The glossary terms to be updated as part of the UpdateEnvironment action.
        public let glossaryTerms: [String]?
        /// The identifier of the environment that is to be updated.
        public let identifier: String
        /// The name to be updated as part of the UpdateEnvironment action.
        public let name: String?
        /// The user parameters of the environment.
        public let userParameters: [EnvironmentParameter]?

        @inlinable
        public init(blueprintVersion: String? = nil, description: String? = nil, domainIdentifier: String, glossaryTerms: [String]? = nil, identifier: String, name: String? = nil, userParameters: [EnvironmentParameter]? = nil) {
            self.blueprintVersion = blueprintVersion
            self.description = description
            self.domainIdentifier = domainIdentifier
            self.glossaryTerms = glossaryTerms
            self.identifier = identifier
            self.name = name
            self.userParameters = userParameters
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.blueprintVersion, forKey: .blueprintVersion)
            try container.encodeIfPresent(self.description, forKey: .description)
            request.encodePath(self.domainIdentifier, key: "domainIdentifier")
            try container.encodeIfPresent(self.glossaryTerms, forKey: .glossaryTerms)
            request.encodePath(self.identifier, key: "identifier")
            try container.encodeIfPresent(self.name, forKey: .name)
            try container.encodeIfPresent(self.userParameters, forKey: .userParameters)
        }

        public func validate(name: String) throws {
            try self.validate(self.domainIdentifier, name: "domainIdentifier", parent: name, pattern: "^dzd[-_][a-zA-Z0-9_-]{1,36}$")
            try self.glossaryTerms?.forEach {
                try validate($0, name: "glossaryTerms[]", parent: name, pattern: "^[a-zA-Z0-9_-]{1,36}$")
            }
            try self.validate(self.glossaryTerms, name: "glossaryTerms", parent: name, max: 20)
            try self.validate(self.glossaryTerms, name: "glossaryTerms", parent: name, min: 1)
            try self.validate(self.identifier, name: "identifier", parent: name, pattern: "^[a-zA-Z0-9_-]{1,36}$")
        }

        private enum CodingKeys: String, CodingKey {
            case blueprintVersion = "blueprintVersion"
            case description = "description"
            case glossaryTerms = "glossaryTerms"
            case name = "name"
            case userParameters = "userParameters"
        }
    }

    public struct UpdateEnvironmentOutput: AWSDecodableShape {
        /// The identifier of the Amazon Web Services account in which the environment is to be updated.
        public let awsAccountId: String?
        /// The Amazon Web Services Region in which the environment is updated.
        public let awsAccountRegion: String?
        /// The timestamp of when the environment was created.
        public let createdAt: Date?
        /// The Amazon DataZone user who created the environment.
        public let createdBy: String
        /// The deployment properties to be updated as part of the UpdateEnvironment action.
        public let deploymentProperties: DeploymentProperties?
        /// The description to be updated as part of the UpdateEnvironment action.
        public let description: String?
        /// The identifier of the domain in which the environment is to be updated.
        public let domainId: String
        /// The environment actions to be updated as part of the UpdateEnvironment action.
        public let environmentActions: [ConfigurableEnvironmentAction]?
        /// The blueprint identifier of the environment.
        public let environmentBlueprintId: String?
        /// The configuration ID of the environment.
        public let environmentConfigurationId: String?
        /// The profile identifier of the environment.
        public let environmentProfileId: String?
        /// The glossary terms to be updated as part of the UpdateEnvironment action.
        public let glossaryTerms: [String]?
        /// The identifier of the environment that is to be updated.
        public let id: String?
        /// The last deployment of the environment.
        public let lastDeployment: Deployment?
        /// The name to be updated as part of the UpdateEnvironment action.
        public let name: String
        /// The project identifier of the environment.
        public let projectId: String
        /// The provider identifier of the environment.
        public let provider: String
        /// The provisioned resources to be updated as part of the UpdateEnvironment action.
        public let provisionedResources: [Resource]?
        /// The provisioning properties to be updated as part of the UpdateEnvironment action.
        public let provisioningProperties: ProvisioningProperties?
        /// The status to be updated as part of the UpdateEnvironment action.
        public let status: EnvironmentStatus?
        /// The timestamp of when the environment was updated.
        public let updatedAt: Date?
        /// The user parameters to be updated as part of the UpdateEnvironment action.
        public let userParameters: [CustomParameter]?

        @inlinable
        public init(awsAccountId: String? = nil, awsAccountRegion: String? = nil, createdAt: Date? = nil, createdBy: String, deploymentProperties: DeploymentProperties? = nil, description: String? = nil, domainId: String, environmentActions: [ConfigurableEnvironmentAction]? = nil, environmentBlueprintId: String? = nil, environmentConfigurationId: String? = nil, environmentProfileId: String? = nil, glossaryTerms: [String]? = nil, id: String? = nil, lastDeployment: Deployment? = nil, name: String, projectId: String, provider: String, provisionedResources: [Resource]? = nil, provisioningProperties: ProvisioningProperties? = nil, status: EnvironmentStatus? = nil, updatedAt: Date? = nil, userParameters: [CustomParameter]? = nil) {
            self.awsAccountId = awsAccountId
            self.awsAccountRegion = awsAccountRegion
            self.createdAt = createdAt
            self.createdBy = createdBy
            self.deploymentProperties = deploymentProperties
            self.description = description
            self.domainId = domainId
            self.environmentActions = environmentActions
            self.environmentBlueprintId = environmentBlueprintId
            self.environmentConfigurationId = environmentConfigurationId
            self.environmentProfileId = environmentProfileId
            self.glossaryTerms = glossaryTerms
            self.id = id
            self.lastDeployment = lastDeployment
            self.name = name
            self.projectId = projectId
            self.provider = provider
            self.provisionedResources = provisionedResources
            self.provisioningProperties = provisioningProperties
            self.status = status
            self.updatedAt = updatedAt
            self.userParameters = userParameters
        }

        private enum CodingKeys: String, CodingKey {
            case awsAccountId = "awsAccountId"
            case awsAccountRegion = "awsAccountRegion"
            case createdAt = "createdAt"
            case createdBy = "createdBy"
            case deploymentProperties = "deploymentProperties"
            case description = "description"
            case domainId = "domainId"
            case environmentActions = "environmentActions"
            case environmentBlueprintId = "environmentBlueprintId"
            case environmentConfigurationId = "environmentConfigurationId"
            case environmentProfileId = "environmentProfileId"
            case glossaryTerms = "glossaryTerms"
            case id = "id"
            case lastDeployment = "lastDeployment"
            case name = "name"
            case projectId = "projectId"
            case provider = "provider"
            case provisionedResources = "provisionedResources"
            case provisioningProperties = "provisioningProperties"
            case status = "status"
            case updatedAt = "updatedAt"
            case userParameters = "userParameters"
        }
    }

    public struct UpdateEnvironmentProfileInput: AWSEncodableShape {
        /// The Amazon Web Services account in which a specified environment profile is to be udpated.
        public let awsAccountId: String?
        /// The Amazon Web Services Region in which a specified environment profile is to be updated.
        public let awsAccountRegion: String?
        /// The description to be updated as part of the UpdateEnvironmentProfile action.
        public let description: String?
        /// The identifier of the Amazon DataZone domain in which an environment profile is to be updated.
        public let domainIdentifier: String
        /// The identifier of the environment profile that is to be updated.
        public let identifier: String
        /// The name to be updated as part of the UpdateEnvironmentProfile action.
        public let name: String?
        /// The user parameters to be updated as part of the UpdateEnvironmentProfile action.
        public let userParameters: [EnvironmentParameter]?

        @inlinable
        public init(awsAccountId: String? = nil, awsAccountRegion: String? = nil, description: String? = nil, domainIdentifier: String, identifier: String, name: String? = nil, userParameters: [EnvironmentParameter]? = nil) {
            self.awsAccountId = awsAccountId
            self.awsAccountRegion = awsAccountRegion
            self.description = description
            self.domainIdentifier = domainIdentifier
            self.identifier = identifier
            self.name = name
            self.userParameters = userParameters
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.awsAccountId, forKey: .awsAccountId)
            try container.encodeIfPresent(self.awsAccountRegion, forKey: .awsAccountRegion)
            try container.encodeIfPresent(self.description, forKey: .description)
            request.encodePath(self.domainIdentifier, key: "domainIdentifier")
            request.encodePath(self.identifier, key: "identifier")
            try container.encodeIfPresent(self.name, forKey: .name)
            try container.encodeIfPresent(self.userParameters, forKey: .userParameters)
        }

        public func validate(name: String) throws {
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, pattern: "^\\d{12}$")
            try self.validate(self.awsAccountRegion, name: "awsAccountRegion", parent: name, pattern: "^[a-z]{2}-[a-z]{4,10}-\\d$")
            try self.validate(self.domainIdentifier, name: "domainIdentifier", parent: name, pattern: "^dzd[-_][a-zA-Z0-9_-]{1,36}$")
            try self.validate(self.identifier, name: "identifier", parent: name, pattern: "^[a-zA-Z0-9_-]{0,36}$")
            try self.validate(self.name, name: "name", parent: name, max: 64)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[\\w -]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case awsAccountId = "awsAccountId"
            case awsAccountRegion = "awsAccountRegion"
            case description = "description"
            case name = "name"
            case userParameters = "userParameters"
        }
    }

    public struct UpdateEnvironmentProfileOutput: AWSDecodableShape {
        /// The Amazon Web Services account in which a specified environment profile is to be udpated.
        public let awsAccountId: String?
        /// The Amazon Web Services Region in which a specified environment profile is to be updated.
        public let awsAccountRegion: String?
        /// The timestamp of when the environment profile was created.
        public let createdAt: Date?
        /// The Amazon DataZone user who created the environment profile.
        public let createdBy: String
        /// The description to be updated as part of the UpdateEnvironmentProfile action.
        public let description: String?
        /// The identifier of the Amazon DataZone domain in which the environment profile is to be updated.
        public let domainId: String
        /// The identifier of the blueprint of the environment profile that is to be updated.
        public let environmentBlueprintId: String
        /// The identifier of the environment profile that is to be udpated.
        public let id: String
        /// The name to be updated as part of the UpdateEnvironmentProfile action.
        public let name: String
        /// The identifier of the project of the environment profile that is to be updated.
        public let projectId: String?
        /// The timestamp of when the environment profile was updated.
        public let updatedAt: Date?
        /// The user parameters to be updated as part of the UpdateEnvironmentProfile action.
        public let userParameters: [CustomParameter]?

        @inlinable
        public init(awsAccountId: String? = nil, awsAccountRegion: String? = nil, createdAt: Date? = nil, createdBy: String, description: String? = nil, domainId: String, environmentBlueprintId: String, id: String, name: String, projectId: String? = nil, updatedAt: Date? = nil, userParameters: [CustomParameter]? = nil) {
            self.awsAccountId = awsAccountId
            self.awsAccountRegion = awsAccountRegion
            self.createdAt = createdAt
            self.createdBy = createdBy
            self.description = description
            self.domainId = domainId
            self.environmentBlueprintId = environmentBlueprintId
            self.id = id
            self.name = name
            self.projectId = projectId
            self.updatedAt = updatedAt
            self.userParameters = userParameters
        }

        private enum CodingKeys: String, CodingKey {
            case awsAccountId = "awsAccountId"
            case awsAccountRegion = "awsAccountRegion"
            case createdAt = "createdAt"
            case createdBy = "createdBy"
            case description = "description"
            case domainId = "domainId"
            case environmentBlueprintId = "environmentBlueprintId"
            case id = "id"
            case name = "name"
            case projectId = "projectId"
            case updatedAt = "updatedAt"
            case userParameters = "userParameters"
        }
    }

    public struct UpdateGlossaryInput: AWSEncodableShape {
        /// A unique, case-sensitive identifier that is provided to ensure the idempotency of the request.
        public let clientToken: String?
        /// The description to be updated as part of the UpdateGlossary action.
        public let description: String?
        /// The identifier of the Amazon DataZone domain in which a business glossary is to be updated.
        public let domainIdentifier: String
        /// The identifier of the business glossary to be updated.
        public let identifier: String
        /// The name to be updated as part of the UpdateGlossary action.
        public let name: String?
        /// The status to be updated as part of the UpdateGlossary action.
        public let status: GlossaryStatus?

        @inlinable
        public init(clientToken: String? = UpdateGlossaryInput.idempotencyToken(), description: String? = nil, domainIdentifier: String, identifier: String, name: String? = nil, status: GlossaryStatus? = nil) {
            self.clientToken = clientToken
            self.description = description
            self.domainIdentifier = domainIdentifier
            self.identifier = identifier
            self.name = name
            self.status = status
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.clientToken, forKey: .clientToken)
            try container.encodeIfPresent(self.description, forKey: .description)
            request.encodePath(self.domainIdentifier, key: "domainIdentifier")
            request.encodePath(self.identifier, key: "identifier")
            try container.encodeIfPresent(self.name, forKey: .name)
            try container.encodeIfPresent(self.status, forKey: .status)
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 128)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "^[\\x21-\\x7E]+$")
            try self.validate(self.description, name: "description", parent: name, max: 4096)
            try self.validate(self.domainIdentifier, name: "domainIdentifier", parent: name, pattern: "^dzd[-_][a-zA-Z0-9_-]{1,36}$")
            try self.validate(self.identifier, name: "identifier", parent: name, pattern: "^[a-zA-Z0-9_-]{1,36}$")
            try self.validate(self.name, name: "name", parent: name, max: 256)
            try self.validate(self.name, name: "name", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "clientToken"
            case description = "description"
            case name = "name"
            case status = "status"
        }
    }

    public struct UpdateGlossaryOutput: AWSDecodableShape {
        /// The description to be updated as part of the UpdateGlossary action.
        public let description: String?
        /// The identifier of the Amazon DataZone domain in which a business glossary is to be updated.
        public let domainId: String
        /// The identifier of the business glossary that is to be updated.
        public let id: String
        /// The name to be updated as part of the UpdateGlossary action.
        public let name: String
        /// The identifier of the project in which to update a business glossary.
        public let owningProjectId: String
        /// The status to be updated as part of the UpdateGlossary action.
        public let status: GlossaryStatus?

        @inlinable
        public init(description: String? = nil, domainId: String, id: String, name: String, owningProjectId: String, status: GlossaryStatus? = nil) {
            self.description = description
            self.domainId = domainId
            self.id = id
            self.name = name
            self.owningProjectId = owningProjectId
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case description = "description"
            case domainId = "domainId"
            case id = "id"
            case name = "name"
            case owningProjectId = "owningProjectId"
            case status = "status"
        }
    }

    public struct UpdateGlossaryTermInput: AWSEncodableShape {
        /// The identifier of the Amazon DataZone domain in which a business glossary term is to be updated.
        public let domainIdentifier: String
        /// The identifier of the business glossary in which a term is to be updated.
        public let glossaryIdentifier: String?
        /// The identifier of the business glossary term that is to be updated.
        public let identifier: String
        /// The long description to be updated as part of the UpdateGlossaryTerm action.
        public let longDescription: String?
        /// The name to be updated as part of the UpdateGlossaryTerm action.
        public let name: String?
        /// The short description to be updated as part of the UpdateGlossaryTerm action.
        public let shortDescription: String?
        /// The status to be updated as part of the UpdateGlossaryTerm action.
        public let status: GlossaryTermStatus?
        /// The term relations to be updated as part of the UpdateGlossaryTerm action.
        public let termRelations: TermRelations?

        @inlinable
        public init(domainIdentifier: String, glossaryIdentifier: String? = nil, identifier: String, longDescription: String? = nil, name: String? = nil, shortDescription: String? = nil, status: GlossaryTermStatus? = nil, termRelations: TermRelations? = nil) {
            self.domainIdentifier = domainIdentifier
            self.glossaryIdentifier = glossaryIdentifier
            self.identifier = identifier
            self.longDescription = longDescription
            self.name = name
            self.shortDescription = shortDescription
            self.status = status
            self.termRelations = termRelations
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.domainIdentifier, key: "domainIdentifier")
            try container.encodeIfPresent(self.glossaryIdentifier, forKey: .glossaryIdentifier)
            request.encodePath(self.identifier, key: "identifier")
            try container.encodeIfPresent(self.longDescription, forKey: .longDescription)
            try container.encodeIfPresent(self.name, forKey: .name)
            try container.encodeIfPresent(self.shortDescription, forKey: .shortDescription)
            try container.encodeIfPresent(self.status, forKey: .status)
            try container.encodeIfPresent(self.termRelations, forKey: .termRelations)
        }

        public func validate(name: String) throws {
            try self.validate(self.domainIdentifier, name: "domainIdentifier", parent: name, pattern: "^dzd[-_][a-zA-Z0-9_-]{1,36}$")
            try self.validate(self.glossaryIdentifier, name: "glossaryIdentifier", parent: name, pattern: "^[a-zA-Z0-9_-]{1,36}$")
            try self.validate(self.identifier, name: "identifier", parent: name, pattern: "^[a-zA-Z0-9_-]{1,36}$")
            try self.validate(self.longDescription, name: "longDescription", parent: name, max: 4096)
            try self.validate(self.name, name: "name", parent: name, max: 256)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.shortDescription, name: "shortDescription", parent: name, max: 1024)
            try self.termRelations?.validate(name: "\(name).termRelations")
        }

        private enum CodingKeys: String, CodingKey {
            case glossaryIdentifier = "glossaryIdentifier"
            case longDescription = "longDescription"
            case name = "name"
            case shortDescription = "shortDescription"
            case status = "status"
            case termRelations = "termRelations"
        }
    }

    public struct UpdateGlossaryTermOutput: AWSDecodableShape {
        /// The identifier of the Amazon DataZone domain in which a business glossary term is to be updated.
        public let domainId: String
        /// The identifier of the business glossary in which a term is to be updated.
        public let glossaryId: String
        /// The identifier of the business glossary term that is to be updated.
        public let id: String
        /// The long description to be updated as part of the UpdateGlossaryTerm action.
        public let longDescription: String?
        /// The name to be updated as part of the UpdateGlossaryTerm action.
        public let name: String
        /// The short description to be updated as part of the UpdateGlossaryTerm action.
        public let shortDescription: String?
        /// The status to be updated as part of the UpdateGlossaryTerm action.
        public let status: GlossaryTermStatus
        /// The term relations to be updated as part of the UpdateGlossaryTerm action.
        public let termRelations: TermRelations?

        @inlinable
        public init(domainId: String, glossaryId: String, id: String, longDescription: String? = nil, name: String, shortDescription: String? = nil, status: GlossaryTermStatus, termRelations: TermRelations? = nil) {
            self.domainId = domainId
            self.glossaryId = glossaryId
            self.id = id
            self.longDescription = longDescription
            self.name = name
            self.shortDescription = shortDescription
            self.status = status
            self.termRelations = termRelations
        }

        private enum CodingKeys: String, CodingKey {
            case domainId = "domainId"
            case glossaryId = "glossaryId"
            case id = "id"
            case longDescription = "longDescription"
            case name = "name"
            case shortDescription = "shortDescription"
            case status = "status"
            case termRelations = "termRelations"
        }
    }

    public struct UpdateGroupProfileInput: AWSEncodableShape {
        /// The identifier of the Amazon DataZone domain in which a group profile is updated.
        public let domainIdentifier: String
        /// The identifier of the group profile that is updated.
        public let groupIdentifier: String
        /// The status of the group profile that is updated.
        public let status: GroupProfileStatus

        @inlinable
        public init(domainIdentifier: String, groupIdentifier: String, status: GroupProfileStatus) {
            self.domainIdentifier = domainIdentifier
            self.groupIdentifier = groupIdentifier
            self.status = status
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.domainIdentifier, key: "domainIdentifier")
            request.encodePath(self.groupIdentifier, key: "groupIdentifier")
            try container.encode(self.status, forKey: .status)
        }

        public func validate(name: String) throws {
            try self.validate(self.domainIdentifier, name: "domainIdentifier", parent: name, pattern: "^dzd[-_][a-zA-Z0-9_-]{1,36}$")
            try self.validate(self.groupIdentifier, name: "groupIdentifier", parent: name, pattern: "(^([0-9a-f]{10}-|)[A-Fa-f0-9]{8}-[A-Fa-f0-9]{4}-[A-Fa-f0-9]{4}-[A-Fa-f0-9]{4}-[A-Fa-f0-9]{12}$|[\\p{L}\\p{M}\\p{S}\\p{N}\\p{P}\\t\\n\\r  ]+)")
        }

        private enum CodingKeys: String, CodingKey {
            case status = "status"
        }
    }

    public struct UpdateGroupProfileOutput: AWSDecodableShape {
        /// The identifier of the Amazon DataZone domain in which a group profile is updated.
        public let domainId: String?
        /// The name of the group profile that is updated.
        public let groupName: String?
        /// The identifier of the group profile that is updated.
        public let id: String?
        /// The status of the group profile that is updated.
        public let status: GroupProfileStatus?

        @inlinable
        public init(domainId: String? = nil, groupName: String? = nil, id: String? = nil, status: GroupProfileStatus? = nil) {
            self.domainId = domainId
            self.groupName = groupName
            self.id = id
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case domainId = "domainId"
            case groupName = "groupName"
            case id = "id"
            case status = "status"
        }
    }

    public struct UpdateProjectInput: AWSEncodableShape {
        /// The description to be updated as part of the UpdateProject action.
        public let description: String?
        /// The ID of the Amazon DataZone domain where a project is being updated.
        public let domainIdentifier: String
        /// The environment deployment details of the project.
        public let environmentDeploymentDetails: EnvironmentDeploymentDetails?
        /// The glossary terms to be updated as part of the UpdateProject action.
        public let glossaryTerms: [String]?
        /// The identifier of the project that is to be updated.
        public let identifier: String
        /// The name to be updated as part of the UpdateProject action.
        public let name: String?
        /// The project profile version to which the project should be updated. You can only specify the following string for this parameter: latest.
        public let projectProfileVersion: String?
        /// The user parameters of the project.
        public let userParameters: [EnvironmentConfigurationUserParameter]?

        @inlinable
        public init(description: String? = nil, domainIdentifier: String, environmentDeploymentDetails: EnvironmentDeploymentDetails? = nil, glossaryTerms: [String]? = nil, identifier: String, name: String? = nil, projectProfileVersion: String? = nil, userParameters: [EnvironmentConfigurationUserParameter]? = nil) {
            self.description = description
            self.domainIdentifier = domainIdentifier
            self.environmentDeploymentDetails = environmentDeploymentDetails
            self.glossaryTerms = glossaryTerms
            self.identifier = identifier
            self.name = name
            self.projectProfileVersion = projectProfileVersion
            self.userParameters = userParameters
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.description, forKey: .description)
            request.encodePath(self.domainIdentifier, key: "domainIdentifier")
            try container.encodeIfPresent(self.environmentDeploymentDetails, forKey: .environmentDeploymentDetails)
            try container.encodeIfPresent(self.glossaryTerms, forKey: .glossaryTerms)
            request.encodePath(self.identifier, key: "identifier")
            try container.encodeIfPresent(self.name, forKey: .name)
            try container.encodeIfPresent(self.projectProfileVersion, forKey: .projectProfileVersion)
            try container.encodeIfPresent(self.userParameters, forKey: .userParameters)
        }

        public func validate(name: String) throws {
            try self.validate(self.description, name: "description", parent: name, max: 2048)
            try self.validate(self.domainIdentifier, name: "domainIdentifier", parent: name, pattern: "^dzd[-_][a-zA-Z0-9_-]{1,36}$")
            try self.glossaryTerms?.forEach {
                try validate($0, name: "glossaryTerms[]", parent: name, pattern: "^[a-zA-Z0-9_-]{1,36}$")
            }
            try self.validate(self.glossaryTerms, name: "glossaryTerms", parent: name, max: 20)
            try self.validate(self.glossaryTerms, name: "glossaryTerms", parent: name, min: 1)
            try self.validate(self.identifier, name: "identifier", parent: name, pattern: "^[a-zA-Z0-9_-]{1,36}$")
            try self.validate(self.name, name: "name", parent: name, max: 64)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[\\w -]+$")
            try self.userParameters?.forEach {
                try $0.validate(name: "\(name).userParameters[]")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case description = "description"
            case environmentDeploymentDetails = "environmentDeploymentDetails"
            case glossaryTerms = "glossaryTerms"
            case name = "name"
            case projectProfileVersion = "projectProfileVersion"
            case userParameters = "userParameters"
        }
    }

    public struct UpdateProjectOutput: AWSDecodableShape {
        /// The timestamp of when the project was created.
        public let createdAt: Date?
        /// The Amazon DataZone user who created the project.
        public let createdBy: String
        /// The description of the project that is to be updated.
        public let description: String?
        /// The identifier of the Amazon DataZone domain in which a project is updated.
        public let domainId: String
        /// The ID of the domain unit.
        public let domainUnitId: String?
        /// The environment deployment details of the project.
        public let environmentDeploymentDetails: EnvironmentDeploymentDetails?
        /// Specifies the error message that is returned if the operation cannot be successfully completed.
        public let failureReasons: [ProjectDeletionError]?
        /// The glossary terms of the project that are to be updated.
        public let glossaryTerms: [String]?
        /// The identifier of the project that is to be updated.
        public let id: String
        /// The timestamp of when the project was last updated.
        public let lastUpdatedAt: Date?
        /// The name of the project that is to be updated.
        public let name: String
        /// The ID of the project profile.
        public let projectProfileId: String?
        /// The status of the project.
        public let projectStatus: ProjectStatus?
        /// The user parameters of the project.
        public let userParameters: [EnvironmentConfigurationUserParameter]?

        @inlinable
        public init(createdAt: Date? = nil, createdBy: String, description: String? = nil, domainId: String, domainUnitId: String? = nil, environmentDeploymentDetails: EnvironmentDeploymentDetails? = nil, failureReasons: [ProjectDeletionError]? = nil, glossaryTerms: [String]? = nil, id: String, lastUpdatedAt: Date? = nil, name: String, projectProfileId: String? = nil, projectStatus: ProjectStatus? = nil, userParameters: [EnvironmentConfigurationUserParameter]? = nil) {
            self.createdAt = createdAt
            self.createdBy = createdBy
            self.description = description
            self.domainId = domainId
            self.domainUnitId = domainUnitId
            self.environmentDeploymentDetails = environmentDeploymentDetails
            self.failureReasons = failureReasons
            self.glossaryTerms = glossaryTerms
            self.id = id
            self.lastUpdatedAt = lastUpdatedAt
            self.name = name
            self.projectProfileId = projectProfileId
            self.projectStatus = projectStatus
            self.userParameters = userParameters
        }

        private enum CodingKeys: String, CodingKey {
            case createdAt = "createdAt"
            case createdBy = "createdBy"
            case description = "description"
            case domainId = "domainId"
            case domainUnitId = "domainUnitId"
            case environmentDeploymentDetails = "environmentDeploymentDetails"
            case failureReasons = "failureReasons"
            case glossaryTerms = "glossaryTerms"
            case id = "id"
            case lastUpdatedAt = "lastUpdatedAt"
            case name = "name"
            case projectProfileId = "projectProfileId"
            case projectStatus = "projectStatus"
            case userParameters = "userParameters"
        }
    }

    public struct UpdateProjectProfileInput: AWSEncodableShape {
        /// The description of a project profile.
        public let description: String?
        /// The ID of the domain where a project profile is to be updated.
        public let domainIdentifier: String
        /// The ID of the domain unit where a project profile is to be updated.
        public let domainUnitIdentifier: String?
        /// The environment configurations of a project profile.
        public let environmentConfigurations: [EnvironmentConfiguration]?
        /// The ID of a project profile that is to be updated.
        public let identifier: String
        /// The name of a project profile.
        public let name: String?
        /// The status of a project profile.
        public let status: Status?

        @inlinable
        public init(description: String? = nil, domainIdentifier: String, domainUnitIdentifier: String? = nil, environmentConfigurations: [EnvironmentConfiguration]? = nil, identifier: String, name: String? = nil, status: Status? = nil) {
            self.description = description
            self.domainIdentifier = domainIdentifier
            self.domainUnitIdentifier = domainUnitIdentifier
            self.environmentConfigurations = environmentConfigurations
            self.identifier = identifier
            self.name = name
            self.status = status
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.description, forKey: .description)
            request.encodePath(self.domainIdentifier, key: "domainIdentifier")
            try container.encodeIfPresent(self.domainUnitIdentifier, forKey: .domainUnitIdentifier)
            try container.encodeIfPresent(self.environmentConfigurations, forKey: .environmentConfigurations)
            request.encodePath(self.identifier, key: "identifier")
            try container.encodeIfPresent(self.name, forKey: .name)
            try container.encodeIfPresent(self.status, forKey: .status)
        }

        public func validate(name: String) throws {
            try self.validate(self.description, name: "description", parent: name, max: 2048)
            try self.validate(self.domainIdentifier, name: "domainIdentifier", parent: name, pattern: "^dzd[-_][a-zA-Z0-9_-]{1,36}$")
            try self.validate(self.domainUnitIdentifier, name: "domainUnitIdentifier", parent: name, max: 256)
            try self.validate(self.domainUnitIdentifier, name: "domainUnitIdentifier", parent: name, min: 1)
            try self.validate(self.domainUnitIdentifier, name: "domainUnitIdentifier", parent: name, pattern: "^[a-z0-9_\\-]+$")
            try self.environmentConfigurations?.forEach {
                try $0.validate(name: "\(name).environmentConfigurations[]")
            }
            try self.validate(self.identifier, name: "identifier", parent: name, pattern: "^[a-zA-Z0-9_-]{1,36}$")
            try self.validate(self.name, name: "name", parent: name, max: 64)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[\\w -]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case description = "description"
            case domainUnitIdentifier = "domainUnitIdentifier"
            case environmentConfigurations = "environmentConfigurations"
            case name = "name"
            case status = "status"
        }
    }

    public struct UpdateProjectProfileOutput: AWSDecodableShape {
        /// The timestamp at which a project profile is created.
        public let createdAt: Date?
        /// The user who created a project profile.
        public let createdBy: String
        /// The description of a project profile.
        public let description: String?
        /// The ID of the domain where project profile is to be updated.
        public let domainId: String
        /// The domain unit ID of the project profile to be updated.
        public let domainUnitId: String?
        /// The environment configurations of a project profile.
        public let environmentConfigurations: [EnvironmentConfiguration]?
        /// The ID of the project profile.
        public let id: String
        /// The timestamp at which a project profile was last updated.
        public let lastUpdatedAt: Date?
        /// The name of the project profile.
        public let name: String
        /// The status of the project profile.
        public let status: Status?

        @inlinable
        public init(createdAt: Date? = nil, createdBy: String, description: String? = nil, domainId: String, domainUnitId: String? = nil, environmentConfigurations: [EnvironmentConfiguration]? = nil, id: String, lastUpdatedAt: Date? = nil, name: String, status: Status? = nil) {
            self.createdAt = createdAt
            self.createdBy = createdBy
            self.description = description
            self.domainId = domainId
            self.domainUnitId = domainUnitId
            self.environmentConfigurations = environmentConfigurations
            self.id = id
            self.lastUpdatedAt = lastUpdatedAt
            self.name = name
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case createdAt = "createdAt"
            case createdBy = "createdBy"
            case description = "description"
            case domainId = "domainId"
            case domainUnitId = "domainUnitId"
            case environmentConfigurations = "environmentConfigurations"
            case id = "id"
            case lastUpdatedAt = "lastUpdatedAt"
            case name = "name"
            case status = "status"
        }
    }

    public struct UpdateRuleInput: AWSEncodableShape {
        /// The description of the rule.
        public let description: String?
        /// The detail of the rule.
        public let detail: RuleDetail?
        /// The ID of the domain in which a rule is to be updated.
        public let domainIdentifier: String
        /// The ID of the rule that is to be updated
        public let identifier: String
        /// Specifies whether to update this rule in the child domain units.
        public let includeChildDomainUnits: Bool?
        /// The name of the rule.
        public let name: String?
        /// The scrope of the rule.
        public let scope: RuleScope?

        @inlinable
        public init(description: String? = nil, detail: RuleDetail? = nil, domainIdentifier: String, identifier: String, includeChildDomainUnits: Bool? = nil, name: String? = nil, scope: RuleScope? = nil) {
            self.description = description
            self.detail = detail
            self.domainIdentifier = domainIdentifier
            self.identifier = identifier
            self.includeChildDomainUnits = includeChildDomainUnits
            self.name = name
            self.scope = scope
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.description, forKey: .description)
            try container.encodeIfPresent(self.detail, forKey: .detail)
            request.encodePath(self.domainIdentifier, key: "domainIdentifier")
            request.encodePath(self.identifier, key: "identifier")
            try container.encodeIfPresent(self.includeChildDomainUnits, forKey: .includeChildDomainUnits)
            try container.encodeIfPresent(self.name, forKey: .name)
            try container.encodeIfPresent(self.scope, forKey: .scope)
        }

        public func validate(name: String) throws {
            try self.validate(self.description, name: "description", parent: name, max: 2048)
            try self.detail?.validate(name: "\(name).detail")
            try self.validate(self.domainIdentifier, name: "domainIdentifier", parent: name, pattern: "^dzd[-_][a-zA-Z0-9_-]{1,36}$")
            try self.validate(self.identifier, name: "identifier", parent: name, pattern: "^[a-zA-Z0-9_-]{1,36}$")
            try self.validate(self.name, name: "name", parent: name, max: 256)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[\\w -]+$")
            try self.scope?.validate(name: "\(name).scope")
        }

        private enum CodingKeys: String, CodingKey {
            case description = "description"
            case detail = "detail"
            case includeChildDomainUnits = "includeChildDomainUnits"
            case name = "name"
            case scope = "scope"
        }
    }

    public struct UpdateRuleOutput: AWSDecodableShape {
        /// The action of the rule.
        public let action: RuleAction
        /// The timestamp at which the rule was created.
        public let createdAt: Date
        /// The user who created the rule.
        public let createdBy: String
        /// The description of the rule.
        public let description: String?
        /// The detail of the rule.
        public let detail: RuleDetail
        /// The ID of the rule.
        public let identifier: String
        /// The timestamp at which the rule was last updated.
        public let lastUpdatedBy: String
        /// The name of the rule.
        public let name: String
        /// The revision of the rule.
        public let revision: String
        /// The type of the rule.
        public let ruleType: RuleType
        /// The scope of the rule.
        public let scope: RuleScope
        /// The target of the rule.
        public let target: RuleTarget
        /// The timestamp at which the rule was last updated.
        public let updatedAt: Date

        @inlinable
        public init(action: RuleAction, createdAt: Date, createdBy: String, description: String? = nil, detail: RuleDetail, identifier: String, lastUpdatedBy: String, name: String, revision: String, ruleType: RuleType, scope: RuleScope, target: RuleTarget, updatedAt: Date) {
            self.action = action
            self.createdAt = createdAt
            self.createdBy = createdBy
            self.description = description
            self.detail = detail
            self.identifier = identifier
            self.lastUpdatedBy = lastUpdatedBy
            self.name = name
            self.revision = revision
            self.ruleType = ruleType
            self.scope = scope
            self.target = target
            self.updatedAt = updatedAt
        }

        private enum CodingKeys: String, CodingKey {
            case action = "action"
            case createdAt = "createdAt"
            case createdBy = "createdBy"
            case description = "description"
            case detail = "detail"
            case identifier = "identifier"
            case lastUpdatedBy = "lastUpdatedBy"
            case name = "name"
            case revision = "revision"
            case ruleType = "ruleType"
            case scope = "scope"
            case target = "target"
            case updatedAt = "updatedAt"
        }
    }

    public struct UpdateSubscriptionGrantStatusInput: AWSEncodableShape {
        /// The identifier of the asset the subscription grant status of which is to be updated.
        public let assetIdentifier: String
        /// The identifier of the Amazon DataZone domain in which a subscription grant status is to be updated.
        public let domainIdentifier: String
        /// Specifies the error message that is returned if the operation cannot be successfully completed.
        public let failureCause: FailureCause?
        /// The identifier of the subscription grant the status of which is to be updated.
        public let identifier: String
        /// The status to be updated as part of the UpdateSubscriptionGrantStatus action.
        public let status: SubscriptionGrantStatus
        /// The target name to be updated as part of the UpdateSubscriptionGrantStatus action.
        public let targetName: String?

        @inlinable
        public init(assetIdentifier: String, domainIdentifier: String, failureCause: FailureCause? = nil, identifier: String, status: SubscriptionGrantStatus, targetName: String? = nil) {
            self.assetIdentifier = assetIdentifier
            self.domainIdentifier = domainIdentifier
            self.failureCause = failureCause
            self.identifier = identifier
            self.status = status
            self.targetName = targetName
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.assetIdentifier, key: "assetIdentifier")
            request.encodePath(self.domainIdentifier, key: "domainIdentifier")
            try container.encodeIfPresent(self.failureCause, forKey: .failureCause)
            request.encodePath(self.identifier, key: "identifier")
            try container.encode(self.status, forKey: .status)
            try container.encodeIfPresent(self.targetName, forKey: .targetName)
        }

        public func validate(name: String) throws {
            try self.validate(self.assetIdentifier, name: "assetIdentifier", parent: name, pattern: "^[a-zA-Z0-9_-]{1,36}$")
            try self.validate(self.domainIdentifier, name: "domainIdentifier", parent: name, pattern: "^dzd[-_][a-zA-Z0-9_-]{1,36}$")
            try self.validate(self.identifier, name: "identifier", parent: name, pattern: "^[a-zA-Z0-9_-]{1,36}$")
        }

        private enum CodingKeys: String, CodingKey {
            case failureCause = "failureCause"
            case status = "status"
            case targetName = "targetName"
        }
    }

    public struct UpdateSubscriptionGrantStatusOutput: AWSDecodableShape {
        /// The details of the asset for which the subscription grant is created.
        public let assets: [SubscribedAsset]?
        /// The timestamp of when the subscription grant status was created.
        public let createdAt: Date
        /// The Amazon DataZone domain user who created the subscription grant status.
        public let createdBy: String
        /// The identifier of the Amazon DataZone domain in which a subscription grant status is to be updated.
        public let domainId: String
        /// The granted entity to be updated as part of the UpdateSubscriptionGrantStatus action.
        public let grantedEntity: GrantedEntity
        /// The identifier of the subscription grant.
        public let id: String
        /// The status to be updated as part of the UpdateSubscriptionGrantStatus action.
        public let status: SubscriptionGrantOverallStatus
        /// The identifier of the subscription.
        public let subscriptionId: String?
        /// The identifier of the subscription target whose subscription grant status is to be updated.
        public let subscriptionTargetId: String
        /// The timestamp of when the subscription grant status is to be updated.
        public let updatedAt: Date
        /// The Amazon DataZone user who updated the subscription grant status.
        public let updatedBy: String?

        @inlinable
        public init(assets: [SubscribedAsset]? = nil, createdAt: Date, createdBy: String, domainId: String, grantedEntity: GrantedEntity, id: String, status: SubscriptionGrantOverallStatus, subscriptionTargetId: String, updatedAt: Date, updatedBy: String? = nil) {
            self.assets = assets
            self.createdAt = createdAt
            self.createdBy = createdBy
            self.domainId = domainId
            self.grantedEntity = grantedEntity
            self.id = id
            self.status = status
            self.subscriptionId = nil
            self.subscriptionTargetId = subscriptionTargetId
            self.updatedAt = updatedAt
            self.updatedBy = updatedBy
        }

        @available(*, deprecated, message: "Members subscriptionId have been deprecated")
        @inlinable
        public init(assets: [SubscribedAsset]? = nil, createdAt: Date, createdBy: String, domainId: String, grantedEntity: GrantedEntity, id: String, status: SubscriptionGrantOverallStatus, subscriptionId: String? = nil, subscriptionTargetId: String, updatedAt: Date, updatedBy: String? = nil) {
            self.assets = assets
            self.createdAt = createdAt
            self.createdBy = createdBy
            self.domainId = domainId
            self.grantedEntity = grantedEntity
            self.id = id
            self.status = status
            self.subscriptionId = subscriptionId
            self.subscriptionTargetId = subscriptionTargetId
            self.updatedAt = updatedAt
            self.updatedBy = updatedBy
        }

        private enum CodingKeys: String, CodingKey {
            case assets = "assets"
            case createdAt = "createdAt"
            case createdBy = "createdBy"
            case domainId = "domainId"
            case grantedEntity = "grantedEntity"
            case id = "id"
            case status = "status"
            case subscriptionId = "subscriptionId"
            case subscriptionTargetId = "subscriptionTargetId"
            case updatedAt = "updatedAt"
            case updatedBy = "updatedBy"
        }
    }

    public struct UpdateSubscriptionRequestInput: AWSEncodableShape {
        /// The identifier of the Amazon DataZone domain in which a subscription request is to be updated.
        public let domainIdentifier: String
        /// The identifier of the subscription request that is to be updated.
        public let identifier: String
        /// The reason for the UpdateSubscriptionRequest action.
        public let requestReason: String

        @inlinable
        public init(domainIdentifier: String, identifier: String, requestReason: String) {
            self.domainIdentifier = domainIdentifier
            self.identifier = identifier
            self.requestReason = requestReason
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.domainIdentifier, key: "domainIdentifier")
            request.encodePath(self.identifier, key: "identifier")
            try container.encode(self.requestReason, forKey: .requestReason)
        }

        public func validate(name: String) throws {
            try self.validate(self.domainIdentifier, name: "domainIdentifier", parent: name, pattern: "^dzd[-_][a-zA-Z0-9_-]{1,36}$")
            try self.validate(self.identifier, name: "identifier", parent: name, pattern: "^[a-zA-Z0-9_-]{1,36}$")
            try self.validate(self.requestReason, name: "requestReason", parent: name, max: 4096)
            try self.validate(self.requestReason, name: "requestReason", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case requestReason = "requestReason"
        }
    }

    public struct UpdateSubscriptionRequestOutput: AWSDecodableShape {
        /// The timestamp of when the subscription request was created.
        public let createdAt: Date
        /// The Amazon DataZone user who created the subscription request.
        public let createdBy: String
        /// The decision comment of the UpdateSubscriptionRequest action.
        public let decisionComment: String?
        /// The identifier of the Amazon DataZone domain in which a subscription request is to be updated.
        public let domainId: String
        /// The ID of the existing subscription.
        public let existingSubscriptionId: String?
        /// The identifier of the subscription request that is to be updated.
        public let id: String
        /// Metadata forms included in the subscription request.
        public let metadataForms: [FormOutput]?
        /// The reason for the UpdateSubscriptionRequest action.
        public let requestReason: String
        /// The identifier of the Amazon DataZone user who reviews the subscription request.
        public let reviewerId: String?
        /// The status of the subscription request.
        public let status: SubscriptionRequestStatus
        /// The subscribed listings of the subscription request.
        public let subscribedListings: [SubscribedListing]
        /// The subscribed principals of the subscription request.
        public let subscribedPrincipals: [SubscribedPrincipal]
        /// The timestamp of when the subscription request was updated.
        public let updatedAt: Date
        /// The Amazon DataZone user who updated the subscription request.
        public let updatedBy: String?

        @inlinable
        public init(createdAt: Date, createdBy: String, decisionComment: String? = nil, domainId: String, existingSubscriptionId: String? = nil, id: String, metadataForms: [FormOutput]? = nil, requestReason: String, reviewerId: String? = nil, status: SubscriptionRequestStatus, subscribedListings: [SubscribedListing], subscribedPrincipals: [SubscribedPrincipal], updatedAt: Date, updatedBy: String? = nil) {
            self.createdAt = createdAt
            self.createdBy = createdBy
            self.decisionComment = decisionComment
            self.domainId = domainId
            self.existingSubscriptionId = existingSubscriptionId
            self.id = id
            self.metadataForms = metadataForms
            self.requestReason = requestReason
            self.reviewerId = reviewerId
            self.status = status
            self.subscribedListings = subscribedListings
            self.subscribedPrincipals = subscribedPrincipals
            self.updatedAt = updatedAt
            self.updatedBy = updatedBy
        }

        private enum CodingKeys: String, CodingKey {
            case createdAt = "createdAt"
            case createdBy = "createdBy"
            case decisionComment = "decisionComment"
            case domainId = "domainId"
            case existingSubscriptionId = "existingSubscriptionId"
            case id = "id"
            case metadataForms = "metadataForms"
            case requestReason = "requestReason"
            case reviewerId = "reviewerId"
            case status = "status"
            case subscribedListings = "subscribedListings"
            case subscribedPrincipals = "subscribedPrincipals"
            case updatedAt = "updatedAt"
            case updatedBy = "updatedBy"
        }
    }

    public struct UpdateSubscriptionTargetInput: AWSEncodableShape {
        /// The applicable asset types to be updated as part of the UpdateSubscriptionTarget action.
        public let applicableAssetTypes: [String]?
        /// The authorized principals to be updated as part of the UpdateSubscriptionTarget action.
        public let authorizedPrincipals: [String]?
        /// The identifier of the Amazon DataZone domain in which a subscription target is to be updated.
        public let domainIdentifier: String
        /// The identifier of the environment in which a subscription target is to be updated.
        public let environmentIdentifier: String
        /// Identifier of the subscription target that is to be updated.
        public let identifier: String
        /// The manage access role to be updated as part of the UpdateSubscriptionTarget action.
        public let manageAccessRole: String?
        /// The name to be updated as part of the UpdateSubscriptionTarget action.
        public let name: String?
        /// The provider to be updated as part of the UpdateSubscriptionTarget action.
        public let provider: String?
        /// The configuration to be updated as part of the UpdateSubscriptionTarget action.
        public let subscriptionTargetConfig: [SubscriptionTargetForm]?

        @inlinable
        public init(applicableAssetTypes: [String]? = nil, authorizedPrincipals: [String]? = nil, domainIdentifier: String, environmentIdentifier: String, identifier: String, manageAccessRole: String? = nil, name: String? = nil, provider: String? = nil, subscriptionTargetConfig: [SubscriptionTargetForm]? = nil) {
            self.applicableAssetTypes = applicableAssetTypes
            self.authorizedPrincipals = authorizedPrincipals
            self.domainIdentifier = domainIdentifier
            self.environmentIdentifier = environmentIdentifier
            self.identifier = identifier
            self.manageAccessRole = manageAccessRole
            self.name = name
            self.provider = provider
            self.subscriptionTargetConfig = subscriptionTargetConfig
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.applicableAssetTypes, forKey: .applicableAssetTypes)
            try container.encodeIfPresent(self.authorizedPrincipals, forKey: .authorizedPrincipals)
            request.encodePath(self.domainIdentifier, key: "domainIdentifier")
            request.encodePath(self.environmentIdentifier, key: "environmentIdentifier")
            request.encodePath(self.identifier, key: "identifier")
            try container.encodeIfPresent(self.manageAccessRole, forKey: .manageAccessRole)
            try container.encodeIfPresent(self.name, forKey: .name)
            try container.encodeIfPresent(self.provider, forKey: .provider)
            try container.encodeIfPresent(self.subscriptionTargetConfig, forKey: .subscriptionTargetConfig)
        }

        public func validate(name: String) throws {
            try self.applicableAssetTypes?.forEach {
                try validate($0, name: "applicableAssetTypes[]", parent: name, max: 256)
                try validate($0, name: "applicableAssetTypes[]", parent: name, min: 1)
                try validate($0, name: "applicableAssetTypes[]", parent: name, pattern: "^[^\\.]*")
            }
            try self.authorizedPrincipals?.forEach {
                try validate($0, name: "authorizedPrincipals[]", parent: name, pattern: "^[a-zA-Z0-9:/._-]*$")
            }
            try self.validate(self.authorizedPrincipals, name: "authorizedPrincipals", parent: name, max: 20)
            try self.validate(self.authorizedPrincipals, name: "authorizedPrincipals", parent: name, min: 1)
            try self.validate(self.domainIdentifier, name: "domainIdentifier", parent: name, pattern: "^dzd[-_][a-zA-Z0-9_-]{1,36}$")
            try self.validate(self.environmentIdentifier, name: "environmentIdentifier", parent: name, pattern: "^[a-zA-Z0-9_-]{1,36}$")
            try self.validate(self.identifier, name: "identifier", parent: name, pattern: "^[a-zA-Z0-9_-]{1,36}$")
            try self.validate(self.manageAccessRole, name: "manageAccessRole", parent: name, pattern: "^arn:aws(|-cn|-us-gov):iam::\\d{12}:(role|role/service-role)/[\\w+=,.@-]*$")
            try self.validate(self.name, name: "name", parent: name, max: 256)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.subscriptionTargetConfig?.forEach {
                try $0.validate(name: "\(name).subscriptionTargetConfig[]")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case applicableAssetTypes = "applicableAssetTypes"
            case authorizedPrincipals = "authorizedPrincipals"
            case manageAccessRole = "manageAccessRole"
            case name = "name"
            case provider = "provider"
            case subscriptionTargetConfig = "subscriptionTargetConfig"
        }
    }

    public struct UpdateSubscriptionTargetOutput: AWSDecodableShape {
        /// The applicable asset types to be updated as part of the UpdateSubscriptionTarget action.
        public let applicableAssetTypes: [String]
        /// The authorized principals to be updated as part of the UpdateSubscriptionTarget action.
        public let authorizedPrincipals: [String]
        /// The timestamp of when a subscription target was created.
        public let createdAt: Date
        /// The Amazon DataZone user who created the subscription target.
        public let createdBy: String
        /// The identifier of the Amazon DataZone domain in which a subscription target is to be updated.
        public let domainId: String
        /// The identifier of the environment in which a subscription target is to be updated.
        public let environmentId: String
        /// Identifier of the subscription target that is to be updated.
        public let id: String
        /// The manage access role to be updated as part of the UpdateSubscriptionTarget action.
        public let manageAccessRole: String?
        /// The name to be updated as part of the UpdateSubscriptionTarget action.
        public let name: String
        /// The identifier of the project in which a subscription target is to be updated.
        public let projectId: String
        /// The provider to be updated as part of the UpdateSubscriptionTarget action.
        public let provider: String
        /// The configuration to be updated as part of the UpdateSubscriptionTarget action.
        public let subscriptionTargetConfig: [SubscriptionTargetForm]
        /// The type to be updated as part of the UpdateSubscriptionTarget action.
        public let type: String
        /// The timestamp of when the subscription target was updated.
        public let updatedAt: Date?
        /// The Amazon DataZone user who updated the subscription target.
        public let updatedBy: String?

        @inlinable
        public init(applicableAssetTypes: [String], authorizedPrincipals: [String], createdAt: Date, createdBy: String, domainId: String, environmentId: String, id: String, manageAccessRole: String? = nil, name: String, projectId: String, provider: String, subscriptionTargetConfig: [SubscriptionTargetForm], type: String, updatedAt: Date? = nil, updatedBy: String? = nil) {
            self.applicableAssetTypes = applicableAssetTypes
            self.authorizedPrincipals = authorizedPrincipals
            self.createdAt = createdAt
            self.createdBy = createdBy
            self.domainId = domainId
            self.environmentId = environmentId
            self.id = id
            self.manageAccessRole = manageAccessRole
            self.name = name
            self.projectId = projectId
            self.provider = provider
            self.subscriptionTargetConfig = subscriptionTargetConfig
            self.type = type
            self.updatedAt = updatedAt
            self.updatedBy = updatedBy
        }

        private enum CodingKeys: String, CodingKey {
            case applicableAssetTypes = "applicableAssetTypes"
            case authorizedPrincipals = "authorizedPrincipals"
            case createdAt = "createdAt"
            case createdBy = "createdBy"
            case domainId = "domainId"
            case environmentId = "environmentId"
            case id = "id"
            case manageAccessRole = "manageAccessRole"
            case name = "name"
            case projectId = "projectId"
            case provider = "provider"
            case subscriptionTargetConfig = "subscriptionTargetConfig"
            case type = "type"
            case updatedAt = "updatedAt"
            case updatedBy = "updatedBy"
        }
    }

    public struct UpdateUserProfileInput: AWSEncodableShape {
        /// The identifier of the Amazon DataZone domain in which a user profile is updated.
        public let domainIdentifier: String
        /// The status of the user profile that are to be updated.
        public let status: UserProfileStatus
        /// The type of the user profile that are to be updated.
        public let type: UserProfileType?
        /// The identifier of the user whose user profile is to be updated.
        public let userIdentifier: String

        @inlinable
        public init(domainIdentifier: String, status: UserProfileStatus, type: UserProfileType? = nil, userIdentifier: String) {
            self.domainIdentifier = domainIdentifier
            self.status = status
            self.type = type
            self.userIdentifier = userIdentifier
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.domainIdentifier, key: "domainIdentifier")
            try container.encode(self.status, forKey: .status)
            try container.encodeIfPresent(self.type, forKey: .type)
            request.encodePath(self.userIdentifier, key: "userIdentifier")
        }

        public func validate(name: String) throws {
            try self.validate(self.domainIdentifier, name: "domainIdentifier", parent: name, pattern: "^dzd[-_][a-zA-Z0-9_-]{1,36}$")
            try self.validate(self.userIdentifier, name: "userIdentifier", parent: name, pattern: "(^([0-9a-f]{10}-|)[A-Fa-f0-9]{8}-[A-Fa-f0-9]{4}-[A-Fa-f0-9]{4}-[A-Fa-f0-9]{4}-[A-Fa-f0-9]{12}$|^[a-zA-Z_0-9+=,.@-]+$|^arn:aws:iam::\\d{12}:.+$)")
        }

        private enum CodingKeys: String, CodingKey {
            case status = "status"
            case type = "type"
        }
    }

    public struct UpdateUserProfileOutput: AWSDecodableShape {
        public let details: UserProfileDetails?
        /// The identifier of the Amazon DataZone domain in which a user profile is updated.
        public let domainId: String?
        /// The identifier of the user profile.
        public let id: String?
        /// The status of the user profile.
        public let status: UserProfileStatus?
        /// The type of the user profile.
        public let type: UserProfileType?

        @inlinable
        public init(details: UserProfileDetails? = nil, domainId: String? = nil, id: String? = nil, status: UserProfileStatus? = nil, type: UserProfileType? = nil) {
            self.details = details
            self.domainId = domainId
            self.id = id
            self.status = status
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case details = "details"
            case domainId = "domainId"
            case id = "id"
            case status = "status"
            case type = "type"
        }
    }

    public struct UserDetails: AWSDecodableShape {
        /// The identifier of the Amazon DataZone user.
        public let userId: String

        @inlinable
        public init(userId: String) {
            self.userId = userId
        }

        private enum CodingKeys: String, CodingKey {
            case userId = "userId"
        }
    }

    public struct UserProfileSummary: AWSDecodableShape {
        /// The details of the user profile.
        public let details: UserProfileDetails?
        /// The ID of the Amazon DataZone domain of the user profile.
        public let domainId: String?
        /// The ID of the user profile.
        public let id: String?
        /// The status of the user profile.
        public let status: UserProfileStatus?
        /// The type of the user profile.
        public let type: UserProfileType?

        @inlinable
        public init(details: UserProfileDetails? = nil, domainId: String? = nil, id: String? = nil, status: UserProfileStatus? = nil, type: UserProfileType? = nil) {
            self.details = details
            self.domainId = domainId
            self.id = id
            self.status = status
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case details = "details"
            case domainId = "domainId"
            case id = "id"
            case status = "status"
            case type = "type"
        }
    }

    public struct UsernamePassword: AWSEncodableShape & AWSDecodableShape {
        /// The password of a connection.
        public let password: String
        /// The username of a connection.
        public let username: String

        @inlinable
        public init(password: String, username: String) {
            self.password = password
            self.username = username
        }

        public func validate(name: String) throws {
            try self.validate(self.password, name: "password", parent: name, max: 64)
            try self.validate(self.username, name: "username", parent: name, max: 64)
        }

        private enum CodingKeys: String, CodingKey {
            case password = "password"
            case username = "username"
        }
    }

    public struct ActionParameters: AWSEncodableShape & AWSDecodableShape {
        /// The console link specified as part of the environment action.
        public let awsConsoleLink: AwsConsoleLinkParameters?

        @inlinable
        public init(awsConsoleLink: AwsConsoleLinkParameters? = nil) {
            self.awsConsoleLink = awsConsoleLink
        }

        private enum CodingKeys: String, CodingKey {
            case awsConsoleLink = "awsConsoleLink"
        }
    }

    public struct DomainUnitGrantFilter: AWSEncodableShape & AWSDecodableShape {
        /// Specifies a grant filter containing all domain units.
        public let allDomainUnitsGrantFilter: AllDomainUnitsGrantFilter?

        @inlinable
        public init(allDomainUnitsGrantFilter: AllDomainUnitsGrantFilter? = nil) {
            self.allDomainUnitsGrantFilter = allDomainUnitsGrantFilter
        }

        private enum CodingKeys: String, CodingKey {
            case allDomainUnitsGrantFilter = "allDomainUnitsGrantFilter"
        }
    }

    public struct EventSummary: AWSDecodableShape {
        /// The open lineage run event summary.
        public let openLineageRunEventSummary: OpenLineageRunEventSummary?

        @inlinable
        public init(openLineageRunEventSummary: OpenLineageRunEventSummary? = nil) {
            self.openLineageRunEventSummary = openLineageRunEventSummary
        }

        private enum CodingKeys: String, CodingKey {
            case openLineageRunEventSummary = "openLineageRunEventSummary"
        }
    }

    public struct GrantedEntity: AWSDecodableShape {
        /// The listing for which a subscription is granted.
        public let listing: ListingRevision?

        @inlinable
        public init(listing: ListingRevision? = nil) {
            self.listing = listing
        }

        private enum CodingKeys: String, CodingKey {
            case listing = "listing"
        }
    }

    public struct GrantedEntityInput: AWSEncodableShape {
        /// The listing for which a subscription is to be granted.
        public let listing: ListingRevisionInput?

        @inlinable
        public init(listing: ListingRevisionInput? = nil) {
            self.listing = listing
        }

        public func validate(name: String) throws {
            try self.listing?.validate(name: "\(name).listing")
        }

        private enum CodingKeys: String, CodingKey {
            case listing = "listing"
        }
    }

    public struct GroupPolicyGrantPrincipal: AWSEncodableShape & AWSDecodableShape {
        /// The ID Of the group of the group principal.
        public let groupIdentifier: String?

        @inlinable
        public init(groupIdentifier: String? = nil) {
            self.groupIdentifier = groupIdentifier
        }

        public func validate(name: String) throws {
            try self.validate(self.groupIdentifier, name: "groupIdentifier", parent: name, pattern: "(^([0-9a-f]{10}-|)[A-Fa-f0-9]{8}-[A-Fa-f0-9]{4}-[A-Fa-f0-9]{4}-[A-Fa-f0-9]{4}-[A-Fa-f0-9]{12}$|[\\p{L}\\p{M}\\p{S}\\p{N}\\p{P}\\t\\n\\r  ]+)")
        }

        private enum CodingKeys: String, CodingKey {
            case groupIdentifier = "groupIdentifier"
        }
    }

    public struct JobRunDetails: AWSDecodableShape {
        /// The data lineage details of a job run.
        public let lineageRunDetails: LineageRunDetails?

        @inlinable
        public init(lineageRunDetails: LineageRunDetails? = nil) {
            self.lineageRunDetails = lineageRunDetails
        }

        private enum CodingKeys: String, CodingKey {
            case lineageRunDetails = "lineageRunDetails"
        }
    }

    public struct Model: AWSEncodableShape & AWSDecodableShape {
        /// Indicates the smithy model of the API.
        public let smithy: String?

        @inlinable
        public init(smithy: String? = nil) {
            self.smithy = smithy
        }

        public func validate(name: String) throws {
            try self.validate(self.smithy, name: "smithy", parent: name, max: 100000)
            try self.validate(self.smithy, name: "smithy", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case smithy = "smithy"
        }
    }

    public struct ProjectGrantFilter: AWSEncodableShape & AWSDecodableShape {
        /// The domain unit filter of the project grant filter.
        public let domainUnitFilter: DomainUnitFilterForProject?

        @inlinable
        public init(domainUnitFilter: DomainUnitFilterForProject? = nil) {
            self.domainUnitFilter = domainUnitFilter
        }

        public func validate(name: String) throws {
            try self.domainUnitFilter?.validate(name: "\(name).domainUnitFilter")
        }

        private enum CodingKeys: String, CodingKey {
            case domainUnitFilter = "domainUnitFilter"
        }
    }

    public struct ProvisioningConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The Lake Formation configuration of the Data Lake blueprint.
        public let lakeFormationConfiguration: LakeFormationConfiguration?

        @inlinable
        public init(lakeFormationConfiguration: LakeFormationConfiguration? = nil) {
            self.lakeFormationConfiguration = lakeFormationConfiguration
        }

        public func validate(name: String) throws {
            try self.lakeFormationConfiguration?.validate(name: "\(name).lakeFormationConfiguration")
        }

        private enum CodingKeys: String, CodingKey {
            case lakeFormationConfiguration = "lakeFormationConfiguration"
        }
    }

    public struct ProvisioningProperties: AWSDecodableShape {
        /// The cloud formation properties included as part of the provisioning properties of an environment blueprint.
        public let cloudFormation: CloudFormationProperties?

        @inlinable
        public init(cloudFormation: CloudFormationProperties? = nil) {
            self.cloudFormation = cloudFormation
        }

        private enum CodingKeys: String, CodingKey {
            case cloudFormation = "cloudFormation"
        }
    }

    public struct RuleDetail: AWSEncodableShape & AWSDecodableShape {
        /// The enforcement detail of the metadata form.
        public let metadataFormEnforcementDetail: MetadataFormEnforcementDetail?

        @inlinable
        public init(metadataFormEnforcementDetail: MetadataFormEnforcementDetail? = nil) {
            self.metadataFormEnforcementDetail = metadataFormEnforcementDetail
        }

        public func validate(name: String) throws {
            try self.metadataFormEnforcementDetail?.validate(name: "\(name).metadataFormEnforcementDetail")
        }

        private enum CodingKeys: String, CodingKey {
            case metadataFormEnforcementDetail = "metadataFormEnforcementDetail"
        }
    }

    public struct RuleTarget: AWSEncodableShape & AWSDecodableShape {
        /// The ID of the domain unit.
        public let domainUnitTarget: DomainUnitTarget?

        @inlinable
        public init(domainUnitTarget: DomainUnitTarget? = nil) {
            self.domainUnitTarget = domainUnitTarget
        }

        public func validate(name: String) throws {
            try self.domainUnitTarget?.validate(name: "\(name).domainUnitTarget")
        }

        private enum CodingKeys: String, CodingKey {
            case domainUnitTarget = "domainUnitTarget"
        }
    }

    public struct SubscribedPrincipal: AWSDecodableShape {
        /// The project that has the subscription grant.
        public let project: SubscribedProject?

        @inlinable
        public init(project: SubscribedProject? = nil) {
            self.project = project
        }

        private enum CodingKeys: String, CodingKey {
            case project = "project"
        }
    }

    public struct SubscribedPrincipalInput: AWSEncodableShape {
        /// The project that is to be given a subscription grant.
        public let project: SubscribedProjectInput?

        @inlinable
        public init(project: SubscribedProjectInput? = nil) {
            self.project = project
        }

        public func validate(name: String) throws {
            try self.project?.validate(name: "\(name).project")
        }

        private enum CodingKeys: String, CodingKey {
            case project = "project"
        }
    }
}

// MARK: - Errors

/// Error enum for DataZone
public struct DataZoneErrorType: AWSErrorType {
    enum Code: String {
        case accessDeniedException = "AccessDeniedException"
        case conflictException = "ConflictException"
        case internalServerException = "InternalServerException"
        case resourceNotFoundException = "ResourceNotFoundException"
        case serviceQuotaExceededException = "ServiceQuotaExceededException"
        case throttlingException = "ThrottlingException"
        case unauthorizedException = "UnauthorizedException"
        case validationException = "ValidationException"
    }

    private let error: Code
    public let context: AWSErrorContext?

    /// initialize DataZone
    public init?(errorCode: String, context: AWSErrorContext) {
        guard let error = Code(rawValue: errorCode) else { return nil }
        self.error = error
        self.context = context
    }

    internal init(_ error: Code) {
        self.error = error
        self.context = nil
    }

    /// return error code string
    public var errorCode: String { self.error.rawValue }

    /// You do not have sufficient access to perform this action.
    public static var accessDeniedException: Self { .init(.accessDeniedException) }
    /// There is a conflict while performing this action.
    public static var conflictException: Self { .init(.conflictException) }
    /// The request has failed because of an unknown error, exception or failure.
    public static var internalServerException: Self { .init(.internalServerException) }
    /// The specified resource cannot be found.
    public static var resourceNotFoundException: Self { .init(.resourceNotFoundException) }
    /// The request has exceeded the specified service quota.
    public static var serviceQuotaExceededException: Self { .init(.serviceQuotaExceededException) }
    /// The request was denied due to request throttling.
    public static var throttlingException: Self { .init(.throttlingException) }
    /// You do not have permission to perform this action.
    public static var unauthorizedException: Self { .init(.unauthorizedException) }
    /// The input fails to satisfy the constraints specified by the Amazon Web Services service.
    public static var validationException: Self { .init(.validationException) }
}

extension DataZoneErrorType: Equatable {
    public static func == (lhs: DataZoneErrorType, rhs: DataZoneErrorType) -> Bool {
        lhs.error == rhs.error
    }
}

extension DataZoneErrorType: CustomStringConvertible {
    public var description: String {
        return "\(self.error.rawValue): \(self.message ?? "")"
    }
}
