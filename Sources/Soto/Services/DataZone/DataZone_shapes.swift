//===----------------------------------------------------------------------===//
//
// This source file is part of the Soto for AWS open source project
//
// Copyright (c) 2017-2023 the Soto project authors
// Licensed under Apache License v2.0
//
// See LICENSE.txt for license information
// See CONTRIBUTORS.txt for the list of Soto project authors
//
// SPDX-License-Identifier: Apache-2.0
//
//===----------------------------------------------------------------------===//

// THIS FILE IS AUTOMATICALLY GENERATED by https://github.com/soto-project/soto-codegenerator.
// DO NOT EDIT.

#if os(Linux) && compiler(<5.10)
// swift-corelibs-foundation hasn't been updated with Sendable conformances
@preconcurrency import Foundation
#else
import Foundation
#endif
@_spi(SotoInternal) import SotoCore

extension DataZone {
    // MARK: Enums

    public enum AcceptRuleBehavior: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case all = "ALL"
        case none = "NONE"
        public var description: String { return self.rawValue }
    }

    public enum AuthType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case disabled = "DISABLED"
        case iamIdc = "IAM_IDC"
        public var description: String { return self.rawValue }
    }

    public enum ChangeAction: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case publish = "PUBLISH"
        case unpublish = "UNPUBLISH"
        public var description: String { return self.rawValue }
    }

    public enum ConfigurableActionTypeAuthorization: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case https = "HTTPS"
        case iam = "IAM"
        public var description: String { return self.rawValue }
    }

    public enum DataAssetActivityStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case failed = "FAILED"
        case publishingFailed = "PUBLISHING_FAILED"
        case skippedAlreadyImported = "SKIPPED_ALREADY_IMPORTED"
        case skippedArchived = "SKIPPED_ARCHIVED"
        case skippedNoAccess = "SKIPPED_NO_ACCESS"
        case succeededCreated = "SUCCEEDED_CREATED"
        case succeededUpdated = "SUCCEEDED_UPDATED"
        case unchanged = "UNCHANGED"
        public var description: String { return self.rawValue }
    }

    public enum DataSourceErrorType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case accessDeniedException = "ACCESS_DENIED_EXCEPTION"
        case conflictException = "CONFLICT_EXCEPTION"
        case internalServerException = "INTERNAL_SERVER_EXCEPTION"
        case resourceNotFoundException = "RESOURCE_NOT_FOUND_EXCEPTION"
        case serviceQuotaExceededException = "SERVICE_QUOTA_EXCEEDED_EXCEPTION"
        case throttlingException = "THROTTLING_EXCEPTION"
        case validationException = "VALIDATION_EXCEPTION"
        public var description: String { return self.rawValue }
    }

    public enum DataSourceRunStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case failed = "FAILED"
        case partiallySucceeded = "PARTIALLY_SUCCEEDED"
        case requested = "REQUESTED"
        case running = "RUNNING"
        case success = "SUCCESS"
        public var description: String { return self.rawValue }
    }

    public enum DataSourceRunType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case prioritized = "PRIORITIZED"
        case scheduled = "SCHEDULED"
        public var description: String { return self.rawValue }
    }

    public enum DataSourceStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case creating = "CREATING"
        case deleting = "DELETING"
        case failedCreation = "FAILED_CREATION"
        case failedDeletion = "FAILED_DELETION"
        case failedUpdate = "FAILED_UPDATE"
        case ready = "READY"
        case running = "RUNNING"
        case updating = "UPDATING"
        public var description: String { return self.rawValue }
    }

    public enum DeploymentStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case failed = "FAILED"
        case inProgress = "IN_PROGRESS"
        case pendingDeployment = "PENDING_DEPLOYMENT"
        case successful = "SUCCESSFUL"
        public var description: String { return self.rawValue }
    }

    public enum DeploymentType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case create = "CREATE"
        case delete = "DELETE"
        case update = "UPDATE"
        public var description: String { return self.rawValue }
    }

    public enum DomainStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case available = "AVAILABLE"
        case creating = "CREATING"
        case creationFailed = "CREATION_FAILED"
        case deleted = "DELETED"
        case deleting = "DELETING"
        case deletionFailed = "DELETION_FAILED"
        public var description: String { return self.rawValue }
    }

    public enum EnableSetting: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case disabled = "DISABLED"
        case enabled = "ENABLED"
        public var description: String { return self.rawValue }
    }

    public enum EntityType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case asset = "ASSET"
        public var description: String { return self.rawValue }
    }

    public enum EnvironmentStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case active = "ACTIVE"
        case createFailed = "CREATE_FAILED"
        case creating = "CREATING"
        case deleteFailed = "DELETE_FAILED"
        case deleted = "DELETED"
        case deleting = "DELETING"
        case disabled = "DISABLED"
        case expired = "EXPIRED"
        case inaccessible = "INACCESSIBLE"
        case suspended = "SUSPENDED"
        case updateFailed = "UPDATE_FAILED"
        case updating = "UPDATING"
        case validationFailed = "VALIDATION_FAILED"
        public var description: String { return self.rawValue }
    }

    public enum FilterExpressionType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case exclude = "EXCLUDE"
        case include = "INCLUDE"
        public var description: String { return self.rawValue }
    }

    public enum FormTypeStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case disabled = "DISABLED"
        case enabled = "ENABLED"
        public var description: String { return self.rawValue }
    }

    public enum GlossaryStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case disabled = "DISABLED"
        case enabled = "ENABLED"
        public var description: String { return self.rawValue }
    }

    public enum GlossaryTermStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case disabled = "DISABLED"
        case enabled = "ENABLED"
        public var description: String { return self.rawValue }
    }

    public enum GroupProfileStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case assigned = "ASSIGNED"
        case notAssigned = "NOT_ASSIGNED"
        public var description: String { return self.rawValue }
    }

    public enum GroupSearchType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case datazoneSsoGroup = "DATAZONE_SSO_GROUP"
        case ssoGroup = "SSO_GROUP"
        public var description: String { return self.rawValue }
    }

    public enum InventorySearchScope: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case asset = "ASSET"
        case glossary = "GLOSSARY"
        case glossaryTerm = "GLOSSARY_TERM"
        public var description: String { return self.rawValue }
    }

    public enum ListingStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case active = "ACTIVE"
        case creating = "CREATING"
        case inactive = "INACTIVE"
        public var description: String { return self.rawValue }
    }

    public enum MetadataGenerationRunStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case canceled = "CANCELED"
        case failed = "FAILED"
        case inProgress = "IN_PROGRESS"
        case submitted = "SUBMITTED"
        case succeeded = "SUCCEEDED"
        public var description: String { return self.rawValue }
    }

    public enum MetadataGenerationRunType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case businessDescriptions = "BUSINESS_DESCRIPTIONS"
        public var description: String { return self.rawValue }
    }

    public enum MetadataGenerationTargetType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case asset = "ASSET"
        public var description: String { return self.rawValue }
    }

    public enum NotificationResourceType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case project = "PROJECT"
        public var description: String { return self.rawValue }
    }

    public enum NotificationRole: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case domainOwner = "DOMAIN_OWNER"
        case projectContributor = "PROJECT_CONTRIBUTOR"
        case projectOwner = "PROJECT_OWNER"
        case projectSubscriber = "PROJECT_SUBSCRIBER"
        case projectViewer = "PROJECT_VIEWER"
        public var description: String { return self.rawValue }
    }

    public enum NotificationType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case event = "EVENT"
        case task = "TASK"
        public var description: String { return self.rawValue }
    }

    public enum ProjectStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case active = "ACTIVE"
        case deleteFailed = "DELETE_FAILED"
        case deleting = "DELETING"
        public var description: String { return self.rawValue }
    }

    public enum RejectRuleBehavior: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case all = "ALL"
        case none = "NONE"
        public var description: String { return self.rawValue }
    }

    public enum SearchOutputAdditionalAttribute: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case forms = "FORMS"
        case timeSeriesDataPointForms = "TIME_SERIES_DATA_POINT_FORMS"
        public var description: String { return self.rawValue }
    }

    public enum SortFieldProject: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case name = "NAME"
        public var description: String { return self.rawValue }
    }

    public enum SortKey: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case createdAt = "CREATED_AT"
        case updatedAt = "UPDATED_AT"
        public var description: String { return self.rawValue }
    }

    public enum SortOrder: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case ascending = "ASCENDING"
        case descending = "DESCENDING"
        public var description: String { return self.rawValue }
    }

    public enum SubscriptionGrantOverallStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case completed = "COMPLETED"
        case grantAndRevokeFailed = "GRANT_AND_REVOKE_FAILED"
        case grantFailed = "GRANT_FAILED"
        case inProgress = "IN_PROGRESS"
        case inaccessible = "INACCESSIBLE"
        case pending = "PENDING"
        case revokeFailed = "REVOKE_FAILED"
        public var description: String { return self.rawValue }
    }

    public enum SubscriptionGrantStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case grantFailed = "GRANT_FAILED"
        case grantInProgress = "GRANT_IN_PROGRESS"
        case grantPending = "GRANT_PENDING"
        case granted = "GRANTED"
        case revokeFailed = "REVOKE_FAILED"
        case revokeInProgress = "REVOKE_IN_PROGRESS"
        case revokePending = "REVOKE_PENDING"
        case revoked = "REVOKED"
        public var description: String { return self.rawValue }
    }

    public enum SubscriptionRequestStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case accepted = "ACCEPTED"
        case pending = "PENDING"
        case rejected = "REJECTED"
        public var description: String { return self.rawValue }
    }

    public enum SubscriptionStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case approved = "APPROVED"
        case cancelled = "CANCELLED"
        case revoked = "REVOKED"
        public var description: String { return self.rawValue }
    }

    public enum TaskStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case active = "ACTIVE"
        case inactive = "INACTIVE"
        public var description: String { return self.rawValue }
    }

    public enum TimeSeriesEntityType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case asset = "ASSET"
        case listing = "LISTING"
        public var description: String { return self.rawValue }
    }

    public enum Timezone: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case africaJohannesburg = "AFRICA_JOHANNESBURG"
        case americaMontreal = "AMERICA_MONTREAL"
        case americaSaoPaulo = "AMERICA_SAO_PAULO"
        case asiaBahrain = "ASIA_BAHRAIN"
        case asiaBangkok = "ASIA_BANGKOK"
        case asiaCalcutta = "ASIA_CALCUTTA"
        case asiaDubai = "ASIA_DUBAI"
        case asiaHongKong = "ASIA_HONG_KONG"
        case asiaJakarta = "ASIA_JAKARTA"
        case asiaKualaLumpur = "ASIA_KUALA_LUMPUR"
        case asiaSeoul = "ASIA_SEOUL"
        case asiaShanghai = "ASIA_SHANGHAI"
        case asiaSingapore = "ASIA_SINGAPORE"
        case asiaTaipei = "ASIA_TAIPEI"
        case asiaTokyo = "ASIA_TOKYO"
        case australiaMelbourne = "AUSTRALIA_MELBOURNE"
        case australiaSydney = "AUSTRALIA_SYDNEY"
        case canadaCentral = "CANADA_CENTRAL"
        case cet = "CET"
        case cst6cdt = "CST6CDT"
        case etcGmt = "ETC_GMT"
        case etcGmt0 = "ETC_GMT0"
        case etcGmtAdd0 = "ETC_GMT_ADD_0"
        case etcGmtAdd1 = "ETC_GMT_ADD_1"
        case etcGmtAdd10 = "ETC_GMT_ADD_10"
        case etcGmtAdd11 = "ETC_GMT_ADD_11"
        case etcGmtAdd12 = "ETC_GMT_ADD_12"
        case etcGmtAdd2 = "ETC_GMT_ADD_2"
        case etcGmtAdd3 = "ETC_GMT_ADD_3"
        case etcGmtAdd4 = "ETC_GMT_ADD_4"
        case etcGmtAdd5 = "ETC_GMT_ADD_5"
        case etcGmtAdd6 = "ETC_GMT_ADD_6"
        case etcGmtAdd7 = "ETC_GMT_ADD_7"
        case etcGmtAdd8 = "ETC_GMT_ADD_8"
        case etcGmtAdd9 = "ETC_GMT_ADD_9"
        case etcGmtNeg0 = "ETC_GMT_NEG_0"
        case etcGmtNeg1 = "ETC_GMT_NEG_1"
        case etcGmtNeg10 = "ETC_GMT_NEG_10"
        case etcGmtNeg11 = "ETC_GMT_NEG_11"
        case etcGmtNeg12 = "ETC_GMT_NEG_12"
        case etcGmtNeg13 = "ETC_GMT_NEG_13"
        case etcGmtNeg14 = "ETC_GMT_NEG_14"
        case etcGmtNeg2 = "ETC_GMT_NEG_2"
        case etcGmtNeg3 = "ETC_GMT_NEG_3"
        case etcGmtNeg4 = "ETC_GMT_NEG_4"
        case etcGmtNeg5 = "ETC_GMT_NEG_5"
        case etcGmtNeg6 = "ETC_GMT_NEG_6"
        case etcGmtNeg7 = "ETC_GMT_NEG_7"
        case etcGmtNeg8 = "ETC_GMT_NEG_8"
        case etcGmtNeg9 = "ETC_GMT_NEG_9"
        case europeDublin = "EUROPE_DUBLIN"
        case europeLondon = "EUROPE_LONDON"
        case europeParis = "EUROPE_PARIS"
        case europeStockholm = "EUROPE_STOCKHOLM"
        case europeZurich = "EUROPE_ZURICH"
        case israel = "ISRAEL"
        case mexicoGeneral = "MEXICO_GENERAL"
        case mst7mdt = "MST7MDT"
        case pacificAuckland = "PACIFIC_AUCKLAND"
        case usCentral = "US_CENTRAL"
        case usEastern = "US_EASTERN"
        case usMountain = "US_MOUNTAIN"
        case usPacific = "US_PACIFIC"
        case utc = "UTC"
        public var description: String { return self.rawValue }
    }

    public enum TypesSearchScope: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case assetType = "ASSET_TYPE"
        case formType = "FORM_TYPE"
        public var description: String { return self.rawValue }
    }

    public enum UserAssignment: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case automatic = "AUTOMATIC"
        case manual = "MANUAL"
        public var description: String { return self.rawValue }
    }

    public enum UserDesignation: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case projectContributor = "PROJECT_CONTRIBUTOR"
        case projectOwner = "PROJECT_OWNER"
        public var description: String { return self.rawValue }
    }

    public enum UserProfileStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case activated = "ACTIVATED"
        case assigned = "ASSIGNED"
        case deactivated = "DEACTIVATED"
        case notAssigned = "NOT_ASSIGNED"
        public var description: String { return self.rawValue }
    }

    public enum UserProfileType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case iam = "IAM"
        case sso = "SSO"
        public var description: String { return self.rawValue }
    }

    public enum UserSearchType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case datazoneIamUser = "DATAZONE_IAM_USER"
        case datazoneSsoUser = "DATAZONE_SSO_USER"
        case datazoneUser = "DATAZONE_USER"
        case ssoUser = "SSO_USER"
        public var description: String { return self.rawValue }
    }

    public enum UserType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case iamRole = "IAM_ROLE"
        case iamUser = "IAM_USER"
        case ssoUser = "SSO_USER"
        public var description: String { return self.rawValue }
    }

    public enum DataSourceConfigurationInput: AWSEncodableShape, Sendable {
        /// The configuration of the Amazon Web Services Glue data source.
        case glueRunConfiguration(GlueRunConfigurationInput)
        /// The configuration of the Amazon Redshift data source.
        case redshiftRunConfiguration(RedshiftRunConfigurationInput)

        public func encode(to encoder: Encoder) throws {
            var container = encoder.container(keyedBy: CodingKeys.self)
            switch self {
            case .glueRunConfiguration(let value):
                try container.encode(value, forKey: .glueRunConfiguration)
            case .redshiftRunConfiguration(let value):
                try container.encode(value, forKey: .redshiftRunConfiguration)
            }
        }

        private enum CodingKeys: String, CodingKey {
            case glueRunConfiguration = "glueRunConfiguration"
            case redshiftRunConfiguration = "redshiftRunConfiguration"
        }
    }

    public enum DataSourceConfigurationOutput: AWSDecodableShape, Sendable {
        /// The configuration of the Amazon Web Services Glue data source.
        case glueRunConfiguration(GlueRunConfigurationOutput)
        /// The configuration of the Amazon Redshift data source.
        case redshiftRunConfiguration(RedshiftRunConfigurationOutput)

        public init(from decoder: Decoder) throws {
            let container = try decoder.container(keyedBy: CodingKeys.self)
            guard container.allKeys.count == 1, let key = container.allKeys.first else {
                let context = DecodingError.Context(
                    codingPath: container.codingPath,
                    debugDescription: "Expected exactly one key, but got \(container.allKeys.count)"
                )
                throw DecodingError.dataCorrupted(context)
            }
            switch key {
            case .glueRunConfiguration:
                let value = try container.decode(GlueRunConfigurationOutput.self, forKey: .glueRunConfiguration)
                self = .glueRunConfiguration(value)
            case .redshiftRunConfiguration:
                let value = try container.decode(RedshiftRunConfigurationOutput.self, forKey: .redshiftRunConfiguration)
                self = .redshiftRunConfiguration(value)
            }
        }

        private enum CodingKeys: String, CodingKey {
            case glueRunConfiguration = "glueRunConfiguration"
            case redshiftRunConfiguration = "redshiftRunConfiguration"
        }
    }

    public enum FilterClause: AWSEncodableShape, Sendable {
        /// The 'and' search filter clause in Amazon DataZone.
        case and([FilterClause])
        /// A search filter in Amazon DataZone.
        case filter(Filter)
        /// The 'or' search filter clause in Amazon DataZone.
        case or([FilterClause])

        public func encode(to encoder: Encoder) throws {
            var container = encoder.container(keyedBy: CodingKeys.self)
            switch self {
            case .and(let value):
                try container.encode(value, forKey: .and)
            case .filter(let value):
                try container.encode(value, forKey: .filter)
            case .or(let value):
                try container.encode(value, forKey: .or)
            }
        }

        public func validate(name: String) throws {
            switch self {
            case .and(let value):
                try value.forEach {
                    try $0.validate(name: "\(name).and[]")
                }
                try self.validate(value, name: "and", parent: name, max: 100)
                try self.validate(value, name: "and", parent: name, min: 1)
            case .filter(let value):
                try value.validate(name: "\(name).filter")
            case .or(let value):
                try value.forEach {
                    try $0.validate(name: "\(name).or[]")
                }
                try self.validate(value, name: "or", parent: name, max: 100)
                try self.validate(value, name: "or", parent: name, min: 1)
            }
        }

        private enum CodingKeys: String, CodingKey {
            case and = "and"
            case filter = "filter"
            case or = "or"
        }
    }

    public enum Member: AWSEncodableShape, Sendable {
        /// The ID of the group of a project member.
        case groupIdentifier(String)
        /// The user ID of a project member.
        case userIdentifier(String)

        public func encode(to encoder: Encoder) throws {
            var container = encoder.container(keyedBy: CodingKeys.self)
            switch self {
            case .groupIdentifier(let value):
                try container.encode(value, forKey: .groupIdentifier)
            case .userIdentifier(let value):
                try container.encode(value, forKey: .userIdentifier)
            }
        }

        private enum CodingKeys: String, CodingKey {
            case groupIdentifier = "groupIdentifier"
            case userIdentifier = "userIdentifier"
        }
    }

    public enum MemberDetails: AWSDecodableShape, Sendable {
        /// The group details of a project member.
        case group(GroupDetails)
        /// The user details of a project member.
        case user(UserDetails)

        public init(from decoder: Decoder) throws {
            let container = try decoder.container(keyedBy: CodingKeys.self)
            guard container.allKeys.count == 1, let key = container.allKeys.first else {
                let context = DecodingError.Context(
                    codingPath: container.codingPath,
                    debugDescription: "Expected exactly one key, but got \(container.allKeys.count)"
                )
                throw DecodingError.dataCorrupted(context)
            }
            switch key {
            case .group:
                let value = try container.decode(GroupDetails.self, forKey: .group)
                self = .group(value)
            case .user:
                let value = try container.decode(UserDetails.self, forKey: .user)
                self = .user(value)
            }
        }

        private enum CodingKeys: String, CodingKey {
            case group = "group"
            case user = "user"
        }
    }

    public enum RedshiftStorage: AWSEncodableShape & AWSDecodableShape, Sendable {
        /// The details of the Amazon Redshift cluster source.
        case redshiftClusterSource(RedshiftClusterStorage)
        /// The details of the Amazon Redshift Serverless workgroup source.
        case redshiftServerlessSource(RedshiftServerlessStorage)

        public init(from decoder: Decoder) throws {
            let container = try decoder.container(keyedBy: CodingKeys.self)
            guard container.allKeys.count == 1, let key = container.allKeys.first else {
                let context = DecodingError.Context(
                    codingPath: container.codingPath,
                    debugDescription: "Expected exactly one key, but got \(container.allKeys.count)"
                )
                throw DecodingError.dataCorrupted(context)
            }
            switch key {
            case .redshiftClusterSource:
                let value = try container.decode(RedshiftClusterStorage.self, forKey: .redshiftClusterSource)
                self = .redshiftClusterSource(value)
            case .redshiftServerlessSource:
                let value = try container.decode(RedshiftServerlessStorage.self, forKey: .redshiftServerlessSource)
                self = .redshiftServerlessSource(value)
            }
        }

        public func encode(to encoder: Encoder) throws {
            var container = encoder.container(keyedBy: CodingKeys.self)
            switch self {
            case .redshiftClusterSource(let value):
                try container.encode(value, forKey: .redshiftClusterSource)
            case .redshiftServerlessSource(let value):
                try container.encode(value, forKey: .redshiftServerlessSource)
            }
        }

        private enum CodingKeys: String, CodingKey {
            case redshiftClusterSource = "redshiftClusterSource"
            case redshiftServerlessSource = "redshiftServerlessSource"
        }
    }

    public enum SearchInventoryResultItem: AWSDecodableShape, Sendable {
        /// The asset item included in the search results.
        case assetItem(AssetItem)
        /// The data product item included in the search results.
        case dataProductItem(DataProductSummary)
        /// The glossary item included in the search results.
        case glossaryItem(GlossaryItem)
        /// The glossary term item included in the search results.
        case glossaryTermItem(GlossaryTermItem)

        public init(from decoder: Decoder) throws {
            let container = try decoder.container(keyedBy: CodingKeys.self)
            guard container.allKeys.count == 1, let key = container.allKeys.first else {
                let context = DecodingError.Context(
                    codingPath: container.codingPath,
                    debugDescription: "Expected exactly one key, but got \(container.allKeys.count)"
                )
                throw DecodingError.dataCorrupted(context)
            }
            switch key {
            case .assetItem:
                let value = try container.decode(AssetItem.self, forKey: .assetItem)
                self = .assetItem(value)
            case .dataProductItem:
                let value = try container.decode(DataProductSummary.self, forKey: .dataProductItem)
                self = .dataProductItem(value)
            case .glossaryItem:
                let value = try container.decode(GlossaryItem.self, forKey: .glossaryItem)
                self = .glossaryItem(value)
            case .glossaryTermItem:
                let value = try container.decode(GlossaryTermItem.self, forKey: .glossaryTermItem)
                self = .glossaryTermItem(value)
            }
        }

        private enum CodingKeys: String, CodingKey {
            case assetItem = "assetItem"
            case dataProductItem = "dataProductItem"
            case glossaryItem = "glossaryItem"
            case glossaryTermItem = "glossaryTermItem"
        }
    }

    public enum SearchTypesResultItem: AWSDecodableShape, Sendable {
        /// The asset type included in the results of the SearchTypes action.
        case assetTypeItem(AssetTypeItem)
        /// The form type included in the results of the SearchTypes action.
        case formTypeItem(FormTypeData)

        public init(from decoder: Decoder) throws {
            let container = try decoder.container(keyedBy: CodingKeys.self)
            guard container.allKeys.count == 1, let key = container.allKeys.first else {
                let context = DecodingError.Context(
                    codingPath: container.codingPath,
                    debugDescription: "Expected exactly one key, but got \(container.allKeys.count)"
                )
                throw DecodingError.dataCorrupted(context)
            }
            switch key {
            case .assetTypeItem:
                let value = try container.decode(AssetTypeItem.self, forKey: .assetTypeItem)
                self = .assetTypeItem(value)
            case .formTypeItem:
                let value = try container.decode(FormTypeData.self, forKey: .formTypeItem)
                self = .formTypeItem(value)
            }
        }

        private enum CodingKeys: String, CodingKey {
            case assetTypeItem = "assetTypeItem"
            case formTypeItem = "formTypeItem"
        }
    }

    public enum UserProfileDetails: AWSDecodableShape, Sendable {
        /// The IAM details included in the user profile details.
        case iam(IamUserProfileDetails)
        /// The single sign-on details included in the user profile details.
        case sso(SsoUserProfileDetails)

        public init(from decoder: Decoder) throws {
            let container = try decoder.container(keyedBy: CodingKeys.self)
            guard container.allKeys.count == 1, let key = container.allKeys.first else {
                let context = DecodingError.Context(
                    codingPath: container.codingPath,
                    debugDescription: "Expected exactly one key, but got \(container.allKeys.count)"
                )
                throw DecodingError.dataCorrupted(context)
            }
            switch key {
            case .iam:
                let value = try container.decode(IamUserProfileDetails.self, forKey: .iam)
                self = .iam(value)
            case .sso:
                let value = try container.decode(SsoUserProfileDetails.self, forKey: .sso)
                self = .sso(value)
            }
        }

        private enum CodingKeys: String, CodingKey {
            case iam = "iam"
            case sso = "sso"
        }
    }

    // MARK: Shapes

    public struct AcceptChoice: AWSEncodableShape {
        /// The edit of the prediction.
        public let editedValue: String?
        /// Specifies the prediction (aka, the automatically generated piece of metadata) that can be accepted.
        public let predictionChoice: Int?
        /// Specifies the target (for example, a column name) where a prediction can be accepted.
        public let predictionTarget: String?

        public init(editedValue: String? = nil, predictionChoice: Int? = nil, predictionTarget: String? = nil) {
            self.editedValue = editedValue
            self.predictionChoice = predictionChoice
            self.predictionTarget = predictionTarget
        }

        public func validate(name: String) throws {
            try self.validate(self.editedValue, name: "editedValue", parent: name, max: 5000)
            try self.validate(self.editedValue, name: "editedValue", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case editedValue = "editedValue"
            case predictionChoice = "predictionChoice"
            case predictionTarget = "predictionTarget"
        }
    }

    public struct AcceptPredictionsInput: AWSEncodableShape {
        /// Specifies the prediction (aka, the automatically generated piece of metadata) and the target (for example, a column name) that can be accepted.
        public let acceptChoices: [AcceptChoice]?
        /// Specifies the rule (or the conditions) under which a prediction can be accepted.
        public let acceptRule: AcceptRule?
        /// A unique, case-sensitive identifier to ensure idempotency of the request. This field is automatically populated if not provided.
        public let clientToken: String?
        /// The identifier of the Amazon DataZone domain.
        public let domainIdentifier: String
        /// The identifier of the asset.
        public let identifier: String
        /// The revision that is to be made to the asset.
        public let revision: String?

        public init(acceptChoices: [AcceptChoice]? = nil, acceptRule: AcceptRule? = nil, clientToken: String? = AcceptPredictionsInput.idempotencyToken(), domainIdentifier: String, identifier: String, revision: String? = nil) {
            self.acceptChoices = acceptChoices
            self.acceptRule = acceptRule
            self.clientToken = clientToken
            self.domainIdentifier = domainIdentifier
            self.identifier = identifier
            self.revision = revision
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.acceptChoices, forKey: .acceptChoices)
            try container.encodeIfPresent(self.acceptRule, forKey: .acceptRule)
            try container.encodeIfPresent(self.clientToken, forKey: .clientToken)
            request.encodePath(self.domainIdentifier, key: "domainIdentifier")
            request.encodePath(self.identifier, key: "identifier")
            request.encodeQuery(self.revision, key: "revision")
        }

        public func validate(name: String) throws {
            try self.acceptChoices?.forEach {
                try $0.validate(name: "\(name).acceptChoices[]")
            }
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 128)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "^[\\x21-\\x7E]+$")
            try self.validate(self.domainIdentifier, name: "domainIdentifier", parent: name, pattern: "^dzd[-_][a-zA-Z0-9_-]{1,36}$")
            try self.validate(self.identifier, name: "identifier", parent: name, pattern: "^[a-zA-Z0-9_-]{1,36}$")
            try self.validate(self.revision, name: "revision", parent: name, max: 64)
            try self.validate(self.revision, name: "revision", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case acceptChoices = "acceptChoices"
            case acceptRule = "acceptRule"
            case clientToken = "clientToken"
        }
    }

    public struct AcceptPredictionsOutput: AWSDecodableShape {
        /// The ID of the asset.
        public let assetId: String
        /// The identifier of the Amazon DataZone domain.
        public let domainId: String
        /// The revision that is to be made to the asset.
        public let revision: String

        public init(assetId: String, domainId: String, revision: String) {
            self.assetId = assetId
            self.domainId = domainId
            self.revision = revision
        }

        private enum CodingKeys: String, CodingKey {
            case assetId = "assetId"
            case domainId = "domainId"
            case revision = "revision"
        }
    }

    public struct AcceptRule: AWSEncodableShape {
        /// Specifies whether you want to accept the top prediction for all targets or none.
        public let rule: AcceptRuleBehavior?
        /// The confidence score that specifies the condition at which a prediction can be accepted.
        public let threshold: Float?

        public init(rule: AcceptRuleBehavior? = nil, threshold: Float? = nil) {
            self.rule = rule
            self.threshold = threshold
        }

        private enum CodingKeys: String, CodingKey {
            case rule = "rule"
            case threshold = "threshold"
        }
    }

    public struct AcceptSubscriptionRequestInput: AWSEncodableShape {
        /// A description that specifies the reason for accepting the specified subscription request.
        public let decisionComment: String?
        /// The Amazon DataZone domain where the specified subscription request is being accepted.
        public let domainIdentifier: String
        /// The unique identifier of the subscription request that is to be accepted.
        public let identifier: String

        public init(decisionComment: String? = nil, domainIdentifier: String, identifier: String) {
            self.decisionComment = decisionComment
            self.domainIdentifier = domainIdentifier
            self.identifier = identifier
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.decisionComment, forKey: .decisionComment)
            request.encodePath(self.domainIdentifier, key: "domainIdentifier")
            request.encodePath(self.identifier, key: "identifier")
        }

        public func validate(name: String) throws {
            try self.validate(self.decisionComment, name: "decisionComment", parent: name, max: 4096)
            try self.validate(self.decisionComment, name: "decisionComment", parent: name, min: 1)
            try self.validate(self.domainIdentifier, name: "domainIdentifier", parent: name, pattern: "^dzd[-_][a-zA-Z0-9_-]{1,36}$")
            try self.validate(self.identifier, name: "identifier", parent: name, pattern: "^[a-zA-Z0-9_-]{1,36}$")
        }

        private enum CodingKeys: String, CodingKey {
            case decisionComment = "decisionComment"
        }
    }

    public struct AcceptSubscriptionRequestOutput: AWSDecodableShape {
        /// The timestamp that specifies when the subscription request was accepted.
        public let createdAt: Date
        /// Specifies the Amazon DataZone user that accepted the specified subscription request.
        public let createdBy: String
        /// Specifies the reason for accepting the subscription request.
        public let decisionComment: String?
        /// The unique identifier of the Amazon DataZone domain where the specified subscription request was accepted.
        public let domainId: String
        /// The identifier of the subscription request.
        public let id: String
        /// Specifies the reason for requesting a subscription to the asset.
        public let requestReason: String
        /// Specifes the ID of the Amazon DataZone user who reviewed the subscription request.
        public let reviewerId: String?
        /// Specifies the status of the subscription request.
        public let status: SubscriptionRequestStatus
        /// Specifies the asset for which the subscription request was created.
        public let subscribedListings: [SubscribedListing]
        /// Specifies the Amazon DataZone users who are subscribed to the asset specified in the subscription request.
        public let subscribedPrincipals: [SubscribedPrincipal]
        /// Specifies the timestamp when subscription request was updated.
        public let updatedAt: Date
        /// Specifies the Amazon DataZone user who updated the subscription request.
        public let updatedBy: String?

        public init(createdAt: Date, createdBy: String, decisionComment: String? = nil, domainId: String, id: String, requestReason: String, reviewerId: String? = nil, status: SubscriptionRequestStatus, subscribedListings: [SubscribedListing], subscribedPrincipals: [SubscribedPrincipal], updatedAt: Date, updatedBy: String? = nil) {
            self.createdAt = createdAt
            self.createdBy = createdBy
            self.decisionComment = decisionComment
            self.domainId = domainId
            self.id = id
            self.requestReason = requestReason
            self.reviewerId = reviewerId
            self.status = status
            self.subscribedListings = subscribedListings
            self.subscribedPrincipals = subscribedPrincipals
            self.updatedAt = updatedAt
            self.updatedBy = updatedBy
        }

        private enum CodingKeys: String, CodingKey {
            case createdAt = "createdAt"
            case createdBy = "createdBy"
            case decisionComment = "decisionComment"
            case domainId = "domainId"
            case id = "id"
            case requestReason = "requestReason"
            case reviewerId = "reviewerId"
            case status = "status"
            case subscribedListings = "subscribedListings"
            case subscribedPrincipals = "subscribedPrincipals"
            case updatedAt = "updatedAt"
            case updatedBy = "updatedBy"
        }
    }

    public struct AssetItem: AWSDecodableShape {
        /// The additional attributes of a Amazon DataZone inventory asset.
        public let additionalAttributes: AssetItemAdditionalAttributes?
        /// The timestamp of when the Amazon DataZone inventory asset was created.
        public let createdAt: Date?
        /// The Amazon DataZone user who created the inventory asset.
        public let createdBy: String?
        /// The description of an Amazon DataZone inventory asset.
        public let description: String?
        /// The identifier of the Amazon DataZone domain in which the inventory asset exists.
        public let domainId: String
        /// The external identifier of the Amazon DataZone inventory asset.
        public let externalIdentifier: String?
        /// The timestamp of when the first revision of the inventory asset was created.
        public let firstRevisionCreatedAt: Date?
        /// The Amazon DataZone user who created the first revision of the inventory asset.
        public let firstRevisionCreatedBy: String?
        /// The glossary terms attached to the Amazon DataZone inventory asset.
        public let glossaryTerms: [String]?
        /// the identifier of the Amazon DataZone inventory asset.
        public let identifier: String
        /// The name of the Amazon DataZone inventory asset.
        public let name: String
        /// The identifier of the Amazon DataZone project that owns the inventory asset.
        public let owningProjectId: String
        /// The identifier of the asset type of the specified Amazon DataZone inventory asset.
        public let typeIdentifier: String
        /// The revision of the inventory asset type.
        public let typeRevision: String

        public init(additionalAttributes: AssetItemAdditionalAttributes? = nil, createdAt: Date? = nil, createdBy: String? = nil, description: String? = nil, domainId: String, externalIdentifier: String? = nil, firstRevisionCreatedAt: Date? = nil, firstRevisionCreatedBy: String? = nil, glossaryTerms: [String]? = nil, identifier: String, name: String, owningProjectId: String, typeIdentifier: String, typeRevision: String) {
            self.additionalAttributes = additionalAttributes
            self.createdAt = createdAt
            self.createdBy = createdBy
            self.description = description
            self.domainId = domainId
            self.externalIdentifier = externalIdentifier
            self.firstRevisionCreatedAt = firstRevisionCreatedAt
            self.firstRevisionCreatedBy = firstRevisionCreatedBy
            self.glossaryTerms = glossaryTerms
            self.identifier = identifier
            self.name = name
            self.owningProjectId = owningProjectId
            self.typeIdentifier = typeIdentifier
            self.typeRevision = typeRevision
        }

        private enum CodingKeys: String, CodingKey {
            case additionalAttributes = "additionalAttributes"
            case createdAt = "createdAt"
            case createdBy = "createdBy"
            case description = "description"
            case domainId = "domainId"
            case externalIdentifier = "externalIdentifier"
            case firstRevisionCreatedAt = "firstRevisionCreatedAt"
            case firstRevisionCreatedBy = "firstRevisionCreatedBy"
            case glossaryTerms = "glossaryTerms"
            case identifier = "identifier"
            case name = "name"
            case owningProjectId = "owningProjectId"
            case typeIdentifier = "typeIdentifier"
            case typeRevision = "typeRevision"
        }
    }

    public struct AssetItemAdditionalAttributes: AWSDecodableShape {
        /// The forms included in the additional attributes of an inventory asset.
        public let formsOutput: [FormOutput]?
        /// The latest time series data points forms included in the additional attributes of an asset.
        public let latestTimeSeriesDataPointFormsOutput: [TimeSeriesDataPointSummaryFormOutput]?
        /// The read-only forms included in the additional attributes of an inventory asset.
        public let readOnlyFormsOutput: [FormOutput]?

        public init(formsOutput: [FormOutput]? = nil, latestTimeSeriesDataPointFormsOutput: [TimeSeriesDataPointSummaryFormOutput]? = nil, readOnlyFormsOutput: [FormOutput]? = nil) {
            self.formsOutput = formsOutput
            self.latestTimeSeriesDataPointFormsOutput = latestTimeSeriesDataPointFormsOutput
            self.readOnlyFormsOutput = readOnlyFormsOutput
        }

        private enum CodingKeys: String, CodingKey {
            case formsOutput = "formsOutput"
            case latestTimeSeriesDataPointFormsOutput = "latestTimeSeriesDataPointFormsOutput"
            case readOnlyFormsOutput = "readOnlyFormsOutput"
        }
    }

    public struct AssetListing: AWSDecodableShape {
        /// The identifier of an asset published in an Amazon DataZone catalog.
        public let assetId: String?
        /// The revision of an asset published in an Amazon DataZone catalog.
        public let assetRevision: String?
        /// The type of an asset published in an Amazon DataZone catalog.
        public let assetType: String?
        /// The timestamp of when an asset published in an Amazon DataZone catalog was created.
        public let createdAt: Date?
        /// The metadata forms attached to an asset published in an Amazon DataZone catalog.
        public let forms: String?
        /// The glossary terms attached to an asset published in an Amazon DataZone catalog.
        public let glossaryTerms: [DetailedGlossaryTerm]?
        /// The latest time series data points forms included in the additional attributes of an asset.
        public let latestTimeSeriesDataPointForms: [TimeSeriesDataPointSummaryFormOutput]?
        /// The identifier of the project where an asset published in an Amazon DataZone catalog exists.
        public let owningProjectId: String?

        public init(assetId: String? = nil, assetRevision: String? = nil, assetType: String? = nil, createdAt: Date? = nil, forms: String? = nil, glossaryTerms: [DetailedGlossaryTerm]? = nil, latestTimeSeriesDataPointForms: [TimeSeriesDataPointSummaryFormOutput]? = nil, owningProjectId: String? = nil) {
            self.assetId = assetId
            self.assetRevision = assetRevision
            self.assetType = assetType
            self.createdAt = createdAt
            self.forms = forms
            self.glossaryTerms = glossaryTerms
            self.latestTimeSeriesDataPointForms = latestTimeSeriesDataPointForms
            self.owningProjectId = owningProjectId
        }

        private enum CodingKeys: String, CodingKey {
            case assetId = "assetId"
            case assetRevision = "assetRevision"
            case assetType = "assetType"
            case createdAt = "createdAt"
            case forms = "forms"
            case glossaryTerms = "glossaryTerms"
            case latestTimeSeriesDataPointForms = "latestTimeSeriesDataPointForms"
            case owningProjectId = "owningProjectId"
        }
    }

    public struct AssetListingDetails: AWSDecodableShape {
        /// The identifier of an asset published in an Amazon DataZone catalog.
        public let listingId: String
        /// The status of an asset published in an Amazon DataZone catalog.
        public let listingStatus: ListingStatus

        public init(listingId: String, listingStatus: ListingStatus) {
            self.listingId = listingId
            self.listingStatus = listingStatus
        }

        private enum CodingKeys: String, CodingKey {
            case listingId = "listingId"
            case listingStatus = "listingStatus"
        }
    }

    public struct AssetListingItem: AWSDecodableShape {
        /// The additional attributes of an asset published in an Amazon DataZone catalog.
        public let additionalAttributes: AssetListingItemAdditionalAttributes?
        /// The timestamp of when an asset published in an Amazon DataZone catalog was created.
        public let createdAt: Date?
        /// The description of an asset published in an Amazon DataZone catalog.
        public let description: String?
        /// The identifier of the inventory asset.
        public let entityId: String?
        /// The revision of the inventory asset.
        public let entityRevision: String?
        /// The type of the inventory asset.
        public let entityType: String?
        /// Glossary terms attached to the inventory asset.
        public let glossaryTerms: [DetailedGlossaryTerm]?
        /// The Amazon DataZone user who created the listing.
        public let listingCreatedBy: String?
        /// The identifier of the listing (asset published in Amazon DataZone catalog).
        public let listingId: String?
        /// The revision of the listing (asset published in Amazon DataZone catalog).
        public let listingRevision: String?
        /// The Amazon DataZone user who updated the listing.
        public let listingUpdatedBy: String?
        /// The name of the inventory asset.
        public let name: String?
        /// The identifier of the project that owns the inventory asset.
        public let owningProjectId: String?

        public init(additionalAttributes: AssetListingItemAdditionalAttributes? = nil, createdAt: Date? = nil, description: String? = nil, entityId: String? = nil, entityRevision: String? = nil, entityType: String? = nil, glossaryTerms: [DetailedGlossaryTerm]? = nil, listingCreatedBy: String? = nil, listingId: String? = nil, listingRevision: String? = nil, listingUpdatedBy: String? = nil, name: String? = nil, owningProjectId: String? = nil) {
            self.additionalAttributes = additionalAttributes
            self.createdAt = createdAt
            self.description = description
            self.entityId = entityId
            self.entityRevision = entityRevision
            self.entityType = entityType
            self.glossaryTerms = glossaryTerms
            self.listingCreatedBy = listingCreatedBy
            self.listingId = listingId
            self.listingRevision = listingRevision
            self.listingUpdatedBy = listingUpdatedBy
            self.name = name
            self.owningProjectId = owningProjectId
        }

        private enum CodingKeys: String, CodingKey {
            case additionalAttributes = "additionalAttributes"
            case createdAt = "createdAt"
            case description = "description"
            case entityId = "entityId"
            case entityRevision = "entityRevision"
            case entityType = "entityType"
            case glossaryTerms = "glossaryTerms"
            case listingCreatedBy = "listingCreatedBy"
            case listingId = "listingId"
            case listingRevision = "listingRevision"
            case listingUpdatedBy = "listingUpdatedBy"
            case name = "name"
            case owningProjectId = "owningProjectId"
        }
    }

    public struct AssetListingItemAdditionalAttributes: AWSDecodableShape {
        /// The metadata forms that form additional attributes of the metadata asset.
        public let forms: String?
        /// The latest time series data points forms included in the additional attributes of an asset.
        public let latestTimeSeriesDataPointForms: [TimeSeriesDataPointSummaryFormOutput]?

        public init(forms: String? = nil, latestTimeSeriesDataPointForms: [TimeSeriesDataPointSummaryFormOutput]? = nil) {
            self.forms = forms
            self.latestTimeSeriesDataPointForms = latestTimeSeriesDataPointForms
        }

        private enum CodingKeys: String, CodingKey {
            case forms = "forms"
            case latestTimeSeriesDataPointForms = "latestTimeSeriesDataPointForms"
        }
    }

    public struct AssetRevision: AWSDecodableShape {
        /// The timestamp of when an inventory asset revison was created.
        public let createdAt: Date?
        /// The Amazon DataZone user who created the asset revision.
        public let createdBy: String?
        /// The Amazon DataZone user who created the inventory asset.
        public let domainId: String?
        /// The identifier of the inventory asset revision.
        public let id: String?
        /// The revision details of the inventory asset.
        public let revision: String?

        public init(createdAt: Date? = nil, createdBy: String? = nil, domainId: String? = nil, id: String? = nil, revision: String? = nil) {
            self.createdAt = createdAt
            self.createdBy = createdBy
            self.domainId = domainId
            self.id = id
            self.revision = revision
        }

        private enum CodingKeys: String, CodingKey {
            case createdAt = "createdAt"
            case createdBy = "createdBy"
            case domainId = "domainId"
            case id = "id"
            case revision = "revision"
        }
    }

    public struct AssetTargetNameMap: AWSEncodableShape {
        /// The identifier of the inventory asset.
        public let assetId: String
        /// The target name in the asset target name map.
        public let targetName: String

        public init(assetId: String, targetName: String) {
            self.assetId = assetId
            self.targetName = targetName
        }

        public func validate(name: String) throws {
            try self.validate(self.assetId, name: "assetId", parent: name, pattern: "^[a-zA-Z0-9_-]{1,36}$")
        }

        private enum CodingKeys: String, CodingKey {
            case assetId = "assetId"
            case targetName = "targetName"
        }
    }

    public struct AssetTypeItem: AWSDecodableShape {
        /// The timestamp of when the asset type was created.
        public let createdAt: Date?
        /// The Amazon DataZone user who created the asset type.
        public let createdBy: String?
        /// The description of the asset type.
        public let description: String?
        /// The identifier of the Amazon DataZone domain where the asset type exists.
        public let domainId: String
        /// The forms included in the details of the asset type.
        public let formsOutput: [String: FormEntryOutput]
        /// The name of the asset type.
        public let name: String
        /// The identifier of the Amazon DataZone domain where the asset type was originally created.
        public let originDomainId: String?
        /// The identifier of the Amazon DataZone project where the asset type exists.
        public let originProjectId: String?
        /// The identifier of the Amazon DataZone project that owns the asset type.
        public let owningProjectId: String
        /// The revision of the asset type.
        public let revision: String
        /// The timestamp of when the asset type was updated.
        public let updatedAt: Date?
        /// The Amazon DataZone user who updated the asset type.
        public let updatedBy: String?

        public init(createdAt: Date? = nil, createdBy: String? = nil, description: String? = nil, domainId: String, formsOutput: [String: FormEntryOutput], name: String, originDomainId: String? = nil, originProjectId: String? = nil, owningProjectId: String, revision: String, updatedAt: Date? = nil, updatedBy: String? = nil) {
            self.createdAt = createdAt
            self.createdBy = createdBy
            self.description = description
            self.domainId = domainId
            self.formsOutput = formsOutput
            self.name = name
            self.originDomainId = originDomainId
            self.originProjectId = originProjectId
            self.owningProjectId = owningProjectId
            self.revision = revision
            self.updatedAt = updatedAt
            self.updatedBy = updatedBy
        }

        private enum CodingKeys: String, CodingKey {
            case createdAt = "createdAt"
            case createdBy = "createdBy"
            case description = "description"
            case domainId = "domainId"
            case formsOutput = "formsOutput"
            case name = "name"
            case originDomainId = "originDomainId"
            case originProjectId = "originProjectId"
            case owningProjectId = "owningProjectId"
            case revision = "revision"
            case updatedAt = "updatedAt"
            case updatedBy = "updatedBy"
        }
    }

    public struct BusinessNameGenerationConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// Specifies whether the business name generation is enabled.
        public let enabled: Bool?

        public init(enabled: Bool? = nil) {
            self.enabled = enabled
        }

        private enum CodingKeys: String, CodingKey {
            case enabled = "enabled"
        }
    }

    public struct CancelMetadataGenerationRunInput: AWSEncodableShape {
        /// The ID of the Amazon DataZone domain in which the metadata generation run is to be cancelled.
        public let domainIdentifier: String
        /// The ID of the metadata generation run.
        public let identifier: String

        public init(domainIdentifier: String, identifier: String) {
            self.domainIdentifier = domainIdentifier
            self.identifier = identifier
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.domainIdentifier, key: "domainIdentifier")
            request.encodePath(self.identifier, key: "identifier")
        }

        public func validate(name: String) throws {
            try self.validate(self.domainIdentifier, name: "domainIdentifier", parent: name, pattern: "^dzd[-_][a-zA-Z0-9_-]{1,36}$")
            try self.validate(self.identifier, name: "identifier", parent: name, pattern: "^[a-zA-Z0-9_-]{1,36}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct CancelMetadataGenerationRunOutput: AWSDecodableShape {
        public init() {}
    }

    public struct CancelSubscriptionInput: AWSEncodableShape {
        /// The unique identifier of the Amazon DataZone domain where the subscription request is being cancelled.
        public let domainIdentifier: String
        /// The unique identifier of the subscription that is being cancelled.
        public let identifier: String

        public init(domainIdentifier: String, identifier: String) {
            self.domainIdentifier = domainIdentifier
            self.identifier = identifier
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.domainIdentifier, key: "domainIdentifier")
            request.encodePath(self.identifier, key: "identifier")
        }

        public func validate(name: String) throws {
            try self.validate(self.domainIdentifier, name: "domainIdentifier", parent: name, pattern: "^dzd[-_][a-zA-Z0-9_-]{1,36}$")
            try self.validate(self.identifier, name: "identifier", parent: name, pattern: "^[a-zA-Z0-9_-]{1,36}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct CancelSubscriptionOutput: AWSDecodableShape {
        /// The timestamp that specifies when the request to cancel the subscription was created.
        public let createdAt: Date
        /// Specifies the Amazon DataZone user who is cancelling the subscription.
        public let createdBy: String
        /// The unique identifier of the Amazon DataZone domain where the subscription is being cancelled.
        public let domainId: String
        /// The identifier of the subscription.
        public let id: String
        /// Specifies whether the permissions to the asset are retained after the subscription is cancelled.
        public let retainPermissions: Bool?
        /// The status of the request to cancel the subscription.
        public let status: SubscriptionStatus
        /// The asset to which a subscription is being cancelled.
        public let subscribedListing: SubscribedListing
        /// The Amazon DataZone user who is made a subscriber to the specified asset by the subscription that is being cancelled.
        public let subscribedPrincipal: SubscribedPrincipal
        /// The unique ID of the subscripton request for the subscription that is being cancelled.
        public let subscriptionRequestId: String?
        /// The timestamp that specifies when the subscription was cancelled.
        public let updatedAt: Date
        /// The Amazon DataZone user that cancelled the subscription.
        public let updatedBy: String?

        public init(createdAt: Date, createdBy: String, domainId: String, id: String, retainPermissions: Bool? = nil, status: SubscriptionStatus, subscribedListing: SubscribedListing, subscribedPrincipal: SubscribedPrincipal, subscriptionRequestId: String? = nil, updatedAt: Date, updatedBy: String? = nil) {
            self.createdAt = createdAt
            self.createdBy = createdBy
            self.domainId = domainId
            self.id = id
            self.retainPermissions = retainPermissions
            self.status = status
            self.subscribedListing = subscribedListing
            self.subscribedPrincipal = subscribedPrincipal
            self.subscriptionRequestId = subscriptionRequestId
            self.updatedAt = updatedAt
            self.updatedBy = updatedBy
        }

        private enum CodingKeys: String, CodingKey {
            case createdAt = "createdAt"
            case createdBy = "createdBy"
            case domainId = "domainId"
            case id = "id"
            case retainPermissions = "retainPermissions"
            case status = "status"
            case subscribedListing = "subscribedListing"
            case subscribedPrincipal = "subscribedPrincipal"
            case subscriptionRequestId = "subscriptionRequestId"
            case updatedAt = "updatedAt"
            case updatedBy = "updatedBy"
        }
    }

    public struct CloudFormationProperties: AWSDecodableShape {
        /// The template URL of the cloud formation provisioning properties of the environment blueprint.
        public let templateUrl: String

        public init(templateUrl: String) {
            self.templateUrl = templateUrl
        }

        private enum CodingKeys: String, CodingKey {
            case templateUrl = "templateUrl"
        }
    }

    public struct ConfigurableActionParameter: AWSDecodableShape {
        /// The key of the configurable action parameter.
        public let key: String?
        /// The value of the configurable action parameter.
        public let value: String?

        public init(key: String? = nil, value: String? = nil) {
            self.key = key
            self.value = value
        }

        private enum CodingKeys: String, CodingKey {
            case key = "key"
            case value = "value"
        }
    }

    public struct ConfigurableEnvironmentAction: AWSDecodableShape {
        /// The authentication type of a configurable action of a Amazon DataZone environment.
        public let auth: ConfigurableActionTypeAuthorization?
        /// The parameters of a configurable action in a Amazon DataZone environment.
        public let parameters: [ConfigurableActionParameter]
        /// The type of a configurable action in a Amazon DataZone environment.
        public let type: String

        public init(auth: ConfigurableActionTypeAuthorization? = nil, parameters: [ConfigurableActionParameter], type: String) {
            self.auth = auth
            self.parameters = parameters
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case auth = "auth"
            case parameters = "parameters"
            case type = "type"
        }
    }

    public struct CreateAssetInput: AWSEncodableShape {
        /// A unique, case-sensitive identifier that is provided to ensure the idempotency of the request.
        public let clientToken: String?
        /// Asset description.
        public let description: String?
        /// Amazon DataZone domain where the asset is created.
        public let domainIdentifier: String
        /// The external identifier of the asset.
        public let externalIdentifier: String?
        /// Metadata forms attached to the asset.
        public let formsInput: [FormInput]?
        /// Glossary terms attached to the asset.
        public let glossaryTerms: [String]?
        /// Asset name.
        public let name: String
        /// The unique identifier of the project that owns this asset.
        public let owningProjectIdentifier: String
        /// The configuration of the automatically generated business-friendly metadata for the asset.
        public let predictionConfiguration: PredictionConfiguration?
        /// The unique identifier of this asset's type.
        public let typeIdentifier: String
        /// The revision of this asset's type.
        public let typeRevision: String?

        public init(clientToken: String? = CreateAssetInput.idempotencyToken(), description: String? = nil, domainIdentifier: String, externalIdentifier: String? = nil, formsInput: [FormInput]? = nil, glossaryTerms: [String]? = nil, name: String, owningProjectIdentifier: String, predictionConfiguration: PredictionConfiguration? = nil, typeIdentifier: String, typeRevision: String? = nil) {
            self.clientToken = clientToken
            self.description = description
            self.domainIdentifier = domainIdentifier
            self.externalIdentifier = externalIdentifier
            self.formsInput = formsInput
            self.glossaryTerms = glossaryTerms
            self.name = name
            self.owningProjectIdentifier = owningProjectIdentifier
            self.predictionConfiguration = predictionConfiguration
            self.typeIdentifier = typeIdentifier
            self.typeRevision = typeRevision
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.clientToken, forKey: .clientToken)
            try container.encodeIfPresent(self.description, forKey: .description)
            request.encodePath(self.domainIdentifier, key: "domainIdentifier")
            try container.encodeIfPresent(self.externalIdentifier, forKey: .externalIdentifier)
            try container.encodeIfPresent(self.formsInput, forKey: .formsInput)
            try container.encodeIfPresent(self.glossaryTerms, forKey: .glossaryTerms)
            try container.encode(self.name, forKey: .name)
            try container.encode(self.owningProjectIdentifier, forKey: .owningProjectIdentifier)
            try container.encodeIfPresent(self.predictionConfiguration, forKey: .predictionConfiguration)
            try container.encode(self.typeIdentifier, forKey: .typeIdentifier)
            try container.encodeIfPresent(self.typeRevision, forKey: .typeRevision)
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 128)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "^[\\x21-\\x7E]+$")
            try self.validate(self.description, name: "description", parent: name, max: 2048)
            try self.validate(self.domainIdentifier, name: "domainIdentifier", parent: name, pattern: "^dzd[-_][a-zA-Z0-9_-]{1,36}$")
            try self.validate(self.externalIdentifier, name: "externalIdentifier", parent: name, max: 256)
            try self.validate(self.externalIdentifier, name: "externalIdentifier", parent: name, min: 1)
            try self.formsInput?.forEach {
                try $0.validate(name: "\(name).formsInput[]")
            }
            try self.validate(self.formsInput, name: "formsInput", parent: name, max: 10)
            try self.glossaryTerms?.forEach {
                try validate($0, name: "glossaryTerms[]", parent: name, pattern: "^[a-zA-Z0-9_-]{1,36}$")
            }
            try self.validate(self.glossaryTerms, name: "glossaryTerms", parent: name, max: 20)
            try self.validate(self.glossaryTerms, name: "glossaryTerms", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, max: 256)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.owningProjectIdentifier, name: "owningProjectIdentifier", parent: name, pattern: "^[a-zA-Z0-9_-]{1,36}$")
            try self.validate(self.typeIdentifier, name: "typeIdentifier", parent: name, max: 513)
            try self.validate(self.typeIdentifier, name: "typeIdentifier", parent: name, min: 1)
            try self.validate(self.typeIdentifier, name: "typeIdentifier", parent: name, pattern: "^(?!\\.)[\\w\\.]*\\w$")
            try self.validate(self.typeRevision, name: "typeRevision", parent: name, max: 64)
            try self.validate(self.typeRevision, name: "typeRevision", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "clientToken"
            case description = "description"
            case externalIdentifier = "externalIdentifier"
            case formsInput = "formsInput"
            case glossaryTerms = "glossaryTerms"
            case name = "name"
            case owningProjectIdentifier = "owningProjectIdentifier"
            case predictionConfiguration = "predictionConfiguration"
            case typeIdentifier = "typeIdentifier"
            case typeRevision = "typeRevision"
        }
    }

    public struct CreateAssetOutput: AWSDecodableShape {
        /// The timestamp of when the asset was created.
        public let createdAt: Date?
        /// The Amazon DataZone user that created this asset in the catalog.
        public let createdBy: String?
        /// The description of the created asset.
        public let description: String?
        /// The ID of the Amazon DataZone domain in which the asset was created.
        public let domainId: String
        /// The external identifier of the asset.
        public let externalIdentifier: String?
        /// The timestamp of when the first revision of the asset took place.
        public let firstRevisionCreatedAt: Date?
        /// The Amazon DataZone user that made the first revision of the asset.
        public let firstRevisionCreatedBy: String?
        /// The metadata forms that are attached to the created asset.
        public let formsOutput: [FormOutput]
        /// The glossary terms that are attached to the created asset.
        public let glossaryTerms: [String]?
        /// The unique identifier of the created asset.
        public let id: String
        /// The latest data point that was imported into the time series form for the asset.
        public let latestTimeSeriesDataPointFormsOutput: [TimeSeriesDataPointSummaryFormOutput]?
        /// The details of an asset published in an Amazon DataZone catalog.
        public let listing: AssetListingDetails?
        /// The name of the created asset.
        public let name: String
        /// The ID of the Amazon DataZone project that owns the created asset.
        public let owningProjectId: String
        /// The configuration of the automatically generated business-friendly metadata for the asset.
        public let predictionConfiguration: PredictionConfiguration?
        /// The read-only metadata forms that are attached to the created asset.
        public let readOnlyFormsOutput: [FormOutput]?
        /// The revision of the asset.
        public let revision: String
        /// The identifier of the created asset type.
        public let typeIdentifier: String
        /// The revision type of the asset.
        public let typeRevision: String

        public init(createdAt: Date? = nil, createdBy: String? = nil, description: String? = nil, domainId: String, externalIdentifier: String? = nil, firstRevisionCreatedAt: Date? = nil, firstRevisionCreatedBy: String? = nil, formsOutput: [FormOutput], glossaryTerms: [String]? = nil, id: String, latestTimeSeriesDataPointFormsOutput: [TimeSeriesDataPointSummaryFormOutput]? = nil, listing: AssetListingDetails? = nil, name: String, owningProjectId: String, predictionConfiguration: PredictionConfiguration? = nil, readOnlyFormsOutput: [FormOutput]? = nil, revision: String, typeIdentifier: String, typeRevision: String) {
            self.createdAt = createdAt
            self.createdBy = createdBy
            self.description = description
            self.domainId = domainId
            self.externalIdentifier = externalIdentifier
            self.firstRevisionCreatedAt = firstRevisionCreatedAt
            self.firstRevisionCreatedBy = firstRevisionCreatedBy
            self.formsOutput = formsOutput
            self.glossaryTerms = glossaryTerms
            self.id = id
            self.latestTimeSeriesDataPointFormsOutput = latestTimeSeriesDataPointFormsOutput
            self.listing = listing
            self.name = name
            self.owningProjectId = owningProjectId
            self.predictionConfiguration = predictionConfiguration
            self.readOnlyFormsOutput = readOnlyFormsOutput
            self.revision = revision
            self.typeIdentifier = typeIdentifier
            self.typeRevision = typeRevision
        }

        private enum CodingKeys: String, CodingKey {
            case createdAt = "createdAt"
            case createdBy = "createdBy"
            case description = "description"
            case domainId = "domainId"
            case externalIdentifier = "externalIdentifier"
            case firstRevisionCreatedAt = "firstRevisionCreatedAt"
            case firstRevisionCreatedBy = "firstRevisionCreatedBy"
            case formsOutput = "formsOutput"
            case glossaryTerms = "glossaryTerms"
            case id = "id"
            case latestTimeSeriesDataPointFormsOutput = "latestTimeSeriesDataPointFormsOutput"
            case listing = "listing"
            case name = "name"
            case owningProjectId = "owningProjectId"
            case predictionConfiguration = "predictionConfiguration"
            case readOnlyFormsOutput = "readOnlyFormsOutput"
            case revision = "revision"
            case typeIdentifier = "typeIdentifier"
            case typeRevision = "typeRevision"
        }
    }

    public struct CreateAssetRevisionInput: AWSEncodableShape {
        /// A unique, case-sensitive identifier that is provided to ensure the idempotency of the request.
        public let clientToken: String?
        /// The revised description of the asset.
        public let description: String?
        /// The unique identifier of the domain where the asset is being revised.
        public let domainIdentifier: String
        /// The metadata forms to be attached to the asset as part of asset revision.
        public let formsInput: [FormInput]?
        /// The glossary terms to be attached to the asset as part of asset revision.
        public let glossaryTerms: [String]?
        /// The identifier of the asset.
        public let identifier: String
        /// Te revised name of the asset.
        public let name: String
        /// The configuration of the automatically generated business-friendly metadata for the asset.
        public let predictionConfiguration: PredictionConfiguration?
        /// The revision type of the asset.
        public let typeRevision: String?

        public init(clientToken: String? = CreateAssetRevisionInput.idempotencyToken(), description: String? = nil, domainIdentifier: String, formsInput: [FormInput]? = nil, glossaryTerms: [String]? = nil, identifier: String, name: String, predictionConfiguration: PredictionConfiguration? = nil, typeRevision: String? = nil) {
            self.clientToken = clientToken
            self.description = description
            self.domainIdentifier = domainIdentifier
            self.formsInput = formsInput
            self.glossaryTerms = glossaryTerms
            self.identifier = identifier
            self.name = name
            self.predictionConfiguration = predictionConfiguration
            self.typeRevision = typeRevision
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.clientToken, forKey: .clientToken)
            try container.encodeIfPresent(self.description, forKey: .description)
            request.encodePath(self.domainIdentifier, key: "domainIdentifier")
            try container.encodeIfPresent(self.formsInput, forKey: .formsInput)
            try container.encodeIfPresent(self.glossaryTerms, forKey: .glossaryTerms)
            request.encodePath(self.identifier, key: "identifier")
            try container.encode(self.name, forKey: .name)
            try container.encodeIfPresent(self.predictionConfiguration, forKey: .predictionConfiguration)
            try container.encodeIfPresent(self.typeRevision, forKey: .typeRevision)
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 128)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "^[\\x21-\\x7E]+$")
            try self.validate(self.description, name: "description", parent: name, max: 2048)
            try self.validate(self.domainIdentifier, name: "domainIdentifier", parent: name, pattern: "^dzd[-_][a-zA-Z0-9_-]{1,36}$")
            try self.formsInput?.forEach {
                try $0.validate(name: "\(name).formsInput[]")
            }
            try self.validate(self.formsInput, name: "formsInput", parent: name, max: 10)
            try self.glossaryTerms?.forEach {
                try validate($0, name: "glossaryTerms[]", parent: name, pattern: "^[a-zA-Z0-9_-]{1,36}$")
            }
            try self.validate(self.glossaryTerms, name: "glossaryTerms", parent: name, max: 20)
            try self.validate(self.glossaryTerms, name: "glossaryTerms", parent: name, min: 1)
            try self.validate(self.identifier, name: "identifier", parent: name, pattern: "^[a-zA-Z0-9_-]{1,36}$")
            try self.validate(self.name, name: "name", parent: name, max: 256)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.typeRevision, name: "typeRevision", parent: name, max: 64)
            try self.validate(self.typeRevision, name: "typeRevision", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "clientToken"
            case description = "description"
            case formsInput = "formsInput"
            case glossaryTerms = "glossaryTerms"
            case name = "name"
            case predictionConfiguration = "predictionConfiguration"
            case typeRevision = "typeRevision"
        }
    }

    public struct CreateAssetRevisionOutput: AWSDecodableShape {
        /// The timestamp of when the asset revision occured.
        public let createdAt: Date?
        /// The Amazon DataZone user who performed the asset revision.
        public let createdBy: String?
        /// The revised asset description.
        public let description: String?
        /// The unique identifier of the Amazon DataZone domain where the asset was revised.
        public let domainId: String
        /// The external identifier of the asset.
        public let externalIdentifier: String?
        /// The timestamp of when the first asset revision occured.
        public let firstRevisionCreatedAt: Date?
        /// The Amazon DataZone user who performed the first asset revision.
        public let firstRevisionCreatedBy: String?
        /// The metadata forms that were attached to the asset as part of the asset revision.
        public let formsOutput: [FormOutput]
        /// The glossary terms that were attached to the asset as part of asset revision.
        public let glossaryTerms: [String]?
        /// The unique identifier of the asset revision.
        public let id: String
        /// The latest data point that was imported into the time series form for the asset.
        public let latestTimeSeriesDataPointFormsOutput: [TimeSeriesDataPointSummaryFormOutput]?
        /// The details of an asset published in an Amazon DataZone catalog.
        public let listing: AssetListingDetails?
        /// The revised name of the asset.
        public let name: String
        /// The unique identifier of the revised project that owns the asset.
        public let owningProjectId: String
        /// The configuration of the automatically generated business-friendly metadata for the asset.
        public let predictionConfiguration: PredictionConfiguration?
        /// The read-only metadata forms that were attached to the asset as part of the asset revision.
        public let readOnlyFormsOutput: [FormOutput]?
        /// The revision of the asset.
        public let revision: String
        /// The identifier of the revision type.
        public let typeIdentifier: String
        /// The revision type of the asset.
        public let typeRevision: String

        public init(createdAt: Date? = nil, createdBy: String? = nil, description: String? = nil, domainId: String, externalIdentifier: String? = nil, firstRevisionCreatedAt: Date? = nil, firstRevisionCreatedBy: String? = nil, formsOutput: [FormOutput], glossaryTerms: [String]? = nil, id: String, latestTimeSeriesDataPointFormsOutput: [TimeSeriesDataPointSummaryFormOutput]? = nil, listing: AssetListingDetails? = nil, name: String, owningProjectId: String, predictionConfiguration: PredictionConfiguration? = nil, readOnlyFormsOutput: [FormOutput]? = nil, revision: String, typeIdentifier: String, typeRevision: String) {
            self.createdAt = createdAt
            self.createdBy = createdBy
            self.description = description
            self.domainId = domainId
            self.externalIdentifier = externalIdentifier
            self.firstRevisionCreatedAt = firstRevisionCreatedAt
            self.firstRevisionCreatedBy = firstRevisionCreatedBy
            self.formsOutput = formsOutput
            self.glossaryTerms = glossaryTerms
            self.id = id
            self.latestTimeSeriesDataPointFormsOutput = latestTimeSeriesDataPointFormsOutput
            self.listing = listing
            self.name = name
            self.owningProjectId = owningProjectId
            self.predictionConfiguration = predictionConfiguration
            self.readOnlyFormsOutput = readOnlyFormsOutput
            self.revision = revision
            self.typeIdentifier = typeIdentifier
            self.typeRevision = typeRevision
        }

        private enum CodingKeys: String, CodingKey {
            case createdAt = "createdAt"
            case createdBy = "createdBy"
            case description = "description"
            case domainId = "domainId"
            case externalIdentifier = "externalIdentifier"
            case firstRevisionCreatedAt = "firstRevisionCreatedAt"
            case firstRevisionCreatedBy = "firstRevisionCreatedBy"
            case formsOutput = "formsOutput"
            case glossaryTerms = "glossaryTerms"
            case id = "id"
            case latestTimeSeriesDataPointFormsOutput = "latestTimeSeriesDataPointFormsOutput"
            case listing = "listing"
            case name = "name"
            case owningProjectId = "owningProjectId"
            case predictionConfiguration = "predictionConfiguration"
            case readOnlyFormsOutput = "readOnlyFormsOutput"
            case revision = "revision"
            case typeIdentifier = "typeIdentifier"
            case typeRevision = "typeRevision"
        }
    }

    public struct CreateAssetTypeInput: AWSEncodableShape {
        /// The descripton of the custom asset type.
        public let description: String?
        /// The unique identifier of the Amazon DataZone domain where the custom asset type is being created.
        public let domainIdentifier: String
        /// The metadata forms that are to be attached to the custom asset type.
        public let formsInput: [String: FormEntryInput]
        /// The name of the custom asset type.
        public let name: String
        /// The identifier of the Amazon DataZone project that is to own the custom asset type.
        public let owningProjectIdentifier: String

        public init(description: String? = nil, domainIdentifier: String, formsInput: [String: FormEntryInput], name: String, owningProjectIdentifier: String) {
            self.description = description
            self.domainIdentifier = domainIdentifier
            self.formsInput = formsInput
            self.name = name
            self.owningProjectIdentifier = owningProjectIdentifier
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.description, forKey: .description)
            request.encodePath(self.domainIdentifier, key: "domainIdentifier")
            try container.encode(self.formsInput, forKey: .formsInput)
            try container.encode(self.name, forKey: .name)
            try container.encode(self.owningProjectIdentifier, forKey: .owningProjectIdentifier)
        }

        public func validate(name: String) throws {
            try self.validate(self.description, name: "description", parent: name, max: 2048)
            try self.validate(self.domainIdentifier, name: "domainIdentifier", parent: name, pattern: "^dzd[-_][a-zA-Z0-9_-]{1,36}$")
            try self.formsInput.forEach {
                try validate($0.key, name: "formsInput.key", parent: name, max: 128)
                try validate($0.key, name: "formsInput.key", parent: name, min: 1)
                try validate($0.key, name: "formsInput.key", parent: name, pattern: "^(?![0-9_])\\w+$|^_\\w*[a-zA-Z0-9]\\w*$")
                try $0.value.validate(name: "\(name).formsInput[\"\($0.key)\"]")
            }
            try self.validate(self.formsInput, name: "formsInput", parent: name, max: 10)
            try self.validate(self.name, name: "name", parent: name, max: 256)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[^\\.]*")
            try self.validate(self.owningProjectIdentifier, name: "owningProjectIdentifier", parent: name, pattern: "^[a-zA-Z0-9_-]{1,36}$")
        }

        private enum CodingKeys: String, CodingKey {
            case description = "description"
            case formsInput = "formsInput"
            case name = "name"
            case owningProjectIdentifier = "owningProjectIdentifier"
        }
    }

    public struct CreateAssetTypeOutput: AWSDecodableShape {
        /// The timestamp of when the asset type is to be created.
        public let createdAt: Date?
        /// The Amazon DataZone user who creates this custom asset type.
        public let createdBy: String?
        /// The description of the custom asset type.
        public let description: String?
        /// The ID of the Amazon DataZone domain in which the asset type was created.
        public let domainId: String
        /// The metadata forms that are attached to the asset type.
        public let formsOutput: [String: FormEntryOutput]
        /// The name of the asset type.
        public let name: String
        /// The ID of the Amazon DataZone domain where the asset type was originally created.
        public let originDomainId: String?
        /// The ID of the Amazon DataZone project where the asset type was originally created.
        public let originProjectId: String?
        /// The ID of the Amazon DataZone project that currently owns this asset type.
        public let owningProjectId: String?
        /// The revision of the custom asset type.
        public let revision: String
        /// The timestamp of when the custom type was created.
        public let updatedAt: Date?
        /// The Amazon DataZone user that created the custom asset type.
        public let updatedBy: String?

        public init(createdAt: Date? = nil, createdBy: String? = nil, description: String? = nil, domainId: String, formsOutput: [String: FormEntryOutput], name: String, originDomainId: String? = nil, originProjectId: String? = nil, owningProjectId: String? = nil, revision: String, updatedAt: Date? = nil, updatedBy: String? = nil) {
            self.createdAt = createdAt
            self.createdBy = createdBy
            self.description = description
            self.domainId = domainId
            self.formsOutput = formsOutput
            self.name = name
            self.originDomainId = originDomainId
            self.originProjectId = originProjectId
            self.owningProjectId = owningProjectId
            self.revision = revision
            self.updatedAt = updatedAt
            self.updatedBy = updatedBy
        }

        private enum CodingKeys: String, CodingKey {
            case createdAt = "createdAt"
            case createdBy = "createdBy"
            case description = "description"
            case domainId = "domainId"
            case formsOutput = "formsOutput"
            case name = "name"
            case originDomainId = "originDomainId"
            case originProjectId = "originProjectId"
            case owningProjectId = "owningProjectId"
            case revision = "revision"
            case updatedAt = "updatedAt"
            case updatedBy = "updatedBy"
        }
    }

    public struct CreateDataSourceInput: AWSEncodableShape {
        /// The metadata forms that are to be attached to the assets that this data source works with.
        public let assetFormsInput: [FormInput]?
        /// A unique, case-sensitive identifier that is provided to ensure the idempotency of the request.
        public let clientToken: String?
        /// Specifies the configuration of the data source. It can be set to either glueRunConfiguration or redshiftRunConfiguration.
        public let configuration: DataSourceConfigurationInput?
        /// The description of the data source.
        public let description: String?
        /// The ID of the Amazon DataZone domain where the data source is created.
        public let domainIdentifier: String
        /// Specifies whether the data source is enabled.
        public let enableSetting: EnableSetting?
        /// The unique identifier of the Amazon DataZone environment to which the data source publishes assets.
        public let environmentIdentifier: String
        /// The name of the data source.
        public let name: String
        /// The identifier of the Amazon DataZone project in which you want to add this data source.
        public let projectIdentifier: String
        /// Specifies whether the assets that this data source creates in the inventory are to be also automatically published to the catalog.
        public let publishOnImport: Bool?
        /// Specifies whether the business name generation is to be enabled for this data source.
        public let recommendation: RecommendationConfiguration?
        /// The schedule of the data source runs.
        public let schedule: ScheduleConfiguration?
        /// The type of the data source.
        public let type: String

        public init(assetFormsInput: [FormInput]? = nil, clientToken: String? = CreateDataSourceInput.idempotencyToken(), configuration: DataSourceConfigurationInput? = nil, description: String? = nil, domainIdentifier: String, enableSetting: EnableSetting? = nil, environmentIdentifier: String, name: String, projectIdentifier: String, publishOnImport: Bool? = nil, recommendation: RecommendationConfiguration? = nil, schedule: ScheduleConfiguration? = nil, type: String) {
            self.assetFormsInput = assetFormsInput
            self.clientToken = clientToken
            self.configuration = configuration
            self.description = description
            self.domainIdentifier = domainIdentifier
            self.enableSetting = enableSetting
            self.environmentIdentifier = environmentIdentifier
            self.name = name
            self.projectIdentifier = projectIdentifier
            self.publishOnImport = publishOnImport
            self.recommendation = recommendation
            self.schedule = schedule
            self.type = type
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.assetFormsInput, forKey: .assetFormsInput)
            try container.encodeIfPresent(self.clientToken, forKey: .clientToken)
            try container.encodeIfPresent(self.configuration, forKey: .configuration)
            try container.encodeIfPresent(self.description, forKey: .description)
            request.encodePath(self.domainIdentifier, key: "domainIdentifier")
            try container.encodeIfPresent(self.enableSetting, forKey: .enableSetting)
            try container.encode(self.environmentIdentifier, forKey: .environmentIdentifier)
            try container.encode(self.name, forKey: .name)
            try container.encode(self.projectIdentifier, forKey: .projectIdentifier)
            try container.encodeIfPresent(self.publishOnImport, forKey: .publishOnImport)
            try container.encodeIfPresent(self.recommendation, forKey: .recommendation)
            try container.encodeIfPresent(self.schedule, forKey: .schedule)
            try container.encode(self.type, forKey: .type)
        }

        public func validate(name: String) throws {
            try self.assetFormsInput?.forEach {
                try $0.validate(name: "\(name).assetFormsInput[]")
            }
            try self.validate(self.assetFormsInput, name: "assetFormsInput", parent: name, max: 10)
            try self.validate(self.description, name: "description", parent: name, max: 2048)
            try self.validate(self.domainIdentifier, name: "domainIdentifier", parent: name, pattern: "^dzd[-_][a-zA-Z0-9_-]{1,36}$")
            try self.validate(self.name, name: "name", parent: name, max: 256)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.schedule?.validate(name: "\(name).schedule")
            try self.validate(self.type, name: "type", parent: name, max: 256)
            try self.validate(self.type, name: "type", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case assetFormsInput = "assetFormsInput"
            case clientToken = "clientToken"
            case configuration = "configuration"
            case description = "description"
            case enableSetting = "enableSetting"
            case environmentIdentifier = "environmentIdentifier"
            case name = "name"
            case projectIdentifier = "projectIdentifier"
            case publishOnImport = "publishOnImport"
            case recommendation = "recommendation"
            case schedule = "schedule"
            case type = "type"
        }
    }

    public struct CreateDataSourceOutput: AWSDecodableShape {
        /// The metadata forms attached to the assets that this data source creates.
        public let assetFormsOutput: [FormOutput]?
        /// Specifies the configuration of the data source. It can be set to either glueRunConfiguration or redshiftRunConfiguration.
        public let configuration: DataSourceConfigurationOutput?
        /// The timestamp of when the data source was created.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var createdAt: Date?
        /// The description of the data source.
        public let description: String?
        /// The ID of the Amazon DataZone domain in which the data source is created.
        public let domainId: String
        /// Specifies whether the data source is enabled.
        public let enableSetting: EnableSetting?
        /// The unique identifier of the Amazon DataZone environment to which the data source publishes assets.
        public let environmentId: String
        /// Specifies the error message that is returned if the operation cannot be successfully completed.
        public let errorMessage: DataSourceErrorMessage?
        /// The unique identifier of the data source.
        public let id: String
        /// The timestamp that specifies when the data source was last run.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var lastRunAt: Date?
        /// Specifies the error message that is returned if the operation cannot be successfully completed.
        public let lastRunErrorMessage: DataSourceErrorMessage?
        /// The status of the last run of this data source.
        public let lastRunStatus: DataSourceRunStatus?
        /// The name of the data source.
        public let name: String
        /// The ID of the Amazon DataZone project to which the data source is added.
        public let projectId: String
        /// Specifies whether the assets that this data source creates in the inventory are to be also automatically published to the catalog.
        public let publishOnImport: Bool?
        /// Specifies whether the business name generation is to be enabled for this data source.
        public let recommendation: RecommendationConfiguration?
        /// The schedule of the data source runs.
        public let schedule: ScheduleConfiguration?
        /// The status of the data source.
        public let status: DataSourceStatus?
        /// The type of the data source.
        public let type: String?
        /// The timestamp of when the data source was updated.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var updatedAt: Date?

        public init(assetFormsOutput: [FormOutput]? = nil, configuration: DataSourceConfigurationOutput? = nil, createdAt: Date? = nil, description: String? = nil, domainId: String, enableSetting: EnableSetting? = nil, environmentId: String, errorMessage: DataSourceErrorMessage? = nil, id: String, lastRunAt: Date? = nil, lastRunErrorMessage: DataSourceErrorMessage? = nil, lastRunStatus: DataSourceRunStatus? = nil, name: String, projectId: String, publishOnImport: Bool? = nil, recommendation: RecommendationConfiguration? = nil, schedule: ScheduleConfiguration? = nil, status: DataSourceStatus? = nil, type: String? = nil, updatedAt: Date? = nil) {
            self.assetFormsOutput = assetFormsOutput
            self.configuration = configuration
            self.createdAt = createdAt
            self.description = description
            self.domainId = domainId
            self.enableSetting = enableSetting
            self.environmentId = environmentId
            self.errorMessage = errorMessage
            self.id = id
            self.lastRunAt = lastRunAt
            self.lastRunErrorMessage = lastRunErrorMessage
            self.lastRunStatus = lastRunStatus
            self.name = name
            self.projectId = projectId
            self.publishOnImport = publishOnImport
            self.recommendation = recommendation
            self.schedule = schedule
            self.status = status
            self.type = type
            self.updatedAt = updatedAt
        }

        private enum CodingKeys: String, CodingKey {
            case assetFormsOutput = "assetFormsOutput"
            case configuration = "configuration"
            case createdAt = "createdAt"
            case description = "description"
            case domainId = "domainId"
            case enableSetting = "enableSetting"
            case environmentId = "environmentId"
            case errorMessage = "errorMessage"
            case id = "id"
            case lastRunAt = "lastRunAt"
            case lastRunErrorMessage = "lastRunErrorMessage"
            case lastRunStatus = "lastRunStatus"
            case name = "name"
            case projectId = "projectId"
            case publishOnImport = "publishOnImport"
            case recommendation = "recommendation"
            case schedule = "schedule"
            case status = "status"
            case type = "type"
            case updatedAt = "updatedAt"
        }
    }

    public struct CreateDomainInput: AWSEncodableShape {
        /// A unique, case-sensitive identifier that is provided to ensure the idempotency of the request.
        public let clientToken: String?
        /// The description of the Amazon DataZone domain.
        public let description: String?
        /// The domain execution role that is created when an Amazon DataZone domain is created. The domain execution role is created in the Amazon Web Services account that houses the Amazon DataZone domain.
        public let domainExecutionRole: String
        /// The identifier of the Amazon Web Services Key Management Service (KMS) key that is used to encrypt the Amazon DataZone domain, metadata, and reporting data.
        public let kmsKeyIdentifier: String?
        /// The name of the Amazon DataZone domain.
        public let name: String
        /// The single-sign on configuration of the Amazon DataZone domain.
        public let singleSignOn: SingleSignOn?
        /// The tags specified for the Amazon DataZone domain.
        public let tags: [String: String]?

        public init(clientToken: String? = CreateDomainInput.idempotencyToken(), description: String? = nil, domainExecutionRole: String, kmsKeyIdentifier: String? = nil, name: String, singleSignOn: SingleSignOn? = nil, tags: [String: String]? = nil) {
            self.clientToken = clientToken
            self.description = description
            self.domainExecutionRole = domainExecutionRole
            self.kmsKeyIdentifier = kmsKeyIdentifier
            self.name = name
            self.singleSignOn = singleSignOn
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.validate(self.domainExecutionRole, name: "domainExecutionRole", parent: name, pattern: "^arn:aws[^:]*:iam::\\d{12}:(role|role/service-role)/[\\w+=,.@-]*$")
            try self.validate(self.kmsKeyIdentifier, name: "kmsKeyIdentifier", parent: name, max: 1024)
            try self.validate(self.kmsKeyIdentifier, name: "kmsKeyIdentifier", parent: name, min: 1)
            try self.validate(self.kmsKeyIdentifier, name: "kmsKeyIdentifier", parent: name, pattern: "^arn:aws(|-cn|-us-gov):kms:[a-zA-Z0-9-]*:[0-9]{12}:key/[a-zA-Z0-9-]{36}$")
            try self.tags?.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.key, name: "tags.key", parent: name, pattern: "^[\\w \\.:/=+@-]+$")
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, pattern: "^[\\w \\.:/=+@-]*$")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "clientToken"
            case description = "description"
            case domainExecutionRole = "domainExecutionRole"
            case kmsKeyIdentifier = "kmsKeyIdentifier"
            case name = "name"
            case singleSignOn = "singleSignOn"
            case tags = "tags"
        }
    }

    public struct CreateDomainOutput: AWSDecodableShape {
        /// The ARN of the Amazon DataZone domain.
        public let arn: String?
        /// The description of the Amazon DataZone domain.
        public let description: String?
        /// The domain execution role that is created when an Amazon DataZone domain is created. The domain execution role is created in the Amazon Web Services account that houses the Amazon DataZone domain.
        public let domainExecutionRole: String?
        /// The identifier of the Amazon DataZone domain.
        public let id: String
        /// The identifier of the Amazon Web Services Key Management Service (KMS) key that is used to encrypt the Amazon DataZone domain, metadata, and reporting data.
        public let kmsKeyIdentifier: String?
        /// The name of the Amazon DataZone domain.
        public let name: String?
        /// The URL of the data portal for this Amazon DataZone domain.
        public let portalUrl: String?
        /// The single-sign on configuration of the Amazon DataZone domain.
        public let singleSignOn: SingleSignOn?
        /// The status of the Amazon DataZone domain.
        public let status: DomainStatus?
        /// The tags specified for the Amazon DataZone domain.
        public let tags: [String: String]?

        public init(arn: String? = nil, description: String? = nil, domainExecutionRole: String? = nil, id: String, kmsKeyIdentifier: String? = nil, name: String? = nil, portalUrl: String? = nil, singleSignOn: SingleSignOn? = nil, status: DomainStatus? = nil, tags: [String: String]? = nil) {
            self.arn = arn
            self.description = description
            self.domainExecutionRole = domainExecutionRole
            self.id = id
            self.kmsKeyIdentifier = kmsKeyIdentifier
            self.name = name
            self.portalUrl = portalUrl
            self.singleSignOn = singleSignOn
            self.status = status
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case description = "description"
            case domainExecutionRole = "domainExecutionRole"
            case id = "id"
            case kmsKeyIdentifier = "kmsKeyIdentifier"
            case name = "name"
            case portalUrl = "portalUrl"
            case singleSignOn = "singleSignOn"
            case status = "status"
            case tags = "tags"
        }
    }

    public struct CreateEnvironmentInput: AWSEncodableShape {
        /// The description of the Amazon DataZone environment.
        public let description: String?
        /// The identifier of the Amazon DataZone domain in which the environment is created.
        public let domainIdentifier: String
        /// The identifier of the environment profile that is used to create this Amazon DataZone environment.
        public let environmentProfileIdentifier: String
        /// The glossary terms that can be used in this Amazon DataZone environment.
        public let glossaryTerms: [String]?
        /// The name of the Amazon DataZone environment.
        public let name: String
        /// The identifier of the Amazon DataZone project in which this environment is created.
        public let projectIdentifier: String
        /// The user parameters of this Amazon DataZone environment.
        public let userParameters: [EnvironmentParameter]?

        public init(description: String? = nil, domainIdentifier: String, environmentProfileIdentifier: String, glossaryTerms: [String]? = nil, name: String, projectIdentifier: String, userParameters: [EnvironmentParameter]? = nil) {
            self.description = description
            self.domainIdentifier = domainIdentifier
            self.environmentProfileIdentifier = environmentProfileIdentifier
            self.glossaryTerms = glossaryTerms
            self.name = name
            self.projectIdentifier = projectIdentifier
            self.userParameters = userParameters
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.description, forKey: .description)
            request.encodePath(self.domainIdentifier, key: "domainIdentifier")
            try container.encode(self.environmentProfileIdentifier, forKey: .environmentProfileIdentifier)
            try container.encodeIfPresent(self.glossaryTerms, forKey: .glossaryTerms)
            try container.encode(self.name, forKey: .name)
            try container.encode(self.projectIdentifier, forKey: .projectIdentifier)
            try container.encodeIfPresent(self.userParameters, forKey: .userParameters)
        }

        public func validate(name: String) throws {
            try self.validate(self.domainIdentifier, name: "domainIdentifier", parent: name, pattern: "^dzd[-_][a-zA-Z0-9_-]{1,36}$")
            try self.validate(self.environmentProfileIdentifier, name: "environmentProfileIdentifier", parent: name, pattern: "^[a-zA-Z0-9_-]{1,36}$")
            try self.glossaryTerms?.forEach {
                try validate($0, name: "glossaryTerms[]", parent: name, pattern: "^[a-zA-Z0-9_-]{1,36}$")
            }
            try self.validate(self.glossaryTerms, name: "glossaryTerms", parent: name, max: 20)
            try self.validate(self.glossaryTerms, name: "glossaryTerms", parent: name, min: 1)
            try self.validate(self.projectIdentifier, name: "projectIdentifier", parent: name, pattern: "^[a-zA-Z0-9_-]{1,36}$")
        }

        private enum CodingKeys: String, CodingKey {
            case description = "description"
            case environmentProfileIdentifier = "environmentProfileIdentifier"
            case glossaryTerms = "glossaryTerms"
            case name = "name"
            case projectIdentifier = "projectIdentifier"
            case userParameters = "userParameters"
        }
    }

    public struct CreateEnvironmentOutput: AWSDecodableShape {
        /// The Amazon Web Services account in which the Amazon DataZone environment is created.
        public let awsAccountId: String?
        /// The Amazon Web Services region in which the Amazon DataZone environment is created.
        public let awsAccountRegion: String?
        /// The timestamp of when the environment was created.
        public let createdAt: Date?
        /// The Amazon DataZone user who created this environment.
        public let createdBy: String
        /// The deployment properties of this Amazon DataZone environment.
        public let deploymentProperties: DeploymentProperties?
        /// The description of this Amazon DataZone environment.
        public let description: String?
        /// The identifier of the Amazon DataZone domain in which the environment is created.
        public let domainId: String
        /// The configurable actions of this Amazon DataZone environment.
        public let environmentActions: [ConfigurableEnvironmentAction]?
        /// The ID of the blueprint with which this Amazon DataZone environment was created.
        public let environmentBlueprintId: String?
        /// The ID of the environment profile with which this Amazon DataZone environment was created.
        public let environmentProfileId: String
        /// The glossary terms that can be used in this Amazon DataZone environment.
        public let glossaryTerms: [String]?
        /// The ID of this Amazon DataZone environment.
        public let id: String?
        /// The details of the last deployment of this Amazon DataZone environment.
        public let lastDeployment: Deployment?
        /// The name of this environment.
        public let name: String
        /// The ID of the Amazon DataZone project in which this environment is created.
        public let projectId: String
        /// The provider of this Amazon DataZone environment.
        public let provider: String
        /// The provisioned resources of this Amazon DataZone environment.
        public let provisionedResources: [Resource]?
        /// The provisioning properties of this Amazon DataZone environment.
        public let provisioningProperties: ProvisioningProperties?
        /// The status of this Amazon DataZone environment.
        public let status: EnvironmentStatus?
        /// The timestamp of when this environment was updated.
        public let updatedAt: Date?
        /// The user parameters of this Amazon DataZone environment.
        public let userParameters: [CustomParameter]?

        public init(awsAccountId: String? = nil, awsAccountRegion: String? = nil, createdAt: Date? = nil, createdBy: String, deploymentProperties: DeploymentProperties? = nil, description: String? = nil, domainId: String, environmentActions: [ConfigurableEnvironmentAction]? = nil, environmentBlueprintId: String? = nil, environmentProfileId: String, glossaryTerms: [String]? = nil, id: String? = nil, lastDeployment: Deployment? = nil, name: String, projectId: String, provider: String, provisionedResources: [Resource]? = nil, provisioningProperties: ProvisioningProperties? = nil, status: EnvironmentStatus? = nil, updatedAt: Date? = nil, userParameters: [CustomParameter]? = nil) {
            self.awsAccountId = awsAccountId
            self.awsAccountRegion = awsAccountRegion
            self.createdAt = createdAt
            self.createdBy = createdBy
            self.deploymentProperties = deploymentProperties
            self.description = description
            self.domainId = domainId
            self.environmentActions = environmentActions
            self.environmentBlueprintId = environmentBlueprintId
            self.environmentProfileId = environmentProfileId
            self.glossaryTerms = glossaryTerms
            self.id = id
            self.lastDeployment = lastDeployment
            self.name = name
            self.projectId = projectId
            self.provider = provider
            self.provisionedResources = provisionedResources
            self.provisioningProperties = provisioningProperties
            self.status = status
            self.updatedAt = updatedAt
            self.userParameters = userParameters
        }

        private enum CodingKeys: String, CodingKey {
            case awsAccountId = "awsAccountId"
            case awsAccountRegion = "awsAccountRegion"
            case createdAt = "createdAt"
            case createdBy = "createdBy"
            case deploymentProperties = "deploymentProperties"
            case description = "description"
            case domainId = "domainId"
            case environmentActions = "environmentActions"
            case environmentBlueprintId = "environmentBlueprintId"
            case environmentProfileId = "environmentProfileId"
            case glossaryTerms = "glossaryTerms"
            case id = "id"
            case lastDeployment = "lastDeployment"
            case name = "name"
            case projectId = "projectId"
            case provider = "provider"
            case provisionedResources = "provisionedResources"
            case provisioningProperties = "provisioningProperties"
            case status = "status"
            case updatedAt = "updatedAt"
            case userParameters = "userParameters"
        }
    }

    public struct CreateEnvironmentProfileInput: AWSEncodableShape {
        /// The Amazon Web Services account in which the Amazon DataZone environment is created.
        public let awsAccountId: String?
        /// The Amazon Web Services region in which this environment profile is created.
        public let awsAccountRegion: String?
        /// The description of this Amazon DataZone environment profile.
        public let description: String?
        /// The ID of the Amazon DataZone domain in which this environment profile is created.
        public let domainIdentifier: String
        /// The ID of the blueprint with which this environment profile is created.
        public let environmentBlueprintIdentifier: String
        /// The name of this Amazon DataZone environment profile.
        public let name: String
        /// The identifier of the project in which to create the environment profile.
        public let projectIdentifier: String
        /// The user parameters of this Amazon DataZone environment profile.
        public let userParameters: [EnvironmentParameter]?

        public init(awsAccountId: String? = nil, awsAccountRegion: String? = nil, description: String? = nil, domainIdentifier: String, environmentBlueprintIdentifier: String, name: String, projectIdentifier: String, userParameters: [EnvironmentParameter]? = nil) {
            self.awsAccountId = awsAccountId
            self.awsAccountRegion = awsAccountRegion
            self.description = description
            self.domainIdentifier = domainIdentifier
            self.environmentBlueprintIdentifier = environmentBlueprintIdentifier
            self.name = name
            self.projectIdentifier = projectIdentifier
            self.userParameters = userParameters
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.awsAccountId, forKey: .awsAccountId)
            try container.encodeIfPresent(self.awsAccountRegion, forKey: .awsAccountRegion)
            try container.encodeIfPresent(self.description, forKey: .description)
            request.encodePath(self.domainIdentifier, key: "domainIdentifier")
            try container.encode(self.environmentBlueprintIdentifier, forKey: .environmentBlueprintIdentifier)
            try container.encode(self.name, forKey: .name)
            try container.encode(self.projectIdentifier, forKey: .projectIdentifier)
            try container.encodeIfPresent(self.userParameters, forKey: .userParameters)
        }

        public func validate(name: String) throws {
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, pattern: "^\\d{12}$")
            try self.validate(self.awsAccountRegion, name: "awsAccountRegion", parent: name, pattern: "^[a-z]{2}-[a-z]{4,10}-\\d$")
            try self.validate(self.description, name: "description", parent: name, max: 2048)
            try self.validate(self.domainIdentifier, name: "domainIdentifier", parent: name, pattern: "^dzd[-_][a-zA-Z0-9_-]{1,36}$")
            try self.validate(self.environmentBlueprintIdentifier, name: "environmentBlueprintIdentifier", parent: name, pattern: "^[a-zA-Z0-9_-]{1,36}$")
            try self.validate(self.name, name: "name", parent: name, max: 64)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[\\w -]+$")
            try self.validate(self.projectIdentifier, name: "projectIdentifier", parent: name, pattern: "^[a-zA-Z0-9_-]{1,36}$")
        }

        private enum CodingKeys: String, CodingKey {
            case awsAccountId = "awsAccountId"
            case awsAccountRegion = "awsAccountRegion"
            case description = "description"
            case environmentBlueprintIdentifier = "environmentBlueprintIdentifier"
            case name = "name"
            case projectIdentifier = "projectIdentifier"
            case userParameters = "userParameters"
        }
    }

    public struct CreateEnvironmentProfileOutput: AWSDecodableShape {
        /// The Amazon Web Services account ID in which this Amazon DataZone environment profile is created.
        public let awsAccountId: String?
        /// The Amazon Web Services region in which this Amazon DataZone environment profile is created.
        public let awsAccountRegion: String?
        /// The timestamp of when this environment profile was created.
        public let createdAt: Date?
        /// The Amazon DataZone user who created this environment profile.
        public let createdBy: String
        /// The description of this Amazon DataZone environment profile.
        public let description: String?
        /// The ID of the Amazon DataZone domain in which this environment profile is created.
        public let domainId: String
        /// The ID of the blueprint with which this environment profile is created.
        public let environmentBlueprintId: String
        /// The ID of this Amazon DataZone environment profile.
        public let id: String
        /// The name of this Amazon DataZone environment profile.
        public let name: String
        /// The ID of the Amazon DataZone project in which this environment profile is created.
        public let projectId: String?
        /// The timestamp of when this environment profile was updated.
        public let updatedAt: Date?
        /// The user parameters of this Amazon DataZone environment profile.
        public let userParameters: [CustomParameter]?

        public init(awsAccountId: String? = nil, awsAccountRegion: String? = nil, createdAt: Date? = nil, createdBy: String, description: String? = nil, domainId: String, environmentBlueprintId: String, id: String, name: String, projectId: String? = nil, updatedAt: Date? = nil, userParameters: [CustomParameter]? = nil) {
            self.awsAccountId = awsAccountId
            self.awsAccountRegion = awsAccountRegion
            self.createdAt = createdAt
            self.createdBy = createdBy
            self.description = description
            self.domainId = domainId
            self.environmentBlueprintId = environmentBlueprintId
            self.id = id
            self.name = name
            self.projectId = projectId
            self.updatedAt = updatedAt
            self.userParameters = userParameters
        }

        private enum CodingKeys: String, CodingKey {
            case awsAccountId = "awsAccountId"
            case awsAccountRegion = "awsAccountRegion"
            case createdAt = "createdAt"
            case createdBy = "createdBy"
            case description = "description"
            case domainId = "domainId"
            case environmentBlueprintId = "environmentBlueprintId"
            case id = "id"
            case name = "name"
            case projectId = "projectId"
            case updatedAt = "updatedAt"
            case userParameters = "userParameters"
        }
    }

    public struct CreateFormTypeInput: AWSEncodableShape {
        /// The description of this Amazon DataZone metadata form type.
        public let description: String?
        /// The ID of the Amazon DataZone domain in which this metadata form type is created.
        public let domainIdentifier: String
        /// The model of this Amazon DataZone metadata form type.
        public let model: Model
        /// The name of this Amazon DataZone metadata form type.
        public let name: String
        /// The ID of the Amazon DataZone project that owns this metadata form type.
        public let owningProjectIdentifier: String
        /// The status of this Amazon DataZone metadata form type.
        public let status: FormTypeStatus?

        public init(description: String? = nil, domainIdentifier: String, model: Model, name: String, owningProjectIdentifier: String, status: FormTypeStatus? = nil) {
            self.description = description
            self.domainIdentifier = domainIdentifier
            self.model = model
            self.name = name
            self.owningProjectIdentifier = owningProjectIdentifier
            self.status = status
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.description, forKey: .description)
            request.encodePath(self.domainIdentifier, key: "domainIdentifier")
            try container.encode(self.model, forKey: .model)
            try container.encode(self.name, forKey: .name)
            try container.encode(self.owningProjectIdentifier, forKey: .owningProjectIdentifier)
            try container.encodeIfPresent(self.status, forKey: .status)
        }

        public func validate(name: String) throws {
            try self.validate(self.description, name: "description", parent: name, max: 2048)
            try self.validate(self.domainIdentifier, name: "domainIdentifier", parent: name, pattern: "^dzd[-_][a-zA-Z0-9_-]{1,36}$")
            try self.model.validate(name: "\(name).model")
            try self.validate(self.name, name: "name", parent: name, max: 128)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^(amazon.datazone.)?(?![0-9_])\\w+$|^_\\w*[a-zA-Z0-9]\\w*$")
            try self.validate(self.owningProjectIdentifier, name: "owningProjectIdentifier", parent: name, pattern: "^[a-zA-Z0-9_-]{1,36}$")
        }

        private enum CodingKeys: String, CodingKey {
            case description = "description"
            case model = "model"
            case name = "name"
            case owningProjectIdentifier = "owningProjectIdentifier"
            case status = "status"
        }
    }

    public struct CreateFormTypeOutput: AWSDecodableShape {
        /// The description of this Amazon DataZone metadata form type.
        public let description: String?
        /// The ID of the Amazon DataZone domain in which this metadata form type is created.
        public let domainId: String
        /// The name of this Amazon DataZone metadata form type.
        public let name: String
        /// The ID of the Amazon DataZone domain in which this metadata form type was originally created.
        public let originDomainId: String?
        /// The ID of the project in which this Amazon DataZone metadata form type was originally created.
        public let originProjectId: String?
        /// The ID of the project that owns this Amazon DataZone metadata form type.
        public let owningProjectId: String?
        /// The revision of this Amazon DataZone metadata form type.
        public let revision: String

        public init(description: String? = nil, domainId: String, name: String, originDomainId: String? = nil, originProjectId: String? = nil, owningProjectId: String? = nil, revision: String) {
            self.description = description
            self.domainId = domainId
            self.name = name
            self.originDomainId = originDomainId
            self.originProjectId = originProjectId
            self.owningProjectId = owningProjectId
            self.revision = revision
        }

        private enum CodingKeys: String, CodingKey {
            case description = "description"
            case domainId = "domainId"
            case name = "name"
            case originDomainId = "originDomainId"
            case originProjectId = "originProjectId"
            case owningProjectId = "owningProjectId"
            case revision = "revision"
        }
    }

    public struct CreateGlossaryInput: AWSEncodableShape {
        /// A unique, case-sensitive identifier that is provided to ensure the idempotency of the request.
        public let clientToken: String?
        /// The description of this business glossary.
        public let description: String?
        /// The ID of the Amazon DataZone domain in which this business glossary is created.
        public let domainIdentifier: String
        /// The name of this business glossary.
        public let name: String
        /// The ID of the project that currently owns business glossary.
        public let owningProjectIdentifier: String
        /// The status of this business glossary.
        public let status: GlossaryStatus?

        public init(clientToken: String? = CreateGlossaryInput.idempotencyToken(), description: String? = nil, domainIdentifier: String, name: String, owningProjectIdentifier: String, status: GlossaryStatus? = nil) {
            self.clientToken = clientToken
            self.description = description
            self.domainIdentifier = domainIdentifier
            self.name = name
            self.owningProjectIdentifier = owningProjectIdentifier
            self.status = status
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.clientToken, forKey: .clientToken)
            try container.encodeIfPresent(self.description, forKey: .description)
            request.encodePath(self.domainIdentifier, key: "domainIdentifier")
            try container.encode(self.name, forKey: .name)
            try container.encode(self.owningProjectIdentifier, forKey: .owningProjectIdentifier)
            try container.encodeIfPresent(self.status, forKey: .status)
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 128)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "^[\\x21-\\x7E]+$")
            try self.validate(self.description, name: "description", parent: name, max: 4096)
            try self.validate(self.domainIdentifier, name: "domainIdentifier", parent: name, pattern: "^dzd[-_][a-zA-Z0-9_-]{1,36}$")
            try self.validate(self.name, name: "name", parent: name, max: 256)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.owningProjectIdentifier, name: "owningProjectIdentifier", parent: name, pattern: "^[a-zA-Z0-9_-]{1,36}$")
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "clientToken"
            case description = "description"
            case name = "name"
            case owningProjectIdentifier = "owningProjectIdentifier"
            case status = "status"
        }
    }

    public struct CreateGlossaryOutput: AWSDecodableShape {
        /// The description of this business glossary.
        public let description: String?
        /// The ID of the Amazon DataZone domain in which this business glossary is created.
        public let domainId: String
        /// The ID of this business glossary.
        public let id: String
        /// The name of this business glossary.
        public let name: String
        /// The ID of the project that currently owns this business glossary.
        public let owningProjectId: String
        /// The status of this business glossary.
        public let status: GlossaryStatus?

        public init(description: String? = nil, domainId: String, id: String, name: String, owningProjectId: String, status: GlossaryStatus? = nil) {
            self.description = description
            self.domainId = domainId
            self.id = id
            self.name = name
            self.owningProjectId = owningProjectId
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case description = "description"
            case domainId = "domainId"
            case id = "id"
            case name = "name"
            case owningProjectId = "owningProjectId"
            case status = "status"
        }
    }

    public struct CreateGlossaryTermInput: AWSEncodableShape {
        /// A unique, case-sensitive identifier that is provided to ensure the idempotency of the request.
        public let clientToken: String?
        /// The ID of the Amazon DataZone domain in which this business glossary term is created.
        public let domainIdentifier: String
        /// The ID of the business glossary in which this term is created.
        public let glossaryIdentifier: String
        /// The long description of this business glossary term.
        public let longDescription: String?
        /// The name of this business glossary term.
        public let name: String
        /// The short description of this business glossary term.
        public let shortDescription: String?
        /// The status of this business glossary term.
        public let status: GlossaryTermStatus?
        /// The term relations of this business glossary term.
        public let termRelations: TermRelations?

        public init(clientToken: String? = CreateGlossaryTermInput.idempotencyToken(), domainIdentifier: String, glossaryIdentifier: String, longDescription: String? = nil, name: String, shortDescription: String? = nil, status: GlossaryTermStatus? = nil, termRelations: TermRelations? = nil) {
            self.clientToken = clientToken
            self.domainIdentifier = domainIdentifier
            self.glossaryIdentifier = glossaryIdentifier
            self.longDescription = longDescription
            self.name = name
            self.shortDescription = shortDescription
            self.status = status
            self.termRelations = termRelations
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.clientToken, forKey: .clientToken)
            request.encodePath(self.domainIdentifier, key: "domainIdentifier")
            try container.encode(self.glossaryIdentifier, forKey: .glossaryIdentifier)
            try container.encodeIfPresent(self.longDescription, forKey: .longDescription)
            try container.encode(self.name, forKey: .name)
            try container.encodeIfPresent(self.shortDescription, forKey: .shortDescription)
            try container.encodeIfPresent(self.status, forKey: .status)
            try container.encodeIfPresent(self.termRelations, forKey: .termRelations)
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 128)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "^[\\x21-\\x7E]+$")
            try self.validate(self.domainIdentifier, name: "domainIdentifier", parent: name, pattern: "^dzd[-_][a-zA-Z0-9_-]{1,36}$")
            try self.validate(self.glossaryIdentifier, name: "glossaryIdentifier", parent: name, pattern: "^[a-zA-Z0-9_-]{1,36}$")
            try self.validate(self.longDescription, name: "longDescription", parent: name, max: 4096)
            try self.validate(self.name, name: "name", parent: name, max: 256)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.shortDescription, name: "shortDescription", parent: name, max: 1024)
            try self.termRelations?.validate(name: "\(name).termRelations")
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "clientToken"
            case glossaryIdentifier = "glossaryIdentifier"
            case longDescription = "longDescription"
            case name = "name"
            case shortDescription = "shortDescription"
            case status = "status"
            case termRelations = "termRelations"
        }
    }

    public struct CreateGlossaryTermOutput: AWSDecodableShape {
        /// The ID of the Amazon DataZone domain in which this business glossary term is created.
        public let domainId: String
        /// The ID of the business glossary in which this term is created.
        public let glossaryId: String
        /// The ID of this business glossary term.
        public let id: String
        /// The long description of this business glossary term.
        public let longDescription: String?
        /// The name of this business glossary term.
        public let name: String
        /// The short description of this business glossary term.
        public let shortDescription: String?
        /// The status of this business glossary term.
        public let status: GlossaryTermStatus
        /// The term relations of this business glossary term.
        public let termRelations: TermRelations?

        public init(domainId: String, glossaryId: String, id: String, longDescription: String? = nil, name: String, shortDescription: String? = nil, status: GlossaryTermStatus, termRelations: TermRelations? = nil) {
            self.domainId = domainId
            self.glossaryId = glossaryId
            self.id = id
            self.longDescription = longDescription
            self.name = name
            self.shortDescription = shortDescription
            self.status = status
            self.termRelations = termRelations
        }

        private enum CodingKeys: String, CodingKey {
            case domainId = "domainId"
            case glossaryId = "glossaryId"
            case id = "id"
            case longDescription = "longDescription"
            case name = "name"
            case shortDescription = "shortDescription"
            case status = "status"
            case termRelations = "termRelations"
        }
    }

    public struct CreateGroupProfileInput: AWSEncodableShape {
        ///  A unique, case-sensitive identifier that is provided to ensure the idempotency of the request.
        public let clientToken: String?
        /// The identifier of the Amazon DataZone domain in which the group profile is created.
        public let domainIdentifier: String
        /// The identifier of the group for which the group profile is created.
        public let groupIdentifier: String

        public init(clientToken: String? = CreateGroupProfileInput.idempotencyToken(), domainIdentifier: String, groupIdentifier: String) {
            self.clientToken = clientToken
            self.domainIdentifier = domainIdentifier
            self.groupIdentifier = groupIdentifier
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.clientToken, forKey: .clientToken)
            request.encodePath(self.domainIdentifier, key: "domainIdentifier")
            try container.encode(self.groupIdentifier, forKey: .groupIdentifier)
        }

        public func validate(name: String) throws {
            try self.validate(self.domainIdentifier, name: "domainIdentifier", parent: name, pattern: "^dzd[-_][a-zA-Z0-9_-]{1,36}$")
            try self.validate(self.groupIdentifier, name: "groupIdentifier", parent: name, pattern: "(^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}$|[\\p{L}\\p{M}\\p{S}\\p{N}\\p{P}\\t\\n\\r  ]+)")
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "clientToken"
            case groupIdentifier = "groupIdentifier"
        }
    }

    public struct CreateGroupProfileOutput: AWSDecodableShape {
        /// The identifier of the Amazon DataZone domain in which the group profile is created.
        public let domainId: String?
        /// The name of the group for which group profile is created.
        public let groupName: String?
        /// The identifier of the group profile.
        public let id: String?
        /// The status of the group profile.
        public let status: GroupProfileStatus?

        public init(domainId: String? = nil, groupName: String? = nil, id: String? = nil, status: GroupProfileStatus? = nil) {
            self.domainId = domainId
            self.groupName = groupName
            self.id = id
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case domainId = "domainId"
            case groupName = "groupName"
            case id = "id"
            case status = "status"
        }
    }

    public struct CreateListingChangeSetInput: AWSEncodableShape {
        /// Specifies whether to publish or unpublish a listing.
        public let action: ChangeAction
        /// A unique, case-sensitive identifier that is provided to ensure the idempotency of the request.
        public let clientToken: String?
        /// The ID of the Amazon DataZone domain.
        public let domainIdentifier: String
        /// The ID of the asset.
        public let entityIdentifier: String
        /// The revision of an asset.
        public let entityRevision: String?
        /// The type of an entity.
        public let entityType: EntityType

        public init(action: ChangeAction, clientToken: String? = CreateListingChangeSetInput.idempotencyToken(), domainIdentifier: String, entityIdentifier: String, entityRevision: String? = nil, entityType: EntityType) {
            self.action = action
            self.clientToken = clientToken
            self.domainIdentifier = domainIdentifier
            self.entityIdentifier = entityIdentifier
            self.entityRevision = entityRevision
            self.entityType = entityType
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encode(self.action, forKey: .action)
            try container.encodeIfPresent(self.clientToken, forKey: .clientToken)
            request.encodePath(self.domainIdentifier, key: "domainIdentifier")
            try container.encode(self.entityIdentifier, forKey: .entityIdentifier)
            try container.encodeIfPresent(self.entityRevision, forKey: .entityRevision)
            try container.encode(self.entityType, forKey: .entityType)
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 128)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "^[\\x21-\\x7E]+$")
            try self.validate(self.domainIdentifier, name: "domainIdentifier", parent: name, pattern: "^dzd[-_][a-zA-Z0-9_-]{1,36}$")
            try self.validate(self.entityIdentifier, name: "entityIdentifier", parent: name, pattern: "^[a-zA-Z0-9_-]{1,36}$")
            try self.validate(self.entityRevision, name: "entityRevision", parent: name, max: 64)
            try self.validate(self.entityRevision, name: "entityRevision", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case action = "action"
            case clientToken = "clientToken"
            case entityIdentifier = "entityIdentifier"
            case entityRevision = "entityRevision"
            case entityType = "entityType"
        }
    }

    public struct CreateListingChangeSetOutput: AWSDecodableShape {
        /// The ID of the listing (a record of an asset at a given time).
        public let listingId: String
        /// The revision of a listing.
        public let listingRevision: String
        /// Specifies the status of the listing.
        public let status: ListingStatus

        public init(listingId: String, listingRevision: String, status: ListingStatus) {
            self.listingId = listingId
            self.listingRevision = listingRevision
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case listingId = "listingId"
            case listingRevision = "listingRevision"
            case status = "status"
        }
    }

    public struct CreateProjectInput: AWSEncodableShape {
        /// The description of the Amazon DataZone project.
        public let description: String?
        /// The ID of the Amazon DataZone domain in which this project is created.
        public let domainIdentifier: String
        /// The glossary terms that can be used in this Amazon DataZone project.
        public let glossaryTerms: [String]?
        /// The name of the Amazon DataZone project.
        public let name: String

        public init(description: String? = nil, domainIdentifier: String, glossaryTerms: [String]? = nil, name: String) {
            self.description = description
            self.domainIdentifier = domainIdentifier
            self.glossaryTerms = glossaryTerms
            self.name = name
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.description, forKey: .description)
            request.encodePath(self.domainIdentifier, key: "domainIdentifier")
            try container.encodeIfPresent(self.glossaryTerms, forKey: .glossaryTerms)
            try container.encode(self.name, forKey: .name)
        }

        public func validate(name: String) throws {
            try self.validate(self.description, name: "description", parent: name, max: 2048)
            try self.validate(self.domainIdentifier, name: "domainIdentifier", parent: name, pattern: "^dzd[-_][a-zA-Z0-9_-]{1,36}$")
            try self.glossaryTerms?.forEach {
                try validate($0, name: "glossaryTerms[]", parent: name, pattern: "^[a-zA-Z0-9_-]{1,36}$")
            }
            try self.validate(self.glossaryTerms, name: "glossaryTerms", parent: name, max: 20)
            try self.validate(self.glossaryTerms, name: "glossaryTerms", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, max: 64)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[\\w -]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case description = "description"
            case glossaryTerms = "glossaryTerms"
            case name = "name"
        }
    }

    public struct CreateProjectMembershipInput: AWSEncodableShape {
        /// The designation of the project membership.
        public let designation: UserDesignation
        /// The ID of the Amazon DataZone domain in which project membership is created.
        public let domainIdentifier: String
        /// The project member whose project membership was created.
        public let member: Member
        /// The ID of the project for which this project membership was created.
        public let projectIdentifier: String

        public init(designation: UserDesignation, domainIdentifier: String, member: Member, projectIdentifier: String) {
            self.designation = designation
            self.domainIdentifier = domainIdentifier
            self.member = member
            self.projectIdentifier = projectIdentifier
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encode(self.designation, forKey: .designation)
            request.encodePath(self.domainIdentifier, key: "domainIdentifier")
            try container.encode(self.member, forKey: .member)
            request.encodePath(self.projectIdentifier, key: "projectIdentifier")
        }

        public func validate(name: String) throws {
            try self.validate(self.domainIdentifier, name: "domainIdentifier", parent: name, pattern: "^dzd[-_][a-zA-Z0-9_-]{1,36}$")
            try self.validate(self.projectIdentifier, name: "projectIdentifier", parent: name, pattern: "^[a-zA-Z0-9_-]{1,36}$")
        }

        private enum CodingKeys: String, CodingKey {
            case designation = "designation"
            case member = "member"
        }
    }

    public struct CreateProjectMembershipOutput: AWSDecodableShape {
        public init() {}
    }

    public struct CreateProjectOutput: AWSDecodableShape {
        /// The timestamp of when the project was created.
        public let createdAt: Date?
        /// The Amazon DataZone user who created the project.
        public let createdBy: String
        /// The description of the project.
        public let description: String?
        /// The identifier of the Amazon DataZone domain in which the project was created.
        public let domainId: String
        /// Specifies the error message that is returned if the operation cannot be successfully completed.
        public let failureReasons: [ProjectDeletionError]?
        /// The glossary terms that can be used in the project.
        public let glossaryTerms: [String]?
        /// The ID of the Amazon DataZone project.
        public let id: String
        /// The timestamp of when the project was last updated.
        public let lastUpdatedAt: Date?
        /// The name of the project.
        public let name: String
        /// The status of the Amazon DataZone project that was created.
        public let projectStatus: ProjectStatus?

        public init(createdAt: Date? = nil, createdBy: String, description: String? = nil, domainId: String, failureReasons: [ProjectDeletionError]? = nil, glossaryTerms: [String]? = nil, id: String, lastUpdatedAt: Date? = nil, name: String, projectStatus: ProjectStatus? = nil) {
            self.createdAt = createdAt
            self.createdBy = createdBy
            self.description = description
            self.domainId = domainId
            self.failureReasons = failureReasons
            self.glossaryTerms = glossaryTerms
            self.id = id
            self.lastUpdatedAt = lastUpdatedAt
            self.name = name
            self.projectStatus = projectStatus
        }

        private enum CodingKeys: String, CodingKey {
            case createdAt = "createdAt"
            case createdBy = "createdBy"
            case description = "description"
            case domainId = "domainId"
            case failureReasons = "failureReasons"
            case glossaryTerms = "glossaryTerms"
            case id = "id"
            case lastUpdatedAt = "lastUpdatedAt"
            case name = "name"
            case projectStatus = "projectStatus"
        }
    }

    public struct CreateSubscriptionGrantInput: AWSEncodableShape {
        /// The names of the assets for which the subscription grant is created.
        public let assetTargetNames: [AssetTargetNameMap]?
        /// A unique, case-sensitive identifier that is provided to ensure the idempotency of the request.
        public let clientToken: String?
        /// The ID of the Amazon DataZone domain in which the subscription grant is created.
        public let domainIdentifier: String
        /// The ID of the environment in which the subscription grant is created.
        public let environmentIdentifier: String
        /// The entity to which the subscription is to be granted.
        public let grantedEntity: GrantedEntityInput
        /// The ID of the subscription target for which the subscription grant is created.
        public let subscriptionTargetIdentifier: String

        public init(assetTargetNames: [AssetTargetNameMap]? = nil, clientToken: String? = CreateSubscriptionGrantInput.idempotencyToken(), domainIdentifier: String, environmentIdentifier: String, grantedEntity: GrantedEntityInput, subscriptionTargetIdentifier: String) {
            self.assetTargetNames = assetTargetNames
            self.clientToken = clientToken
            self.domainIdentifier = domainIdentifier
            self.environmentIdentifier = environmentIdentifier
            self.grantedEntity = grantedEntity
            self.subscriptionTargetIdentifier = subscriptionTargetIdentifier
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.assetTargetNames, forKey: .assetTargetNames)
            try container.encodeIfPresent(self.clientToken, forKey: .clientToken)
            request.encodePath(self.domainIdentifier, key: "domainIdentifier")
            try container.encode(self.environmentIdentifier, forKey: .environmentIdentifier)
            try container.encode(self.grantedEntity, forKey: .grantedEntity)
            try container.encode(self.subscriptionTargetIdentifier, forKey: .subscriptionTargetIdentifier)
        }

        public func validate(name: String) throws {
            try self.assetTargetNames?.forEach {
                try $0.validate(name: "\(name).assetTargetNames[]")
            }
            try self.validate(self.domainIdentifier, name: "domainIdentifier", parent: name, pattern: "^dzd[-_][a-zA-Z0-9_-]{1,36}$")
            try self.validate(self.environmentIdentifier, name: "environmentIdentifier", parent: name, pattern: "^[a-zA-Z0-9_-]{1,36}$")
            try self.grantedEntity.validate(name: "\(name).grantedEntity")
            try self.validate(self.subscriptionTargetIdentifier, name: "subscriptionTargetIdentifier", parent: name, pattern: "^[a-zA-Z0-9_-]{1,36}$")
        }

        private enum CodingKeys: String, CodingKey {
            case assetTargetNames = "assetTargetNames"
            case clientToken = "clientToken"
            case environmentIdentifier = "environmentIdentifier"
            case grantedEntity = "grantedEntity"
            case subscriptionTargetIdentifier = "subscriptionTargetIdentifier"
        }
    }

    public struct CreateSubscriptionGrantOutput: AWSDecodableShape {
        /// The assets for which the subscription grant is created.
        public let assets: [SubscribedAsset]?
        /// A timestamp of when the subscription grant is created.
        public let createdAt: Date
        /// The Amazon DataZone user who created the subscription grant.
        public let createdBy: String
        /// The ID of the Amazon DataZone domain in which the subscription grant is created.
        public let domainId: String
        /// The entity to which the subscription is granted.
        public let grantedEntity: GrantedEntity
        /// The ID of the subscription grant.
        public let id: String
        /// The status of the subscription grant.
        public let status: SubscriptionGrantOverallStatus
        /// The identifier of the subscription grant.
        public let subscriptionId: String?
        /// The ID of the subscription target for which the subscription grant is created.
        public let subscriptionTargetId: String
        /// A timestamp of when the subscription grant was updated.
        public let updatedAt: Date
        /// The Amazon DataZone user who updated the subscription grant.
        public let updatedBy: String?

        public init(assets: [SubscribedAsset]? = nil, createdAt: Date, createdBy: String, domainId: String, grantedEntity: GrantedEntity, id: String, status: SubscriptionGrantOverallStatus, subscriptionId: String? = nil, subscriptionTargetId: String, updatedAt: Date, updatedBy: String? = nil) {
            self.assets = assets
            self.createdAt = createdAt
            self.createdBy = createdBy
            self.domainId = domainId
            self.grantedEntity = grantedEntity
            self.id = id
            self.status = status
            self.subscriptionId = subscriptionId
            self.subscriptionTargetId = subscriptionTargetId
            self.updatedAt = updatedAt
            self.updatedBy = updatedBy
        }

        private enum CodingKeys: String, CodingKey {
            case assets = "assets"
            case createdAt = "createdAt"
            case createdBy = "createdBy"
            case domainId = "domainId"
            case grantedEntity = "grantedEntity"
            case id = "id"
            case status = "status"
            case subscriptionId = "subscriptionId"
            case subscriptionTargetId = "subscriptionTargetId"
            case updatedAt = "updatedAt"
            case updatedBy = "updatedBy"
        }
    }

    public struct CreateSubscriptionRequestInput: AWSEncodableShape {
        /// A unique, case-sensitive identifier that is provided to ensure the idempotency of the request.
        public let clientToken: String?
        /// The ID of the Amazon DataZone domain in which the subscription request is created.
        public let domainIdentifier: String
        /// The reason for the subscription request.
        public let requestReason: String
        /// The published asset for which the subscription grant is to be created.
        public let subscribedListings: [SubscribedListingInput]
        /// The Amazon DataZone principals for whom the subscription request is created.
        public let subscribedPrincipals: [SubscribedPrincipalInput]

        public init(clientToken: String? = CreateSubscriptionRequestInput.idempotencyToken(), domainIdentifier: String, requestReason: String, subscribedListings: [SubscribedListingInput], subscribedPrincipals: [SubscribedPrincipalInput]) {
            self.clientToken = clientToken
            self.domainIdentifier = domainIdentifier
            self.requestReason = requestReason
            self.subscribedListings = subscribedListings
            self.subscribedPrincipals = subscribedPrincipals
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.clientToken, forKey: .clientToken)
            request.encodePath(self.domainIdentifier, key: "domainIdentifier")
            try container.encode(self.requestReason, forKey: .requestReason)
            try container.encode(self.subscribedListings, forKey: .subscribedListings)
            try container.encode(self.subscribedPrincipals, forKey: .subscribedPrincipals)
        }

        public func validate(name: String) throws {
            try self.validate(self.domainIdentifier, name: "domainIdentifier", parent: name, pattern: "^dzd[-_][a-zA-Z0-9_-]{1,36}$")
            try self.validate(self.requestReason, name: "requestReason", parent: name, max: 4096)
            try self.validate(self.requestReason, name: "requestReason", parent: name, min: 1)
            try self.subscribedListings.forEach {
                try $0.validate(name: "\(name).subscribedListings[]")
            }
            try self.validate(self.subscribedListings, name: "subscribedListings", parent: name, max: 1)
            try self.validate(self.subscribedListings, name: "subscribedListings", parent: name, min: 1)
            try self.subscribedPrincipals.forEach {
                try $0.validate(name: "\(name).subscribedPrincipals[]")
            }
            try self.validate(self.subscribedPrincipals, name: "subscribedPrincipals", parent: name, max: 1)
            try self.validate(self.subscribedPrincipals, name: "subscribedPrincipals", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "clientToken"
            case requestReason = "requestReason"
            case subscribedListings = "subscribedListings"
            case subscribedPrincipals = "subscribedPrincipals"
        }
    }

    public struct CreateSubscriptionRequestOutput: AWSDecodableShape {
        /// A timestamp of when the subscription request is created.
        public let createdAt: Date
        /// The Amazon DataZone user who created the subscription request.
        public let createdBy: String
        /// The decision comment of the subscription request.
        public let decisionComment: String?
        /// The ID of the Amazon DataZone domain in whcih the subscription request is created.
        public let domainId: String
        /// The ID of the subscription request.
        public let id: String
        /// The reason for the subscription request.
        public let requestReason: String
        /// The ID of the reviewer of the subscription request.
        public let reviewerId: String?
        /// The status of the subscription request.
        public let status: SubscriptionRequestStatus
        /// The published asset for which the subscription grant is to be created.
        public let subscribedListings: [SubscribedListing]
        /// The subscribed principals of the subscription request.
        public let subscribedPrincipals: [SubscribedPrincipal]
        /// The timestamp of when the subscription request was updated.
        public let updatedAt: Date
        /// The Amazon DataZone user who updated the subscription request.
        public let updatedBy: String?

        public init(createdAt: Date, createdBy: String, decisionComment: String? = nil, domainId: String, id: String, requestReason: String, reviewerId: String? = nil, status: SubscriptionRequestStatus, subscribedListings: [SubscribedListing], subscribedPrincipals: [SubscribedPrincipal], updatedAt: Date, updatedBy: String? = nil) {
            self.createdAt = createdAt
            self.createdBy = createdBy
            self.decisionComment = decisionComment
            self.domainId = domainId
            self.id = id
            self.requestReason = requestReason
            self.reviewerId = reviewerId
            self.status = status
            self.subscribedListings = subscribedListings
            self.subscribedPrincipals = subscribedPrincipals
            self.updatedAt = updatedAt
            self.updatedBy = updatedBy
        }

        private enum CodingKeys: String, CodingKey {
            case createdAt = "createdAt"
            case createdBy = "createdBy"
            case decisionComment = "decisionComment"
            case domainId = "domainId"
            case id = "id"
            case requestReason = "requestReason"
            case reviewerId = "reviewerId"
            case status = "status"
            case subscribedListings = "subscribedListings"
            case subscribedPrincipals = "subscribedPrincipals"
            case updatedAt = "updatedAt"
            case updatedBy = "updatedBy"
        }
    }

    public struct CreateSubscriptionTargetInput: AWSEncodableShape {
        /// The asset types that can be included in the subscription target.
        public let applicableAssetTypes: [String]
        /// The authorized principals of the subscription target.
        public let authorizedPrincipals: [String]
        /// A unique, case-sensitive identifier that is provided to ensure the idempotency of the request.
        public let clientToken: String?
        /// The ID of the Amazon DataZone domain in which subscription target is created.
        public let domainIdentifier: String
        /// The ID of the environment in which subscription target is created.
        public let environmentIdentifier: String
        /// The manage access role that is used to create the subscription target.
        public let manageAccessRole: String
        /// The name of the subscription target.
        public let name: String
        /// The provider of the subscription target.
        public let provider: String?
        /// The configuration of the subscription target.
        public let subscriptionTargetConfig: [SubscriptionTargetForm]
        /// The type of the subscription target.
        public let type: String

        public init(applicableAssetTypes: [String], authorizedPrincipals: [String], clientToken: String? = CreateSubscriptionTargetInput.idempotencyToken(), domainIdentifier: String, environmentIdentifier: String, manageAccessRole: String, name: String, provider: String? = nil, subscriptionTargetConfig: [SubscriptionTargetForm], type: String) {
            self.applicableAssetTypes = applicableAssetTypes
            self.authorizedPrincipals = authorizedPrincipals
            self.clientToken = clientToken
            self.domainIdentifier = domainIdentifier
            self.environmentIdentifier = environmentIdentifier
            self.manageAccessRole = manageAccessRole
            self.name = name
            self.provider = provider
            self.subscriptionTargetConfig = subscriptionTargetConfig
            self.type = type
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encode(self.applicableAssetTypes, forKey: .applicableAssetTypes)
            try container.encode(self.authorizedPrincipals, forKey: .authorizedPrincipals)
            try container.encodeIfPresent(self.clientToken, forKey: .clientToken)
            request.encodePath(self.domainIdentifier, key: "domainIdentifier")
            request.encodePath(self.environmentIdentifier, key: "environmentIdentifier")
            try container.encode(self.manageAccessRole, forKey: .manageAccessRole)
            try container.encode(self.name, forKey: .name)
            try container.encodeIfPresent(self.provider, forKey: .provider)
            try container.encode(self.subscriptionTargetConfig, forKey: .subscriptionTargetConfig)
            try container.encode(self.type, forKey: .type)
        }

        public func validate(name: String) throws {
            try self.applicableAssetTypes.forEach {
                try validate($0, name: "applicableAssetTypes[]", parent: name, max: 256)
                try validate($0, name: "applicableAssetTypes[]", parent: name, min: 1)
                try validate($0, name: "applicableAssetTypes[]", parent: name, pattern: "^[^\\.]*")
            }
            try self.authorizedPrincipals.forEach {
                try validate($0, name: "authorizedPrincipals[]", parent: name, pattern: "^[a-zA-Z0-9:/_-]*$")
            }
            try self.validate(self.authorizedPrincipals, name: "authorizedPrincipals", parent: name, max: 10)
            try self.validate(self.authorizedPrincipals, name: "authorizedPrincipals", parent: name, min: 1)
            try self.validate(self.domainIdentifier, name: "domainIdentifier", parent: name, pattern: "^dzd[-_][a-zA-Z0-9_-]{1,36}$")
            try self.validate(self.environmentIdentifier, name: "environmentIdentifier", parent: name, pattern: "^[a-zA-Z0-9_-]{1,36}$")
            try self.validate(self.name, name: "name", parent: name, max: 256)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.subscriptionTargetConfig.forEach {
                try $0.validate(name: "\(name).subscriptionTargetConfig[]")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case applicableAssetTypes = "applicableAssetTypes"
            case authorizedPrincipals = "authorizedPrincipals"
            case clientToken = "clientToken"
            case manageAccessRole = "manageAccessRole"
            case name = "name"
            case provider = "provider"
            case subscriptionTargetConfig = "subscriptionTargetConfig"
            case type = "type"
        }
    }

    public struct CreateSubscriptionTargetOutput: AWSDecodableShape {
        /// The asset types that can be included in the subscription target.
        public let applicableAssetTypes: [String]
        /// The authorised principals of the subscription target.
        public let authorizedPrincipals: [String]
        /// The timestamp of when the subscription target was created.
        public let createdAt: Date
        /// The Amazon DataZone user who created the subscription target.
        public let createdBy: String
        /// The ID of the Amazon DataZone domain in which the subscription target was created.
        public let domainId: String
        /// The ID of the environment in which the subscription target was created.
        public let environmentId: String
        /// The ID of the subscription target.
        public let id: String
        /// The manage access role with which the subscription target was created.
        public let manageAccessRole: String
        /// The name of the subscription target.
        public let name: String
        /// ???
        public let projectId: String
        /// The provider of the subscription target.
        public let provider: String
        /// The configuration of the subscription target.
        public let subscriptionTargetConfig: [SubscriptionTargetForm]
        /// The type of the subscription target.
        public let type: String
        /// The timestamp of when the subscription target was updated.
        public let updatedAt: Date?
        /// The Amazon DataZone user who updated the subscription target.
        public let updatedBy: String?

        public init(applicableAssetTypes: [String], authorizedPrincipals: [String], createdAt: Date, createdBy: String, domainId: String, environmentId: String, id: String, manageAccessRole: String, name: String, projectId: String, provider: String, subscriptionTargetConfig: [SubscriptionTargetForm], type: String, updatedAt: Date? = nil, updatedBy: String? = nil) {
            self.applicableAssetTypes = applicableAssetTypes
            self.authorizedPrincipals = authorizedPrincipals
            self.createdAt = createdAt
            self.createdBy = createdBy
            self.domainId = domainId
            self.environmentId = environmentId
            self.id = id
            self.manageAccessRole = manageAccessRole
            self.name = name
            self.projectId = projectId
            self.provider = provider
            self.subscriptionTargetConfig = subscriptionTargetConfig
            self.type = type
            self.updatedAt = updatedAt
            self.updatedBy = updatedBy
        }

        private enum CodingKeys: String, CodingKey {
            case applicableAssetTypes = "applicableAssetTypes"
            case authorizedPrincipals = "authorizedPrincipals"
            case createdAt = "createdAt"
            case createdBy = "createdBy"
            case domainId = "domainId"
            case environmentId = "environmentId"
            case id = "id"
            case manageAccessRole = "manageAccessRole"
            case name = "name"
            case projectId = "projectId"
            case provider = "provider"
            case subscriptionTargetConfig = "subscriptionTargetConfig"
            case type = "type"
            case updatedAt = "updatedAt"
            case updatedBy = "updatedBy"
        }
    }

    public struct CreateUserProfileInput: AWSEncodableShape {
        /// A unique, case-sensitive identifier that is provided to ensure the idempotency of the request.
        public let clientToken: String?
        /// The identifier of the Amazon DataZone domain in which a user profile is created.
        public let domainIdentifier: String
        /// The identifier of the user for which the user profile is created.
        public let userIdentifier: String
        /// The user type of the user for which the user profile is created.
        public let userType: UserType?

        public init(clientToken: String? = CreateUserProfileInput.idempotencyToken(), domainIdentifier: String, userIdentifier: String, userType: UserType? = nil) {
            self.clientToken = clientToken
            self.domainIdentifier = domainIdentifier
            self.userIdentifier = userIdentifier
            self.userType = userType
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.clientToken, forKey: .clientToken)
            request.encodePath(self.domainIdentifier, key: "domainIdentifier")
            try container.encode(self.userIdentifier, forKey: .userIdentifier)
            try container.encodeIfPresent(self.userType, forKey: .userType)
        }

        public func validate(name: String) throws {
            try self.validate(self.domainIdentifier, name: "domainIdentifier", parent: name, pattern: "^dzd[-_][a-zA-Z0-9_-]{1,36}$")
            try self.validate(self.userIdentifier, name: "userIdentifier", parent: name, pattern: "(^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}$|^[a-zA-Z_0-9+=,.@-]+$|^arn:aws:iam::\\d{12}:.+$)")
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "clientToken"
            case userIdentifier = "userIdentifier"
            case userType = "userType"
        }
    }

    public struct CreateUserProfileOutput: AWSDecodableShape {
        public let details: UserProfileDetails?
        /// The identifier of the Amazon DataZone domain in which a user profile is created.
        public let domainId: String?
        /// The identifier of the user profile.
        public let id: String?
        /// The status of the user profile.
        public let status: UserProfileStatus?
        /// The type of the user profile.
        public let type: UserProfileType?

        public init(details: UserProfileDetails? = nil, domainId: String? = nil, id: String? = nil, status: UserProfileStatus? = nil, type: UserProfileType? = nil) {
            self.details = details
            self.domainId = domainId
            self.id = id
            self.status = status
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case details = "details"
            case domainId = "domainId"
            case id = "id"
            case status = "status"
            case type = "type"
        }
    }

    public struct CustomParameter: AWSDecodableShape {
        /// The default value of the parameter.
        public let defaultValue: String?
        /// The description of the parameter.
        public let description: String?
        /// The filed type of the parameter.
        public let fieldType: String
        /// Specifies whether the parameter is editable.
        public let isEditable: Bool?
        /// Specifies whether the custom parameter is optional.
        public let isOptional: Bool?
        /// The key name of the parameter.
        public let keyName: String

        public init(defaultValue: String? = nil, description: String? = nil, fieldType: String, isEditable: Bool? = nil, isOptional: Bool? = nil, keyName: String) {
            self.defaultValue = defaultValue
            self.description = description
            self.fieldType = fieldType
            self.isEditable = isEditable
            self.isOptional = isOptional
            self.keyName = keyName
        }

        private enum CodingKeys: String, CodingKey {
            case defaultValue = "defaultValue"
            case description = "description"
            case fieldType = "fieldType"
            case isEditable = "isEditable"
            case isOptional = "isOptional"
            case keyName = "keyName"
        }
    }

    public struct DataProductItem: AWSDecodableShape {
        public let domainId: String?
        public let itemId: String?

        public init(domainId: String? = nil, itemId: String? = nil) {
            self.domainId = domainId
            self.itemId = itemId
        }

        private enum CodingKeys: String, CodingKey {
            case domainId = "domainId"
            case itemId = "itemId"
        }
    }

    public struct DataProductSummary: AWSDecodableShape {
        public let createdAt: Date?
        public let createdBy: String?
        public let dataProductItems: [DataProductItem]?
        public let description: String?
        public let domainId: String
        public let glossaryTerms: [String]?
        public let id: String
        public let name: String
        public let owningProjectId: String
        public let updatedAt: Date?
        public let updatedBy: String?

        public init(createdAt: Date? = nil, createdBy: String? = nil, dataProductItems: [DataProductItem]? = nil, description: String? = nil, domainId: String, glossaryTerms: [String]? = nil, id: String, name: String, owningProjectId: String, updatedAt: Date? = nil, updatedBy: String? = nil) {
            self.createdAt = createdAt
            self.createdBy = createdBy
            self.dataProductItems = dataProductItems
            self.description = description
            self.domainId = domainId
            self.glossaryTerms = glossaryTerms
            self.id = id
            self.name = name
            self.owningProjectId = owningProjectId
            self.updatedAt = updatedAt
            self.updatedBy = updatedBy
        }

        private enum CodingKeys: String, CodingKey {
            case createdAt = "createdAt"
            case createdBy = "createdBy"
            case dataProductItems = "dataProductItems"
            case description = "description"
            case domainId = "domainId"
            case glossaryTerms = "glossaryTerms"
            case id = "id"
            case name = "name"
            case owningProjectId = "owningProjectId"
            case updatedAt = "updatedAt"
            case updatedBy = "updatedBy"
        }
    }

    public struct DataSourceErrorMessage: AWSDecodableShape {
        /// The details of the error message that is returned if the operation cannot be successfully completed.
        public let errorDetail: String?
        /// The type of the error message that is returned if the operation cannot be successfully completed.
        public let errorType: DataSourceErrorType

        public init(errorDetail: String? = nil, errorType: DataSourceErrorType) {
            self.errorDetail = errorDetail
            self.errorType = errorType
        }

        private enum CodingKeys: String, CodingKey {
            case errorDetail = "errorDetail"
            case errorType = "errorType"
        }
    }

    public struct DataSourceRunActivity: AWSDecodableShape {
        /// The timestamp of when data source run activity was created.
        @CustomCoding<ISO8601DateCoder>
        public var createdAt: Date
        /// The identifier of the asset included in the data source run activity.
        public let dataAssetId: String?
        /// The status of the asset included in the data source run activity.
        public let dataAssetStatus: DataAssetActivityStatus
        /// The database included in the data source run activity.
        public let database: String
        /// The identifier of the data source for the data source run activity.
        public let dataSourceRunId: String
        public let errorMessage: DataSourceErrorMessage?
        /// The project ID included in the data source run activity.
        public let projectId: String
        /// The technical description included in the data source run activity.
        public let technicalDescription: String?
        /// The technical name included in the data source run activity.
        public let technicalName: String
        /// The timestamp of when data source run activity was updated.
        @CustomCoding<ISO8601DateCoder>
        public var updatedAt: Date

        public init(createdAt: Date, dataAssetId: String? = nil, dataAssetStatus: DataAssetActivityStatus, database: String, dataSourceRunId: String, errorMessage: DataSourceErrorMessage? = nil, projectId: String, technicalDescription: String? = nil, technicalName: String, updatedAt: Date) {
            self.createdAt = createdAt
            self.dataAssetId = dataAssetId
            self.dataAssetStatus = dataAssetStatus
            self.database = database
            self.dataSourceRunId = dataSourceRunId
            self.errorMessage = errorMessage
            self.projectId = projectId
            self.technicalDescription = technicalDescription
            self.technicalName = technicalName
            self.updatedAt = updatedAt
        }

        private enum CodingKeys: String, CodingKey {
            case createdAt = "createdAt"
            case dataAssetId = "dataAssetId"
            case dataAssetStatus = "dataAssetStatus"
            case database = "database"
            case dataSourceRunId = "dataSourceRunId"
            case errorMessage = "errorMessage"
            case projectId = "projectId"
            case technicalDescription = "technicalDescription"
            case technicalName = "technicalName"
            case updatedAt = "updatedAt"
        }
    }

    public struct DataSourceRunSummary: AWSDecodableShape {
        /// The timestamp of when a data source run was created.
        @CustomCoding<ISO8601DateCoder>
        public var createdAt: Date
        /// The identifier of the data source of the data source run.
        public let dataSourceId: String
        public let errorMessage: DataSourceErrorMessage?
        /// The identifier of the data source run.
        public let id: String
        /// The project ID of the data source run.
        public let projectId: String
        public let runStatisticsForAssets: RunStatisticsForAssets?
        /// The timestamp of when a data source run was started.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var startedAt: Date?
        /// The status of the data source run.
        public let status: DataSourceRunStatus
        /// The timestamp of when a data source run was stopped.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var stoppedAt: Date?
        /// The type of the data source run.
        public let type: DataSourceRunType
        /// The timestamp of when a data source run was updated.
        @CustomCoding<ISO8601DateCoder>
        public var updatedAt: Date

        public init(createdAt: Date, dataSourceId: String, errorMessage: DataSourceErrorMessage? = nil, id: String, projectId: String, runStatisticsForAssets: RunStatisticsForAssets? = nil, startedAt: Date? = nil, status: DataSourceRunStatus, stoppedAt: Date? = nil, type: DataSourceRunType, updatedAt: Date) {
            self.createdAt = createdAt
            self.dataSourceId = dataSourceId
            self.errorMessage = errorMessage
            self.id = id
            self.projectId = projectId
            self.runStatisticsForAssets = runStatisticsForAssets
            self.startedAt = startedAt
            self.status = status
            self.stoppedAt = stoppedAt
            self.type = type
            self.updatedAt = updatedAt
        }

        private enum CodingKeys: String, CodingKey {
            case createdAt = "createdAt"
            case dataSourceId = "dataSourceId"
            case errorMessage = "errorMessage"
            case id = "id"
            case projectId = "projectId"
            case runStatisticsForAssets = "runStatisticsForAssets"
            case startedAt = "startedAt"
            case status = "status"
            case stoppedAt = "stoppedAt"
            case type = "type"
            case updatedAt = "updatedAt"
        }
    }

    public struct DataSourceSummary: AWSDecodableShape {
        /// The timestamp of when the data source was created.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var createdAt: Date?
        /// The ID of the data source.
        public let dataSourceId: String
        /// The ID of the Amazon DataZone domain in which the data source exists.
        public let domainId: String
        /// Specifies whether the data source is enabled.
        public let enableSetting: EnableSetting?
        /// The ID of the environment in which the data source exists.
        public let environmentId: String
        /// The count of the assets created during the last data source run.
        public let lastRunAssetCount: Int?
        /// The timestamp of when the data source run was last performed.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var lastRunAt: Date?
        public let lastRunErrorMessage: DataSourceErrorMessage?
        /// The status of the last data source run.
        public let lastRunStatus: DataSourceRunStatus?
        /// The name of the data source.
        public let name: String
        public let schedule: ScheduleConfiguration?
        /// The status of the data source.
        public let status: DataSourceStatus
        /// The type of the data source.
        public let type: String
        /// The timestamp of when the data source was updated.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var updatedAt: Date?

        public init(createdAt: Date? = nil, dataSourceId: String, domainId: String, enableSetting: EnableSetting? = nil, environmentId: String, lastRunAssetCount: Int? = nil, lastRunAt: Date? = nil, lastRunErrorMessage: DataSourceErrorMessage? = nil, lastRunStatus: DataSourceRunStatus? = nil, name: String, schedule: ScheduleConfiguration? = nil, status: DataSourceStatus, type: String, updatedAt: Date? = nil) {
            self.createdAt = createdAt
            self.dataSourceId = dataSourceId
            self.domainId = domainId
            self.enableSetting = enableSetting
            self.environmentId = environmentId
            self.lastRunAssetCount = lastRunAssetCount
            self.lastRunAt = lastRunAt
            self.lastRunErrorMessage = lastRunErrorMessage
            self.lastRunStatus = lastRunStatus
            self.name = name
            self.schedule = schedule
            self.status = status
            self.type = type
            self.updatedAt = updatedAt
        }

        private enum CodingKeys: String, CodingKey {
            case createdAt = "createdAt"
            case dataSourceId = "dataSourceId"
            case domainId = "domainId"
            case enableSetting = "enableSetting"
            case environmentId = "environmentId"
            case lastRunAssetCount = "lastRunAssetCount"
            case lastRunAt = "lastRunAt"
            case lastRunErrorMessage = "lastRunErrorMessage"
            case lastRunStatus = "lastRunStatus"
            case name = "name"
            case schedule = "schedule"
            case status = "status"
            case type = "type"
            case updatedAt = "updatedAt"
        }
    }

    public struct DeleteAssetInput: AWSEncodableShape {
        /// The ID of the Amazon DataZone domain in which the asset is deleted.
        public let domainIdentifier: String
        /// The identifier of the asset that is deleted.
        public let identifier: String

        public init(domainIdentifier: String, identifier: String) {
            self.domainIdentifier = domainIdentifier
            self.identifier = identifier
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.domainIdentifier, key: "domainIdentifier")
            request.encodePath(self.identifier, key: "identifier")
        }

        public func validate(name: String) throws {
            try self.validate(self.domainIdentifier, name: "domainIdentifier", parent: name, pattern: "^dzd[-_][a-zA-Z0-9_-]{1,36}$")
            try self.validate(self.identifier, name: "identifier", parent: name, pattern: "^[a-zA-Z0-9_-]{1,36}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteAssetOutput: AWSDecodableShape {
        public init() {}
    }

    public struct DeleteAssetTypeInput: AWSEncodableShape {
        /// The ID of the Amazon DataZone domain in which the asset type is deleted.
        public let domainIdentifier: String
        /// The identifier of the asset type that is deleted.
        public let identifier: String

        public init(domainIdentifier: String, identifier: String) {
            self.domainIdentifier = domainIdentifier
            self.identifier = identifier
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.domainIdentifier, key: "domainIdentifier")
            request.encodePath(self.identifier, key: "identifier")
        }

        public func validate(name: String) throws {
            try self.validate(self.domainIdentifier, name: "domainIdentifier", parent: name, pattern: "^dzd[-_][a-zA-Z0-9_-]{1,36}$")
            try self.validate(self.identifier, name: "identifier", parent: name, max: 513)
            try self.validate(self.identifier, name: "identifier", parent: name, min: 1)
            try self.validate(self.identifier, name: "identifier", parent: name, pattern: "^(?!\\.)[\\w\\.]*\\w$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteAssetTypeOutput: AWSDecodableShape {
        public init() {}
    }

    public struct DeleteDataSourceInput: AWSEncodableShape {
        /// A unique, case-sensitive identifier that is provided to ensure the idempotency of the request.
        public let clientToken: String?
        /// The ID of the Amazon DataZone domain in which the data source is deleted.
        public let domainIdentifier: String
        /// The identifier of the data source that is deleted.
        public let identifier: String

        public init(clientToken: String? = DeleteDataSourceInput.idempotencyToken(), domainIdentifier: String, identifier: String) {
            self.clientToken = clientToken
            self.domainIdentifier = domainIdentifier
            self.identifier = identifier
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.clientToken, key: "clientToken")
            request.encodePath(self.domainIdentifier, key: "domainIdentifier")
            request.encodePath(self.identifier, key: "identifier")
        }

        public func validate(name: String) throws {
            try self.validate(self.domainIdentifier, name: "domainIdentifier", parent: name, pattern: "^dzd[-_][a-zA-Z0-9_-]{1,36}$")
            try self.validate(self.identifier, name: "identifier", parent: name, pattern: "^[a-zA-Z0-9_-]{1,36}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteDataSourceOutput: AWSDecodableShape {
        /// The asset data forms associated with this data source.
        public let assetFormsOutput: [FormOutput]?
        /// The configuration of the data source that is deleted.
        public let configuration: DataSourceConfigurationOutput?
        /// The timestamp of when this data source was created.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var createdAt: Date?
        /// The description of the data source that is deleted.
        public let description: String?
        /// The ID of the Amazon DataZone domain in which the data source is deleted.
        public let domainId: String
        /// The enable setting of the data source that specifies whether the data source is enabled or disabled.
        public let enableSetting: EnableSetting?
        /// The ID of the environemnt associated with this data source.
        public let environmentId: String
        /// Specifies the error message that is returned if the operation cannot be successfully completed.
        public let errorMessage: DataSourceErrorMessage?
        /// The ID of the data source that is deleted.
        public let id: String
        /// The timestamp of when the data source was last run.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var lastRunAt: Date?
        /// Specifies the error message that is returned if the operation cannot be successfully completed.
        public let lastRunErrorMessage: DataSourceErrorMessage?
        /// The status of the last run of this data source.
        public let lastRunStatus: DataSourceRunStatus?
        /// The name of the data source that is deleted.
        public let name: String
        /// The ID of the project in which this data source exists and from which it's deleted.
        public let projectId: String
        /// Specifies whether the assets that this data source creates in the inventory are to be also automatically published to the catalog.
        public let publishOnImport: Bool?
        /// The schedule of runs for this data source.
        public let schedule: ScheduleConfiguration?
        /// The status of this data source.
        public let status: DataSourceStatus?
        /// The type of this data source.
        public let type: String?
        /// The timestamp of when this data source was updated.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var updatedAt: Date?

        public init(assetFormsOutput: [FormOutput]? = nil, configuration: DataSourceConfigurationOutput? = nil, createdAt: Date? = nil, description: String? = nil, domainId: String, enableSetting: EnableSetting? = nil, environmentId: String, errorMessage: DataSourceErrorMessage? = nil, id: String, lastRunAt: Date? = nil, lastRunErrorMessage: DataSourceErrorMessage? = nil, lastRunStatus: DataSourceRunStatus? = nil, name: String, projectId: String, publishOnImport: Bool? = nil, schedule: ScheduleConfiguration? = nil, status: DataSourceStatus? = nil, type: String? = nil, updatedAt: Date? = nil) {
            self.assetFormsOutput = assetFormsOutput
            self.configuration = configuration
            self.createdAt = createdAt
            self.description = description
            self.domainId = domainId
            self.enableSetting = enableSetting
            self.environmentId = environmentId
            self.errorMessage = errorMessage
            self.id = id
            self.lastRunAt = lastRunAt
            self.lastRunErrorMessage = lastRunErrorMessage
            self.lastRunStatus = lastRunStatus
            self.name = name
            self.projectId = projectId
            self.publishOnImport = publishOnImport
            self.schedule = schedule
            self.status = status
            self.type = type
            self.updatedAt = updatedAt
        }

        private enum CodingKeys: String, CodingKey {
            case assetFormsOutput = "assetFormsOutput"
            case configuration = "configuration"
            case createdAt = "createdAt"
            case description = "description"
            case domainId = "domainId"
            case enableSetting = "enableSetting"
            case environmentId = "environmentId"
            case errorMessage = "errorMessage"
            case id = "id"
            case lastRunAt = "lastRunAt"
            case lastRunErrorMessage = "lastRunErrorMessage"
            case lastRunStatus = "lastRunStatus"
            case name = "name"
            case projectId = "projectId"
            case publishOnImport = "publishOnImport"
            case schedule = "schedule"
            case status = "status"
            case type = "type"
            case updatedAt = "updatedAt"
        }
    }

    public struct DeleteDomainInput: AWSEncodableShape {
        /// A unique, case-sensitive identifier that is provided to ensure the idempotency of the request.
        public let clientToken: String?
        /// The identifier of the Amazon Web Services domain that is to be deleted.
        public let identifier: String
        /// Specifies the optional flag to delete all child entities within the domain.
        public let skipDeletionCheck: Bool?

        public init(clientToken: String? = DeleteDomainInput.idempotencyToken(), identifier: String, skipDeletionCheck: Bool? = nil) {
            self.clientToken = clientToken
            self.identifier = identifier
            self.skipDeletionCheck = skipDeletionCheck
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.clientToken, key: "clientToken")
            request.encodePath(self.identifier, key: "identifier")
            request.encodeQuery(self.skipDeletionCheck, key: "skipDeletionCheck")
        }

        public func validate(name: String) throws {
            try self.validate(self.identifier, name: "identifier", parent: name, pattern: "^dzd[-_][a-zA-Z0-9_-]{1,36}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteDomainOutput: AWSDecodableShape {
        /// The status of the domain.
        public let status: DomainStatus

        public init(status: DomainStatus) {
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case status = "status"
        }
    }

    public struct DeleteEnvironmentBlueprintConfigurationInput: AWSEncodableShape {
        /// The ID of the Amazon DataZone domain in which the blueprint configuration is deleted.
        public let domainIdentifier: String
        /// The ID of the blueprint the configuration of which is deleted.
        public let environmentBlueprintIdentifier: String

        public init(domainIdentifier: String, environmentBlueprintIdentifier: String) {
            self.domainIdentifier = domainIdentifier
            self.environmentBlueprintIdentifier = environmentBlueprintIdentifier
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.domainIdentifier, key: "domainIdentifier")
            request.encodePath(self.environmentBlueprintIdentifier, key: "environmentBlueprintIdentifier")
        }

        public func validate(name: String) throws {
            try self.validate(self.domainIdentifier, name: "domainIdentifier", parent: name, pattern: "^dzd[-_][a-zA-Z0-9_-]{1,36}$")
            try self.validate(self.environmentBlueprintIdentifier, name: "environmentBlueprintIdentifier", parent: name, pattern: "^[a-zA-Z0-9_-]{1,36}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteEnvironmentBlueprintConfigurationOutput: AWSDecodableShape {
        public init() {}
    }

    public struct DeleteEnvironmentInput: AWSEncodableShape {
        /// The ID of the Amazon DataZone domain in which the environment is deleted.
        public let domainIdentifier: String
        /// The identifier of the environment that is to be deleted.
        public let identifier: String

        public init(domainIdentifier: String, identifier: String) {
            self.domainIdentifier = domainIdentifier
            self.identifier = identifier
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.domainIdentifier, key: "domainIdentifier")
            request.encodePath(self.identifier, key: "identifier")
        }

        public func validate(name: String) throws {
            try self.validate(self.domainIdentifier, name: "domainIdentifier", parent: name, pattern: "^dzd[-_][a-zA-Z0-9_-]{1,36}$")
            try self.validate(self.identifier, name: "identifier", parent: name, pattern: "^[a-zA-Z0-9_-]{1,36}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteEnvironmentProfileInput: AWSEncodableShape {
        /// The ID of the Amazon DataZone domain in which the environment profile is deleted.
        public let domainIdentifier: String
        /// The ID of the environment profile that is deleted.
        public let identifier: String

        public init(domainIdentifier: String, identifier: String) {
            self.domainIdentifier = domainIdentifier
            self.identifier = identifier
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.domainIdentifier, key: "domainIdentifier")
            request.encodePath(self.identifier, key: "identifier")
        }

        public func validate(name: String) throws {
            try self.validate(self.domainIdentifier, name: "domainIdentifier", parent: name, pattern: "^dzd[-_][a-zA-Z0-9_-]{1,36}$")
            try self.validate(self.identifier, name: "identifier", parent: name, pattern: "^[a-zA-Z0-9_-]{1,36}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteFormTypeInput: AWSEncodableShape {
        /// The ID of the Amazon DataZone domain in which the metadata form type is deleted.
        public let domainIdentifier: String
        /// The ID of the metadata form type that is deleted.
        public let formTypeIdentifier: String

        public init(domainIdentifier: String, formTypeIdentifier: String) {
            self.domainIdentifier = domainIdentifier
            self.formTypeIdentifier = formTypeIdentifier
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.domainIdentifier, key: "domainIdentifier")
            request.encodePath(self.formTypeIdentifier, key: "formTypeIdentifier")
        }

        public func validate(name: String) throws {
            try self.validate(self.domainIdentifier, name: "domainIdentifier", parent: name, pattern: "^dzd[-_][a-zA-Z0-9_-]{1,36}$")
            try self.validate(self.formTypeIdentifier, name: "formTypeIdentifier", parent: name, max: 385)
            try self.validate(self.formTypeIdentifier, name: "formTypeIdentifier", parent: name, min: 1)
            try self.validate(self.formTypeIdentifier, name: "formTypeIdentifier", parent: name, pattern: "^(?!\\.)[\\w\\.]*\\w$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteFormTypeOutput: AWSDecodableShape {
        public init() {}
    }

    public struct DeleteGlossaryInput: AWSEncodableShape {
        /// The ID of the Amazon DataZone domain in which the business glossary is deleted.
        public let domainIdentifier: String
        /// The ID of the business glossary that is deleted.
        public let identifier: String

        public init(domainIdentifier: String, identifier: String) {
            self.domainIdentifier = domainIdentifier
            self.identifier = identifier
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.domainIdentifier, key: "domainIdentifier")
            request.encodePath(self.identifier, key: "identifier")
        }

        public func validate(name: String) throws {
            try self.validate(self.domainIdentifier, name: "domainIdentifier", parent: name, pattern: "^dzd[-_][a-zA-Z0-9_-]{1,36}$")
            try self.validate(self.identifier, name: "identifier", parent: name, pattern: "^[a-zA-Z0-9_-]{1,36}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteGlossaryOutput: AWSDecodableShape {
        public init() {}
    }

    public struct DeleteGlossaryTermInput: AWSEncodableShape {
        /// The ID of the Amazon DataZone domain in which the business glossary term is deleted.
        public let domainIdentifier: String
        /// The ID of the business glossary term that is deleted.
        public let identifier: String

        public init(domainIdentifier: String, identifier: String) {
            self.domainIdentifier = domainIdentifier
            self.identifier = identifier
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.domainIdentifier, key: "domainIdentifier")
            request.encodePath(self.identifier, key: "identifier")
        }

        public func validate(name: String) throws {
            try self.validate(self.domainIdentifier, name: "domainIdentifier", parent: name, pattern: "^dzd[-_][a-zA-Z0-9_-]{1,36}$")
            try self.validate(self.identifier, name: "identifier", parent: name, pattern: "^[a-zA-Z0-9_-]{1,36}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteGlossaryTermOutput: AWSDecodableShape {
        public init() {}
    }

    public struct DeleteListingInput: AWSEncodableShape {
        /// The ID of the Amazon DataZone domain.
        public let domainIdentifier: String
        /// The ID of the listing to be deleted.
        public let identifier: String

        public init(domainIdentifier: String, identifier: String) {
            self.domainIdentifier = domainIdentifier
            self.identifier = identifier
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.domainIdentifier, key: "domainIdentifier")
            request.encodePath(self.identifier, key: "identifier")
        }

        public func validate(name: String) throws {
            try self.validate(self.domainIdentifier, name: "domainIdentifier", parent: name, pattern: "^dzd[-_][a-zA-Z0-9_-]{1,36}$")
            try self.validate(self.identifier, name: "identifier", parent: name, pattern: "^[a-zA-Z0-9_-]{1,36}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteListingOutput: AWSDecodableShape {
        public init() {}
    }

    public struct DeleteProjectInput: AWSEncodableShape {
        /// The ID of the Amazon DataZone domain in which the project is deleted.
        public let domainIdentifier: String
        /// The identifier of the project that is to be deleted.
        public let identifier: String
        /// Specifies the optional flag to delete all child entities within the project.
        public let skipDeletionCheck: Bool?

        public init(domainIdentifier: String, identifier: String, skipDeletionCheck: Bool? = nil) {
            self.domainIdentifier = domainIdentifier
            self.identifier = identifier
            self.skipDeletionCheck = skipDeletionCheck
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.domainIdentifier, key: "domainIdentifier")
            request.encodePath(self.identifier, key: "identifier")
            request.encodeQuery(self.skipDeletionCheck, key: "skipDeletionCheck")
        }

        public func validate(name: String) throws {
            try self.validate(self.domainIdentifier, name: "domainIdentifier", parent: name, pattern: "^dzd[-_][a-zA-Z0-9_-]{1,36}$")
            try self.validate(self.identifier, name: "identifier", parent: name, pattern: "^[a-zA-Z0-9_-]{1,36}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteProjectMembershipInput: AWSEncodableShape {
        /// The ID of the Amazon DataZone domain where project membership is deleted.
        public let domainIdentifier: String
        /// The project member whose project membership is deleted.
        public let member: Member
        /// The ID of the Amazon DataZone project the membership to which is deleted.
        public let projectIdentifier: String

        public init(domainIdentifier: String, member: Member, projectIdentifier: String) {
            self.domainIdentifier = domainIdentifier
            self.member = member
            self.projectIdentifier = projectIdentifier
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.domainIdentifier, key: "domainIdentifier")
            try container.encode(self.member, forKey: .member)
            request.encodePath(self.projectIdentifier, key: "projectIdentifier")
        }

        public func validate(name: String) throws {
            try self.validate(self.domainIdentifier, name: "domainIdentifier", parent: name, pattern: "^dzd[-_][a-zA-Z0-9_-]{1,36}$")
            try self.validate(self.projectIdentifier, name: "projectIdentifier", parent: name, pattern: "^[a-zA-Z0-9_-]{1,36}$")
        }

        private enum CodingKeys: String, CodingKey {
            case member = "member"
        }
    }

    public struct DeleteProjectMembershipOutput: AWSDecodableShape {
        public init() {}
    }

    public struct DeleteProjectOutput: AWSDecodableShape {
        public init() {}
    }

    public struct DeleteSubscriptionGrantInput: AWSEncodableShape {
        /// The ID of the Amazon DataZone domain where the subscription grant is deleted.
        public let domainIdentifier: String
        /// The ID of the subscription grant that is deleted.
        public let identifier: String

        public init(domainIdentifier: String, identifier: String) {
            self.domainIdentifier = domainIdentifier
            self.identifier = identifier
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.domainIdentifier, key: "domainIdentifier")
            request.encodePath(self.identifier, key: "identifier")
        }

        public func validate(name: String) throws {
            try self.validate(self.domainIdentifier, name: "domainIdentifier", parent: name, pattern: "^dzd[-_][a-zA-Z0-9_-]{1,36}$")
            try self.validate(self.identifier, name: "identifier", parent: name, pattern: "^[a-zA-Z0-9_-]{1,36}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteSubscriptionGrantOutput: AWSDecodableShape {
        /// The assets for which the subsctiption grant that is deleted gave access.
        public let assets: [SubscribedAsset]?
        /// The timestamp of when the subscription grant that is deleted was created.
        public let createdAt: Date
        /// The Amazon DataZone user who created the subscription grant that is deleted.
        public let createdBy: String
        /// The ID of the Amazon DataZone domain in which the subscription grant is deleted.
        public let domainId: String
        /// The entity to which the subscription is deleted.
        public let grantedEntity: GrantedEntity
        /// The ID of the subscription grant that is deleted.
        public let id: String
        /// The status of the subscription grant that is deleted.
        public let status: SubscriptionGrantOverallStatus
        /// The identifier of the subsctiption whose subscription grant is to be deleted.
        public let subscriptionId: String?
        /// The ID of the subscription target associated with the subscription grant that is deleted.
        public let subscriptionTargetId: String
        /// The timestamp of when the subscription grant that is deleted was updated.
        public let updatedAt: Date
        /// The Amazon DataZone user who updated the subscription grant that is deleted.
        public let updatedBy: String?

        public init(assets: [SubscribedAsset]? = nil, createdAt: Date, createdBy: String, domainId: String, grantedEntity: GrantedEntity, id: String, status: SubscriptionGrantOverallStatus, subscriptionId: String? = nil, subscriptionTargetId: String, updatedAt: Date, updatedBy: String? = nil) {
            self.assets = assets
            self.createdAt = createdAt
            self.createdBy = createdBy
            self.domainId = domainId
            self.grantedEntity = grantedEntity
            self.id = id
            self.status = status
            self.subscriptionId = subscriptionId
            self.subscriptionTargetId = subscriptionTargetId
            self.updatedAt = updatedAt
            self.updatedBy = updatedBy
        }

        private enum CodingKeys: String, CodingKey {
            case assets = "assets"
            case createdAt = "createdAt"
            case createdBy = "createdBy"
            case domainId = "domainId"
            case grantedEntity = "grantedEntity"
            case id = "id"
            case status = "status"
            case subscriptionId = "subscriptionId"
            case subscriptionTargetId = "subscriptionTargetId"
            case updatedAt = "updatedAt"
            case updatedBy = "updatedBy"
        }
    }

    public struct DeleteSubscriptionRequestInput: AWSEncodableShape {
        /// The ID of the Amazon DataZone domain in which the subscription request is deleted.
        public let domainIdentifier: String
        /// The ID of the subscription request that is deleted.
        public let identifier: String

        public init(domainIdentifier: String, identifier: String) {
            self.domainIdentifier = domainIdentifier
            self.identifier = identifier
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.domainIdentifier, key: "domainIdentifier")
            request.encodePath(self.identifier, key: "identifier")
        }

        public func validate(name: String) throws {
            try self.validate(self.domainIdentifier, name: "domainIdentifier", parent: name, pattern: "^dzd[-_][a-zA-Z0-9_-]{1,36}$")
            try self.validate(self.identifier, name: "identifier", parent: name, pattern: "^[a-zA-Z0-9_-]{1,36}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteSubscriptionTargetInput: AWSEncodableShape {
        /// The ID of the Amazon DataZone domain in which the subscription target is deleted.
        public let domainIdentifier: String
        /// The ID of the Amazon DataZone environment in which the subscription target is deleted.
        public let environmentIdentifier: String
        /// The ID of the subscription target that is deleted.
        public let identifier: String

        public init(domainIdentifier: String, environmentIdentifier: String, identifier: String) {
            self.domainIdentifier = domainIdentifier
            self.environmentIdentifier = environmentIdentifier
            self.identifier = identifier
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.domainIdentifier, key: "domainIdentifier")
            request.encodePath(self.environmentIdentifier, key: "environmentIdentifier")
            request.encodePath(self.identifier, key: "identifier")
        }

        public func validate(name: String) throws {
            try self.validate(self.domainIdentifier, name: "domainIdentifier", parent: name, pattern: "^dzd[-_][a-zA-Z0-9_-]{1,36}$")
            try self.validate(self.environmentIdentifier, name: "environmentIdentifier", parent: name, pattern: "^[a-zA-Z0-9_-]{1,36}$")
            try self.validate(self.identifier, name: "identifier", parent: name, pattern: "^[a-zA-Z0-9_-]{1,36}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteTimeSeriesDataPointsInput: AWSEncodableShape {
        /// A unique, case-sensitive identifier to ensure idempotency of the request. This field is automatically populated if not provided.
        public let clientToken: String?
        /// The ID of the Amazon DataZone domain that houses the asset for which you want to delete a time series form.
        public let domainIdentifier: String
        /// The ID of the asset for which you want to delete a time series form.
        public let entityIdentifier: String
        /// The type of the asset for which you want to delete a time series form.
        public let entityType: TimeSeriesEntityType
        /// The name of the time series form that you want to delete.
        public let formName: String

        public init(clientToken: String? = DeleteTimeSeriesDataPointsInput.idempotencyToken(), domainIdentifier: String, entityIdentifier: String, entityType: TimeSeriesEntityType, formName: String) {
            self.clientToken = clientToken
            self.domainIdentifier = domainIdentifier
            self.entityIdentifier = entityIdentifier
            self.entityType = entityType
            self.formName = formName
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.clientToken, key: "clientToken")
            request.encodePath(self.domainIdentifier, key: "domainIdentifier")
            request.encodePath(self.entityIdentifier, key: "entityIdentifier")
            request.encodePath(self.entityType, key: "entityType")
            request.encodeQuery(self.formName, key: "formName")
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 128)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "^[\\x21-\\x7E]+$")
            try self.validate(self.domainIdentifier, name: "domainIdentifier", parent: name, pattern: "^dzd[-_][a-zA-Z0-9_-]{1,36}$")
            try self.validate(self.entityIdentifier, name: "entityIdentifier", parent: name, pattern: "^[a-zA-Z0-9_-]{1,36}$")
            try self.validate(self.formName, name: "formName", parent: name, max: 128)
            try self.validate(self.formName, name: "formName", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteTimeSeriesDataPointsOutput: AWSDecodableShape {
        public init() {}
    }

    public struct Deployment: AWSDecodableShape {
        /// The identifier of the last deployment of the environment.
        public let deploymentId: String?
        /// The status of the last deployment of the environment.
        public let deploymentStatus: DeploymentStatus?
        /// The type of the last deployment of the environment.
        public let deploymentType: DeploymentType?
        /// The failure reason of the last deployment of the environment.
        public let failureReason: EnvironmentError?
        /// Specifies whether the last deployment of the environment is complete.
        public let isDeploymentComplete: Bool?
        /// The messages of the last deployment of the environment.
        public let messages: [String]?

        public init(deploymentId: String? = nil, deploymentStatus: DeploymentStatus? = nil, deploymentType: DeploymentType? = nil, failureReason: EnvironmentError? = nil, isDeploymentComplete: Bool? = nil, messages: [String]? = nil) {
            self.deploymentId = deploymentId
            self.deploymentStatus = deploymentStatus
            self.deploymentType = deploymentType
            self.failureReason = failureReason
            self.isDeploymentComplete = isDeploymentComplete
            self.messages = messages
        }

        private enum CodingKeys: String, CodingKey {
            case deploymentId = "deploymentId"
            case deploymentStatus = "deploymentStatus"
            case deploymentType = "deploymentType"
            case failureReason = "failureReason"
            case isDeploymentComplete = "isDeploymentComplete"
            case messages = "messages"
        }
    }

    public struct DeploymentProperties: AWSDecodableShape {
        /// The end timeout of the environment blueprint deployment.
        public let endTimeoutMinutes: Int?
        /// The start timeout of the environment blueprint deployment.
        public let startTimeoutMinutes: Int?

        public init(endTimeoutMinutes: Int? = nil, startTimeoutMinutes: Int? = nil) {
            self.endTimeoutMinutes = endTimeoutMinutes
            self.startTimeoutMinutes = startTimeoutMinutes
        }

        private enum CodingKeys: String, CodingKey {
            case endTimeoutMinutes = "endTimeoutMinutes"
            case startTimeoutMinutes = "startTimeoutMinutes"
        }
    }

    public struct DetailedGlossaryTerm: AWSDecodableShape {
        /// The name of a glossary term attached to the inventory asset.
        public let name: String?
        /// The shoft description of a glossary term attached to the inventory asset.
        public let shortDescription: String?

        public init(name: String? = nil, shortDescription: String? = nil) {
            self.name = name
            self.shortDescription = shortDescription
        }

        private enum CodingKeys: String, CodingKey {
            case name = "name"
            case shortDescription = "shortDescription"
        }
    }

    public struct DomainSummary: AWSDecodableShape {
        /// The ARN of the Amazon DataZone domain.
        public let arn: String
        /// A timestamp of when a Amazon DataZone domain was created.
        public let createdAt: Date
        /// A description of an Amazon DataZone domain.
        public let description: String?
        /// The ID of the Amazon DataZone domain.
        public let id: String
        /// A timestamp of when a Amazon DataZone domain was last updated.
        public let lastUpdatedAt: Date?
        /// The identifier of the Amazon Web Services account that manages the domain.
        public let managedAccountId: String
        /// A name of an Amazon DataZone domain.
        public let name: String
        /// The data portal URL for the Amazon DataZone domain.
        public let portalUrl: String?
        /// The status of the Amazon DataZone domain.
        public let status: DomainStatus

        public init(arn: String, createdAt: Date, description: String? = nil, id: String, lastUpdatedAt: Date? = nil, managedAccountId: String, name: String, portalUrl: String? = nil, status: DomainStatus) {
            self.arn = arn
            self.createdAt = createdAt
            self.description = description
            self.id = id
            self.lastUpdatedAt = lastUpdatedAt
            self.managedAccountId = managedAccountId
            self.name = name
            self.portalUrl = portalUrl
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case createdAt = "createdAt"
            case description = "description"
            case id = "id"
            case lastUpdatedAt = "lastUpdatedAt"
            case managedAccountId = "managedAccountId"
            case name = "name"
            case portalUrl = "portalUrl"
            case status = "status"
        }
    }

    public struct EnvironmentBlueprintConfigurationItem: AWSDecodableShape {
        /// The timestamp of when an environment blueprint was created.
        public let createdAt: Date?
        /// The identifier of the Amazon DataZone domain in which an environment blueprint exists.
        public let domainId: String
        /// The enabled Amazon Web Services Regions specified in a blueprint configuration.
        public let enabledRegions: [String]?
        /// The identifier of the environment blueprint.
        public let environmentBlueprintId: String
        /// The ARN of the manage access role specified in the environment blueprint configuration.
        public let manageAccessRoleArn: String?
        /// The ARN of the provisioning role specified in the environment blueprint configuration.
        public let provisioningRoleArn: String?
        /// The regional parameters of the environment blueprint.
        public let regionalParameters: [String: [String: String]]?
        /// The timestamp of when the environment blueprint was updated.
        public let updatedAt: Date?

        public init(createdAt: Date? = nil, domainId: String, enabledRegions: [String]? = nil, environmentBlueprintId: String, manageAccessRoleArn: String? = nil, provisioningRoleArn: String? = nil, regionalParameters: [String: [String: String]]? = nil, updatedAt: Date? = nil) {
            self.createdAt = createdAt
            self.domainId = domainId
            self.enabledRegions = enabledRegions
            self.environmentBlueprintId = environmentBlueprintId
            self.manageAccessRoleArn = manageAccessRoleArn
            self.provisioningRoleArn = provisioningRoleArn
            self.regionalParameters = regionalParameters
            self.updatedAt = updatedAt
        }

        private enum CodingKeys: String, CodingKey {
            case createdAt = "createdAt"
            case domainId = "domainId"
            case enabledRegions = "enabledRegions"
            case environmentBlueprintId = "environmentBlueprintId"
            case manageAccessRoleArn = "manageAccessRoleArn"
            case provisioningRoleArn = "provisioningRoleArn"
            case regionalParameters = "regionalParameters"
            case updatedAt = "updatedAt"
        }
    }

    public struct EnvironmentBlueprintSummary: AWSDecodableShape {
        /// The timestamp of when an environment blueprint was created.
        public let createdAt: Date?
        /// The description of a blueprint.
        public let description: String?
        /// The identifier of the blueprint.
        public let id: String
        /// The name of the blueprint.
        public let name: String
        /// The provider of the blueprint.
        public let provider: String
        /// The provisioning properties of the blueprint.
        public let provisioningProperties: ProvisioningProperties
        /// The timestamp of when the blueprint was enabled.
        public let updatedAt: Date?

        public init(createdAt: Date? = nil, description: String? = nil, id: String, name: String, provider: String, provisioningProperties: ProvisioningProperties, updatedAt: Date? = nil) {
            self.createdAt = createdAt
            self.description = description
            self.id = id
            self.name = name
            self.provider = provider
            self.provisioningProperties = provisioningProperties
            self.updatedAt = updatedAt
        }

        private enum CodingKeys: String, CodingKey {
            case createdAt = "createdAt"
            case description = "description"
            case id = "id"
            case name = "name"
            case provider = "provider"
            case provisioningProperties = "provisioningProperties"
            case updatedAt = "updatedAt"
        }
    }

    public struct EnvironmentError: AWSDecodableShape {
        /// The error code for the failure reason for the environment deployment.
        public let code: String?
        /// The error message for the failure reason for the environment deployment.
        public let message: String

        public init(code: String? = nil, message: String) {
            self.code = code
            self.message = message
        }

        private enum CodingKeys: String, CodingKey {
            case code = "code"
            case message = "message"
        }
    }

    public struct EnvironmentParameter: AWSEncodableShape {
        /// The name of an environment profile parameter.
        public let name: String?
        /// The value of an environment profile parameter.
        public let value: String?

        public init(name: String? = nil, value: String? = nil) {
            self.name = name
            self.value = value
        }

        private enum CodingKeys: String, CodingKey {
            case name = "name"
            case value = "value"
        }
    }

    public struct EnvironmentProfileSummary: AWSDecodableShape {
        /// The identifier of an Amazon Web Services account in which an environment profile exists.
        public let awsAccountId: String?
        /// The Amazon Web Services Region in which an environment profile exists.
        public let awsAccountRegion: String?
        /// The timestamp of when an environment profile was created.
        public let createdAt: Date?
        /// The Amazon DataZone user who created the environment profile.
        public let createdBy: String
        /// The description of the environment profile.
        public let description: String?
        /// The identifier of the Amazon DataZone domain in which the environment profile exists.
        public let domainId: String
        /// The identifier of a blueprint with which an environment profile is created.
        public let environmentBlueprintId: String
        /// The identifier of the environment profile.
        public let id: String
        /// The name of the environment profile.
        public let name: String
        /// The identifier of a project in which an environment profile exists.
        public let projectId: String?
        /// The timestamp of when the environment profile was updated.
        public let updatedAt: Date?

        public init(awsAccountId: String? = nil, awsAccountRegion: String? = nil, createdAt: Date? = nil, createdBy: String, description: String? = nil, domainId: String, environmentBlueprintId: String, id: String, name: String, projectId: String? = nil, updatedAt: Date? = nil) {
            self.awsAccountId = awsAccountId
            self.awsAccountRegion = awsAccountRegion
            self.createdAt = createdAt
            self.createdBy = createdBy
            self.description = description
            self.domainId = domainId
            self.environmentBlueprintId = environmentBlueprintId
            self.id = id
            self.name = name
            self.projectId = projectId
            self.updatedAt = updatedAt
        }

        private enum CodingKeys: String, CodingKey {
            case awsAccountId = "awsAccountId"
            case awsAccountRegion = "awsAccountRegion"
            case createdAt = "createdAt"
            case createdBy = "createdBy"
            case description = "description"
            case domainId = "domainId"
            case environmentBlueprintId = "environmentBlueprintId"
            case id = "id"
            case name = "name"
            case projectId = "projectId"
            case updatedAt = "updatedAt"
        }
    }

    public struct EnvironmentSummary: AWSDecodableShape {
        /// The identifier of the Amazon Web Services account in which an environment exists.
        public let awsAccountId: String?
        /// The Amazon Web Services Region in which an environment exists.
        public let awsAccountRegion: String?
        /// The timestamp of when the environment was created.
        public let createdAt: Date?
        /// The Amazon DataZone user who created the environment.
        public let createdBy: String
        /// The description of the environment.
        public let description: String?
        /// The identifier of the Amazon DataZone domain in which the environment exists.
        public let domainId: String
        /// The identifier of the environment profile with which the environment was created.
        public let environmentProfileId: String
        /// The identifier of the environment.
        public let id: String?
        /// The name of the environment.
        public let name: String
        /// The identifier of the project in which the environment exists.
        public let projectId: String
        /// The provider of the environment.
        public let provider: String
        /// The status of the environment.
        public let status: EnvironmentStatus?
        /// The timestamp of when the environment was updated.
        public let updatedAt: Date?

        public init(awsAccountId: String? = nil, awsAccountRegion: String? = nil, createdAt: Date? = nil, createdBy: String, description: String? = nil, domainId: String, environmentProfileId: String, id: String? = nil, name: String, projectId: String, provider: String, status: EnvironmentStatus? = nil, updatedAt: Date? = nil) {
            self.awsAccountId = awsAccountId
            self.awsAccountRegion = awsAccountRegion
            self.createdAt = createdAt
            self.createdBy = createdBy
            self.description = description
            self.domainId = domainId
            self.environmentProfileId = environmentProfileId
            self.id = id
            self.name = name
            self.projectId = projectId
            self.provider = provider
            self.status = status
            self.updatedAt = updatedAt
        }

        private enum CodingKeys: String, CodingKey {
            case awsAccountId = "awsAccountId"
            case awsAccountRegion = "awsAccountRegion"
            case createdAt = "createdAt"
            case createdBy = "createdBy"
            case description = "description"
            case domainId = "domainId"
            case environmentProfileId = "environmentProfileId"
            case id = "id"
            case name = "name"
            case projectId = "projectId"
            case provider = "provider"
            case status = "status"
            case updatedAt = "updatedAt"
        }
    }

    public struct FailureCause: AWSEncodableShape & AWSDecodableShape {
        /// The description of the error message.
        public let message: String?

        public init(message: String? = nil) {
            self.message = message
        }

        private enum CodingKeys: String, CodingKey {
            case message = "message"
        }
    }

    public struct Filter: AWSEncodableShape {
        /// A search filter attribute in Amazon DataZone.
        public let attribute: String
        /// A search filter value in Amazon DataZone.
        public let value: String

        public init(attribute: String, value: String) {
            self.attribute = attribute
            self.value = value
        }

        public func validate(name: String) throws {
            try self.validate(self.attribute, name: "attribute", parent: name, max: 128)
            try self.validate(self.attribute, name: "attribute", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case attribute = "attribute"
            case value = "value"
        }
    }

    public struct FilterExpression: AWSEncodableShape & AWSDecodableShape {
        /// The search filter expression.
        public let expression: String
        /// The search filter explresison type.
        public let type: FilterExpressionType

        public init(expression: String, type: FilterExpressionType) {
            self.expression = expression
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case expression = "expression"
            case type = "type"
        }
    }

    public struct FormEntryInput: AWSEncodableShape {
        /// Specifies whether a form entry is required.
        public let required: Bool?
        /// The type ID of the form entry.
        public let typeIdentifier: String
        /// The type revision of the form entry.
        public let typeRevision: String

        public init(required: Bool? = nil, typeIdentifier: String, typeRevision: String) {
            self.required = required
            self.typeIdentifier = typeIdentifier
            self.typeRevision = typeRevision
        }

        public func validate(name: String) throws {
            try self.validate(self.typeIdentifier, name: "typeIdentifier", parent: name, max: 385)
            try self.validate(self.typeIdentifier, name: "typeIdentifier", parent: name, min: 1)
            try self.validate(self.typeIdentifier, name: "typeIdentifier", parent: name, pattern: "^(?!\\.)[\\w\\.]*\\w$")
            try self.validate(self.typeRevision, name: "typeRevision", parent: name, max: 64)
            try self.validate(self.typeRevision, name: "typeRevision", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case required = "required"
            case typeIdentifier = "typeIdentifier"
            case typeRevision = "typeRevision"
        }
    }

    public struct FormEntryOutput: AWSDecodableShape {
        /// Specifies whether a form entry is required.
        public let required: Bool?
        /// The name of the type of the form entry.
        public let typeName: String
        /// The type revision of the form entry.
        public let typeRevision: String

        public init(required: Bool? = nil, typeName: String, typeRevision: String) {
            self.required = required
            self.typeName = typeName
            self.typeRevision = typeRevision
        }

        private enum CodingKeys: String, CodingKey {
            case required = "required"
            case typeName = "typeName"
            case typeRevision = "typeRevision"
        }
    }

    public struct FormInput: AWSEncodableShape {
        /// The content of the metadata form.
        public let content: String?
        /// The name of the metadata form.
        public let formName: String
        /// The ID of the metadata form type.
        public let typeIdentifier: String?
        /// The revision of the metadata form type.
        public let typeRevision: String?

        public init(content: String? = nil, formName: String, typeIdentifier: String? = nil, typeRevision: String? = nil) {
            self.content = content
            self.formName = formName
            self.typeIdentifier = typeIdentifier
            self.typeRevision = typeRevision
        }

        public func validate(name: String) throws {
            try self.validate(self.formName, name: "formName", parent: name, max: 128)
            try self.validate(self.formName, name: "formName", parent: name, min: 1)
            try self.validate(self.formName, name: "formName", parent: name, pattern: "^(?![0-9_])\\w+$|^_\\w*[a-zA-Z0-9]\\w*$")
            try self.validate(self.typeIdentifier, name: "typeIdentifier", parent: name, max: 385)
            try self.validate(self.typeIdentifier, name: "typeIdentifier", parent: name, min: 1)
            try self.validate(self.typeIdentifier, name: "typeIdentifier", parent: name, pattern: "^(?!\\.)[\\w\\.]*\\w$")
            try self.validate(self.typeRevision, name: "typeRevision", parent: name, max: 64)
            try self.validate(self.typeRevision, name: "typeRevision", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case content = "content"
            case formName = "formName"
            case typeIdentifier = "typeIdentifier"
            case typeRevision = "typeRevision"
        }
    }

    public struct FormOutput: AWSDecodableShape {
        /// The content of the metadata form.
        public let content: String?
        /// The name of the metadata form.
        public let formName: String
        /// The name of the metadata form type.
        public let typeName: String?
        /// The revision of the metadata form type.
        public let typeRevision: String?

        public init(content: String? = nil, formName: String, typeName: String? = nil, typeRevision: String? = nil) {
            self.content = content
            self.formName = formName
            self.typeName = typeName
            self.typeRevision = typeRevision
        }

        private enum CodingKeys: String, CodingKey {
            case content = "content"
            case formName = "formName"
            case typeName = "typeName"
            case typeRevision = "typeRevision"
        }
    }

    public struct FormTypeData: AWSDecodableShape {
        /// The timestamp of when the metadata form type was created.
        public let createdAt: Date?
        /// The Amazon DataZone user who created teh metadata form type.
        public let createdBy: String?
        /// The description of the metadata form type.
        public let description: String?
        /// The identifier of the Amazon DataZone domain in which the form type exists.
        public let domainId: String
        /// The imports specified in the form type.
        public let imports: [Import]?
        /// The model of the form type.
        public let model: Model?
        /// The name of the form type.
        public let name: String
        /// The identifier of the Amazon DataZone domain in which the form type was originally created.
        public let originDomainId: String?
        /// The identifier of the project in which the form type was originally created.
        public let originProjectId: String?
        /// The identifier of the project that owns the form type.
        public let owningProjectId: String?
        /// The revision of the form type.
        public let revision: String
        /// The status of the form type.
        public let status: FormTypeStatus?

        public init(createdAt: Date? = nil, createdBy: String? = nil, description: String? = nil, domainId: String, imports: [Import]? = nil, model: Model? = nil, name: String, originDomainId: String? = nil, originProjectId: String? = nil, owningProjectId: String? = nil, revision: String, status: FormTypeStatus? = nil) {
            self.createdAt = createdAt
            self.createdBy = createdBy
            self.description = description
            self.domainId = domainId
            self.imports = imports
            self.model = model
            self.name = name
            self.originDomainId = originDomainId
            self.originProjectId = originProjectId
            self.owningProjectId = owningProjectId
            self.revision = revision
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case createdAt = "createdAt"
            case createdBy = "createdBy"
            case description = "description"
            case domainId = "domainId"
            case imports = "imports"
            case model = "model"
            case name = "name"
            case originDomainId = "originDomainId"
            case originProjectId = "originProjectId"
            case owningProjectId = "owningProjectId"
            case revision = "revision"
            case status = "status"
        }
    }

    public struct GetAssetInput: AWSEncodableShape {
        /// The ID of the Amazon DataZone domain to which the asset belongs.
        public let domainIdentifier: String
        /// The ID of the Amazon DataZone asset.
        public let identifier: String
        /// The revision of the Amazon DataZone asset.
        public let revision: String?

        public init(domainIdentifier: String, identifier: String, revision: String? = nil) {
            self.domainIdentifier = domainIdentifier
            self.identifier = identifier
            self.revision = revision
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.domainIdentifier, key: "domainIdentifier")
            request.encodePath(self.identifier, key: "identifier")
            request.encodeQuery(self.revision, key: "revision")
        }

        public func validate(name: String) throws {
            try self.validate(self.domainIdentifier, name: "domainIdentifier", parent: name, pattern: "^dzd[-_][a-zA-Z0-9_-]{1,36}$")
            try self.validate(self.identifier, name: "identifier", parent: name, pattern: "^[a-zA-Z0-9_-]{1,36}$")
            try self.validate(self.revision, name: "revision", parent: name, max: 64)
            try self.validate(self.revision, name: "revision", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetAssetOutput: AWSDecodableShape {
        /// The timestamp of when the asset was created.
        public let createdAt: Date?
        /// The Amazon DataZone user who created the asset.
        public let createdBy: String?
        /// The description of the Amazon DataZone asset.
        public let description: String?
        /// The ID of the Amazon DataZone domain to which the asset belongs.
        public let domainId: String
        /// The external ID of the asset.
        public let externalIdentifier: String?
        /// The timestamp of when the first revision of the asset was created.
        public let firstRevisionCreatedAt: Date?
        /// The Amazon DataZone user who created the first revision of the asset.
        public let firstRevisionCreatedBy: String?
        /// The metadata forms attached to the asset.
        public let formsOutput: [FormOutput]
        /// The business glossary terms attached to the asset.
        public let glossaryTerms: [String]?
        /// The ID of the asset.
        public let id: String
        /// The latest data point that was imported into the time series form for the asset.
        public let latestTimeSeriesDataPointFormsOutput: [TimeSeriesDataPointSummaryFormOutput]?
        /// The listing of the asset.
        public let listing: AssetListingDetails?
        /// The name of the asset.
        public let name: String
        /// The ID of the project that owns the asset.
        public let owningProjectId: String
        /// The read-only metadata forms attached to the asset.
        public let readOnlyFormsOutput: [FormOutput]?
        /// The revision of the asset.
        public let revision: String
        /// The ID of the asset type.
        public let typeIdentifier: String
        /// The revision of the asset type.
        public let typeRevision: String

        public init(createdAt: Date? = nil, createdBy: String? = nil, description: String? = nil, domainId: String, externalIdentifier: String? = nil, firstRevisionCreatedAt: Date? = nil, firstRevisionCreatedBy: String? = nil, formsOutput: [FormOutput], glossaryTerms: [String]? = nil, id: String, latestTimeSeriesDataPointFormsOutput: [TimeSeriesDataPointSummaryFormOutput]? = nil, listing: AssetListingDetails? = nil, name: String, owningProjectId: String, readOnlyFormsOutput: [FormOutput]? = nil, revision: String, typeIdentifier: String, typeRevision: String) {
            self.createdAt = createdAt
            self.createdBy = createdBy
            self.description = description
            self.domainId = domainId
            self.externalIdentifier = externalIdentifier
            self.firstRevisionCreatedAt = firstRevisionCreatedAt
            self.firstRevisionCreatedBy = firstRevisionCreatedBy
            self.formsOutput = formsOutput
            self.glossaryTerms = glossaryTerms
            self.id = id
            self.latestTimeSeriesDataPointFormsOutput = latestTimeSeriesDataPointFormsOutput
            self.listing = listing
            self.name = name
            self.owningProjectId = owningProjectId
            self.readOnlyFormsOutput = readOnlyFormsOutput
            self.revision = revision
            self.typeIdentifier = typeIdentifier
            self.typeRevision = typeRevision
        }

        private enum CodingKeys: String, CodingKey {
            case createdAt = "createdAt"
            case createdBy = "createdBy"
            case description = "description"
            case domainId = "domainId"
            case externalIdentifier = "externalIdentifier"
            case firstRevisionCreatedAt = "firstRevisionCreatedAt"
            case firstRevisionCreatedBy = "firstRevisionCreatedBy"
            case formsOutput = "formsOutput"
            case glossaryTerms = "glossaryTerms"
            case id = "id"
            case latestTimeSeriesDataPointFormsOutput = "latestTimeSeriesDataPointFormsOutput"
            case listing = "listing"
            case name = "name"
            case owningProjectId = "owningProjectId"
            case readOnlyFormsOutput = "readOnlyFormsOutput"
            case revision = "revision"
            case typeIdentifier = "typeIdentifier"
            case typeRevision = "typeRevision"
        }
    }

    public struct GetAssetTypeInput: AWSEncodableShape {
        /// The ID of the Amazon DataZone domain in which the asset type exists.
        public let domainIdentifier: String
        /// The ID of the asset type.
        public let identifier: String
        /// The revision of the asset type.
        public let revision: String?

        public init(domainIdentifier: String, identifier: String, revision: String? = nil) {
            self.domainIdentifier = domainIdentifier
            self.identifier = identifier
            self.revision = revision
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.domainIdentifier, key: "domainIdentifier")
            request.encodePath(self.identifier, key: "identifier")
            request.encodeQuery(self.revision, key: "revision")
        }

        public func validate(name: String) throws {
            try self.validate(self.domainIdentifier, name: "domainIdentifier", parent: name, pattern: "^dzd[-_][a-zA-Z0-9_-]{1,36}$")
            try self.validate(self.identifier, name: "identifier", parent: name, max: 513)
            try self.validate(self.identifier, name: "identifier", parent: name, min: 1)
            try self.validate(self.identifier, name: "identifier", parent: name, pattern: "^(?!\\.)[\\w\\.]*\\w$")
            try self.validate(self.revision, name: "revision", parent: name, max: 64)
            try self.validate(self.revision, name: "revision", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetAssetTypeOutput: AWSDecodableShape {
        /// The timestamp of when the asset type was created.
        public let createdAt: Date?
        /// The Amazon DataZone user who created the asset type.
        public let createdBy: String?
        /// The description of the asset type.
        public let description: String?
        /// The ID of the Amazon DataZone domain in which the asset type exists.
        public let domainId: String
        /// The metadata forms attached to the asset type.
        public let formsOutput: [String: FormEntryOutput]
        /// The name of the asset type.
        public let name: String
        /// The ID of the Amazon DataZone domain in which the asset type was originally created.
        public let originDomainId: String?
        /// The ID of the Amazon DataZone project in which the asset type was originally created.
        public let originProjectId: String?
        /// The ID of the Amazon DataZone project that owns the asset type.
        public let owningProjectId: String
        /// The revision of the asset type.
        public let revision: String
        /// The timestamp of when the asset type was updated.
        public let updatedAt: Date?
        /// The Amazon DataZone user that updated the asset type.
        public let updatedBy: String?

        public init(createdAt: Date? = nil, createdBy: String? = nil, description: String? = nil, domainId: String, formsOutput: [String: FormEntryOutput], name: String, originDomainId: String? = nil, originProjectId: String? = nil, owningProjectId: String, revision: String, updatedAt: Date? = nil, updatedBy: String? = nil) {
            self.createdAt = createdAt
            self.createdBy = createdBy
            self.description = description
            self.domainId = domainId
            self.formsOutput = formsOutput
            self.name = name
            self.originDomainId = originDomainId
            self.originProjectId = originProjectId
            self.owningProjectId = owningProjectId
            self.revision = revision
            self.updatedAt = updatedAt
            self.updatedBy = updatedBy
        }

        private enum CodingKeys: String, CodingKey {
            case createdAt = "createdAt"
            case createdBy = "createdBy"
            case description = "description"
            case domainId = "domainId"
            case formsOutput = "formsOutput"
            case name = "name"
            case originDomainId = "originDomainId"
            case originProjectId = "originProjectId"
            case owningProjectId = "owningProjectId"
            case revision = "revision"
            case updatedAt = "updatedAt"
            case updatedBy = "updatedBy"
        }
    }

    public struct GetDataSourceInput: AWSEncodableShape {
        /// The ID of the Amazon DataZone domain in which the data source exists.
        public let domainIdentifier: String
        /// The ID of the Amazon DataZone data source.
        public let identifier: String

        public init(domainIdentifier: String, identifier: String) {
            self.domainIdentifier = domainIdentifier
            self.identifier = identifier
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.domainIdentifier, key: "domainIdentifier")
            request.encodePath(self.identifier, key: "identifier")
        }

        public func validate(name: String) throws {
            try self.validate(self.domainIdentifier, name: "domainIdentifier", parent: name, pattern: "^dzd[-_][a-zA-Z0-9_-]{1,36}$")
            try self.validate(self.identifier, name: "identifier", parent: name, pattern: "^[a-zA-Z0-9_-]{1,36}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetDataSourceOutput: AWSDecodableShape {
        /// The metadata forms attached to the assets created by this data source.
        public let assetFormsOutput: [FormOutput]?
        /// The configuration of the data source.
        public let configuration: DataSourceConfigurationOutput?
        /// The timestamp of when the data source was created.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var createdAt: Date?
        /// The description of the data source.
        public let description: String?
        /// The ID of the Amazon DataZone domain in which the data source exists.
        public let domainId: String
        /// Specifies whether this data source is enabled or not.
        public let enableSetting: EnableSetting?
        /// The ID of the environment where this data source creates and publishes assets,
        public let environmentId: String
        /// Specifies the error message that is returned if the operation cannot be successfully completed.
        public let errorMessage: DataSourceErrorMessage?
        /// The ID of the data source.
        public let id: String
        /// The number of assets created by the data source during its last run.
        public let lastRunAssetCount: Int?
        /// The timestamp of the last run of the data source.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var lastRunAt: Date?
        /// Specifies the error message that is returned if the operation cannot be successfully completed.
        public let lastRunErrorMessage: DataSourceErrorMessage?
        /// The status of the last run of the data source.
        public let lastRunStatus: DataSourceRunStatus?
        /// The name of the data source.
        public let name: String
        /// The ID of the project where the data source creates and publishes assets.
        public let projectId: String
        /// Specifies whether the assets that this data source creates in the inventory are to be also automatically published to the catalog.
        public let publishOnImport: Bool?
        /// The recommendation configuration of the data source.
        public let recommendation: RecommendationConfiguration?
        /// The schedule of the data source runs.
        public let schedule: ScheduleConfiguration?
        /// The status of the data source.
        public let status: DataSourceStatus?
        /// The type of the data source.
        public let type: String?
        /// The timestamp of when the data source was updated.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var updatedAt: Date?

        public init(assetFormsOutput: [FormOutput]? = nil, configuration: DataSourceConfigurationOutput? = nil, createdAt: Date? = nil, description: String? = nil, domainId: String, enableSetting: EnableSetting? = nil, environmentId: String, errorMessage: DataSourceErrorMessage? = nil, id: String, lastRunAssetCount: Int? = nil, lastRunAt: Date? = nil, lastRunErrorMessage: DataSourceErrorMessage? = nil, lastRunStatus: DataSourceRunStatus? = nil, name: String, projectId: String, publishOnImport: Bool? = nil, recommendation: RecommendationConfiguration? = nil, schedule: ScheduleConfiguration? = nil, status: DataSourceStatus? = nil, type: String? = nil, updatedAt: Date? = nil) {
            self.assetFormsOutput = assetFormsOutput
            self.configuration = configuration
            self.createdAt = createdAt
            self.description = description
            self.domainId = domainId
            self.enableSetting = enableSetting
            self.environmentId = environmentId
            self.errorMessage = errorMessage
            self.id = id
            self.lastRunAssetCount = lastRunAssetCount
            self.lastRunAt = lastRunAt
            self.lastRunErrorMessage = lastRunErrorMessage
            self.lastRunStatus = lastRunStatus
            self.name = name
            self.projectId = projectId
            self.publishOnImport = publishOnImport
            self.recommendation = recommendation
            self.schedule = schedule
            self.status = status
            self.type = type
            self.updatedAt = updatedAt
        }

        private enum CodingKeys: String, CodingKey {
            case assetFormsOutput = "assetFormsOutput"
            case configuration = "configuration"
            case createdAt = "createdAt"
            case description = "description"
            case domainId = "domainId"
            case enableSetting = "enableSetting"
            case environmentId = "environmentId"
            case errorMessage = "errorMessage"
            case id = "id"
            case lastRunAssetCount = "lastRunAssetCount"
            case lastRunAt = "lastRunAt"
            case lastRunErrorMessage = "lastRunErrorMessage"
            case lastRunStatus = "lastRunStatus"
            case name = "name"
            case projectId = "projectId"
            case publishOnImport = "publishOnImport"
            case recommendation = "recommendation"
            case schedule = "schedule"
            case status = "status"
            case type = "type"
            case updatedAt = "updatedAt"
        }
    }

    public struct GetDataSourceRunInput: AWSEncodableShape {
        /// The ID of the domain in which this data source run was performed.
        public let domainIdentifier: String
        /// The ID of the data source run.
        public let identifier: String

        public init(domainIdentifier: String, identifier: String) {
            self.domainIdentifier = domainIdentifier
            self.identifier = identifier
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.domainIdentifier, key: "domainIdentifier")
            request.encodePath(self.identifier, key: "identifier")
        }

        public func validate(name: String) throws {
            try self.validate(self.domainIdentifier, name: "domainIdentifier", parent: name, pattern: "^dzd[-_][a-zA-Z0-9_-]{1,36}$")
            try self.validate(self.identifier, name: "identifier", parent: name, pattern: "^[a-zA-Z0-9_-]{1,36}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetDataSourceRunOutput: AWSDecodableShape {
        /// The timestamp of when the data source run was created.
        @CustomCoding<ISO8601DateCoder>
        public var createdAt: Date
        /// The configuration snapshot of the data source run.
        public let dataSourceConfigurationSnapshot: String?
        /// The ID of the data source for this data source run.
        public let dataSourceId: String
        /// The ID of the domain in which this data source run was performed.
        public let domainId: String
        /// Specifies the error message that is returned if the operation cannot be successfully completed.
        public let errorMessage: DataSourceErrorMessage?
        /// The ID of the data source run.
        public let id: String
        /// The ID of the project in which this data source run occured.
        public let projectId: String
        /// The asset statistics from this data source run.
        public let runStatisticsForAssets: RunStatisticsForAssets?
        /// The timestamp of when this data source run started.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var startedAt: Date?
        /// The status of this data source run.
        public let status: DataSourceRunStatus
        /// The timestamp of when this data source run stopped.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var stoppedAt: Date?
        /// The type of this data source run.
        public let type: DataSourceRunType
        /// The timestamp of when this data source run was updated.
        @CustomCoding<ISO8601DateCoder>
        public var updatedAt: Date

        public init(createdAt: Date, dataSourceConfigurationSnapshot: String? = nil, dataSourceId: String, domainId: String, errorMessage: DataSourceErrorMessage? = nil, id: String, projectId: String, runStatisticsForAssets: RunStatisticsForAssets? = nil, startedAt: Date? = nil, status: DataSourceRunStatus, stoppedAt: Date? = nil, type: DataSourceRunType, updatedAt: Date) {
            self.createdAt = createdAt
            self.dataSourceConfigurationSnapshot = dataSourceConfigurationSnapshot
            self.dataSourceId = dataSourceId
            self.domainId = domainId
            self.errorMessage = errorMessage
            self.id = id
            self.projectId = projectId
            self.runStatisticsForAssets = runStatisticsForAssets
            self.startedAt = startedAt
            self.status = status
            self.stoppedAt = stoppedAt
            self.type = type
            self.updatedAt = updatedAt
        }

        private enum CodingKeys: String, CodingKey {
            case createdAt = "createdAt"
            case dataSourceConfigurationSnapshot = "dataSourceConfigurationSnapshot"
            case dataSourceId = "dataSourceId"
            case domainId = "domainId"
            case errorMessage = "errorMessage"
            case id = "id"
            case projectId = "projectId"
            case runStatisticsForAssets = "runStatisticsForAssets"
            case startedAt = "startedAt"
            case status = "status"
            case stoppedAt = "stoppedAt"
            case type = "type"
            case updatedAt = "updatedAt"
        }
    }

    public struct GetDomainInput: AWSEncodableShape {
        /// The identifier of the specified Amazon DataZone domain.
        public let identifier: String

        public init(identifier: String) {
            self.identifier = identifier
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.identifier, key: "identifier")
        }

        public func validate(name: String) throws {
            try self.validate(self.identifier, name: "identifier", parent: name, pattern: "^dzd[-_][a-zA-Z0-9_-]{1,36}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetDomainOutput: AWSDecodableShape {
        /// The ARN of the specified Amazon DataZone domain.
        public let arn: String?
        /// The timestamp of when the Amazon DataZone domain was created.
        public let createdAt: Date?
        /// The description of the Amazon DataZone domain.
        public let description: String?
        /// The domain execution role with which the Amazon DataZone domain is created.
        public let domainExecutionRole: String
        /// The identifier of the specified Amazon DataZone domain.
        public let id: String
        /// The identifier of the Amazon Web Services Key Management Service (KMS) key that is used to encrypt the Amazon DataZone domain, metadata, and reporting data.
        public let kmsKeyIdentifier: String?
        /// The timestamp of when the Amazon DataZone domain was last updated.
        public let lastUpdatedAt: Date?
        /// The name of the Amazon DataZone domain.
        public let name: String?
        /// The URL of the data portal for this Amazon DataZone domain.
        public let portalUrl: String?
        /// The single sing-on option of the specified Amazon DataZone domain.
        public let singleSignOn: SingleSignOn?
        /// The status of the specified Amazon DataZone domain.
        public let status: DomainStatus
        /// The tags specified for the Amazon DataZone domain.
        public let tags: [String: String]?

        public init(arn: String? = nil, createdAt: Date? = nil, description: String? = nil, domainExecutionRole: String, id: String, kmsKeyIdentifier: String? = nil, lastUpdatedAt: Date? = nil, name: String? = nil, portalUrl: String? = nil, singleSignOn: SingleSignOn? = nil, status: DomainStatus, tags: [String: String]? = nil) {
            self.arn = arn
            self.createdAt = createdAt
            self.description = description
            self.domainExecutionRole = domainExecutionRole
            self.id = id
            self.kmsKeyIdentifier = kmsKeyIdentifier
            self.lastUpdatedAt = lastUpdatedAt
            self.name = name
            self.portalUrl = portalUrl
            self.singleSignOn = singleSignOn
            self.status = status
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case createdAt = "createdAt"
            case description = "description"
            case domainExecutionRole = "domainExecutionRole"
            case id = "id"
            case kmsKeyIdentifier = "kmsKeyIdentifier"
            case lastUpdatedAt = "lastUpdatedAt"
            case name = "name"
            case portalUrl = "portalUrl"
            case singleSignOn = "singleSignOn"
            case status = "status"
            case tags = "tags"
        }
    }

    public struct GetEnvironmentBlueprintConfigurationInput: AWSEncodableShape {
        /// The ID of the Amazon DataZone domain where this blueprint exists.
        public let domainIdentifier: String
        /// He ID of the blueprint.
        public let environmentBlueprintIdentifier: String

        public init(domainIdentifier: String, environmentBlueprintIdentifier: String) {
            self.domainIdentifier = domainIdentifier
            self.environmentBlueprintIdentifier = environmentBlueprintIdentifier
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.domainIdentifier, key: "domainIdentifier")
            request.encodePath(self.environmentBlueprintIdentifier, key: "environmentBlueprintIdentifier")
        }

        public func validate(name: String) throws {
            try self.validate(self.domainIdentifier, name: "domainIdentifier", parent: name, pattern: "^dzd[-_][a-zA-Z0-9_-]{1,36}$")
            try self.validate(self.environmentBlueprintIdentifier, name: "environmentBlueprintIdentifier", parent: name, pattern: "^[a-zA-Z0-9_-]{1,36}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetEnvironmentBlueprintConfigurationOutput: AWSDecodableShape {
        /// The timestamp of when this blueprint was created.
        public let createdAt: Date?
        /// The ID of the Amazon DataZone domain where this blueprint exists.
        public let domainId: String
        /// The Amazon Web Services regions in which this blueprint is enabled.
        public let enabledRegions: [String]?
        /// The ID of the blueprint.
        public let environmentBlueprintId: String
        /// The ARN of the manage access role with which this blueprint is created.
        public let manageAccessRoleArn: String?
        /// The ARN of the provisioning role with which this blueprint is created.
        public let provisioningRoleArn: String?
        /// The regional parameters of the blueprint.
        public let regionalParameters: [String: [String: String]]?
        /// The timestamp of when this blueprint was upated.
        public let updatedAt: Date?

        public init(createdAt: Date? = nil, domainId: String, enabledRegions: [String]? = nil, environmentBlueprintId: String, manageAccessRoleArn: String? = nil, provisioningRoleArn: String? = nil, regionalParameters: [String: [String: String]]? = nil, updatedAt: Date? = nil) {
            self.createdAt = createdAt
            self.domainId = domainId
            self.enabledRegions = enabledRegions
            self.environmentBlueprintId = environmentBlueprintId
            self.manageAccessRoleArn = manageAccessRoleArn
            self.provisioningRoleArn = provisioningRoleArn
            self.regionalParameters = regionalParameters
            self.updatedAt = updatedAt
        }

        private enum CodingKeys: String, CodingKey {
            case createdAt = "createdAt"
            case domainId = "domainId"
            case enabledRegions = "enabledRegions"
            case environmentBlueprintId = "environmentBlueprintId"
            case manageAccessRoleArn = "manageAccessRoleArn"
            case provisioningRoleArn = "provisioningRoleArn"
            case regionalParameters = "regionalParameters"
            case updatedAt = "updatedAt"
        }
    }

    public struct GetEnvironmentBlueprintInput: AWSEncodableShape {
        /// The identifier of the domain in which this blueprint exists.
        public let domainIdentifier: String
        /// The ID of this Amazon DataZone blueprint.
        public let identifier: String

        public init(domainIdentifier: String, identifier: String) {
            self.domainIdentifier = domainIdentifier
            self.identifier = identifier
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.domainIdentifier, key: "domainIdentifier")
            request.encodePath(self.identifier, key: "identifier")
        }

        public func validate(name: String) throws {
            try self.validate(self.domainIdentifier, name: "domainIdentifier", parent: name, pattern: "^dzd[-_][a-zA-Z0-9_-]{1,36}$")
            try self.validate(self.identifier, name: "identifier", parent: name, pattern: "^[a-zA-Z0-9_-]{1,36}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetEnvironmentBlueprintOutput: AWSDecodableShape {
        /// A timestamp of when this blueprint was created.
        public let createdAt: Date?
        /// The deployment properties of this Amazon DataZone blueprint.
        public let deploymentProperties: DeploymentProperties?
        /// The description of this Amazon DataZone blueprint.
        public let description: String?
        /// The glossary terms attached to this Amazon DataZone blueprint.
        public let glossaryTerms: [String]?
        /// The ID of this Amazon DataZone blueprint.
        public let id: String
        /// The name of this Amazon DataZone blueprint.
        public let name: String
        /// The provider of this Amazon DataZone blueprint.
        public let provider: String
        /// The provisioning properties of this Amazon DataZone blueprint.
        public let provisioningProperties: ProvisioningProperties
        /// The timestamp of when this blueprint was updated.
        public let updatedAt: Date?
        /// The user parameters of this blueprint.
        public let userParameters: [CustomParameter]?

        public init(createdAt: Date? = nil, deploymentProperties: DeploymentProperties? = nil, description: String? = nil, glossaryTerms: [String]? = nil, id: String, name: String, provider: String, provisioningProperties: ProvisioningProperties, updatedAt: Date? = nil, userParameters: [CustomParameter]? = nil) {
            self.createdAt = createdAt
            self.deploymentProperties = deploymentProperties
            self.description = description
            self.glossaryTerms = glossaryTerms
            self.id = id
            self.name = name
            self.provider = provider
            self.provisioningProperties = provisioningProperties
            self.updatedAt = updatedAt
            self.userParameters = userParameters
        }

        private enum CodingKeys: String, CodingKey {
            case createdAt = "createdAt"
            case deploymentProperties = "deploymentProperties"
            case description = "description"
            case glossaryTerms = "glossaryTerms"
            case id = "id"
            case name = "name"
            case provider = "provider"
            case provisioningProperties = "provisioningProperties"
            case updatedAt = "updatedAt"
            case userParameters = "userParameters"
        }
    }

    public struct GetEnvironmentInput: AWSEncodableShape {
        /// The ID of the Amazon DataZone domain where the environment exists.
        public let domainIdentifier: String
        /// The ID of the Amazon DataZone environment.
        public let identifier: String

        public init(domainIdentifier: String, identifier: String) {
            self.domainIdentifier = domainIdentifier
            self.identifier = identifier
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.domainIdentifier, key: "domainIdentifier")
            request.encodePath(self.identifier, key: "identifier")
        }

        public func validate(name: String) throws {
            try self.validate(self.domainIdentifier, name: "domainIdentifier", parent: name, pattern: "^dzd[-_][a-zA-Z0-9_-]{1,36}$")
            try self.validate(self.identifier, name: "identifier", parent: name, pattern: "^[a-zA-Z0-9_-]{1,36}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetEnvironmentOutput: AWSDecodableShape {
        /// The ID of the Amazon Web Services account where the environment exists.
        public let awsAccountId: String?
        /// The Amazon Web Services region where the environment exists.
        public let awsAccountRegion: String?
        /// The timestamp of when the environment was created.
        public let createdAt: Date?
        /// The Amazon DataZone user who created the environment.
        public let createdBy: String
        /// The deployment properties of the environment.
        public let deploymentProperties: DeploymentProperties?
        /// The description of the environment.
        public let description: String?
        /// The ID of the Amazon DataZone domain where the environment exists.
        public let domainId: String
        /// The actions of the environment.
        public let environmentActions: [ConfigurableEnvironmentAction]?
        /// The blueprint with which the environment is created.
        public let environmentBlueprintId: String?
        /// The ID of the environment profile with which the environment is created.
        public let environmentProfileId: String
        /// The business glossary terms that can be used in this environment.
        public let glossaryTerms: [String]?
        /// The ID of the environment.
        public let id: String?
        /// The details of the last deployment of the environment.
        public let lastDeployment: Deployment?
        /// The name of the environment.
        public let name: String
        /// The ID of the Amazon DataZone project in which this environment is created.
        public let projectId: String
        /// The provider of this Amazon DataZone environment.
        public let provider: String
        /// The provisioned resources of this Amazon DataZone environment.
        public let provisionedResources: [Resource]?
        /// The provisioning properties of this Amazon DataZone environment.
        public let provisioningProperties: ProvisioningProperties?
        /// The status of this Amazon DataZone environment.
        public let status: EnvironmentStatus?
        /// The timestamp of when this environment was updated.
        public let updatedAt: Date?
        /// The user parameters of this Amazon DataZone environment.
        public let userParameters: [CustomParameter]?

        public init(awsAccountId: String? = nil, awsAccountRegion: String? = nil, createdAt: Date? = nil, createdBy: String, deploymentProperties: DeploymentProperties? = nil, description: String? = nil, domainId: String, environmentActions: [ConfigurableEnvironmentAction]? = nil, environmentBlueprintId: String? = nil, environmentProfileId: String, glossaryTerms: [String]? = nil, id: String? = nil, lastDeployment: Deployment? = nil, name: String, projectId: String, provider: String, provisionedResources: [Resource]? = nil, provisioningProperties: ProvisioningProperties? = nil, status: EnvironmentStatus? = nil, updatedAt: Date? = nil, userParameters: [CustomParameter]? = nil) {
            self.awsAccountId = awsAccountId
            self.awsAccountRegion = awsAccountRegion
            self.createdAt = createdAt
            self.createdBy = createdBy
            self.deploymentProperties = deploymentProperties
            self.description = description
            self.domainId = domainId
            self.environmentActions = environmentActions
            self.environmentBlueprintId = environmentBlueprintId
            self.environmentProfileId = environmentProfileId
            self.glossaryTerms = glossaryTerms
            self.id = id
            self.lastDeployment = lastDeployment
            self.name = name
            self.projectId = projectId
            self.provider = provider
            self.provisionedResources = provisionedResources
            self.provisioningProperties = provisioningProperties
            self.status = status
            self.updatedAt = updatedAt
            self.userParameters = userParameters
        }

        private enum CodingKeys: String, CodingKey {
            case awsAccountId = "awsAccountId"
            case awsAccountRegion = "awsAccountRegion"
            case createdAt = "createdAt"
            case createdBy = "createdBy"
            case deploymentProperties = "deploymentProperties"
            case description = "description"
            case domainId = "domainId"
            case environmentActions = "environmentActions"
            case environmentBlueprintId = "environmentBlueprintId"
            case environmentProfileId = "environmentProfileId"
            case glossaryTerms = "glossaryTerms"
            case id = "id"
            case lastDeployment = "lastDeployment"
            case name = "name"
            case projectId = "projectId"
            case provider = "provider"
            case provisionedResources = "provisionedResources"
            case provisioningProperties = "provisioningProperties"
            case status = "status"
            case updatedAt = "updatedAt"
            case userParameters = "userParameters"
        }
    }

    public struct GetEnvironmentProfileInput: AWSEncodableShape {
        /// The ID of the Amazon DataZone domain in which this environment profile exists.
        public let domainIdentifier: String
        /// The ID of the environment profile.
        public let identifier: String

        public init(domainIdentifier: String, identifier: String) {
            self.domainIdentifier = domainIdentifier
            self.identifier = identifier
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.domainIdentifier, key: "domainIdentifier")
            request.encodePath(self.identifier, key: "identifier")
        }

        public func validate(name: String) throws {
            try self.validate(self.domainIdentifier, name: "domainIdentifier", parent: name, pattern: "^dzd[-_][a-zA-Z0-9_-]{1,36}$")
            try self.validate(self.identifier, name: "identifier", parent: name, pattern: "^[a-zA-Z0-9_-]{1,36}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetEnvironmentProfileOutput: AWSDecodableShape {
        /// The ID of the Amazon Web Services account where this environment profile exists.
        public let awsAccountId: String?
        /// The Amazon Web Services region where this environment profile exists.
        public let awsAccountRegion: String?
        /// The timestamp of when this environment profile was created.
        public let createdAt: Date?
        /// The Amazon DataZone user who created this environment profile.
        public let createdBy: String
        /// The description of the environment profile.
        public let description: String?
        /// The ID of the Amazon DataZone domain in which this environment profile exists.
        public let domainId: String
        /// The ID of the blueprint with which this environment profile is created.
        public let environmentBlueprintId: String
        /// The ID of the environment profile.
        public let id: String
        /// The name of the environment profile.
        public let name: String
        /// The ID of the Amazon DataZone project in which this environment profile is created.
        public let projectId: String?
        /// The timestamp of when this environment profile was upated.
        public let updatedAt: Date?
        /// The user parameters of the environment profile.
        public let userParameters: [CustomParameter]?

        public init(awsAccountId: String? = nil, awsAccountRegion: String? = nil, createdAt: Date? = nil, createdBy: String, description: String? = nil, domainId: String, environmentBlueprintId: String, id: String, name: String, projectId: String? = nil, updatedAt: Date? = nil, userParameters: [CustomParameter]? = nil) {
            self.awsAccountId = awsAccountId
            self.awsAccountRegion = awsAccountRegion
            self.createdAt = createdAt
            self.createdBy = createdBy
            self.description = description
            self.domainId = domainId
            self.environmentBlueprintId = environmentBlueprintId
            self.id = id
            self.name = name
            self.projectId = projectId
            self.updatedAt = updatedAt
            self.userParameters = userParameters
        }

        private enum CodingKeys: String, CodingKey {
            case awsAccountId = "awsAccountId"
            case awsAccountRegion = "awsAccountRegion"
            case createdAt = "createdAt"
            case createdBy = "createdBy"
            case description = "description"
            case domainId = "domainId"
            case environmentBlueprintId = "environmentBlueprintId"
            case id = "id"
            case name = "name"
            case projectId = "projectId"
            case updatedAt = "updatedAt"
            case userParameters = "userParameters"
        }
    }

    public struct GetFormTypeInput: AWSEncodableShape {
        /// The ID of the Amazon DataZone domain in which this metadata form type exists.
        public let domainIdentifier: String
        /// The ID of the metadata form type.
        public let formTypeIdentifier: String
        /// The revision of this metadata form type.
        public let revision: String?

        public init(domainIdentifier: String, formTypeIdentifier: String, revision: String? = nil) {
            self.domainIdentifier = domainIdentifier
            self.formTypeIdentifier = formTypeIdentifier
            self.revision = revision
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.domainIdentifier, key: "domainIdentifier")
            request.encodePath(self.formTypeIdentifier, key: "formTypeIdentifier")
            request.encodeQuery(self.revision, key: "revision")
        }

        public func validate(name: String) throws {
            try self.validate(self.domainIdentifier, name: "domainIdentifier", parent: name, pattern: "^dzd[-_][a-zA-Z0-9_-]{1,36}$")
            try self.validate(self.formTypeIdentifier, name: "formTypeIdentifier", parent: name, max: 385)
            try self.validate(self.formTypeIdentifier, name: "formTypeIdentifier", parent: name, min: 1)
            try self.validate(self.formTypeIdentifier, name: "formTypeIdentifier", parent: name, pattern: "^(?!\\.)[\\w\\.]*\\w$")
            try self.validate(self.revision, name: "revision", parent: name, max: 64)
            try self.validate(self.revision, name: "revision", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetFormTypeOutput: AWSDecodableShape {
        /// The timestamp of when this metadata form type was created.
        public let createdAt: Date?
        /// The Amazon DataZone user who created this metadata form type.
        public let createdBy: String?
        /// The description of the metadata form type.
        public let description: String?
        /// The ID of the Amazon DataZone domain in which this metadata form type exists.
        public let domainId: String
        /// The imports of the metadata form type.
        public let imports: [Import]?
        /// The model of the metadata form type.
        public let model: Model
        /// The name of the metadata form type.
        public let name: String
        /// The ID of the Amazon DataZone domain in which the metadata form type was originally created.
        public let originDomainId: String?
        /// The ID of the project in which this metadata form type was originally created.
        public let originProjectId: String?
        /// The ID of the project that owns this metadata form type.
        public let owningProjectId: String?
        /// The revision of the metadata form type.
        public let revision: String
        /// The status of the metadata form type.
        public let status: FormTypeStatus?

        public init(createdAt: Date? = nil, createdBy: String? = nil, description: String? = nil, domainId: String, imports: [Import]? = nil, model: Model, name: String, originDomainId: String? = nil, originProjectId: String? = nil, owningProjectId: String? = nil, revision: String, status: FormTypeStatus? = nil) {
            self.createdAt = createdAt
            self.createdBy = createdBy
            self.description = description
            self.domainId = domainId
            self.imports = imports
            self.model = model
            self.name = name
            self.originDomainId = originDomainId
            self.originProjectId = originProjectId
            self.owningProjectId = owningProjectId
            self.revision = revision
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case createdAt = "createdAt"
            case createdBy = "createdBy"
            case description = "description"
            case domainId = "domainId"
            case imports = "imports"
            case model = "model"
            case name = "name"
            case originDomainId = "originDomainId"
            case originProjectId = "originProjectId"
            case owningProjectId = "owningProjectId"
            case revision = "revision"
            case status = "status"
        }
    }

    public struct GetGlossaryInput: AWSEncodableShape {
        /// The ID of the Amazon DataZone domain in which this business glossary exists.
        public let domainIdentifier: String
        /// The ID of the business glossary.
        public let identifier: String

        public init(domainIdentifier: String, identifier: String) {
            self.domainIdentifier = domainIdentifier
            self.identifier = identifier
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.domainIdentifier, key: "domainIdentifier")
            request.encodePath(self.identifier, key: "identifier")
        }

        public func validate(name: String) throws {
            try self.validate(self.domainIdentifier, name: "domainIdentifier", parent: name, pattern: "^dzd[-_][a-zA-Z0-9_-]{1,36}$")
            try self.validate(self.identifier, name: "identifier", parent: name, pattern: "^[a-zA-Z0-9_-]{1,36}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetGlossaryOutput: AWSDecodableShape {
        /// The timestamp of when this business glossary was created.
        public let createdAt: Date?
        /// The Amazon DataZone user who created this business glossary.
        public let createdBy: String?
        /// The description of the business glossary.
        public let description: String?
        /// The ID of the Amazon DataZone domain in which this business glossary exists.
        public let domainId: String
        /// The ID of the business glossary.
        public let id: String
        /// The name of the business glossary.
        public let name: String
        /// The ID of the project that owns this business glossary.
        public let owningProjectId: String
        /// The status of the business glossary.
        public let status: GlossaryStatus
        /// The timestamp of when the business glossary was updated.
        public let updatedAt: Date?
        /// The Amazon DataZone user who updated the business glossary.
        public let updatedBy: String?

        public init(createdAt: Date? = nil, createdBy: String? = nil, description: String? = nil, domainId: String, id: String, name: String, owningProjectId: String, status: GlossaryStatus, updatedAt: Date? = nil, updatedBy: String? = nil) {
            self.createdAt = createdAt
            self.createdBy = createdBy
            self.description = description
            self.domainId = domainId
            self.id = id
            self.name = name
            self.owningProjectId = owningProjectId
            self.status = status
            self.updatedAt = updatedAt
            self.updatedBy = updatedBy
        }

        private enum CodingKeys: String, CodingKey {
            case createdAt = "createdAt"
            case createdBy = "createdBy"
            case description = "description"
            case domainId = "domainId"
            case id = "id"
            case name = "name"
            case owningProjectId = "owningProjectId"
            case status = "status"
            case updatedAt = "updatedAt"
            case updatedBy = "updatedBy"
        }
    }

    public struct GetGlossaryTermInput: AWSEncodableShape {
        /// The ID of the Amazon DataZone domain in which this business glossary term exists.
        public let domainIdentifier: String
        /// The ID of the business glossary term.
        public let identifier: String

        public init(domainIdentifier: String, identifier: String) {
            self.domainIdentifier = domainIdentifier
            self.identifier = identifier
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.domainIdentifier, key: "domainIdentifier")
            request.encodePath(self.identifier, key: "identifier")
        }

        public func validate(name: String) throws {
            try self.validate(self.domainIdentifier, name: "domainIdentifier", parent: name, pattern: "^dzd[-_][a-zA-Z0-9_-]{1,36}$")
            try self.validate(self.identifier, name: "identifier", parent: name, pattern: "^[a-zA-Z0-9_-]{1,36}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetGlossaryTermOutput: AWSDecodableShape {
        /// The timestamp of when the business glossary term was created.
        public let createdAt: Date?
        /// The Amazon DataZone user who created the business glossary.
        public let createdBy: String?
        /// The ID of the Amazon DataZone domain in which this business glossary term exists.
        public let domainId: String
        /// The ID of the business glossary to which this term belongs.
        public let glossaryId: String
        /// The ID of the business glossary term.
        public let id: String
        /// The long description of the business glossary term.
        public let longDescription: String?
        /// The name of the business glossary term.
        public let name: String
        /// The short decription of the business glossary term.
        public let shortDescription: String?
        /// The status of the business glossary term.
        public let status: GlossaryTermStatus
        /// The relations of the business glossary term.
        public let termRelations: TermRelations?
        /// The timestamp of when the business glossary term was updated.
        public let updatedAt: Date?
        /// The Amazon DataZone user who updated the business glossary term.
        public let updatedBy: String?

        public init(createdAt: Date? = nil, createdBy: String? = nil, domainId: String, glossaryId: String, id: String, longDescription: String? = nil, name: String, shortDescription: String? = nil, status: GlossaryTermStatus, termRelations: TermRelations? = nil, updatedAt: Date? = nil, updatedBy: String? = nil) {
            self.createdAt = createdAt
            self.createdBy = createdBy
            self.domainId = domainId
            self.glossaryId = glossaryId
            self.id = id
            self.longDescription = longDescription
            self.name = name
            self.shortDescription = shortDescription
            self.status = status
            self.termRelations = termRelations
            self.updatedAt = updatedAt
            self.updatedBy = updatedBy
        }

        private enum CodingKeys: String, CodingKey {
            case createdAt = "createdAt"
            case createdBy = "createdBy"
            case domainId = "domainId"
            case glossaryId = "glossaryId"
            case id = "id"
            case longDescription = "longDescription"
            case name = "name"
            case shortDescription = "shortDescription"
            case status = "status"
            case termRelations = "termRelations"
            case updatedAt = "updatedAt"
            case updatedBy = "updatedBy"
        }
    }

    public struct GetGroupProfileInput: AWSEncodableShape {
        /// The identifier of the Amazon DataZone domain in which the group profile exists.
        public let domainIdentifier: String
        /// The identifier of the group profile.
        public let groupIdentifier: String

        public init(domainIdentifier: String, groupIdentifier: String) {
            self.domainIdentifier = domainIdentifier
            self.groupIdentifier = groupIdentifier
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.domainIdentifier, key: "domainIdentifier")
            request.encodePath(self.groupIdentifier, key: "groupIdentifier")
        }

        public func validate(name: String) throws {
            try self.validate(self.domainIdentifier, name: "domainIdentifier", parent: name, pattern: "^dzd[-_][a-zA-Z0-9_-]{1,36}$")
            try self.validate(self.groupIdentifier, name: "groupIdentifier", parent: name, pattern: "(^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}$|[\\p{L}\\p{M}\\p{S}\\p{N}\\p{P}\\t\\n\\r  ]+)")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetGroupProfileOutput: AWSDecodableShape {
        /// The identifier of the Amazon DataZone domain in which the group profile exists.
        public let domainId: String?
        /// The name of the group for which the specified group profile exists.
        public let groupName: String?
        /// The identifier of the group profile.
        public let id: String?
        /// The identifier of the group profile.
        public let status: GroupProfileStatus?

        public init(domainId: String? = nil, groupName: String? = nil, id: String? = nil, status: GroupProfileStatus? = nil) {
            self.domainId = domainId
            self.groupName = groupName
            self.id = id
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case domainId = "domainId"
            case groupName = "groupName"
            case id = "id"
            case status = "status"
        }
    }

    public struct GetIamPortalLoginUrlInput: AWSEncodableShape {
        /// the ID of the Amazon DataZone domain the data portal of which you want to get.
        public let domainIdentifier: String

        public init(domainIdentifier: String) {
            self.domainIdentifier = domainIdentifier
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.domainIdentifier, key: "domainIdentifier")
        }

        public func validate(name: String) throws {
            try self.validate(self.domainIdentifier, name: "domainIdentifier", parent: name, pattern: "^dzd[-_][a-zA-Z0-9_-]{1,36}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetIamPortalLoginUrlOutput: AWSDecodableShape {
        /// The data portal URL of the specified Amazon DataZone domain.
        public let authCodeUrl: String?
        /// The ID of the user profile.
        public let userProfileId: String

        public init(authCodeUrl: String? = nil, userProfileId: String) {
            self.authCodeUrl = authCodeUrl
            self.userProfileId = userProfileId
        }

        private enum CodingKeys: String, CodingKey {
            case authCodeUrl = "authCodeUrl"
            case userProfileId = "userProfileId"
        }
    }

    public struct GetListingInput: AWSEncodableShape {
        /// The ID of the Amazon DataZone domain.
        public let domainIdentifier: String
        /// The ID of the listing.
        public let identifier: String
        /// The revision of the listing.
        public let listingRevision: String?

        public init(domainIdentifier: String, identifier: String, listingRevision: String? = nil) {
            self.domainIdentifier = domainIdentifier
            self.identifier = identifier
            self.listingRevision = listingRevision
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.domainIdentifier, key: "domainIdentifier")
            request.encodePath(self.identifier, key: "identifier")
            request.encodeQuery(self.listingRevision, key: "listingRevision")
        }

        public func validate(name: String) throws {
            try self.validate(self.domainIdentifier, name: "domainIdentifier", parent: name, pattern: "^dzd[-_][a-zA-Z0-9_-]{1,36}$")
            try self.validate(self.identifier, name: "identifier", parent: name, pattern: "^[a-zA-Z0-9_-]{1,36}$")
            try self.validate(self.listingRevision, name: "listingRevision", parent: name, max: 64)
            try self.validate(self.listingRevision, name: "listingRevision", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetListingOutput: AWSDecodableShape {
        /// The timestamp of when the listing was created.
        public let createdAt: Date?
        /// The Amazon DataZone user who created the listing.
        public let createdBy: String?
        /// The description of the listing.
        public let description: String?
        /// The ID of the Amazon DataZone domain.
        public let domainId: String
        /// The ID of the listing.
        public let id: String
        /// The details of a listing.
        public let item: ListingItem?
        /// The revision of a listing.
        public let listingRevision: String
        /// The name of the listing.
        public let name: String?
        /// The status of the listing.
        public let status: ListingStatus?
        /// The timestamp of when the listing was updated.
        public let updatedAt: Date?
        /// The Amazon DataZone user who updated the listing.
        public let updatedBy: String?

        public init(createdAt: Date? = nil, createdBy: String? = nil, description: String? = nil, domainId: String, id: String, item: ListingItem? = nil, listingRevision: String, name: String? = nil, status: ListingStatus? = nil, updatedAt: Date? = nil, updatedBy: String? = nil) {
            self.createdAt = createdAt
            self.createdBy = createdBy
            self.description = description
            self.domainId = domainId
            self.id = id
            self.item = item
            self.listingRevision = listingRevision
            self.name = name
            self.status = status
            self.updatedAt = updatedAt
            self.updatedBy = updatedBy
        }

        private enum CodingKeys: String, CodingKey {
            case createdAt = "createdAt"
            case createdBy = "createdBy"
            case description = "description"
            case domainId = "domainId"
            case id = "id"
            case item = "item"
            case listingRevision = "listingRevision"
            case name = "name"
            case status = "status"
            case updatedAt = "updatedAt"
            case updatedBy = "updatedBy"
        }
    }

    public struct GetMetadataGenerationRunInput: AWSEncodableShape {
        /// The ID of the Amazon DataZone domain the metadata generation run of which you want to get.
        public let domainIdentifier: String
        /// The identifier of the metadata generation run.
        public let identifier: String

        public init(domainIdentifier: String, identifier: String) {
            self.domainIdentifier = domainIdentifier
            self.identifier = identifier
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.domainIdentifier, key: "domainIdentifier")
            request.encodePath(self.identifier, key: "identifier")
        }

        public func validate(name: String) throws {
            try self.validate(self.domainIdentifier, name: "domainIdentifier", parent: name, pattern: "^dzd[-_][a-zA-Z0-9_-]{1,36}$")
            try self.validate(self.identifier, name: "identifier", parent: name, pattern: "^[a-zA-Z0-9_-]{1,36}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetMetadataGenerationRunOutput: AWSDecodableShape {
        /// The timestamp of when the metadata generation run was start.
        public let createdAt: Date?
        /// The Amazon DataZone user who started the metadata generation run.
        public let createdBy: String?
        /// The ID of the Amazon DataZone domain the metadata generation run of which you want to get.
        public let domainId: String
        /// The ID of the metadata generation run.
        public let id: String
        /// The ID of the project that owns the assets for which you're running metadata generation.
        public let owningProjectId: String
        /// The status of the metadata generation run.
        public let status: MetadataGenerationRunStatus?
        /// The asset for which you're generating metadata.
        public let target: MetadataGenerationRunTarget?
        /// The type of metadata generation run.
        public let type: MetadataGenerationRunType?

        public init(createdAt: Date? = nil, createdBy: String? = nil, domainId: String, id: String, owningProjectId: String, status: MetadataGenerationRunStatus? = nil, target: MetadataGenerationRunTarget? = nil, type: MetadataGenerationRunType? = nil) {
            self.createdAt = createdAt
            self.createdBy = createdBy
            self.domainId = domainId
            self.id = id
            self.owningProjectId = owningProjectId
            self.status = status
            self.target = target
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case createdAt = "createdAt"
            case createdBy = "createdBy"
            case domainId = "domainId"
            case id = "id"
            case owningProjectId = "owningProjectId"
            case status = "status"
            case target = "target"
            case type = "type"
        }
    }

    public struct GetProjectInput: AWSEncodableShape {
        /// The ID of the Amazon DataZone domain in which the project exists.
        public let domainIdentifier: String
        /// The ID of the project.
        public let identifier: String

        public init(domainIdentifier: String, identifier: String) {
            self.domainIdentifier = domainIdentifier
            self.identifier = identifier
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.domainIdentifier, key: "domainIdentifier")
            request.encodePath(self.identifier, key: "identifier")
        }

        public func validate(name: String) throws {
            try self.validate(self.domainIdentifier, name: "domainIdentifier", parent: name, pattern: "^dzd[-_][a-zA-Z0-9_-]{1,36}$")
            try self.validate(self.identifier, name: "identifier", parent: name, pattern: "^[a-zA-Z0-9_-]{1,36}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetProjectOutput: AWSDecodableShape {
        /// The timestamp of when the project was created.
        public let createdAt: Date?
        /// The Amazon DataZone user who created the project.
        public let createdBy: String
        /// The description of the project.
        public let description: String?
        /// The ID of the Amazon DataZone domain in which the project exists.
        public let domainId: String
        /// Specifies the error message that is returned if the operation cannot be successfully completed.
        public let failureReasons: [ProjectDeletionError]?
        /// The business glossary terms that can be used in the project.
        public let glossaryTerms: [String]?
        /// &gt;The ID of the project.
        public let id: String
        /// The timestamp of when the project was last updated.
        public let lastUpdatedAt: Date?
        /// The name of the project.
        public let name: String
        /// The status of the project.
        public let projectStatus: ProjectStatus?

        public init(createdAt: Date? = nil, createdBy: String, description: String? = nil, domainId: String, failureReasons: [ProjectDeletionError]? = nil, glossaryTerms: [String]? = nil, id: String, lastUpdatedAt: Date? = nil, name: String, projectStatus: ProjectStatus? = nil) {
            self.createdAt = createdAt
            self.createdBy = createdBy
            self.description = description
            self.domainId = domainId
            self.failureReasons = failureReasons
            self.glossaryTerms = glossaryTerms
            self.id = id
            self.lastUpdatedAt = lastUpdatedAt
            self.name = name
            self.projectStatus = projectStatus
        }

        private enum CodingKeys: String, CodingKey {
            case createdAt = "createdAt"
            case createdBy = "createdBy"
            case description = "description"
            case domainId = "domainId"
            case failureReasons = "failureReasons"
            case glossaryTerms = "glossaryTerms"
            case id = "id"
            case lastUpdatedAt = "lastUpdatedAt"
            case name = "name"
            case projectStatus = "projectStatus"
        }
    }

    public struct GetSubscriptionGrantInput: AWSEncodableShape {
        /// The ID of the Amazon DataZone domain in which the subscription grant exists.
        public let domainIdentifier: String
        /// The ID of the subscription grant.
        public let identifier: String

        public init(domainIdentifier: String, identifier: String) {
            self.domainIdentifier = domainIdentifier
            self.identifier = identifier
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.domainIdentifier, key: "domainIdentifier")
            request.encodePath(self.identifier, key: "identifier")
        }

        public func validate(name: String) throws {
            try self.validate(self.domainIdentifier, name: "domainIdentifier", parent: name, pattern: "^dzd[-_][a-zA-Z0-9_-]{1,36}$")
            try self.validate(self.identifier, name: "identifier", parent: name, pattern: "^[a-zA-Z0-9_-]{1,36}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetSubscriptionGrantOutput: AWSDecodableShape {
        /// The assets for which the subscription grant is created.
        public let assets: [SubscribedAsset]?
        /// The timestamp of when the subscription grant is created.
        public let createdAt: Date
        /// The Amazon DataZone user who created the subscription grant.
        public let createdBy: String
        /// The ID of the Amazon DataZone domain in which the subscription grant exists.
        public let domainId: String
        /// The entity to which the subscription is granted.
        public let grantedEntity: GrantedEntity
        /// The ID of the subscription grant.
        public let id: String
        /// The status of the subscription grant.
        public let status: SubscriptionGrantOverallStatus
        /// The identifier of the subscription.
        public let subscriptionId: String?
        /// The subscription target ID associated with the subscription grant.
        public let subscriptionTargetId: String
        /// The timestamp of when the subscription grant was upated.
        public let updatedAt: Date
        /// The Amazon DataZone user who updated the subscription grant.
        public let updatedBy: String?

        public init(assets: [SubscribedAsset]? = nil, createdAt: Date, createdBy: String, domainId: String, grantedEntity: GrantedEntity, id: String, status: SubscriptionGrantOverallStatus, subscriptionId: String? = nil, subscriptionTargetId: String, updatedAt: Date, updatedBy: String? = nil) {
            self.assets = assets
            self.createdAt = createdAt
            self.createdBy = createdBy
            self.domainId = domainId
            self.grantedEntity = grantedEntity
            self.id = id
            self.status = status
            self.subscriptionId = subscriptionId
            self.subscriptionTargetId = subscriptionTargetId
            self.updatedAt = updatedAt
            self.updatedBy = updatedBy
        }

        private enum CodingKeys: String, CodingKey {
            case assets = "assets"
            case createdAt = "createdAt"
            case createdBy = "createdBy"
            case domainId = "domainId"
            case grantedEntity = "grantedEntity"
            case id = "id"
            case status = "status"
            case subscriptionId = "subscriptionId"
            case subscriptionTargetId = "subscriptionTargetId"
            case updatedAt = "updatedAt"
            case updatedBy = "updatedBy"
        }
    }

    public struct GetSubscriptionInput: AWSEncodableShape {
        /// The ID of the Amazon DataZone domain in which the subscription exists.
        public let domainIdentifier: String
        /// The ID of the subscription.
        public let identifier: String

        public init(domainIdentifier: String, identifier: String) {
            self.domainIdentifier = domainIdentifier
            self.identifier = identifier
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.domainIdentifier, key: "domainIdentifier")
            request.encodePath(self.identifier, key: "identifier")
        }

        public func validate(name: String) throws {
            try self.validate(self.domainIdentifier, name: "domainIdentifier", parent: name, pattern: "^dzd[-_][a-zA-Z0-9_-]{1,36}$")
            try self.validate(self.identifier, name: "identifier", parent: name, pattern: "^[a-zA-Z0-9_-]{1,36}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetSubscriptionOutput: AWSDecodableShape {
        /// The timestamp of when the subscription was created.
        public let createdAt: Date
        /// The Amazon DataZone user who created the subscription.
        public let createdBy: String
        /// The ID of the Amazon DataZone domain in which the subscription exists.
        public let domainId: String
        /// The ID of the subscription.
        public let id: String
        /// The retain permissions of the subscription.
        public let retainPermissions: Bool?
        /// The status of the subscription.
        public let status: SubscriptionStatus
        /// The details of the published asset for which the subscription grant is created.
        public let subscribedListing: SubscribedListing
        /// The principal that owns the subscription.
        public let subscribedPrincipal: SubscribedPrincipal
        /// The ID of the subscription request.
        public let subscriptionRequestId: String?
        /// The timestamp of when the subscription was updated.
        public let updatedAt: Date
        /// The Amazon DataZone user who updated the subscription.
        public let updatedBy: String?

        public init(createdAt: Date, createdBy: String, domainId: String, id: String, retainPermissions: Bool? = nil, status: SubscriptionStatus, subscribedListing: SubscribedListing, subscribedPrincipal: SubscribedPrincipal, subscriptionRequestId: String? = nil, updatedAt: Date, updatedBy: String? = nil) {
            self.createdAt = createdAt
            self.createdBy = createdBy
            self.domainId = domainId
            self.id = id
            self.retainPermissions = retainPermissions
            self.status = status
            self.subscribedListing = subscribedListing
            self.subscribedPrincipal = subscribedPrincipal
            self.subscriptionRequestId = subscriptionRequestId
            self.updatedAt = updatedAt
            self.updatedBy = updatedBy
        }

        private enum CodingKeys: String, CodingKey {
            case createdAt = "createdAt"
            case createdBy = "createdBy"
            case domainId = "domainId"
            case id = "id"
            case retainPermissions = "retainPermissions"
            case status = "status"
            case subscribedListing = "subscribedListing"
            case subscribedPrincipal = "subscribedPrincipal"
            case subscriptionRequestId = "subscriptionRequestId"
            case updatedAt = "updatedAt"
            case updatedBy = "updatedBy"
        }
    }

    public struct GetSubscriptionRequestDetailsInput: AWSEncodableShape {
        /// The identifier of the Amazon DataZone domain in which to get the subscription request details.
        public let domainIdentifier: String
        /// The identifier of the subscription request the details of which to get.
        public let identifier: String

        public init(domainIdentifier: String, identifier: String) {
            self.domainIdentifier = domainIdentifier
            self.identifier = identifier
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.domainIdentifier, key: "domainIdentifier")
            request.encodePath(self.identifier, key: "identifier")
        }

        public func validate(name: String) throws {
            try self.validate(self.domainIdentifier, name: "domainIdentifier", parent: name, pattern: "^dzd[-_][a-zA-Z0-9_-]{1,36}$")
            try self.validate(self.identifier, name: "identifier", parent: name, pattern: "^[a-zA-Z0-9_-]{1,36}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetSubscriptionRequestDetailsOutput: AWSDecodableShape {
        /// The timestamp of when the specified subscription request was created.
        public let createdAt: Date
        /// The Amazon DataZone user who created the subscription request.
        public let createdBy: String
        /// The decision comment of the subscription request.
        public let decisionComment: String?
        /// The Amazon DataZone domain of the subscription request.
        public let domainId: String
        /// The identifier of the subscription request.
        public let id: String
        /// The reason for the subscription request.
        public let requestReason: String
        /// The identifier of the Amazon DataZone user who reviewed the subscription request.
        public let reviewerId: String?
        /// The status of the subscription request.
        public let status: SubscriptionRequestStatus
        /// The subscribed listings in the subscription request.
        public let subscribedListings: [SubscribedListing]
        /// The subscribed principals in the subscription request.
        public let subscribedPrincipals: [SubscribedPrincipal]
        /// The timestamp of when the subscription request was updated.
        public let updatedAt: Date
        /// The Amazon DataZone user who updated the subscription request.
        public let updatedBy: String?

        public init(createdAt: Date, createdBy: String, decisionComment: String? = nil, domainId: String, id: String, requestReason: String, reviewerId: String? = nil, status: SubscriptionRequestStatus, subscribedListings: [SubscribedListing], subscribedPrincipals: [SubscribedPrincipal], updatedAt: Date, updatedBy: String? = nil) {
            self.createdAt = createdAt
            self.createdBy = createdBy
            self.decisionComment = decisionComment
            self.domainId = domainId
            self.id = id
            self.requestReason = requestReason
            self.reviewerId = reviewerId
            self.status = status
            self.subscribedListings = subscribedListings
            self.subscribedPrincipals = subscribedPrincipals
            self.updatedAt = updatedAt
            self.updatedBy = updatedBy
        }

        private enum CodingKeys: String, CodingKey {
            case createdAt = "createdAt"
            case createdBy = "createdBy"
            case decisionComment = "decisionComment"
            case domainId = "domainId"
            case id = "id"
            case requestReason = "requestReason"
            case reviewerId = "reviewerId"
            case status = "status"
            case subscribedListings = "subscribedListings"
            case subscribedPrincipals = "subscribedPrincipals"
            case updatedAt = "updatedAt"
            case updatedBy = "updatedBy"
        }
    }

    public struct GetSubscriptionTargetInput: AWSEncodableShape {
        /// The ID of the Amazon DataZone domain in which the subscription target exists.
        public let domainIdentifier: String
        /// The ID of the environment associated with the subscription target.
        public let environmentIdentifier: String
        /// The ID of the subscription target.
        public let identifier: String

        public init(domainIdentifier: String, environmentIdentifier: String, identifier: String) {
            self.domainIdentifier = domainIdentifier
            self.environmentIdentifier = environmentIdentifier
            self.identifier = identifier
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.domainIdentifier, key: "domainIdentifier")
            request.encodePath(self.environmentIdentifier, key: "environmentIdentifier")
            request.encodePath(self.identifier, key: "identifier")
        }

        public func validate(name: String) throws {
            try self.validate(self.domainIdentifier, name: "domainIdentifier", parent: name, pattern: "^dzd[-_][a-zA-Z0-9_-]{1,36}$")
            try self.validate(self.environmentIdentifier, name: "environmentIdentifier", parent: name, pattern: "^[a-zA-Z0-9_-]{1,36}$")
            try self.validate(self.identifier, name: "identifier", parent: name, pattern: "^[a-zA-Z0-9_-]{1,36}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetSubscriptionTargetOutput: AWSDecodableShape {
        /// The asset types associated with the subscription target.
        public let applicableAssetTypes: [String]
        /// The authorized principals of the subscription target.
        public let authorizedPrincipals: [String]
        /// The timestamp of when the subscription target was created.
        public let createdAt: Date
        /// The Amazon DataZone user who created the subscription target.
        public let createdBy: String
        /// The ID of the Amazon DataZone domain in which the subscription target exists.
        public let domainId: String
        /// The ID of the environment associated with the subscription target.
        public let environmentId: String
        /// The ID of the subscription target.
        public let id: String
        /// The manage access role with which the subscription target was created.
        public let manageAccessRole: String
        /// The name of the subscription target.
        public let name: String
        /// The ID of the project associated with the subscription target.
        public let projectId: String
        /// The provider of the subscription target.
        public let provider: String
        /// The configuration of teh subscription target.
        public let subscriptionTargetConfig: [SubscriptionTargetForm]
        /// The type of the subscription target.
        public let type: String
        /// The timestamp of when the subscription target was updated.
        public let updatedAt: Date?
        /// The Amazon DataZone user who updated the subscription target.
        public let updatedBy: String?

        public init(applicableAssetTypes: [String], authorizedPrincipals: [String], createdAt: Date, createdBy: String, domainId: String, environmentId: String, id: String, manageAccessRole: String, name: String, projectId: String, provider: String, subscriptionTargetConfig: [SubscriptionTargetForm], type: String, updatedAt: Date? = nil, updatedBy: String? = nil) {
            self.applicableAssetTypes = applicableAssetTypes
            self.authorizedPrincipals = authorizedPrincipals
            self.createdAt = createdAt
            self.createdBy = createdBy
            self.domainId = domainId
            self.environmentId = environmentId
            self.id = id
            self.manageAccessRole = manageAccessRole
            self.name = name
            self.projectId = projectId
            self.provider = provider
            self.subscriptionTargetConfig = subscriptionTargetConfig
            self.type = type
            self.updatedAt = updatedAt
            self.updatedBy = updatedBy
        }

        private enum CodingKeys: String, CodingKey {
            case applicableAssetTypes = "applicableAssetTypes"
            case authorizedPrincipals = "authorizedPrincipals"
            case createdAt = "createdAt"
            case createdBy = "createdBy"
            case domainId = "domainId"
            case environmentId = "environmentId"
            case id = "id"
            case manageAccessRole = "manageAccessRole"
            case name = "name"
            case projectId = "projectId"
            case provider = "provider"
            case subscriptionTargetConfig = "subscriptionTargetConfig"
            case type = "type"
            case updatedAt = "updatedAt"
            case updatedBy = "updatedBy"
        }
    }

    public struct GetTimeSeriesDataPointInput: AWSEncodableShape {
        /// The ID of the Amazon DataZone domain that houses the asset for which you want to get the data point.
        public let domainIdentifier: String
        /// The ID of the asset for which you want to get the data point.
        public let entityIdentifier: String
        /// The type of the asset for which you want to get the data point.
        public let entityType: TimeSeriesEntityType
        /// The name of the time series form that houses the data point that you want to get.
        public let formName: String
        /// The ID of the data point that you want to get.
        public let identifier: String

        public init(domainIdentifier: String, entityIdentifier: String, entityType: TimeSeriesEntityType, formName: String, identifier: String) {
            self.domainIdentifier = domainIdentifier
            self.entityIdentifier = entityIdentifier
            self.entityType = entityType
            self.formName = formName
            self.identifier = identifier
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.domainIdentifier, key: "domainIdentifier")
            request.encodePath(self.entityIdentifier, key: "entityIdentifier")
            request.encodePath(self.entityType, key: "entityType")
            request.encodeQuery(self.formName, key: "formName")
            request.encodePath(self.identifier, key: "identifier")
        }

        public func validate(name: String) throws {
            try self.validate(self.domainIdentifier, name: "domainIdentifier", parent: name, pattern: "^dzd[-_][a-zA-Z0-9_-]{1,36}$")
            try self.validate(self.entityIdentifier, name: "entityIdentifier", parent: name, pattern: "^[a-zA-Z0-9_-]{1,36}$")
            try self.validate(self.formName, name: "formName", parent: name, max: 128)
            try self.validate(self.formName, name: "formName", parent: name, min: 1)
            try self.validate(self.identifier, name: "identifier", parent: name, pattern: "^[a-zA-Z0-9_-]{1,36}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetTimeSeriesDataPointOutput: AWSDecodableShape {
        /// The ID of the Amazon DataZone domain that houses the asset data point that you want to get.
        public let domainId: String?
        /// The ID of the asset for which you want to get the data point.
        public let entityId: String?
        /// The type of the asset for which you want to get the data point.
        public let entityType: TimeSeriesEntityType?
        /// The time series form that houses the data point that you want to get.
        public let form: TimeSeriesDataPointFormOutput?
        /// The name of the time series form that houses the data point that you want to get.
        public let formName: String?

        public init(domainId: String? = nil, entityId: String? = nil, entityType: TimeSeriesEntityType? = nil, form: TimeSeriesDataPointFormOutput? = nil, formName: String? = nil) {
            self.domainId = domainId
            self.entityId = entityId
            self.entityType = entityType
            self.form = form
            self.formName = formName
        }

        private enum CodingKeys: String, CodingKey {
            case domainId = "domainId"
            case entityId = "entityId"
            case entityType = "entityType"
            case form = "form"
            case formName = "formName"
        }
    }

    public struct GetUserProfileInput: AWSEncodableShape {
        /// the ID of the Amazon DataZone domain the data portal of which you want to get.
        public let domainIdentifier: String
        /// The type of the user profile.
        public let type: UserProfileType?
        /// The identifier of the user for which you want to get the user profile.
        public let userIdentifier: String

        public init(domainIdentifier: String, type: UserProfileType? = nil, userIdentifier: String) {
            self.domainIdentifier = domainIdentifier
            self.type = type
            self.userIdentifier = userIdentifier
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.domainIdentifier, key: "domainIdentifier")
            request.encodeQuery(self.type, key: "type")
            request.encodePath(self.userIdentifier, key: "userIdentifier")
        }

        public func validate(name: String) throws {
            try self.validate(self.domainIdentifier, name: "domainIdentifier", parent: name, pattern: "^dzd[-_][a-zA-Z0-9_-]{1,36}$")
            try self.validate(self.userIdentifier, name: "userIdentifier", parent: name, pattern: "(^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}$|^[a-zA-Z_0-9+=,.@-]+$|^arn:aws:iam::\\d{12}:.+$)")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetUserProfileOutput: AWSDecodableShape {
        public let details: UserProfileDetails?
        /// the identifier of the Amazon DataZone domain of which you want to get the user profile.
        public let domainId: String?
        /// The identifier of the user profile.
        public let id: String?
        /// The status of the user profile.
        public let status: UserProfileStatus?
        /// The type of the user profile.
        public let type: UserProfileType?

        public init(details: UserProfileDetails? = nil, domainId: String? = nil, id: String? = nil, status: UserProfileStatus? = nil, type: UserProfileType? = nil) {
            self.details = details
            self.domainId = domainId
            self.id = id
            self.status = status
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case details = "details"
            case domainId = "domainId"
            case id = "id"
            case status = "status"
            case type = "type"
        }
    }

    public struct GlossaryItem: AWSDecodableShape {
        /// The timestamp of when the glossary was created.
        public let createdAt: Date?
        /// The Amazon DataZone user who created the glossary.
        public let createdBy: String?
        /// The business glossary description.
        public let description: String?
        /// The identifier of the Amazon DataZone domain in which the business glossary exists.
        public let domainId: String
        /// The identifier of the glossary.
        public let id: String
        /// The name of the glossary.
        public let name: String
        /// The identifier of the project that owns the business glosary.
        public let owningProjectId: String
        /// The business glossary status.
        public let status: GlossaryStatus
        /// The timestamp of when the business glossary was updated.
        public let updatedAt: Date?
        /// The Amazon DataZone user who updated the business glossary.
        public let updatedBy: String?

        public init(createdAt: Date? = nil, createdBy: String? = nil, description: String? = nil, domainId: String, id: String, name: String, owningProjectId: String, status: GlossaryStatus, updatedAt: Date? = nil, updatedBy: String? = nil) {
            self.createdAt = createdAt
            self.createdBy = createdBy
            self.description = description
            self.domainId = domainId
            self.id = id
            self.name = name
            self.owningProjectId = owningProjectId
            self.status = status
            self.updatedAt = updatedAt
            self.updatedBy = updatedBy
        }

        private enum CodingKeys: String, CodingKey {
            case createdAt = "createdAt"
            case createdBy = "createdBy"
            case description = "description"
            case domainId = "domainId"
            case id = "id"
            case name = "name"
            case owningProjectId = "owningProjectId"
            case status = "status"
            case updatedAt = "updatedAt"
            case updatedBy = "updatedBy"
        }
    }

    public struct GlossaryTermItem: AWSDecodableShape {
        /// The timestamp of when a business glossary term was created.
        public let createdAt: Date?
        /// The Amazon DataZone user who created the business glossary.
        public let createdBy: String?
        /// The identifier of the Amazon DataZone domain in which the business glossary exists.
        public let domainId: String
        /// The identifier of the business glossary to which the term belongs.
        public let glossaryId: String
        /// The identifier of the business glossary term.
        public let id: String
        /// The long description of the business glossary term.
        public let longDescription: String?
        /// The name of the business glossary term.
        public let name: String
        /// The short description of the business glossary term.
        public let shortDescription: String?
        /// The status of the business glossary term.
        public let status: GlossaryTermStatus
        /// The relations of the business glossary term.
        public let termRelations: TermRelations?
        /// The timestamp of when a business glossary term was updated.
        public let updatedAt: Date?
        /// The Amazon DataZone user who updated the business glossary term.
        public let updatedBy: String?

        public init(createdAt: Date? = nil, createdBy: String? = nil, domainId: String, glossaryId: String, id: String, longDescription: String? = nil, name: String, shortDescription: String? = nil, status: GlossaryTermStatus, termRelations: TermRelations? = nil, updatedAt: Date? = nil, updatedBy: String? = nil) {
            self.createdAt = createdAt
            self.createdBy = createdBy
            self.domainId = domainId
            self.glossaryId = glossaryId
            self.id = id
            self.longDescription = longDescription
            self.name = name
            self.shortDescription = shortDescription
            self.status = status
            self.termRelations = termRelations
            self.updatedAt = updatedAt
            self.updatedBy = updatedBy
        }

        private enum CodingKeys: String, CodingKey {
            case createdAt = "createdAt"
            case createdBy = "createdBy"
            case domainId = "domainId"
            case glossaryId = "glossaryId"
            case id = "id"
            case longDescription = "longDescription"
            case name = "name"
            case shortDescription = "shortDescription"
            case status = "status"
            case termRelations = "termRelations"
            case updatedAt = "updatedAt"
            case updatedBy = "updatedBy"
        }
    }

    public struct GlueRunConfigurationInput: AWSEncodableShape {
        /// Specifies whether to automatically import data quality metrics as part of the data source run.
        public let autoImportDataQualityResult: Bool?
        /// The data access role included in the configuration details of the Amazon Web Services Glue data source.
        public let dataAccessRole: String?
        /// The relational filter configurations included in the configuration details of the Amazon Web Services Glue data source.
        public let relationalFilterConfigurations: [RelationalFilterConfiguration]

        public init(autoImportDataQualityResult: Bool? = nil, dataAccessRole: String? = nil, relationalFilterConfigurations: [RelationalFilterConfiguration]) {
            self.autoImportDataQualityResult = autoImportDataQualityResult
            self.dataAccessRole = dataAccessRole
            self.relationalFilterConfigurations = relationalFilterConfigurations
        }

        private enum CodingKeys: String, CodingKey {
            case autoImportDataQualityResult = "autoImportDataQualityResult"
            case dataAccessRole = "dataAccessRole"
            case relationalFilterConfigurations = "relationalFilterConfigurations"
        }
    }

    public struct GlueRunConfigurationOutput: AWSDecodableShape {
        /// The Amazon Web Services account ID included in the configuration details of the Amazon Web Services Glue data source.
        public let accountId: String?
        /// Specifies whether to automatically import data quality metrics as part of the data source run.
        public let autoImportDataQualityResult: Bool?
        /// The data access role included in the configuration details of the Amazon Web Services Glue data source.
        public let dataAccessRole: String?
        /// The Amazon Web Services region included in the configuration details of the Amazon Web Services Glue data source.
        public let region: String?
        /// The relational filter configurations included in the configuration details of the Amazon Web Services Glue data source.
        public let relationalFilterConfigurations: [RelationalFilterConfiguration]

        public init(accountId: String? = nil, autoImportDataQualityResult: Bool? = nil, dataAccessRole: String? = nil, region: String? = nil, relationalFilterConfigurations: [RelationalFilterConfiguration]) {
            self.accountId = accountId
            self.autoImportDataQualityResult = autoImportDataQualityResult
            self.dataAccessRole = dataAccessRole
            self.region = region
            self.relationalFilterConfigurations = relationalFilterConfigurations
        }

        private enum CodingKeys: String, CodingKey {
            case accountId = "accountId"
            case autoImportDataQualityResult = "autoImportDataQualityResult"
            case dataAccessRole = "dataAccessRole"
            case region = "region"
            case relationalFilterConfigurations = "relationalFilterConfigurations"
        }
    }

    public struct GroupDetails: AWSDecodableShape {
        /// The identifier of the group in Amazon DataZone.
        public let groupId: String

        public init(groupId: String) {
            self.groupId = groupId
        }

        private enum CodingKeys: String, CodingKey {
            case groupId = "groupId"
        }
    }

    public struct GroupProfileSummary: AWSDecodableShape {
        /// The ID of the Amazon DataZone domain of a group profile.
        public let domainId: String?
        /// The group name of a group profile.
        public let groupName: String?
        /// The ID of a group profile.
        public let id: String?
        /// The status of a group profile.
        public let status: GroupProfileStatus?

        public init(domainId: String? = nil, groupName: String? = nil, id: String? = nil, status: GroupProfileStatus? = nil) {
            self.domainId = domainId
            self.groupName = groupName
            self.id = id
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case domainId = "domainId"
            case groupName = "groupName"
            case id = "id"
            case status = "status"
        }
    }

    public struct IamUserProfileDetails: AWSDecodableShape {
        /// The ARN of an IAM user profile in Amazon DataZone.
        public let arn: String?

        public init(arn: String? = nil) {
            self.arn = arn
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
        }
    }

    public struct Import: AWSDecodableShape {
        /// The name of the import.
        public let name: String
        /// The revision of the import.
        public let revision: String

        public init(name: String, revision: String) {
            self.name = name
            self.revision = revision
        }

        private enum CodingKeys: String, CodingKey {
            case name = "name"
            case revision = "revision"
        }
    }

    public struct ListAssetRevisionsInput: AWSEncodableShape {
        /// The identifier of the domain.
        public let domainIdentifier: String
        /// The identifier of the asset.
        public let identifier: String
        /// The maximum number of revisions to return in a single call to ListAssetRevisions. When the number of revisions to be listed is greater than the value of MaxResults, the response contains a NextToken value that you can use in a subsequent call to ListAssetRevisions to list the next set of revisions.
        public let maxResults: Int?
        /// When the number of revisions is greater than the default value for the MaxResults parameter, or if you explicitly specify a value for MaxResults that is less than the number of revisions, the response includes a pagination token named NextToken. You can specify this NextToken value in a subsequent call to ListAssetRevisions to list the next set of revisions.
        public let nextToken: String?

        public init(domainIdentifier: String, identifier: String, maxResults: Int? = nil, nextToken: String? = nil) {
            self.domainIdentifier = domainIdentifier
            self.identifier = identifier
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.domainIdentifier, key: "domainIdentifier")
            request.encodePath(self.identifier, key: "identifier")
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
        }

        public func validate(name: String) throws {
            try self.validate(self.domainIdentifier, name: "domainIdentifier", parent: name, pattern: "^dzd[-_][a-zA-Z0-9_-]{1,36}$")
            try self.validate(self.identifier, name: "identifier", parent: name, pattern: "^[a-zA-Z0-9_-]{1,36}$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 50)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 8192)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListAssetRevisionsOutput: AWSDecodableShape {
        /// The results of the ListAssetRevisions action.
        public let items: [AssetRevision]?
        /// When the number of revisions is greater than the default value for the MaxResults parameter, or if you explicitly specify a value for MaxResults that is less than the number of revisions, the response includes a pagination token named NextToken. You can specify this NextToken value in a subsequent call to ListAssetRevisions to list the next set of revisions.
        public let nextToken: String?

        public init(items: [AssetRevision]? = nil, nextToken: String? = nil) {
            self.items = items
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case items = "items"
            case nextToken = "nextToken"
        }
    }

    public struct ListDataSourceRunActivitiesInput: AWSEncodableShape {
        /// The identifier of the Amazon DataZone domain in which to list data source run activities.
        public let domainIdentifier: String
        /// The identifier of the data source run.
        public let identifier: String
        /// The maximum number of activities to return in a single call to ListDataSourceRunActivities. When the number of activities to be listed is greater than the value of MaxResults, the response contains a NextToken value that you can use in a subsequent call to ListDataSourceRunActivities to list the next set of activities.
        public let maxResults: Int?
        /// When the number of activities is greater than the default value for the MaxResults parameter, or if you explicitly specify a value for MaxResults that is less than the number of activities, the response includes a pagination token named NextToken. You can specify this NextToken value in a subsequent call to ListDataSourceRunActivities to list the next set of activities.
        public let nextToken: String?
        /// The status of the data source run.
        public let status: DataAssetActivityStatus?

        public init(domainIdentifier: String, identifier: String, maxResults: Int? = nil, nextToken: String? = nil, status: DataAssetActivityStatus? = nil) {
            self.domainIdentifier = domainIdentifier
            self.identifier = identifier
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.status = status
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.domainIdentifier, key: "domainIdentifier")
            request.encodePath(self.identifier, key: "identifier")
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
            request.encodeQuery(self.status, key: "status")
        }

        public func validate(name: String) throws {
            try self.validate(self.domainIdentifier, name: "domainIdentifier", parent: name, pattern: "^dzd[-_][a-zA-Z0-9_-]{1,36}$")
            try self.validate(self.identifier, name: "identifier", parent: name, pattern: "^[a-zA-Z0-9_-]{1,36}$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 50)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 8192)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListDataSourceRunActivitiesOutput: AWSDecodableShape {
        /// The results of the ListDataSourceRunActivities action.
        public let items: [DataSourceRunActivity]
        /// When the number of activities is greater than the default value for the MaxResults parameter, or if you explicitly specify a value for MaxResults that is less than the number of activities, the response includes a pagination token named NextToken. You can specify this NextToken value in a subsequent call to ListDataSourceRunActivities to list the next set of activities.
        public let nextToken: String?

        public init(items: [DataSourceRunActivity], nextToken: String? = nil) {
            self.items = items
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case items = "items"
            case nextToken = "nextToken"
        }
    }

    public struct ListDataSourceRunsInput: AWSEncodableShape {
        /// The identifier of the data source.
        public let dataSourceIdentifier: String
        /// The identifier of the Amazon DataZone domain in which to invoke the ListDataSourceRuns action.
        public let domainIdentifier: String
        /// The maximum number of runs to return in a single call to ListDataSourceRuns. When the number of runs to be listed is greater than the value of MaxResults, the response contains a NextToken value that you can use in a subsequent call to ListDataSourceRuns to list the next set of runs.
        public let maxResults: Int?
        /// When the number of runs is greater than the default value for the MaxResults parameter, or if you explicitly specify a value for MaxResults that is less than the number of runs, the response includes a pagination token named NextToken. You can specify this NextToken value in a subsequent call to ListDataSourceRuns to list the next set of runs.
        public let nextToken: String?
        /// The status of the data source.
        public let status: DataSourceRunStatus?

        public init(dataSourceIdentifier: String, domainIdentifier: String, maxResults: Int? = nil, nextToken: String? = nil, status: DataSourceRunStatus? = nil) {
            self.dataSourceIdentifier = dataSourceIdentifier
            self.domainIdentifier = domainIdentifier
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.status = status
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.dataSourceIdentifier, key: "dataSourceIdentifier")
            request.encodePath(self.domainIdentifier, key: "domainIdentifier")
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
            request.encodeQuery(self.status, key: "status")
        }

        public func validate(name: String) throws {
            try self.validate(self.dataSourceIdentifier, name: "dataSourceIdentifier", parent: name, pattern: "^[a-zA-Z0-9_-]{1,36}$")
            try self.validate(self.domainIdentifier, name: "domainIdentifier", parent: name, pattern: "^dzd[-_][a-zA-Z0-9_-]{1,36}$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 50)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 8192)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListDataSourceRunsOutput: AWSDecodableShape {
        /// The results of the ListDataSourceRuns action.
        public let items: [DataSourceRunSummary]
        /// When the number of runs is greater than the default value for the MaxResults parameter, or if you explicitly specify a value for MaxResults that is less than the number of runs, the response includes a pagination token named NextToken. You can specify this NextToken value in a subsequent call to ListDataSourceRuns to list the next set of runs.
        public let nextToken: String?

        public init(items: [DataSourceRunSummary], nextToken: String? = nil) {
            self.items = items
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case items = "items"
            case nextToken = "nextToken"
        }
    }

    public struct ListDataSourcesInput: AWSEncodableShape {
        /// The identifier of the Amazon DataZone domain in which to list the data sources.
        public let domainIdentifier: String
        /// The identifier of the environment in which to list the data sources.
        public let environmentIdentifier: String?
        /// The maximum number of data sources to return in a single call to ListDataSources. When the number of data sources to be listed is greater than the value of MaxResults, the response contains a NextToken value that you can use in a subsequent call to ListDataSources to list the next set of data sources.
        public let maxResults: Int?
        /// The name of the data source.
        public let name: String?
        /// When the number of data sources is greater than the default value for the MaxResults parameter, or if you explicitly specify a value for MaxResults that is less than the number of data sources, the response includes a pagination token named NextToken. You can specify this NextToken value in a subsequent call to ListDataSources to list the next set of data sources.
        public let nextToken: String?
        /// The identifier of the project in which to list data sources.
        public let projectIdentifier: String
        /// The status of the data source.
        public let status: DataSourceStatus?
        /// The type of the data source.
        public let type: String?

        public init(domainIdentifier: String, environmentIdentifier: String? = nil, maxResults: Int? = nil, name: String? = nil, nextToken: String? = nil, projectIdentifier: String, status: DataSourceStatus? = nil, type: String? = nil) {
            self.domainIdentifier = domainIdentifier
            self.environmentIdentifier = environmentIdentifier
            self.maxResults = maxResults
            self.name = name
            self.nextToken = nextToken
            self.projectIdentifier = projectIdentifier
            self.status = status
            self.type = type
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.domainIdentifier, key: "domainIdentifier")
            request.encodeQuery(self.environmentIdentifier, key: "environmentIdentifier")
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.name, key: "name")
            request.encodeQuery(self.nextToken, key: "nextToken")
            request.encodeQuery(self.projectIdentifier, key: "projectIdentifier")
            request.encodeQuery(self.status, key: "status")
            request.encodeQuery(self.type, key: "type")
        }

        public func validate(name: String) throws {
            try self.validate(self.domainIdentifier, name: "domainIdentifier", parent: name, pattern: "^dzd[-_][a-zA-Z0-9_-]{1,36}$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 50)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, max: 256)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 8192)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.type, name: "type", parent: name, max: 256)
            try self.validate(self.type, name: "type", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListDataSourcesOutput: AWSDecodableShape {
        /// The results of the ListDataSources action.
        public let items: [DataSourceSummary]
        /// When the number of data sources is greater than the default value for the MaxResults parameter, or if you explicitly specify a value for MaxResults that is less than the number of data sources, the response includes a pagination token named NextToken. You can specify this NextToken value in a subsequent call to ListDataSources to list the next set of data sources.
        public let nextToken: String?

        public init(items: [DataSourceSummary], nextToken: String? = nil) {
            self.items = items
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case items = "items"
            case nextToken = "nextToken"
        }
    }

    public struct ListDomainsInput: AWSEncodableShape {
        /// The maximum number of domains to return in a single call to ListDomains. When the number of domains to be listed is greater than the value of MaxResults, the response contains a NextToken value that you can use in a subsequent call to ListDomains to list the next set of domains.
        public let maxResults: Int?
        /// When the number of domains is greater than the default value for the MaxResults parameter, or if you explicitly specify a value for MaxResults that is less than the number of domains, the response includes a pagination token named NextToken. You can specify this NextToken value in a subsequent call to ListDomains to list the next set of domains.
        public let nextToken: String?
        /// The status of the data source.
        public let status: DomainStatus?

        public init(maxResults: Int? = nil, nextToken: String? = nil, status: DomainStatus? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.status = status
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
            request.encodeQuery(self.status, key: "status")
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 25)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 8192)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListDomainsOutput: AWSDecodableShape {
        /// The results of the ListDomains action.
        public let items: [DomainSummary]
        /// When the number of domains is greater than the default value for the MaxResults parameter, or if you explicitly specify a value for MaxResults that is less than the number of domains, the response includes a pagination token named NextToken. You can specify this NextToken value in a subsequent call to ListDomains to list the next set of domains.
        public let nextToken: String?

        public init(items: [DomainSummary], nextToken: String? = nil) {
            self.items = items
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case items = "items"
            case nextToken = "nextToken"
        }
    }

    public struct ListEnvironmentBlueprintConfigurationsInput: AWSEncodableShape {
        /// The identifier of the Amazon DataZone domain.
        public let domainIdentifier: String
        /// The maximum number of blueprint configurations to return in a single call to ListEnvironmentBlueprintConfigurations. When the number of configurations to be listed is greater than the value of MaxResults, the response contains a NextToken value that you can use in a subsequent call to ListEnvironmentBlueprintConfigurations to list the next set of configurations.
        public let maxResults: Int?
        /// When the number of blueprint configurations is greater than the default value for the MaxResults parameter, or if you explicitly specify a value for MaxResults that is less than the number of configurations, the response includes a pagination token named NextToken. You can specify this NextToken value in a subsequent call to ListEnvironmentBlueprintConfigurations to list the next set of configurations.
        public let nextToken: String?

        public init(domainIdentifier: String, maxResults: Int? = nil, nextToken: String? = nil) {
            self.domainIdentifier = domainIdentifier
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.domainIdentifier, key: "domainIdentifier")
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
        }

        public func validate(name: String) throws {
            try self.validate(self.domainIdentifier, name: "domainIdentifier", parent: name, pattern: "^dzd[-_][a-zA-Z0-9_-]{1,36}$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 50)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 8192)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListEnvironmentBlueprintConfigurationsOutput: AWSDecodableShape {
        /// The results of the ListEnvironmentBlueprintConfigurations action.
        public let items: [EnvironmentBlueprintConfigurationItem]?
        /// When the number of blueprint configurations is greater than the default value for the MaxResults parameter, or if you explicitly specify a value for MaxResults that is less than the number of configurations, the response includes a pagination token named NextToken. You can specify this NextToken value in a subsequent call to ListEnvironmentBlueprintConfigurations to list the next set of configurations.
        public let nextToken: String?

        public init(items: [EnvironmentBlueprintConfigurationItem]? = nil, nextToken: String? = nil) {
            self.items = items
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case items = "items"
            case nextToken = "nextToken"
        }
    }

    public struct ListEnvironmentBlueprintsInput: AWSEncodableShape {
        /// The identifier of the Amazon DataZone domain.
        public let domainIdentifier: String
        /// Specifies whether the environment blueprint is managed by Amazon DataZone.
        public let managed: Bool?
        /// The maximum number of blueprints to return in a single call to ListEnvironmentBlueprints. When the number of blueprints to be listed is greater than the value of MaxResults, the response contains a NextToken value that you can use in a subsequent call to ListEnvironmentBlueprints to list the next set of blueprints.
        public let maxResults: Int?
        /// The name of the Amazon DataZone environment.
        public let name: String?
        /// When the number of blueprints in the environment is greater than the default value for the MaxResults parameter, or if you explicitly specify a value for MaxResults that is less than the number of blueprints in the environment, the response includes a pagination token named NextToken. You can specify this NextToken value in a subsequent call to ListEnvironmentBlueprintsto list the next set of blueprints.
        public let nextToken: String?

        public init(domainIdentifier: String, managed: Bool? = nil, maxResults: Int? = nil, name: String? = nil, nextToken: String? = nil) {
            self.domainIdentifier = domainIdentifier
            self.managed = managed
            self.maxResults = maxResults
            self.name = name
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.domainIdentifier, key: "domainIdentifier")
            request.encodeQuery(self.managed, key: "managed")
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.name, key: "name")
            request.encodeQuery(self.nextToken, key: "nextToken")
        }

        public func validate(name: String) throws {
            try self.validate(self.domainIdentifier, name: "domainIdentifier", parent: name, pattern: "^dzd[-_][a-zA-Z0-9_-]{1,36}$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 50)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, max: 64)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[\\w -]+$")
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 8192)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListEnvironmentBlueprintsOutput: AWSDecodableShape {
        /// The results of the ListEnvironmentBlueprints action.
        public let items: [EnvironmentBlueprintSummary]
        /// When the number of blueprints in the environment is greater than the default value for the MaxResults parameter, or if you explicitly specify a value for MaxResults that is less than the number of blueprints in the environment, the response includes a pagination token named NextToken. You can specify this NextToken value in a subsequent call to ListEnvironmentBlueprintsto list the next set of blueprints.
        public let nextToken: String?

        public init(items: [EnvironmentBlueprintSummary], nextToken: String? = nil) {
            self.items = items
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case items = "items"
            case nextToken = "nextToken"
        }
    }

    public struct ListEnvironmentProfilesInput: AWSEncodableShape {
        /// The identifier of the Amazon Web Services account where you want to list environment profiles.
        public let awsAccountId: String?
        /// The Amazon Web Services region where you want to list environment profiles.
        public let awsAccountRegion: String?
        /// The identifier of the Amazon DataZone domain.
        public let domainIdentifier: String
        /// The identifier of the blueprint that was used to create the environment profiles that you want to list.
        public let environmentBlueprintIdentifier: String?
        /// The maximum number of environment profiles to return in a single call to ListEnvironmentProfiles. When the number of environment profiles to be listed is greater than the value of MaxResults, the response contains a NextToken value that you can use in a subsequent call to ListEnvironmentProfiles to list the next set of environment profiles.
        public let maxResults: Int?
        public let name: String?
        /// When the number of environment profiles is greater than the default value for the MaxResults parameter, or if you explicitly specify a value for MaxResults that is less than the number of environment profiles, the response includes a pagination token named NextToken. You can specify this NextToken value in a subsequent call to ListEnvironmentProfiles to list the next set of environment profiles.
        public let nextToken: String?
        /// The identifier of the Amazon DataZone project.
        public let projectIdentifier: String?

        public init(awsAccountId: String? = nil, awsAccountRegion: String? = nil, domainIdentifier: String, environmentBlueprintIdentifier: String? = nil, maxResults: Int? = nil, name: String? = nil, nextToken: String? = nil, projectIdentifier: String? = nil) {
            self.awsAccountId = awsAccountId
            self.awsAccountRegion = awsAccountRegion
            self.domainIdentifier = domainIdentifier
            self.environmentBlueprintIdentifier = environmentBlueprintIdentifier
            self.maxResults = maxResults
            self.name = name
            self.nextToken = nextToken
            self.projectIdentifier = projectIdentifier
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.awsAccountId, key: "awsAccountId")
            request.encodeQuery(self.awsAccountRegion, key: "awsAccountRegion")
            request.encodePath(self.domainIdentifier, key: "domainIdentifier")
            request.encodeQuery(self.environmentBlueprintIdentifier, key: "environmentBlueprintIdentifier")
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.name, key: "name")
            request.encodeQuery(self.nextToken, key: "nextToken")
            request.encodeQuery(self.projectIdentifier, key: "projectIdentifier")
        }

        public func validate(name: String) throws {
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, pattern: "^\\d{12}$")
            try self.validate(self.awsAccountRegion, name: "awsAccountRegion", parent: name, pattern: "^[a-z]{2}-[a-z]{4,10}-\\d$")
            try self.validate(self.domainIdentifier, name: "domainIdentifier", parent: name, pattern: "^dzd[-_][a-zA-Z0-9_-]{1,36}$")
            try self.validate(self.environmentBlueprintIdentifier, name: "environmentBlueprintIdentifier", parent: name, pattern: "^[a-zA-Z0-9_-]{1,36}$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 50)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, max: 64)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[\\w -]+$")
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 8192)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.projectIdentifier, name: "projectIdentifier", parent: name, pattern: "^[a-zA-Z0-9_-]{1,36}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListEnvironmentProfilesOutput: AWSDecodableShape {
        /// The results of the ListEnvironmentProfiles action.
        public let items: [EnvironmentProfileSummary]
        /// When the number of environment profiles is greater than the default value for the MaxResults parameter, or if you explicitly specify a value for MaxResults that is less than the number of environment profiles, the response includes a pagination token named NextToken. You can specify this NextToken value in a subsequent call to ListEnvironmentProfiles to list the next set of environment profiles.
        public let nextToken: String?

        public init(items: [EnvironmentProfileSummary], nextToken: String? = nil) {
            self.items = items
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case items = "items"
            case nextToken = "nextToken"
        }
    }

    public struct ListEnvironmentsInput: AWSEncodableShape {
        /// The identifier of the Amazon Web Services account where you want to list environments.
        public let awsAccountId: String?
        /// The Amazon Web Services region where you want to list environments.
        public let awsAccountRegion: String?
        /// The identifier of the Amazon DataZone domain.
        public let domainIdentifier: String
        /// The identifier of the Amazon DataZone blueprint.
        public let environmentBlueprintIdentifier: String?
        /// The identifier of the environment profile.
        public let environmentProfileIdentifier: String?
        /// The maximum number of environments to return in a single call to ListEnvironments. When the number of environments to be listed is greater than the value of MaxResults, the response contains a NextToken value that you can use in a subsequent call to ListEnvironments to list the next set of environments.
        public let maxResults: Int?
        /// The name of the environment.
        public let name: String?
        /// When the number of environments is greater than the default value for the MaxResults parameter, or if you explicitly specify a value for MaxResults that is less than the number of environments, the response includes a pagination token named NextToken. You can specify this NextToken value in a subsequent call to ListEnvironments to list the next set of environments.
        public let nextToken: String?
        /// The identifier of the Amazon DataZone project.
        public let projectIdentifier: String
        /// The provider of the environment.
        public let provider: String?
        /// The status of the environments that you want to list.
        public let status: EnvironmentStatus?

        public init(awsAccountId: String? = nil, awsAccountRegion: String? = nil, domainIdentifier: String, environmentBlueprintIdentifier: String? = nil, environmentProfileIdentifier: String? = nil, maxResults: Int? = nil, name: String? = nil, nextToken: String? = nil, projectIdentifier: String, provider: String? = nil, status: EnvironmentStatus? = nil) {
            self.awsAccountId = awsAccountId
            self.awsAccountRegion = awsAccountRegion
            self.domainIdentifier = domainIdentifier
            self.environmentBlueprintIdentifier = environmentBlueprintIdentifier
            self.environmentProfileIdentifier = environmentProfileIdentifier
            self.maxResults = maxResults
            self.name = name
            self.nextToken = nextToken
            self.projectIdentifier = projectIdentifier
            self.provider = provider
            self.status = status
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.awsAccountId, key: "awsAccountId")
            request.encodeQuery(self.awsAccountRegion, key: "awsAccountRegion")
            request.encodePath(self.domainIdentifier, key: "domainIdentifier")
            request.encodeQuery(self.environmentBlueprintIdentifier, key: "environmentBlueprintIdentifier")
            request.encodeQuery(self.environmentProfileIdentifier, key: "environmentProfileIdentifier")
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.name, key: "name")
            request.encodeQuery(self.nextToken, key: "nextToken")
            request.encodeQuery(self.projectIdentifier, key: "projectIdentifier")
            request.encodeQuery(self.provider, key: "provider")
            request.encodeQuery(self.status, key: "status")
        }

        public func validate(name: String) throws {
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, pattern: "^\\d{12}$")
            try self.validate(self.awsAccountRegion, name: "awsAccountRegion", parent: name, pattern: "^[a-z]{2}-[a-z]{4,10}-\\d$")
            try self.validate(self.domainIdentifier, name: "domainIdentifier", parent: name, pattern: "^dzd[-_][a-zA-Z0-9_-]{1,36}$")
            try self.validate(self.environmentBlueprintIdentifier, name: "environmentBlueprintIdentifier", parent: name, pattern: "^[a-zA-Z0-9_-]{1,36}$")
            try self.validate(self.environmentProfileIdentifier, name: "environmentProfileIdentifier", parent: name, pattern: "^[a-zA-Z0-9_-]{1,36}$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 50)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 8192)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.projectIdentifier, name: "projectIdentifier", parent: name, pattern: "^[a-zA-Z0-9_-]{1,36}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListEnvironmentsOutput: AWSDecodableShape {
        /// The results of the ListEnvironments action.
        public let items: [EnvironmentSummary]
        /// When the number of environments is greater than the default value for the MaxResults parameter, or if you explicitly specify a value for MaxResults that is less than the number of environments, the response includes a pagination token named NextToken. You can specify this NextToken value in a subsequent call to ListEnvironments to list the next set of environments.
        public let nextToken: String?

        public init(items: [EnvironmentSummary], nextToken: String? = nil) {
            self.items = items
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case items = "items"
            case nextToken = "nextToken"
        }
    }

    public struct ListMetadataGenerationRunsInput: AWSEncodableShape {
        /// The ID of the Amazon DataZone domain where you want to list metadata generation runs.
        public let domainIdentifier: String
        /// The maximum number of metadata generation runs to return in a single call to ListMetadataGenerationRuns. When the number of metadata generation runs to be listed is greater than the value of MaxResults, the response contains a NextToken value that you can use in a subsequent call to ListMetadataGenerationRuns to list the next set of revisions.
        public let maxResults: Int?
        /// When the number of metadata generation runs is greater than the default value for the MaxResults parameter, or if you explicitly specify a value for MaxResults that is less than the number of metadata generation runs, the response includes a pagination token named NextToken. You can specify this NextToken value in a subsequent call to ListMetadataGenerationRuns to list the next set of revisions.
        public let nextToken: String?
        /// The status of the metadata generation runs.
        public let status: MetadataGenerationRunStatus?
        /// The type of the metadata generation runs.
        public let type: MetadataGenerationRunType?

        public init(domainIdentifier: String, maxResults: Int? = nil, nextToken: String? = nil, status: MetadataGenerationRunStatus? = nil, type: MetadataGenerationRunType? = nil) {
            self.domainIdentifier = domainIdentifier
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.status = status
            self.type = type
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.domainIdentifier, key: "domainIdentifier")
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
            request.encodeQuery(self.status, key: "status")
            request.encodeQuery(self.type, key: "type")
        }

        public func validate(name: String) throws {
            try self.validate(self.domainIdentifier, name: "domainIdentifier", parent: name, pattern: "^dzd[-_][a-zA-Z0-9_-]{1,36}$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 50)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 8192)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListMetadataGenerationRunsOutput: AWSDecodableShape {
        /// The results of the ListMetadataGenerationRuns action.
        public let items: [MetadataGenerationRunItem]?
        /// When the number of metadata generation runs is greater than the default value for the MaxResults parameter, or if you explicitly specify a value for MaxResults that is less than the number of metadata generation runs, the response includes a pagination token named NextToken. You can specify this NextToken value in a subsequent call to ListMetadataGenerationRuns to list the next set of revisions.
        public let nextToken: String?

        public init(items: [MetadataGenerationRunItem]? = nil, nextToken: String? = nil) {
            self.items = items
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case items = "items"
            case nextToken = "nextToken"
        }
    }

    public struct ListNotificationsInput: AWSEncodableShape {
        /// The time after which you want to list notifications.
        public let afterTimestamp: Date?
        /// The time before which you want to list notifications.
        public let beforeTimestamp: Date?
        /// The identifier of the Amazon DataZone domain.
        public let domainIdentifier: String
        /// The maximum number of notifications to return in a single call to ListNotifications. When the number of notifications to be listed is greater than the value of MaxResults, the response contains a NextToken value that you can use in a subsequent call to ListNotifications to list the next set of notifications.
        public let maxResults: Int?
        /// When the number of notifications is greater than the default value for the MaxResults parameter, or if you explicitly specify a value for MaxResults that is less than the number of notifications, the response includes a pagination token named NextToken. You can specify this NextToken value in a subsequent call to ListNotifications to list the next set of notifications.
        public let nextToken: String?
        /// The subjects of notifications.
        public let subjects: [String]?
        /// The task status of notifications.
        public let taskStatus: TaskStatus?
        /// The type of notifications.
        public let type: NotificationType

        public init(afterTimestamp: Date? = nil, beforeTimestamp: Date? = nil, domainIdentifier: String, maxResults: Int? = nil, nextToken: String? = nil, subjects: [String]? = nil, taskStatus: TaskStatus? = nil, type: NotificationType) {
            self.afterTimestamp = afterTimestamp
            self.beforeTimestamp = beforeTimestamp
            self.domainIdentifier = domainIdentifier
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.subjects = subjects
            self.taskStatus = taskStatus
            self.type = type
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.afterTimestamp, key: "afterTimestamp")
            request.encodeQuery(self.beforeTimestamp, key: "beforeTimestamp")
            request.encodePath(self.domainIdentifier, key: "domainIdentifier")
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
            request.encodeQuery(self.subjects, key: "subjects")
            request.encodeQuery(self.taskStatus, key: "taskStatus")
            request.encodeQuery(self.type, key: "type")
        }

        public func validate(name: String) throws {
            try self.validate(self.domainIdentifier, name: "domainIdentifier", parent: name, pattern: "^dzd[-_][a-zA-Z0-9_-]{1,36}$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 50)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 8192)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListNotificationsOutput: AWSDecodableShape {
        /// When the number of notifications is greater than the default value for the MaxResults parameter, or if you explicitly specify a value for MaxResults that is less than the number of notifications, the response includes a pagination token named NextToken. You can specify this NextToken value in a subsequent call to ListNotifications to list the next set of notifications.
        public let nextToken: String?
        /// The results of the ListNotifications action.
        public let notifications: [NotificationOutput]?

        public init(nextToken: String? = nil, notifications: [NotificationOutput]? = nil) {
            self.nextToken = nextToken
            self.notifications = notifications
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "nextToken"
            case notifications = "notifications"
        }
    }

    public struct ListProjectMembershipsInput: AWSEncodableShape {
        /// The identifier of the Amazon DataZone domain in which you want to list project memberships.
        public let domainIdentifier: String
        /// The maximum number of memberships to return in a single call to ListProjectMemberships. When the number of memberships to be listed is greater than the value of MaxResults, the response contains a NextToken value that you can use in a subsequent call to ListProjectMemberships to list the next set of memberships.
        public let maxResults: Int?
        /// When the number of memberships is greater than the default value for the MaxResults parameter, or if you explicitly specify a value for MaxResults that is less than the number of memberships, the response includes a pagination token named NextToken. You can specify this NextToken value in a subsequent call to ListProjectMemberships to list the next set of memberships.
        public let nextToken: String?
        /// The identifier of the project whose memberships you want to list.
        public let projectIdentifier: String
        /// The method by which you want to sort the project memberships.
        public let sortBy: SortFieldProject?
        /// The sort order of the project memberships.
        public let sortOrder: SortOrder?

        public init(domainIdentifier: String, maxResults: Int? = nil, nextToken: String? = nil, projectIdentifier: String, sortBy: SortFieldProject? = nil, sortOrder: SortOrder? = nil) {
            self.domainIdentifier = domainIdentifier
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.projectIdentifier = projectIdentifier
            self.sortBy = sortBy
            self.sortOrder = sortOrder
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.domainIdentifier, key: "domainIdentifier")
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
            request.encodePath(self.projectIdentifier, key: "projectIdentifier")
            request.encodeQuery(self.sortBy, key: "sortBy")
            request.encodeQuery(self.sortOrder, key: "sortOrder")
        }

        public func validate(name: String) throws {
            try self.validate(self.domainIdentifier, name: "domainIdentifier", parent: name, pattern: "^dzd[-_][a-zA-Z0-9_-]{1,36}$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 50)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 8192)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.projectIdentifier, name: "projectIdentifier", parent: name, pattern: "^[a-zA-Z0-9_-]{1,36}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListProjectMembershipsOutput: AWSDecodableShape {
        /// The members of the project.
        public let members: [ProjectMember]
        /// When the number of memberships is greater than the default value for the MaxResults parameter, or if you explicitly specify a value for MaxResults that is less than the number of memberships, the response includes a pagination token named NextToken. You can specify this NextToken value in a subsequent call to ListProjectMemberships to list the next set of memberships.
        public let nextToken: String?

        public init(members: [ProjectMember], nextToken: String? = nil) {
            self.members = members
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case members = "members"
            case nextToken = "nextToken"
        }
    }

    public struct ListProjectsInput: AWSEncodableShape {
        /// The identifier of the Amazon DataZone domain.
        public let domainIdentifier: String
        /// The identifier of a group.
        public let groupIdentifier: String?
        /// The maximum number of projects to return in a single call to ListProjects. When the number of projects to be listed is greater than the value of MaxResults, the response contains a NextToken value that you can use in a subsequent call to ListProjects to list the next set of projects.
        public let maxResults: Int?
        /// The name of the project.
        public let name: String?
        /// When the number of projects is greater than the default value for the MaxResults parameter, or if you explicitly specify a value for MaxResults that is less than the number of projects, the response includes a pagination token named NextToken. You can specify this NextToken value in a subsequent call to ListProjects to list the next set of projects.
        public let nextToken: String?
        /// The identifier of the Amazon DataZone user.
        public let userIdentifier: String?

        public init(domainIdentifier: String, groupIdentifier: String? = nil, maxResults: Int? = nil, name: String? = nil, nextToken: String? = nil, userIdentifier: String? = nil) {
            self.domainIdentifier = domainIdentifier
            self.groupIdentifier = groupIdentifier
            self.maxResults = maxResults
            self.name = name
            self.nextToken = nextToken
            self.userIdentifier = userIdentifier
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.domainIdentifier, key: "domainIdentifier")
            request.encodeQuery(self.groupIdentifier, key: "groupIdentifier")
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.name, key: "name")
            request.encodeQuery(self.nextToken, key: "nextToken")
            request.encodeQuery(self.userIdentifier, key: "userIdentifier")
        }

        public func validate(name: String) throws {
            try self.validate(self.domainIdentifier, name: "domainIdentifier", parent: name, pattern: "^dzd[-_][a-zA-Z0-9_-]{1,36}$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 50)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, max: 64)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[\\w -]+$")
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 8192)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListProjectsOutput: AWSDecodableShape {
        /// The results of the ListProjects action.
        public let items: [ProjectSummary]?
        /// When the number of projects is greater than the default value for the MaxResults parameter, or if you explicitly specify a value for MaxResults that is less than the number of projects, the response includes a pagination token named NextToken. You can specify this NextToken value in a subsequent call to ListProjects to list the next set of projects.
        public let nextToken: String?

        public init(items: [ProjectSummary]? = nil, nextToken: String? = nil) {
            self.items = items
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case items = "items"
            case nextToken = "nextToken"
        }
    }

    public struct ListSubscriptionGrantsInput: AWSEncodableShape {
        /// The identifier of the Amazon DataZone domain.
        public let domainIdentifier: String
        /// The identifier of the Amazon DataZone environment.
        public let environmentId: String?
        /// The maximum number of subscription grants to return in a single call to ListSubscriptionGrants. When the number of subscription grants to be listed is greater than the value of MaxResults, the response contains a NextToken value that you can use in a subsequent call to ListSubscriptionGrants to list the next set of subscription grants.
        public let maxResults: Int?
        /// When the number of subscription grants is greater than the default value for the MaxResults parameter, or if you explicitly specify a value for MaxResults that is less than the number of subscription grants, the response includes a pagination token named NextToken. You can specify this NextToken value in a subsequent call to ListSubscriptionGrants to list the next set of subscription grants.
        public let nextToken: String?
        /// Specifies the way of sorting the results of this action.
        public let sortBy: SortKey?
        /// Specifies the sort order of this action.
        public let sortOrder: SortOrder?
        /// The identifier of the subscribed listing.
        public let subscribedListingId: String?
        /// The identifier of the subscription.
        public let subscriptionId: String?
        /// The identifier of the subscription target.
        public let subscriptionTargetId: String?

        public init(domainIdentifier: String, environmentId: String? = nil, maxResults: Int? = nil, nextToken: String? = nil, sortBy: SortKey? = nil, sortOrder: SortOrder? = nil, subscribedListingId: String? = nil, subscriptionId: String? = nil, subscriptionTargetId: String? = nil) {
            self.domainIdentifier = domainIdentifier
            self.environmentId = environmentId
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.sortBy = sortBy
            self.sortOrder = sortOrder
            self.subscribedListingId = subscribedListingId
            self.subscriptionId = subscriptionId
            self.subscriptionTargetId = subscriptionTargetId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.domainIdentifier, key: "domainIdentifier")
            request.encodeQuery(self.environmentId, key: "environmentId")
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
            request.encodeQuery(self.sortBy, key: "sortBy")
            request.encodeQuery(self.sortOrder, key: "sortOrder")
            request.encodeQuery(self.subscribedListingId, key: "subscribedListingId")
            request.encodeQuery(self.subscriptionId, key: "subscriptionId")
            request.encodeQuery(self.subscriptionTargetId, key: "subscriptionTargetId")
        }

        public func validate(name: String) throws {
            try self.validate(self.domainIdentifier, name: "domainIdentifier", parent: name, pattern: "^dzd[-_][a-zA-Z0-9_-]{1,36}$")
            try self.validate(self.environmentId, name: "environmentId", parent: name, pattern: "^[a-zA-Z0-9_-]{1,36}$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 50)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 8192)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.subscribedListingId, name: "subscribedListingId", parent: name, pattern: "^[a-zA-Z0-9_-]{1,36}$")
            try self.validate(self.subscriptionId, name: "subscriptionId", parent: name, pattern: "^[a-zA-Z0-9_-]{1,36}$")
            try self.validate(self.subscriptionTargetId, name: "subscriptionTargetId", parent: name, pattern: "^[a-zA-Z0-9_-]{1,36}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListSubscriptionGrantsOutput: AWSDecodableShape {
        /// The results of the ListSubscriptionGrants action.
        public let items: [SubscriptionGrantSummary]
        /// When the number of subscription grants is greater than the default value for the MaxResults parameter, or if you explicitly specify a value for MaxResults that is less than the number of subscription grants, the response includes a pagination token named NextToken. You can specify this NextToken value in a subsequent call to ListSubscriptionGrants to list the next set of subscription grants.
        public let nextToken: String?

        public init(items: [SubscriptionGrantSummary], nextToken: String? = nil) {
            self.items = items
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case items = "items"
            case nextToken = "nextToken"
        }
    }

    public struct ListSubscriptionRequestsInput: AWSEncodableShape {
        /// The identifier of the subscription request approver's project.
        public let approverProjectId: String?
        /// The identifier of the Amazon DataZone domain.
        public let domainIdentifier: String
        /// The maximum number of subscription requests to return in a single call to ListSubscriptionRequests. When the number of subscription requests to be listed is greater than the value of MaxResults, the response contains a NextToken value that you can use in a subsequent call to ListSubscriptionRequests to list the next set of subscription requests.
        public let maxResults: Int?
        /// When the number of subscription requests is greater than the default value for the MaxResults parameter, or if you explicitly specify a value for MaxResults that is less than the number of subscription requests, the response includes a pagination token named NextToken. You can specify this NextToken value in a subsequent call to ListSubscriptionRequests to list the next set of subscription requests.
        public let nextToken: String?
        /// The identifier of the project for the subscription requests.
        public let owningProjectId: String?
        /// Specifies the way to sort the results of this action.
        public let sortBy: SortKey?
        /// Specifies the sort order for the results of this action.
        public let sortOrder: SortOrder?
        /// Specifies the status of the subscription requests.
        public let status: SubscriptionRequestStatus?
        /// The identifier of the subscribed listing.
        public let subscribedListingId: String?

        public init(approverProjectId: String? = nil, domainIdentifier: String, maxResults: Int? = nil, nextToken: String? = nil, owningProjectId: String? = nil, sortBy: SortKey? = nil, sortOrder: SortOrder? = nil, status: SubscriptionRequestStatus? = nil, subscribedListingId: String? = nil) {
            self.approverProjectId = approverProjectId
            self.domainIdentifier = domainIdentifier
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.owningProjectId = owningProjectId
            self.sortBy = sortBy
            self.sortOrder = sortOrder
            self.status = status
            self.subscribedListingId = subscribedListingId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.approverProjectId, key: "approverProjectId")
            request.encodePath(self.domainIdentifier, key: "domainIdentifier")
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
            request.encodeQuery(self.owningProjectId, key: "owningProjectId")
            request.encodeQuery(self.sortBy, key: "sortBy")
            request.encodeQuery(self.sortOrder, key: "sortOrder")
            request.encodeQuery(self.status, key: "status")
            request.encodeQuery(self.subscribedListingId, key: "subscribedListingId")
        }

        public func validate(name: String) throws {
            try self.validate(self.approverProjectId, name: "approverProjectId", parent: name, pattern: "^[a-zA-Z0-9_-]{1,36}$")
            try self.validate(self.domainIdentifier, name: "domainIdentifier", parent: name, pattern: "^dzd[-_][a-zA-Z0-9_-]{1,36}$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 50)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 8192)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.owningProjectId, name: "owningProjectId", parent: name, pattern: "^[a-zA-Z0-9_-]{1,36}$")
            try self.validate(self.subscribedListingId, name: "subscribedListingId", parent: name, pattern: "^[a-zA-Z0-9_-]{1,36}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListSubscriptionRequestsOutput: AWSDecodableShape {
        /// The results of the ListSubscriptionRequests action.
        public let items: [SubscriptionRequestSummary]
        /// When the number of subscription requests is greater than the default value for the MaxResults parameter, or if you explicitly specify a value for MaxResults that is less than the number of subscription requests, the response includes a pagination token named NextToken. You can specify this NextToken value in a subsequent call to ListSubscriptionRequests to list the next set of subscription requests.
        public let nextToken: String?

        public init(items: [SubscriptionRequestSummary], nextToken: String? = nil) {
            self.items = items
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case items = "items"
            case nextToken = "nextToken"
        }
    }

    public struct ListSubscriptionTargetsInput: AWSEncodableShape {
        /// The identifier of the Amazon DataZone domain where you want to list subscription targets.
        public let domainIdentifier: String
        /// The identifier of the environment where you want to list subscription targets.
        public let environmentIdentifier: String
        /// The maximum number of subscription targets to return in a single call to ListSubscriptionTargets. When the number of subscription targets to be listed is greater than the value of MaxResults, the response contains a NextToken value that you can use in a subsequent call to ListSubscriptionTargets to list the next set of subscription targets.
        public let maxResults: Int?
        /// When the number of subscription targets is greater than the default value for the MaxResults parameter, or if you explicitly specify a value for MaxResults that is less than the number of subscription targets, the response includes a pagination token named NextToken. You can specify this NextToken value in a subsequent call to ListSubscriptionTargets to list the next set of subscription targets.
        public let nextToken: String?
        /// Specifies the way in which the results of this action are to be sorted.
        public let sortBy: SortKey?
        /// Specifies the sort order for the results of this action.
        public let sortOrder: SortOrder?

        public init(domainIdentifier: String, environmentIdentifier: String, maxResults: Int? = nil, nextToken: String? = nil, sortBy: SortKey? = nil, sortOrder: SortOrder? = nil) {
            self.domainIdentifier = domainIdentifier
            self.environmentIdentifier = environmentIdentifier
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.sortBy = sortBy
            self.sortOrder = sortOrder
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.domainIdentifier, key: "domainIdentifier")
            request.encodePath(self.environmentIdentifier, key: "environmentIdentifier")
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
            request.encodeQuery(self.sortBy, key: "sortBy")
            request.encodeQuery(self.sortOrder, key: "sortOrder")
        }

        public func validate(name: String) throws {
            try self.validate(self.domainIdentifier, name: "domainIdentifier", parent: name, pattern: "^dzd[-_][a-zA-Z0-9_-]{1,36}$")
            try self.validate(self.environmentIdentifier, name: "environmentIdentifier", parent: name, pattern: "^[a-zA-Z0-9_-]{1,36}$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 50)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 8192)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListSubscriptionTargetsOutput: AWSDecodableShape {
        /// The results of the ListSubscriptionTargets action.
        public let items: [SubscriptionTargetSummary]
        /// When the number of subscription targets is greater than the default value for the MaxResults parameter, or if you explicitly specify a value for MaxResults that is less than the number of subscription targets, the response includes a pagination token named NextToken. You can specify this NextToken value in a subsequent call to ListSubscriptionTargets to list the next set of subscription targets.
        public let nextToken: String?

        public init(items: [SubscriptionTargetSummary], nextToken: String? = nil) {
            self.items = items
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case items = "items"
            case nextToken = "nextToken"
        }
    }

    public struct ListSubscriptionsInput: AWSEncodableShape {
        /// The identifier of the project for the subscription's approver.
        public let approverProjectId: String?
        /// The identifier of the Amazon DataZone domain.
        public let domainIdentifier: String
        /// The maximum number of subscriptions to return in a single call to ListSubscriptions. When the number of subscriptions to be listed is greater than the value of MaxResults, the response contains a NextToken value that you can use in a subsequent call to ListSubscriptions to list the next set of Subscriptions.
        public let maxResults: Int?
        /// When the number of subscriptions is greater than the default value for the MaxResults parameter, or if you explicitly specify a value for MaxResults that is less than the number of subscriptions, the response includes a pagination token named NextToken. You can specify this NextToken value in a subsequent call to ListSubscriptions to list the next set of subscriptions.
        public let nextToken: String?
        /// The identifier of the owning project.
        public let owningProjectId: String?
        /// Specifies the way in which the results of this action are to be sorted.
        public let sortBy: SortKey?
        /// Specifies the sort order for the results of this action.
        public let sortOrder: SortOrder?
        /// The status of the subscriptions that you want to list.
        public let status: SubscriptionStatus?
        /// The identifier of the subscribed listing for the subscriptions that you want to list.
        public let subscribedListingId: String?
        /// The identifier of the subscription request for the subscriptions that you want to list.
        public let subscriptionRequestIdentifier: String?

        public init(approverProjectId: String? = nil, domainIdentifier: String, maxResults: Int? = nil, nextToken: String? = nil, owningProjectId: String? = nil, sortBy: SortKey? = nil, sortOrder: SortOrder? = nil, status: SubscriptionStatus? = nil, subscribedListingId: String? = nil, subscriptionRequestIdentifier: String? = nil) {
            self.approverProjectId = approverProjectId
            self.domainIdentifier = domainIdentifier
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.owningProjectId = owningProjectId
            self.sortBy = sortBy
            self.sortOrder = sortOrder
            self.status = status
            self.subscribedListingId = subscribedListingId
            self.subscriptionRequestIdentifier = subscriptionRequestIdentifier
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.approverProjectId, key: "approverProjectId")
            request.encodePath(self.domainIdentifier, key: "domainIdentifier")
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
            request.encodeQuery(self.owningProjectId, key: "owningProjectId")
            request.encodeQuery(self.sortBy, key: "sortBy")
            request.encodeQuery(self.sortOrder, key: "sortOrder")
            request.encodeQuery(self.status, key: "status")
            request.encodeQuery(self.subscribedListingId, key: "subscribedListingId")
            request.encodeQuery(self.subscriptionRequestIdentifier, key: "subscriptionRequestIdentifier")
        }

        public func validate(name: String) throws {
            try self.validate(self.approverProjectId, name: "approverProjectId", parent: name, pattern: "^[a-zA-Z0-9_-]{1,36}$")
            try self.validate(self.domainIdentifier, name: "domainIdentifier", parent: name, pattern: "^dzd[-_][a-zA-Z0-9_-]{1,36}$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 50)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 8192)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.owningProjectId, name: "owningProjectId", parent: name, pattern: "^[a-zA-Z0-9_-]{1,36}$")
            try self.validate(self.subscribedListingId, name: "subscribedListingId", parent: name, pattern: "^[a-zA-Z0-9_-]{1,36}$")
            try self.validate(self.subscriptionRequestIdentifier, name: "subscriptionRequestIdentifier", parent: name, pattern: "^[a-zA-Z0-9_-]{1,36}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListSubscriptionsOutput: AWSDecodableShape {
        /// The results of the ListSubscriptions action.
        public let items: [SubscriptionSummary]
        /// When the number of subscriptions is greater than the default value for the MaxResults parameter, or if you explicitly specify a value for MaxResults that is less than the number of subscriptions, the response includes a pagination token named NextToken. You can specify this NextToken value in a subsequent call to ListSubscriptions to list the next set of subscriptions.
        public let nextToken: String?

        public init(items: [SubscriptionSummary], nextToken: String? = nil) {
            self.items = items
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case items = "items"
            case nextToken = "nextToken"
        }
    }

    public struct ListTagsForResourceRequest: AWSEncodableShape {
        /// The ARN of the resource whose tags you want to list.
        public let resourceArn: String

        public init(resourceArn: String) {
            self.resourceArn = resourceArn
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.resourceArn, key: "resourceArn")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListTagsForResourceResponse: AWSDecodableShape {
        /// The tags of the specified resource.
        public let tags: [String: String]?

        public init(tags: [String: String]? = nil) {
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case tags = "tags"
        }
    }

    public struct ListTimeSeriesDataPointsInput: AWSEncodableShape {
        /// The ID of the Amazon DataZone domain that houses the assets for which you want to list time series data points.
        public let domainIdentifier: String
        /// The timestamp at which the data points that you wanted to list ended.
        public let endedAt: Date?
        /// The ID of the asset for which you want to list data points.
        public let entityIdentifier: String
        /// The type of the asset for which you want to list data points.
        public let entityType: TimeSeriesEntityType
        /// The name of the time series data points form.
        public let formName: String
        /// The maximum number of data points to return in a single call to ListTimeSeriesDataPoints. When the number of data points to be listed is greater than the value of MaxResults, the response contains a NextToken value that you can use in a subsequent call to ListTimeSeriesDataPoints to list the next set of data points.
        public let maxResults: Int?
        /// When the number of data points is greater than the default value for the MaxResults parameter, or if you explicitly specify a value for MaxResults that is less than the number of data points, the response includes a pagination token named NextToken. You can specify this NextToken value in a subsequent call to ListTimeSeriesDataPoints to list the next set of data points.
        public let nextToken: String?
        /// The timestamp at which the data points that you want to list started.
        public let startedAt: Date?

        public init(domainIdentifier: String, endedAt: Date? = nil, entityIdentifier: String, entityType: TimeSeriesEntityType, formName: String, maxResults: Int? = nil, nextToken: String? = nil, startedAt: Date? = nil) {
            self.domainIdentifier = domainIdentifier
            self.endedAt = endedAt
            self.entityIdentifier = entityIdentifier
            self.entityType = entityType
            self.formName = formName
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.startedAt = startedAt
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.domainIdentifier, key: "domainIdentifier")
            request.encodeQuery(self.endedAt, key: "endedAt")
            request.encodePath(self.entityIdentifier, key: "entityIdentifier")
            request.encodePath(self.entityType, key: "entityType")
            request.encodeQuery(self.formName, key: "formName")
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
            request.encodeQuery(self.startedAt, key: "startedAt")
        }

        public func validate(name: String) throws {
            try self.validate(self.domainIdentifier, name: "domainIdentifier", parent: name, pattern: "^dzd[-_][a-zA-Z0-9_-]{1,36}$")
            try self.validate(self.entityIdentifier, name: "entityIdentifier", parent: name, pattern: "^[a-zA-Z0-9_-]{1,36}$")
            try self.validate(self.formName, name: "formName", parent: name, max: 128)
            try self.validate(self.formName, name: "formName", parent: name, min: 1)
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 50)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 8192)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListTimeSeriesDataPointsOutput: AWSDecodableShape {
        /// The results of the ListTimeSeriesDataPoints action.
        public let items: [TimeSeriesDataPointSummaryFormOutput]?
        /// When the number of data points is greater than the default value for the MaxResults parameter, or if you explicitly specify a value for MaxResults that is less than the number of data points, the response includes a pagination token named NextToken. You can specify this NextToken value in a subsequent call to ListTimeSeriesDataPoints to list the next set of data points.
        public let nextToken: String?

        public init(items: [TimeSeriesDataPointSummaryFormOutput]? = nil, nextToken: String? = nil) {
            self.items = items
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case items = "items"
            case nextToken = "nextToken"
        }
    }

    public struct ListingRevision: AWSDecodableShape {
        /// An identifier of a revision of an asset published in a Amazon DataZone catalog.
        public let id: String
        /// The details of a revision of an asset published in a Amazon DataZone catalog.
        public let revision: String

        public init(id: String, revision: String) {
            self.id = id
            self.revision = revision
        }

        private enum CodingKeys: String, CodingKey {
            case id = "id"
            case revision = "revision"
        }
    }

    public struct ListingRevisionInput: AWSEncodableShape {
        /// An identifier of revision to be made to an asset published in a Amazon DataZone catalog.
        public let identifier: String
        /// The details of a revision to be made to an asset published in a Amazon DataZone catalog.
        public let revision: String

        public init(identifier: String, revision: String) {
            self.identifier = identifier
            self.revision = revision
        }

        public func validate(name: String) throws {
            try self.validate(self.identifier, name: "identifier", parent: name, pattern: "^[a-zA-Z0-9_-]{1,36}$")
            try self.validate(self.revision, name: "revision", parent: name, max: 64)
            try self.validate(self.revision, name: "revision", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case identifier = "identifier"
            case revision = "revision"
        }
    }

    public struct MetadataGenerationRunItem: AWSDecodableShape {
        /// The timestamp at which the metadata generation run was created.
        public let createdAt: Date?
        /// The user who created the metadata generation run.
        public let createdBy: String?
        /// The ID of the Amazon DataZone domain in which the metadata generation run was created.
        public let domainId: String
        /// The ID of the metadata generation run.
        public let id: String
        /// The ID of the project that owns the asset for which the metadata generation was ran.
        public let owningProjectId: String
        /// The status of the metadata generation run.
        public let status: MetadataGenerationRunStatus?
        /// The asset for which metadata was generated.
        public let target: MetadataGenerationRunTarget?
        /// The type of the metadata generation run.
        public let type: MetadataGenerationRunType?

        public init(createdAt: Date? = nil, createdBy: String? = nil, domainId: String, id: String, owningProjectId: String, status: MetadataGenerationRunStatus? = nil, target: MetadataGenerationRunTarget? = nil, type: MetadataGenerationRunType? = nil) {
            self.createdAt = createdAt
            self.createdBy = createdBy
            self.domainId = domainId
            self.id = id
            self.owningProjectId = owningProjectId
            self.status = status
            self.target = target
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case createdAt = "createdAt"
            case createdBy = "createdBy"
            case domainId = "domainId"
            case id = "id"
            case owningProjectId = "owningProjectId"
            case status = "status"
            case target = "target"
            case type = "type"
        }
    }

    public struct MetadataGenerationRunTarget: AWSEncodableShape & AWSDecodableShape {
        /// The ID of the metadata generation run's target.
        public let identifier: String
        /// The revision of the asset for which metadata was generated.
        public let revision: String?
        /// The type of the asset for which metadata was generated.
        public let type: MetadataGenerationTargetType

        public init(identifier: String, revision: String? = nil, type: MetadataGenerationTargetType) {
            self.identifier = identifier
            self.revision = revision
            self.type = type
        }

        public func validate(name: String) throws {
            try self.validate(self.revision, name: "revision", parent: name, max: 64)
            try self.validate(self.revision, name: "revision", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case identifier = "identifier"
            case revision = "revision"
            case type = "type"
        }
    }

    public struct NotificationOutput: AWSDecodableShape {
        /// The action link included in the notification.
        public let actionLink: String
        /// The timestamp of when a notification was created.
        public let creationTimestamp: Date
        /// The identifier of a Amazon DataZone domain in which the notification exists.
        public let domainIdentifier: String
        /// The identifier of the notification.
        public let identifier: String
        /// The timestamp of when the notification was last updated.
        public let lastUpdatedTimestamp: Date
        /// The message included in the notification.
        public let message: String
        /// The metadata included in the notification.
        public let metadata: [String: String]?
        /// The status included in the notification.
        public let status: TaskStatus?
        /// The title of the notification.
        public let title: String
        /// The topic of the notification.
        public let topic: Topic
        /// The type of the notification.
        public let type: NotificationType

        public init(actionLink: String, creationTimestamp: Date, domainIdentifier: String, identifier: String, lastUpdatedTimestamp: Date, message: String, metadata: [String: String]? = nil, status: TaskStatus? = nil, title: String, topic: Topic, type: NotificationType) {
            self.actionLink = actionLink
            self.creationTimestamp = creationTimestamp
            self.domainIdentifier = domainIdentifier
            self.identifier = identifier
            self.lastUpdatedTimestamp = lastUpdatedTimestamp
            self.message = message
            self.metadata = metadata
            self.status = status
            self.title = title
            self.topic = topic
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case actionLink = "actionLink"
            case creationTimestamp = "creationTimestamp"
            case domainIdentifier = "domainIdentifier"
            case identifier = "identifier"
            case lastUpdatedTimestamp = "lastUpdatedTimestamp"
            case message = "message"
            case metadata = "metadata"
            case status = "status"
            case title = "title"
            case topic = "topic"
            case type = "type"
        }
    }

    public struct NotificationResource: AWSDecodableShape {
        /// The ID of the resource mentioned in a notification.
        public let id: String
        /// The name of the resource mentioned in a notification.
        public let name: String?
        /// The type of the resource mentioned in a notification.
        public let type: NotificationResourceType

        public init(id: String, name: String? = nil, type: NotificationResourceType) {
            self.id = id
            self.name = name
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case id = "id"
            case name = "name"
            case type = "type"
        }
    }

    public struct PostTimeSeriesDataPointsInput: AWSEncodableShape {
        /// A unique, case-sensitive identifier that is provided to ensure the idempotency of the request.
        public let clientToken: String?
        /// The ID of the Amazon DataZone domain in which you want to post time series data points.
        public let domainIdentifier: String
        /// The ID of the asset for which you want to post time series data points.
        public let entityIdentifier: String
        /// The type of the asset for which you want to post data points.
        public let entityType: TimeSeriesEntityType
        /// The forms that contain the data points that you want to post.
        public let forms: [TimeSeriesDataPointFormInput]

        public init(clientToken: String? = PostTimeSeriesDataPointsInput.idempotencyToken(), domainIdentifier: String, entityIdentifier: String, entityType: TimeSeriesEntityType, forms: [TimeSeriesDataPointFormInput]) {
            self.clientToken = clientToken
            self.domainIdentifier = domainIdentifier
            self.entityIdentifier = entityIdentifier
            self.entityType = entityType
            self.forms = forms
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.clientToken, forKey: .clientToken)
            request.encodePath(self.domainIdentifier, key: "domainIdentifier")
            request.encodePath(self.entityIdentifier, key: "entityIdentifier")
            request.encodePath(self.entityType, key: "entityType")
            try container.encode(self.forms, forKey: .forms)
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 128)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "^[\\x21-\\x7E]+$")
            try self.validate(self.domainIdentifier, name: "domainIdentifier", parent: name, pattern: "^dzd[-_][a-zA-Z0-9_-]{1,36}$")
            try self.validate(self.entityIdentifier, name: "entityIdentifier", parent: name, pattern: "^[a-zA-Z0-9_-]{1,36}$")
            try self.forms.forEach {
                try $0.validate(name: "\(name).forms[]")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "clientToken"
            case forms = "forms"
        }
    }

    public struct PostTimeSeriesDataPointsOutput: AWSDecodableShape {
        /// The ID of the Amazon DataZone domain in which you want to post time series data points.
        public let domainId: String?
        /// The ID of the asset for which you want to post time series data points.
        public let entityId: String?
        /// The type of the asset for which you want to post data points.
        public let entityType: TimeSeriesEntityType?
        /// The forms that contain the data points that you have posted.
        public let forms: [TimeSeriesDataPointFormOutput]?

        public init(domainId: String? = nil, entityId: String? = nil, entityType: TimeSeriesEntityType? = nil, forms: [TimeSeriesDataPointFormOutput]? = nil) {
            self.domainId = domainId
            self.entityId = entityId
            self.entityType = entityType
            self.forms = forms
        }

        private enum CodingKeys: String, CodingKey {
            case domainId = "domainId"
            case entityId = "entityId"
            case entityType = "entityType"
            case forms = "forms"
        }
    }

    public struct PredictionConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The business name generation mechanism.
        public let businessNameGeneration: BusinessNameGenerationConfiguration?

        public init(businessNameGeneration: BusinessNameGenerationConfiguration? = nil) {
            self.businessNameGeneration = businessNameGeneration
        }

        private enum CodingKeys: String, CodingKey {
            case businessNameGeneration = "businessNameGeneration"
        }
    }

    public struct ProjectDeletionError: AWSDecodableShape {
        /// The code of the project deletion error.
        public let code: String?
        /// The message of the project deletion error.
        public let message: String?

        public init(code: String? = nil, message: String? = nil) {
            self.code = code
            self.message = message
        }

        private enum CodingKeys: String, CodingKey {
            case code = "code"
            case message = "message"
        }
    }

    public struct ProjectMember: AWSDecodableShape {
        /// The designated role of a project member.
        public let designation: UserDesignation
        /// The membership details of a project member.
        public let memberDetails: MemberDetails

        public init(designation: UserDesignation, memberDetails: MemberDetails) {
            self.designation = designation
            self.memberDetails = memberDetails
        }

        private enum CodingKeys: String, CodingKey {
            case designation = "designation"
            case memberDetails = "memberDetails"
        }
    }

    public struct ProjectSummary: AWSDecodableShape {
        /// The timestamp of when a project was created.
        public let createdAt: Date?
        /// The Amazon DataZone user who created the project.
        public let createdBy: String
        /// The description of a project.
        public let description: String?
        /// The identifier of a Amazon DataZone domain where the project exists.
        public let domainId: String
        /// Specifies the error message that is returned if the operation cannot be successfully completed.
        public let failureReasons: [ProjectDeletionError]?
        /// The identifier of a project.
        public let id: String
        /// The name of a project.
        public let name: String
        /// The status of the project.
        public let projectStatus: ProjectStatus?
        /// The timestamp of when the project was updated.
        public let updatedAt: Date?

        public init(createdAt: Date? = nil, createdBy: String, description: String? = nil, domainId: String, failureReasons: [ProjectDeletionError]? = nil, id: String, name: String, projectStatus: ProjectStatus? = nil, updatedAt: Date? = nil) {
            self.createdAt = createdAt
            self.createdBy = createdBy
            self.description = description
            self.domainId = domainId
            self.failureReasons = failureReasons
            self.id = id
            self.name = name
            self.projectStatus = projectStatus
            self.updatedAt = updatedAt
        }

        private enum CodingKeys: String, CodingKey {
            case createdAt = "createdAt"
            case createdBy = "createdBy"
            case description = "description"
            case domainId = "domainId"
            case failureReasons = "failureReasons"
            case id = "id"
            case name = "name"
            case projectStatus = "projectStatus"
            case updatedAt = "updatedAt"
        }
    }

    public struct PutEnvironmentBlueprintConfigurationInput: AWSEncodableShape {
        /// The identifier of the Amazon DataZone domain.
        public let domainIdentifier: String
        /// Specifies the enabled Amazon Web Services Regions.
        public let enabledRegions: [String]
        /// The identifier of the environment blueprint.
        public let environmentBlueprintIdentifier: String
        /// The ARN of the manage access role.
        public let manageAccessRoleArn: String?
        /// The ARN of the provisioning role.
        public let provisioningRoleArn: String?
        /// The regional parameters in the environment blueprint.
        public let regionalParameters: [String: [String: String]]?

        public init(domainIdentifier: String, enabledRegions: [String], environmentBlueprintIdentifier: String, manageAccessRoleArn: String? = nil, provisioningRoleArn: String? = nil, regionalParameters: [String: [String: String]]? = nil) {
            self.domainIdentifier = domainIdentifier
            self.enabledRegions = enabledRegions
            self.environmentBlueprintIdentifier = environmentBlueprintIdentifier
            self.manageAccessRoleArn = manageAccessRoleArn
            self.provisioningRoleArn = provisioningRoleArn
            self.regionalParameters = regionalParameters
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.domainIdentifier, key: "domainIdentifier")
            try container.encode(self.enabledRegions, forKey: .enabledRegions)
            request.encodePath(self.environmentBlueprintIdentifier, key: "environmentBlueprintIdentifier")
            try container.encodeIfPresent(self.manageAccessRoleArn, forKey: .manageAccessRoleArn)
            try container.encodeIfPresent(self.provisioningRoleArn, forKey: .provisioningRoleArn)
            try container.encodeIfPresent(self.regionalParameters, forKey: .regionalParameters)
        }

        public func validate(name: String) throws {
            try self.validate(self.domainIdentifier, name: "domainIdentifier", parent: name, pattern: "^dzd[-_][a-zA-Z0-9_-]{1,36}$")
            try self.enabledRegions.forEach {
                try validate($0, name: "enabledRegions[]", parent: name, max: 16)
                try validate($0, name: "enabledRegions[]", parent: name, min: 4)
                try validate($0, name: "enabledRegions[]", parent: name, pattern: "^[a-z]{2}-?(iso|gov)?-{1}[a-z]*-{1}[0-9]$")
            }
            try self.validate(self.environmentBlueprintIdentifier, name: "environmentBlueprintIdentifier", parent: name, pattern: "^[a-zA-Z0-9_-]{1,36}$")
            try self.validate(self.manageAccessRoleArn, name: "manageAccessRoleArn", parent: name, pattern: "^arn:aws[^:]*:iam::\\d{12}:(role|role/service-role)/[\\w+=,.@-]*$")
            try self.validate(self.provisioningRoleArn, name: "provisioningRoleArn", parent: name, pattern: "^arn:aws[^:]*:iam::\\d{12}:(role|role/service-role)/[\\w+=,.@-]*$")
            try self.regionalParameters?.forEach {
                try validate($0.key, name: "regionalParameters.key", parent: name, max: 16)
                try validate($0.key, name: "regionalParameters.key", parent: name, min: 4)
                try validate($0.key, name: "regionalParameters.key", parent: name, pattern: "^[a-z]{2}-?(iso|gov)?-{1}[a-z]*-{1}[0-9]$")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case enabledRegions = "enabledRegions"
            case manageAccessRoleArn = "manageAccessRoleArn"
            case provisioningRoleArn = "provisioningRoleArn"
            case regionalParameters = "regionalParameters"
        }
    }

    public struct PutEnvironmentBlueprintConfigurationOutput: AWSDecodableShape {
        /// The timestamp of when the environment blueprint was created.
        public let createdAt: Date?
        /// The identifier of the Amazon DataZone domain.
        public let domainId: String
        /// Specifies the enabled Amazon Web Services Regions.
        public let enabledRegions: [String]?
        /// The identifier of the environment blueprint.
        public let environmentBlueprintId: String
        /// The ARN of the manage access role.
        public let manageAccessRoleArn: String?
        /// The ARN of the provisioning role.
        public let provisioningRoleArn: String?
        /// The regional parameters in the environment blueprint.
        public let regionalParameters: [String: [String: String]]?
        /// The timestamp of when the environment blueprint was updated.
        public let updatedAt: Date?

        public init(createdAt: Date? = nil, domainId: String, enabledRegions: [String]? = nil, environmentBlueprintId: String, manageAccessRoleArn: String? = nil, provisioningRoleArn: String? = nil, regionalParameters: [String: [String: String]]? = nil, updatedAt: Date? = nil) {
            self.createdAt = createdAt
            self.domainId = domainId
            self.enabledRegions = enabledRegions
            self.environmentBlueprintId = environmentBlueprintId
            self.manageAccessRoleArn = manageAccessRoleArn
            self.provisioningRoleArn = provisioningRoleArn
            self.regionalParameters = regionalParameters
            self.updatedAt = updatedAt
        }

        private enum CodingKeys: String, CodingKey {
            case createdAt = "createdAt"
            case domainId = "domainId"
            case enabledRegions = "enabledRegions"
            case environmentBlueprintId = "environmentBlueprintId"
            case manageAccessRoleArn = "manageAccessRoleArn"
            case provisioningRoleArn = "provisioningRoleArn"
            case regionalParameters = "regionalParameters"
            case updatedAt = "updatedAt"
        }
    }

    public struct RecommendationConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// Specifies whether automatic business name generation is to be enabled or not as part of the recommendation configuration.
        public let enableBusinessNameGeneration: Bool?

        public init(enableBusinessNameGeneration: Bool? = nil) {
            self.enableBusinessNameGeneration = enableBusinessNameGeneration
        }

        private enum CodingKeys: String, CodingKey {
            case enableBusinessNameGeneration = "enableBusinessNameGeneration"
        }
    }

    public struct RedshiftClusterStorage: AWSEncodableShape & AWSDecodableShape {
        /// The name of an Amazon Redshift cluster.
        public let clusterName: String

        public init(clusterName: String) {
            self.clusterName = clusterName
        }

        private enum CodingKeys: String, CodingKey {
            case clusterName = "clusterName"
        }
    }

    public struct RedshiftCredentialConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The ARN of a secret manager for an Amazon Redshift cluster.
        public let secretManagerArn: String

        public init(secretManagerArn: String) {
            self.secretManagerArn = secretManagerArn
        }

        private enum CodingKeys: String, CodingKey {
            case secretManagerArn = "secretManagerArn"
        }
    }

    public struct RedshiftRunConfigurationInput: AWSEncodableShape {
        /// The data access role included in the configuration details of the Amazon Redshift data source.
        public let dataAccessRole: String?
        public let redshiftCredentialConfiguration: RedshiftCredentialConfiguration
        public let redshiftStorage: RedshiftStorage
        /// The relational filger configurations included in the configuration details of the Amazon Redshift data source.
        public let relationalFilterConfigurations: [RelationalFilterConfiguration]

        public init(dataAccessRole: String? = nil, redshiftCredentialConfiguration: RedshiftCredentialConfiguration, redshiftStorage: RedshiftStorage, relationalFilterConfigurations: [RelationalFilterConfiguration]) {
            self.dataAccessRole = dataAccessRole
            self.redshiftCredentialConfiguration = redshiftCredentialConfiguration
            self.redshiftStorage = redshiftStorage
            self.relationalFilterConfigurations = relationalFilterConfigurations
        }

        private enum CodingKeys: String, CodingKey {
            case dataAccessRole = "dataAccessRole"
            case redshiftCredentialConfiguration = "redshiftCredentialConfiguration"
            case redshiftStorage = "redshiftStorage"
            case relationalFilterConfigurations = "relationalFilterConfigurations"
        }
    }

    public struct RedshiftRunConfigurationOutput: AWSDecodableShape {
        /// The ID of the Amazon Web Services account included in the configuration details of the Amazon Redshift data source.
        public let accountId: String?
        /// The data access role included in the configuration details of the Amazon Redshift data source.
        public let dataAccessRole: String?
        public let redshiftCredentialConfiguration: RedshiftCredentialConfiguration
        public let redshiftStorage: RedshiftStorage
        /// The Amazon Web Services region included in the configuration details of the Amazon Redshift data source.
        public let region: String?
        /// The relational filger configurations included in the configuration details of the Amazon Redshift data source.
        public let relationalFilterConfigurations: [RelationalFilterConfiguration]

        public init(accountId: String? = nil, dataAccessRole: String? = nil, redshiftCredentialConfiguration: RedshiftCredentialConfiguration, redshiftStorage: RedshiftStorage, region: String? = nil, relationalFilterConfigurations: [RelationalFilterConfiguration]) {
            self.accountId = accountId
            self.dataAccessRole = dataAccessRole
            self.redshiftCredentialConfiguration = redshiftCredentialConfiguration
            self.redshiftStorage = redshiftStorage
            self.region = region
            self.relationalFilterConfigurations = relationalFilterConfigurations
        }

        private enum CodingKeys: String, CodingKey {
            case accountId = "accountId"
            case dataAccessRole = "dataAccessRole"
            case redshiftCredentialConfiguration = "redshiftCredentialConfiguration"
            case redshiftStorage = "redshiftStorage"
            case region = "region"
            case relationalFilterConfigurations = "relationalFilterConfigurations"
        }
    }

    public struct RedshiftServerlessStorage: AWSEncodableShape & AWSDecodableShape {
        /// The name of the Amazon Redshift Serverless workgroup.
        public let workgroupName: String

        public init(workgroupName: String) {
            self.workgroupName = workgroupName
        }

        private enum CodingKeys: String, CodingKey {
            case workgroupName = "workgroupName"
        }
    }

    public struct RejectChoice: AWSEncodableShape {
        /// Specifies the the automatically generated business metadata that can be rejected.
        public let predictionChoices: [Int]?
        /// Specifies the target (for example, a column name) where a prediction can be rejected.
        public let predictionTarget: String?

        public init(predictionChoices: [Int]? = nil, predictionTarget: String? = nil) {
            self.predictionChoices = predictionChoices
            self.predictionTarget = predictionTarget
        }

        private enum CodingKeys: String, CodingKey {
            case predictionChoices = "predictionChoices"
            case predictionTarget = "predictionTarget"
        }
    }

    public struct RejectPredictionsInput: AWSEncodableShape {
        /// A unique, case-sensitive identifier that is provided to ensure the idempotency of the request.
        public let clientToken: String?
        /// The identifier of the Amazon DataZone domain.
        public let domainIdentifier: String
        /// The identifier of the prediction.
        public let identifier: String
        /// Specifies the prediction (aka, the automatically generated piece of metadata) and the target (for example, a column name) that can be rejected.
        public let rejectChoices: [RejectChoice]?
        /// Specifies the rule (or the conditions) under which a prediction can be rejected.
        public let rejectRule: RejectRule?
        /// The revision that is to be made to the asset.
        public let revision: String?

        public init(clientToken: String? = RejectPredictionsInput.idempotencyToken(), domainIdentifier: String, identifier: String, rejectChoices: [RejectChoice]? = nil, rejectRule: RejectRule? = nil, revision: String? = nil) {
            self.clientToken = clientToken
            self.domainIdentifier = domainIdentifier
            self.identifier = identifier
            self.rejectChoices = rejectChoices
            self.rejectRule = rejectRule
            self.revision = revision
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.clientToken, forKey: .clientToken)
            request.encodePath(self.domainIdentifier, key: "domainIdentifier")
            request.encodePath(self.identifier, key: "identifier")
            try container.encodeIfPresent(self.rejectChoices, forKey: .rejectChoices)
            try container.encodeIfPresent(self.rejectRule, forKey: .rejectRule)
            request.encodeQuery(self.revision, key: "revision")
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 128)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "^[\\x21-\\x7E]+$")
            try self.validate(self.domainIdentifier, name: "domainIdentifier", parent: name, pattern: "^dzd[-_][a-zA-Z0-9_-]{1,36}$")
            try self.validate(self.identifier, name: "identifier", parent: name, pattern: "^[a-zA-Z0-9_-]{1,36}$")
            try self.validate(self.revision, name: "revision", parent: name, max: 64)
            try self.validate(self.revision, name: "revision", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "clientToken"
            case rejectChoices = "rejectChoices"
            case rejectRule = "rejectRule"
        }
    }

    public struct RejectPredictionsOutput: AWSDecodableShape {
        /// The ID of the asset.
        public let assetId: String
        /// The revision that is to be made to the asset.
        public let assetRevision: String
        /// The ID of the Amazon DataZone domain.
        public let domainId: String

        public init(assetId: String, assetRevision: String, domainId: String) {
            self.assetId = assetId
            self.assetRevision = assetRevision
            self.domainId = domainId
        }

        private enum CodingKeys: String, CodingKey {
            case assetId = "assetId"
            case assetRevision = "assetRevision"
            case domainId = "domainId"
        }
    }

    public struct RejectRule: AWSEncodableShape {
        /// Specifies whether you want to reject the top prediction for all targets or none.
        public let rule: RejectRuleBehavior?
        /// The confidence score that specifies the condition at which a prediction can be rejected.
        public let threshold: Float?

        public init(rule: RejectRuleBehavior? = nil, threshold: Float? = nil) {
            self.rule = rule
            self.threshold = threshold
        }

        private enum CodingKeys: String, CodingKey {
            case rule = "rule"
            case threshold = "threshold"
        }
    }

    public struct RejectSubscriptionRequestInput: AWSEncodableShape {
        /// The decision comment of the rejected subscription request.
        public let decisionComment: String?
        /// The identifier of the Amazon DataZone domain in which the subscription request was rejected.
        public let domainIdentifier: String
        /// The identifier of the subscription request that was rejected.
        public let identifier: String

        public init(decisionComment: String? = nil, domainIdentifier: String, identifier: String) {
            self.decisionComment = decisionComment
            self.domainIdentifier = domainIdentifier
            self.identifier = identifier
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.decisionComment, forKey: .decisionComment)
            request.encodePath(self.domainIdentifier, key: "domainIdentifier")
            request.encodePath(self.identifier, key: "identifier")
        }

        public func validate(name: String) throws {
            try self.validate(self.decisionComment, name: "decisionComment", parent: name, max: 4096)
            try self.validate(self.decisionComment, name: "decisionComment", parent: name, min: 1)
            try self.validate(self.domainIdentifier, name: "domainIdentifier", parent: name, pattern: "^dzd[-_][a-zA-Z0-9_-]{1,36}$")
            try self.validate(self.identifier, name: "identifier", parent: name, pattern: "^[a-zA-Z0-9_-]{1,36}$")
        }

        private enum CodingKeys: String, CodingKey {
            case decisionComment = "decisionComment"
        }
    }

    public struct RejectSubscriptionRequestOutput: AWSDecodableShape {
        /// The timestamp of when the subscription request was rejected.
        public let createdAt: Date
        /// The timestamp of when the subscription request was rejected.
        public let createdBy: String
        /// The decision comment of the rejected subscription request.
        public let decisionComment: String?
        /// The identifier of the Amazon DataZone domain in which the subscription request was rejected.
        public let domainId: String
        /// The identifier of the subscription request that was rejected.
        public let id: String
        /// The reason for the subscription request.
        public let requestReason: String
        /// The identifier of the subscription request reviewer.
        public let reviewerId: String?
        /// The status of the subscription request.
        public let status: SubscriptionRequestStatus
        /// The subscribed listings of the subscription request.
        public let subscribedListings: [SubscribedListing]
        /// The subscribed principals of the subscription request.
        public let subscribedPrincipals: [SubscribedPrincipal]
        /// The timestamp of when the subscription request was updated.
        public let updatedAt: Date
        /// The Amazon DataZone user who updated the subscription request.
        public let updatedBy: String?

        public init(createdAt: Date, createdBy: String, decisionComment: String? = nil, domainId: String, id: String, requestReason: String, reviewerId: String? = nil, status: SubscriptionRequestStatus, subscribedListings: [SubscribedListing], subscribedPrincipals: [SubscribedPrincipal], updatedAt: Date, updatedBy: String? = nil) {
            self.createdAt = createdAt
            self.createdBy = createdBy
            self.decisionComment = decisionComment
            self.domainId = domainId
            self.id = id
            self.requestReason = requestReason
            self.reviewerId = reviewerId
            self.status = status
            self.subscribedListings = subscribedListings
            self.subscribedPrincipals = subscribedPrincipals
            self.updatedAt = updatedAt
            self.updatedBy = updatedBy
        }

        private enum CodingKeys: String, CodingKey {
            case createdAt = "createdAt"
            case createdBy = "createdBy"
            case decisionComment = "decisionComment"
            case domainId = "domainId"
            case id = "id"
            case requestReason = "requestReason"
            case reviewerId = "reviewerId"
            case status = "status"
            case subscribedListings = "subscribedListings"
            case subscribedPrincipals = "subscribedPrincipals"
            case updatedAt = "updatedAt"
            case updatedBy = "updatedBy"
        }
    }

    public struct RelationalFilterConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The database name specified in the relational filter configuration for the data source.
        public let databaseName: String
        /// The filter expressions specified in the relational filter configuration for the data source.
        public let filterExpressions: [FilterExpression]?
        /// The schema name specified in the relational filter configuration for the data source.
        public let schemaName: String?

        public init(databaseName: String, filterExpressions: [FilterExpression]? = nil, schemaName: String? = nil) {
            self.databaseName = databaseName
            self.filterExpressions = filterExpressions
            self.schemaName = schemaName
        }

        private enum CodingKeys: String, CodingKey {
            case databaseName = "databaseName"
            case filterExpressions = "filterExpressions"
            case schemaName = "schemaName"
        }
    }

    public struct Resource: AWSDecodableShape {
        /// The name of a provisioned resource of this Amazon DataZone environment.
        public let name: String?
        /// The provider of a provisioned resource of this Amazon DataZone environment.
        public let provider: String?
        /// The type of a provisioned resource of this Amazon DataZone environment.
        public let type: String
        /// The value of a provisioned resource of this Amazon DataZone environment.
        public let value: String

        public init(name: String? = nil, provider: String? = nil, type: String, value: String) {
            self.name = name
            self.provider = provider
            self.type = type
            self.value = value
        }

        private enum CodingKeys: String, CodingKey {
            case name = "name"
            case provider = "provider"
            case type = "type"
            case value = "value"
        }
    }

    public struct RevokeSubscriptionInput: AWSEncodableShape {
        /// The identifier of the Amazon DataZone domain where you want to revoke a subscription.
        public let domainIdentifier: String
        /// The identifier of the revoked subscription.
        public let identifier: String
        /// Specifies whether permissions are retained when the subscription is revoked.
        public let retainPermissions: Bool?

        public init(domainIdentifier: String, identifier: String, retainPermissions: Bool? = nil) {
            self.domainIdentifier = domainIdentifier
            self.identifier = identifier
            self.retainPermissions = retainPermissions
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.domainIdentifier, key: "domainIdentifier")
            request.encodePath(self.identifier, key: "identifier")
            try container.encodeIfPresent(self.retainPermissions, forKey: .retainPermissions)
        }

        public func validate(name: String) throws {
            try self.validate(self.domainIdentifier, name: "domainIdentifier", parent: name, pattern: "^dzd[-_][a-zA-Z0-9_-]{1,36}$")
            try self.validate(self.identifier, name: "identifier", parent: name, pattern: "^[a-zA-Z0-9_-]{1,36}$")
        }

        private enum CodingKeys: String, CodingKey {
            case retainPermissions = "retainPermissions"
        }
    }

    public struct RevokeSubscriptionOutput: AWSDecodableShape {
        /// The timestamp of when the subscription was revoked.
        public let createdAt: Date
        /// The identifier of the user who revoked the subscription.
        public let createdBy: String
        /// The identifier of the Amazon DataZone domain where you want to revoke a subscription.
        public let domainId: String
        /// The identifier of the revoked subscription.
        public let id: String
        /// Specifies whether permissions are retained when the subscription is revoked.
        public let retainPermissions: Bool?
        /// The status of the revoked subscription.
        public let status: SubscriptionStatus
        /// The subscribed listing of the revoked subscription.
        public let subscribedListing: SubscribedListing
        /// The subscribed principal of the revoked subscription.
        public let subscribedPrincipal: SubscribedPrincipal
        /// The identifier of the subscription request for the revoked subscription.
        public let subscriptionRequestId: String?
        /// The timestamp of when the subscription was revoked.
        public let updatedAt: Date
        /// The Amazon DataZone user who revoked the subscription.
        public let updatedBy: String?

        public init(createdAt: Date, createdBy: String, domainId: String, id: String, retainPermissions: Bool? = nil, status: SubscriptionStatus, subscribedListing: SubscribedListing, subscribedPrincipal: SubscribedPrincipal, subscriptionRequestId: String? = nil, updatedAt: Date, updatedBy: String? = nil) {
            self.createdAt = createdAt
            self.createdBy = createdBy
            self.domainId = domainId
            self.id = id
            self.retainPermissions = retainPermissions
            self.status = status
            self.subscribedListing = subscribedListing
            self.subscribedPrincipal = subscribedPrincipal
            self.subscriptionRequestId = subscriptionRequestId
            self.updatedAt = updatedAt
            self.updatedBy = updatedBy
        }

        private enum CodingKeys: String, CodingKey {
            case createdAt = "createdAt"
            case createdBy = "createdBy"
            case domainId = "domainId"
            case id = "id"
            case retainPermissions = "retainPermissions"
            case status = "status"
            case subscribedListing = "subscribedListing"
            case subscribedPrincipal = "subscribedPrincipal"
            case subscriptionRequestId = "subscriptionRequestId"
            case updatedAt = "updatedAt"
            case updatedBy = "updatedBy"
        }
    }

    public struct RunStatisticsForAssets: AWSDecodableShape {
        /// The added statistic for the data source run.
        public let added: Int?
        /// The failed statistic for the data source run.
        public let failed: Int?
        /// The skipped statistic for the data source run.
        public let skipped: Int?
        /// The unchanged statistic for the data source run.
        public let unchanged: Int?
        /// The updated statistic for the data source run.
        public let updated: Int?

        public init(added: Int? = nil, failed: Int? = nil, skipped: Int? = nil, unchanged: Int? = nil, updated: Int? = nil) {
            self.added = added
            self.failed = failed
            self.skipped = skipped
            self.unchanged = unchanged
            self.updated = updated
        }

        private enum CodingKeys: String, CodingKey {
            case added = "added"
            case failed = "failed"
            case skipped = "skipped"
            case unchanged = "unchanged"
            case updated = "updated"
        }
    }

    public struct ScheduleConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The schedule of the data source runs.
        public let schedule: String?
        /// The timezone of the data source run.
        public let timezone: Timezone?

        public init(schedule: String? = nil, timezone: Timezone? = nil) {
            self.schedule = schedule
            self.timezone = timezone
        }

        public func validate(name: String) throws {
            try self.validate(self.schedule, name: "schedule", parent: name, max: 256)
            try self.validate(self.schedule, name: "schedule", parent: name, min: 1)
            try self.validate(self.schedule, name: "schedule", parent: name, pattern: "cron\\((\\b[0-5]?[0-9]\\b) (\\b2[0-3]\\b|\\b[0-1]?[0-9]\\b) (.*){1,5} (.*){1,5} (.*){1,5} (.*){1,5}\\)")
        }

        private enum CodingKeys: String, CodingKey {
            case schedule = "schedule"
            case timezone = "timezone"
        }
    }

    public struct SearchGroupProfilesInput: AWSEncodableShape {
        /// The identifier of the Amazon DataZone domain in which you want to search group profiles.
        public let domainIdentifier: String
        /// The group type for which to search.
        public let groupType: GroupSearchType
        /// The maximum number of results to return in a single call to SearchGroupProfiles. When the number of results to be listed is greater than the value of MaxResults, the response contains a NextToken value that you can use in a subsequent call to SearchGroupProfiles to list the next set of results.
        public let maxResults: Int?
        /// When the number of results is greater than the default value for the MaxResults parameter, or if you explicitly specify a value for MaxResults that is less than the number of results, the response includes a pagination token named NextToken. You can specify this NextToken value in a subsequent call to SearchGroupProfiles to list the next set of results.
        public let nextToken: String?
        /// Specifies the text for which to search.
        public let searchText: String?

        public init(domainIdentifier: String, groupType: GroupSearchType, maxResults: Int? = nil, nextToken: String? = nil, searchText: String? = nil) {
            self.domainIdentifier = domainIdentifier
            self.groupType = groupType
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.searchText = searchText
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.domainIdentifier, key: "domainIdentifier")
            try container.encode(self.groupType, forKey: .groupType)
            try container.encodeIfPresent(self.maxResults, forKey: .maxResults)
            try container.encodeIfPresent(self.nextToken, forKey: .nextToken)
            try container.encodeIfPresent(self.searchText, forKey: .searchText)
        }

        public func validate(name: String) throws {
            try self.validate(self.domainIdentifier, name: "domainIdentifier", parent: name, pattern: "^dzd[-_][a-zA-Z0-9_-]{1,36}$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 50)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 8192)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.searchText, name: "searchText", parent: name, max: 1024)
        }

        private enum CodingKeys: String, CodingKey {
            case groupType = "groupType"
            case maxResults = "maxResults"
            case nextToken = "nextToken"
            case searchText = "searchText"
        }
    }

    public struct SearchGroupProfilesOutput: AWSDecodableShape {
        /// The results of the SearchGroupProfiles action.
        public let items: [GroupProfileSummary]?
        /// When the number of results is greater than the default value for the MaxResults parameter, or if you explicitly specify a value for MaxResults that is less than the number of results, the response includes a pagination token named NextToken. You can specify this NextToken value in a subsequent call to SearchGroupProfiles to list the next set of results.
        public let nextToken: String?

        public init(items: [GroupProfileSummary]? = nil, nextToken: String? = nil) {
            self.items = items
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case items = "items"
            case nextToken = "nextToken"
        }
    }

    public struct SearchInItem: AWSEncodableShape {
        /// The search attribute.
        public let attribute: String

        public init(attribute: String) {
            self.attribute = attribute
        }

        public func validate(name: String) throws {
            try self.validate(self.attribute, name: "attribute", parent: name, max: 128)
            try self.validate(self.attribute, name: "attribute", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case attribute = "attribute"
        }
    }

    public struct SearchInput: AWSEncodableShape {
        /// Specifies additional attributes for the Search action.
        public let additionalAttributes: [SearchOutputAdditionalAttribute]?
        /// The identifier of the Amazon DataZone domain.
        public let domainIdentifier: String
        /// Specifies the search filters.
        public let filters: FilterClause?
        /// The maximum number of results to return in a single call to Search. When the number of results to be listed is greater than the value of MaxResults, the response contains a NextToken value that you can use in a subsequent call to Search to list the next set of results.
        public let maxResults: Int?
        /// When the number of results is greater than the default value for the MaxResults parameter, or if you explicitly specify a value for MaxResults that is less than the number of results, the response includes a pagination token named NextToken. You can specify this NextToken value in a subsequent call to Search to list the next set of results.
        public let nextToken: String?
        /// The identifier of the owning project specified for the search.
        public let owningProjectIdentifier: String?
        /// The details of the search.
        public let searchIn: [SearchInItem]?
        /// The scope of the search.
        public let searchScope: InventorySearchScope
        /// Specifies the text for which to search.
        public let searchText: String?
        /// Specifies the way in which the search results are to be sorted.
        public let sort: SearchSort?

        public init(additionalAttributes: [SearchOutputAdditionalAttribute]? = nil, domainIdentifier: String, filters: FilterClause? = nil, maxResults: Int? = nil, nextToken: String? = nil, owningProjectIdentifier: String? = nil, searchIn: [SearchInItem]? = nil, searchScope: InventorySearchScope, searchText: String? = nil, sort: SearchSort? = nil) {
            self.additionalAttributes = additionalAttributes
            self.domainIdentifier = domainIdentifier
            self.filters = filters
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.owningProjectIdentifier = owningProjectIdentifier
            self.searchIn = searchIn
            self.searchScope = searchScope
            self.searchText = searchText
            self.sort = sort
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.additionalAttributes, forKey: .additionalAttributes)
            request.encodePath(self.domainIdentifier, key: "domainIdentifier")
            try container.encodeIfPresent(self.filters, forKey: .filters)
            try container.encodeIfPresent(self.maxResults, forKey: .maxResults)
            try container.encodeIfPresent(self.nextToken, forKey: .nextToken)
            try container.encodeIfPresent(self.owningProjectIdentifier, forKey: .owningProjectIdentifier)
            try container.encodeIfPresent(self.searchIn, forKey: .searchIn)
            try container.encode(self.searchScope, forKey: .searchScope)
            try container.encodeIfPresent(self.searchText, forKey: .searchText)
            try container.encodeIfPresent(self.sort, forKey: .sort)
        }

        public func validate(name: String) throws {
            try self.validate(self.domainIdentifier, name: "domainIdentifier", parent: name, pattern: "^dzd[-_][a-zA-Z0-9_-]{1,36}$")
            try self.filters?.validate(name: "\(name).filters")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 50)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 8192)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.owningProjectIdentifier, name: "owningProjectIdentifier", parent: name, pattern: "^[a-zA-Z0-9_-]{1,36}$")
            try self.searchIn?.forEach {
                try $0.validate(name: "\(name).searchIn[]")
            }
            try self.validate(self.searchIn, name: "searchIn", parent: name, max: 10)
            try self.validate(self.searchIn, name: "searchIn", parent: name, min: 1)
            try self.validate(self.searchText, name: "searchText", parent: name, max: 4096)
            try self.validate(self.searchText, name: "searchText", parent: name, min: 1)
            try self.sort?.validate(name: "\(name).sort")
        }

        private enum CodingKeys: String, CodingKey {
            case additionalAttributes = "additionalAttributes"
            case filters = "filters"
            case maxResults = "maxResults"
            case nextToken = "nextToken"
            case owningProjectIdentifier = "owningProjectIdentifier"
            case searchIn = "searchIn"
            case searchScope = "searchScope"
            case searchText = "searchText"
            case sort = "sort"
        }
    }

    public struct SearchListingsInput: AWSEncodableShape {
        /// Specifies additional attributes for the search.
        public let additionalAttributes: [SearchOutputAdditionalAttribute]?
        /// The identifier of the domain in which to search listings.
        public let domainIdentifier: String
        /// Specifies the filters for the search of listings.
        public let filters: FilterClause?
        /// The maximum number of results to return in a single call to SearchListings. When the number of results to be listed is greater than the value of MaxResults, the response contains a NextToken value that you can use in a subsequent call to SearchListings to list the next set of results.
        public let maxResults: Int?
        /// When the number of results is greater than the default value for the MaxResults parameter, or if you explicitly specify a value for MaxResults that is less than the number of results, the response includes a pagination token named NextToken. You can specify this NextToken value in a subsequent call to SearchListings to list the next set of results.
        public let nextToken: String?
        /// The details of the search.
        public let searchIn: [SearchInItem]?
        /// Specifies the text for which to search.
        public let searchText: String?
        /// Specifies the way for sorting the search results.
        public let sort: SearchSort?

        public init(additionalAttributes: [SearchOutputAdditionalAttribute]? = nil, domainIdentifier: String, filters: FilterClause? = nil, maxResults: Int? = nil, nextToken: String? = nil, searchIn: [SearchInItem]? = nil, searchText: String? = nil, sort: SearchSort? = nil) {
            self.additionalAttributes = additionalAttributes
            self.domainIdentifier = domainIdentifier
            self.filters = filters
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.searchIn = searchIn
            self.searchText = searchText
            self.sort = sort
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.additionalAttributes, forKey: .additionalAttributes)
            request.encodePath(self.domainIdentifier, key: "domainIdentifier")
            try container.encodeIfPresent(self.filters, forKey: .filters)
            try container.encodeIfPresent(self.maxResults, forKey: .maxResults)
            try container.encodeIfPresent(self.nextToken, forKey: .nextToken)
            try container.encodeIfPresent(self.searchIn, forKey: .searchIn)
            try container.encodeIfPresent(self.searchText, forKey: .searchText)
            try container.encodeIfPresent(self.sort, forKey: .sort)
        }

        public func validate(name: String) throws {
            try self.validate(self.domainIdentifier, name: "domainIdentifier", parent: name, pattern: "^dzd[-_][a-zA-Z0-9_-]{1,36}$")
            try self.filters?.validate(name: "\(name).filters")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 50)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 8192)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.searchIn?.forEach {
                try $0.validate(name: "\(name).searchIn[]")
            }
            try self.validate(self.searchIn, name: "searchIn", parent: name, max: 10)
            try self.validate(self.searchIn, name: "searchIn", parent: name, min: 1)
            try self.sort?.validate(name: "\(name).sort")
        }

        private enum CodingKeys: String, CodingKey {
            case additionalAttributes = "additionalAttributes"
            case filters = "filters"
            case maxResults = "maxResults"
            case nextToken = "nextToken"
            case searchIn = "searchIn"
            case searchText = "searchText"
            case sort = "sort"
        }
    }

    public struct SearchListingsOutput: AWSDecodableShape {
        /// The results of the SearchListings action.
        public let items: [SearchResultItem]?
        /// When the number of results is greater than the default value for the MaxResults parameter, or if you explicitly specify a value for MaxResults that is less than the number of results, the response includes a pagination token named NextToken. You can specify this NextToken value in a subsequent call to SearchListings to list the next set of results.
        public let nextToken: String?
        /// Total number of search results.
        public let totalMatchCount: Int?

        public init(items: [SearchResultItem]? = nil, nextToken: String? = nil, totalMatchCount: Int? = nil) {
            self.items = items
            self.nextToken = nextToken
            self.totalMatchCount = totalMatchCount
        }

        private enum CodingKeys: String, CodingKey {
            case items = "items"
            case nextToken = "nextToken"
            case totalMatchCount = "totalMatchCount"
        }
    }

    public struct SearchOutput: AWSDecodableShape {
        /// The results of the Search action.
        public let items: [SearchInventoryResultItem]?
        /// When the number of results is greater than the default value for the MaxResults parameter, or if you explicitly specify a value for MaxResults that is less than the number of results, the response includes a pagination token named NextToken. You can specify this NextToken value in a subsequent call to Search to list the next set of results.
        public let nextToken: String?
        /// Total number of search results.
        public let totalMatchCount: Int?

        public init(items: [SearchInventoryResultItem]? = nil, nextToken: String? = nil, totalMatchCount: Int? = nil) {
            self.items = items
            self.nextToken = nextToken
            self.totalMatchCount = totalMatchCount
        }

        private enum CodingKeys: String, CodingKey {
            case items = "items"
            case nextToken = "nextToken"
            case totalMatchCount = "totalMatchCount"
        }
    }

    public struct SearchSort: AWSEncodableShape {
        /// The attribute detail of the way to sort search results.
        public let attribute: String
        /// The order detail of the wya to sort search results.
        public let order: SortOrder?

        public init(attribute: String, order: SortOrder? = nil) {
            self.attribute = attribute
            self.order = order
        }

        public func validate(name: String) throws {
            try self.validate(self.attribute, name: "attribute", parent: name, max: 128)
            try self.validate(self.attribute, name: "attribute", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case attribute = "attribute"
            case order = "order"
        }
    }

    public struct SearchTypesInput: AWSEncodableShape {
        /// The identifier of the Amazon DataZone domain in which to invoke the SearchTypes action.
        public let domainIdentifier: String
        /// The filters for the SearchTypes action.
        public let filters: FilterClause?
        /// Specifies whether the search is managed.
        public let managed: Bool
        /// The maximum number of results to return in a single call to SearchTypes. When the number of results to be listed is greater than the value of MaxResults, the response contains a NextToken value that you can use in a subsequent call to SearchTypes to list the next set of results.
        public let maxResults: Int?
        /// When the number of results is greater than the default value for the MaxResults parameter, or if you explicitly specify a value for MaxResults that is less than the number of results, the response includes a pagination token named NextToken. You can specify this NextToken value in a subsequent call to SearchTypes to list the next set of results.
        public let nextToken: String?
        /// The details of the search.
        public let searchIn: [SearchInItem]?
        /// Specifies the scope of the search for types.
        public let searchScope: TypesSearchScope
        /// Specifies the text for which to search.
        public let searchText: String?
        /// The specifies the way to sort the SearchTypes results.
        public let sort: SearchSort?

        public init(domainIdentifier: String, filters: FilterClause? = nil, managed: Bool, maxResults: Int? = nil, nextToken: String? = nil, searchIn: [SearchInItem]? = nil, searchScope: TypesSearchScope, searchText: String? = nil, sort: SearchSort? = nil) {
            self.domainIdentifier = domainIdentifier
            self.filters = filters
            self.managed = managed
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.searchIn = searchIn
            self.searchScope = searchScope
            self.searchText = searchText
            self.sort = sort
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.domainIdentifier, key: "domainIdentifier")
            try container.encodeIfPresent(self.filters, forKey: .filters)
            try container.encode(self.managed, forKey: .managed)
            try container.encodeIfPresent(self.maxResults, forKey: .maxResults)
            try container.encodeIfPresent(self.nextToken, forKey: .nextToken)
            try container.encodeIfPresent(self.searchIn, forKey: .searchIn)
            try container.encode(self.searchScope, forKey: .searchScope)
            try container.encodeIfPresent(self.searchText, forKey: .searchText)
            try container.encodeIfPresent(self.sort, forKey: .sort)
        }

        public func validate(name: String) throws {
            try self.validate(self.domainIdentifier, name: "domainIdentifier", parent: name, pattern: "^dzd[-_][a-zA-Z0-9_-]{1,36}$")
            try self.filters?.validate(name: "\(name).filters")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 50)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 8192)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.searchIn?.forEach {
                try $0.validate(name: "\(name).searchIn[]")
            }
            try self.validate(self.searchIn, name: "searchIn", parent: name, max: 10)
            try self.validate(self.searchIn, name: "searchIn", parent: name, min: 1)
            try self.validate(self.searchText, name: "searchText", parent: name, max: 4096)
            try self.validate(self.searchText, name: "searchText", parent: name, min: 1)
            try self.sort?.validate(name: "\(name).sort")
        }

        private enum CodingKeys: String, CodingKey {
            case filters = "filters"
            case managed = "managed"
            case maxResults = "maxResults"
            case nextToken = "nextToken"
            case searchIn = "searchIn"
            case searchScope = "searchScope"
            case searchText = "searchText"
            case sort = "sort"
        }
    }

    public struct SearchTypesOutput: AWSDecodableShape {
        /// The results of the SearchTypes action.
        public let items: [SearchTypesResultItem]?
        /// When the number of results is greater than the default value for the MaxResults parameter, or if you explicitly specify a value for MaxResults that is less than the number of results, the response includes a pagination token named NextToken. You can specify this NextToken value in a subsequent call to SearchTypes to list the next set of results.
        public let nextToken: String?
        /// Total number of search results.
        public let totalMatchCount: Int?

        public init(items: [SearchTypesResultItem]? = nil, nextToken: String? = nil, totalMatchCount: Int? = nil) {
            self.items = items
            self.nextToken = nextToken
            self.totalMatchCount = totalMatchCount
        }

        private enum CodingKeys: String, CodingKey {
            case items = "items"
            case nextToken = "nextToken"
            case totalMatchCount = "totalMatchCount"
        }
    }

    public struct SearchUserProfilesInput: AWSEncodableShape {
        /// The identifier of the Amazon DataZone domain in which you want to search user profiles.
        public let domainIdentifier: String
        /// The maximum number of results to return in a single call to SearchUserProfiles. When the number of results to be listed is greater than the value of MaxResults, the response contains a NextToken value that you can use in a subsequent call to SearchUserProfiles to list the next set of results.
        public let maxResults: Int?
        /// When the number of results is greater than the default value for the MaxResults parameter, or if you explicitly specify a value for MaxResults that is less than the number of results, the response includes a pagination token named NextToken. You can specify this NextToken value in a subsequent call to SearchUserProfiles to list the next set of results.
        public let nextToken: String?
        /// Specifies the text for which to search.
        public let searchText: String?
        /// Specifies the user type for the SearchUserProfiles action.
        public let userType: UserSearchType

        public init(domainIdentifier: String, maxResults: Int? = nil, nextToken: String? = nil, searchText: String? = nil, userType: UserSearchType) {
            self.domainIdentifier = domainIdentifier
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.searchText = searchText
            self.userType = userType
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.domainIdentifier, key: "domainIdentifier")
            try container.encodeIfPresent(self.maxResults, forKey: .maxResults)
            try container.encodeIfPresent(self.nextToken, forKey: .nextToken)
            try container.encodeIfPresent(self.searchText, forKey: .searchText)
            try container.encode(self.userType, forKey: .userType)
        }

        public func validate(name: String) throws {
            try self.validate(self.domainIdentifier, name: "domainIdentifier", parent: name, pattern: "^dzd[-_][a-zA-Z0-9_-]{1,36}$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 50)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 8192)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.searchText, name: "searchText", parent: name, max: 1024)
        }

        private enum CodingKeys: String, CodingKey {
            case maxResults = "maxResults"
            case nextToken = "nextToken"
            case searchText = "searchText"
            case userType = "userType"
        }
    }

    public struct SearchUserProfilesOutput: AWSDecodableShape {
        /// The results of the SearchUserProfiles action.
        public let items: [UserProfileSummary]?
        /// When the number of results is greater than the default value for the MaxResults parameter, or if you explicitly specify a value for MaxResults that is less than the number of results, the response includes a pagination token named NextToken. You can specify this NextToken value in a subsequent call to SearchUserProfiles to list the next set of results.
        public let nextToken: String?

        public init(items: [UserProfileSummary]? = nil, nextToken: String? = nil) {
            self.items = items
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case items = "items"
            case nextToken = "nextToken"
        }
    }

    public struct SingleSignOn: AWSEncodableShape & AWSDecodableShape {
        /// The type of single sign-on in Amazon DataZone.
        public let type: AuthType?
        /// The single sign-on user assignment in Amazon DataZone.
        public let userAssignment: UserAssignment?

        public init(type: AuthType? = nil, userAssignment: UserAssignment? = nil) {
            self.type = type
            self.userAssignment = userAssignment
        }

        private enum CodingKeys: String, CodingKey {
            case type = "type"
            case userAssignment = "userAssignment"
        }
    }

    public struct SsoUserProfileDetails: AWSDecodableShape {
        /// The first name included in the single sign-on details of the user profile.
        public let firstName: String?
        /// The last name included in the single sign-on details of the user profile.
        public let lastName: String?
        /// The username included in the single sign-on details of the user profile.
        public let username: String?

        public init(firstName: String? = nil, lastName: String? = nil, username: String? = nil) {
            self.firstName = firstName
            self.lastName = lastName
            self.username = username
        }

        private enum CodingKeys: String, CodingKey {
            case firstName = "firstName"
            case lastName = "lastName"
            case username = "username"
        }
    }

    public struct StartDataSourceRunInput: AWSEncodableShape {
        /// A unique, case-sensitive identifier that is provided to ensure the idempotency of the request.
        public let clientToken: String?
        /// The identifier of the data source.
        public let dataSourceIdentifier: String
        /// The identifier of the Amazon DataZone domain in which to start a data source run.
        public let domainIdentifier: String

        public init(clientToken: String? = StartDataSourceRunInput.idempotencyToken(), dataSourceIdentifier: String, domainIdentifier: String) {
            self.clientToken = clientToken
            self.dataSourceIdentifier = dataSourceIdentifier
            self.domainIdentifier = domainIdentifier
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.clientToken, forKey: .clientToken)
            request.encodePath(self.dataSourceIdentifier, key: "dataSourceIdentifier")
            request.encodePath(self.domainIdentifier, key: "domainIdentifier")
        }

        public func validate(name: String) throws {
            try self.validate(self.dataSourceIdentifier, name: "dataSourceIdentifier", parent: name, pattern: "^[a-zA-Z0-9_-]{1,36}$")
            try self.validate(self.domainIdentifier, name: "domainIdentifier", parent: name, pattern: "^dzd[-_][a-zA-Z0-9_-]{1,36}$")
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "clientToken"
        }
    }

    public struct StartDataSourceRunOutput: AWSDecodableShape {
        /// The timestamp of when data source run was created.
        @CustomCoding<ISO8601DateCoder>
        public var createdAt: Date
        /// The configuration snapshot of the data source that is being run.
        public let dataSourceConfigurationSnapshot: String?
        /// The identifier of the data source.
        public let dataSourceId: String
        /// The identifier of the Amazon DataZone domain in which to start a data source run.
        public let domainId: String
        /// Specifies the error message that is returned if the operation cannot be successfully completed.
        public let errorMessage: DataSourceErrorMessage?
        /// The identifier of the data source run.
        public let id: String
        /// The identifier of the project.
        public let projectId: String
        /// Specifies run statistics for assets.
        public let runStatisticsForAssets: RunStatisticsForAssets?
        /// The timestamp of when the data source run was started.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var startedAt: Date?
        /// The status of the data source run.
        public let status: DataSourceRunStatus
        /// The timestamp of when the data source run was stopped.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var stoppedAt: Date?
        /// The type of the data source run.
        public let type: DataSourceRunType
        /// The timestamp of when the data source run was updated.
        @CustomCoding<ISO8601DateCoder>
        public var updatedAt: Date

        public init(createdAt: Date, dataSourceConfigurationSnapshot: String? = nil, dataSourceId: String, domainId: String, errorMessage: DataSourceErrorMessage? = nil, id: String, projectId: String, runStatisticsForAssets: RunStatisticsForAssets? = nil, startedAt: Date? = nil, status: DataSourceRunStatus, stoppedAt: Date? = nil, type: DataSourceRunType, updatedAt: Date) {
            self.createdAt = createdAt
            self.dataSourceConfigurationSnapshot = dataSourceConfigurationSnapshot
            self.dataSourceId = dataSourceId
            self.domainId = domainId
            self.errorMessage = errorMessage
            self.id = id
            self.projectId = projectId
            self.runStatisticsForAssets = runStatisticsForAssets
            self.startedAt = startedAt
            self.status = status
            self.stoppedAt = stoppedAt
            self.type = type
            self.updatedAt = updatedAt
        }

        private enum CodingKeys: String, CodingKey {
            case createdAt = "createdAt"
            case dataSourceConfigurationSnapshot = "dataSourceConfigurationSnapshot"
            case dataSourceId = "dataSourceId"
            case domainId = "domainId"
            case errorMessage = "errorMessage"
            case id = "id"
            case projectId = "projectId"
            case runStatisticsForAssets = "runStatisticsForAssets"
            case startedAt = "startedAt"
            case status = "status"
            case stoppedAt = "stoppedAt"
            case type = "type"
            case updatedAt = "updatedAt"
        }
    }

    public struct StartMetadataGenerationRunInput: AWSEncodableShape {
        /// A unique, case-sensitive identifier to ensure idempotency of the request. This field is automatically populated if not provided.
        public let clientToken: String?
        /// The ID of the Amazon DataZone domain where you want to start a metadata generation run.
        public let domainIdentifier: String
        /// The ID of the project that owns the asset for which you want to start a metadata generation run.
        public let owningProjectIdentifier: String
        /// The asset for which you want to start a metadata generation run.
        public let target: MetadataGenerationRunTarget
        /// The type of the metadata generation run.
        public let type: MetadataGenerationRunType

        public init(clientToken: String? = StartMetadataGenerationRunInput.idempotencyToken(), domainIdentifier: String, owningProjectIdentifier: String, target: MetadataGenerationRunTarget, type: MetadataGenerationRunType) {
            self.clientToken = clientToken
            self.domainIdentifier = domainIdentifier
            self.owningProjectIdentifier = owningProjectIdentifier
            self.target = target
            self.type = type
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.clientToken, forKey: .clientToken)
            request.encodePath(self.domainIdentifier, key: "domainIdentifier")
            try container.encode(self.owningProjectIdentifier, forKey: .owningProjectIdentifier)
            try container.encode(self.target, forKey: .target)
            try container.encode(self.type, forKey: .type)
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 128)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "^[\\x21-\\x7E]+$")
            try self.validate(self.domainIdentifier, name: "domainIdentifier", parent: name, pattern: "^dzd[-_][a-zA-Z0-9_-]{1,36}$")
            try self.validate(self.owningProjectIdentifier, name: "owningProjectIdentifier", parent: name, pattern: "^[a-zA-Z0-9_-]{1,36}$")
            try self.target.validate(name: "\(name).target")
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "clientToken"
            case owningProjectIdentifier = "owningProjectIdentifier"
            case target = "target"
            case type = "type"
        }
    }

    public struct StartMetadataGenerationRunOutput: AWSDecodableShape {
        /// The timestamp at which the metadata generation run was started.
        public let createdAt: Date?
        /// The ID of the user who started the metadata generation run.
        public let createdBy: String?
        /// The ID of the Amazon DataZone domain in which the metadata generation run was started.
        public let domainId: String
        /// The ID of the metadata generation run.
        public let id: String
        /// The ID of the project that owns the asset for which the metadata generation run was started.
        public let owningProjectId: String?
        /// The status of the metadata generation run.
        public let status: MetadataGenerationRunStatus?
        /// The type of the metadata generation run.
        public let type: MetadataGenerationRunType?

        public init(createdAt: Date? = nil, createdBy: String? = nil, domainId: String, id: String, owningProjectId: String? = nil, status: MetadataGenerationRunStatus? = nil, type: MetadataGenerationRunType? = nil) {
            self.createdAt = createdAt
            self.createdBy = createdBy
            self.domainId = domainId
            self.id = id
            self.owningProjectId = owningProjectId
            self.status = status
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case createdAt = "createdAt"
            case createdBy = "createdBy"
            case domainId = "domainId"
            case id = "id"
            case owningProjectId = "owningProjectId"
            case status = "status"
            case type = "type"
        }
    }

    public struct SubscribedAsset: AWSDecodableShape {
        /// The identifier of the asset for which the subscription grant is created.
        public let assetId: String
        /// The revision of the asset for which the subscription grant is created.
        public let assetRevision: String
        /// The failure cause included in the details of the asset for which the subscription grant is created.
        public let failureCause: FailureCause?
        /// The failure timestamp included in the details of the asset for which the subscription grant is created.
        public let failureTimestamp: Date?
        /// The timestamp of when the subscription grant to the asset is created.
        public let grantedTimestamp: Date?
        /// The status of the asset for which the subscription grant is created.
        public let status: SubscriptionGrantStatus
        /// The target name of the asset for which the subscription grant is created.
        public let targetName: String?

        public init(assetId: String, assetRevision: String, failureCause: FailureCause? = nil, failureTimestamp: Date? = nil, grantedTimestamp: Date? = nil, status: SubscriptionGrantStatus, targetName: String? = nil) {
            self.assetId = assetId
            self.assetRevision = assetRevision
            self.failureCause = failureCause
            self.failureTimestamp = failureTimestamp
            self.grantedTimestamp = grantedTimestamp
            self.status = status
            self.targetName = targetName
        }

        private enum CodingKeys: String, CodingKey {
            case assetId = "assetId"
            case assetRevision = "assetRevision"
            case failureCause = "failureCause"
            case failureTimestamp = "failureTimestamp"
            case grantedTimestamp = "grantedTimestamp"
            case status = "status"
            case targetName = "targetName"
        }
    }

    public struct SubscribedAssetListing: AWSDecodableShape {
        /// The identifier of the published asset for which the subscription grant is created.
        public let entityId: String?
        /// The revision of the published asset for which the subscription grant is created.
        public let entityRevision: String?
        /// The type of the published asset for which the subscription grant is created.
        public let entityType: String?
        /// The forms attached to the published asset for which the subscription grant is created.
        public let forms: String?
        /// The glossary terms attached to the published asset for which the subscription grant is created.
        public let glossaryTerms: [DetailedGlossaryTerm]?

        public init(entityId: String? = nil, entityRevision: String? = nil, entityType: String? = nil, forms: String? = nil, glossaryTerms: [DetailedGlossaryTerm]? = nil) {
            self.entityId = entityId
            self.entityRevision = entityRevision
            self.entityType = entityType
            self.forms = forms
            self.glossaryTerms = glossaryTerms
        }

        private enum CodingKeys: String, CodingKey {
            case entityId = "entityId"
            case entityRevision = "entityRevision"
            case entityType = "entityType"
            case forms = "forms"
            case glossaryTerms = "glossaryTerms"
        }
    }

    public struct SubscribedListing: AWSDecodableShape {
        /// The description of the published asset for which the subscription grant is created.
        public let description: String
        /// The identifier of the published asset for which the subscription grant is created.
        public let id: String
        /// The published asset for which the subscription grant is created.
        public let item: SubscribedListingItem
        /// The name of the published asset for which the subscription grant is created.
        public let name: String
        /// The identifier of the project of the published asset for which the subscription grant is created.
        public let ownerProjectId: String
        /// The name of the project that owns the published asset for which the subscription grant is created.
        public let ownerProjectName: String?
        /// The revision of the published asset for which the subscription grant is created.
        public let revision: String?

        public init(description: String, id: String, item: SubscribedListingItem, name: String, ownerProjectId: String, ownerProjectName: String? = nil, revision: String? = nil) {
            self.description = description
            self.id = id
            self.item = item
            self.name = name
            self.ownerProjectId = ownerProjectId
            self.ownerProjectName = ownerProjectName
            self.revision = revision
        }

        private enum CodingKeys: String, CodingKey {
            case description = "description"
            case id = "id"
            case item = "item"
            case name = "name"
            case ownerProjectId = "ownerProjectId"
            case ownerProjectName = "ownerProjectName"
            case revision = "revision"
        }
    }

    public struct SubscribedListingInput: AWSEncodableShape {
        /// The identifier of the published asset for which the subscription grant is to be created.
        public let identifier: String

        public init(identifier: String) {
            self.identifier = identifier
        }

        public func validate(name: String) throws {
            try self.validate(self.identifier, name: "identifier", parent: name, pattern: "^[a-zA-Z0-9_-]{1,36}$")
        }

        private enum CodingKeys: String, CodingKey {
            case identifier = "identifier"
        }
    }

    public struct SubscribedProject: AWSDecodableShape {
        /// The identifier of the project that has the subscription grant.
        public let id: String?
        /// The name of the project that has the subscription grant.
        public let name: String?

        public init(id: String? = nil, name: String? = nil) {
            self.id = id
            self.name = name
        }

        private enum CodingKeys: String, CodingKey {
            case id = "id"
            case name = "name"
        }
    }

    public struct SubscribedProjectInput: AWSEncodableShape {
        /// The identifier of the project that is to be given a subscription grant.
        public let identifier: String?

        public init(identifier: String? = nil) {
            self.identifier = identifier
        }

        public func validate(name: String) throws {
            try self.validate(self.identifier, name: "identifier", parent: name, pattern: "^[a-zA-Z0-9_-]{1,36}$")
        }

        private enum CodingKeys: String, CodingKey {
            case identifier = "identifier"
        }
    }

    public struct SubscriptionGrantSummary: AWSDecodableShape {
        /// The assets included in the subscription grant.
        public let assets: [SubscribedAsset]?
        /// The timestamp of when a subscription grant was created.
        public let createdAt: Date
        /// The datazone user who created the subscription grant.
        public let createdBy: String
        /// The identifier of the Amazon DataZone domain in which a subscription grant exists.
        public let domainId: String
        /// The entity to which the subscription is granted.
        public let grantedEntity: GrantedEntity
        /// The identifier of the subscription grant.
        public let id: String
        /// The status of the subscription grant.
        public let status: SubscriptionGrantOverallStatus
        /// The ID of the subscription grant.
        public let subscriptionId: String?
        /// The identifier of the target of the subscription grant.
        public let subscriptionTargetId: String
        /// The timestampf of when the subscription grant was updated.
        public let updatedAt: Date
        /// The Amazon DataZone user who updated the subscription grant.
        public let updatedBy: String?

        public init(assets: [SubscribedAsset]? = nil, createdAt: Date, createdBy: String, domainId: String, grantedEntity: GrantedEntity, id: String, status: SubscriptionGrantOverallStatus, subscriptionId: String? = nil, subscriptionTargetId: String, updatedAt: Date, updatedBy: String? = nil) {
            self.assets = assets
            self.createdAt = createdAt
            self.createdBy = createdBy
            self.domainId = domainId
            self.grantedEntity = grantedEntity
            self.id = id
            self.status = status
            self.subscriptionId = subscriptionId
            self.subscriptionTargetId = subscriptionTargetId
            self.updatedAt = updatedAt
            self.updatedBy = updatedBy
        }

        private enum CodingKeys: String, CodingKey {
            case assets = "assets"
            case createdAt = "createdAt"
            case createdBy = "createdBy"
            case domainId = "domainId"
            case grantedEntity = "grantedEntity"
            case id = "id"
            case status = "status"
            case subscriptionId = "subscriptionId"
            case subscriptionTargetId = "subscriptionTargetId"
            case updatedAt = "updatedAt"
            case updatedBy = "updatedBy"
        }
    }

    public struct SubscriptionRequestSummary: AWSDecodableShape {
        /// The timestamp of when a subscription request was created.
        public let createdAt: Date
        /// The Amazon DataZone user who created the subscription request.
        public let createdBy: String
        /// The decision comment of the subscription request.
        public let decisionComment: String?
        /// The identifier of the Amazon DataZone domain in which a subscription request exists.
        public let domainId: String
        /// The identifier of the subscription request.
        public let id: String
        /// The reason for the subscription request.
        public let requestReason: String
        /// The identifier of the subscription request reviewer.
        public let reviewerId: String?
        /// The status of the subscription request.
        public let status: SubscriptionRequestStatus
        /// The listings included in the subscription request.
        public let subscribedListings: [SubscribedListing]
        /// The principals included in the subscription request.
        public let subscribedPrincipals: [SubscribedPrincipal]
        /// The timestamp of when the subscription request was updated.
        public let updatedAt: Date
        /// The identifier of the Amazon DataZone user who updated the subscription request.
        public let updatedBy: String?

        public init(createdAt: Date, createdBy: String, decisionComment: String? = nil, domainId: String, id: String, requestReason: String, reviewerId: String? = nil, status: SubscriptionRequestStatus, subscribedListings: [SubscribedListing], subscribedPrincipals: [SubscribedPrincipal], updatedAt: Date, updatedBy: String? = nil) {
            self.createdAt = createdAt
            self.createdBy = createdBy
            self.decisionComment = decisionComment
            self.domainId = domainId
            self.id = id
            self.requestReason = requestReason
            self.reviewerId = reviewerId
            self.status = status
            self.subscribedListings = subscribedListings
            self.subscribedPrincipals = subscribedPrincipals
            self.updatedAt = updatedAt
            self.updatedBy = updatedBy
        }

        private enum CodingKeys: String, CodingKey {
            case createdAt = "createdAt"
            case createdBy = "createdBy"
            case decisionComment = "decisionComment"
            case domainId = "domainId"
            case id = "id"
            case requestReason = "requestReason"
            case reviewerId = "reviewerId"
            case status = "status"
            case subscribedListings = "subscribedListings"
            case subscribedPrincipals = "subscribedPrincipals"
            case updatedAt = "updatedAt"
            case updatedBy = "updatedBy"
        }
    }

    public struct SubscriptionSummary: AWSDecodableShape {
        /// The timestamp of when the subscription was created.
        public let createdAt: Date
        /// The Amazon DataZone user who created the subscription.
        public let createdBy: String
        /// The identifier of the Amazon DataZone domain in which a subscription exists.
        public let domainId: String
        /// The identifier of the subscription.
        public let id: String
        /// The retain permissions included in the subscription.
        public let retainPermissions: Bool?
        /// The status of the subscription.
        public let status: SubscriptionStatus
        /// The listing included in the subscription.
        public let subscribedListing: SubscribedListing
        /// The principal included in the subscription.
        public let subscribedPrincipal: SubscribedPrincipal
        /// The identifier of the subscription request for the subscription.
        public let subscriptionRequestId: String?
        /// The timestamp of when the subscription was updated.
        public let updatedAt: Date
        /// The Amazon DataZone user who updated the subscription.
        public let updatedBy: String?

        public init(createdAt: Date, createdBy: String, domainId: String, id: String, retainPermissions: Bool? = nil, status: SubscriptionStatus, subscribedListing: SubscribedListing, subscribedPrincipal: SubscribedPrincipal, subscriptionRequestId: String? = nil, updatedAt: Date, updatedBy: String? = nil) {
            self.createdAt = createdAt
            self.createdBy = createdBy
            self.domainId = domainId
            self.id = id
            self.retainPermissions = retainPermissions
            self.status = status
            self.subscribedListing = subscribedListing
            self.subscribedPrincipal = subscribedPrincipal
            self.subscriptionRequestId = subscriptionRequestId
            self.updatedAt = updatedAt
            self.updatedBy = updatedBy
        }

        private enum CodingKeys: String, CodingKey {
            case createdAt = "createdAt"
            case createdBy = "createdBy"
            case domainId = "domainId"
            case id = "id"
            case retainPermissions = "retainPermissions"
            case status = "status"
            case subscribedListing = "subscribedListing"
            case subscribedPrincipal = "subscribedPrincipal"
            case subscriptionRequestId = "subscriptionRequestId"
            case updatedAt = "updatedAt"
            case updatedBy = "updatedBy"
        }
    }

    public struct SubscriptionTargetForm: AWSEncodableShape & AWSDecodableShape {
        /// The content of the subscription target configuration.
        public let content: String
        /// The form name included in the subscription target configuration.
        public let formName: String

        public init(content: String, formName: String) {
            self.content = content
            self.formName = formName
        }

        public func validate(name: String) throws {
            try self.validate(self.formName, name: "formName", parent: name, max: 128)
            try self.validate(self.formName, name: "formName", parent: name, min: 1)
            try self.validate(self.formName, name: "formName", parent: name, pattern: "^(?![0-9_])\\w+$|^_\\w*[a-zA-Z0-9]\\w*$")
        }

        private enum CodingKeys: String, CodingKey {
            case content = "content"
            case formName = "formName"
        }
    }

    public struct SubscriptionTargetSummary: AWSDecodableShape {
        /// The asset types included in the subscription target.
        public let applicableAssetTypes: [String]
        /// The authorized principals included in the subscription target.
        public let authorizedPrincipals: [String]
        /// The timestamp of when the subscription target was created.
        public let createdAt: Date
        /// The Amazon DataZone user who created the subscription target.
        public let createdBy: String
        /// The identifier of the Amazon DataZone domain in which the subscription target exists.
        public let domainId: String
        /// The identifier of the environment of the subscription target.
        public let environmentId: String
        /// The identifier of the subscription target.
        public let id: String
        /// The manage access role specified in the subscription target.
        public let manageAccessRole: String
        /// The name of the subscription target.
        public let name: String
        /// The identifier of the project specified in the subscription target.
        public let projectId: String
        /// The provider of the subscription target.
        public let provider: String
        /// The configuration of the subscription target.
        public let subscriptionTargetConfig: [SubscriptionTargetForm]
        /// The type of the subscription target.
        public let type: String
        /// The timestamp of when the subscription target was updated.
        public let updatedAt: Date?
        /// The Amazon DataZone user who updated the subscription target.
        public let updatedBy: String?

        public init(applicableAssetTypes: [String], authorizedPrincipals: [String], createdAt: Date, createdBy: String, domainId: String, environmentId: String, id: String, manageAccessRole: String, name: String, projectId: String, provider: String, subscriptionTargetConfig: [SubscriptionTargetForm], type: String, updatedAt: Date? = nil, updatedBy: String? = nil) {
            self.applicableAssetTypes = applicableAssetTypes
            self.authorizedPrincipals = authorizedPrincipals
            self.createdAt = createdAt
            self.createdBy = createdBy
            self.domainId = domainId
            self.environmentId = environmentId
            self.id = id
            self.manageAccessRole = manageAccessRole
            self.name = name
            self.projectId = projectId
            self.provider = provider
            self.subscriptionTargetConfig = subscriptionTargetConfig
            self.type = type
            self.updatedAt = updatedAt
            self.updatedBy = updatedBy
        }

        private enum CodingKeys: String, CodingKey {
            case applicableAssetTypes = "applicableAssetTypes"
            case authorizedPrincipals = "authorizedPrincipals"
            case createdAt = "createdAt"
            case createdBy = "createdBy"
            case domainId = "domainId"
            case environmentId = "environmentId"
            case id = "id"
            case manageAccessRole = "manageAccessRole"
            case name = "name"
            case projectId = "projectId"
            case provider = "provider"
            case subscriptionTargetConfig = "subscriptionTargetConfig"
            case type = "type"
            case updatedAt = "updatedAt"
            case updatedBy = "updatedBy"
        }
    }

    public struct TagResourceRequest: AWSEncodableShape {
        /// The ARN of the resource to be tagged in Amazon DataZone.
        public let resourceArn: String
        /// Specifies the tags for the TagResource action.
        public let tags: [String: String]

        public init(resourceArn: String, tags: [String: String]) {
            self.resourceArn = resourceArn
            self.tags = tags
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.resourceArn, key: "resourceArn")
            try container.encode(self.tags, forKey: .tags)
        }

        public func validate(name: String) throws {
            try self.tags.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.key, name: "tags.key", parent: name, pattern: "^[\\w \\.:/=+@-]+$")
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, pattern: "^[\\w \\.:/=+@-]*$")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case tags = "tags"
        }
    }

    public struct TagResourceResponse: AWSDecodableShape {
        public init() {}
    }

    public struct TermRelations: AWSEncodableShape & AWSDecodableShape {
        /// The classifies of the term relations.
        public let classifies: [String]?
        /// The isA property of the term relations.
        public let isA: [String]?

        public init(classifies: [String]? = nil, isA: [String]? = nil) {
            self.classifies = classifies
            self.isA = isA
        }

        public func validate(name: String) throws {
            try self.classifies?.forEach {
                try validate($0, name: "classifies[]", parent: name, pattern: "^[a-zA-Z0-9_-]{1,36}$")
            }
            try self.validate(self.classifies, name: "classifies", parent: name, max: 20)
            try self.validate(self.classifies, name: "classifies", parent: name, min: 1)
            try self.isA?.forEach {
                try validate($0, name: "isA[]", parent: name, pattern: "^[a-zA-Z0-9_-]{1,36}$")
            }
            try self.validate(self.isA, name: "isA", parent: name, max: 20)
            try self.validate(self.isA, name: "isA", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case classifies = "classifies"
            case isA = "isA"
        }
    }

    public struct TimeSeriesDataPointFormInput: AWSEncodableShape {
        /// The content of the time series data points form.
        public let content: String?
        /// The name of the time series data points form.
        public let formName: String
        /// The timestamp of the time series data points form.
        public let timestamp: Date
        /// The ID of the type of the time series data points form.
        public let typeIdentifier: String
        /// The revision type of the time series data points form.
        public let typeRevision: String?

        public init(content: String? = nil, formName: String, timestamp: Date, typeIdentifier: String, typeRevision: String? = nil) {
            self.content = content
            self.formName = formName
            self.timestamp = timestamp
            self.typeIdentifier = typeIdentifier
            self.typeRevision = typeRevision
        }

        public func validate(name: String) throws {
            try self.validate(self.formName, name: "formName", parent: name, max: 128)
            try self.validate(self.formName, name: "formName", parent: name, min: 1)
            try self.validate(self.typeIdentifier, name: "typeIdentifier", parent: name, max: 385)
            try self.validate(self.typeIdentifier, name: "typeIdentifier", parent: name, min: 1)
            try self.validate(self.typeIdentifier, name: "typeIdentifier", parent: name, pattern: "^(?!\\.)[\\w\\.]*\\w$")
            try self.validate(self.typeRevision, name: "typeRevision", parent: name, max: 64)
            try self.validate(self.typeRevision, name: "typeRevision", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case content = "content"
            case formName = "formName"
            case timestamp = "timestamp"
            case typeIdentifier = "typeIdentifier"
            case typeRevision = "typeRevision"
        }
    }

    public struct TimeSeriesDataPointFormOutput: AWSDecodableShape {
        /// The content of the time series data points form.
        public let content: String?
        /// The name of the time series data points form.
        public let formName: String
        /// The ID of the time series data points form.
        public let id: String?
        /// The timestamp of the time series data points form.
        public let timestamp: Date
        /// The ID of the type of the time series data points form.
        public let typeIdentifier: String
        /// The revision type of the time series data points form.
        public let typeRevision: String?

        public init(content: String? = nil, formName: String, id: String? = nil, timestamp: Date, typeIdentifier: String, typeRevision: String? = nil) {
            self.content = content
            self.formName = formName
            self.id = id
            self.timestamp = timestamp
            self.typeIdentifier = typeIdentifier
            self.typeRevision = typeRevision
        }

        private enum CodingKeys: String, CodingKey {
            case content = "content"
            case formName = "formName"
            case id = "id"
            case timestamp = "timestamp"
            case typeIdentifier = "typeIdentifier"
            case typeRevision = "typeRevision"
        }
    }

    public struct TimeSeriesDataPointSummaryFormOutput: AWSDecodableShape {
        /// The content of the summary of the time series data points form.
        public let contentSummary: String?
        /// The name of the time series data points summary form.
        public let formName: String
        /// The ID of the time series data points summary form.
        public let id: String?
        /// The timestamp of the time series data points summary form.
        public let timestamp: Date
        /// The type ID of the time series data points summary form.
        public let typeIdentifier: String
        /// The type revision of the time series data points summary form.
        public let typeRevision: String?

        public init(contentSummary: String? = nil, formName: String, id: String? = nil, timestamp: Date, typeIdentifier: String, typeRevision: String? = nil) {
            self.contentSummary = contentSummary
            self.formName = formName
            self.id = id
            self.timestamp = timestamp
            self.typeIdentifier = typeIdentifier
            self.typeRevision = typeRevision
        }

        private enum CodingKeys: String, CodingKey {
            case contentSummary = "contentSummary"
            case formName = "formName"
            case id = "id"
            case timestamp = "timestamp"
            case typeIdentifier = "typeIdentifier"
            case typeRevision = "typeRevision"
        }
    }

    public struct Topic: AWSDecodableShape {
        public let resource: NotificationResource
        /// The role of the resource mentioned in a notification.
        public let role: NotificationRole
        /// The subject of the resource mentioned in a notification.
        public let subject: String

        public init(resource: NotificationResource, role: NotificationRole, subject: String) {
            self.resource = resource
            self.role = role
            self.subject = subject
        }

        private enum CodingKeys: String, CodingKey {
            case resource = "resource"
            case role = "role"
            case subject = "subject"
        }
    }

    public struct UntagResourceRequest: AWSEncodableShape {
        /// The ARN of the resource to be untagged in Amazon DataZone.
        public let resourceArn: String
        /// Specifies the tag keys for the UntagResource action.
        public let tagKeys: [String]

        public init(resourceArn: String, tagKeys: [String]) {
            self.resourceArn = resourceArn
            self.tagKeys = tagKeys
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.resourceArn, key: "resourceArn")
            request.encodeQuery(self.tagKeys, key: "tagKeys")
        }

        public func validate(name: String) throws {
            try self.tagKeys.forEach {
                try validate($0, name: "tagKeys[]", parent: name, max: 128)
                try validate($0, name: "tagKeys[]", parent: name, min: 1)
                try validate($0, name: "tagKeys[]", parent: name, pattern: "^[\\w \\.:/=+@-]+$")
            }
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct UntagResourceResponse: AWSDecodableShape {
        public init() {}
    }

    public struct UpdateDataSourceInput: AWSEncodableShape {
        /// The asset forms to be updated as part of the UpdateDataSource action.
        public let assetFormsInput: [FormInput]?
        /// The configuration to be updated as part of the UpdateDataSource action.
        public let configuration: DataSourceConfigurationInput?
        /// The description to be updated as part of the UpdateDataSource action.
        public let description: String?
        /// The identifier of the domain in which to update a data source.
        public let domainIdentifier: String
        /// The enable setting to be updated as part of the UpdateDataSource action.
        public let enableSetting: EnableSetting?
        /// The identifier of the data source to be updated.
        public let identifier: String
        /// The name to be updated as part of the UpdateDataSource action.
        public let name: String?
        /// The publish on import setting to be updated as part of the UpdateDataSource action.
        public let publishOnImport: Bool?
        /// The recommendation to be updated as part of the UpdateDataSource action.
        public let recommendation: RecommendationConfiguration?
        /// The schedule to be updated as part of the UpdateDataSource action.
        public let schedule: ScheduleConfiguration?

        public init(assetFormsInput: [FormInput]? = nil, configuration: DataSourceConfigurationInput? = nil, description: String? = nil, domainIdentifier: String, enableSetting: EnableSetting? = nil, identifier: String, name: String? = nil, publishOnImport: Bool? = nil, recommendation: RecommendationConfiguration? = nil, schedule: ScheduleConfiguration? = nil) {
            self.assetFormsInput = assetFormsInput
            self.configuration = configuration
            self.description = description
            self.domainIdentifier = domainIdentifier
            self.enableSetting = enableSetting
            self.identifier = identifier
            self.name = name
            self.publishOnImport = publishOnImport
            self.recommendation = recommendation
            self.schedule = schedule
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.assetFormsInput, forKey: .assetFormsInput)
            try container.encodeIfPresent(self.configuration, forKey: .configuration)
            try container.encodeIfPresent(self.description, forKey: .description)
            request.encodePath(self.domainIdentifier, key: "domainIdentifier")
            try container.encodeIfPresent(self.enableSetting, forKey: .enableSetting)
            request.encodePath(self.identifier, key: "identifier")
            try container.encodeIfPresent(self.name, forKey: .name)
            try container.encodeIfPresent(self.publishOnImport, forKey: .publishOnImport)
            try container.encodeIfPresent(self.recommendation, forKey: .recommendation)
            try container.encodeIfPresent(self.schedule, forKey: .schedule)
        }

        public func validate(name: String) throws {
            try self.assetFormsInput?.forEach {
                try $0.validate(name: "\(name).assetFormsInput[]")
            }
            try self.validate(self.assetFormsInput, name: "assetFormsInput", parent: name, max: 10)
            try self.validate(self.description, name: "description", parent: name, max: 2048)
            try self.validate(self.domainIdentifier, name: "domainIdentifier", parent: name, pattern: "^dzd[-_][a-zA-Z0-9_-]{1,36}$")
            try self.validate(self.identifier, name: "identifier", parent: name, pattern: "^[a-zA-Z0-9_-]{1,36}$")
            try self.validate(self.name, name: "name", parent: name, max: 256)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.schedule?.validate(name: "\(name).schedule")
        }

        private enum CodingKeys: String, CodingKey {
            case assetFormsInput = "assetFormsInput"
            case configuration = "configuration"
            case description = "description"
            case enableSetting = "enableSetting"
            case name = "name"
            case publishOnImport = "publishOnImport"
            case recommendation = "recommendation"
            case schedule = "schedule"
        }
    }

    public struct UpdateDataSourceOutput: AWSDecodableShape {
        /// The asset forms to be updated as part of the UpdateDataSource action.
        public let assetFormsOutput: [FormOutput]?
        /// The configuration to be updated as part of the UpdateDataSource action.
        public let configuration: DataSourceConfigurationOutput?
        /// The timestamp of when the data source was updated.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var createdAt: Date?
        /// The description to be updated as part of the UpdateDataSource action.
        public let description: String?
        /// The identifier of the Amazon DataZone domain in which a data source is to be updated.
        public let domainId: String
        /// The enable setting to be updated as part of the UpdateDataSource action.
        public let enableSetting: EnableSetting?
        /// The identifier of the environment in which a data source is to be updated.
        public let environmentId: String
        /// Specifies the error message that is returned if the operation cannot be successfully completed.
        public let errorMessage: DataSourceErrorMessage?
        /// The identifier of the data source to be updated.
        public let id: String
        /// The timestamp of when the data source was last run.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var lastRunAt: Date?
        /// The last run error message of the data source.
        public let lastRunErrorMessage: DataSourceErrorMessage?
        /// The last run status of the data source.
        public let lastRunStatus: DataSourceRunStatus?
        /// The name to be updated as part of the UpdateDataSource action.
        public let name: String
        /// The identifier of the project where data source is to be updated.
        public let projectId: String
        /// The publish on import setting to be updated as part of the UpdateDataSource action.
        public let publishOnImport: Bool?
        /// The recommendation to be updated as part of the UpdateDataSource action.
        public let recommendation: RecommendationConfiguration?
        /// The schedule to be updated as part of the UpdateDataSource action.
        public let schedule: ScheduleConfiguration?
        /// The status to be updated as part of the UpdateDataSource action.
        public let status: DataSourceStatus?
        /// The type to be updated as part of the UpdateDataSource action.
        public let type: String?
        /// The timestamp of when the data source was updated.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var updatedAt: Date?

        public init(assetFormsOutput: [FormOutput]? = nil, configuration: DataSourceConfigurationOutput? = nil, createdAt: Date? = nil, description: String? = nil, domainId: String, enableSetting: EnableSetting? = nil, environmentId: String, errorMessage: DataSourceErrorMessage? = nil, id: String, lastRunAt: Date? = nil, lastRunErrorMessage: DataSourceErrorMessage? = nil, lastRunStatus: DataSourceRunStatus? = nil, name: String, projectId: String, publishOnImport: Bool? = nil, recommendation: RecommendationConfiguration? = nil, schedule: ScheduleConfiguration? = nil, status: DataSourceStatus? = nil, type: String? = nil, updatedAt: Date? = nil) {
            self.assetFormsOutput = assetFormsOutput
            self.configuration = configuration
            self.createdAt = createdAt
            self.description = description
            self.domainId = domainId
            self.enableSetting = enableSetting
            self.environmentId = environmentId
            self.errorMessage = errorMessage
            self.id = id
            self.lastRunAt = lastRunAt
            self.lastRunErrorMessage = lastRunErrorMessage
            self.lastRunStatus = lastRunStatus
            self.name = name
            self.projectId = projectId
            self.publishOnImport = publishOnImport
            self.recommendation = recommendation
            self.schedule = schedule
            self.status = status
            self.type = type
            self.updatedAt = updatedAt
        }

        private enum CodingKeys: String, CodingKey {
            case assetFormsOutput = "assetFormsOutput"
            case configuration = "configuration"
            case createdAt = "createdAt"
            case description = "description"
            case domainId = "domainId"
            case enableSetting = "enableSetting"
            case environmentId = "environmentId"
            case errorMessage = "errorMessage"
            case id = "id"
            case lastRunAt = "lastRunAt"
            case lastRunErrorMessage = "lastRunErrorMessage"
            case lastRunStatus = "lastRunStatus"
            case name = "name"
            case projectId = "projectId"
            case publishOnImport = "publishOnImport"
            case recommendation = "recommendation"
            case schedule = "schedule"
            case status = "status"
            case type = "type"
            case updatedAt = "updatedAt"
        }
    }

    public struct UpdateDomainInput: AWSEncodableShape {
        /// A unique, case-sensitive identifier that is provided to ensure the idempotency of the request.
        public let clientToken: String?
        /// The description to be updated as part of the UpdateDomain action.
        public let description: String?
        /// The domain execution role to be updated as part of the UpdateDomain action.
        public let domainExecutionRole: String?
        /// The ID of the Amazon Web Services domain that is to be updated.
        public let identifier: String
        /// The name to be updated as part of the UpdateDomain action.
        public let name: String?
        /// The single sign-on option to be updated as part of the UpdateDomain action.
        public let singleSignOn: SingleSignOn?

        public init(clientToken: String? = UpdateDomainInput.idempotencyToken(), description: String? = nil, domainExecutionRole: String? = nil, identifier: String, name: String? = nil, singleSignOn: SingleSignOn? = nil) {
            self.clientToken = clientToken
            self.description = description
            self.domainExecutionRole = domainExecutionRole
            self.identifier = identifier
            self.name = name
            self.singleSignOn = singleSignOn
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.clientToken, key: "clientToken")
            try container.encodeIfPresent(self.description, forKey: .description)
            try container.encodeIfPresent(self.domainExecutionRole, forKey: .domainExecutionRole)
            request.encodePath(self.identifier, key: "identifier")
            try container.encodeIfPresent(self.name, forKey: .name)
            try container.encodeIfPresent(self.singleSignOn, forKey: .singleSignOn)
        }

        public func validate(name: String) throws {
            try self.validate(self.domainExecutionRole, name: "domainExecutionRole", parent: name, pattern: "^arn:aws[^:]*:iam::\\d{12}:(role|role/service-role)/[\\w+=,.@-]*$")
            try self.validate(self.identifier, name: "identifier", parent: name, pattern: "^dzd[-_][a-zA-Z0-9_-]{1,36}$")
        }

        private enum CodingKeys: String, CodingKey {
            case description = "description"
            case domainExecutionRole = "domainExecutionRole"
            case name = "name"
            case singleSignOn = "singleSignOn"
        }
    }

    public struct UpdateDomainOutput: AWSDecodableShape {
        /// The description to be updated as part of the UpdateDomain action.
        public let description: String?
        /// The domain execution role to be updated as part of the UpdateDomain action.
        public let domainExecutionRole: String?
        /// The identifier of the Amazon DataZone domain.
        public let id: String
        /// Specifies the timestamp of when the domain was last updated.
        public let lastUpdatedAt: Date?
        /// The name to be updated as part of the UpdateDomain action.
        public let name: String?
        /// The single sign-on option of the Amazon DataZone domain.
        public let singleSignOn: SingleSignOn?

        public init(description: String? = nil, domainExecutionRole: String? = nil, id: String, lastUpdatedAt: Date? = nil, name: String? = nil, singleSignOn: SingleSignOn? = nil) {
            self.description = description
            self.domainExecutionRole = domainExecutionRole
            self.id = id
            self.lastUpdatedAt = lastUpdatedAt
            self.name = name
            self.singleSignOn = singleSignOn
        }

        private enum CodingKeys: String, CodingKey {
            case description = "description"
            case domainExecutionRole = "domainExecutionRole"
            case id = "id"
            case lastUpdatedAt = "lastUpdatedAt"
            case name = "name"
            case singleSignOn = "singleSignOn"
        }
    }

    public struct UpdateEnvironmentInput: AWSEncodableShape {
        /// The description to be updated as part of the UpdateEnvironment action.
        public let description: String?
        /// The identifier of the domain in which the environment is to be updated.
        public let domainIdentifier: String
        /// The glossary terms to be updated as part of the UpdateEnvironment action.
        public let glossaryTerms: [String]?
        /// The identifier of the environment that is to be updated.
        public let identifier: String
        /// The name to be updated as part of the UpdateEnvironment action.
        public let name: String?

        public init(description: String? = nil, domainIdentifier: String, glossaryTerms: [String]? = nil, identifier: String, name: String? = nil) {
            self.description = description
            self.domainIdentifier = domainIdentifier
            self.glossaryTerms = glossaryTerms
            self.identifier = identifier
            self.name = name
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.description, forKey: .description)
            request.encodePath(self.domainIdentifier, key: "domainIdentifier")
            try container.encodeIfPresent(self.glossaryTerms, forKey: .glossaryTerms)
            request.encodePath(self.identifier, key: "identifier")
            try container.encodeIfPresent(self.name, forKey: .name)
        }

        public func validate(name: String) throws {
            try self.validate(self.domainIdentifier, name: "domainIdentifier", parent: name, pattern: "^dzd[-_][a-zA-Z0-9_-]{1,36}$")
            try self.glossaryTerms?.forEach {
                try validate($0, name: "glossaryTerms[]", parent: name, pattern: "^[a-zA-Z0-9_-]{1,36}$")
            }
            try self.validate(self.glossaryTerms, name: "glossaryTerms", parent: name, max: 20)
            try self.validate(self.glossaryTerms, name: "glossaryTerms", parent: name, min: 1)
            try self.validate(self.identifier, name: "identifier", parent: name, pattern: "^[a-zA-Z0-9_-]{1,36}$")
        }

        private enum CodingKeys: String, CodingKey {
            case description = "description"
            case glossaryTerms = "glossaryTerms"
            case name = "name"
        }
    }

    public struct UpdateEnvironmentOutput: AWSDecodableShape {
        /// The identifier of the Amazon Web Services account in which the environment is to be updated.
        public let awsAccountId: String?
        /// The Amazon Web Services Region in which the environment is updated.
        public let awsAccountRegion: String?
        /// The timestamp of when the environment was created.
        public let createdAt: Date?
        /// The Amazon DataZone user who created the environment.
        public let createdBy: String
        /// The deployment properties to be updated as part of the UpdateEnvironment action.
        public let deploymentProperties: DeploymentProperties?
        /// The description to be updated as part of the UpdateEnvironment action.
        public let description: String?
        /// The identifier of the domain in which the environment is to be updated.
        public let domainId: String
        /// The environment actions to be updated as part of the UpdateEnvironment action.
        public let environmentActions: [ConfigurableEnvironmentAction]?
        /// The blueprint identifier of the environment.
        public let environmentBlueprintId: String?
        /// The profile identifier of the environment.
        public let environmentProfileId: String
        /// The glossary terms to be updated as part of the UpdateEnvironment action.
        public let glossaryTerms: [String]?
        /// The identifier of the environment that is to be updated.
        public let id: String?
        /// The last deployment of the environment.
        public let lastDeployment: Deployment?
        /// The name to be updated as part of the UpdateEnvironment action.
        public let name: String
        /// The project identifier of the environment.
        public let projectId: String
        /// The provider identifier of the environment.
        public let provider: String
        /// The provisioned resources to be updated as part of the UpdateEnvironment action.
        public let provisionedResources: [Resource]?
        /// The provisioning properties to be updated as part of the UpdateEnvironment action.
        public let provisioningProperties: ProvisioningProperties?
        /// The status to be updated as part of the UpdateEnvironment action.
        public let status: EnvironmentStatus?
        /// The timestamp of when the environment was updated.
        public let updatedAt: Date?
        /// The user parameters to be updated as part of the UpdateEnvironment action.
        public let userParameters: [CustomParameter]?

        public init(awsAccountId: String? = nil, awsAccountRegion: String? = nil, createdAt: Date? = nil, createdBy: String, deploymentProperties: DeploymentProperties? = nil, description: String? = nil, domainId: String, environmentActions: [ConfigurableEnvironmentAction]? = nil, environmentBlueprintId: String? = nil, environmentProfileId: String, glossaryTerms: [String]? = nil, id: String? = nil, lastDeployment: Deployment? = nil, name: String, projectId: String, provider: String, provisionedResources: [Resource]? = nil, provisioningProperties: ProvisioningProperties? = nil, status: EnvironmentStatus? = nil, updatedAt: Date? = nil, userParameters: [CustomParameter]? = nil) {
            self.awsAccountId = awsAccountId
            self.awsAccountRegion = awsAccountRegion
            self.createdAt = createdAt
            self.createdBy = createdBy
            self.deploymentProperties = deploymentProperties
            self.description = description
            self.domainId = domainId
            self.environmentActions = environmentActions
            self.environmentBlueprintId = environmentBlueprintId
            self.environmentProfileId = environmentProfileId
            self.glossaryTerms = glossaryTerms
            self.id = id
            self.lastDeployment = lastDeployment
            self.name = name
            self.projectId = projectId
            self.provider = provider
            self.provisionedResources = provisionedResources
            self.provisioningProperties = provisioningProperties
            self.status = status
            self.updatedAt = updatedAt
            self.userParameters = userParameters
        }

        private enum CodingKeys: String, CodingKey {
            case awsAccountId = "awsAccountId"
            case awsAccountRegion = "awsAccountRegion"
            case createdAt = "createdAt"
            case createdBy = "createdBy"
            case deploymentProperties = "deploymentProperties"
            case description = "description"
            case domainId = "domainId"
            case environmentActions = "environmentActions"
            case environmentBlueprintId = "environmentBlueprintId"
            case environmentProfileId = "environmentProfileId"
            case glossaryTerms = "glossaryTerms"
            case id = "id"
            case lastDeployment = "lastDeployment"
            case name = "name"
            case projectId = "projectId"
            case provider = "provider"
            case provisionedResources = "provisionedResources"
            case provisioningProperties = "provisioningProperties"
            case status = "status"
            case updatedAt = "updatedAt"
            case userParameters = "userParameters"
        }
    }

    public struct UpdateEnvironmentProfileInput: AWSEncodableShape {
        /// The Amazon Web Services account in which a specified environment profile is to be udpated.
        public let awsAccountId: String?
        /// The Amazon Web Services Region in which a specified environment profile is to be updated.
        public let awsAccountRegion: String?
        /// The description to be updated as part of the UpdateEnvironmentProfile action.
        public let description: String?
        /// The identifier of the Amazon DataZone domain in which an environment profile is to be updated.
        public let domainIdentifier: String
        /// The identifier of the environment profile that is to be updated.
        public let identifier: String
        /// The name to be updated as part of the UpdateEnvironmentProfile action.
        public let name: String?
        /// The user parameters to be updated as part of the UpdateEnvironmentProfile action.
        public let userParameters: [EnvironmentParameter]?

        public init(awsAccountId: String? = nil, awsAccountRegion: String? = nil, description: String? = nil, domainIdentifier: String, identifier: String, name: String? = nil, userParameters: [EnvironmentParameter]? = nil) {
            self.awsAccountId = awsAccountId
            self.awsAccountRegion = awsAccountRegion
            self.description = description
            self.domainIdentifier = domainIdentifier
            self.identifier = identifier
            self.name = name
            self.userParameters = userParameters
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.awsAccountId, forKey: .awsAccountId)
            try container.encodeIfPresent(self.awsAccountRegion, forKey: .awsAccountRegion)
            try container.encodeIfPresent(self.description, forKey: .description)
            request.encodePath(self.domainIdentifier, key: "domainIdentifier")
            request.encodePath(self.identifier, key: "identifier")
            try container.encodeIfPresent(self.name, forKey: .name)
            try container.encodeIfPresent(self.userParameters, forKey: .userParameters)
        }

        public func validate(name: String) throws {
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, pattern: "^\\d{12}$")
            try self.validate(self.awsAccountRegion, name: "awsAccountRegion", parent: name, pattern: "^[a-z]{2}-[a-z]{4,10}-\\d$")
            try self.validate(self.domainIdentifier, name: "domainIdentifier", parent: name, pattern: "^dzd[-_][a-zA-Z0-9_-]{1,36}$")
            try self.validate(self.identifier, name: "identifier", parent: name, pattern: "^[a-zA-Z0-9_-]{1,36}$")
            try self.validate(self.name, name: "name", parent: name, max: 64)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[\\w -]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case awsAccountId = "awsAccountId"
            case awsAccountRegion = "awsAccountRegion"
            case description = "description"
            case name = "name"
            case userParameters = "userParameters"
        }
    }

    public struct UpdateEnvironmentProfileOutput: AWSDecodableShape {
        /// The Amazon Web Services account in which a specified environment profile is to be udpated.
        public let awsAccountId: String?
        /// The Amazon Web Services Region in which a specified environment profile is to be updated.
        public let awsAccountRegion: String?
        /// The timestamp of when the environment profile was created.
        public let createdAt: Date?
        /// The Amazon DataZone user who created the environment profile.
        public let createdBy: String
        /// The description to be updated as part of the UpdateEnvironmentProfile action.
        public let description: String?
        /// The identifier of the Amazon DataZone domain in which the environment profile is to be updated.
        public let domainId: String
        /// The identifier of the blueprint of the environment profile that is to be updated.
        public let environmentBlueprintId: String
        /// The identifier of the environment profile that is to be udpated.
        public let id: String
        /// The name to be updated as part of the UpdateEnvironmentProfile action.
        public let name: String
        /// The identifier of the project of the environment profile that is to be updated.
        public let projectId: String?
        /// The timestamp of when the environment profile was updated.
        public let updatedAt: Date?
        /// The user parameters to be updated as part of the UpdateEnvironmentProfile action.
        public let userParameters: [CustomParameter]?

        public init(awsAccountId: String? = nil, awsAccountRegion: String? = nil, createdAt: Date? = nil, createdBy: String, description: String? = nil, domainId: String, environmentBlueprintId: String, id: String, name: String, projectId: String? = nil, updatedAt: Date? = nil, userParameters: [CustomParameter]? = nil) {
            self.awsAccountId = awsAccountId
            self.awsAccountRegion = awsAccountRegion
            self.createdAt = createdAt
            self.createdBy = createdBy
            self.description = description
            self.domainId = domainId
            self.environmentBlueprintId = environmentBlueprintId
            self.id = id
            self.name = name
            self.projectId = projectId
            self.updatedAt = updatedAt
            self.userParameters = userParameters
        }

        private enum CodingKeys: String, CodingKey {
            case awsAccountId = "awsAccountId"
            case awsAccountRegion = "awsAccountRegion"
            case createdAt = "createdAt"
            case createdBy = "createdBy"
            case description = "description"
            case domainId = "domainId"
            case environmentBlueprintId = "environmentBlueprintId"
            case id = "id"
            case name = "name"
            case projectId = "projectId"
            case updatedAt = "updatedAt"
            case userParameters = "userParameters"
        }
    }

    public struct UpdateGlossaryInput: AWSEncodableShape {
        /// A unique, case-sensitive identifier that is provided to ensure the idempotency of the request.
        public let clientToken: String?
        /// The description to be updated as part of the UpdateGlossary action.
        public let description: String?
        /// The identifier of the Amazon DataZone domain in which a business glossary is to be updated.
        public let domainIdentifier: String
        /// The identifier of the business glossary to be updated.
        public let identifier: String
        /// The name to be updated as part of the UpdateGlossary action.
        public let name: String?
        /// The status to be updated as part of the UpdateGlossary action.
        public let status: GlossaryStatus?

        public init(clientToken: String? = UpdateGlossaryInput.idempotencyToken(), description: String? = nil, domainIdentifier: String, identifier: String, name: String? = nil, status: GlossaryStatus? = nil) {
            self.clientToken = clientToken
            self.description = description
            self.domainIdentifier = domainIdentifier
            self.identifier = identifier
            self.name = name
            self.status = status
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.clientToken, forKey: .clientToken)
            try container.encodeIfPresent(self.description, forKey: .description)
            request.encodePath(self.domainIdentifier, key: "domainIdentifier")
            request.encodePath(self.identifier, key: "identifier")
            try container.encodeIfPresent(self.name, forKey: .name)
            try container.encodeIfPresent(self.status, forKey: .status)
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 128)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "^[\\x21-\\x7E]+$")
            try self.validate(self.description, name: "description", parent: name, max: 4096)
            try self.validate(self.domainIdentifier, name: "domainIdentifier", parent: name, pattern: "^dzd[-_][a-zA-Z0-9_-]{1,36}$")
            try self.validate(self.identifier, name: "identifier", parent: name, pattern: "^[a-zA-Z0-9_-]{1,36}$")
            try self.validate(self.name, name: "name", parent: name, max: 256)
            try self.validate(self.name, name: "name", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "clientToken"
            case description = "description"
            case name = "name"
            case status = "status"
        }
    }

    public struct UpdateGlossaryOutput: AWSDecodableShape {
        /// The description to be updated as part of the UpdateGlossary action.
        public let description: String?
        /// The identifier of the Amazon DataZone domain in which a business glossary is to be updated.
        public let domainId: String
        /// The identifier of the business glossary that is to be updated.
        public let id: String
        /// The name to be updated as part of the UpdateGlossary action.
        public let name: String
        /// The identifier of the project in which to update a business glossary.
        public let owningProjectId: String
        /// The status to be updated as part of the UpdateGlossary action.
        public let status: GlossaryStatus?

        public init(description: String? = nil, domainId: String, id: String, name: String, owningProjectId: String, status: GlossaryStatus? = nil) {
            self.description = description
            self.domainId = domainId
            self.id = id
            self.name = name
            self.owningProjectId = owningProjectId
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case description = "description"
            case domainId = "domainId"
            case id = "id"
            case name = "name"
            case owningProjectId = "owningProjectId"
            case status = "status"
        }
    }

    public struct UpdateGlossaryTermInput: AWSEncodableShape {
        /// The identifier of the Amazon DataZone domain in which a business glossary term is to be updated.
        public let domainIdentifier: String
        /// The identifier of the business glossary in which a term is to be updated.
        public let glossaryIdentifier: String?
        /// The identifier of the business glossary term that is to be updated.
        public let identifier: String
        /// The long description to be updated as part of the UpdateGlossaryTerm action.
        public let longDescription: String?
        /// The name to be updated as part of the UpdateGlossaryTerm action.
        public let name: String?
        /// The short description to be updated as part of the UpdateGlossaryTerm action.
        public let shortDescription: String?
        /// The status to be updated as part of the UpdateGlossaryTerm action.
        public let status: GlossaryTermStatus?
        /// The term relations to be updated as part of the UpdateGlossaryTerm action.
        public let termRelations: TermRelations?

        public init(domainIdentifier: String, glossaryIdentifier: String? = nil, identifier: String, longDescription: String? = nil, name: String? = nil, shortDescription: String? = nil, status: GlossaryTermStatus? = nil, termRelations: TermRelations? = nil) {
            self.domainIdentifier = domainIdentifier
            self.glossaryIdentifier = glossaryIdentifier
            self.identifier = identifier
            self.longDescription = longDescription
            self.name = name
            self.shortDescription = shortDescription
            self.status = status
            self.termRelations = termRelations
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.domainIdentifier, key: "domainIdentifier")
            try container.encodeIfPresent(self.glossaryIdentifier, forKey: .glossaryIdentifier)
            request.encodePath(self.identifier, key: "identifier")
            try container.encodeIfPresent(self.longDescription, forKey: .longDescription)
            try container.encodeIfPresent(self.name, forKey: .name)
            try container.encodeIfPresent(self.shortDescription, forKey: .shortDescription)
            try container.encodeIfPresent(self.status, forKey: .status)
            try container.encodeIfPresent(self.termRelations, forKey: .termRelations)
        }

        public func validate(name: String) throws {
            try self.validate(self.domainIdentifier, name: "domainIdentifier", parent: name, pattern: "^dzd[-_][a-zA-Z0-9_-]{1,36}$")
            try self.validate(self.glossaryIdentifier, name: "glossaryIdentifier", parent: name, pattern: "^[a-zA-Z0-9_-]{1,36}$")
            try self.validate(self.identifier, name: "identifier", parent: name, pattern: "^[a-zA-Z0-9_-]{1,36}$")
            try self.validate(self.longDescription, name: "longDescription", parent: name, max: 4096)
            try self.validate(self.name, name: "name", parent: name, max: 256)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.shortDescription, name: "shortDescription", parent: name, max: 1024)
            try self.termRelations?.validate(name: "\(name).termRelations")
        }

        private enum CodingKeys: String, CodingKey {
            case glossaryIdentifier = "glossaryIdentifier"
            case longDescription = "longDescription"
            case name = "name"
            case shortDescription = "shortDescription"
            case status = "status"
            case termRelations = "termRelations"
        }
    }

    public struct UpdateGlossaryTermOutput: AWSDecodableShape {
        /// The identifier of the Amazon DataZone domain in which a business glossary term is to be updated.
        public let domainId: String
        /// The identifier of the business glossary in which a term is to be updated.
        public let glossaryId: String
        /// The identifier of the business glossary term that is to be updated.
        public let id: String
        /// The long description to be updated as part of the UpdateGlossaryTerm action.
        public let longDescription: String?
        /// The name to be updated as part of the UpdateGlossaryTerm action.
        public let name: String
        /// The short description to be updated as part of the UpdateGlossaryTerm action.
        public let shortDescription: String?
        /// The status to be updated as part of the UpdateGlossaryTerm action.
        public let status: GlossaryTermStatus
        /// The term relations to be updated as part of the UpdateGlossaryTerm action.
        public let termRelations: TermRelations?

        public init(domainId: String, glossaryId: String, id: String, longDescription: String? = nil, name: String, shortDescription: String? = nil, status: GlossaryTermStatus, termRelations: TermRelations? = nil) {
            self.domainId = domainId
            self.glossaryId = glossaryId
            self.id = id
            self.longDescription = longDescription
            self.name = name
            self.shortDescription = shortDescription
            self.status = status
            self.termRelations = termRelations
        }

        private enum CodingKeys: String, CodingKey {
            case domainId = "domainId"
            case glossaryId = "glossaryId"
            case id = "id"
            case longDescription = "longDescription"
            case name = "name"
            case shortDescription = "shortDescription"
            case status = "status"
            case termRelations = "termRelations"
        }
    }

    public struct UpdateGroupProfileInput: AWSEncodableShape {
        /// The identifier of the Amazon DataZone domain in which a group profile is updated.
        public let domainIdentifier: String
        /// The identifier of the group profile that is updated.
        public let groupIdentifier: String
        /// The status of the group profile that is updated.
        public let status: GroupProfileStatus

        public init(domainIdentifier: String, groupIdentifier: String, status: GroupProfileStatus) {
            self.domainIdentifier = domainIdentifier
            self.groupIdentifier = groupIdentifier
            self.status = status
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.domainIdentifier, key: "domainIdentifier")
            request.encodePath(self.groupIdentifier, key: "groupIdentifier")
            try container.encode(self.status, forKey: .status)
        }

        public func validate(name: String) throws {
            try self.validate(self.domainIdentifier, name: "domainIdentifier", parent: name, pattern: "^dzd[-_][a-zA-Z0-9_-]{1,36}$")
            try self.validate(self.groupIdentifier, name: "groupIdentifier", parent: name, pattern: "(^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}$|[\\p{L}\\p{M}\\p{S}\\p{N}\\p{P}\\t\\n\\r  ]+)")
        }

        private enum CodingKeys: String, CodingKey {
            case status = "status"
        }
    }

    public struct UpdateGroupProfileOutput: AWSDecodableShape {
        /// The identifier of the Amazon DataZone domain in which a group profile is updated.
        public let domainId: String?
        /// The name of the group profile that is updated.
        public let groupName: String?
        /// The identifier of the group profile that is updated.
        public let id: String?
        /// The status of the group profile that is updated.
        public let status: GroupProfileStatus?

        public init(domainId: String? = nil, groupName: String? = nil, id: String? = nil, status: GroupProfileStatus? = nil) {
            self.domainId = domainId
            self.groupName = groupName
            self.id = id
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case domainId = "domainId"
            case groupName = "groupName"
            case id = "id"
            case status = "status"
        }
    }

    public struct UpdateProjectInput: AWSEncodableShape {
        /// The description to be updated as part of the UpdateProject action.
        public let description: String?
        /// The identifier of the Amazon DataZone domain in which a project is to be updated.
        public let domainIdentifier: String
        /// The glossary terms to be updated as part of the UpdateProject action.
        public let glossaryTerms: [String]?
        /// The identifier of the project that is to be updated.
        public let identifier: String
        /// The name to be updated as part of the UpdateProject action.
        public let name: String?

        public init(description: String? = nil, domainIdentifier: String, glossaryTerms: [String]? = nil, identifier: String, name: String? = nil) {
            self.description = description
            self.domainIdentifier = domainIdentifier
            self.glossaryTerms = glossaryTerms
            self.identifier = identifier
            self.name = name
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.description, forKey: .description)
            request.encodePath(self.domainIdentifier, key: "domainIdentifier")
            try container.encodeIfPresent(self.glossaryTerms, forKey: .glossaryTerms)
            request.encodePath(self.identifier, key: "identifier")
            try container.encodeIfPresent(self.name, forKey: .name)
        }

        public func validate(name: String) throws {
            try self.validate(self.description, name: "description", parent: name, max: 2048)
            try self.validate(self.domainIdentifier, name: "domainIdentifier", parent: name, pattern: "^dzd[-_][a-zA-Z0-9_-]{1,36}$")
            try self.glossaryTerms?.forEach {
                try validate($0, name: "glossaryTerms[]", parent: name, pattern: "^[a-zA-Z0-9_-]{1,36}$")
            }
            try self.validate(self.glossaryTerms, name: "glossaryTerms", parent: name, max: 20)
            try self.validate(self.glossaryTerms, name: "glossaryTerms", parent: name, min: 1)
            try self.validate(self.identifier, name: "identifier", parent: name, pattern: "^[a-zA-Z0-9_-]{1,36}$")
            try self.validate(self.name, name: "name", parent: name, max: 64)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[\\w -]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case description = "description"
            case glossaryTerms = "glossaryTerms"
            case name = "name"
        }
    }

    public struct UpdateProjectOutput: AWSDecodableShape {
        /// The timestamp of when the project was created.
        public let createdAt: Date?
        /// The Amazon DataZone user who created the project.
        public let createdBy: String
        /// The description of the project that is to be updated.
        public let description: String?
        /// The identifier of the Amazon DataZone domain in which a project is updated.
        public let domainId: String
        /// Specifies the error message that is returned if the operation cannot be successfully completed.
        public let failureReasons: [ProjectDeletionError]?
        /// The glossary terms of the project that are to be updated.
        public let glossaryTerms: [String]?
        /// The identifier of the project that is to be updated.
        public let id: String
        /// The timestamp of when the project was last updated.
        public let lastUpdatedAt: Date?
        /// The name of the project that is to be updated.
        public let name: String
        /// The status of the project.
        public let projectStatus: ProjectStatus?

        public init(createdAt: Date? = nil, createdBy: String, description: String? = nil, domainId: String, failureReasons: [ProjectDeletionError]? = nil, glossaryTerms: [String]? = nil, id: String, lastUpdatedAt: Date? = nil, name: String, projectStatus: ProjectStatus? = nil) {
            self.createdAt = createdAt
            self.createdBy = createdBy
            self.description = description
            self.domainId = domainId
            self.failureReasons = failureReasons
            self.glossaryTerms = glossaryTerms
            self.id = id
            self.lastUpdatedAt = lastUpdatedAt
            self.name = name
            self.projectStatus = projectStatus
        }

        private enum CodingKeys: String, CodingKey {
            case createdAt = "createdAt"
            case createdBy = "createdBy"
            case description = "description"
            case domainId = "domainId"
            case failureReasons = "failureReasons"
            case glossaryTerms = "glossaryTerms"
            case id = "id"
            case lastUpdatedAt = "lastUpdatedAt"
            case name = "name"
            case projectStatus = "projectStatus"
        }
    }

    public struct UpdateSubscriptionGrantStatusInput: AWSEncodableShape {
        /// The identifier of the asset the subscription grant status of which is to be updated.
        public let assetIdentifier: String
        /// The identifier of the Amazon DataZone domain in which a subscription grant status is to be updated.
        public let domainIdentifier: String
        /// Specifies the error message that is returned if the operation cannot be successfully completed.
        public let failureCause: FailureCause?
        /// The identifier of the subscription grant the status of which is to be updated.
        public let identifier: String
        /// The status to be updated as part of the UpdateSubscriptionGrantStatus action.
        public let status: SubscriptionGrantStatus
        /// The target name to be updated as part of the UpdateSubscriptionGrantStatus action.
        public let targetName: String?

        public init(assetIdentifier: String, domainIdentifier: String, failureCause: FailureCause? = nil, identifier: String, status: SubscriptionGrantStatus, targetName: String? = nil) {
            self.assetIdentifier = assetIdentifier
            self.domainIdentifier = domainIdentifier
            self.failureCause = failureCause
            self.identifier = identifier
            self.status = status
            self.targetName = targetName
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.assetIdentifier, key: "assetIdentifier")
            request.encodePath(self.domainIdentifier, key: "domainIdentifier")
            try container.encodeIfPresent(self.failureCause, forKey: .failureCause)
            request.encodePath(self.identifier, key: "identifier")
            try container.encode(self.status, forKey: .status)
            try container.encodeIfPresent(self.targetName, forKey: .targetName)
        }

        public func validate(name: String) throws {
            try self.validate(self.assetIdentifier, name: "assetIdentifier", parent: name, pattern: "^[a-zA-Z0-9_-]{1,36}$")
            try self.validate(self.domainIdentifier, name: "domainIdentifier", parent: name, pattern: "^dzd[-_][a-zA-Z0-9_-]{1,36}$")
            try self.validate(self.identifier, name: "identifier", parent: name, pattern: "^[a-zA-Z0-9_-]{1,36}$")
        }

        private enum CodingKeys: String, CodingKey {
            case failureCause = "failureCause"
            case status = "status"
            case targetName = "targetName"
        }
    }

    public struct UpdateSubscriptionGrantStatusOutput: AWSDecodableShape {
        /// The details of the asset for which the subscription grant is created.
        public let assets: [SubscribedAsset]?
        /// The timestamp of when the subscription grant status was created.
        public let createdAt: Date
        /// The Amazon DataZone domain user who created the subscription grant status.
        public let createdBy: String
        /// The identifier of the Amazon DataZone domain in which a subscription grant status is to be updated.
        public let domainId: String
        /// The granted entity to be updated as part of the UpdateSubscriptionGrantStatus action.
        public let grantedEntity: GrantedEntity
        /// The identifier of the subscription grant.
        public let id: String
        /// The status to be updated as part of the UpdateSubscriptionGrantStatus action.
        public let status: SubscriptionGrantOverallStatus
        /// The identifier of the subscription.
        public let subscriptionId: String?
        /// The identifier of the subscription target whose subscription grant status is to be updated.
        public let subscriptionTargetId: String
        /// The timestamp of when the subscription grant status is to be updated.
        public let updatedAt: Date
        /// The Amazon DataZone user who updated the subscription grant status.
        public let updatedBy: String?

        public init(assets: [SubscribedAsset]? = nil, createdAt: Date, createdBy: String, domainId: String, grantedEntity: GrantedEntity, id: String, status: SubscriptionGrantOverallStatus, subscriptionId: String? = nil, subscriptionTargetId: String, updatedAt: Date, updatedBy: String? = nil) {
            self.assets = assets
            self.createdAt = createdAt
            self.createdBy = createdBy
            self.domainId = domainId
            self.grantedEntity = grantedEntity
            self.id = id
            self.status = status
            self.subscriptionId = subscriptionId
            self.subscriptionTargetId = subscriptionTargetId
            self.updatedAt = updatedAt
            self.updatedBy = updatedBy
        }

        private enum CodingKeys: String, CodingKey {
            case assets = "assets"
            case createdAt = "createdAt"
            case createdBy = "createdBy"
            case domainId = "domainId"
            case grantedEntity = "grantedEntity"
            case id = "id"
            case status = "status"
            case subscriptionId = "subscriptionId"
            case subscriptionTargetId = "subscriptionTargetId"
            case updatedAt = "updatedAt"
            case updatedBy = "updatedBy"
        }
    }

    public struct UpdateSubscriptionRequestInput: AWSEncodableShape {
        /// The identifier of the Amazon DataZone domain in which a subscription request is to be updated.
        public let domainIdentifier: String
        /// The identifier of the subscription request that is to be updated.
        public let identifier: String
        /// The reason for the UpdateSubscriptionRequest action.
        public let requestReason: String

        public init(domainIdentifier: String, identifier: String, requestReason: String) {
            self.domainIdentifier = domainIdentifier
            self.identifier = identifier
            self.requestReason = requestReason
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.domainIdentifier, key: "domainIdentifier")
            request.encodePath(self.identifier, key: "identifier")
            try container.encode(self.requestReason, forKey: .requestReason)
        }

        public func validate(name: String) throws {
            try self.validate(self.domainIdentifier, name: "domainIdentifier", parent: name, pattern: "^dzd[-_][a-zA-Z0-9_-]{1,36}$")
            try self.validate(self.identifier, name: "identifier", parent: name, pattern: "^[a-zA-Z0-9_-]{1,36}$")
            try self.validate(self.requestReason, name: "requestReason", parent: name, max: 4096)
            try self.validate(self.requestReason, name: "requestReason", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case requestReason = "requestReason"
        }
    }

    public struct UpdateSubscriptionRequestOutput: AWSDecodableShape {
        /// The timestamp of when the subscription request was created.
        public let createdAt: Date
        /// The Amazon DataZone user who created the subscription request.
        public let createdBy: String
        /// The decision comment of the UpdateSubscriptionRequest action.
        public let decisionComment: String?
        /// The identifier of the Amazon DataZone domain in which a subscription request is to be updated.
        public let domainId: String
        /// The identifier of the subscription request that is to be updated.
        public let id: String
        /// The reason for the UpdateSubscriptionRequest action.
        public let requestReason: String
        /// The identifier of the Amazon DataZone user who reviews the subscription request.
        public let reviewerId: String?
        /// The status of the subscription request.
        public let status: SubscriptionRequestStatus
        /// The subscribed listings of the subscription request.
        public let subscribedListings: [SubscribedListing]
        /// The subscribed principals of the subscription request.
        public let subscribedPrincipals: [SubscribedPrincipal]
        /// The timestamp of when the subscription request was updated.
        public let updatedAt: Date
        /// The Amazon DataZone user who updated the subscription request.
        public let updatedBy: String?

        public init(createdAt: Date, createdBy: String, decisionComment: String? = nil, domainId: String, id: String, requestReason: String, reviewerId: String? = nil, status: SubscriptionRequestStatus, subscribedListings: [SubscribedListing], subscribedPrincipals: [SubscribedPrincipal], updatedAt: Date, updatedBy: String? = nil) {
            self.createdAt = createdAt
            self.createdBy = createdBy
            self.decisionComment = decisionComment
            self.domainId = domainId
            self.id = id
            self.requestReason = requestReason
            self.reviewerId = reviewerId
            self.status = status
            self.subscribedListings = subscribedListings
            self.subscribedPrincipals = subscribedPrincipals
            self.updatedAt = updatedAt
            self.updatedBy = updatedBy
        }

        private enum CodingKeys: String, CodingKey {
            case createdAt = "createdAt"
            case createdBy = "createdBy"
            case decisionComment = "decisionComment"
            case domainId = "domainId"
            case id = "id"
            case requestReason = "requestReason"
            case reviewerId = "reviewerId"
            case status = "status"
            case subscribedListings = "subscribedListings"
            case subscribedPrincipals = "subscribedPrincipals"
            case updatedAt = "updatedAt"
            case updatedBy = "updatedBy"
        }
    }

    public struct UpdateSubscriptionTargetInput: AWSEncodableShape {
        /// The applicable asset types to be updated as part of the UpdateSubscriptionTarget action.
        public let applicableAssetTypes: [String]?
        /// The authorized principals to be updated as part of the UpdateSubscriptionTarget action.
        public let authorizedPrincipals: [String]?
        /// The identifier of the Amazon DataZone domain in which a subscription target is to be updated.
        public let domainIdentifier: String
        /// The identifier of the environment in which a subscription target is to be updated.
        public let environmentIdentifier: String
        /// Identifier of the subscription target that is to be updated.
        public let identifier: String
        /// The manage access role to be updated as part of the UpdateSubscriptionTarget action.
        public let manageAccessRole: String?
        /// The name to be updated as part of the UpdateSubscriptionTarget action.
        public let name: String?
        /// The provider to be updated as part of the UpdateSubscriptionTarget action.
        public let provider: String?
        /// The configuration to be updated as part of the UpdateSubscriptionTarget action.
        public let subscriptionTargetConfig: [SubscriptionTargetForm]?

        public init(applicableAssetTypes: [String]? = nil, authorizedPrincipals: [String]? = nil, domainIdentifier: String, environmentIdentifier: String, identifier: String, manageAccessRole: String? = nil, name: String? = nil, provider: String? = nil, subscriptionTargetConfig: [SubscriptionTargetForm]? = nil) {
            self.applicableAssetTypes = applicableAssetTypes
            self.authorizedPrincipals = authorizedPrincipals
            self.domainIdentifier = domainIdentifier
            self.environmentIdentifier = environmentIdentifier
            self.identifier = identifier
            self.manageAccessRole = manageAccessRole
            self.name = name
            self.provider = provider
            self.subscriptionTargetConfig = subscriptionTargetConfig
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.applicableAssetTypes, forKey: .applicableAssetTypes)
            try container.encodeIfPresent(self.authorizedPrincipals, forKey: .authorizedPrincipals)
            request.encodePath(self.domainIdentifier, key: "domainIdentifier")
            request.encodePath(self.environmentIdentifier, key: "environmentIdentifier")
            request.encodePath(self.identifier, key: "identifier")
            try container.encodeIfPresent(self.manageAccessRole, forKey: .manageAccessRole)
            try container.encodeIfPresent(self.name, forKey: .name)
            try container.encodeIfPresent(self.provider, forKey: .provider)
            try container.encodeIfPresent(self.subscriptionTargetConfig, forKey: .subscriptionTargetConfig)
        }

        public func validate(name: String) throws {
            try self.applicableAssetTypes?.forEach {
                try validate($0, name: "applicableAssetTypes[]", parent: name, max: 256)
                try validate($0, name: "applicableAssetTypes[]", parent: name, min: 1)
                try validate($0, name: "applicableAssetTypes[]", parent: name, pattern: "^[^\\.]*")
            }
            try self.authorizedPrincipals?.forEach {
                try validate($0, name: "authorizedPrincipals[]", parent: name, pattern: "^[a-zA-Z0-9:/_-]*$")
            }
            try self.validate(self.authorizedPrincipals, name: "authorizedPrincipals", parent: name, max: 10)
            try self.validate(self.authorizedPrincipals, name: "authorizedPrincipals", parent: name, min: 1)
            try self.validate(self.domainIdentifier, name: "domainIdentifier", parent: name, pattern: "^dzd[-_][a-zA-Z0-9_-]{1,36}$")
            try self.validate(self.environmentIdentifier, name: "environmentIdentifier", parent: name, pattern: "^[a-zA-Z0-9_-]{1,36}$")
            try self.validate(self.identifier, name: "identifier", parent: name, pattern: "^[a-zA-Z0-9_-]{1,36}$")
            try self.validate(self.name, name: "name", parent: name, max: 256)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.subscriptionTargetConfig?.forEach {
                try $0.validate(name: "\(name).subscriptionTargetConfig[]")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case applicableAssetTypes = "applicableAssetTypes"
            case authorizedPrincipals = "authorizedPrincipals"
            case manageAccessRole = "manageAccessRole"
            case name = "name"
            case provider = "provider"
            case subscriptionTargetConfig = "subscriptionTargetConfig"
        }
    }

    public struct UpdateSubscriptionTargetOutput: AWSDecodableShape {
        /// The applicable asset types to be updated as part of the UpdateSubscriptionTarget action.
        public let applicableAssetTypes: [String]
        /// The authorized principals to be updated as part of the UpdateSubscriptionTarget action.
        public let authorizedPrincipals: [String]
        /// The timestamp of when a subscription target was created.
        public let createdAt: Date
        /// The Amazon DataZone user who created the subscription target.
        public let createdBy: String
        /// The identifier of the Amazon DataZone domain in which a subscription target is to be updated.
        public let domainId: String
        /// The identifier of the environment in which a subscription target is to be updated.
        public let environmentId: String
        /// Identifier of the subscription target that is to be updated.
        public let id: String
        /// The manage access role to be updated as part of the UpdateSubscriptionTarget action.
        public let manageAccessRole: String
        /// The name to be updated as part of the UpdateSubscriptionTarget action.
        public let name: String
        /// The identifier of the project in which a subscription target is to be updated.
        public let projectId: String
        /// The provider to be updated as part of the UpdateSubscriptionTarget action.
        public let provider: String
        /// The configuration to be updated as part of the UpdateSubscriptionTarget action.
        public let subscriptionTargetConfig: [SubscriptionTargetForm]
        /// The type to be updated as part of the UpdateSubscriptionTarget action.
        public let type: String
        /// The timestamp of when the subscription target was updated.
        public let updatedAt: Date?
        /// The Amazon DataZone user who updated the subscription target.
        public let updatedBy: String?

        public init(applicableAssetTypes: [String], authorizedPrincipals: [String], createdAt: Date, createdBy: String, domainId: String, environmentId: String, id: String, manageAccessRole: String, name: String, projectId: String, provider: String, subscriptionTargetConfig: [SubscriptionTargetForm], type: String, updatedAt: Date? = nil, updatedBy: String? = nil) {
            self.applicableAssetTypes = applicableAssetTypes
            self.authorizedPrincipals = authorizedPrincipals
            self.createdAt = createdAt
            self.createdBy = createdBy
            self.domainId = domainId
            self.environmentId = environmentId
            self.id = id
            self.manageAccessRole = manageAccessRole
            self.name = name
            self.projectId = projectId
            self.provider = provider
            self.subscriptionTargetConfig = subscriptionTargetConfig
            self.type = type
            self.updatedAt = updatedAt
            self.updatedBy = updatedBy
        }

        private enum CodingKeys: String, CodingKey {
            case applicableAssetTypes = "applicableAssetTypes"
            case authorizedPrincipals = "authorizedPrincipals"
            case createdAt = "createdAt"
            case createdBy = "createdBy"
            case domainId = "domainId"
            case environmentId = "environmentId"
            case id = "id"
            case manageAccessRole = "manageAccessRole"
            case name = "name"
            case projectId = "projectId"
            case provider = "provider"
            case subscriptionTargetConfig = "subscriptionTargetConfig"
            case type = "type"
            case updatedAt = "updatedAt"
            case updatedBy = "updatedBy"
        }
    }

    public struct UpdateUserProfileInput: AWSEncodableShape {
        /// The identifier of the Amazon DataZone domain in which a user profile is updated.
        public let domainIdentifier: String
        /// The status of the user profile that are to be updated.
        public let status: UserProfileStatus
        /// The type of the user profile that are to be updated.
        public let type: UserProfileType?
        /// The identifier of the user whose user profile is to be updated.
        public let userIdentifier: String

        public init(domainIdentifier: String, status: UserProfileStatus, type: UserProfileType? = nil, userIdentifier: String) {
            self.domainIdentifier = domainIdentifier
            self.status = status
            self.type = type
            self.userIdentifier = userIdentifier
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.domainIdentifier, key: "domainIdentifier")
            try container.encode(self.status, forKey: .status)
            try container.encodeIfPresent(self.type, forKey: .type)
            request.encodePath(self.userIdentifier, key: "userIdentifier")
        }

        public func validate(name: String) throws {
            try self.validate(self.domainIdentifier, name: "domainIdentifier", parent: name, pattern: "^dzd[-_][a-zA-Z0-9_-]{1,36}$")
            try self.validate(self.userIdentifier, name: "userIdentifier", parent: name, pattern: "(^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}$|^[a-zA-Z_0-9+=,.@-]+$|^arn:aws:iam::\\d{12}:.+$)")
        }

        private enum CodingKeys: String, CodingKey {
            case status = "status"
            case type = "type"
        }
    }

    public struct UpdateUserProfileOutput: AWSDecodableShape {
        public let details: UserProfileDetails?
        /// The identifier of the Amazon DataZone domain in which a user profile is updated.
        public let domainId: String?
        /// The identifier of the user profile.
        public let id: String?
        /// The status of the user profile.
        public let status: UserProfileStatus?
        /// The type of the user profile.
        public let type: UserProfileType?

        public init(details: UserProfileDetails? = nil, domainId: String? = nil, id: String? = nil, status: UserProfileStatus? = nil, type: UserProfileType? = nil) {
            self.details = details
            self.domainId = domainId
            self.id = id
            self.status = status
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case details = "details"
            case domainId = "domainId"
            case id = "id"
            case status = "status"
            case type = "type"
        }
    }

    public struct UserDetails: AWSDecodableShape {
        /// The identifier of the Amazon DataZone user.
        public let userId: String

        public init(userId: String) {
            self.userId = userId
        }

        private enum CodingKeys: String, CodingKey {
            case userId = "userId"
        }
    }

    public struct UserProfileSummary: AWSDecodableShape {
        /// The details of the user profile.
        public let details: UserProfileDetails?
        /// The ID of the Amazon DataZone domain of the user profile.
        public let domainId: String?
        /// The ID of the user profile.
        public let id: String?
        /// The status of the user profile.
        public let status: UserProfileStatus?
        /// The type of the user profile.
        public let type: UserProfileType?

        public init(details: UserProfileDetails? = nil, domainId: String? = nil, id: String? = nil, status: UserProfileStatus? = nil, type: UserProfileType? = nil) {
            self.details = details
            self.domainId = domainId
            self.id = id
            self.status = status
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case details = "details"
            case domainId = "domainId"
            case id = "id"
            case status = "status"
            case type = "type"
        }
    }

    public struct GrantedEntity: AWSDecodableShape {
        /// The listing for which a subscription is granted.
        public let listing: ListingRevision?

        public init(listing: ListingRevision? = nil) {
            self.listing = listing
        }

        private enum CodingKeys: String, CodingKey {
            case listing = "listing"
        }
    }

    public struct GrantedEntityInput: AWSEncodableShape {
        /// The listing for which a subscription is to be granted.
        public let listing: ListingRevisionInput?

        public init(listing: ListingRevisionInput? = nil) {
            self.listing = listing
        }

        public func validate(name: String) throws {
            try self.listing?.validate(name: "\(name).listing")
        }

        private enum CodingKeys: String, CodingKey {
            case listing = "listing"
        }
    }

    public struct ListingItem: AWSDecodableShape {
        /// An asset published in an Amazon DataZone catalog.
        public let assetListing: AssetListing?

        public init(assetListing: AssetListing? = nil) {
            self.assetListing = assetListing
        }

        private enum CodingKeys: String, CodingKey {
            case assetListing = "assetListing"
        }
    }

    public struct Model: AWSEncodableShape & AWSDecodableShape {
        /// Indicates the smithy model of the API.
        public let smithy: String?

        public init(smithy: String? = nil) {
            self.smithy = smithy
        }

        public func validate(name: String) throws {
            try self.validate(self.smithy, name: "smithy", parent: name, max: 10000)
            try self.validate(self.smithy, name: "smithy", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case smithy = "smithy"
        }
    }

    public struct ProvisioningProperties: AWSDecodableShape {
        /// The cloud formation properties included as part of the provisioning properties of an environment blueprint.
        public let cloudFormation: CloudFormationProperties?

        public init(cloudFormation: CloudFormationProperties? = nil) {
            self.cloudFormation = cloudFormation
        }

        private enum CodingKeys: String, CodingKey {
            case cloudFormation = "cloudFormation"
        }
    }

    public struct SearchResultItem: AWSDecodableShape {
        /// The asset listing included in the results of the SearchListings action.
        public let assetListing: AssetListingItem?

        public init(assetListing: AssetListingItem? = nil) {
            self.assetListing = assetListing
        }

        private enum CodingKeys: String, CodingKey {
            case assetListing = "assetListing"
        }
    }

    public struct SubscribedListingItem: AWSDecodableShape {
        /// The asset for which the subscription grant is created.
        public let assetListing: SubscribedAssetListing?

        public init(assetListing: SubscribedAssetListing? = nil) {
            self.assetListing = assetListing
        }

        private enum CodingKeys: String, CodingKey {
            case assetListing = "assetListing"
        }
    }

    public struct SubscribedPrincipal: AWSDecodableShape {
        /// The project that has the subscription grant.
        public let project: SubscribedProject?

        public init(project: SubscribedProject? = nil) {
            self.project = project
        }

        private enum CodingKeys: String, CodingKey {
            case project = "project"
        }
    }

    public struct SubscribedPrincipalInput: AWSEncodableShape {
        /// The project that is to be given a subscription grant.
        public let project: SubscribedProjectInput?

        public init(project: SubscribedProjectInput? = nil) {
            self.project = project
        }

        public func validate(name: String) throws {
            try self.project?.validate(name: "\(name).project")
        }

        private enum CodingKeys: String, CodingKey {
            case project = "project"
        }
    }
}

// MARK: - Errors

/// Error enum for DataZone
public struct DataZoneErrorType: AWSErrorType {
    enum Code: String {
        case accessDeniedException = "AccessDeniedException"
        case conflictException = "ConflictException"
        case internalServerException = "InternalServerException"
        case resourceNotFoundException = "ResourceNotFoundException"
        case serviceQuotaExceededException = "ServiceQuotaExceededException"
        case throttlingException = "ThrottlingException"
        case unauthorizedException = "UnauthorizedException"
        case validationException = "ValidationException"
    }

    private let error: Code
    public let context: AWSErrorContext?

    /// initialize DataZone
    public init?(errorCode: String, context: AWSErrorContext) {
        guard let error = Code(rawValue: errorCode) else { return nil }
        self.error = error
        self.context = context
    }

    internal init(_ error: Code) {
        self.error = error
        self.context = nil
    }

    /// return error code string
    public var errorCode: String { self.error.rawValue }

    /// You do not have sufficient access to perform this action.
    public static var accessDeniedException: Self { .init(.accessDeniedException) }
    /// There is a conflict while performing this action.
    public static var conflictException: Self { .init(.conflictException) }
    /// The request has failed because of an unknown error, exception or failure.
    public static var internalServerException: Self { .init(.internalServerException) }
    /// The specified resource cannot be found.
    public static var resourceNotFoundException: Self { .init(.resourceNotFoundException) }
    /// The request has exceeded the specified service quota.
    public static var serviceQuotaExceededException: Self { .init(.serviceQuotaExceededException) }
    /// The request was denied due to request throttling.
    public static var throttlingException: Self { .init(.throttlingException) }
    /// You do not have permission to perform this action.
    public static var unauthorizedException: Self { .init(.unauthorizedException) }
    /// The input fails to satisfy the constraints specified by the Amazon Web Services service.
    public static var validationException: Self { .init(.validationException) }
}

extension DataZoneErrorType: Equatable {
    public static func == (lhs: DataZoneErrorType, rhs: DataZoneErrorType) -> Bool {
        lhs.error == rhs.error
    }
}

extension DataZoneErrorType: CustomStringConvertible {
    public var description: String {
        return "\(self.error.rawValue): \(self.message ?? "")"
    }
}
