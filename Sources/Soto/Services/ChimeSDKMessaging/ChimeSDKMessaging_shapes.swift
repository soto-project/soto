//===----------------------------------------------------------------------===//
//
// This source file is part of the Soto for AWS open source project
//
// Copyright (c) 2017-2022 the Soto project authors
// Licensed under Apache License v2.0
//
// See LICENSE.txt for license information
// See CONTRIBUTORS.txt for the list of Soto project authors
//
// SPDX-License-Identifier: Apache-2.0
//
//===----------------------------------------------------------------------===//

// THIS FILE IS AUTOMATICALLY GENERATED by https://github.com/soto-project/soto-codegenerator.
// DO NOT EDIT.

import Foundation
import SotoCore

extension ChimeSDKMessaging {
    // MARK: Enums

    public enum AllowNotifications: String, CustomStringConvertible, Codable, _SotoSendable {
        case all = "ALL"
        case filtered = "FILTERED"
        case none = "NONE"
        public var description: String { return self.rawValue }
    }

    public enum ChannelMembershipType: String, CustomStringConvertible, Codable, _SotoSendable {
        case `default` = "DEFAULT"
        case hidden = "HIDDEN"
        public var description: String { return self.rawValue }
    }

    public enum ChannelMessagePersistenceType: String, CustomStringConvertible, Codable, _SotoSendable {
        case nonPersistent = "NON_PERSISTENT"
        case persistent = "PERSISTENT"
        public var description: String { return self.rawValue }
    }

    public enum ChannelMessageStatus: String, CustomStringConvertible, Codable, _SotoSendable {
        case denied = "DENIED"
        case failed = "FAILED"
        case pending = "PENDING"
        case sent = "SENT"
        public var description: String { return self.rawValue }
    }

    public enum ChannelMessageType: String, CustomStringConvertible, Codable, _SotoSendable {
        case control = "CONTROL"
        case standard = "STANDARD"
        public var description: String { return self.rawValue }
    }

    public enum ChannelMode: String, CustomStringConvertible, Codable, _SotoSendable {
        case restricted = "RESTRICTED"
        case unrestricted = "UNRESTRICTED"
        public var description: String { return self.rawValue }
    }

    public enum ChannelPrivacy: String, CustomStringConvertible, Codable, _SotoSendable {
        case `private` = "PRIVATE"
        case `public` = "PUBLIC"
        public var description: String { return self.rawValue }
    }

    public enum ErrorCode: String, CustomStringConvertible, Codable, _SotoSendable {
        case accessDenied = "AccessDenied"
        case badRequest = "BadRequest"
        case conflict = "Conflict"
        case forbidden = "Forbidden"
        case notFound = "NotFound"
        case phoneNumberAssociationsExist = "PhoneNumberAssociationsExist"
        case preconditionFailed = "PreconditionFailed"
        case resourceLimitExceeded = "ResourceLimitExceeded"
        case serviceFailure = "ServiceFailure"
        case serviceUnavailable = "ServiceUnavailable"
        case throttled = "Throttled"
        case throttling = "Throttling"
        case unauthorized = "Unauthorized"
        case unprocessable = "Unprocessable"
        case voiceConnectorGroupAssociationsExist = "VoiceConnectorGroupAssociationsExist"
        public var description: String { return self.rawValue }
    }

    public enum FallbackAction: String, CustomStringConvertible, Codable, _SotoSendable {
        case `continue` = "CONTINUE"
        case abort = "ABORT"
        public var description: String { return self.rawValue }
    }

    public enum InvocationType: String, CustomStringConvertible, Codable, _SotoSendable {
        case `async` = "ASYNC"
        public var description: String { return self.rawValue }
    }

    public enum PushNotificationType: String, CustomStringConvertible, Codable, _SotoSendable {
        case `default` = "DEFAULT"
        case voip = "VOIP"
        public var description: String { return self.rawValue }
    }

    public enum SearchFieldKey: String, CustomStringConvertible, Codable, _SotoSendable {
        case members = "MEMBERS"
        public var description: String { return self.rawValue }
    }

    public enum SearchFieldOperator: String, CustomStringConvertible, Codable, _SotoSendable {
        case equals = "EQUALS"
        case includes = "INCLUDES"
        public var description: String { return self.rawValue }
    }

    public enum SortOrder: String, CustomStringConvertible, Codable, _SotoSendable {
        case ascending = "ASCENDING"
        case descending = "DESCENDING"
        public var description: String { return self.rawValue }
    }

    // MARK: Shapes

    public struct AppInstanceUserMembershipSummary: AWSDecodableShape {
        /// The time at which an AppInstanceUser last marked a channel as read.
        public let readMarkerTimestamp: Date?
        /// The ID of the SubChannel that the AppInstanceUser is a member of.
        public let subChannelId: String?
        /// The type of ChannelMembership.
        public let type: ChannelMembershipType?

        public init(readMarkerTimestamp: Date? = nil, subChannelId: String? = nil, type: ChannelMembershipType? = nil) {
            self.readMarkerTimestamp = readMarkerTimestamp
            self.subChannelId = subChannelId
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case readMarkerTimestamp = "ReadMarkerTimestamp"
            case subChannelId = "SubChannelId"
            case type = "Type"
        }
    }

    public struct AssociateChannelFlowRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "channelArn", location: .uri("ChannelArn")),
            AWSMemberEncoding(label: "chimeBearer", location: .header("x-amz-chime-bearer"))
        ]

        /// The ARN of the channel.
        public let channelArn: String
        /// The ARN of the channel flow.
        public let channelFlowArn: String
        /// The AppInstanceUserArn of the user making the API call.
        public let chimeBearer: String

        public init(channelArn: String, channelFlowArn: String, chimeBearer: String) {
            self.channelArn = channelArn
            self.channelFlowArn = channelFlowArn
            self.chimeBearer = chimeBearer
        }

        public func validate(name: String) throws {
            try self.validate(self.channelArn, name: "channelArn", parent: name, max: 1600)
            try self.validate(self.channelArn, name: "channelArn", parent: name, min: 5)
            try self.validate(self.channelArn, name: "channelArn", parent: name, pattern: "^arn:[a-z0-9-\\.]{1,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[^/].{0,1023}$")
            try self.validate(self.channelFlowArn, name: "channelFlowArn", parent: name, max: 1600)
            try self.validate(self.channelFlowArn, name: "channelFlowArn", parent: name, min: 5)
            try self.validate(self.channelFlowArn, name: "channelFlowArn", parent: name, pattern: "^arn:[a-z0-9-\\.]{1,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[^/].{0,1023}$")
            try self.validate(self.chimeBearer, name: "chimeBearer", parent: name, max: 1600)
            try self.validate(self.chimeBearer, name: "chimeBearer", parent: name, min: 5)
            try self.validate(self.chimeBearer, name: "chimeBearer", parent: name, pattern: "^arn:[a-z0-9-\\.]{1,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[^/].{0,1023}$")
        }

        private enum CodingKeys: String, CodingKey {
            case channelFlowArn = "ChannelFlowArn"
        }
    }

    public struct BatchChannelMemberships: AWSDecodableShape {
        /// The ARN of the channel to which you're adding users.
        public let channelArn: String?
        /// The identifier of the member who invited another member.
        public let invitedBy: Identity?
        /// The users successfully added to the request.
        public let members: [Identity]?
        /// The ID of the SubChannel.
        public let subChannelId: String?
        /// The membership types set for the channel users.
        public let type: ChannelMembershipType?

        public init(channelArn: String? = nil, invitedBy: Identity? = nil, members: [Identity]? = nil, subChannelId: String? = nil, type: ChannelMembershipType? = nil) {
            self.channelArn = channelArn
            self.invitedBy = invitedBy
            self.members = members
            self.subChannelId = subChannelId
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case channelArn = "ChannelArn"
            case invitedBy = "InvitedBy"
            case members = "Members"
            case subChannelId = "SubChannelId"
            case type = "Type"
        }
    }

    public struct BatchCreateChannelMembershipError: AWSDecodableShape {
        /// The error code.
        public let errorCode: ErrorCode?
        /// The error message.
        public let errorMessage: String?
        /// The AppInstanceUserArn of the member that the service couldn't add.
        public let memberArn: String?

        public init(errorCode: ErrorCode? = nil, errorMessage: String? = nil, memberArn: String? = nil) {
            self.errorCode = errorCode
            self.errorMessage = errorMessage
            self.memberArn = memberArn
        }

        private enum CodingKeys: String, CodingKey {
            case errorCode = "ErrorCode"
            case errorMessage = "ErrorMessage"
            case memberArn = "MemberArn"
        }
    }

    public struct BatchCreateChannelMembershipRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "channelArn", location: .uri("ChannelArn")),
            AWSMemberEncoding(label: "chimeBearer", location: .header("x-amz-chime-bearer"))
        ]

        /// The ARN of the channel to which you're adding users.
        public let channelArn: String
        /// The AppInstanceUserArn of the user that makes the API call.
        public let chimeBearer: String
        /// The AppInstanceUserArns of the members you want to add to the channel.
        public let memberArns: [String]
        /// The ID of the SubChannel in the request.   Only required when creating membership in a SubChannel for a moderator in an elastic channel.
        public let subChannelId: String?
        /// The membership type of a user, DEFAULT or HIDDEN. Default members are always returned as part of ListChannelMemberships. Hidden members are only returned if the type filter in ListChannelMemberships equals HIDDEN. Otherwise hidden members are not returned. This is only supported by moderators.
        public let type: ChannelMembershipType?

        public init(channelArn: String, chimeBearer: String, memberArns: [String], subChannelId: String? = nil, type: ChannelMembershipType? = nil) {
            self.channelArn = channelArn
            self.chimeBearer = chimeBearer
            self.memberArns = memberArns
            self.subChannelId = subChannelId
            self.type = type
        }

        public func validate(name: String) throws {
            try self.validate(self.channelArn, name: "channelArn", parent: name, max: 1600)
            try self.validate(self.channelArn, name: "channelArn", parent: name, min: 5)
            try self.validate(self.channelArn, name: "channelArn", parent: name, pattern: "^arn:[a-z0-9-\\.]{1,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[^/].{0,1023}$")
            try self.validate(self.chimeBearer, name: "chimeBearer", parent: name, max: 1600)
            try self.validate(self.chimeBearer, name: "chimeBearer", parent: name, min: 5)
            try self.validate(self.chimeBearer, name: "chimeBearer", parent: name, pattern: "^arn:[a-z0-9-\\.]{1,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[^/].{0,1023}$")
            try self.memberArns.forEach {
                try validate($0, name: "memberArns[]", parent: name, max: 1600)
                try validate($0, name: "memberArns[]", parent: name, min: 5)
                try validate($0, name: "memberArns[]", parent: name, pattern: "^arn:[a-z0-9-\\.]{1,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[^/].{0,1023}$")
            }
            try self.validate(self.memberArns, name: "memberArns", parent: name, max: 100)
            try self.validate(self.memberArns, name: "memberArns", parent: name, min: 1)
            try self.validate(self.subChannelId, name: "subChannelId", parent: name, max: 128)
            try self.validate(self.subChannelId, name: "subChannelId", parent: name, min: 1)
            try self.validate(self.subChannelId, name: "subChannelId", parent: name, pattern: "^[-_a-zA-Z0-9]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case memberArns = "MemberArns"
            case subChannelId = "SubChannelId"
            case type = "Type"
        }
    }

    public struct BatchCreateChannelMembershipResponse: AWSDecodableShape {
        /// The list of channel memberships in the response.
        public let batchChannelMemberships: BatchChannelMemberships?
        /// If the action fails for one or more of the memberships in the request, a list of the memberships is returned, along with error codes and error messages.
        public let errors: [BatchCreateChannelMembershipError]?

        public init(batchChannelMemberships: BatchChannelMemberships? = nil, errors: [BatchCreateChannelMembershipError]? = nil) {
            self.batchChannelMemberships = batchChannelMemberships
            self.errors = errors
        }

        private enum CodingKeys: String, CodingKey {
            case batchChannelMemberships = "BatchChannelMemberships"
            case errors = "Errors"
        }
    }

    public struct Channel: AWSDecodableShape {
        /// The ARN of a channel.
        public let channelArn: String?
        /// The ARN of the channel flow.
        public let channelFlowArn: String?
        /// The AppInstanceUser who created the channel.
        public let createdBy: Identity?
        /// The time at which the AppInstanceUser created the channel.
        public let createdTimestamp: Date?
        /// The attributes required to configure and create an elastic channel. An elastic channel can support a maximum of 1-million members.
        public let elasticChannelConfiguration: ElasticChannelConfiguration?
        /// The time at which a member sent the last message in the channel.
        public let lastMessageTimestamp: Date?
        /// The time at which a channel was last updated.
        public let lastUpdatedTimestamp: Date?
        /// The channel's metadata.
        public let metadata: String?
        /// The mode of the channel.
        public let mode: ChannelMode?
        /// The name of a channel.
        public let name: String?
        /// The channel's privacy setting.
        public let privacy: ChannelPrivacy?

        public init(channelArn: String? = nil, channelFlowArn: String? = nil, createdBy: Identity? = nil, createdTimestamp: Date? = nil, elasticChannelConfiguration: ElasticChannelConfiguration? = nil, lastMessageTimestamp: Date? = nil, lastUpdatedTimestamp: Date? = nil, metadata: String? = nil, mode: ChannelMode? = nil, name: String? = nil, privacy: ChannelPrivacy? = nil) {
            self.channelArn = channelArn
            self.channelFlowArn = channelFlowArn
            self.createdBy = createdBy
            self.createdTimestamp = createdTimestamp
            self.elasticChannelConfiguration = elasticChannelConfiguration
            self.lastMessageTimestamp = lastMessageTimestamp
            self.lastUpdatedTimestamp = lastUpdatedTimestamp
            self.metadata = metadata
            self.mode = mode
            self.name = name
            self.privacy = privacy
        }

        private enum CodingKeys: String, CodingKey {
            case channelArn = "ChannelArn"
            case channelFlowArn = "ChannelFlowArn"
            case createdBy = "CreatedBy"
            case createdTimestamp = "CreatedTimestamp"
            case elasticChannelConfiguration = "ElasticChannelConfiguration"
            case lastMessageTimestamp = "LastMessageTimestamp"
            case lastUpdatedTimestamp = "LastUpdatedTimestamp"
            case metadata = "Metadata"
            case mode = "Mode"
            case name = "Name"
            case privacy = "Privacy"
        }
    }

    public struct ChannelAssociatedWithFlowSummary: AWSDecodableShape {
        /// The ARN of the channel.
        public let channelArn: String?
        /// The channel's metadata.
        public let metadata: String?
        /// The mode of the channel.
        public let mode: ChannelMode?
        /// The name of the channel flow.
        public let name: String?
        /// The channel's privacy setting.
        public let privacy: ChannelPrivacy?

        public init(channelArn: String? = nil, metadata: String? = nil, mode: ChannelMode? = nil, name: String? = nil, privacy: ChannelPrivacy? = nil) {
            self.channelArn = channelArn
            self.metadata = metadata
            self.mode = mode
            self.name = name
            self.privacy = privacy
        }

        private enum CodingKeys: String, CodingKey {
            case channelArn = "ChannelArn"
            case metadata = "Metadata"
            case mode = "Mode"
            case name = "Name"
            case privacy = "Privacy"
        }
    }

    public struct ChannelBan: AWSDecodableShape {
        /// The ARN of the channel from which a member is being banned.
        public let channelArn: String?
        /// The AppInstanceUser who created the ban.
        public let createdBy: Identity?
        /// The time at which the ban was created.
        public let createdTimestamp: Date?
        /// The member being banned from the channel.
        public let member: Identity?

        public init(channelArn: String? = nil, createdBy: Identity? = nil, createdTimestamp: Date? = nil, member: Identity? = nil) {
            self.channelArn = channelArn
            self.createdBy = createdBy
            self.createdTimestamp = createdTimestamp
            self.member = member
        }

        private enum CodingKeys: String, CodingKey {
            case channelArn = "ChannelArn"
            case createdBy = "CreatedBy"
            case createdTimestamp = "CreatedTimestamp"
            case member = "Member"
        }
    }

    public struct ChannelBanSummary: AWSDecodableShape {
        /// The member being banned from a channel.
        public let member: Identity?

        public init(member: Identity? = nil) {
            self.member = member
        }

        private enum CodingKeys: String, CodingKey {
            case member = "Member"
        }
    }

    public struct ChannelFlow: AWSDecodableShape {
        /// The ARN of the channel flow.
        public let channelFlowArn: String?
        /// The time at which the channel flow was created.
        public let createdTimestamp: Date?
        /// The time at which a channel flow was updated.
        public let lastUpdatedTimestamp: Date?
        /// The name of the channel flow.
        public let name: String?
        /// Information about the processor Lambda functions.
        public let processors: [Processor]?

        public init(channelFlowArn: String? = nil, createdTimestamp: Date? = nil, lastUpdatedTimestamp: Date? = nil, name: String? = nil, processors: [Processor]? = nil) {
            self.channelFlowArn = channelFlowArn
            self.createdTimestamp = createdTimestamp
            self.lastUpdatedTimestamp = lastUpdatedTimestamp
            self.name = name
            self.processors = processors
        }

        private enum CodingKeys: String, CodingKey {
            case channelFlowArn = "ChannelFlowArn"
            case createdTimestamp = "CreatedTimestamp"
            case lastUpdatedTimestamp = "LastUpdatedTimestamp"
            case name = "Name"
            case processors = "Processors"
        }
    }

    public struct ChannelFlowCallbackRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "channelArn", location: .uri("ChannelArn"))
        ]

        /// The identifier passed to the processor by the service when invoked. Use the identifier to call back the service.
        public let callbackId: String
        /// The ARN of the channel.
        public let channelArn: String
        /// Stores information about the processed message.
        public let channelMessage: ChannelMessageCallback
        /// When a processor determines that a message needs to be DENIED, pass this parameter with a value of true.
        public let deleteResource: Bool?

        public init(callbackId: String = ChannelFlowCallbackRequest.idempotencyToken(), channelArn: String, channelMessage: ChannelMessageCallback, deleteResource: Bool? = nil) {
            self.callbackId = callbackId
            self.channelArn = channelArn
            self.channelMessage = channelMessage
            self.deleteResource = deleteResource
        }

        public func validate(name: String) throws {
            try self.validate(self.callbackId, name: "callbackId", parent: name, max: 64)
            try self.validate(self.callbackId, name: "callbackId", parent: name, min: 32)
            try self.validate(self.channelArn, name: "channelArn", parent: name, max: 1600)
            try self.validate(self.channelArn, name: "channelArn", parent: name, min: 5)
            try self.validate(self.channelArn, name: "channelArn", parent: name, pattern: "^arn:[a-z0-9-\\.]{1,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[^/].{0,1023}$")
            try self.channelMessage.validate(name: "\(name).channelMessage")
        }

        private enum CodingKeys: String, CodingKey {
            case callbackId = "CallbackId"
            case channelMessage = "ChannelMessage"
            case deleteResource = "DeleteResource"
        }
    }

    public struct ChannelFlowCallbackResponse: AWSDecodableShape {
        /// The call back ID passed in the request.
        public let callbackId: String?
        /// The ARN of the channel.
        public let channelArn: String?

        public init(callbackId: String? = nil, channelArn: String? = nil) {
            self.callbackId = callbackId
            self.channelArn = channelArn
        }

        private enum CodingKeys: String, CodingKey {
            case callbackId = "CallbackId"
            case channelArn = "ChannelArn"
        }
    }

    public struct ChannelFlowSummary: AWSDecodableShape {
        /// The ARN of the channel flow.
        public let channelFlowArn: String?
        /// The name of the channel flow.
        public let name: String?
        /// Information about the processor Lambda functions.
        public let processors: [Processor]?

        public init(channelFlowArn: String? = nil, name: String? = nil, processors: [Processor]? = nil) {
            self.channelFlowArn = channelFlowArn
            self.name = name
            self.processors = processors
        }

        private enum CodingKeys: String, CodingKey {
            case channelFlowArn = "ChannelFlowArn"
            case name = "Name"
            case processors = "Processors"
        }
    }

    public struct ChannelMembership: AWSDecodableShape {
        /// The ARN of the member's channel.
        public let channelArn: String?
        /// The time at which the channel membership was created.
        public let createdTimestamp: Date?
        /// The identifier of the member who invited another member.
        public let invitedBy: Identity?
        /// The time at which a channel membership was last updated.
        public let lastUpdatedTimestamp: Date?
        /// The data of the channel member.
        public let member: Identity?
        /// The ID of the SubChannel that a user belongs to.
        public let subChannelId: String?
        /// The membership type set for the channel member.
        public let type: ChannelMembershipType?

        public init(channelArn: String? = nil, createdTimestamp: Date? = nil, invitedBy: Identity? = nil, lastUpdatedTimestamp: Date? = nil, member: Identity? = nil, subChannelId: String? = nil, type: ChannelMembershipType? = nil) {
            self.channelArn = channelArn
            self.createdTimestamp = createdTimestamp
            self.invitedBy = invitedBy
            self.lastUpdatedTimestamp = lastUpdatedTimestamp
            self.member = member
            self.subChannelId = subChannelId
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case channelArn = "ChannelArn"
            case createdTimestamp = "CreatedTimestamp"
            case invitedBy = "InvitedBy"
            case lastUpdatedTimestamp = "LastUpdatedTimestamp"
            case member = "Member"
            case subChannelId = "SubChannelId"
            case type = "Type"
        }
    }

    public struct ChannelMembershipForAppInstanceUserSummary: AWSDecodableShape {
        /// Returns the channel membership data for an AppInstance.
        public let appInstanceUserMembershipSummary: AppInstanceUserMembershipSummary?
        /// Returns the channel data for an AppInstance.
        public let channelSummary: ChannelSummary?

        public init(appInstanceUserMembershipSummary: AppInstanceUserMembershipSummary? = nil, channelSummary: ChannelSummary? = nil) {
            self.appInstanceUserMembershipSummary = appInstanceUserMembershipSummary
            self.channelSummary = channelSummary
        }

        private enum CodingKeys: String, CodingKey {
            case appInstanceUserMembershipSummary = "AppInstanceUserMembershipSummary"
            case channelSummary = "ChannelSummary"
        }
    }

    public struct ChannelMembershipPreferences: AWSEncodableShape & AWSDecodableShape {
        /// The push notification configuration of a message.
        public let pushNotifications: PushNotificationPreferences?

        public init(pushNotifications: PushNotificationPreferences? = nil) {
            self.pushNotifications = pushNotifications
        }

        public func validate(name: String) throws {
            try self.pushNotifications?.validate(name: "\(name).pushNotifications")
        }

        private enum CodingKeys: String, CodingKey {
            case pushNotifications = "PushNotifications"
        }
    }

    public struct ChannelMembershipSummary: AWSDecodableShape {
        /// A member's summary data.
        public let member: Identity?

        public init(member: Identity? = nil) {
            self.member = member
        }

        private enum CodingKeys: String, CodingKey {
            case member = "Member"
        }
    }

    public struct ChannelMessage: AWSDecodableShape {
        /// The ARN of the channel.
        public let channelArn: String?
        /// The message content.
        public let content: String?
        /// The time at which the message was created.
        public let createdTimestamp: Date?
        /// The time at which a message was edited.
        public let lastEditedTimestamp: Date?
        /// The time at which a message was updated.
        public let lastUpdatedTimestamp: Date?
        /// The attributes for the message, used for message filtering along with a FilterRule defined in the PushNotificationPreferences.
        public let messageAttributes: [String: MessageAttributeValue]?
        /// The ID of a message.
        public let messageId: String?
        /// The message metadata.
        public let metadata: String?
        /// The persistence setting for a channel message.
        public let persistence: ChannelMessagePersistenceType?
        /// Hides the content of a message.
        public let redacted: Bool?
        /// The message sender.
        public let sender: Identity?
        /// The status of the channel message.
        public let status: ChannelMessageStatusStructure?
        /// The ID of the SubChannel.
        public let subChannelId: String?
        /// The message type.
        public let type: ChannelMessageType?

        public init(channelArn: String? = nil, content: String? = nil, createdTimestamp: Date? = nil, lastEditedTimestamp: Date? = nil, lastUpdatedTimestamp: Date? = nil, messageAttributes: [String: MessageAttributeValue]? = nil, messageId: String? = nil, metadata: String? = nil, persistence: ChannelMessagePersistenceType? = nil, redacted: Bool? = nil, sender: Identity? = nil, status: ChannelMessageStatusStructure? = nil, subChannelId: String? = nil, type: ChannelMessageType? = nil) {
            self.channelArn = channelArn
            self.content = content
            self.createdTimestamp = createdTimestamp
            self.lastEditedTimestamp = lastEditedTimestamp
            self.lastUpdatedTimestamp = lastUpdatedTimestamp
            self.messageAttributes = messageAttributes
            self.messageId = messageId
            self.metadata = metadata
            self.persistence = persistence
            self.redacted = redacted
            self.sender = sender
            self.status = status
            self.subChannelId = subChannelId
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case channelArn = "ChannelArn"
            case content = "Content"
            case createdTimestamp = "CreatedTimestamp"
            case lastEditedTimestamp = "LastEditedTimestamp"
            case lastUpdatedTimestamp = "LastUpdatedTimestamp"
            case messageAttributes = "MessageAttributes"
            case messageId = "MessageId"
            case metadata = "Metadata"
            case persistence = "Persistence"
            case redacted = "Redacted"
            case sender = "Sender"
            case status = "Status"
            case subChannelId = "SubChannelId"
            case type = "Type"
        }
    }

    public struct ChannelMessageCallback: AWSEncodableShape {
        /// The message content.
        public let content: String?
        /// The attributes for the message, used for message filtering along with a FilterRule defined in the PushNotificationPreferences.
        public let messageAttributes: [String: MessageAttributeValue]?
        /// The message ID.
        public let messageId: String
        /// The message metadata.
        public let metadata: String?
        /// The push notification configuration of the message.
        public let pushNotification: PushNotificationConfiguration?
        /// The ID of the SubChannel.
        public let subChannelId: String?

        public init(content: String? = nil, messageAttributes: [String: MessageAttributeValue]? = nil, messageId: String, metadata: String? = nil, pushNotification: PushNotificationConfiguration? = nil, subChannelId: String? = nil) {
            self.content = content
            self.messageAttributes = messageAttributes
            self.messageId = messageId
            self.metadata = metadata
            self.pushNotification = pushNotification
            self.subChannelId = subChannelId
        }

        public func validate(name: String) throws {
            try self.validate(self.content, name: "content", parent: name, min: 1)
            try self.validate(self.content, name: "content", parent: name, pattern: "^[\\s\\S]*$")
            try self.messageAttributes?.forEach {
                try validate($0.key, name: "messageAttributes.key", parent: name, max: 64)
                try validate($0.key, name: "messageAttributes.key", parent: name, min: 1)
                try validate($0.key, name: "messageAttributes.key", parent: name, pattern: "^[\\s\\S]*$")
                try $0.value.validate(name: "\(name).messageAttributes[\"\($0.key)\"]")
            }
            try self.validate(self.messageId, name: "messageId", parent: name, max: 128)
            try self.validate(self.messageId, name: "messageId", parent: name, min: 1)
            try self.validate(self.messageId, name: "messageId", parent: name, pattern: "^[-_a-zA-Z0-9]*$")
            try self.validate(self.metadata, name: "metadata", parent: name, max: 1024)
            try self.validate(self.metadata, name: "metadata", parent: name, pattern: ".*")
            try self.pushNotification?.validate(name: "\(name).pushNotification")
            try self.validate(self.subChannelId, name: "subChannelId", parent: name, max: 128)
            try self.validate(self.subChannelId, name: "subChannelId", parent: name, min: 1)
            try self.validate(self.subChannelId, name: "subChannelId", parent: name, pattern: "^[-_a-zA-Z0-9]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case content = "Content"
            case messageAttributes = "MessageAttributes"
            case messageId = "MessageId"
            case metadata = "Metadata"
            case pushNotification = "PushNotification"
            case subChannelId = "SubChannelId"
        }
    }

    public struct ChannelMessageStatusStructure: AWSDecodableShape {
        /// Contains more details about the messasge status.
        public let detail: String?
        /// The message status value.
        public let value: ChannelMessageStatus?

        public init(detail: String? = nil, value: ChannelMessageStatus? = nil) {
            self.detail = detail
            self.value = value
        }

        private enum CodingKeys: String, CodingKey {
            case detail = "Detail"
            case value = "Value"
        }
    }

    public struct ChannelMessageSummary: AWSDecodableShape {
        /// The content of the message.
        public let content: String?
        /// The time at which the message summary was created.
        public let createdTimestamp: Date?
        /// The time at which a message was last edited.
        public let lastEditedTimestamp: Date?
        /// The time at which a message was last updated.
        public let lastUpdatedTimestamp: Date?
        /// The message attribues listed in a the summary of a channel message.
        public let messageAttributes: [String: MessageAttributeValue]?
        /// The ID of the message.
        public let messageId: String?
        /// The metadata of the message.
        public let metadata: String?
        /// Indicates whether a message was redacted.
        public let redacted: Bool?
        /// The message sender.
        public let sender: Identity?
        /// The message status. The status value is SENT for messages sent to a channel without a channel flow. For channels associated with channel flow, the value determines the  processing stage.
        public let status: ChannelMessageStatusStructure?
        /// The type of message.
        public let type: ChannelMessageType?

        public init(content: String? = nil, createdTimestamp: Date? = nil, lastEditedTimestamp: Date? = nil, lastUpdatedTimestamp: Date? = nil, messageAttributes: [String: MessageAttributeValue]? = nil, messageId: String? = nil, metadata: String? = nil, redacted: Bool? = nil, sender: Identity? = nil, status: ChannelMessageStatusStructure? = nil, type: ChannelMessageType? = nil) {
            self.content = content
            self.createdTimestamp = createdTimestamp
            self.lastEditedTimestamp = lastEditedTimestamp
            self.lastUpdatedTimestamp = lastUpdatedTimestamp
            self.messageAttributes = messageAttributes
            self.messageId = messageId
            self.metadata = metadata
            self.redacted = redacted
            self.sender = sender
            self.status = status
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case content = "Content"
            case createdTimestamp = "CreatedTimestamp"
            case lastEditedTimestamp = "LastEditedTimestamp"
            case lastUpdatedTimestamp = "LastUpdatedTimestamp"
            case messageAttributes = "MessageAttributes"
            case messageId = "MessageId"
            case metadata = "Metadata"
            case redacted = "Redacted"
            case sender = "Sender"
            case status = "Status"
            case type = "Type"
        }
    }

    public struct ChannelModeratedByAppInstanceUserSummary: AWSDecodableShape {
        /// Summary of the details of a Channel.
        public let channelSummary: ChannelSummary?

        public init(channelSummary: ChannelSummary? = nil) {
            self.channelSummary = channelSummary
        }

        private enum CodingKeys: String, CodingKey {
            case channelSummary = "ChannelSummary"
        }
    }

    public struct ChannelModerator: AWSDecodableShape {
        /// The ARN of the moderator's channel.
        public let channelArn: String?
        /// The AppInstanceUser who created the moderator.
        public let createdBy: Identity?
        /// The time at which the moderator was created.
        public let createdTimestamp: Date?
        /// The moderator's data.
        public let moderator: Identity?

        public init(channelArn: String? = nil, createdBy: Identity? = nil, createdTimestamp: Date? = nil, moderator: Identity? = nil) {
            self.channelArn = channelArn
            self.createdBy = createdBy
            self.createdTimestamp = createdTimestamp
            self.moderator = moderator
        }

        private enum CodingKeys: String, CodingKey {
            case channelArn = "ChannelArn"
            case createdBy = "CreatedBy"
            case createdTimestamp = "CreatedTimestamp"
            case moderator = "Moderator"
        }
    }

    public struct ChannelModeratorSummary: AWSDecodableShape {
        /// The data for a moderator.
        public let moderator: Identity?

        public init(moderator: Identity? = nil) {
            self.moderator = moderator
        }

        private enum CodingKeys: String, CodingKey {
            case moderator = "Moderator"
        }
    }

    public struct ChannelSummary: AWSDecodableShape {
        /// The ARN of the channel.
        public let channelArn: String?
        /// The time at which the last persistent message in a channel was sent.
        public let lastMessageTimestamp: Date?
        /// The metadata of the channel.
        public let metadata: String?
        /// The mode of the channel.
        public let mode: ChannelMode?
        /// The name of the channel.
        public let name: String?
        /// The privacy setting of the channel.
        public let privacy: ChannelPrivacy?

        public init(channelArn: String? = nil, lastMessageTimestamp: Date? = nil, metadata: String? = nil, mode: ChannelMode? = nil, name: String? = nil, privacy: ChannelPrivacy? = nil) {
            self.channelArn = channelArn
            self.lastMessageTimestamp = lastMessageTimestamp
            self.metadata = metadata
            self.mode = mode
            self.name = name
            self.privacy = privacy
        }

        private enum CodingKeys: String, CodingKey {
            case channelArn = "ChannelArn"
            case lastMessageTimestamp = "LastMessageTimestamp"
            case metadata = "Metadata"
            case mode = "Mode"
            case name = "Name"
            case privacy = "Privacy"
        }
    }

    public struct CreateChannelBanRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "channelArn", location: .uri("ChannelArn")),
            AWSMemberEncoding(label: "chimeBearer", location: .header("x-amz-chime-bearer"))
        ]

        /// The ARN of the ban request.
        public let channelArn: String
        /// The AppInstanceUserArn of the user that makes the API call.
        public let chimeBearer: String
        /// The AppInstanceUserArn of the member being banned.
        public let memberArn: String

        public init(channelArn: String, chimeBearer: String, memberArn: String) {
            self.channelArn = channelArn
            self.chimeBearer = chimeBearer
            self.memberArn = memberArn
        }

        public func validate(name: String) throws {
            try self.validate(self.channelArn, name: "channelArn", parent: name, max: 1600)
            try self.validate(self.channelArn, name: "channelArn", parent: name, min: 5)
            try self.validate(self.channelArn, name: "channelArn", parent: name, pattern: "^arn:[a-z0-9-\\.]{1,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[^/].{0,1023}$")
            try self.validate(self.chimeBearer, name: "chimeBearer", parent: name, max: 1600)
            try self.validate(self.chimeBearer, name: "chimeBearer", parent: name, min: 5)
            try self.validate(self.chimeBearer, name: "chimeBearer", parent: name, pattern: "^arn:[a-z0-9-\\.]{1,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[^/].{0,1023}$")
            try self.validate(self.memberArn, name: "memberArn", parent: name, max: 1600)
            try self.validate(self.memberArn, name: "memberArn", parent: name, min: 5)
            try self.validate(self.memberArn, name: "memberArn", parent: name, pattern: "^arn:[a-z0-9-\\.]{1,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[^/].{0,1023}$")
        }

        private enum CodingKeys: String, CodingKey {
            case memberArn = "MemberArn"
        }
    }

    public struct CreateChannelBanResponse: AWSDecodableShape {
        /// The ARN of the response to the ban request.
        public let channelArn: String?
        /// The ChannelArn and BannedIdentity of the member in the ban response.
        public let member: Identity?

        public init(channelArn: String? = nil, member: Identity? = nil) {
            self.channelArn = channelArn
            self.member = member
        }

        private enum CodingKeys: String, CodingKey {
            case channelArn = "ChannelArn"
            case member = "Member"
        }
    }

    public struct CreateChannelFlowRequest: AWSEncodableShape {
        /// The ARN of the channel flow request.
        public let appInstanceArn: String
        /// The client token for the request. An Idempotency token.
        public let clientRequestToken: String
        /// The name of the channel flow.
        public let name: String
        /// Information about the processor Lambda functions.
        public let processors: [Processor]
        /// The tags for the creation request.
        public let tags: [Tag]?

        public init(appInstanceArn: String, clientRequestToken: String, name: String, processors: [Processor], tags: [Tag]? = nil) {
            self.appInstanceArn = appInstanceArn
            self.clientRequestToken = clientRequestToken
            self.name = name
            self.processors = processors
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.validate(self.appInstanceArn, name: "appInstanceArn", parent: name, max: 1600)
            try self.validate(self.appInstanceArn, name: "appInstanceArn", parent: name, min: 5)
            try self.validate(self.appInstanceArn, name: "appInstanceArn", parent: name, pattern: "^arn:[a-z0-9-\\.]{1,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[^/].{0,1023}$")
            try self.validate(self.clientRequestToken, name: "clientRequestToken", parent: name, max: 64)
            try self.validate(self.clientRequestToken, name: "clientRequestToken", parent: name, min: 2)
            try self.validate(self.clientRequestToken, name: "clientRequestToken", parent: name, pattern: "^[-_a-zA-Z0-9]*$")
            try self.validate(self.name, name: "name", parent: name, max: 256)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[\\u0009\\u000A\\u000D\\u0020-\\u007E\\u0085\\u00A0-\\uD7FF\\uE000-\\uFFFD\\u10000-\\u10FFFF]*$")
            try self.processors.forEach {
                try $0.validate(name: "\(name).processors[]")
            }
            try self.validate(self.processors, name: "processors", parent: name, max: 3)
            try self.validate(self.processors, name: "processors", parent: name, min: 1)
            try self.tags?.forEach {
                try $0.validate(name: "\(name).tags[]")
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 50)
            try self.validate(self.tags, name: "tags", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case appInstanceArn = "AppInstanceArn"
            case clientRequestToken = "ClientRequestToken"
            case name = "Name"
            case processors = "Processors"
            case tags = "Tags"
        }
    }

    public struct CreateChannelFlowResponse: AWSDecodableShape {
        /// The ARN of the channel flow.
        public let channelFlowArn: String?

        public init(channelFlowArn: String? = nil) {
            self.channelFlowArn = channelFlowArn
        }

        private enum CodingKeys: String, CodingKey {
            case channelFlowArn = "ChannelFlowArn"
        }
    }

    public struct CreateChannelMembershipRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "channelArn", location: .uri("ChannelArn")),
            AWSMemberEncoding(label: "chimeBearer", location: .header("x-amz-chime-bearer"))
        ]

        /// The ARN of the channel to which you're adding users.
        public let channelArn: String
        /// The AppInstanceUserArn of the user that makes the API call.
        public let chimeBearer: String
        /// The AppInstanceUserArn of the member you want to add to the channel.
        public let memberArn: String
        /// The ID of the SubChannel in the request.  Only required when creating membership in a SubChannel for a moderator in an elastic channel.
        public let subChannelId: String?
        /// The membership type of a user, DEFAULT or HIDDEN. Default members are always returned as part of ListChannelMemberships. Hidden members are only returned if the type filter in ListChannelMemberships equals HIDDEN. Otherwise hidden members are not returned. This is only supported by moderators.
        public let type: ChannelMembershipType

        public init(channelArn: String, chimeBearer: String, memberArn: String, subChannelId: String? = nil, type: ChannelMembershipType) {
            self.channelArn = channelArn
            self.chimeBearer = chimeBearer
            self.memberArn = memberArn
            self.subChannelId = subChannelId
            self.type = type
        }

        public func validate(name: String) throws {
            try self.validate(self.channelArn, name: "channelArn", parent: name, max: 1600)
            try self.validate(self.channelArn, name: "channelArn", parent: name, min: 5)
            try self.validate(self.channelArn, name: "channelArn", parent: name, pattern: "^arn:[a-z0-9-\\.]{1,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[^/].{0,1023}$")
            try self.validate(self.chimeBearer, name: "chimeBearer", parent: name, max: 1600)
            try self.validate(self.chimeBearer, name: "chimeBearer", parent: name, min: 5)
            try self.validate(self.chimeBearer, name: "chimeBearer", parent: name, pattern: "^arn:[a-z0-9-\\.]{1,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[^/].{0,1023}$")
            try self.validate(self.memberArn, name: "memberArn", parent: name, max: 1600)
            try self.validate(self.memberArn, name: "memberArn", parent: name, min: 5)
            try self.validate(self.memberArn, name: "memberArn", parent: name, pattern: "^arn:[a-z0-9-\\.]{1,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[^/].{0,1023}$")
            try self.validate(self.subChannelId, name: "subChannelId", parent: name, max: 128)
            try self.validate(self.subChannelId, name: "subChannelId", parent: name, min: 1)
            try self.validate(self.subChannelId, name: "subChannelId", parent: name, pattern: "^[-_a-zA-Z0-9]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case memberArn = "MemberArn"
            case subChannelId = "SubChannelId"
            case type = "Type"
        }
    }

    public struct CreateChannelMembershipResponse: AWSDecodableShape {
        /// The ARN of the channel.
        public let channelArn: String?
        /// The ARN and metadata of the member being added.
        public let member: Identity?
        /// The ID of the SubChannel in the response.
        public let subChannelId: String?

        public init(channelArn: String? = nil, member: Identity? = nil, subChannelId: String? = nil) {
            self.channelArn = channelArn
            self.member = member
            self.subChannelId = subChannelId
        }

        private enum CodingKeys: String, CodingKey {
            case channelArn = "ChannelArn"
            case member = "Member"
            case subChannelId = "SubChannelId"
        }
    }

    public struct CreateChannelModeratorRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "channelArn", location: .uri("ChannelArn")),
            AWSMemberEncoding(label: "chimeBearer", location: .header("x-amz-chime-bearer"))
        ]

        /// The ARN of the channel.
        public let channelArn: String
        /// The AppInstanceUserArn of the moderator.
        public let channelModeratorArn: String
        /// The AppInstanceUserArn of the user that makes the API call.
        public let chimeBearer: String

        public init(channelArn: String, channelModeratorArn: String, chimeBearer: String) {
            self.channelArn = channelArn
            self.channelModeratorArn = channelModeratorArn
            self.chimeBearer = chimeBearer
        }

        public func validate(name: String) throws {
            try self.validate(self.channelArn, name: "channelArn", parent: name, max: 1600)
            try self.validate(self.channelArn, name: "channelArn", parent: name, min: 5)
            try self.validate(self.channelArn, name: "channelArn", parent: name, pattern: "^arn:[a-z0-9-\\.]{1,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[^/].{0,1023}$")
            try self.validate(self.channelModeratorArn, name: "channelModeratorArn", parent: name, max: 1600)
            try self.validate(self.channelModeratorArn, name: "channelModeratorArn", parent: name, min: 5)
            try self.validate(self.channelModeratorArn, name: "channelModeratorArn", parent: name, pattern: "^arn:[a-z0-9-\\.]{1,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[^/].{0,1023}$")
            try self.validate(self.chimeBearer, name: "chimeBearer", parent: name, max: 1600)
            try self.validate(self.chimeBearer, name: "chimeBearer", parent: name, min: 5)
            try self.validate(self.chimeBearer, name: "chimeBearer", parent: name, pattern: "^arn:[a-z0-9-\\.]{1,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[^/].{0,1023}$")
        }

        private enum CodingKeys: String, CodingKey {
            case channelModeratorArn = "ChannelModeratorArn"
        }
    }

    public struct CreateChannelModeratorResponse: AWSDecodableShape {
        /// The ARN of the channel.
        public let channelArn: String?
        /// The ARNs of the channel and the moderator.
        public let channelModerator: Identity?

        public init(channelArn: String? = nil, channelModerator: Identity? = nil) {
            self.channelArn = channelArn
            self.channelModerator = channelModerator
        }

        private enum CodingKeys: String, CodingKey {
            case channelArn = "ChannelArn"
            case channelModerator = "ChannelModerator"
        }
    }

    public struct CreateChannelRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "chimeBearer", location: .header("x-amz-chime-bearer"))
        ]

        /// The ARN of the channel request.
        public let appInstanceArn: String
        /// The ID of the channel in the request.
        public let channelId: String?
        /// The AppInstanceUserArn of the user that makes the API call.
        public let chimeBearer: String
        /// The client token for the request. An Idempotency token.
        public let clientRequestToken: String
        /// The attributes required to configure and create an elastic channel. An elastic channel can support a maximum of 1-million users, excluding moderators.
        public let elasticChannelConfiguration: ElasticChannelConfiguration?
        /// The ARNs of the channel members in the request.
        public let memberArns: [String]?
        /// The metadata of the creation request. Limited to 1KB and UTF-8.
        public let metadata: String?
        /// The channel mode: UNRESTRICTED or RESTRICTED. Administrators, moderators, and channel members can add themselves and other members to unrestricted channels. Only administrators and moderators can add members to restricted channels.
        public let mode: ChannelMode?
        /// The ARNs of the channel moderators in the request.
        public let moderatorArns: [String]?
        /// The name of the channel.
        public let name: String
        /// The channel's privacy level: PUBLIC or PRIVATE. Private channels aren't discoverable by users outside the channel. Public channels are discoverable by anyone in the AppInstance.
        public let privacy: ChannelPrivacy?
        /// The tags for the creation request.
        public let tags: [Tag]?

        public init(appInstanceArn: String, channelId: String? = nil, chimeBearer: String, clientRequestToken: String = CreateChannelRequest.idempotencyToken(), elasticChannelConfiguration: ElasticChannelConfiguration? = nil, memberArns: [String]? = nil, metadata: String? = nil, mode: ChannelMode? = nil, moderatorArns: [String]? = nil, name: String, privacy: ChannelPrivacy? = nil, tags: [Tag]? = nil) {
            self.appInstanceArn = appInstanceArn
            self.channelId = channelId
            self.chimeBearer = chimeBearer
            self.clientRequestToken = clientRequestToken
            self.elasticChannelConfiguration = elasticChannelConfiguration
            self.memberArns = memberArns
            self.metadata = metadata
            self.mode = mode
            self.moderatorArns = moderatorArns
            self.name = name
            self.privacy = privacy
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.validate(self.appInstanceArn, name: "appInstanceArn", parent: name, max: 1600)
            try self.validate(self.appInstanceArn, name: "appInstanceArn", parent: name, min: 5)
            try self.validate(self.appInstanceArn, name: "appInstanceArn", parent: name, pattern: "^arn:[a-z0-9-\\.]{1,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[^/].{0,1023}$")
            try self.validate(self.channelId, name: "channelId", parent: name, max: 64)
            try self.validate(self.channelId, name: "channelId", parent: name, min: 1)
            try self.validate(self.channelId, name: "channelId", parent: name, pattern: "^[A-Za-z0-9]([A-Za-z0-9\\:\\-\\_\\.\\@]{0,62}[A-Za-z0-9])?$")
            try self.validate(self.chimeBearer, name: "chimeBearer", parent: name, max: 1600)
            try self.validate(self.chimeBearer, name: "chimeBearer", parent: name, min: 5)
            try self.validate(self.chimeBearer, name: "chimeBearer", parent: name, pattern: "^arn:[a-z0-9-\\.]{1,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[^/].{0,1023}$")
            try self.validate(self.clientRequestToken, name: "clientRequestToken", parent: name, max: 64)
            try self.validate(self.clientRequestToken, name: "clientRequestToken", parent: name, min: 2)
            try self.validate(self.clientRequestToken, name: "clientRequestToken", parent: name, pattern: "^[-_a-zA-Z0-9]*$")
            try self.elasticChannelConfiguration?.validate(name: "\(name).elasticChannelConfiguration")
            try self.memberArns?.forEach {
                try validate($0, name: "memberArns[]", parent: name, max: 1600)
                try validate($0, name: "memberArns[]", parent: name, min: 5)
                try validate($0, name: "memberArns[]", parent: name, pattern: "^arn:[a-z0-9-\\.]{1,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[^/].{0,1023}$")
            }
            try self.validate(self.memberArns, name: "memberArns", parent: name, max: 10)
            try self.validate(self.memberArns, name: "memberArns", parent: name, min: 1)
            try self.validate(self.metadata, name: "metadata", parent: name, max: 1024)
            try self.validate(self.metadata, name: "metadata", parent: name, pattern: ".*")
            try self.moderatorArns?.forEach {
                try validate($0, name: "moderatorArns[]", parent: name, max: 1600)
                try validate($0, name: "moderatorArns[]", parent: name, min: 5)
                try validate($0, name: "moderatorArns[]", parent: name, pattern: "^arn:[a-z0-9-\\.]{1,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[^/].{0,1023}$")
            }
            try self.validate(self.moderatorArns, name: "moderatorArns", parent: name, max: 10)
            try self.validate(self.moderatorArns, name: "moderatorArns", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, max: 256)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[\\u0009\\u000A\\u000D\\u0020-\\u007E\\u0085\\u00A0-\\uD7FF\\uE000-\\uFFFD\\u10000-\\u10FFFF]*$")
            try self.tags?.forEach {
                try $0.validate(name: "\(name).tags[]")
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 50)
            try self.validate(self.tags, name: "tags", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case appInstanceArn = "AppInstanceArn"
            case channelId = "ChannelId"
            case clientRequestToken = "ClientRequestToken"
            case elasticChannelConfiguration = "ElasticChannelConfiguration"
            case memberArns = "MemberArns"
            case metadata = "Metadata"
            case mode = "Mode"
            case moderatorArns = "ModeratorArns"
            case name = "Name"
            case privacy = "Privacy"
            case tags = "Tags"
        }
    }

    public struct CreateChannelResponse: AWSDecodableShape {
        /// The ARN of the channel.
        public let channelArn: String?

        public init(channelArn: String? = nil) {
            self.channelArn = channelArn
        }

        private enum CodingKeys: String, CodingKey {
            case channelArn = "ChannelArn"
        }
    }

    public struct DeleteChannelBanRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "channelArn", location: .uri("ChannelArn")),
            AWSMemberEncoding(label: "chimeBearer", location: .header("x-amz-chime-bearer")),
            AWSMemberEncoding(label: "memberArn", location: .uri("MemberArn"))
        ]

        /// The ARN of the channel from which the AppInstanceUser was banned.
        public let channelArn: String
        /// The AppInstanceUserArn of the user that makes the API call.
        public let chimeBearer: String
        /// The ARN of the AppInstanceUser that you want to reinstate.
        public let memberArn: String

        public init(channelArn: String, chimeBearer: String, memberArn: String) {
            self.channelArn = channelArn
            self.chimeBearer = chimeBearer
            self.memberArn = memberArn
        }

        public func validate(name: String) throws {
            try self.validate(self.channelArn, name: "channelArn", parent: name, max: 1600)
            try self.validate(self.channelArn, name: "channelArn", parent: name, min: 5)
            try self.validate(self.channelArn, name: "channelArn", parent: name, pattern: "^arn:[a-z0-9-\\.]{1,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[^/].{0,1023}$")
            try self.validate(self.chimeBearer, name: "chimeBearer", parent: name, max: 1600)
            try self.validate(self.chimeBearer, name: "chimeBearer", parent: name, min: 5)
            try self.validate(self.chimeBearer, name: "chimeBearer", parent: name, pattern: "^arn:[a-z0-9-\\.]{1,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[^/].{0,1023}$")
            try self.validate(self.memberArn, name: "memberArn", parent: name, max: 1600)
            try self.validate(self.memberArn, name: "memberArn", parent: name, min: 5)
            try self.validate(self.memberArn, name: "memberArn", parent: name, pattern: "^arn:[a-z0-9-\\.]{1,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[^/].{0,1023}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteChannelFlowRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "channelFlowArn", location: .uri("ChannelFlowArn"))
        ]

        /// The ARN of the channel flow.
        public let channelFlowArn: String

        public init(channelFlowArn: String) {
            self.channelFlowArn = channelFlowArn
        }

        public func validate(name: String) throws {
            try self.validate(self.channelFlowArn, name: "channelFlowArn", parent: name, max: 1600)
            try self.validate(self.channelFlowArn, name: "channelFlowArn", parent: name, min: 5)
            try self.validate(self.channelFlowArn, name: "channelFlowArn", parent: name, pattern: "^arn:[a-z0-9-\\.]{1,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[^/].{0,1023}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteChannelMembershipRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "channelArn", location: .uri("ChannelArn")),
            AWSMemberEncoding(label: "chimeBearer", location: .header("x-amz-chime-bearer")),
            AWSMemberEncoding(label: "memberArn", location: .uri("MemberArn")),
            AWSMemberEncoding(label: "subChannelId", location: .querystring("sub-channel-id"))
        ]

        /// The ARN of the channel from which you want to remove the user.
        public let channelArn: String
        /// The AppInstanceUserArn of the user that makes the API call.
        public let chimeBearer: String
        /// The AppInstanceUserArn of the member that you're removing from the channel.
        public let memberArn: String
        /// The ID of the SubChannel in the request.  Only for use by moderators.
        public let subChannelId: String?

        public init(channelArn: String, chimeBearer: String, memberArn: String, subChannelId: String? = nil) {
            self.channelArn = channelArn
            self.chimeBearer = chimeBearer
            self.memberArn = memberArn
            self.subChannelId = subChannelId
        }

        public func validate(name: String) throws {
            try self.validate(self.channelArn, name: "channelArn", parent: name, max: 1600)
            try self.validate(self.channelArn, name: "channelArn", parent: name, min: 5)
            try self.validate(self.channelArn, name: "channelArn", parent: name, pattern: "^arn:[a-z0-9-\\.]{1,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[^/].{0,1023}$")
            try self.validate(self.chimeBearer, name: "chimeBearer", parent: name, max: 1600)
            try self.validate(self.chimeBearer, name: "chimeBearer", parent: name, min: 5)
            try self.validate(self.chimeBearer, name: "chimeBearer", parent: name, pattern: "^arn:[a-z0-9-\\.]{1,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[^/].{0,1023}$")
            try self.validate(self.memberArn, name: "memberArn", parent: name, max: 1600)
            try self.validate(self.memberArn, name: "memberArn", parent: name, min: 5)
            try self.validate(self.memberArn, name: "memberArn", parent: name, pattern: "^arn:[a-z0-9-\\.]{1,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[^/].{0,1023}$")
            try self.validate(self.subChannelId, name: "subChannelId", parent: name, max: 128)
            try self.validate(self.subChannelId, name: "subChannelId", parent: name, min: 1)
            try self.validate(self.subChannelId, name: "subChannelId", parent: name, pattern: "^[-_a-zA-Z0-9]*$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteChannelMessageRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "channelArn", location: .uri("ChannelArn")),
            AWSMemberEncoding(label: "chimeBearer", location: .header("x-amz-chime-bearer")),
            AWSMemberEncoding(label: "messageId", location: .uri("MessageId")),
            AWSMemberEncoding(label: "subChannelId", location: .querystring("sub-channel-id"))
        ]

        /// The ARN of the channel.
        public let channelArn: String
        /// The AppInstanceUserArn of the user that makes the API call.
        public let chimeBearer: String
        /// The ID of the message being deleted.
        public let messageId: String
        /// The ID of the SubChannel in the request.  Only required when deleting messages in a SubChannel that the user belongs to.
        public let subChannelId: String?

        public init(channelArn: String, chimeBearer: String, messageId: String, subChannelId: String? = nil) {
            self.channelArn = channelArn
            self.chimeBearer = chimeBearer
            self.messageId = messageId
            self.subChannelId = subChannelId
        }

        public func validate(name: String) throws {
            try self.validate(self.channelArn, name: "channelArn", parent: name, max: 1600)
            try self.validate(self.channelArn, name: "channelArn", parent: name, min: 5)
            try self.validate(self.channelArn, name: "channelArn", parent: name, pattern: "^arn:[a-z0-9-\\.]{1,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[^/].{0,1023}$")
            try self.validate(self.chimeBearer, name: "chimeBearer", parent: name, max: 1600)
            try self.validate(self.chimeBearer, name: "chimeBearer", parent: name, min: 5)
            try self.validate(self.chimeBearer, name: "chimeBearer", parent: name, pattern: "^arn:[a-z0-9-\\.]{1,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[^/].{0,1023}$")
            try self.validate(self.messageId, name: "messageId", parent: name, max: 128)
            try self.validate(self.messageId, name: "messageId", parent: name, min: 1)
            try self.validate(self.messageId, name: "messageId", parent: name, pattern: "^[-_a-zA-Z0-9]*$")
            try self.validate(self.subChannelId, name: "subChannelId", parent: name, max: 128)
            try self.validate(self.subChannelId, name: "subChannelId", parent: name, min: 1)
            try self.validate(self.subChannelId, name: "subChannelId", parent: name, pattern: "^[-_a-zA-Z0-9]*$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteChannelModeratorRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "channelArn", location: .uri("ChannelArn")),
            AWSMemberEncoding(label: "channelModeratorArn", location: .uri("ChannelModeratorArn")),
            AWSMemberEncoding(label: "chimeBearer", location: .header("x-amz-chime-bearer"))
        ]

        /// The ARN of the channel.
        public let channelArn: String
        /// The AppInstanceUserArn of the moderator being deleted.
        public let channelModeratorArn: String
        /// The AppInstanceUserArn of the user that makes the API call.
        public let chimeBearer: String

        public init(channelArn: String, channelModeratorArn: String, chimeBearer: String) {
            self.channelArn = channelArn
            self.channelModeratorArn = channelModeratorArn
            self.chimeBearer = chimeBearer
        }

        public func validate(name: String) throws {
            try self.validate(self.channelArn, name: "channelArn", parent: name, max: 1600)
            try self.validate(self.channelArn, name: "channelArn", parent: name, min: 5)
            try self.validate(self.channelArn, name: "channelArn", parent: name, pattern: "^arn:[a-z0-9-\\.]{1,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[^/].{0,1023}$")
            try self.validate(self.channelModeratorArn, name: "channelModeratorArn", parent: name, max: 1600)
            try self.validate(self.channelModeratorArn, name: "channelModeratorArn", parent: name, min: 5)
            try self.validate(self.channelModeratorArn, name: "channelModeratorArn", parent: name, pattern: "^arn:[a-z0-9-\\.]{1,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[^/].{0,1023}$")
            try self.validate(self.chimeBearer, name: "chimeBearer", parent: name, max: 1600)
            try self.validate(self.chimeBearer, name: "chimeBearer", parent: name, min: 5)
            try self.validate(self.chimeBearer, name: "chimeBearer", parent: name, pattern: "^arn:[a-z0-9-\\.]{1,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[^/].{0,1023}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteChannelRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "channelArn", location: .uri("ChannelArn")),
            AWSMemberEncoding(label: "chimeBearer", location: .header("x-amz-chime-bearer")),
            AWSMemberEncoding(label: "subChannelId", location: .querystring("sub-channel-id"))
        ]

        /// The ARN of the channel being deleted.
        public let channelArn: String
        /// The AppInstanceUserArn of the user that makes the API call.
        public let chimeBearer: String
        /// The ID of the SubChannel in the request.
        public let subChannelId: String?

        public init(channelArn: String, chimeBearer: String, subChannelId: String? = nil) {
            self.channelArn = channelArn
            self.chimeBearer = chimeBearer
            self.subChannelId = subChannelId
        }

        public func validate(name: String) throws {
            try self.validate(self.channelArn, name: "channelArn", parent: name, max: 1600)
            try self.validate(self.channelArn, name: "channelArn", parent: name, min: 5)
            try self.validate(self.channelArn, name: "channelArn", parent: name, pattern: "^arn:[a-z0-9-\\.]{1,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[^/].{0,1023}$")
            try self.validate(self.chimeBearer, name: "chimeBearer", parent: name, max: 1600)
            try self.validate(self.chimeBearer, name: "chimeBearer", parent: name, min: 5)
            try self.validate(self.chimeBearer, name: "chimeBearer", parent: name, pattern: "^arn:[a-z0-9-\\.]{1,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[^/].{0,1023}$")
            try self.validate(self.subChannelId, name: "subChannelId", parent: name, max: 128)
            try self.validate(self.subChannelId, name: "subChannelId", parent: name, min: 1)
            try self.validate(self.subChannelId, name: "subChannelId", parent: name, pattern: "^[-_a-zA-Z0-9]*$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DescribeChannelBanRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "channelArn", location: .uri("ChannelArn")),
            AWSMemberEncoding(label: "chimeBearer", location: .header("x-amz-chime-bearer")),
            AWSMemberEncoding(label: "memberArn", location: .uri("MemberArn"))
        ]

        /// The ARN of the channel from which the user is banned.
        public let channelArn: String
        /// The AppInstanceUserArn of the user that makes the API call.
        public let chimeBearer: String
        /// The AppInstanceUserArn of the member being banned.
        public let memberArn: String

        public init(channelArn: String, chimeBearer: String, memberArn: String) {
            self.channelArn = channelArn
            self.chimeBearer = chimeBearer
            self.memberArn = memberArn
        }

        public func validate(name: String) throws {
            try self.validate(self.channelArn, name: "channelArn", parent: name, max: 1600)
            try self.validate(self.channelArn, name: "channelArn", parent: name, min: 5)
            try self.validate(self.channelArn, name: "channelArn", parent: name, pattern: "^arn:[a-z0-9-\\.]{1,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[^/].{0,1023}$")
            try self.validate(self.chimeBearer, name: "chimeBearer", parent: name, max: 1600)
            try self.validate(self.chimeBearer, name: "chimeBearer", parent: name, min: 5)
            try self.validate(self.chimeBearer, name: "chimeBearer", parent: name, pattern: "^arn:[a-z0-9-\\.]{1,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[^/].{0,1023}$")
            try self.validate(self.memberArn, name: "memberArn", parent: name, max: 1600)
            try self.validate(self.memberArn, name: "memberArn", parent: name, min: 5)
            try self.validate(self.memberArn, name: "memberArn", parent: name, pattern: "^arn:[a-z0-9-\\.]{1,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[^/].{0,1023}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DescribeChannelBanResponse: AWSDecodableShape {
        /// The details of the ban.
        public let channelBan: ChannelBan?

        public init(channelBan: ChannelBan? = nil) {
            self.channelBan = channelBan
        }

        private enum CodingKeys: String, CodingKey {
            case channelBan = "ChannelBan"
        }
    }

    public struct DescribeChannelFlowRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "channelFlowArn", location: .uri("ChannelFlowArn"))
        ]

        /// The ARN of the channel flow.
        public let channelFlowArn: String

        public init(channelFlowArn: String) {
            self.channelFlowArn = channelFlowArn
        }

        public func validate(name: String) throws {
            try self.validate(self.channelFlowArn, name: "channelFlowArn", parent: name, max: 1600)
            try self.validate(self.channelFlowArn, name: "channelFlowArn", parent: name, min: 5)
            try self.validate(self.channelFlowArn, name: "channelFlowArn", parent: name, pattern: "^arn:[a-z0-9-\\.]{1,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[^/].{0,1023}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DescribeChannelFlowResponse: AWSDecodableShape {
        /// The channel flow details.
        public let channelFlow: ChannelFlow?

        public init(channelFlow: ChannelFlow? = nil) {
            self.channelFlow = channelFlow
        }

        private enum CodingKeys: String, CodingKey {
            case channelFlow = "ChannelFlow"
        }
    }

    public struct DescribeChannelMembershipForAppInstanceUserRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "appInstanceUserArn", location: .querystring("app-instance-user-arn")),
            AWSMemberEncoding(label: "channelArn", location: .uri("ChannelArn")),
            AWSMemberEncoding(label: "chimeBearer", location: .header("x-amz-chime-bearer"))
        ]

        /// The ARN of the user in a channel.
        public let appInstanceUserArn: String
        /// The ARN of the channel to which the user belongs.
        public let channelArn: String
        /// The AppInstanceUserArn of the user that makes the API call.
        public let chimeBearer: String

        public init(appInstanceUserArn: String, channelArn: String, chimeBearer: String) {
            self.appInstanceUserArn = appInstanceUserArn
            self.channelArn = channelArn
            self.chimeBearer = chimeBearer
        }

        public func validate(name: String) throws {
            try self.validate(self.appInstanceUserArn, name: "appInstanceUserArn", parent: name, max: 1600)
            try self.validate(self.appInstanceUserArn, name: "appInstanceUserArn", parent: name, min: 5)
            try self.validate(self.appInstanceUserArn, name: "appInstanceUserArn", parent: name, pattern: "^arn:[a-z0-9-\\.]{1,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[^/].{0,1023}$")
            try self.validate(self.channelArn, name: "channelArn", parent: name, max: 1600)
            try self.validate(self.channelArn, name: "channelArn", parent: name, min: 5)
            try self.validate(self.channelArn, name: "channelArn", parent: name, pattern: "^arn:[a-z0-9-\\.]{1,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[^/].{0,1023}$")
            try self.validate(self.chimeBearer, name: "chimeBearer", parent: name, max: 1600)
            try self.validate(self.chimeBearer, name: "chimeBearer", parent: name, min: 5)
            try self.validate(self.chimeBearer, name: "chimeBearer", parent: name, pattern: "^arn:[a-z0-9-\\.]{1,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[^/].{0,1023}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DescribeChannelMembershipForAppInstanceUserResponse: AWSDecodableShape {
        /// The channel to which a user belongs.
        public let channelMembership: ChannelMembershipForAppInstanceUserSummary?

        public init(channelMembership: ChannelMembershipForAppInstanceUserSummary? = nil) {
            self.channelMembership = channelMembership
        }

        private enum CodingKeys: String, CodingKey {
            case channelMembership = "ChannelMembership"
        }
    }

    public struct DescribeChannelMembershipRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "channelArn", location: .uri("ChannelArn")),
            AWSMemberEncoding(label: "chimeBearer", location: .header("x-amz-chime-bearer")),
            AWSMemberEncoding(label: "memberArn", location: .uri("MemberArn")),
            AWSMemberEncoding(label: "subChannelId", location: .querystring("sub-channel-id"))
        ]

        /// The ARN of the channel.
        public let channelArn: String
        /// The AppInstanceUserArn of the user that makes the API call.
        public let chimeBearer: String
        /// The AppInstanceUserArn of the member.
        public let memberArn: String
        /// The ID of the SubChannel in the request. The response contains an ElasticChannelConfiguration object.  Only required to get a users SubChannel membership details.
        public let subChannelId: String?

        public init(channelArn: String, chimeBearer: String, memberArn: String, subChannelId: String? = nil) {
            self.channelArn = channelArn
            self.chimeBearer = chimeBearer
            self.memberArn = memberArn
            self.subChannelId = subChannelId
        }

        public func validate(name: String) throws {
            try self.validate(self.channelArn, name: "channelArn", parent: name, max: 1600)
            try self.validate(self.channelArn, name: "channelArn", parent: name, min: 5)
            try self.validate(self.channelArn, name: "channelArn", parent: name, pattern: "^arn:[a-z0-9-\\.]{1,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[^/].{0,1023}$")
            try self.validate(self.chimeBearer, name: "chimeBearer", parent: name, max: 1600)
            try self.validate(self.chimeBearer, name: "chimeBearer", parent: name, min: 5)
            try self.validate(self.chimeBearer, name: "chimeBearer", parent: name, pattern: "^arn:[a-z0-9-\\.]{1,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[^/].{0,1023}$")
            try self.validate(self.memberArn, name: "memberArn", parent: name, max: 1600)
            try self.validate(self.memberArn, name: "memberArn", parent: name, min: 5)
            try self.validate(self.memberArn, name: "memberArn", parent: name, pattern: "^arn:[a-z0-9-\\.]{1,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[^/].{0,1023}$")
            try self.validate(self.subChannelId, name: "subChannelId", parent: name, max: 128)
            try self.validate(self.subChannelId, name: "subChannelId", parent: name, min: 1)
            try self.validate(self.subChannelId, name: "subChannelId", parent: name, pattern: "^[-_a-zA-Z0-9]*$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DescribeChannelMembershipResponse: AWSDecodableShape {
        /// The details of the membership.
        public let channelMembership: ChannelMembership?

        public init(channelMembership: ChannelMembership? = nil) {
            self.channelMembership = channelMembership
        }

        private enum CodingKeys: String, CodingKey {
            case channelMembership = "ChannelMembership"
        }
    }

    public struct DescribeChannelModeratedByAppInstanceUserRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "appInstanceUserArn", location: .querystring("app-instance-user-arn")),
            AWSMemberEncoding(label: "channelArn", location: .uri("ChannelArn")),
            AWSMemberEncoding(label: "chimeBearer", location: .header("x-amz-chime-bearer"))
        ]

        /// The ARN of the AppInstanceUser in the moderated channel.
        public let appInstanceUserArn: String
        /// The ARN of the moderated channel.
        public let channelArn: String
        /// The AppInstanceUserArn of the user that makes the API call.
        public let chimeBearer: String

        public init(appInstanceUserArn: String, channelArn: String, chimeBearer: String) {
            self.appInstanceUserArn = appInstanceUserArn
            self.channelArn = channelArn
            self.chimeBearer = chimeBearer
        }

        public func validate(name: String) throws {
            try self.validate(self.appInstanceUserArn, name: "appInstanceUserArn", parent: name, max: 1600)
            try self.validate(self.appInstanceUserArn, name: "appInstanceUserArn", parent: name, min: 5)
            try self.validate(self.appInstanceUserArn, name: "appInstanceUserArn", parent: name, pattern: "^arn:[a-z0-9-\\.]{1,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[^/].{0,1023}$")
            try self.validate(self.channelArn, name: "channelArn", parent: name, max: 1600)
            try self.validate(self.channelArn, name: "channelArn", parent: name, min: 5)
            try self.validate(self.channelArn, name: "channelArn", parent: name, pattern: "^arn:[a-z0-9-\\.]{1,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[^/].{0,1023}$")
            try self.validate(self.chimeBearer, name: "chimeBearer", parent: name, max: 1600)
            try self.validate(self.chimeBearer, name: "chimeBearer", parent: name, min: 5)
            try self.validate(self.chimeBearer, name: "chimeBearer", parent: name, pattern: "^arn:[a-z0-9-\\.]{1,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[^/].{0,1023}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DescribeChannelModeratedByAppInstanceUserResponse: AWSDecodableShape {
        /// The moderated channel.
        public let channel: ChannelModeratedByAppInstanceUserSummary?

        public init(channel: ChannelModeratedByAppInstanceUserSummary? = nil) {
            self.channel = channel
        }

        private enum CodingKeys: String, CodingKey {
            case channel = "Channel"
        }
    }

    public struct DescribeChannelModeratorRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "channelArn", location: .uri("ChannelArn")),
            AWSMemberEncoding(label: "channelModeratorArn", location: .uri("ChannelModeratorArn")),
            AWSMemberEncoding(label: "chimeBearer", location: .header("x-amz-chime-bearer"))
        ]

        /// The ARN of the channel.
        public let channelArn: String
        /// The AppInstanceUserArn of the channel moderator.
        public let channelModeratorArn: String
        /// The AppInstanceUserArn of the user that makes the API call.
        public let chimeBearer: String

        public init(channelArn: String, channelModeratorArn: String, chimeBearer: String) {
            self.channelArn = channelArn
            self.channelModeratorArn = channelModeratorArn
            self.chimeBearer = chimeBearer
        }

        public func validate(name: String) throws {
            try self.validate(self.channelArn, name: "channelArn", parent: name, max: 1600)
            try self.validate(self.channelArn, name: "channelArn", parent: name, min: 5)
            try self.validate(self.channelArn, name: "channelArn", parent: name, pattern: "^arn:[a-z0-9-\\.]{1,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[^/].{0,1023}$")
            try self.validate(self.channelModeratorArn, name: "channelModeratorArn", parent: name, max: 1600)
            try self.validate(self.channelModeratorArn, name: "channelModeratorArn", parent: name, min: 5)
            try self.validate(self.channelModeratorArn, name: "channelModeratorArn", parent: name, pattern: "^arn:[a-z0-9-\\.]{1,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[^/].{0,1023}$")
            try self.validate(self.chimeBearer, name: "chimeBearer", parent: name, max: 1600)
            try self.validate(self.chimeBearer, name: "chimeBearer", parent: name, min: 5)
            try self.validate(self.chimeBearer, name: "chimeBearer", parent: name, pattern: "^arn:[a-z0-9-\\.]{1,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[^/].{0,1023}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DescribeChannelModeratorResponse: AWSDecodableShape {
        /// The details of the channel moderator.
        public let channelModerator: ChannelModerator?

        public init(channelModerator: ChannelModerator? = nil) {
            self.channelModerator = channelModerator
        }

        private enum CodingKeys: String, CodingKey {
            case channelModerator = "ChannelModerator"
        }
    }

    public struct DescribeChannelRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "channelArn", location: .uri("ChannelArn")),
            AWSMemberEncoding(label: "chimeBearer", location: .header("x-amz-chime-bearer"))
        ]

        /// The ARN of the channel.
        public let channelArn: String
        /// The AppInstanceUserArn of the user that makes the API call.
        public let chimeBearer: String

        public init(channelArn: String, chimeBearer: String) {
            self.channelArn = channelArn
            self.chimeBearer = chimeBearer
        }

        public func validate(name: String) throws {
            try self.validate(self.channelArn, name: "channelArn", parent: name, max: 1600)
            try self.validate(self.channelArn, name: "channelArn", parent: name, min: 5)
            try self.validate(self.channelArn, name: "channelArn", parent: name, pattern: "^arn:[a-z0-9-\\.]{1,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[^/].{0,1023}$")
            try self.validate(self.chimeBearer, name: "chimeBearer", parent: name, max: 1600)
            try self.validate(self.chimeBearer, name: "chimeBearer", parent: name, min: 5)
            try self.validate(self.chimeBearer, name: "chimeBearer", parent: name, pattern: "^arn:[a-z0-9-\\.]{1,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[^/].{0,1023}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DescribeChannelResponse: AWSDecodableShape {
        /// The channel details.
        public let channel: Channel?

        public init(channel: Channel? = nil) {
            self.channel = channel
        }

        private enum CodingKeys: String, CodingKey {
            case channel = "Channel"
        }
    }

    public struct DisassociateChannelFlowRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "channelArn", location: .uri("ChannelArn")),
            AWSMemberEncoding(label: "channelFlowArn", location: .uri("ChannelFlowArn")),
            AWSMemberEncoding(label: "chimeBearer", location: .header("x-amz-chime-bearer"))
        ]

        /// The ARN of the channel.
        public let channelArn: String
        /// The ARN of the channel flow.
        public let channelFlowArn: String
        /// The AppInstanceUserArn of the user making the API call.
        public let chimeBearer: String

        public init(channelArn: String, channelFlowArn: String, chimeBearer: String) {
            self.channelArn = channelArn
            self.channelFlowArn = channelFlowArn
            self.chimeBearer = chimeBearer
        }

        public func validate(name: String) throws {
            try self.validate(self.channelArn, name: "channelArn", parent: name, max: 1600)
            try self.validate(self.channelArn, name: "channelArn", parent: name, min: 5)
            try self.validate(self.channelArn, name: "channelArn", parent: name, pattern: "^arn:[a-z0-9-\\.]{1,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[^/].{0,1023}$")
            try self.validate(self.channelFlowArn, name: "channelFlowArn", parent: name, max: 1600)
            try self.validate(self.channelFlowArn, name: "channelFlowArn", parent: name, min: 5)
            try self.validate(self.channelFlowArn, name: "channelFlowArn", parent: name, pattern: "^arn:[a-z0-9-\\.]{1,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[^/].{0,1023}$")
            try self.validate(self.chimeBearer, name: "chimeBearer", parent: name, max: 1600)
            try self.validate(self.chimeBearer, name: "chimeBearer", parent: name, min: 5)
            try self.validate(self.chimeBearer, name: "chimeBearer", parent: name, pattern: "^arn:[a-z0-9-\\.]{1,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[^/].{0,1023}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ElasticChannelConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The maximum number of SubChannels that you want to allow in the elastic channel.
        public let maximumSubChannels: Int
        /// The minimum allowed percentage of TargetMembershipsPerSubChannel users. Ceil of the calculated value is used in balancing members among SubChannels of the elastic channel.
        public let minimumMembershipPercentage: Int
        /// The maximum number of members allowed in a SubChannel.
        public let targetMembershipsPerSubChannel: Int

        public init(maximumSubChannels: Int, minimumMembershipPercentage: Int, targetMembershipsPerSubChannel: Int) {
            self.maximumSubChannels = maximumSubChannels
            self.minimumMembershipPercentage = minimumMembershipPercentage
            self.targetMembershipsPerSubChannel = targetMembershipsPerSubChannel
        }

        public func validate(name: String) throws {
            try self.validate(self.maximumSubChannels, name: "maximumSubChannels", parent: name, min: 2)
            try self.validate(self.minimumMembershipPercentage, name: "minimumMembershipPercentage", parent: name, max: 40)
            try self.validate(self.minimumMembershipPercentage, name: "minimumMembershipPercentage", parent: name, min: 1)
            try self.validate(self.targetMembershipsPerSubChannel, name: "targetMembershipsPerSubChannel", parent: name, min: 2)
        }

        private enum CodingKeys: String, CodingKey {
            case maximumSubChannels = "MaximumSubChannels"
            case minimumMembershipPercentage = "MinimumMembershipPercentage"
            case targetMembershipsPerSubChannel = "TargetMembershipsPerSubChannel"
        }
    }

    public struct GetChannelMembershipPreferencesRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "channelArn", location: .uri("ChannelArn")),
            AWSMemberEncoding(label: "chimeBearer", location: .header("x-amz-chime-bearer")),
            AWSMemberEncoding(label: "memberArn", location: .uri("MemberArn"))
        ]

        /// The ARN of the channel.
        public let channelArn: String
        /// The AppInstanceUserARN of the user making the API call.
        public let chimeBearer: String
        /// The AppInstanceUserArn of the member retrieving the preferences.
        public let memberArn: String

        public init(channelArn: String, chimeBearer: String, memberArn: String) {
            self.channelArn = channelArn
            self.chimeBearer = chimeBearer
            self.memberArn = memberArn
        }

        public func validate(name: String) throws {
            try self.validate(self.channelArn, name: "channelArn", parent: name, max: 1600)
            try self.validate(self.channelArn, name: "channelArn", parent: name, min: 5)
            try self.validate(self.channelArn, name: "channelArn", parent: name, pattern: "^arn:[a-z0-9-\\.]{1,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[^/].{0,1023}$")
            try self.validate(self.chimeBearer, name: "chimeBearer", parent: name, max: 1600)
            try self.validate(self.chimeBearer, name: "chimeBearer", parent: name, min: 5)
            try self.validate(self.chimeBearer, name: "chimeBearer", parent: name, pattern: "^arn:[a-z0-9-\\.]{1,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[^/].{0,1023}$")
            try self.validate(self.memberArn, name: "memberArn", parent: name, max: 1600)
            try self.validate(self.memberArn, name: "memberArn", parent: name, min: 5)
            try self.validate(self.memberArn, name: "memberArn", parent: name, pattern: "^arn:[a-z0-9-\\.]{1,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[^/].{0,1023}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetChannelMembershipPreferencesResponse: AWSDecodableShape {
        /// The ARN of the channel.
        public let channelArn: String?
        /// The details of a user.
        public let member: Identity?
        /// The channel membership preferences for an AppInstanceUser .
        public let preferences: ChannelMembershipPreferences?

        public init(channelArn: String? = nil, member: Identity? = nil, preferences: ChannelMembershipPreferences? = nil) {
            self.channelArn = channelArn
            self.member = member
            self.preferences = preferences
        }

        private enum CodingKeys: String, CodingKey {
            case channelArn = "ChannelArn"
            case member = "Member"
            case preferences = "Preferences"
        }
    }

    public struct GetChannelMessageRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "channelArn", location: .uri("ChannelArn")),
            AWSMemberEncoding(label: "chimeBearer", location: .header("x-amz-chime-bearer")),
            AWSMemberEncoding(label: "messageId", location: .uri("MessageId")),
            AWSMemberEncoding(label: "subChannelId", location: .querystring("sub-channel-id"))
        ]

        /// The ARN of the channel.
        public let channelArn: String
        /// The AppInstanceUserArn of the user that makes the API call.
        public let chimeBearer: String
        /// The ID of the message.
        public let messageId: String
        /// The ID of the SubChannel in the request.  Only required when getting messages in a SubChannel that the user belongs to.
        public let subChannelId: String?

        public init(channelArn: String, chimeBearer: String, messageId: String, subChannelId: String? = nil) {
            self.channelArn = channelArn
            self.chimeBearer = chimeBearer
            self.messageId = messageId
            self.subChannelId = subChannelId
        }

        public func validate(name: String) throws {
            try self.validate(self.channelArn, name: "channelArn", parent: name, max: 1600)
            try self.validate(self.channelArn, name: "channelArn", parent: name, min: 5)
            try self.validate(self.channelArn, name: "channelArn", parent: name, pattern: "^arn:[a-z0-9-\\.]{1,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[^/].{0,1023}$")
            try self.validate(self.chimeBearer, name: "chimeBearer", parent: name, max: 1600)
            try self.validate(self.chimeBearer, name: "chimeBearer", parent: name, min: 5)
            try self.validate(self.chimeBearer, name: "chimeBearer", parent: name, pattern: "^arn:[a-z0-9-\\.]{1,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[^/].{0,1023}$")
            try self.validate(self.messageId, name: "messageId", parent: name, max: 128)
            try self.validate(self.messageId, name: "messageId", parent: name, min: 1)
            try self.validate(self.messageId, name: "messageId", parent: name, pattern: "^[-_a-zA-Z0-9]*$")
            try self.validate(self.subChannelId, name: "subChannelId", parent: name, max: 128)
            try self.validate(self.subChannelId, name: "subChannelId", parent: name, min: 1)
            try self.validate(self.subChannelId, name: "subChannelId", parent: name, pattern: "^[-_a-zA-Z0-9]*$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetChannelMessageResponse: AWSDecodableShape {
        /// The details of and content in the message.
        public let channelMessage: ChannelMessage?

        public init(channelMessage: ChannelMessage? = nil) {
            self.channelMessage = channelMessage
        }

        private enum CodingKeys: String, CodingKey {
            case channelMessage = "ChannelMessage"
        }
    }

    public struct GetChannelMessageStatusRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "channelArn", location: .uri("ChannelArn")),
            AWSMemberEncoding(label: "chimeBearer", location: .header("x-amz-chime-bearer")),
            AWSMemberEncoding(label: "messageId", location: .uri("MessageId")),
            AWSMemberEncoding(label: "subChannelId", location: .querystring("sub-channel-id"))
        ]

        /// The ARN of the channel
        public let channelArn: String
        /// The AppInstanceUserArn of the user making the API call.
        public let chimeBearer: String
        /// The ID of the message.
        public let messageId: String
        /// The ID of the SubChannel in the request.  Only required when getting message status in a SubChannel that the user belongs to.
        public let subChannelId: String?

        public init(channelArn: String, chimeBearer: String, messageId: String, subChannelId: String? = nil) {
            self.channelArn = channelArn
            self.chimeBearer = chimeBearer
            self.messageId = messageId
            self.subChannelId = subChannelId
        }

        public func validate(name: String) throws {
            try self.validate(self.channelArn, name: "channelArn", parent: name, max: 1600)
            try self.validate(self.channelArn, name: "channelArn", parent: name, min: 5)
            try self.validate(self.channelArn, name: "channelArn", parent: name, pattern: "^arn:[a-z0-9-\\.]{1,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[^/].{0,1023}$")
            try self.validate(self.chimeBearer, name: "chimeBearer", parent: name, max: 1600)
            try self.validate(self.chimeBearer, name: "chimeBearer", parent: name, min: 5)
            try self.validate(self.chimeBearer, name: "chimeBearer", parent: name, pattern: "^arn:[a-z0-9-\\.]{1,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[^/].{0,1023}$")
            try self.validate(self.messageId, name: "messageId", parent: name, max: 128)
            try self.validate(self.messageId, name: "messageId", parent: name, min: 1)
            try self.validate(self.messageId, name: "messageId", parent: name, pattern: "^[-_a-zA-Z0-9]*$")
            try self.validate(self.subChannelId, name: "subChannelId", parent: name, max: 128)
            try self.validate(self.subChannelId, name: "subChannelId", parent: name, min: 1)
            try self.validate(self.subChannelId, name: "subChannelId", parent: name, pattern: "^[-_a-zA-Z0-9]*$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetChannelMessageStatusResponse: AWSDecodableShape {
        /// The message status and details.
        public let status: ChannelMessageStatusStructure?

        public init(status: ChannelMessageStatusStructure? = nil) {
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case status = "Status"
        }
    }

    public struct GetMessagingSessionEndpointRequest: AWSEncodableShape {
        public init() {}
    }

    public struct GetMessagingSessionEndpointResponse: AWSDecodableShape {
        /// The endpoint returned in the response.
        public let endpoint: MessagingSessionEndpoint?

        public init(endpoint: MessagingSessionEndpoint? = nil) {
            self.endpoint = endpoint
        }

        private enum CodingKeys: String, CodingKey {
            case endpoint = "Endpoint"
        }
    }

    public struct Identity: AWSDecodableShape {
        /// The ARN in an Identity.
        public let arn: String?
        /// The name in an Identity.
        public let name: String?

        public init(arn: String? = nil, name: String? = nil) {
            self.arn = arn
            self.name = name
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case name = "Name"
        }
    }

    public struct LambdaConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// Controls how the Lambda function is invoked.
        public let invocationType: InvocationType
        /// The ARN of the Lambda message processing function.
        public let resourceArn: String

        public init(invocationType: InvocationType, resourceArn: String) {
            self.invocationType = invocationType
            self.resourceArn = resourceArn
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, max: 2048)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, min: 15)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, pattern: "^arn:aws:lambda:[a-z]{2}-[a-z]+-\\d{1}:\\d{12}:function:[a-zA-Z0-9\\-_\\.]+(:(\\$LATEST|[a-zA-Z0-9\\-_]+))?$")
        }

        private enum CodingKeys: String, CodingKey {
            case invocationType = "InvocationType"
            case resourceArn = "ResourceArn"
        }
    }

    public struct ListChannelBansRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "channelArn", location: .uri("ChannelArn")),
            AWSMemberEncoding(label: "chimeBearer", location: .header("x-amz-chime-bearer")),
            AWSMemberEncoding(label: "maxResults", location: .querystring("max-results")),
            AWSMemberEncoding(label: "nextToken", location: .querystring("next-token"))
        ]

        /// The ARN of the channel.
        public let channelArn: String
        /// The AppInstanceUserArn of the user that makes the API call.
        public let chimeBearer: String
        /// The maximum number of bans that you want returned.
        public let maxResults: Int?
        /// The token passed by previous API calls until all requested bans are returned.
        public let nextToken: String?

        public init(channelArn: String, chimeBearer: String, maxResults: Int? = nil, nextToken: String? = nil) {
            self.channelArn = channelArn
            self.chimeBearer = chimeBearer
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.validate(self.channelArn, name: "channelArn", parent: name, max: 1600)
            try self.validate(self.channelArn, name: "channelArn", parent: name, min: 5)
            try self.validate(self.channelArn, name: "channelArn", parent: name, pattern: "^arn:[a-z0-9-\\.]{1,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[^/].{0,1023}$")
            try self.validate(self.chimeBearer, name: "chimeBearer", parent: name, max: 1600)
            try self.validate(self.chimeBearer, name: "chimeBearer", parent: name, min: 5)
            try self.validate(self.chimeBearer, name: "chimeBearer", parent: name, pattern: "^arn:[a-z0-9-\\.]{1,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[^/].{0,1023}$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 50)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 2048)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: ".*")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListChannelBansResponse: AWSDecodableShape {
        /// The ARN of the channel.
        public let channelArn: String?
        /// The information for each requested ban.
        public let channelBans: [ChannelBanSummary]?
        /// The token passed by previous API calls until all requested bans are returned.
        public let nextToken: String?

        public init(channelArn: String? = nil, channelBans: [ChannelBanSummary]? = nil, nextToken: String? = nil) {
            self.channelArn = channelArn
            self.channelBans = channelBans
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case channelArn = "ChannelArn"
            case channelBans = "ChannelBans"
            case nextToken = "NextToken"
        }
    }

    public struct ListChannelFlowsRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "appInstanceArn", location: .querystring("app-instance-arn")),
            AWSMemberEncoding(label: "maxResults", location: .querystring("max-results")),
            AWSMemberEncoding(label: "nextToken", location: .querystring("next-token"))
        ]

        /// The ARN of the app instance.
        public let appInstanceArn: String
        /// The maximum number of channel flows that you want to return.
        public let maxResults: Int?
        /// The token passed by previous API calls until all requested channel flows are returned.
        public let nextToken: String?

        public init(appInstanceArn: String, maxResults: Int? = nil, nextToken: String? = nil) {
            self.appInstanceArn = appInstanceArn
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.validate(self.appInstanceArn, name: "appInstanceArn", parent: name, max: 1600)
            try self.validate(self.appInstanceArn, name: "appInstanceArn", parent: name, min: 5)
            try self.validate(self.appInstanceArn, name: "appInstanceArn", parent: name, pattern: "^arn:[a-z0-9-\\.]{1,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[^/].{0,1023}$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 50)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 2048)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: ".*")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListChannelFlowsResponse: AWSDecodableShape {
        /// The information about each channel flow.
        public let channelFlows: [ChannelFlowSummary]?
        /// The token passed by previous API calls until all requested channels are returned.
        public let nextToken: String?

        public init(channelFlows: [ChannelFlowSummary]? = nil, nextToken: String? = nil) {
            self.channelFlows = channelFlows
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case channelFlows = "ChannelFlows"
            case nextToken = "NextToken"
        }
    }

    public struct ListChannelMembershipsForAppInstanceUserRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "appInstanceUserArn", location: .querystring("app-instance-user-arn")),
            AWSMemberEncoding(label: "chimeBearer", location: .header("x-amz-chime-bearer")),
            AWSMemberEncoding(label: "maxResults", location: .querystring("max-results")),
            AWSMemberEncoding(label: "nextToken", location: .querystring("next-token"))
        ]

        /// The ARN of the AppInstanceUsers
        public let appInstanceUserArn: String?
        /// The AppInstanceUserArn of the user that makes the API call.
        public let chimeBearer: String
        /// The maximum number of users that you want returned.
        public let maxResults: Int?
        /// The token returned from previous API requests until the number of channel memberships is reached.
        public let nextToken: String?

        public init(appInstanceUserArn: String? = nil, chimeBearer: String, maxResults: Int? = nil, nextToken: String? = nil) {
            self.appInstanceUserArn = appInstanceUserArn
            self.chimeBearer = chimeBearer
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.validate(self.appInstanceUserArn, name: "appInstanceUserArn", parent: name, max: 1600)
            try self.validate(self.appInstanceUserArn, name: "appInstanceUserArn", parent: name, min: 5)
            try self.validate(self.appInstanceUserArn, name: "appInstanceUserArn", parent: name, pattern: "^arn:[a-z0-9-\\.]{1,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[^/].{0,1023}$")
            try self.validate(self.chimeBearer, name: "chimeBearer", parent: name, max: 1600)
            try self.validate(self.chimeBearer, name: "chimeBearer", parent: name, min: 5)
            try self.validate(self.chimeBearer, name: "chimeBearer", parent: name, pattern: "^arn:[a-z0-9-\\.]{1,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[^/].{0,1023}$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 50)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 2048)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: ".*")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListChannelMembershipsForAppInstanceUserResponse: AWSDecodableShape {
        /// The information for the requested channel memberships.
        public let channelMemberships: [ChannelMembershipForAppInstanceUserSummary]?
        /// The token passed by previous API calls until all requested users are returned.
        public let nextToken: String?

        public init(channelMemberships: [ChannelMembershipForAppInstanceUserSummary]? = nil, nextToken: String? = nil) {
            self.channelMemberships = channelMemberships
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case channelMemberships = "ChannelMemberships"
            case nextToken = "NextToken"
        }
    }

    public struct ListChannelMembershipsRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "channelArn", location: .uri("ChannelArn")),
            AWSMemberEncoding(label: "chimeBearer", location: .header("x-amz-chime-bearer")),
            AWSMemberEncoding(label: "maxResults", location: .querystring("max-results")),
            AWSMemberEncoding(label: "nextToken", location: .querystring("next-token")),
            AWSMemberEncoding(label: "subChannelId", location: .querystring("sub-channel-id")),
            AWSMemberEncoding(label: "type", location: .querystring("type"))
        ]

        /// The maximum number of channel memberships that you want returned.
        public let channelArn: String
        /// The AppInstanceUserArn of the user that makes the API call.
        public let chimeBearer: String
        /// The maximum number of channel memberships that you want returned.
        public let maxResults: Int?
        /// The token passed by previous API calls until all requested channel memberships are returned.
        public let nextToken: String?
        /// The ID of the SubChannel in the request.  Only required when listing a user's memberships in a particular sub-channel of an elastic channel.
        public let subChannelId: String?
        /// The membership type of a user, DEFAULT or HIDDEN. Default members are returned as part of ListChannelMemberships if no type is specified. Hidden members are only returned if the type filter in ListChannelMemberships equals HIDDEN.
        public let type: ChannelMembershipType?

        public init(channelArn: String, chimeBearer: String, maxResults: Int? = nil, nextToken: String? = nil, subChannelId: String? = nil, type: ChannelMembershipType? = nil) {
            self.channelArn = channelArn
            self.chimeBearer = chimeBearer
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.subChannelId = subChannelId
            self.type = type
        }

        public func validate(name: String) throws {
            try self.validate(self.channelArn, name: "channelArn", parent: name, max: 1600)
            try self.validate(self.channelArn, name: "channelArn", parent: name, min: 5)
            try self.validate(self.channelArn, name: "channelArn", parent: name, pattern: "^arn:[a-z0-9-\\.]{1,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[^/].{0,1023}$")
            try self.validate(self.chimeBearer, name: "chimeBearer", parent: name, max: 1600)
            try self.validate(self.chimeBearer, name: "chimeBearer", parent: name, min: 5)
            try self.validate(self.chimeBearer, name: "chimeBearer", parent: name, pattern: "^arn:[a-z0-9-\\.]{1,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[^/].{0,1023}$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 50)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 2048)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: ".*")
            try self.validate(self.subChannelId, name: "subChannelId", parent: name, max: 128)
            try self.validate(self.subChannelId, name: "subChannelId", parent: name, min: 1)
            try self.validate(self.subChannelId, name: "subChannelId", parent: name, pattern: "^[-_a-zA-Z0-9]*$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListChannelMembershipsResponse: AWSDecodableShape {
        /// The ARN of the channel.
        public let channelArn: String?
        /// The information for the requested channel memberships.
        public let channelMemberships: [ChannelMembershipSummary]?
        /// The token passed by previous API calls until all requested channel memberships are returned.
        public let nextToken: String?

        public init(channelArn: String? = nil, channelMemberships: [ChannelMembershipSummary]? = nil, nextToken: String? = nil) {
            self.channelArn = channelArn
            self.channelMemberships = channelMemberships
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case channelArn = "ChannelArn"
            case channelMemberships = "ChannelMemberships"
            case nextToken = "NextToken"
        }
    }

    public struct ListChannelMessagesRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "channelArn", location: .uri("ChannelArn")),
            AWSMemberEncoding(label: "chimeBearer", location: .header("x-amz-chime-bearer")),
            AWSMemberEncoding(label: "maxResults", location: .querystring("max-results")),
            AWSMemberEncoding(label: "nextToken", location: .querystring("next-token")),
            AWSMemberEncoding(label: "notAfter", location: .querystring("not-after")),
            AWSMemberEncoding(label: "notBefore", location: .querystring("not-before")),
            AWSMemberEncoding(label: "sortOrder", location: .querystring("sort-order")),
            AWSMemberEncoding(label: "subChannelId", location: .querystring("sub-channel-id"))
        ]

        /// The ARN of the channel.
        public let channelArn: String
        /// The AppInstanceUserArn of the user that makes the API call.
        public let chimeBearer: String
        /// The maximum number of messages that you want returned.
        public let maxResults: Int?
        /// The token passed by previous API calls until all requested messages are returned.
        public let nextToken: String?
        /// The final or ending time stamp for your requested messages.
        public let notAfter: Date?
        /// The initial or starting time stamp for your requested messages.
        public let notBefore: Date?
        /// The order in which you want messages sorted. Default is Descending, based on time created.
        public let sortOrder: SortOrder?
        /// The ID of the SubChannel in the request.  Only required when listing the messages in a SubChannel that the user belongs to.
        public let subChannelId: String?

        public init(channelArn: String, chimeBearer: String, maxResults: Int? = nil, nextToken: String? = nil, notAfter: Date? = nil, notBefore: Date? = nil, sortOrder: SortOrder? = nil, subChannelId: String? = nil) {
            self.channelArn = channelArn
            self.chimeBearer = chimeBearer
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.notAfter = notAfter
            self.notBefore = notBefore
            self.sortOrder = sortOrder
            self.subChannelId = subChannelId
        }

        public func validate(name: String) throws {
            try self.validate(self.channelArn, name: "channelArn", parent: name, max: 1600)
            try self.validate(self.channelArn, name: "channelArn", parent: name, min: 5)
            try self.validate(self.channelArn, name: "channelArn", parent: name, pattern: "^arn:[a-z0-9-\\.]{1,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[^/].{0,1023}$")
            try self.validate(self.chimeBearer, name: "chimeBearer", parent: name, max: 1600)
            try self.validate(self.chimeBearer, name: "chimeBearer", parent: name, min: 5)
            try self.validate(self.chimeBearer, name: "chimeBearer", parent: name, pattern: "^arn:[a-z0-9-\\.]{1,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[^/].{0,1023}$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 50)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 2048)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: ".*")
            try self.validate(self.subChannelId, name: "subChannelId", parent: name, max: 128)
            try self.validate(self.subChannelId, name: "subChannelId", parent: name, min: 1)
            try self.validate(self.subChannelId, name: "subChannelId", parent: name, pattern: "^[-_a-zA-Z0-9]*$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListChannelMessagesResponse: AWSDecodableShape {
        /// The ARN of the channel containing the requested messages.
        public let channelArn: String?
        /// The information about, and content of, each requested message.
        public let channelMessages: [ChannelMessageSummary]?
        /// The token passed by previous API calls until all requested messages are returned.
        public let nextToken: String?
        /// The ID of the SubChannel in the response.
        public let subChannelId: String?

        public init(channelArn: String? = nil, channelMessages: [ChannelMessageSummary]? = nil, nextToken: String? = nil, subChannelId: String? = nil) {
            self.channelArn = channelArn
            self.channelMessages = channelMessages
            self.nextToken = nextToken
            self.subChannelId = subChannelId
        }

        private enum CodingKeys: String, CodingKey {
            case channelArn = "ChannelArn"
            case channelMessages = "ChannelMessages"
            case nextToken = "NextToken"
            case subChannelId = "SubChannelId"
        }
    }

    public struct ListChannelModeratorsRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "channelArn", location: .uri("ChannelArn")),
            AWSMemberEncoding(label: "chimeBearer", location: .header("x-amz-chime-bearer")),
            AWSMemberEncoding(label: "maxResults", location: .querystring("max-results")),
            AWSMemberEncoding(label: "nextToken", location: .querystring("next-token"))
        ]

        /// The ARN of the channel.
        public let channelArn: String
        /// The AppInstanceUserArn of the user that makes the API call.
        public let chimeBearer: String
        /// The maximum number of moderators that you want returned.
        public let maxResults: Int?
        /// The token passed by previous API calls until all requested moderators are returned.
        public let nextToken: String?

        public init(channelArn: String, chimeBearer: String, maxResults: Int? = nil, nextToken: String? = nil) {
            self.channelArn = channelArn
            self.chimeBearer = chimeBearer
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.validate(self.channelArn, name: "channelArn", parent: name, max: 1600)
            try self.validate(self.channelArn, name: "channelArn", parent: name, min: 5)
            try self.validate(self.channelArn, name: "channelArn", parent: name, pattern: "^arn:[a-z0-9-\\.]{1,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[^/].{0,1023}$")
            try self.validate(self.chimeBearer, name: "chimeBearer", parent: name, max: 1600)
            try self.validate(self.chimeBearer, name: "chimeBearer", parent: name, min: 5)
            try self.validate(self.chimeBearer, name: "chimeBearer", parent: name, pattern: "^arn:[a-z0-9-\\.]{1,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[^/].{0,1023}$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 50)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 2048)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: ".*")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListChannelModeratorsResponse: AWSDecodableShape {
        /// The ARN of the channel.
        public let channelArn: String?
        /// The information about and names of each moderator.
        public let channelModerators: [ChannelModeratorSummary]?
        /// The token passed by previous API calls until all requested moderators are returned.
        public let nextToken: String?

        public init(channelArn: String? = nil, channelModerators: [ChannelModeratorSummary]? = nil, nextToken: String? = nil) {
            self.channelArn = channelArn
            self.channelModerators = channelModerators
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case channelArn = "ChannelArn"
            case channelModerators = "ChannelModerators"
            case nextToken = "NextToken"
        }
    }

    public struct ListChannelsAssociatedWithChannelFlowRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "channelFlowArn", location: .querystring("channel-flow-arn")),
            AWSMemberEncoding(label: "maxResults", location: .querystring("max-results")),
            AWSMemberEncoding(label: "nextToken", location: .querystring("next-token"))
        ]

        /// The ARN of the channel flow.
        public let channelFlowArn: String
        /// The maximum number of channels that you want to return.
        public let maxResults: Int?
        /// The token passed by previous API calls until all requested channels are returned.
        public let nextToken: String?

        public init(channelFlowArn: String, maxResults: Int? = nil, nextToken: String? = nil) {
            self.channelFlowArn = channelFlowArn
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.validate(self.channelFlowArn, name: "channelFlowArn", parent: name, max: 1600)
            try self.validate(self.channelFlowArn, name: "channelFlowArn", parent: name, min: 5)
            try self.validate(self.channelFlowArn, name: "channelFlowArn", parent: name, pattern: "^arn:[a-z0-9-\\.]{1,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[^/].{0,1023}$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 50)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 2048)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: ".*")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListChannelsAssociatedWithChannelFlowResponse: AWSDecodableShape {
        /// The information about each channel.
        public let channels: [ChannelAssociatedWithFlowSummary]?
        /// The token passed by previous API calls until all requested channels are returned.
        public let nextToken: String?

        public init(channels: [ChannelAssociatedWithFlowSummary]? = nil, nextToken: String? = nil) {
            self.channels = channels
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case channels = "Channels"
            case nextToken = "NextToken"
        }
    }

    public struct ListChannelsModeratedByAppInstanceUserRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "appInstanceUserArn", location: .querystring("app-instance-user-arn")),
            AWSMemberEncoding(label: "chimeBearer", location: .header("x-amz-chime-bearer")),
            AWSMemberEncoding(label: "maxResults", location: .querystring("max-results")),
            AWSMemberEncoding(label: "nextToken", location: .querystring("next-token"))
        ]

        /// The ARN of the user in the moderated channel.
        public let appInstanceUserArn: String?
        /// The AppInstanceUserArn of the user that makes the API call.
        public let chimeBearer: String
        /// The maximum number of channels in the request.
        public let maxResults: Int?
        /// The token returned from previous API requests until the number of channels moderated by the user is reached.
        public let nextToken: String?

        public init(appInstanceUserArn: String? = nil, chimeBearer: String, maxResults: Int? = nil, nextToken: String? = nil) {
            self.appInstanceUserArn = appInstanceUserArn
            self.chimeBearer = chimeBearer
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.validate(self.appInstanceUserArn, name: "appInstanceUserArn", parent: name, max: 1600)
            try self.validate(self.appInstanceUserArn, name: "appInstanceUserArn", parent: name, min: 5)
            try self.validate(self.appInstanceUserArn, name: "appInstanceUserArn", parent: name, pattern: "^arn:[a-z0-9-\\.]{1,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[^/].{0,1023}$")
            try self.validate(self.chimeBearer, name: "chimeBearer", parent: name, max: 1600)
            try self.validate(self.chimeBearer, name: "chimeBearer", parent: name, min: 5)
            try self.validate(self.chimeBearer, name: "chimeBearer", parent: name, pattern: "^arn:[a-z0-9-\\.]{1,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[^/].{0,1023}$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 50)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 2048)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: ".*")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListChannelsModeratedByAppInstanceUserResponse: AWSDecodableShape {
        /// The moderated channels in the request.
        public let channels: [ChannelModeratedByAppInstanceUserSummary]?
        /// The token returned from previous API requests until the number of channels moderated by the user is reached.
        public let nextToken: String?

        public init(channels: [ChannelModeratedByAppInstanceUserSummary]? = nil, nextToken: String? = nil) {
            self.channels = channels
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case channels = "Channels"
            case nextToken = "NextToken"
        }
    }

    public struct ListChannelsRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "appInstanceArn", location: .querystring("app-instance-arn")),
            AWSMemberEncoding(label: "chimeBearer", location: .header("x-amz-chime-bearer")),
            AWSMemberEncoding(label: "maxResults", location: .querystring("max-results")),
            AWSMemberEncoding(label: "nextToken", location: .querystring("next-token")),
            AWSMemberEncoding(label: "privacy", location: .querystring("privacy"))
        ]

        /// The ARN of the AppInstance.
        public let appInstanceArn: String
        /// The AppInstanceUserArn of the user that makes the API call.
        public let chimeBearer: String
        /// The maximum number of channels that you want to return.
        public let maxResults: Int?
        /// The token passed by previous API calls until all requested channels are returned.
        public let nextToken: String?
        /// The privacy setting. PUBLIC retrieves all the public channels. PRIVATE retrieves private channels. Only an AppInstanceAdmin can retrieve private channels.
        public let privacy: ChannelPrivacy?

        public init(appInstanceArn: String, chimeBearer: String, maxResults: Int? = nil, nextToken: String? = nil, privacy: ChannelPrivacy? = nil) {
            self.appInstanceArn = appInstanceArn
            self.chimeBearer = chimeBearer
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.privacy = privacy
        }

        public func validate(name: String) throws {
            try self.validate(self.appInstanceArn, name: "appInstanceArn", parent: name, max: 1600)
            try self.validate(self.appInstanceArn, name: "appInstanceArn", parent: name, min: 5)
            try self.validate(self.appInstanceArn, name: "appInstanceArn", parent: name, pattern: "^arn:[a-z0-9-\\.]{1,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[^/].{0,1023}$")
            try self.validate(self.chimeBearer, name: "chimeBearer", parent: name, max: 1600)
            try self.validate(self.chimeBearer, name: "chimeBearer", parent: name, min: 5)
            try self.validate(self.chimeBearer, name: "chimeBearer", parent: name, pattern: "^arn:[a-z0-9-\\.]{1,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[^/].{0,1023}$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 50)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 2048)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: ".*")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListChannelsResponse: AWSDecodableShape {
        /// The information about each channel.
        public let channels: [ChannelSummary]?
        /// The token returned from previous API requests until the number of channels is reached.
        public let nextToken: String?

        public init(channels: [ChannelSummary]? = nil, nextToken: String? = nil) {
            self.channels = channels
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case channels = "Channels"
            case nextToken = "NextToken"
        }
    }

    public struct ListSubChannelsRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "channelArn", location: .uri("ChannelArn")),
            AWSMemberEncoding(label: "chimeBearer", location: .header("x-amz-chime-bearer")),
            AWSMemberEncoding(label: "maxResults", location: .querystring("max-results")),
            AWSMemberEncoding(label: "nextToken", location: .querystring("next-token"))
        ]

        /// The ARN of elastic channel.
        public let channelArn: String
        /// The AppInstanceUserArn of the user making the API call.
        public let chimeBearer: String
        /// The maximum number of sub-channels that you want to return.
        public let maxResults: Int?
        /// The token passed by previous API calls until all requested sub-channels are returned.
        public let nextToken: String?

        public init(channelArn: String, chimeBearer: String, maxResults: Int? = nil, nextToken: String? = nil) {
            self.channelArn = channelArn
            self.chimeBearer = chimeBearer
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.validate(self.channelArn, name: "channelArn", parent: name, max: 1600)
            try self.validate(self.channelArn, name: "channelArn", parent: name, min: 5)
            try self.validate(self.channelArn, name: "channelArn", parent: name, pattern: "^arn:[a-z0-9-\\.]{1,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[^/].{0,1023}$")
            try self.validate(self.chimeBearer, name: "chimeBearer", parent: name, max: 1600)
            try self.validate(self.chimeBearer, name: "chimeBearer", parent: name, min: 5)
            try self.validate(self.chimeBearer, name: "chimeBearer", parent: name, pattern: "^arn:[a-z0-9-\\.]{1,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[^/].{0,1023}$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 50)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 2048)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: ".*")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListSubChannelsResponse: AWSDecodableShape {
        /// The ARN of elastic channel.
        public let channelArn: String?
        /// The token passed by previous API calls until all requested sub-channels are returned.
        public let nextToken: String?
        /// The information about each sub-channel.
        public let subChannels: [SubChannelSummary]?

        public init(channelArn: String? = nil, nextToken: String? = nil, subChannels: [SubChannelSummary]? = nil) {
            self.channelArn = channelArn
            self.nextToken = nextToken
            self.subChannels = subChannels
        }

        private enum CodingKeys: String, CodingKey {
            case channelArn = "ChannelArn"
            case nextToken = "NextToken"
            case subChannels = "SubChannels"
        }
    }

    public struct ListTagsForResourceRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "resourceARN", location: .querystring("arn"))
        ]

        /// The ARN of the resource.
        public let resourceARN: String

        public init(resourceARN: String) {
            self.resourceARN = resourceARN
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceARN, name: "resourceARN", parent: name, max: 1600)
            try self.validate(self.resourceARN, name: "resourceARN", parent: name, min: 5)
            try self.validate(self.resourceARN, name: "resourceARN", parent: name, pattern: "^arn:[a-z0-9-\\.]{1,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[^/].{0,1023}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListTagsForResourceResponse: AWSDecodableShape {
        /// The tag key-value pairs.
        public let tags: [Tag]?

        public init(tags: [Tag]? = nil) {
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case tags = "Tags"
        }
    }

    public struct MessageAttributeValue: AWSEncodableShape & AWSDecodableShape {
        /// The strings in a message attribute value.
        public let stringValues: [String]?

        public init(stringValues: [String]? = nil) {
            self.stringValues = stringValues
        }

        public func validate(name: String) throws {
            try self.stringValues?.forEach {
                try validate($0, name: "stringValues[]", parent: name, max: 512)
                try validate($0, name: "stringValues[]", parent: name, min: 1)
                try validate($0, name: "stringValues[]", parent: name, pattern: "^[\\s\\S]*$")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case stringValues = "StringValues"
        }
    }

    public struct MessagingSessionEndpoint: AWSDecodableShape {
        /// The endpoint to which you establish a websocket connection.
        public let url: String?

        public init(url: String? = nil) {
            self.url = url
        }

        private enum CodingKeys: String, CodingKey {
            case url = "Url"
        }
    }

    public struct Processor: AWSEncodableShape & AWSDecodableShape {
        /// The information about the type of processor and its identifier.
        public let configuration: ProcessorConfiguration
        /// The sequence in which processors run. If you have multiple processors in a channel flow, message processing goes through each processor in the sequence. The value determines the sequence.  At this point, we support only 1 processor within a flow.
        public let executionOrder: Int
        /// Determines whether to continue with message processing or stop it in cases where communication with a processor fails. If a processor has a fallback action of ABORT and  communication with it fails, the processor sets the message status to FAILED and does not send the message to any recipients. Note that if the last processor in the channel flow sequence  has a fallback action of CONTINUE and communication with the processor fails, then the message is considered processed and sent to recipients of the channel.
        public let fallbackAction: FallbackAction
        /// The name of the channel flow.
        public let name: String

        public init(configuration: ProcessorConfiguration, executionOrder: Int, fallbackAction: FallbackAction, name: String) {
            self.configuration = configuration
            self.executionOrder = executionOrder
            self.fallbackAction = fallbackAction
            self.name = name
        }

        public func validate(name: String) throws {
            try self.configuration.validate(name: "\(name).configuration")
            try self.validate(self.executionOrder, name: "executionOrder", parent: name, max: 3)
            try self.validate(self.executionOrder, name: "executionOrder", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, max: 256)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[\\u0009\\u000A\\u000D\\u0020-\\u007E\\u0085\\u00A0-\\uD7FF\\uE000-\\uFFFD\\u10000-\\u10FFFF]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case configuration = "Configuration"
            case executionOrder = "ExecutionOrder"
            case fallbackAction = "FallbackAction"
            case name = "Name"
        }
    }

    public struct ProcessorConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// Indicates that the processor is of type Lambda.
        public let lambda: LambdaConfiguration

        public init(lambda: LambdaConfiguration) {
            self.lambda = lambda
        }

        public func validate(name: String) throws {
            try self.lambda.validate(name: "\(name).lambda")
        }

        private enum CodingKeys: String, CodingKey {
            case lambda = "Lambda"
        }
    }

    public struct PushNotificationConfiguration: AWSEncodableShape {
        /// The body of the push notification.
        public let body: String?
        /// The title of the push notification.
        public let title: String?
        /// Enum value that indicates the type of the push notification for a message. DEFAULT: Normal mobile push notification. VOIP: VOIP mobile push notification.
        public let type: PushNotificationType?

        public init(body: String? = nil, title: String? = nil, type: PushNotificationType? = nil) {
            self.body = body
            self.title = title
            self.type = type
        }

        public func validate(name: String) throws {
            try self.validate(self.body, name: "body", parent: name, max: 150)
            try self.validate(self.body, name: "body", parent: name, pattern: "^[\\s\\S]*$")
            try self.validate(self.title, name: "title", parent: name, max: 50)
            try self.validate(self.title, name: "title", parent: name, pattern: ".*")
        }

        private enum CodingKeys: String, CodingKey {
            case body = "Body"
            case title = "Title"
            case type = "Type"
        }
    }

    public struct PushNotificationPreferences: AWSEncodableShape & AWSDecodableShape {
        /// Enum value that indicates which push notifications to send to the requested member of a channel. ALL sends all push notifications, NONE sends no push notifications, FILTERED sends only filtered push notifications.
        public let allowNotifications: AllowNotifications
        /// The simple JSON object used to send a subset of a push notification to the requested member.
        public let filterRule: String?

        public init(allowNotifications: AllowNotifications, filterRule: String? = nil) {
            self.allowNotifications = allowNotifications
            self.filterRule = filterRule
        }

        public func validate(name: String) throws {
            try self.validate(self.filterRule, name: "filterRule", parent: name, min: 1)
            try self.validate(self.filterRule, name: "filterRule", parent: name, pattern: "^[\\s\\S]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case allowNotifications = "AllowNotifications"
            case filterRule = "FilterRule"
        }
    }

    public struct PutChannelMembershipPreferencesRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "channelArn", location: .uri("ChannelArn")),
            AWSMemberEncoding(label: "chimeBearer", location: .header("x-amz-chime-bearer")),
            AWSMemberEncoding(label: "memberArn", location: .uri("MemberArn"))
        ]

        /// The ARN of the channel.
        public let channelArn: String
        /// The AppInstanceUserARN  of the user making the API call.
        public let chimeBearer: String
        /// The AppInstanceUserArn of the member setting the preferences.
        public let memberArn: String
        /// The channel membership preferences of an AppInstanceUser .
        public let preferences: ChannelMembershipPreferences

        public init(channelArn: String, chimeBearer: String, memberArn: String, preferences: ChannelMembershipPreferences) {
            self.channelArn = channelArn
            self.chimeBearer = chimeBearer
            self.memberArn = memberArn
            self.preferences = preferences
        }

        public func validate(name: String) throws {
            try self.validate(self.channelArn, name: "channelArn", parent: name, max: 1600)
            try self.validate(self.channelArn, name: "channelArn", parent: name, min: 5)
            try self.validate(self.channelArn, name: "channelArn", parent: name, pattern: "^arn:[a-z0-9-\\.]{1,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[^/].{0,1023}$")
            try self.validate(self.chimeBearer, name: "chimeBearer", parent: name, max: 1600)
            try self.validate(self.chimeBearer, name: "chimeBearer", parent: name, min: 5)
            try self.validate(self.chimeBearer, name: "chimeBearer", parent: name, pattern: "^arn:[a-z0-9-\\.]{1,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[^/].{0,1023}$")
            try self.validate(self.memberArn, name: "memberArn", parent: name, max: 1600)
            try self.validate(self.memberArn, name: "memberArn", parent: name, min: 5)
            try self.validate(self.memberArn, name: "memberArn", parent: name, pattern: "^arn:[a-z0-9-\\.]{1,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[^/].{0,1023}$")
            try self.preferences.validate(name: "\(name).preferences")
        }

        private enum CodingKeys: String, CodingKey {
            case preferences = "Preferences"
        }
    }

    public struct PutChannelMembershipPreferencesResponse: AWSDecodableShape {
        /// The ARN of the channel.
        public let channelArn: String?
        /// The details of a user.
        public let member: Identity?
        /// The ARN and metadata of the member being added.
        public let preferences: ChannelMembershipPreferences?

        public init(channelArn: String? = nil, member: Identity? = nil, preferences: ChannelMembershipPreferences? = nil) {
            self.channelArn = channelArn
            self.member = member
            self.preferences = preferences
        }

        private enum CodingKeys: String, CodingKey {
            case channelArn = "ChannelArn"
            case member = "Member"
            case preferences = "Preferences"
        }
    }

    public struct RedactChannelMessageRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "channelArn", location: .uri("ChannelArn")),
            AWSMemberEncoding(label: "chimeBearer", location: .header("x-amz-chime-bearer")),
            AWSMemberEncoding(label: "messageId", location: .uri("MessageId"))
        ]

        /// The ARN of the channel containing the messages that you want to redact.
        public let channelArn: String
        /// The AppInstanceUserArn of the user that makes the API call.
        public let chimeBearer: String
        /// The ID of the message being redacted.
        public let messageId: String
        /// The ID of the SubChannel in the request.
        public let subChannelId: String?

        public init(channelArn: String, chimeBearer: String, messageId: String, subChannelId: String? = nil) {
            self.channelArn = channelArn
            self.chimeBearer = chimeBearer
            self.messageId = messageId
            self.subChannelId = subChannelId
        }

        public func validate(name: String) throws {
            try self.validate(self.channelArn, name: "channelArn", parent: name, max: 1600)
            try self.validate(self.channelArn, name: "channelArn", parent: name, min: 5)
            try self.validate(self.channelArn, name: "channelArn", parent: name, pattern: "^arn:[a-z0-9-\\.]{1,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[^/].{0,1023}$")
            try self.validate(self.chimeBearer, name: "chimeBearer", parent: name, max: 1600)
            try self.validate(self.chimeBearer, name: "chimeBearer", parent: name, min: 5)
            try self.validate(self.chimeBearer, name: "chimeBearer", parent: name, pattern: "^arn:[a-z0-9-\\.]{1,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[^/].{0,1023}$")
            try self.validate(self.messageId, name: "messageId", parent: name, max: 128)
            try self.validate(self.messageId, name: "messageId", parent: name, min: 1)
            try self.validate(self.messageId, name: "messageId", parent: name, pattern: "^[-_a-zA-Z0-9]*$")
            try self.validate(self.subChannelId, name: "subChannelId", parent: name, max: 128)
            try self.validate(self.subChannelId, name: "subChannelId", parent: name, min: 1)
            try self.validate(self.subChannelId, name: "subChannelId", parent: name, pattern: "^[-_a-zA-Z0-9]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case subChannelId = "SubChannelId"
        }
    }

    public struct RedactChannelMessageResponse: AWSDecodableShape {
        /// The ARN of the channel containing the messages that you want to redact.
        public let channelArn: String?
        /// The ID of the message being redacted.
        public let messageId: String?
        /// The ID of the SubChannel in the response.  Only required when redacting messages in a SubChannel that the user belongs to.
        public let subChannelId: String?

        public init(channelArn: String? = nil, messageId: String? = nil, subChannelId: String? = nil) {
            self.channelArn = channelArn
            self.messageId = messageId
            self.subChannelId = subChannelId
        }

        private enum CodingKeys: String, CodingKey {
            case channelArn = "ChannelArn"
            case messageId = "MessageId"
            case subChannelId = "SubChannelId"
        }
    }

    public struct SearchChannelsRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "chimeBearer", location: .header("x-amz-chime-bearer")),
            AWSMemberEncoding(label: "maxResults", location: .querystring("max-results")),
            AWSMemberEncoding(label: "nextToken", location: .querystring("next-token"))
        ]

        /// The AppInstanceUserArn of the user making the API call.
        public let chimeBearer: String?
        /// A list of the Field objects in the channel being searched.
        public let fields: [SearchField]
        /// The maximum number of channels that you want returned.
        public let maxResults: Int?
        /// The token returned from previous API requests until the number of channels is reached.
        public let nextToken: String?

        public init(chimeBearer: String? = nil, fields: [SearchField], maxResults: Int? = nil, nextToken: String? = nil) {
            self.chimeBearer = chimeBearer
            self.fields = fields
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.validate(self.chimeBearer, name: "chimeBearer", parent: name, max: 1600)
            try self.validate(self.chimeBearer, name: "chimeBearer", parent: name, min: 5)
            try self.validate(self.chimeBearer, name: "chimeBearer", parent: name, pattern: "^arn:[a-z0-9-\\.]{1,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[^/].{0,1023}$")
            try self.fields.forEach {
                try $0.validate(name: "\(name).fields[]")
            }
            try self.validate(self.fields, name: "fields", parent: name, max: 20)
            try self.validate(self.fields, name: "fields", parent: name, min: 1)
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 50)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 2048)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: ".*")
        }

        private enum CodingKeys: String, CodingKey {
            case fields = "Fields"
        }
    }

    public struct SearchChannelsResponse: AWSDecodableShape {
        /// A list of the channels in the request.
        public let channels: [ChannelSummary]?
        /// The token returned from previous API responses until the number of channels is reached.
        public let nextToken: String?

        public init(channels: [ChannelSummary]? = nil, nextToken: String? = nil) {
            self.channels = channels
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case channels = "Channels"
            case nextToken = "NextToken"
        }
    }

    public struct SearchField: AWSEncodableShape {
        /// An enum value that indicates the key to search the channel on. MEMBERS allows you to search channels based on memberships. You can use it with the EQUALS  operator to get channels whose memberships are equal to the specified values, and with the INCLUDES  operator to get channels whose memberships include the specified values.
        public let key: SearchFieldKey
        /// The operator used to compare field values, currently EQUALS or INCLUDES.  Use the EQUALS operator to find channels whose memberships equal the specified values.  Use the INCLUDES operator to find channels whose memberships include the specified values.
        public let `operator`: SearchFieldOperator
        /// The values that you want to search for, a list of strings. The values must be AppInstanceUserArns specified as a list of strings.  This operation isn't supported for AppInstanceUsers with large number of memberships.
        public let values: [String]

        public init(key: SearchFieldKey, operator: SearchFieldOperator, values: [String]) {
            self.key = key
            self.`operator` = `operator`
            self.values = values
        }

        public func validate(name: String) throws {
            try self.values.forEach {
                try validate($0, name: "values[]", parent: name, max: 512)
                try validate($0, name: "values[]", parent: name, min: 1)
                try validate($0, name: "values[]", parent: name, pattern: "^[\\s\\S]*$")
            }
            try self.validate(self.values, name: "values", parent: name, max: 20)
            try self.validate(self.values, name: "values", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case key = "Key"
            case `operator` = "Operator"
            case values = "Values"
        }
    }

    public struct SendChannelMessageRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "channelArn", location: .uri("ChannelArn")),
            AWSMemberEncoding(label: "chimeBearer", location: .header("x-amz-chime-bearer"))
        ]

        /// The ARN of the channel.
        public let channelArn: String
        /// The AppInstanceUserArn of the user that makes the API call.
        public let chimeBearer: String
        /// The Idempotency token for each client request.
        public let clientRequestToken: String
        /// The content of the message.
        public let content: String
        /// The attributes for the message, used for message filtering along with a FilterRule defined in the PushNotificationPreferences.
        public let messageAttributes: [String: MessageAttributeValue]?
        /// The optional metadata for each message.
        public let metadata: String?
        /// Boolean that controls whether the message is persisted on the back end. Required.
        public let persistence: ChannelMessagePersistenceType
        /// The push notification configuration of the message.
        public let pushNotification: PushNotificationConfiguration?
        /// The ID of the SubChannel in the request.
        public let subChannelId: String?
        /// The type of message, STANDARD or CONTROL.
        public let type: ChannelMessageType

        public init(channelArn: String, chimeBearer: String, clientRequestToken: String = SendChannelMessageRequest.idempotencyToken(), content: String, messageAttributes: [String: MessageAttributeValue]? = nil, metadata: String? = nil, persistence: ChannelMessagePersistenceType, pushNotification: PushNotificationConfiguration? = nil, subChannelId: String? = nil, type: ChannelMessageType) {
            self.channelArn = channelArn
            self.chimeBearer = chimeBearer
            self.clientRequestToken = clientRequestToken
            self.content = content
            self.messageAttributes = messageAttributes
            self.metadata = metadata
            self.persistence = persistence
            self.pushNotification = pushNotification
            self.subChannelId = subChannelId
            self.type = type
        }

        public func validate(name: String) throws {
            try self.validate(self.channelArn, name: "channelArn", parent: name, max: 1600)
            try self.validate(self.channelArn, name: "channelArn", parent: name, min: 5)
            try self.validate(self.channelArn, name: "channelArn", parent: name, pattern: "^arn:[a-z0-9-\\.]{1,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[^/].{0,1023}$")
            try self.validate(self.chimeBearer, name: "chimeBearer", parent: name, max: 1600)
            try self.validate(self.chimeBearer, name: "chimeBearer", parent: name, min: 5)
            try self.validate(self.chimeBearer, name: "chimeBearer", parent: name, pattern: "^arn:[a-z0-9-\\.]{1,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[^/].{0,1023}$")
            try self.validate(self.clientRequestToken, name: "clientRequestToken", parent: name, max: 64)
            try self.validate(self.clientRequestToken, name: "clientRequestToken", parent: name, min: 2)
            try self.validate(self.clientRequestToken, name: "clientRequestToken", parent: name, pattern: "^[-_a-zA-Z0-9]*$")
            try self.validate(self.content, name: "content", parent: name, min: 1)
            try self.validate(self.content, name: "content", parent: name, pattern: "^[\\s\\S]*$")
            try self.messageAttributes?.forEach {
                try validate($0.key, name: "messageAttributes.key", parent: name, max: 64)
                try validate($0.key, name: "messageAttributes.key", parent: name, min: 1)
                try validate($0.key, name: "messageAttributes.key", parent: name, pattern: "^[\\s\\S]*$")
                try $0.value.validate(name: "\(name).messageAttributes[\"\($0.key)\"]")
            }
            try self.validate(self.metadata, name: "metadata", parent: name, max: 1024)
            try self.validate(self.metadata, name: "metadata", parent: name, pattern: ".*")
            try self.pushNotification?.validate(name: "\(name).pushNotification")
            try self.validate(self.subChannelId, name: "subChannelId", parent: name, max: 128)
            try self.validate(self.subChannelId, name: "subChannelId", parent: name, min: 1)
            try self.validate(self.subChannelId, name: "subChannelId", parent: name, pattern: "^[-_a-zA-Z0-9]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case clientRequestToken = "ClientRequestToken"
            case content = "Content"
            case messageAttributes = "MessageAttributes"
            case metadata = "Metadata"
            case persistence = "Persistence"
            case pushNotification = "PushNotification"
            case subChannelId = "SubChannelId"
            case type = "Type"
        }
    }

    public struct SendChannelMessageResponse: AWSDecodableShape {
        /// The ARN of the channel.
        public let channelArn: String?
        /// The ID string assigned to each message.
        public let messageId: String?
        /// The status of the channel message.
        public let status: ChannelMessageStatusStructure?
        /// The ID of the SubChannel in the response.
        public let subChannelId: String?

        public init(channelArn: String? = nil, messageId: String? = nil, status: ChannelMessageStatusStructure? = nil, subChannelId: String? = nil) {
            self.channelArn = channelArn
            self.messageId = messageId
            self.status = status
            self.subChannelId = subChannelId
        }

        private enum CodingKeys: String, CodingKey {
            case channelArn = "ChannelArn"
            case messageId = "MessageId"
            case status = "Status"
            case subChannelId = "SubChannelId"
        }
    }

    public struct SubChannelSummary: AWSDecodableShape {
        /// The number of members in a SubChannel.
        public let membershipCount: Int?
        /// The unique ID of a SubChannel.
        public let subChannelId: String?

        public init(membershipCount: Int? = nil, subChannelId: String? = nil) {
            self.membershipCount = membershipCount
            self.subChannelId = subChannelId
        }

        private enum CodingKeys: String, CodingKey {
            case membershipCount = "MembershipCount"
            case subChannelId = "SubChannelId"
        }
    }

    public struct Tag: AWSEncodableShape & AWSDecodableShape {
        /// The key in a tag.
        public let key: String
        /// The value in a tag.
        public let value: String

        public init(key: String, value: String) {
            self.key = key
            self.value = value
        }

        public func validate(name: String) throws {
            try self.validate(self.key, name: "key", parent: name, max: 128)
            try self.validate(self.key, name: "key", parent: name, min: 1)
            try self.validate(self.value, name: "value", parent: name, max: 256)
            try self.validate(self.value, name: "value", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case key = "Key"
            case value = "Value"
        }
    }

    public struct TagResourceRequest: AWSEncodableShape {
        /// The resource ARN.
        public let resourceARN: String
        /// The tag key-value pairs.
        public let tags: [Tag]

        public init(resourceARN: String, tags: [Tag]) {
            self.resourceARN = resourceARN
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceARN, name: "resourceARN", parent: name, max: 1600)
            try self.validate(self.resourceARN, name: "resourceARN", parent: name, min: 5)
            try self.validate(self.resourceARN, name: "resourceARN", parent: name, pattern: "^arn:[a-z0-9-\\.]{1,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[^/].{0,1023}$")
            try self.tags.forEach {
                try $0.validate(name: "\(name).tags[]")
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 50)
            try self.validate(self.tags, name: "tags", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case resourceARN = "ResourceARN"
            case tags = "Tags"
        }
    }

    public struct UntagResourceRequest: AWSEncodableShape {
        /// The resource ARN.
        public let resourceARN: String
        /// The tag keys.
        public let tagKeys: [String]

        public init(resourceARN: String, tagKeys: [String]) {
            self.resourceARN = resourceARN
            self.tagKeys = tagKeys
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceARN, name: "resourceARN", parent: name, max: 1600)
            try self.validate(self.resourceARN, name: "resourceARN", parent: name, min: 5)
            try self.validate(self.resourceARN, name: "resourceARN", parent: name, pattern: "^arn:[a-z0-9-\\.]{1,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[^/].{0,1023}$")
            try self.tagKeys.forEach {
                try validate($0, name: "tagKeys[]", parent: name, max: 128)
                try validate($0, name: "tagKeys[]", parent: name, min: 1)
            }
            try self.validate(self.tagKeys, name: "tagKeys", parent: name, max: 50)
            try self.validate(self.tagKeys, name: "tagKeys", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case resourceARN = "ResourceARN"
            case tagKeys = "TagKeys"
        }
    }

    public struct UpdateChannelFlowRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "channelFlowArn", location: .uri("ChannelFlowArn"))
        ]

        /// The ARN of the channel flow.
        public let channelFlowArn: String
        /// The name of the channel flow.
        public let name: String
        /// Information about the processor Lambda functions
        public let processors: [Processor]

        public init(channelFlowArn: String, name: String, processors: [Processor]) {
            self.channelFlowArn = channelFlowArn
            self.name = name
            self.processors = processors
        }

        public func validate(name: String) throws {
            try self.validate(self.channelFlowArn, name: "channelFlowArn", parent: name, max: 1600)
            try self.validate(self.channelFlowArn, name: "channelFlowArn", parent: name, min: 5)
            try self.validate(self.channelFlowArn, name: "channelFlowArn", parent: name, pattern: "^arn:[a-z0-9-\\.]{1,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[^/].{0,1023}$")
            try self.validate(self.name, name: "name", parent: name, max: 256)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[\\u0009\\u000A\\u000D\\u0020-\\u007E\\u0085\\u00A0-\\uD7FF\\uE000-\\uFFFD\\u10000-\\u10FFFF]*$")
            try self.processors.forEach {
                try $0.validate(name: "\(name).processors[]")
            }
            try self.validate(self.processors, name: "processors", parent: name, max: 3)
            try self.validate(self.processors, name: "processors", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case name = "Name"
            case processors = "Processors"
        }
    }

    public struct UpdateChannelFlowResponse: AWSDecodableShape {
        /// The ARN of the channel flow.
        public let channelFlowArn: String?

        public init(channelFlowArn: String? = nil) {
            self.channelFlowArn = channelFlowArn
        }

        private enum CodingKeys: String, CodingKey {
            case channelFlowArn = "ChannelFlowArn"
        }
    }

    public struct UpdateChannelMessageRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "channelArn", location: .uri("ChannelArn")),
            AWSMemberEncoding(label: "chimeBearer", location: .header("x-amz-chime-bearer")),
            AWSMemberEncoding(label: "messageId", location: .uri("MessageId"))
        ]

        /// The ARN of the channel.
        public let channelArn: String
        /// The AppInstanceUserArn of the user that makes the API call.
        public let chimeBearer: String
        /// The content of the message being updated.
        public let content: String?
        /// The ID string of the message being updated.
        public let messageId: String
        /// The metadata of the message being updated.
        public let metadata: String?
        /// The ID of the SubChannel in the request.  Only required when updating messages in a SubChannel that the user belongs to.
        public let subChannelId: String?

        public init(channelArn: String, chimeBearer: String, content: String? = nil, messageId: String, metadata: String? = nil, subChannelId: String? = nil) {
            self.channelArn = channelArn
            self.chimeBearer = chimeBearer
            self.content = content
            self.messageId = messageId
            self.metadata = metadata
            self.subChannelId = subChannelId
        }

        public func validate(name: String) throws {
            try self.validate(self.channelArn, name: "channelArn", parent: name, max: 1600)
            try self.validate(self.channelArn, name: "channelArn", parent: name, min: 5)
            try self.validate(self.channelArn, name: "channelArn", parent: name, pattern: "^arn:[a-z0-9-\\.]{1,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[^/].{0,1023}$")
            try self.validate(self.chimeBearer, name: "chimeBearer", parent: name, max: 1600)
            try self.validate(self.chimeBearer, name: "chimeBearer", parent: name, min: 5)
            try self.validate(self.chimeBearer, name: "chimeBearer", parent: name, pattern: "^arn:[a-z0-9-\\.]{1,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[^/].{0,1023}$")
            try self.validate(self.content, name: "content", parent: name, max: 4096)
            try self.validate(self.content, name: "content", parent: name, pattern: "^[\\s\\S]*$")
            try self.validate(self.messageId, name: "messageId", parent: name, max: 128)
            try self.validate(self.messageId, name: "messageId", parent: name, min: 1)
            try self.validate(self.messageId, name: "messageId", parent: name, pattern: "^[-_a-zA-Z0-9]*$")
            try self.validate(self.metadata, name: "metadata", parent: name, max: 1024)
            try self.validate(self.metadata, name: "metadata", parent: name, pattern: ".*")
            try self.validate(self.subChannelId, name: "subChannelId", parent: name, max: 128)
            try self.validate(self.subChannelId, name: "subChannelId", parent: name, min: 1)
            try self.validate(self.subChannelId, name: "subChannelId", parent: name, pattern: "^[-_a-zA-Z0-9]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case content = "Content"
            case metadata = "Metadata"
            case subChannelId = "SubChannelId"
        }
    }

    public struct UpdateChannelMessageResponse: AWSDecodableShape {
        /// The ARN of the channel.
        public let channelArn: String?
        /// The ID string of the message being updated.
        public let messageId: String?
        /// The status of the message update.
        public let status: ChannelMessageStatusStructure?
        /// The ID of the SubChannel in the response.
        public let subChannelId: String?

        public init(channelArn: String? = nil, messageId: String? = nil, status: ChannelMessageStatusStructure? = nil, subChannelId: String? = nil) {
            self.channelArn = channelArn
            self.messageId = messageId
            self.status = status
            self.subChannelId = subChannelId
        }

        private enum CodingKeys: String, CodingKey {
            case channelArn = "ChannelArn"
            case messageId = "MessageId"
            case status = "Status"
            case subChannelId = "SubChannelId"
        }
    }

    public struct UpdateChannelReadMarkerRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "channelArn", location: .uri("ChannelArn")),
            AWSMemberEncoding(label: "chimeBearer", location: .header("x-amz-chime-bearer"))
        ]

        /// The ARN of the channel.
        public let channelArn: String
        /// The AppInstanceUserArn of the user that makes the API call.
        public let chimeBearer: String
        /// The ID of the SubChannel in the request.
        public let subChannelId: String?

        public init(channelArn: String, chimeBearer: String, subChannelId: String? = nil) {
            self.channelArn = channelArn
            self.chimeBearer = chimeBearer
            self.subChannelId = subChannelId
        }

        public func validate(name: String) throws {
            try self.validate(self.channelArn, name: "channelArn", parent: name, max: 1600)
            try self.validate(self.channelArn, name: "channelArn", parent: name, min: 5)
            try self.validate(self.channelArn, name: "channelArn", parent: name, pattern: "^arn:[a-z0-9-\\.]{1,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[^/].{0,1023}$")
            try self.validate(self.chimeBearer, name: "chimeBearer", parent: name, max: 1600)
            try self.validate(self.chimeBearer, name: "chimeBearer", parent: name, min: 5)
            try self.validate(self.chimeBearer, name: "chimeBearer", parent: name, pattern: "^arn:[a-z0-9-\\.]{1,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[^/].{0,1023}$")
            try self.validate(self.subChannelId, name: "subChannelId", parent: name, max: 128)
            try self.validate(self.subChannelId, name: "subChannelId", parent: name, min: 1)
            try self.validate(self.subChannelId, name: "subChannelId", parent: name, pattern: "^[-_a-zA-Z0-9]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case subChannelId = "SubChannelId"
        }
    }

    public struct UpdateChannelReadMarkerResponse: AWSDecodableShape {
        /// The ARN of the channel.
        public let channelArn: String?
        /// The ID of the SubChannel in the response.
        public let subChannelId: String?

        public init(channelArn: String? = nil, subChannelId: String? = nil) {
            self.channelArn = channelArn
            self.subChannelId = subChannelId
        }

        private enum CodingKeys: String, CodingKey {
            case channelArn = "ChannelArn"
            case subChannelId = "SubChannelId"
        }
    }

    public struct UpdateChannelRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "channelArn", location: .uri("ChannelArn")),
            AWSMemberEncoding(label: "chimeBearer", location: .header("x-amz-chime-bearer"))
        ]

        /// The ARN of the channel.
        public let channelArn: String
        /// The AppInstanceUserArn of the user that makes the API call.
        public let chimeBearer: String
        /// The metadata for the update request.
        public let metadata: String?
        /// The mode of the update request.
        public let mode: ChannelMode?
        /// The name of the channel.
        public let name: String?

        public init(channelArn: String, chimeBearer: String, metadata: String? = nil, mode: ChannelMode? = nil, name: String? = nil) {
            self.channelArn = channelArn
            self.chimeBearer = chimeBearer
            self.metadata = metadata
            self.mode = mode
            self.name = name
        }

        public func validate(name: String) throws {
            try self.validate(self.channelArn, name: "channelArn", parent: name, max: 1600)
            try self.validate(self.channelArn, name: "channelArn", parent: name, min: 5)
            try self.validate(self.channelArn, name: "channelArn", parent: name, pattern: "^arn:[a-z0-9-\\.]{1,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[^/].{0,1023}$")
            try self.validate(self.chimeBearer, name: "chimeBearer", parent: name, max: 1600)
            try self.validate(self.chimeBearer, name: "chimeBearer", parent: name, min: 5)
            try self.validate(self.chimeBearer, name: "chimeBearer", parent: name, pattern: "^arn:[a-z0-9-\\.]{1,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[^/].{0,1023}$")
            try self.validate(self.metadata, name: "metadata", parent: name, max: 1024)
            try self.validate(self.metadata, name: "metadata", parent: name, pattern: ".*")
            try self.validate(self.name, name: "name", parent: name, max: 256)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[\\u0009\\u000A\\u000D\\u0020-\\u007E\\u0085\\u00A0-\\uD7FF\\uE000-\\uFFFD\\u10000-\\u10FFFF]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case metadata = "Metadata"
            case mode = "Mode"
            case name = "Name"
        }
    }

    public struct UpdateChannelResponse: AWSDecodableShape {
        /// The ARN of the channel.
        public let channelArn: String?

        public init(channelArn: String? = nil) {
            self.channelArn = channelArn
        }

        private enum CodingKeys: String, CodingKey {
            case channelArn = "ChannelArn"
        }
    }
}

// MARK: - Errors

/// Error enum for ChimeSDKMessaging
public struct ChimeSDKMessagingErrorType: AWSErrorType {
    enum Code: String {
        case badRequestException = "BadRequestException"
        case conflictException = "ConflictException"
        case forbiddenException = "ForbiddenException"
        case notFoundException = "NotFoundException"
        case resourceLimitExceededException = "ResourceLimitExceededException"
        case serviceFailureException = "ServiceFailureException"
        case serviceUnavailableException = "ServiceUnavailableException"
        case throttledClientException = "ThrottledClientException"
        case unauthorizedClientException = "UnauthorizedClientException"
    }

    private let error: Code
    public let context: AWSErrorContext?

    /// initialize ChimeSDKMessaging
    public init?(errorCode: String, context: AWSErrorContext) {
        guard let error = Code(rawValue: errorCode) else { return nil }
        self.error = error
        self.context = context
    }

    internal init(_ error: Code) {
        self.error = error
        self.context = nil
    }

    /// return error code string
    public var errorCode: String { self.error.rawValue }

    /// The input parameters don&#39;t match the service&#39;s restrictions.
    public static var badRequestException: Self { .init(.badRequestException) }
    /// The request could not be processed because of conflict in the current state of the resource.
    public static var conflictException: Self { .init(.conflictException) }
    /// The client is permanently forbidden from making the request.
    public static var forbiddenException: Self { .init(.forbiddenException) }
    /// One or more of the resources in the request does not exist in the system.
    public static var notFoundException: Self { .init(.notFoundException) }
    /// The request exceeds the resource limit.
    public static var resourceLimitExceededException: Self { .init(.resourceLimitExceededException) }
    /// The service encountered an unexpected error.
    public static var serviceFailureException: Self { .init(.serviceFailureException) }
    /// The service is currently unavailable.
    public static var serviceUnavailableException: Self { .init(.serviceUnavailableException) }
    /// The client exceeded its request rate limit.
    public static var throttledClientException: Self { .init(.throttledClientException) }
    /// The client is not currently authorized to make the request.
    public static var unauthorizedClientException: Self { .init(.unauthorizedClientException) }
}

extension ChimeSDKMessagingErrorType: Equatable {
    public static func == (lhs: ChimeSDKMessagingErrorType, rhs: ChimeSDKMessagingErrorType) -> Bool {
        lhs.error == rhs.error
    }
}

extension ChimeSDKMessagingErrorType: CustomStringConvertible {
    public var description: String {
        return "\(self.error.rawValue): \(self.message ?? "")"
    }
}
