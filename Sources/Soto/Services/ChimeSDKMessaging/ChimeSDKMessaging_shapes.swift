//===----------------------------------------------------------------------===//
//
// This source file is part of the Soto for AWS open source project
//
// Copyright (c) 2017-2024 the Soto project authors
// Licensed under Apache License v2.0
//
// See LICENSE.txt for license information
// See CONTRIBUTORS.txt for the list of Soto project authors
//
// SPDX-License-Identifier: Apache-2.0
//
//===----------------------------------------------------------------------===//

// THIS FILE IS AUTOMATICALLY GENERATED by https://github.com/soto-project/soto-codegenerator.
// DO NOT EDIT.

#if canImport(FoundationEssentials)
import FoundationEssentials
#else
import Foundation
#endif
@_spi(SotoInternal) import SotoCore

extension ChimeSDKMessaging {
    // MARK: Enums

    public enum AllowNotifications: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case all = "ALL"
        case filtered = "FILTERED"
        case none = "NONE"
        public var description: String { return self.rawValue }
    }

    public enum ChannelMembershipType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case `default` = "DEFAULT"
        case hidden = "HIDDEN"
        public var description: String { return self.rawValue }
    }

    public enum ChannelMessagePersistenceType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case nonPersistent = "NON_PERSISTENT"
        case persistent = "PERSISTENT"
        public var description: String { return self.rawValue }
    }

    public enum ChannelMessageStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case denied = "DENIED"
        case failed = "FAILED"
        case pending = "PENDING"
        case sent = "SENT"
        public var description: String { return self.rawValue }
    }

    public enum ChannelMessageType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case control = "CONTROL"
        case standard = "STANDARD"
        public var description: String { return self.rawValue }
    }

    public enum ChannelMode: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case restricted = "RESTRICTED"
        case unrestricted = "UNRESTRICTED"
        public var description: String { return self.rawValue }
    }

    public enum ChannelPrivacy: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case `private` = "PRIVATE"
        case `public` = "PUBLIC"
        public var description: String { return self.rawValue }
    }

    public enum ErrorCode: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case accessDenied = "AccessDenied"
        case badRequest = "BadRequest"
        case conflict = "Conflict"
        case forbidden = "Forbidden"
        case notFound = "NotFound"
        case phoneNumberAssociationsExist = "PhoneNumberAssociationsExist"
        case preconditionFailed = "PreconditionFailed"
        case resourceLimitExceeded = "ResourceLimitExceeded"
        case serviceFailure = "ServiceFailure"
        case serviceUnavailable = "ServiceUnavailable"
        case throttled = "Throttled"
        case throttling = "Throttling"
        case unauthorized = "Unauthorized"
        case unprocessable = "Unprocessable"
        case voiceConnectorGroupAssociationsExist = "VoiceConnectorGroupAssociationsExist"
        public var description: String { return self.rawValue }
    }

    public enum ExpirationCriterion: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case createdTimestamp = "CREATED_TIMESTAMP"
        case lastMessageTimestamp = "LAST_MESSAGE_TIMESTAMP"
        public var description: String { return self.rawValue }
    }

    public enum FallbackAction: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case `continue` = "CONTINUE"
        case abort = "ABORT"
        public var description: String { return self.rawValue }
    }

    public enum InvocationType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case `async` = "ASYNC"
        public var description: String { return self.rawValue }
    }

    public enum MessagingDataType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case channel = "Channel"
        case channelMessage = "ChannelMessage"
        public var description: String { return self.rawValue }
    }

    public enum PushNotificationType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case `default` = "DEFAULT"
        case voip = "VOIP"
        public var description: String { return self.rawValue }
    }

    public enum SearchFieldKey: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case members = "MEMBERS"
        public var description: String { return self.rawValue }
    }

    public enum SearchFieldOperator: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case equals = "EQUALS"
        case includes = "INCLUDES"
        public var description: String { return self.rawValue }
    }

    public enum SortOrder: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case ascending = "ASCENDING"
        case descending = "DESCENDING"
        public var description: String { return self.rawValue }
    }

    // MARK: Shapes

    public struct AppInstanceUserMembershipSummary: AWSDecodableShape {
        /// The time at which an AppInstanceUser last marked a channel as read.
        public let readMarkerTimestamp: Date?
        /// The ID of the SubChannel that the AppInstanceUser is a member of.
        public let subChannelId: String?
        /// The type of ChannelMembership.
        public let type: ChannelMembershipType?

        @inlinable
        public init(readMarkerTimestamp: Date? = nil, subChannelId: String? = nil, type: ChannelMembershipType? = nil) {
            self.readMarkerTimestamp = readMarkerTimestamp
            self.subChannelId = subChannelId
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case readMarkerTimestamp = "ReadMarkerTimestamp"
            case subChannelId = "SubChannelId"
            case type = "Type"
        }
    }

    public struct AssociateChannelFlowRequest: AWSEncodableShape {
        /// The ARN of the channel.
        public let channelArn: String
        /// The ARN of the channel flow.
        public let channelFlowArn: String
        /// The AppInstanceUserArn of the user making the API call.
        public let chimeBearer: String

        @inlinable
        public init(channelArn: String, channelFlowArn: String, chimeBearer: String) {
            self.channelArn = channelArn
            self.channelFlowArn = channelFlowArn
            self.chimeBearer = chimeBearer
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.channelArn, key: "ChannelArn")
            try container.encode(self.channelFlowArn, forKey: .channelFlowArn)
            request.encodeHeader(self.chimeBearer, key: "x-amz-chime-bearer")
        }

        public func validate(name: String) throws {
            try self.validate(self.channelArn, name: "channelArn", parent: name, max: 1600)
            try self.validate(self.channelArn, name: "channelArn", parent: name, min: 5)
            try self.validate(self.channelArn, name: "channelArn", parent: name, pattern: "^arn:[a-z0-9-\\.]{1,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[^/].{0,1023}$")
            try self.validate(self.channelFlowArn, name: "channelFlowArn", parent: name, max: 1600)
            try self.validate(self.channelFlowArn, name: "channelFlowArn", parent: name, min: 5)
            try self.validate(self.channelFlowArn, name: "channelFlowArn", parent: name, pattern: "^arn:[a-z0-9-\\.]{1,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[^/].{0,1023}$")
            try self.validate(self.chimeBearer, name: "chimeBearer", parent: name, max: 1600)
            try self.validate(self.chimeBearer, name: "chimeBearer", parent: name, min: 5)
            try self.validate(self.chimeBearer, name: "chimeBearer", parent: name, pattern: "^arn:[a-z0-9-\\.]{1,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[^/].{0,1023}$")
        }

        private enum CodingKeys: String, CodingKey {
            case channelFlowArn = "ChannelFlowArn"
        }
    }

    public struct BadRequestException: AWSErrorShape {
        public let code: ErrorCode?
        public let message: String?

        @inlinable
        public init(code: ErrorCode? = nil, message: String? = nil) {
            self.code = code
            self.message = message
        }

        private enum CodingKeys: String, CodingKey {
            case code = "Code"
            case message = "Message"
        }
    }

    public struct BatchChannelMemberships: AWSDecodableShape {
        /// The ARN of the channel to which you're adding members.
        public let channelArn: String?
        /// The identifier of the member who invited another member.
        public let invitedBy: Identity?
        /// The users successfully added to the request.
        public let members: [Identity]?
        /// The ID of the SubChannel.
        public let subChannelId: String?
        /// The membership types set for the channel members.
        public let type: ChannelMembershipType?

        @inlinable
        public init(channelArn: String? = nil, invitedBy: Identity? = nil, members: [Identity]? = nil, subChannelId: String? = nil, type: ChannelMembershipType? = nil) {
            self.channelArn = channelArn
            self.invitedBy = invitedBy
            self.members = members
            self.subChannelId = subChannelId
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case channelArn = "ChannelArn"
            case invitedBy = "InvitedBy"
            case members = "Members"
            case subChannelId = "SubChannelId"
            case type = "Type"
        }
    }

    public struct BatchCreateChannelMembershipError: AWSDecodableShape {
        /// The error code.
        public let errorCode: ErrorCode?
        /// The error message.
        public let errorMessage: String?
        /// The AppInstanceUserArn of the member that the service couldn't add.
        public let memberArn: String?

        @inlinable
        public init(errorCode: ErrorCode? = nil, errorMessage: String? = nil, memberArn: String? = nil) {
            self.errorCode = errorCode
            self.errorMessage = errorMessage
            self.memberArn = memberArn
        }

        private enum CodingKeys: String, CodingKey {
            case errorCode = "ErrorCode"
            case errorMessage = "ErrorMessage"
            case memberArn = "MemberArn"
        }
    }

    public struct BatchCreateChannelMembershipRequest: AWSEncodableShape {
        /// The ARN of the channel to which you're adding users or bots.
        public let channelArn: String
        /// The ARN of the AppInstanceUser or AppInstanceBot  that makes the API call.
        public let chimeBearer: String
        /// The ARNs of the members you want to add to the channel. Only AppInstanceUsers and  AppInstanceBots can be added as a channel member.
        public let memberArns: [String]
        /// The ID of the SubChannel in the request.   Only required when creating membership in a SubChannel for a moderator in an elastic channel.
        public let subChannelId: String?
        /// The membership type of a user, DEFAULT or HIDDEN. Default members are always returned as part of ListChannelMemberships. Hidden members are only returned if the type filter in ListChannelMemberships equals HIDDEN. Otherwise hidden members are not returned. This is only supported by moderators.
        public let type: ChannelMembershipType?

        @inlinable
        public init(channelArn: String, chimeBearer: String, memberArns: [String], subChannelId: String? = nil, type: ChannelMembershipType? = nil) {
            self.channelArn = channelArn
            self.chimeBearer = chimeBearer
            self.memberArns = memberArns
            self.subChannelId = subChannelId
            self.type = type
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.channelArn, key: "ChannelArn")
            request.encodeHeader(self.chimeBearer, key: "x-amz-chime-bearer")
            try container.encode(self.memberArns, forKey: .memberArns)
            try container.encodeIfPresent(self.subChannelId, forKey: .subChannelId)
            try container.encodeIfPresent(self.type, forKey: .type)
        }

        public func validate(name: String) throws {
            try self.validate(self.channelArn, name: "channelArn", parent: name, max: 1600)
            try self.validate(self.channelArn, name: "channelArn", parent: name, min: 5)
            try self.validate(self.channelArn, name: "channelArn", parent: name, pattern: "^arn:[a-z0-9-\\.]{1,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[^/].{0,1023}$")
            try self.validate(self.chimeBearer, name: "chimeBearer", parent: name, max: 1600)
            try self.validate(self.chimeBearer, name: "chimeBearer", parent: name, min: 5)
            try self.validate(self.chimeBearer, name: "chimeBearer", parent: name, pattern: "^arn:[a-z0-9-\\.]{1,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[^/].{0,1023}$")
            try self.memberArns.forEach {
                try validate($0, name: "memberArns[]", parent: name, max: 1600)
                try validate($0, name: "memberArns[]", parent: name, min: 5)
                try validate($0, name: "memberArns[]", parent: name, pattern: "^arn:[a-z0-9-\\.]{1,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[^/].{0,1023}$")
            }
            try self.validate(self.memberArns, name: "memberArns", parent: name, max: 100)
            try self.validate(self.memberArns, name: "memberArns", parent: name, min: 1)
            try self.validate(self.subChannelId, name: "subChannelId", parent: name, max: 128)
            try self.validate(self.subChannelId, name: "subChannelId", parent: name, min: 1)
            try self.validate(self.subChannelId, name: "subChannelId", parent: name, pattern: "^[-_a-zA-Z0-9]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case memberArns = "MemberArns"
            case subChannelId = "SubChannelId"
            case type = "Type"
        }
    }

    public struct BatchCreateChannelMembershipResponse: AWSDecodableShape {
        /// The list of channel memberships in the response.
        public let batchChannelMemberships: BatchChannelMemberships?
        /// If the action fails for one or more of the memberships in the request, a list of the memberships is returned, along with error codes and error messages.
        public let errors: [BatchCreateChannelMembershipError]?

        @inlinable
        public init(batchChannelMemberships: BatchChannelMemberships? = nil, errors: [BatchCreateChannelMembershipError]? = nil) {
            self.batchChannelMemberships = batchChannelMemberships
            self.errors = errors
        }

        private enum CodingKeys: String, CodingKey {
            case batchChannelMemberships = "BatchChannelMemberships"
            case errors = "Errors"
        }
    }

    public struct Channel: AWSDecodableShape {
        /// The ARN of a channel.
        public let channelArn: String?
        /// The ARN of the channel flow.
        public let channelFlowArn: String?
        /// The AppInstanceUser who created the channel.
        public let createdBy: Identity?
        /// The time at which the AppInstanceUser created the channel.
        public let createdTimestamp: Date?
        /// The attributes required to configure and create an elastic channel. An elastic channel can support a maximum of 1-million members.
        public let elasticChannelConfiguration: ElasticChannelConfiguration?
        /// Settings that control when a channel expires.
        public let expirationSettings: ExpirationSettings?
        /// The time at which a member sent the last message in the channel.
        public let lastMessageTimestamp: Date?
        /// The time at which a channel was last updated.
        public let lastUpdatedTimestamp: Date?
        /// The channel's metadata.
        public let metadata: String?
        /// The mode of the channel.
        public let mode: ChannelMode?
        /// The name of a channel.
        public let name: String?
        /// The channel's privacy setting.
        public let privacy: ChannelPrivacy?

        @inlinable
        public init(channelArn: String? = nil, channelFlowArn: String? = nil, createdBy: Identity? = nil, createdTimestamp: Date? = nil, elasticChannelConfiguration: ElasticChannelConfiguration? = nil, expirationSettings: ExpirationSettings? = nil, lastMessageTimestamp: Date? = nil, lastUpdatedTimestamp: Date? = nil, metadata: String? = nil, mode: ChannelMode? = nil, name: String? = nil, privacy: ChannelPrivacy? = nil) {
            self.channelArn = channelArn
            self.channelFlowArn = channelFlowArn
            self.createdBy = createdBy
            self.createdTimestamp = createdTimestamp
            self.elasticChannelConfiguration = elasticChannelConfiguration
            self.expirationSettings = expirationSettings
            self.lastMessageTimestamp = lastMessageTimestamp
            self.lastUpdatedTimestamp = lastUpdatedTimestamp
            self.metadata = metadata
            self.mode = mode
            self.name = name
            self.privacy = privacy
        }

        private enum CodingKeys: String, CodingKey {
            case channelArn = "ChannelArn"
            case channelFlowArn = "ChannelFlowArn"
            case createdBy = "CreatedBy"
            case createdTimestamp = "CreatedTimestamp"
            case elasticChannelConfiguration = "ElasticChannelConfiguration"
            case expirationSettings = "ExpirationSettings"
            case lastMessageTimestamp = "LastMessageTimestamp"
            case lastUpdatedTimestamp = "LastUpdatedTimestamp"
            case metadata = "Metadata"
            case mode = "Mode"
            case name = "Name"
            case privacy = "Privacy"
        }
    }

    public struct ChannelAssociatedWithFlowSummary: AWSDecodableShape {
        /// The ARN of the channel.
        public let channelArn: String?
        /// The channel's metadata.
        public let metadata: String?
        /// The mode of the channel.
        public let mode: ChannelMode?
        /// The name of the channel flow.
        public let name: String?
        /// The channel's privacy setting.
        public let privacy: ChannelPrivacy?

        @inlinable
        public init(channelArn: String? = nil, metadata: String? = nil, mode: ChannelMode? = nil, name: String? = nil, privacy: ChannelPrivacy? = nil) {
            self.channelArn = channelArn
            self.metadata = metadata
            self.mode = mode
            self.name = name
            self.privacy = privacy
        }

        private enum CodingKeys: String, CodingKey {
            case channelArn = "ChannelArn"
            case metadata = "Metadata"
            case mode = "Mode"
            case name = "Name"
            case privacy = "Privacy"
        }
    }

    public struct ChannelBan: AWSDecodableShape {
        /// The ARN of the channel from which a member is being banned.
        public let channelArn: String?
        /// The AppInstanceUser who created the ban.
        public let createdBy: Identity?
        /// The time at which the ban was created.
        public let createdTimestamp: Date?
        /// The member being banned from the channel.
        public let member: Identity?

        @inlinable
        public init(channelArn: String? = nil, createdBy: Identity? = nil, createdTimestamp: Date? = nil, member: Identity? = nil) {
            self.channelArn = channelArn
            self.createdBy = createdBy
            self.createdTimestamp = createdTimestamp
            self.member = member
        }

        private enum CodingKeys: String, CodingKey {
            case channelArn = "ChannelArn"
            case createdBy = "CreatedBy"
            case createdTimestamp = "CreatedTimestamp"
            case member = "Member"
        }
    }

    public struct ChannelBanSummary: AWSDecodableShape {
        /// The member being banned from a channel.
        public let member: Identity?

        @inlinable
        public init(member: Identity? = nil) {
            self.member = member
        }

        private enum CodingKeys: String, CodingKey {
            case member = "Member"
        }
    }

    public struct ChannelFlow: AWSDecodableShape {
        /// The ARN of the channel flow.
        public let channelFlowArn: String?
        /// The time at which the channel flow was created.
        public let createdTimestamp: Date?
        /// The time at which a channel flow was updated.
        public let lastUpdatedTimestamp: Date?
        /// The name of the channel flow.
        public let name: String?
        /// Information about the processor Lambda functions.
        public let processors: [Processor]?

        @inlinable
        public init(channelFlowArn: String? = nil, createdTimestamp: Date? = nil, lastUpdatedTimestamp: Date? = nil, name: String? = nil, processors: [Processor]? = nil) {
            self.channelFlowArn = channelFlowArn
            self.createdTimestamp = createdTimestamp
            self.lastUpdatedTimestamp = lastUpdatedTimestamp
            self.name = name
            self.processors = processors
        }

        private enum CodingKeys: String, CodingKey {
            case channelFlowArn = "ChannelFlowArn"
            case createdTimestamp = "CreatedTimestamp"
            case lastUpdatedTimestamp = "LastUpdatedTimestamp"
            case name = "Name"
            case processors = "Processors"
        }
    }

    public struct ChannelFlowCallbackRequest: AWSEncodableShape {
        /// The identifier passed to the processor by the service when invoked. Use the identifier to call back the service.
        public let callbackId: String
        /// The ARN of the channel.
        public let channelArn: String
        /// Stores information about the processed message.
        public let channelMessage: ChannelMessageCallback
        /// When a processor determines that a message needs to be DENIED, pass this parameter with a value of true.
        public let deleteResource: Bool?

        @inlinable
        public init(callbackId: String = ChannelFlowCallbackRequest.idempotencyToken(), channelArn: String, channelMessage: ChannelMessageCallback, deleteResource: Bool? = nil) {
            self.callbackId = callbackId
            self.channelArn = channelArn
            self.channelMessage = channelMessage
            self.deleteResource = deleteResource
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encode(self.callbackId, forKey: .callbackId)
            request.encodePath(self.channelArn, key: "ChannelArn")
            try container.encode(self.channelMessage, forKey: .channelMessage)
            try container.encodeIfPresent(self.deleteResource, forKey: .deleteResource)
        }

        public func validate(name: String) throws {
            try self.validate(self.callbackId, name: "callbackId", parent: name, max: 64)
            try self.validate(self.callbackId, name: "callbackId", parent: name, min: 32)
            try self.validate(self.channelArn, name: "channelArn", parent: name, max: 1600)
            try self.validate(self.channelArn, name: "channelArn", parent: name, min: 5)
            try self.validate(self.channelArn, name: "channelArn", parent: name, pattern: "^arn:[a-z0-9-\\.]{1,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[^/].{0,1023}$")
            try self.channelMessage.validate(name: "\(name).channelMessage")
        }

        private enum CodingKeys: String, CodingKey {
            case callbackId = "CallbackId"
            case channelMessage = "ChannelMessage"
            case deleteResource = "DeleteResource"
        }
    }

    public struct ChannelFlowCallbackResponse: AWSDecodableShape {
        /// The call back ID passed in the request.
        public let callbackId: String?
        /// The ARN of the channel.
        public let channelArn: String?

        @inlinable
        public init(callbackId: String? = nil, channelArn: String? = nil) {
            self.callbackId = callbackId
            self.channelArn = channelArn
        }

        private enum CodingKeys: String, CodingKey {
            case callbackId = "CallbackId"
            case channelArn = "ChannelArn"
        }
    }

    public struct ChannelFlowSummary: AWSDecodableShape {
        /// The ARN of the channel flow.
        public let channelFlowArn: String?
        /// The name of the channel flow.
        public let name: String?
        /// Information about the processor Lambda functions.
        public let processors: [Processor]?

        @inlinable
        public init(channelFlowArn: String? = nil, name: String? = nil, processors: [Processor]? = nil) {
            self.channelFlowArn = channelFlowArn
            self.name = name
            self.processors = processors
        }

        private enum CodingKeys: String, CodingKey {
            case channelFlowArn = "ChannelFlowArn"
            case name = "Name"
            case processors = "Processors"
        }
    }

    public struct ChannelMembership: AWSDecodableShape {
        /// The ARN of the member's channel.
        public let channelArn: String?
        /// The time at which the channel membership was created.
        public let createdTimestamp: Date?
        /// The identifier of the member who invited another member.
        public let invitedBy: Identity?
        /// The time at which a channel membership was last updated.
        public let lastUpdatedTimestamp: Date?
        /// The data of the channel member.
        public let member: Identity?
        /// The ID of the SubChannel that a user belongs to.
        public let subChannelId: String?
        /// The membership type set for the channel member.
        public let type: ChannelMembershipType?

        @inlinable
        public init(channelArn: String? = nil, createdTimestamp: Date? = nil, invitedBy: Identity? = nil, lastUpdatedTimestamp: Date? = nil, member: Identity? = nil, subChannelId: String? = nil, type: ChannelMembershipType? = nil) {
            self.channelArn = channelArn
            self.createdTimestamp = createdTimestamp
            self.invitedBy = invitedBy
            self.lastUpdatedTimestamp = lastUpdatedTimestamp
            self.member = member
            self.subChannelId = subChannelId
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case channelArn = "ChannelArn"
            case createdTimestamp = "CreatedTimestamp"
            case invitedBy = "InvitedBy"
            case lastUpdatedTimestamp = "LastUpdatedTimestamp"
            case member = "Member"
            case subChannelId = "SubChannelId"
            case type = "Type"
        }
    }

    public struct ChannelMembershipForAppInstanceUserSummary: AWSDecodableShape {
        /// Returns the channel membership data for an AppInstance.
        public let appInstanceUserMembershipSummary: AppInstanceUserMembershipSummary?
        /// Returns the channel data for an AppInstance.
        public let channelSummary: ChannelSummary?

        @inlinable
        public init(appInstanceUserMembershipSummary: AppInstanceUserMembershipSummary? = nil, channelSummary: ChannelSummary? = nil) {
            self.appInstanceUserMembershipSummary = appInstanceUserMembershipSummary
            self.channelSummary = channelSummary
        }

        private enum CodingKeys: String, CodingKey {
            case appInstanceUserMembershipSummary = "AppInstanceUserMembershipSummary"
            case channelSummary = "ChannelSummary"
        }
    }

    public struct ChannelMembershipPreferences: AWSEncodableShape & AWSDecodableShape {
        /// The push notification configuration of a message.
        public let pushNotifications: PushNotificationPreferences?

        @inlinable
        public init(pushNotifications: PushNotificationPreferences? = nil) {
            self.pushNotifications = pushNotifications
        }

        public func validate(name: String) throws {
            try self.pushNotifications?.validate(name: "\(name).pushNotifications")
        }

        private enum CodingKeys: String, CodingKey {
            case pushNotifications = "PushNotifications"
        }
    }

    public struct ChannelMembershipSummary: AWSDecodableShape {
        /// A member's summary data.
        public let member: Identity?

        @inlinable
        public init(member: Identity? = nil) {
            self.member = member
        }

        private enum CodingKeys: String, CodingKey {
            case member = "Member"
        }
    }

    public struct ChannelMessage: AWSDecodableShape {
        /// The ARN of the channel.
        public let channelArn: String?
        /// The content of the channel message. For Amazon Lex V2 bot responses, this field holds a list of messages originating from the bot. For more information, refer to  Processing responses from an AppInstanceBot in the  Amazon Chime SDK Messaging Developer Guide.
        public let content: String?
        /// The content type of the channel message. For Amazon Lex V2 bot responses, the content type is application/amz-chime-lex-msgs for success responses and  application/amz-chime-lex-error for failure responses. For more information, refer to  Processing responses from an AppInstanceBot in the  Amazon Chime SDK Messaging Developer Guide.
        public let contentType: String?
        /// The time at which the message was created.
        public let createdTimestamp: Date?
        /// The time at which a message was edited.
        public let lastEditedTimestamp: Date?
        /// The time at which a message was updated.
        public let lastUpdatedTimestamp: Date?
        /// The attributes for the channel message. For Amazon Lex V2 bot responses, the attributes are mapped to specific fields from the bot. For more information, refer to  Processing responses from an AppInstanceBot in the  Amazon Chime SDK Messaging Developer Guide.
        public let messageAttributes: [String: MessageAttributeValue]?
        /// The ID of a message.
        public let messageId: String?
        /// The message metadata.
        public let metadata: String?
        /// The persistence setting for a channel message.
        public let persistence: ChannelMessagePersistenceType?
        /// Hides the content of a message.
        public let redacted: Bool?
        /// The message sender.
        public let sender: Identity?
        /// The status of the channel message.
        public let status: ChannelMessageStatusStructure?
        /// The ID of the SubChannel.
        public let subChannelId: String?
        /// The target of a message, a sender, a user, or a bot.  Only the target and the sender can view targeted messages. Only users who can see targeted messages can take actions on them. However, administrators can delete targeted messages that they can’t see.
        public let target: [Target]?
        /// The message type.
        public let type: ChannelMessageType?

        @inlinable
        public init(channelArn: String? = nil, content: String? = nil, contentType: String? = nil, createdTimestamp: Date? = nil, lastEditedTimestamp: Date? = nil, lastUpdatedTimestamp: Date? = nil, messageAttributes: [String: MessageAttributeValue]? = nil, messageId: String? = nil, metadata: String? = nil, persistence: ChannelMessagePersistenceType? = nil, redacted: Bool? = nil, sender: Identity? = nil, status: ChannelMessageStatusStructure? = nil, subChannelId: String? = nil, target: [Target]? = nil, type: ChannelMessageType? = nil) {
            self.channelArn = channelArn
            self.content = content
            self.contentType = contentType
            self.createdTimestamp = createdTimestamp
            self.lastEditedTimestamp = lastEditedTimestamp
            self.lastUpdatedTimestamp = lastUpdatedTimestamp
            self.messageAttributes = messageAttributes
            self.messageId = messageId
            self.metadata = metadata
            self.persistence = persistence
            self.redacted = redacted
            self.sender = sender
            self.status = status
            self.subChannelId = subChannelId
            self.target = target
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case channelArn = "ChannelArn"
            case content = "Content"
            case contentType = "ContentType"
            case createdTimestamp = "CreatedTimestamp"
            case lastEditedTimestamp = "LastEditedTimestamp"
            case lastUpdatedTimestamp = "LastUpdatedTimestamp"
            case messageAttributes = "MessageAttributes"
            case messageId = "MessageId"
            case metadata = "Metadata"
            case persistence = "Persistence"
            case redacted = "Redacted"
            case sender = "Sender"
            case status = "Status"
            case subChannelId = "SubChannelId"
            case target = "Target"
            case type = "Type"
        }
    }

    public struct ChannelMessageCallback: AWSEncodableShape {
        /// The message content. For Amazon Lex V2 bot responses, this field holds a list of messages originating from the bot. For more information, refer to  Processing responses from an AppInstanceBot in the  Amazon Chime SDK Messaging Developer Guide.
        public let content: String?
        /// The content type of the call-back message. For Amazon Lex V2 bot responses, the content type is application/amz-chime-lex-msgs for success responses and  application/amz-chime-lex-error for failure responses. For more information, refer to  Processing responses from an AppInstanceBot in the  Amazon Chime SDK Messaging Developer Guide.
        public let contentType: String?
        /// The attributes for the channel message. For Amazon Lex V2 bot responses, the attributes are mapped to specific fields from the bot. For more information, refer to  Processing responses from an AppInstanceBot in the  Amazon Chime SDK Messaging Developer Guide.
        public let messageAttributes: [String: MessageAttributeValue]?
        /// The message ID.
        public let messageId: String
        /// The message metadata.
        public let metadata: String?
        /// The push notification configuration of the message.
        public let pushNotification: PushNotificationConfiguration?
        /// The ID of the SubChannel.
        public let subChannelId: String?

        @inlinable
        public init(content: String? = nil, contentType: String? = nil, messageAttributes: [String: MessageAttributeValue]? = nil, messageId: String, metadata: String? = nil, pushNotification: PushNotificationConfiguration? = nil, subChannelId: String? = nil) {
            self.content = content
            self.contentType = contentType
            self.messageAttributes = messageAttributes
            self.messageId = messageId
            self.metadata = metadata
            self.pushNotification = pushNotification
            self.subChannelId = subChannelId
        }

        public func validate(name: String) throws {
            try self.validate(self.content, name: "content", parent: name, min: 1)
            try self.validate(self.content, name: "content", parent: name, pattern: "^[\\s\\S]*$")
            try self.validate(self.contentType, name: "contentType", parent: name, max: 45)
            try self.validate(self.contentType, name: "contentType", parent: name, pattern: "^[\\s\\S]*$")
            try self.messageAttributes?.forEach {
                try validate($0.key, name: "messageAttributes.key", parent: name, max: 64)
                try validate($0.key, name: "messageAttributes.key", parent: name, min: 1)
                try validate($0.key, name: "messageAttributes.key", parent: name, pattern: "^[\\s\\S]*$")
                try $0.value.validate(name: "\(name).messageAttributes[\"\($0.key)\"]")
            }
            try self.validate(self.messageId, name: "messageId", parent: name, max: 128)
            try self.validate(self.messageId, name: "messageId", parent: name, min: 1)
            try self.validate(self.messageId, name: "messageId", parent: name, pattern: "^[-_a-zA-Z0-9]*$")
            try self.validate(self.metadata, name: "metadata", parent: name, max: 1024)
            try self.validate(self.metadata, name: "metadata", parent: name, pattern: ".*")
            try self.pushNotification?.validate(name: "\(name).pushNotification")
            try self.validate(self.subChannelId, name: "subChannelId", parent: name, max: 128)
            try self.validate(self.subChannelId, name: "subChannelId", parent: name, min: 1)
            try self.validate(self.subChannelId, name: "subChannelId", parent: name, pattern: "^[-_a-zA-Z0-9]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case content = "Content"
            case contentType = "ContentType"
            case messageAttributes = "MessageAttributes"
            case messageId = "MessageId"
            case metadata = "Metadata"
            case pushNotification = "PushNotification"
            case subChannelId = "SubChannelId"
        }
    }

    public struct ChannelMessageStatusStructure: AWSDecodableShape {
        /// Contains more details about the message status.
        public let detail: String?
        /// The message status value.
        public let value: ChannelMessageStatus?

        @inlinable
        public init(detail: String? = nil, value: ChannelMessageStatus? = nil) {
            self.detail = detail
            self.value = value
        }

        private enum CodingKeys: String, CodingKey {
            case detail = "Detail"
            case value = "Value"
        }
    }

    public struct ChannelMessageSummary: AWSDecodableShape {
        /// The content of the channel message. For Amazon Lex V2 bot responses, this field holds a list of messages originating from the bot. For more information, refer to  Processing responses from an AppInstanceBot in the  Amazon Chime SDK Messaging Developer Guide.
        public let content: String?
        /// The content type of the channel message listed in the summary. For Amazon Lex V2 bot responses, the content type is application/amz-chime-lex-msgs for success responses and  application/amz-chime-lex-error for failure responses. For more information, refer to  Processing responses from an AppInstanceBot in the  Amazon Chime SDK Messaging Developer Guide.
        public let contentType: String?
        /// The time at which the message summary was created.
        public let createdTimestamp: Date?
        /// The time at which a message was last edited.
        public let lastEditedTimestamp: Date?
        /// The time at which a message was last updated.
        public let lastUpdatedTimestamp: Date?
        /// The attributes for the channel message. For Amazon Lex V2 bot responses, the attributes are mapped to specific fields from the bot. For more information, refer to  Processing responses from an AppInstanceBot in the  Amazon Chime SDK Messaging Developer Guide.
        public let messageAttributes: [String: MessageAttributeValue]?
        /// The ID of the message.
        public let messageId: String?
        /// The metadata of the message.
        public let metadata: String?
        /// Indicates whether a message was redacted.
        public let redacted: Bool?
        /// The message sender.
        public let sender: Identity?
        /// The message status. The status value is SENT for messages sent to a channel without a channel flow. For channels associated with channel flow, the value determines the  processing stage.
        public let status: ChannelMessageStatusStructure?
        /// The target of a message, a sender, a user, or a bot. Only the target and the sender can view targeted messages. Only users who can see targeted messages can take actions on them. However, administrators can delete targeted messages that they can’t see.
        public let target: [Target]?
        /// The type of message.
        public let type: ChannelMessageType?

        @inlinable
        public init(content: String? = nil, contentType: String? = nil, createdTimestamp: Date? = nil, lastEditedTimestamp: Date? = nil, lastUpdatedTimestamp: Date? = nil, messageAttributes: [String: MessageAttributeValue]? = nil, messageId: String? = nil, metadata: String? = nil, redacted: Bool? = nil, sender: Identity? = nil, status: ChannelMessageStatusStructure? = nil, target: [Target]? = nil, type: ChannelMessageType? = nil) {
            self.content = content
            self.contentType = contentType
            self.createdTimestamp = createdTimestamp
            self.lastEditedTimestamp = lastEditedTimestamp
            self.lastUpdatedTimestamp = lastUpdatedTimestamp
            self.messageAttributes = messageAttributes
            self.messageId = messageId
            self.metadata = metadata
            self.redacted = redacted
            self.sender = sender
            self.status = status
            self.target = target
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case content = "Content"
            case contentType = "ContentType"
            case createdTimestamp = "CreatedTimestamp"
            case lastEditedTimestamp = "LastEditedTimestamp"
            case lastUpdatedTimestamp = "LastUpdatedTimestamp"
            case messageAttributes = "MessageAttributes"
            case messageId = "MessageId"
            case metadata = "Metadata"
            case redacted = "Redacted"
            case sender = "Sender"
            case status = "Status"
            case target = "Target"
            case type = "Type"
        }
    }

    public struct ChannelModeratedByAppInstanceUserSummary: AWSDecodableShape {
        /// Summary of the details of a Channel.
        public let channelSummary: ChannelSummary?

        @inlinable
        public init(channelSummary: ChannelSummary? = nil) {
            self.channelSummary = channelSummary
        }

        private enum CodingKeys: String, CodingKey {
            case channelSummary = "ChannelSummary"
        }
    }

    public struct ChannelModerator: AWSDecodableShape {
        /// The ARN of the moderator's channel.
        public let channelArn: String?
        /// The AppInstanceUser who created the moderator.
        public let createdBy: Identity?
        /// The time at which the moderator was created.
        public let createdTimestamp: Date?
        /// The moderator's data.
        public let moderator: Identity?

        @inlinable
        public init(channelArn: String? = nil, createdBy: Identity? = nil, createdTimestamp: Date? = nil, moderator: Identity? = nil) {
            self.channelArn = channelArn
            self.createdBy = createdBy
            self.createdTimestamp = createdTimestamp
            self.moderator = moderator
        }

        private enum CodingKeys: String, CodingKey {
            case channelArn = "ChannelArn"
            case createdBy = "CreatedBy"
            case createdTimestamp = "CreatedTimestamp"
            case moderator = "Moderator"
        }
    }

    public struct ChannelModeratorSummary: AWSDecodableShape {
        /// The data for a moderator.
        public let moderator: Identity?

        @inlinable
        public init(moderator: Identity? = nil) {
            self.moderator = moderator
        }

        private enum CodingKeys: String, CodingKey {
            case moderator = "Moderator"
        }
    }

    public struct ChannelSummary: AWSDecodableShape {
        /// The ARN of the channel.
        public let channelArn: String?
        /// The time at which the last persistent message visible to the caller in a channel was sent.
        public let lastMessageTimestamp: Date?
        /// The metadata of the channel.
        public let metadata: String?
        /// The mode of the channel.
        public let mode: ChannelMode?
        /// The name of the channel.
        public let name: String?
        /// The privacy setting of the channel.
        public let privacy: ChannelPrivacy?

        @inlinable
        public init(channelArn: String? = nil, lastMessageTimestamp: Date? = nil, metadata: String? = nil, mode: ChannelMode? = nil, name: String? = nil, privacy: ChannelPrivacy? = nil) {
            self.channelArn = channelArn
            self.lastMessageTimestamp = lastMessageTimestamp
            self.metadata = metadata
            self.mode = mode
            self.name = name
            self.privacy = privacy
        }

        private enum CodingKeys: String, CodingKey {
            case channelArn = "ChannelArn"
            case lastMessageTimestamp = "LastMessageTimestamp"
            case metadata = "Metadata"
            case mode = "Mode"
            case name = "Name"
            case privacy = "Privacy"
        }
    }

    public struct ConflictException: AWSErrorShape {
        public let code: ErrorCode?
        public let message: String?

        @inlinable
        public init(code: ErrorCode? = nil, message: String? = nil) {
            self.code = code
            self.message = message
        }

        private enum CodingKeys: String, CodingKey {
            case code = "Code"
            case message = "Message"
        }
    }

    public struct CreateChannelBanRequest: AWSEncodableShape {
        /// The ARN of the ban request.
        public let channelArn: String
        /// The ARN of the AppInstanceUser or AppInstanceBot that makes the API call.
        public let chimeBearer: String
        /// The AppInstanceUserArn of the member being banned.
        public let memberArn: String

        @inlinable
        public init(channelArn: String, chimeBearer: String, memberArn: String) {
            self.channelArn = channelArn
            self.chimeBearer = chimeBearer
            self.memberArn = memberArn
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.channelArn, key: "ChannelArn")
            request.encodeHeader(self.chimeBearer, key: "x-amz-chime-bearer")
            try container.encode(self.memberArn, forKey: .memberArn)
        }

        public func validate(name: String) throws {
            try self.validate(self.channelArn, name: "channelArn", parent: name, max: 1600)
            try self.validate(self.channelArn, name: "channelArn", parent: name, min: 5)
            try self.validate(self.channelArn, name: "channelArn", parent: name, pattern: "^arn:[a-z0-9-\\.]{1,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[^/].{0,1023}$")
            try self.validate(self.chimeBearer, name: "chimeBearer", parent: name, max: 1600)
            try self.validate(self.chimeBearer, name: "chimeBearer", parent: name, min: 5)
            try self.validate(self.chimeBearer, name: "chimeBearer", parent: name, pattern: "^arn:[a-z0-9-\\.]{1,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[^/].{0,1023}$")
            try self.validate(self.memberArn, name: "memberArn", parent: name, max: 1600)
            try self.validate(self.memberArn, name: "memberArn", parent: name, min: 5)
            try self.validate(self.memberArn, name: "memberArn", parent: name, pattern: "^arn:[a-z0-9-\\.]{1,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[^/].{0,1023}$")
        }

        private enum CodingKeys: String, CodingKey {
            case memberArn = "MemberArn"
        }
    }

    public struct CreateChannelBanResponse: AWSDecodableShape {
        /// The ARN of the response to the ban request.
        public let channelArn: String?
        /// The ChannelArn and BannedIdentity of the member in the ban response.
        public let member: Identity?

        @inlinable
        public init(channelArn: String? = nil, member: Identity? = nil) {
            self.channelArn = channelArn
            self.member = member
        }

        private enum CodingKeys: String, CodingKey {
            case channelArn = "ChannelArn"
            case member = "Member"
        }
    }

    public struct CreateChannelFlowRequest: AWSEncodableShape {
        /// The ARN of the channel flow request.
        public let appInstanceArn: String
        /// The client token for the request. An Idempotency token.
        public let clientRequestToken: String
        /// The name of the channel flow.
        public let name: String
        /// Information about the processor Lambda functions.
        public let processors: [Processor]
        /// The tags for the creation request.
        public let tags: [Tag]?

        @inlinable
        public init(appInstanceArn: String, clientRequestToken: String = CreateChannelFlowRequest.idempotencyToken(), name: String, processors: [Processor], tags: [Tag]? = nil) {
            self.appInstanceArn = appInstanceArn
            self.clientRequestToken = clientRequestToken
            self.name = name
            self.processors = processors
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.validate(self.appInstanceArn, name: "appInstanceArn", parent: name, max: 1600)
            try self.validate(self.appInstanceArn, name: "appInstanceArn", parent: name, min: 5)
            try self.validate(self.appInstanceArn, name: "appInstanceArn", parent: name, pattern: "^arn:[a-z0-9-\\.]{1,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[^/].{0,1023}$")
            try self.validate(self.clientRequestToken, name: "clientRequestToken", parent: name, max: 64)
            try self.validate(self.clientRequestToken, name: "clientRequestToken", parent: name, min: 2)
            try self.validate(self.clientRequestToken, name: "clientRequestToken", parent: name, pattern: "^[-_a-zA-Z0-9]*$")
            try self.validate(self.name, name: "name", parent: name, max: 256)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[\\u0009\\u000A\\u000D\\u0020-\\u007E\\u0085\\u00A0-\\uD7FF\\uE000-\\uFFFD\\u10000-\\u10FFFF]*$")
            try self.processors.forEach {
                try $0.validate(name: "\(name).processors[]")
            }
            try self.validate(self.processors, name: "processors", parent: name, max: 3)
            try self.validate(self.processors, name: "processors", parent: name, min: 1)
            try self.tags?.forEach {
                try $0.validate(name: "\(name).tags[]")
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 50)
            try self.validate(self.tags, name: "tags", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case appInstanceArn = "AppInstanceArn"
            case clientRequestToken = "ClientRequestToken"
            case name = "Name"
            case processors = "Processors"
            case tags = "Tags"
        }
    }

    public struct CreateChannelFlowResponse: AWSDecodableShape {
        /// The ARN of the channel flow.
        public let channelFlowArn: String?

        @inlinable
        public init(channelFlowArn: String? = nil) {
            self.channelFlowArn = channelFlowArn
        }

        private enum CodingKeys: String, CodingKey {
            case channelFlowArn = "ChannelFlowArn"
        }
    }

    public struct CreateChannelMembershipRequest: AWSEncodableShape {
        /// The ARN of the channel to which you're adding users.
        public let channelArn: String
        /// The ARN of the AppInstanceUser or AppInstanceBot  that makes the API call.
        public let chimeBearer: String
        /// The AppInstanceUserArn of the member you want to add to the channel.
        public let memberArn: String
        /// The ID of the SubChannel in the request.  Only required when creating membership in a SubChannel for a moderator in an elastic channel.
        public let subChannelId: String?
        /// The membership type of a user, DEFAULT or HIDDEN. Default members are always returned as part of ListChannelMemberships. Hidden members are only returned if the type filter in ListChannelMemberships equals HIDDEN. Otherwise hidden members are not returned. This is only supported by moderators.
        public let type: ChannelMembershipType

        @inlinable
        public init(channelArn: String, chimeBearer: String, memberArn: String, subChannelId: String? = nil, type: ChannelMembershipType) {
            self.channelArn = channelArn
            self.chimeBearer = chimeBearer
            self.memberArn = memberArn
            self.subChannelId = subChannelId
            self.type = type
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.channelArn, key: "ChannelArn")
            request.encodeHeader(self.chimeBearer, key: "x-amz-chime-bearer")
            try container.encode(self.memberArn, forKey: .memberArn)
            try container.encodeIfPresent(self.subChannelId, forKey: .subChannelId)
            try container.encode(self.type, forKey: .type)
        }

        public func validate(name: String) throws {
            try self.validate(self.channelArn, name: "channelArn", parent: name, max: 1600)
            try self.validate(self.channelArn, name: "channelArn", parent: name, min: 5)
            try self.validate(self.channelArn, name: "channelArn", parent: name, pattern: "^arn:[a-z0-9-\\.]{1,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[^/].{0,1023}$")
            try self.validate(self.chimeBearer, name: "chimeBearer", parent: name, max: 1600)
            try self.validate(self.chimeBearer, name: "chimeBearer", parent: name, min: 5)
            try self.validate(self.chimeBearer, name: "chimeBearer", parent: name, pattern: "^arn:[a-z0-9-\\.]{1,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[^/].{0,1023}$")
            try self.validate(self.memberArn, name: "memberArn", parent: name, max: 1600)
            try self.validate(self.memberArn, name: "memberArn", parent: name, min: 5)
            try self.validate(self.memberArn, name: "memberArn", parent: name, pattern: "^arn:[a-z0-9-\\.]{1,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[^/].{0,1023}$")
            try self.validate(self.subChannelId, name: "subChannelId", parent: name, max: 128)
            try self.validate(self.subChannelId, name: "subChannelId", parent: name, min: 1)
            try self.validate(self.subChannelId, name: "subChannelId", parent: name, pattern: "^[-_a-zA-Z0-9]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case memberArn = "MemberArn"
            case subChannelId = "SubChannelId"
            case type = "Type"
        }
    }

    public struct CreateChannelMembershipResponse: AWSDecodableShape {
        /// The ARN of the channel.
        public let channelArn: String?
        /// The ARN and metadata of the member being added.
        public let member: Identity?
        /// The ID of the SubChannel in the response.
        public let subChannelId: String?

        @inlinable
        public init(channelArn: String? = nil, member: Identity? = nil, subChannelId: String? = nil) {
            self.channelArn = channelArn
            self.member = member
            self.subChannelId = subChannelId
        }

        private enum CodingKeys: String, CodingKey {
            case channelArn = "ChannelArn"
            case member = "Member"
            case subChannelId = "SubChannelId"
        }
    }

    public struct CreateChannelModeratorRequest: AWSEncodableShape {
        /// The ARN of the channel.
        public let channelArn: String
        /// The AppInstanceUserArn of the moderator.
        public let channelModeratorArn: String
        /// The ARN of the AppInstanceUser or AppInstanceBot  that makes the API call.
        public let chimeBearer: String

        @inlinable
        public init(channelArn: String, channelModeratorArn: String, chimeBearer: String) {
            self.channelArn = channelArn
            self.channelModeratorArn = channelModeratorArn
            self.chimeBearer = chimeBearer
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.channelArn, key: "ChannelArn")
            try container.encode(self.channelModeratorArn, forKey: .channelModeratorArn)
            request.encodeHeader(self.chimeBearer, key: "x-amz-chime-bearer")
        }

        public func validate(name: String) throws {
            try self.validate(self.channelArn, name: "channelArn", parent: name, max: 1600)
            try self.validate(self.channelArn, name: "channelArn", parent: name, min: 5)
            try self.validate(self.channelArn, name: "channelArn", parent: name, pattern: "^arn:[a-z0-9-\\.]{1,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[^/].{0,1023}$")
            try self.validate(self.channelModeratorArn, name: "channelModeratorArn", parent: name, max: 1600)
            try self.validate(self.channelModeratorArn, name: "channelModeratorArn", parent: name, min: 5)
            try self.validate(self.channelModeratorArn, name: "channelModeratorArn", parent: name, pattern: "^arn:[a-z0-9-\\.]{1,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[^/].{0,1023}$")
            try self.validate(self.chimeBearer, name: "chimeBearer", parent: name, max: 1600)
            try self.validate(self.chimeBearer, name: "chimeBearer", parent: name, min: 5)
            try self.validate(self.chimeBearer, name: "chimeBearer", parent: name, pattern: "^arn:[a-z0-9-\\.]{1,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[^/].{0,1023}$")
        }

        private enum CodingKeys: String, CodingKey {
            case channelModeratorArn = "ChannelModeratorArn"
        }
    }

    public struct CreateChannelModeratorResponse: AWSDecodableShape {
        /// The ARN of the channel.
        public let channelArn: String?
        /// The ARNs of the channel and the moderator.
        public let channelModerator: Identity?

        @inlinable
        public init(channelArn: String? = nil, channelModerator: Identity? = nil) {
            self.channelArn = channelArn
            self.channelModerator = channelModerator
        }

        private enum CodingKeys: String, CodingKey {
            case channelArn = "ChannelArn"
            case channelModerator = "ChannelModerator"
        }
    }

    public struct CreateChannelRequest: AWSEncodableShape {
        /// The ARN of the channel request.
        public let appInstanceArn: String
        /// The ID of the channel in the request.
        public let channelId: String?
        /// The ARN of the AppInstanceUser or AppInstanceBot that makes the API call.
        public let chimeBearer: String
        /// The client token for the request. An Idempotency token.
        public let clientRequestToken: String
        /// The attributes required to configure and create an elastic channel. An elastic channel can support a maximum of 1-million users, excluding moderators.
        public let elasticChannelConfiguration: ElasticChannelConfiguration?
        /// Settings that control the interval after which the channel is automatically deleted.
        public let expirationSettings: ExpirationSettings?
        /// The ARNs of the channel members in the request.
        public let memberArns: [String]?
        /// The metadata of the creation request. Limited to 1KB and UTF-8.
        public let metadata: String?
        /// The channel mode: UNRESTRICTED or RESTRICTED. Administrators, moderators, and channel members can add themselves and other members to unrestricted channels. Only administrators and moderators can add members to restricted channels.
        public let mode: ChannelMode?
        /// The ARNs of the channel moderators in the request.
        public let moderatorArns: [String]?
        /// The name of the channel.
        public let name: String
        /// The channel's privacy level: PUBLIC or PRIVATE. Private channels aren't discoverable by users outside the channel. Public channels are discoverable by anyone in the AppInstance.
        public let privacy: ChannelPrivacy?
        /// The tags for the creation request.
        public let tags: [Tag]?

        @inlinable
        public init(appInstanceArn: String, channelId: String? = nil, chimeBearer: String, clientRequestToken: String = CreateChannelRequest.idempotencyToken(), elasticChannelConfiguration: ElasticChannelConfiguration? = nil, expirationSettings: ExpirationSettings? = nil, memberArns: [String]? = nil, metadata: String? = nil, mode: ChannelMode? = nil, moderatorArns: [String]? = nil, name: String, privacy: ChannelPrivacy? = nil, tags: [Tag]? = nil) {
            self.appInstanceArn = appInstanceArn
            self.channelId = channelId
            self.chimeBearer = chimeBearer
            self.clientRequestToken = clientRequestToken
            self.elasticChannelConfiguration = elasticChannelConfiguration
            self.expirationSettings = expirationSettings
            self.memberArns = memberArns
            self.metadata = metadata
            self.mode = mode
            self.moderatorArns = moderatorArns
            self.name = name
            self.privacy = privacy
            self.tags = tags
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encode(self.appInstanceArn, forKey: .appInstanceArn)
            try container.encodeIfPresent(self.channelId, forKey: .channelId)
            request.encodeHeader(self.chimeBearer, key: "x-amz-chime-bearer")
            try container.encode(self.clientRequestToken, forKey: .clientRequestToken)
            try container.encodeIfPresent(self.elasticChannelConfiguration, forKey: .elasticChannelConfiguration)
            try container.encodeIfPresent(self.expirationSettings, forKey: .expirationSettings)
            try container.encodeIfPresent(self.memberArns, forKey: .memberArns)
            try container.encodeIfPresent(self.metadata, forKey: .metadata)
            try container.encodeIfPresent(self.mode, forKey: .mode)
            try container.encodeIfPresent(self.moderatorArns, forKey: .moderatorArns)
            try container.encode(self.name, forKey: .name)
            try container.encodeIfPresent(self.privacy, forKey: .privacy)
            try container.encodeIfPresent(self.tags, forKey: .tags)
        }

        public func validate(name: String) throws {
            try self.validate(self.appInstanceArn, name: "appInstanceArn", parent: name, max: 1600)
            try self.validate(self.appInstanceArn, name: "appInstanceArn", parent: name, min: 5)
            try self.validate(self.appInstanceArn, name: "appInstanceArn", parent: name, pattern: "^arn:[a-z0-9-\\.]{1,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[^/].{0,1023}$")
            try self.validate(self.channelId, name: "channelId", parent: name, max: 64)
            try self.validate(self.channelId, name: "channelId", parent: name, min: 1)
            try self.validate(self.channelId, name: "channelId", parent: name, pattern: "^[A-Za-z0-9]([A-Za-z0-9\\:\\-\\_\\.\\@]{0,62}[A-Za-z0-9])?$")
            try self.validate(self.chimeBearer, name: "chimeBearer", parent: name, max: 1600)
            try self.validate(self.chimeBearer, name: "chimeBearer", parent: name, min: 5)
            try self.validate(self.chimeBearer, name: "chimeBearer", parent: name, pattern: "^arn:[a-z0-9-\\.]{1,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[^/].{0,1023}$")
            try self.validate(self.clientRequestToken, name: "clientRequestToken", parent: name, max: 64)
            try self.validate(self.clientRequestToken, name: "clientRequestToken", parent: name, min: 2)
            try self.validate(self.clientRequestToken, name: "clientRequestToken", parent: name, pattern: "^[-_a-zA-Z0-9]*$")
            try self.elasticChannelConfiguration?.validate(name: "\(name).elasticChannelConfiguration")
            try self.expirationSettings?.validate(name: "\(name).expirationSettings")
            try self.memberArns?.forEach {
                try validate($0, name: "memberArns[]", parent: name, max: 1600)
                try validate($0, name: "memberArns[]", parent: name, min: 5)
                try validate($0, name: "memberArns[]", parent: name, pattern: "^arn:[a-z0-9-\\.]{1,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[^/].{0,1023}$")
            }
            try self.validate(self.memberArns, name: "memberArns", parent: name, max: 10)
            try self.validate(self.memberArns, name: "memberArns", parent: name, min: 1)
            try self.validate(self.metadata, name: "metadata", parent: name, max: 1024)
            try self.validate(self.metadata, name: "metadata", parent: name, pattern: ".*")
            try self.moderatorArns?.forEach {
                try validate($0, name: "moderatorArns[]", parent: name, max: 1600)
                try validate($0, name: "moderatorArns[]", parent: name, min: 5)
                try validate($0, name: "moderatorArns[]", parent: name, pattern: "^arn:[a-z0-9-\\.]{1,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[^/].{0,1023}$")
            }
            try self.validate(self.moderatorArns, name: "moderatorArns", parent: name, max: 10)
            try self.validate(self.moderatorArns, name: "moderatorArns", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, max: 256)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[\\u0009\\u000A\\u000D\\u0020-\\u007E\\u0085\\u00A0-\\uD7FF\\uE000-\\uFFFD\\u10000-\\u10FFFF]*$")
            try self.tags?.forEach {
                try $0.validate(name: "\(name).tags[]")
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 50)
            try self.validate(self.tags, name: "tags", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case appInstanceArn = "AppInstanceArn"
            case channelId = "ChannelId"
            case clientRequestToken = "ClientRequestToken"
            case elasticChannelConfiguration = "ElasticChannelConfiguration"
            case expirationSettings = "ExpirationSettings"
            case memberArns = "MemberArns"
            case metadata = "Metadata"
            case mode = "Mode"
            case moderatorArns = "ModeratorArns"
            case name = "Name"
            case privacy = "Privacy"
            case tags = "Tags"
        }
    }

    public struct CreateChannelResponse: AWSDecodableShape {
        /// The ARN of the channel.
        public let channelArn: String?

        @inlinable
        public init(channelArn: String? = nil) {
            self.channelArn = channelArn
        }

        private enum CodingKeys: String, CodingKey {
            case channelArn = "ChannelArn"
        }
    }

    public struct DeleteChannelBanRequest: AWSEncodableShape {
        /// The ARN of the channel from which the AppInstanceUser was banned.
        public let channelArn: String
        /// The ARN of the AppInstanceUser or AppInstanceBot that makes the  API call.
        public let chimeBearer: String
        /// The ARN of the AppInstanceUser that you want to reinstate.
        public let memberArn: String

        @inlinable
        public init(channelArn: String, chimeBearer: String, memberArn: String) {
            self.channelArn = channelArn
            self.chimeBearer = chimeBearer
            self.memberArn = memberArn
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.channelArn, key: "ChannelArn")
            request.encodeHeader(self.chimeBearer, key: "x-amz-chime-bearer")
            request.encodePath(self.memberArn, key: "MemberArn")
        }

        public func validate(name: String) throws {
            try self.validate(self.channelArn, name: "channelArn", parent: name, max: 1600)
            try self.validate(self.channelArn, name: "channelArn", parent: name, min: 5)
            try self.validate(self.channelArn, name: "channelArn", parent: name, pattern: "^arn:[a-z0-9-\\.]{1,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[^/].{0,1023}$")
            try self.validate(self.chimeBearer, name: "chimeBearer", parent: name, max: 1600)
            try self.validate(self.chimeBearer, name: "chimeBearer", parent: name, min: 5)
            try self.validate(self.chimeBearer, name: "chimeBearer", parent: name, pattern: "^arn:[a-z0-9-\\.]{1,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[^/].{0,1023}$")
            try self.validate(self.memberArn, name: "memberArn", parent: name, max: 1600)
            try self.validate(self.memberArn, name: "memberArn", parent: name, min: 5)
            try self.validate(self.memberArn, name: "memberArn", parent: name, pattern: "^arn:[a-z0-9-\\.]{1,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[^/].{0,1023}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteChannelFlowRequest: AWSEncodableShape {
        /// The ARN of the channel flow.
        public let channelFlowArn: String

        @inlinable
        public init(channelFlowArn: String) {
            self.channelFlowArn = channelFlowArn
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.channelFlowArn, key: "ChannelFlowArn")
        }

        public func validate(name: String) throws {
            try self.validate(self.channelFlowArn, name: "channelFlowArn", parent: name, max: 1600)
            try self.validate(self.channelFlowArn, name: "channelFlowArn", parent: name, min: 5)
            try self.validate(self.channelFlowArn, name: "channelFlowArn", parent: name, pattern: "^arn:[a-z0-9-\\.]{1,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[^/].{0,1023}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteChannelMembershipRequest: AWSEncodableShape {
        /// The ARN of the channel from which you want to remove the user.
        public let channelArn: String
        /// The ARN of the AppInstanceUser or AppInstanceBot that makes the  API call.
        public let chimeBearer: String
        /// The AppInstanceUserArn of the member that you're removing from the channel.
        public let memberArn: String
        /// The ID of the SubChannel in the request.  Only for use by moderators.
        public let subChannelId: String?

        @inlinable
        public init(channelArn: String, chimeBearer: String, memberArn: String, subChannelId: String? = nil) {
            self.channelArn = channelArn
            self.chimeBearer = chimeBearer
            self.memberArn = memberArn
            self.subChannelId = subChannelId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.channelArn, key: "ChannelArn")
            request.encodeHeader(self.chimeBearer, key: "x-amz-chime-bearer")
            request.encodePath(self.memberArn, key: "MemberArn")
            request.encodeQuery(self.subChannelId, key: "sub-channel-id")
        }

        public func validate(name: String) throws {
            try self.validate(self.channelArn, name: "channelArn", parent: name, max: 1600)
            try self.validate(self.channelArn, name: "channelArn", parent: name, min: 5)
            try self.validate(self.channelArn, name: "channelArn", parent: name, pattern: "^arn:[a-z0-9-\\.]{1,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[^/].{0,1023}$")
            try self.validate(self.chimeBearer, name: "chimeBearer", parent: name, max: 1600)
            try self.validate(self.chimeBearer, name: "chimeBearer", parent: name, min: 5)
            try self.validate(self.chimeBearer, name: "chimeBearer", parent: name, pattern: "^arn:[a-z0-9-\\.]{1,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[^/].{0,1023}$")
            try self.validate(self.memberArn, name: "memberArn", parent: name, max: 1600)
            try self.validate(self.memberArn, name: "memberArn", parent: name, min: 5)
            try self.validate(self.memberArn, name: "memberArn", parent: name, pattern: "^arn:[a-z0-9-\\.]{1,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[^/].{0,1023}$")
            try self.validate(self.subChannelId, name: "subChannelId", parent: name, max: 128)
            try self.validate(self.subChannelId, name: "subChannelId", parent: name, min: 1)
            try self.validate(self.subChannelId, name: "subChannelId", parent: name, pattern: "^[-_a-zA-Z0-9]*$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteChannelMessageRequest: AWSEncodableShape {
        /// The ARN of the channel.
        public let channelArn: String
        /// The ARN of the AppInstanceUser or AppInstanceBot that makes the  API call.
        public let chimeBearer: String
        /// The ID of the message being deleted.
        public let messageId: String
        /// The ID of the SubChannel in the request.  Only required when deleting messages in a SubChannel that the user belongs to.
        public let subChannelId: String?

        @inlinable
        public init(channelArn: String, chimeBearer: String, messageId: String, subChannelId: String? = nil) {
            self.channelArn = channelArn
            self.chimeBearer = chimeBearer
            self.messageId = messageId
            self.subChannelId = subChannelId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.channelArn, key: "ChannelArn")
            request.encodeHeader(self.chimeBearer, key: "x-amz-chime-bearer")
            request.encodePath(self.messageId, key: "MessageId")
            request.encodeQuery(self.subChannelId, key: "sub-channel-id")
        }

        public func validate(name: String) throws {
            try self.validate(self.channelArn, name: "channelArn", parent: name, max: 1600)
            try self.validate(self.channelArn, name: "channelArn", parent: name, min: 5)
            try self.validate(self.channelArn, name: "channelArn", parent: name, pattern: "^arn:[a-z0-9-\\.]{1,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[^/].{0,1023}$")
            try self.validate(self.chimeBearer, name: "chimeBearer", parent: name, max: 1600)
            try self.validate(self.chimeBearer, name: "chimeBearer", parent: name, min: 5)
            try self.validate(self.chimeBearer, name: "chimeBearer", parent: name, pattern: "^arn:[a-z0-9-\\.]{1,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[^/].{0,1023}$")
            try self.validate(self.messageId, name: "messageId", parent: name, max: 128)
            try self.validate(self.messageId, name: "messageId", parent: name, min: 1)
            try self.validate(self.messageId, name: "messageId", parent: name, pattern: "^[-_a-zA-Z0-9]*$")
            try self.validate(self.subChannelId, name: "subChannelId", parent: name, max: 128)
            try self.validate(self.subChannelId, name: "subChannelId", parent: name, min: 1)
            try self.validate(self.subChannelId, name: "subChannelId", parent: name, pattern: "^[-_a-zA-Z0-9]*$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteChannelModeratorRequest: AWSEncodableShape {
        /// The ARN of the channel.
        public let channelArn: String
        /// The AppInstanceUserArn of the moderator being deleted.
        public let channelModeratorArn: String
        /// The ARN of the AppInstanceUser or AppInstanceBot that makes the  API call.
        public let chimeBearer: String

        @inlinable
        public init(channelArn: String, channelModeratorArn: String, chimeBearer: String) {
            self.channelArn = channelArn
            self.channelModeratorArn = channelModeratorArn
            self.chimeBearer = chimeBearer
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.channelArn, key: "ChannelArn")
            request.encodePath(self.channelModeratorArn, key: "ChannelModeratorArn")
            request.encodeHeader(self.chimeBearer, key: "x-amz-chime-bearer")
        }

        public func validate(name: String) throws {
            try self.validate(self.channelArn, name: "channelArn", parent: name, max: 1600)
            try self.validate(self.channelArn, name: "channelArn", parent: name, min: 5)
            try self.validate(self.channelArn, name: "channelArn", parent: name, pattern: "^arn:[a-z0-9-\\.]{1,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[^/].{0,1023}$")
            try self.validate(self.channelModeratorArn, name: "channelModeratorArn", parent: name, max: 1600)
            try self.validate(self.channelModeratorArn, name: "channelModeratorArn", parent: name, min: 5)
            try self.validate(self.channelModeratorArn, name: "channelModeratorArn", parent: name, pattern: "^arn:[a-z0-9-\\.]{1,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[^/].{0,1023}$")
            try self.validate(self.chimeBearer, name: "chimeBearer", parent: name, max: 1600)
            try self.validate(self.chimeBearer, name: "chimeBearer", parent: name, min: 5)
            try self.validate(self.chimeBearer, name: "chimeBearer", parent: name, pattern: "^arn:[a-z0-9-\\.]{1,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[^/].{0,1023}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteChannelRequest: AWSEncodableShape {
        /// The ARN of the channel being deleted.
        public let channelArn: String
        /// The ARN of the AppInstanceUser or AppInstanceBot  that makes the API call.
        public let chimeBearer: String

        @inlinable
        public init(channelArn: String, chimeBearer: String) {
            self.channelArn = channelArn
            self.chimeBearer = chimeBearer
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.channelArn, key: "ChannelArn")
            request.encodeHeader(self.chimeBearer, key: "x-amz-chime-bearer")
        }

        public func validate(name: String) throws {
            try self.validate(self.channelArn, name: "channelArn", parent: name, max: 1600)
            try self.validate(self.channelArn, name: "channelArn", parent: name, min: 5)
            try self.validate(self.channelArn, name: "channelArn", parent: name, pattern: "^arn:[a-z0-9-\\.]{1,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[^/].{0,1023}$")
            try self.validate(self.chimeBearer, name: "chimeBearer", parent: name, max: 1600)
            try self.validate(self.chimeBearer, name: "chimeBearer", parent: name, min: 5)
            try self.validate(self.chimeBearer, name: "chimeBearer", parent: name, pattern: "^arn:[a-z0-9-\\.]{1,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[^/].{0,1023}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteMessagingStreamingConfigurationsRequest: AWSEncodableShape {
        /// The ARN of the streaming configurations being deleted.
        public let appInstanceArn: String

        @inlinable
        public init(appInstanceArn: String) {
            self.appInstanceArn = appInstanceArn
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.appInstanceArn, key: "AppInstanceArn")
        }

        public func validate(name: String) throws {
            try self.validate(self.appInstanceArn, name: "appInstanceArn", parent: name, max: 1600)
            try self.validate(self.appInstanceArn, name: "appInstanceArn", parent: name, min: 5)
            try self.validate(self.appInstanceArn, name: "appInstanceArn", parent: name, pattern: "^arn:[a-z0-9-\\.]{1,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[^/].{0,1023}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DescribeChannelBanRequest: AWSEncodableShape {
        /// The ARN of the channel from which the user is banned.
        public let channelArn: String
        /// The ARN of the AppInstanceUser or AppInstanceBot that makes the  API call.
        public let chimeBearer: String
        /// The AppInstanceUserArn of the member being banned.
        public let memberArn: String

        @inlinable
        public init(channelArn: String, chimeBearer: String, memberArn: String) {
            self.channelArn = channelArn
            self.chimeBearer = chimeBearer
            self.memberArn = memberArn
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.channelArn, key: "ChannelArn")
            request.encodeHeader(self.chimeBearer, key: "x-amz-chime-bearer")
            request.encodePath(self.memberArn, key: "MemberArn")
        }

        public func validate(name: String) throws {
            try self.validate(self.channelArn, name: "channelArn", parent: name, max: 1600)
            try self.validate(self.channelArn, name: "channelArn", parent: name, min: 5)
            try self.validate(self.channelArn, name: "channelArn", parent: name, pattern: "^arn:[a-z0-9-\\.]{1,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[^/].{0,1023}$")
            try self.validate(self.chimeBearer, name: "chimeBearer", parent: name, max: 1600)
            try self.validate(self.chimeBearer, name: "chimeBearer", parent: name, min: 5)
            try self.validate(self.chimeBearer, name: "chimeBearer", parent: name, pattern: "^arn:[a-z0-9-\\.]{1,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[^/].{0,1023}$")
            try self.validate(self.memberArn, name: "memberArn", parent: name, max: 1600)
            try self.validate(self.memberArn, name: "memberArn", parent: name, min: 5)
            try self.validate(self.memberArn, name: "memberArn", parent: name, pattern: "^arn:[a-z0-9-\\.]{1,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[^/].{0,1023}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DescribeChannelBanResponse: AWSDecodableShape {
        /// The details of the ban.
        public let channelBan: ChannelBan?

        @inlinable
        public init(channelBan: ChannelBan? = nil) {
            self.channelBan = channelBan
        }

        private enum CodingKeys: String, CodingKey {
            case channelBan = "ChannelBan"
        }
    }

    public struct DescribeChannelFlowRequest: AWSEncodableShape {
        /// The ARN of the channel flow.
        public let channelFlowArn: String

        @inlinable
        public init(channelFlowArn: String) {
            self.channelFlowArn = channelFlowArn
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.channelFlowArn, key: "ChannelFlowArn")
        }

        public func validate(name: String) throws {
            try self.validate(self.channelFlowArn, name: "channelFlowArn", parent: name, max: 1600)
            try self.validate(self.channelFlowArn, name: "channelFlowArn", parent: name, min: 5)
            try self.validate(self.channelFlowArn, name: "channelFlowArn", parent: name, pattern: "^arn:[a-z0-9-\\.]{1,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[^/].{0,1023}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DescribeChannelFlowResponse: AWSDecodableShape {
        /// The channel flow details.
        public let channelFlow: ChannelFlow?

        @inlinable
        public init(channelFlow: ChannelFlow? = nil) {
            self.channelFlow = channelFlow
        }

        private enum CodingKeys: String, CodingKey {
            case channelFlow = "ChannelFlow"
        }
    }

    public struct DescribeChannelMembershipForAppInstanceUserRequest: AWSEncodableShape {
        /// The ARN of the user or bot in a channel.
        public let appInstanceUserArn: String
        /// The ARN of the channel to which the user belongs.
        public let channelArn: String
        /// The ARN of the AppInstanceUser or AppInstanceBot  that makes the API call.
        public let chimeBearer: String

        @inlinable
        public init(appInstanceUserArn: String, channelArn: String, chimeBearer: String) {
            self.appInstanceUserArn = appInstanceUserArn
            self.channelArn = channelArn
            self.chimeBearer = chimeBearer
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.appInstanceUserArn, key: "app-instance-user-arn")
            request.encodePath(self.channelArn, key: "ChannelArn")
            request.encodeHeader(self.chimeBearer, key: "x-amz-chime-bearer")
        }

        public func validate(name: String) throws {
            try self.validate(self.appInstanceUserArn, name: "appInstanceUserArn", parent: name, max: 1600)
            try self.validate(self.appInstanceUserArn, name: "appInstanceUserArn", parent: name, min: 5)
            try self.validate(self.appInstanceUserArn, name: "appInstanceUserArn", parent: name, pattern: "^arn:[a-z0-9-\\.]{1,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[^/].{0,1023}$")
            try self.validate(self.channelArn, name: "channelArn", parent: name, max: 1600)
            try self.validate(self.channelArn, name: "channelArn", parent: name, min: 5)
            try self.validate(self.channelArn, name: "channelArn", parent: name, pattern: "^arn:[a-z0-9-\\.]{1,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[^/].{0,1023}$")
            try self.validate(self.chimeBearer, name: "chimeBearer", parent: name, max: 1600)
            try self.validate(self.chimeBearer, name: "chimeBearer", parent: name, min: 5)
            try self.validate(self.chimeBearer, name: "chimeBearer", parent: name, pattern: "^arn:[a-z0-9-\\.]{1,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[^/].{0,1023}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DescribeChannelMembershipForAppInstanceUserResponse: AWSDecodableShape {
        /// The channel to which a user belongs.
        public let channelMembership: ChannelMembershipForAppInstanceUserSummary?

        @inlinable
        public init(channelMembership: ChannelMembershipForAppInstanceUserSummary? = nil) {
            self.channelMembership = channelMembership
        }

        private enum CodingKeys: String, CodingKey {
            case channelMembership = "ChannelMembership"
        }
    }

    public struct DescribeChannelMembershipRequest: AWSEncodableShape {
        /// The ARN of the channel.
        public let channelArn: String
        /// The ARN of the AppInstanceUser or AppInstanceBot that makes the  API call.
        public let chimeBearer: String
        /// The AppInstanceUserArn of the member.
        public let memberArn: String
        /// The ID of the SubChannel in the request. The response contains an ElasticChannelConfiguration object.  Only required to get a user’s SubChannel membership details.
        public let subChannelId: String?

        @inlinable
        public init(channelArn: String, chimeBearer: String, memberArn: String, subChannelId: String? = nil) {
            self.channelArn = channelArn
            self.chimeBearer = chimeBearer
            self.memberArn = memberArn
            self.subChannelId = subChannelId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.channelArn, key: "ChannelArn")
            request.encodeHeader(self.chimeBearer, key: "x-amz-chime-bearer")
            request.encodePath(self.memberArn, key: "MemberArn")
            request.encodeQuery(self.subChannelId, key: "sub-channel-id")
        }

        public func validate(name: String) throws {
            try self.validate(self.channelArn, name: "channelArn", parent: name, max: 1600)
            try self.validate(self.channelArn, name: "channelArn", parent: name, min: 5)
            try self.validate(self.channelArn, name: "channelArn", parent: name, pattern: "^arn:[a-z0-9-\\.]{1,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[^/].{0,1023}$")
            try self.validate(self.chimeBearer, name: "chimeBearer", parent: name, max: 1600)
            try self.validate(self.chimeBearer, name: "chimeBearer", parent: name, min: 5)
            try self.validate(self.chimeBearer, name: "chimeBearer", parent: name, pattern: "^arn:[a-z0-9-\\.]{1,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[^/].{0,1023}$")
            try self.validate(self.memberArn, name: "memberArn", parent: name, max: 1600)
            try self.validate(self.memberArn, name: "memberArn", parent: name, min: 5)
            try self.validate(self.memberArn, name: "memberArn", parent: name, pattern: "^arn:[a-z0-9-\\.]{1,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[^/].{0,1023}$")
            try self.validate(self.subChannelId, name: "subChannelId", parent: name, max: 128)
            try self.validate(self.subChannelId, name: "subChannelId", parent: name, min: 1)
            try self.validate(self.subChannelId, name: "subChannelId", parent: name, pattern: "^[-_a-zA-Z0-9]*$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DescribeChannelMembershipResponse: AWSDecodableShape {
        /// The details of the membership.
        public let channelMembership: ChannelMembership?

        @inlinable
        public init(channelMembership: ChannelMembership? = nil) {
            self.channelMembership = channelMembership
        }

        private enum CodingKeys: String, CodingKey {
            case channelMembership = "ChannelMembership"
        }
    }

    public struct DescribeChannelModeratedByAppInstanceUserRequest: AWSEncodableShape {
        /// The ARN of the user or bot in the moderated channel.
        public let appInstanceUserArn: String
        /// The ARN of the moderated channel.
        public let channelArn: String
        /// The ARN of the AppInstanceUser or AppInstanceBot  that makes the API call.
        public let chimeBearer: String

        @inlinable
        public init(appInstanceUserArn: String, channelArn: String, chimeBearer: String) {
            self.appInstanceUserArn = appInstanceUserArn
            self.channelArn = channelArn
            self.chimeBearer = chimeBearer
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.appInstanceUserArn, key: "app-instance-user-arn")
            request.encodePath(self.channelArn, key: "ChannelArn")
            request.encodeHeader(self.chimeBearer, key: "x-amz-chime-bearer")
        }

        public func validate(name: String) throws {
            try self.validate(self.appInstanceUserArn, name: "appInstanceUserArn", parent: name, max: 1600)
            try self.validate(self.appInstanceUserArn, name: "appInstanceUserArn", parent: name, min: 5)
            try self.validate(self.appInstanceUserArn, name: "appInstanceUserArn", parent: name, pattern: "^arn:[a-z0-9-\\.]{1,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[^/].{0,1023}$")
            try self.validate(self.channelArn, name: "channelArn", parent: name, max: 1600)
            try self.validate(self.channelArn, name: "channelArn", parent: name, min: 5)
            try self.validate(self.channelArn, name: "channelArn", parent: name, pattern: "^arn:[a-z0-9-\\.]{1,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[^/].{0,1023}$")
            try self.validate(self.chimeBearer, name: "chimeBearer", parent: name, max: 1600)
            try self.validate(self.chimeBearer, name: "chimeBearer", parent: name, min: 5)
            try self.validate(self.chimeBearer, name: "chimeBearer", parent: name, pattern: "^arn:[a-z0-9-\\.]{1,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[^/].{0,1023}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DescribeChannelModeratedByAppInstanceUserResponse: AWSDecodableShape {
        /// The moderated channel.
        public let channel: ChannelModeratedByAppInstanceUserSummary?

        @inlinable
        public init(channel: ChannelModeratedByAppInstanceUserSummary? = nil) {
            self.channel = channel
        }

        private enum CodingKeys: String, CodingKey {
            case channel = "Channel"
        }
    }

    public struct DescribeChannelModeratorRequest: AWSEncodableShape {
        /// The ARN of the channel.
        public let channelArn: String
        /// The AppInstanceUserArn of the channel moderator.
        public let channelModeratorArn: String
        /// The ARN of the AppInstanceUser or AppInstanceBot  that makes the API call.
        public let chimeBearer: String

        @inlinable
        public init(channelArn: String, channelModeratorArn: String, chimeBearer: String) {
            self.channelArn = channelArn
            self.channelModeratorArn = channelModeratorArn
            self.chimeBearer = chimeBearer
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.channelArn, key: "ChannelArn")
            request.encodePath(self.channelModeratorArn, key: "ChannelModeratorArn")
            request.encodeHeader(self.chimeBearer, key: "x-amz-chime-bearer")
        }

        public func validate(name: String) throws {
            try self.validate(self.channelArn, name: "channelArn", parent: name, max: 1600)
            try self.validate(self.channelArn, name: "channelArn", parent: name, min: 5)
            try self.validate(self.channelArn, name: "channelArn", parent: name, pattern: "^arn:[a-z0-9-\\.]{1,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[^/].{0,1023}$")
            try self.validate(self.channelModeratorArn, name: "channelModeratorArn", parent: name, max: 1600)
            try self.validate(self.channelModeratorArn, name: "channelModeratorArn", parent: name, min: 5)
            try self.validate(self.channelModeratorArn, name: "channelModeratorArn", parent: name, pattern: "^arn:[a-z0-9-\\.]{1,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[^/].{0,1023}$")
            try self.validate(self.chimeBearer, name: "chimeBearer", parent: name, max: 1600)
            try self.validate(self.chimeBearer, name: "chimeBearer", parent: name, min: 5)
            try self.validate(self.chimeBearer, name: "chimeBearer", parent: name, pattern: "^arn:[a-z0-9-\\.]{1,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[^/].{0,1023}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DescribeChannelModeratorResponse: AWSDecodableShape {
        /// The details of the channel moderator.
        public let channelModerator: ChannelModerator?

        @inlinable
        public init(channelModerator: ChannelModerator? = nil) {
            self.channelModerator = channelModerator
        }

        private enum CodingKeys: String, CodingKey {
            case channelModerator = "ChannelModerator"
        }
    }

    public struct DescribeChannelRequest: AWSEncodableShape {
        /// The ARN of the channel.
        public let channelArn: String
        /// The ARN of the AppInstanceUser or AppInstanceBot that makes the  API call.
        public let chimeBearer: String

        @inlinable
        public init(channelArn: String, chimeBearer: String) {
            self.channelArn = channelArn
            self.chimeBearer = chimeBearer
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.channelArn, key: "ChannelArn")
            request.encodeHeader(self.chimeBearer, key: "x-amz-chime-bearer")
        }

        public func validate(name: String) throws {
            try self.validate(self.channelArn, name: "channelArn", parent: name, max: 1600)
            try self.validate(self.channelArn, name: "channelArn", parent: name, min: 5)
            try self.validate(self.channelArn, name: "channelArn", parent: name, pattern: "^arn:[a-z0-9-\\.]{1,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[^/].{0,1023}$")
            try self.validate(self.chimeBearer, name: "chimeBearer", parent: name, max: 1600)
            try self.validate(self.chimeBearer, name: "chimeBearer", parent: name, min: 5)
            try self.validate(self.chimeBearer, name: "chimeBearer", parent: name, pattern: "^arn:[a-z0-9-\\.]{1,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[^/].{0,1023}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DescribeChannelResponse: AWSDecodableShape {
        /// The channel details.
        public let channel: Channel?

        @inlinable
        public init(channel: Channel? = nil) {
            self.channel = channel
        }

        private enum CodingKeys: String, CodingKey {
            case channel = "Channel"
        }
    }

    public struct DisassociateChannelFlowRequest: AWSEncodableShape {
        /// The ARN of the channel.
        public let channelArn: String
        /// The ARN of the channel flow.
        public let channelFlowArn: String
        /// The AppInstanceUserArn of the user making the API call.
        public let chimeBearer: String

        @inlinable
        public init(channelArn: String, channelFlowArn: String, chimeBearer: String) {
            self.channelArn = channelArn
            self.channelFlowArn = channelFlowArn
            self.chimeBearer = chimeBearer
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.channelArn, key: "ChannelArn")
            request.encodePath(self.channelFlowArn, key: "ChannelFlowArn")
            request.encodeHeader(self.chimeBearer, key: "x-amz-chime-bearer")
        }

        public func validate(name: String) throws {
            try self.validate(self.channelArn, name: "channelArn", parent: name, max: 1600)
            try self.validate(self.channelArn, name: "channelArn", parent: name, min: 5)
            try self.validate(self.channelArn, name: "channelArn", parent: name, pattern: "^arn:[a-z0-9-\\.]{1,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[^/].{0,1023}$")
            try self.validate(self.channelFlowArn, name: "channelFlowArn", parent: name, max: 1600)
            try self.validate(self.channelFlowArn, name: "channelFlowArn", parent: name, min: 5)
            try self.validate(self.channelFlowArn, name: "channelFlowArn", parent: name, pattern: "^arn:[a-z0-9-\\.]{1,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[^/].{0,1023}$")
            try self.validate(self.chimeBearer, name: "chimeBearer", parent: name, max: 1600)
            try self.validate(self.chimeBearer, name: "chimeBearer", parent: name, min: 5)
            try self.validate(self.chimeBearer, name: "chimeBearer", parent: name, pattern: "^arn:[a-z0-9-\\.]{1,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[^/].{0,1023}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ElasticChannelConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The maximum number of SubChannels that you want to allow in the elastic channel.
        public let maximumSubChannels: Int
        /// The minimum allowed percentage of TargetMembershipsPerSubChannel users. Ceil of the calculated value is used in balancing members among SubChannels of the elastic channel.
        public let minimumMembershipPercentage: Int
        /// The maximum number of members allowed in a SubChannel.
        public let targetMembershipsPerSubChannel: Int

        @inlinable
        public init(maximumSubChannels: Int, minimumMembershipPercentage: Int, targetMembershipsPerSubChannel: Int) {
            self.maximumSubChannels = maximumSubChannels
            self.minimumMembershipPercentage = minimumMembershipPercentage
            self.targetMembershipsPerSubChannel = targetMembershipsPerSubChannel
        }

        public func validate(name: String) throws {
            try self.validate(self.maximumSubChannels, name: "maximumSubChannels", parent: name, min: 2)
            try self.validate(self.minimumMembershipPercentage, name: "minimumMembershipPercentage", parent: name, max: 40)
            try self.validate(self.minimumMembershipPercentage, name: "minimumMembershipPercentage", parent: name, min: 1)
            try self.validate(self.targetMembershipsPerSubChannel, name: "targetMembershipsPerSubChannel", parent: name, min: 2)
        }

        private enum CodingKeys: String, CodingKey {
            case maximumSubChannels = "MaximumSubChannels"
            case minimumMembershipPercentage = "MinimumMembershipPercentage"
            case targetMembershipsPerSubChannel = "TargetMembershipsPerSubChannel"
        }
    }

    public struct ExpirationSettings: AWSEncodableShape & AWSDecodableShape {
        /// The conditions that must be met for a channel to expire.
        public let expirationCriterion: ExpirationCriterion
        /// The period in days after which the system automatically deletes a channel.
        public let expirationDays: Int

        @inlinable
        public init(expirationCriterion: ExpirationCriterion, expirationDays: Int) {
            self.expirationCriterion = expirationCriterion
            self.expirationDays = expirationDays
        }

        public func validate(name: String) throws {
            try self.validate(self.expirationDays, name: "expirationDays", parent: name, max: 5475)
            try self.validate(self.expirationDays, name: "expirationDays", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case expirationCriterion = "ExpirationCriterion"
            case expirationDays = "ExpirationDays"
        }
    }

    public struct ForbiddenException: AWSErrorShape {
        public let code: ErrorCode?
        public let message: String?

        @inlinable
        public init(code: ErrorCode? = nil, message: String? = nil) {
            self.code = code
            self.message = message
        }

        private enum CodingKeys: String, CodingKey {
            case code = "Code"
            case message = "Message"
        }
    }

    public struct GetChannelMembershipPreferencesRequest: AWSEncodableShape {
        /// The ARN of the channel.
        public let channelArn: String
        /// The ARN of the AppInstanceUser or AppInstanceBot that makes the API call.
        public let chimeBearer: String
        /// The AppInstanceUserArn of the member retrieving the preferences.
        public let memberArn: String

        @inlinable
        public init(channelArn: String, chimeBearer: String, memberArn: String) {
            self.channelArn = channelArn
            self.chimeBearer = chimeBearer
            self.memberArn = memberArn
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.channelArn, key: "ChannelArn")
            request.encodeHeader(self.chimeBearer, key: "x-amz-chime-bearer")
            request.encodePath(self.memberArn, key: "MemberArn")
        }

        public func validate(name: String) throws {
            try self.validate(self.channelArn, name: "channelArn", parent: name, max: 1600)
            try self.validate(self.channelArn, name: "channelArn", parent: name, min: 5)
            try self.validate(self.channelArn, name: "channelArn", parent: name, pattern: "^arn:[a-z0-9-\\.]{1,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[^/].{0,1023}$")
            try self.validate(self.chimeBearer, name: "chimeBearer", parent: name, max: 1600)
            try self.validate(self.chimeBearer, name: "chimeBearer", parent: name, min: 5)
            try self.validate(self.chimeBearer, name: "chimeBearer", parent: name, pattern: "^arn:[a-z0-9-\\.]{1,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[^/].{0,1023}$")
            try self.validate(self.memberArn, name: "memberArn", parent: name, max: 1600)
            try self.validate(self.memberArn, name: "memberArn", parent: name, min: 5)
            try self.validate(self.memberArn, name: "memberArn", parent: name, pattern: "^arn:[a-z0-9-\\.]{1,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[^/].{0,1023}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetChannelMembershipPreferencesResponse: AWSDecodableShape {
        /// The ARN of the channel.
        public let channelArn: String?
        /// The details of a user.
        public let member: Identity?
        /// The channel membership preferences for an AppInstanceUser .
        public let preferences: ChannelMembershipPreferences?

        @inlinable
        public init(channelArn: String? = nil, member: Identity? = nil, preferences: ChannelMembershipPreferences? = nil) {
            self.channelArn = channelArn
            self.member = member
            self.preferences = preferences
        }

        private enum CodingKeys: String, CodingKey {
            case channelArn = "ChannelArn"
            case member = "Member"
            case preferences = "Preferences"
        }
    }

    public struct GetChannelMessageRequest: AWSEncodableShape {
        /// The ARN of the channel.
        public let channelArn: String
        /// The ARN of the AppInstanceUser or AppInstanceBot  that makes the API call.
        public let chimeBearer: String
        /// The ID of the message.
        public let messageId: String
        /// The ID of the SubChannel in the request.  Only required when getting messages in a SubChannel that the user belongs to.
        public let subChannelId: String?

        @inlinable
        public init(channelArn: String, chimeBearer: String, messageId: String, subChannelId: String? = nil) {
            self.channelArn = channelArn
            self.chimeBearer = chimeBearer
            self.messageId = messageId
            self.subChannelId = subChannelId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.channelArn, key: "ChannelArn")
            request.encodeHeader(self.chimeBearer, key: "x-amz-chime-bearer")
            request.encodePath(self.messageId, key: "MessageId")
            request.encodeQuery(self.subChannelId, key: "sub-channel-id")
        }

        public func validate(name: String) throws {
            try self.validate(self.channelArn, name: "channelArn", parent: name, max: 1600)
            try self.validate(self.channelArn, name: "channelArn", parent: name, min: 5)
            try self.validate(self.channelArn, name: "channelArn", parent: name, pattern: "^arn:[a-z0-9-\\.]{1,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[^/].{0,1023}$")
            try self.validate(self.chimeBearer, name: "chimeBearer", parent: name, max: 1600)
            try self.validate(self.chimeBearer, name: "chimeBearer", parent: name, min: 5)
            try self.validate(self.chimeBearer, name: "chimeBearer", parent: name, pattern: "^arn:[a-z0-9-\\.]{1,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[^/].{0,1023}$")
            try self.validate(self.messageId, name: "messageId", parent: name, max: 128)
            try self.validate(self.messageId, name: "messageId", parent: name, min: 1)
            try self.validate(self.messageId, name: "messageId", parent: name, pattern: "^[-_a-zA-Z0-9]*$")
            try self.validate(self.subChannelId, name: "subChannelId", parent: name, max: 128)
            try self.validate(self.subChannelId, name: "subChannelId", parent: name, min: 1)
            try self.validate(self.subChannelId, name: "subChannelId", parent: name, pattern: "^[-_a-zA-Z0-9]*$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetChannelMessageResponse: AWSDecodableShape {
        /// The details of and content in the message.
        public let channelMessage: ChannelMessage?

        @inlinable
        public init(channelMessage: ChannelMessage? = nil) {
            self.channelMessage = channelMessage
        }

        private enum CodingKeys: String, CodingKey {
            case channelMessage = "ChannelMessage"
        }
    }

    public struct GetChannelMessageStatusRequest: AWSEncodableShape {
        /// The ARN of the channel
        public let channelArn: String
        /// The AppInstanceUserArn of the user making the API call.
        public let chimeBearer: String
        /// The ID of the message.
        public let messageId: String
        /// The ID of the SubChannel in the request.  Only required when getting message status in a SubChannel that the user belongs to.
        public let subChannelId: String?

        @inlinable
        public init(channelArn: String, chimeBearer: String, messageId: String, subChannelId: String? = nil) {
            self.channelArn = channelArn
            self.chimeBearer = chimeBearer
            self.messageId = messageId
            self.subChannelId = subChannelId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.channelArn, key: "ChannelArn")
            request.encodeHeader(self.chimeBearer, key: "x-amz-chime-bearer")
            request.encodePath(self.messageId, key: "MessageId")
            request.encodeQuery(self.subChannelId, key: "sub-channel-id")
        }

        public func validate(name: String) throws {
            try self.validate(self.channelArn, name: "channelArn", parent: name, max: 1600)
            try self.validate(self.channelArn, name: "channelArn", parent: name, min: 5)
            try self.validate(self.channelArn, name: "channelArn", parent: name, pattern: "^arn:[a-z0-9-\\.]{1,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[^/].{0,1023}$")
            try self.validate(self.chimeBearer, name: "chimeBearer", parent: name, max: 1600)
            try self.validate(self.chimeBearer, name: "chimeBearer", parent: name, min: 5)
            try self.validate(self.chimeBearer, name: "chimeBearer", parent: name, pattern: "^arn:[a-z0-9-\\.]{1,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[^/].{0,1023}$")
            try self.validate(self.messageId, name: "messageId", parent: name, max: 128)
            try self.validate(self.messageId, name: "messageId", parent: name, min: 1)
            try self.validate(self.messageId, name: "messageId", parent: name, pattern: "^[-_a-zA-Z0-9]*$")
            try self.validate(self.subChannelId, name: "subChannelId", parent: name, max: 128)
            try self.validate(self.subChannelId, name: "subChannelId", parent: name, min: 1)
            try self.validate(self.subChannelId, name: "subChannelId", parent: name, pattern: "^[-_a-zA-Z0-9]*$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetChannelMessageStatusResponse: AWSDecodableShape {
        /// The message status and details.
        public let status: ChannelMessageStatusStructure?

        @inlinable
        public init(status: ChannelMessageStatusStructure? = nil) {
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case status = "Status"
        }
    }

    public struct GetMessagingSessionEndpointRequest: AWSEncodableShape {
        public init() {}
    }

    public struct GetMessagingSessionEndpointResponse: AWSDecodableShape {
        /// The endpoint returned in the response.
        public let endpoint: MessagingSessionEndpoint?

        @inlinable
        public init(endpoint: MessagingSessionEndpoint? = nil) {
            self.endpoint = endpoint
        }

        private enum CodingKeys: String, CodingKey {
            case endpoint = "Endpoint"
        }
    }

    public struct GetMessagingStreamingConfigurationsRequest: AWSEncodableShape {
        /// The ARN of the streaming configurations.
        public let appInstanceArn: String

        @inlinable
        public init(appInstanceArn: String) {
            self.appInstanceArn = appInstanceArn
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.appInstanceArn, key: "AppInstanceArn")
        }

        public func validate(name: String) throws {
            try self.validate(self.appInstanceArn, name: "appInstanceArn", parent: name, max: 1600)
            try self.validate(self.appInstanceArn, name: "appInstanceArn", parent: name, min: 5)
            try self.validate(self.appInstanceArn, name: "appInstanceArn", parent: name, pattern: "^arn:[a-z0-9-\\.]{1,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[^/].{0,1023}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetMessagingStreamingConfigurationsResponse: AWSDecodableShape {
        /// The streaming settings.
        public let streamingConfigurations: [StreamingConfiguration]?

        @inlinable
        public init(streamingConfigurations: [StreamingConfiguration]? = nil) {
            self.streamingConfigurations = streamingConfigurations
        }

        private enum CodingKeys: String, CodingKey {
            case streamingConfigurations = "StreamingConfigurations"
        }
    }

    public struct Identity: AWSDecodableShape {
        /// The ARN in an Identity.
        public let arn: String?
        /// The name in an Identity.
        public let name: String?

        @inlinable
        public init(arn: String? = nil, name: String? = nil) {
            self.arn = arn
            self.name = name
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case name = "Name"
        }
    }

    public struct LambdaConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// Controls how the Lambda function is invoked.
        public let invocationType: InvocationType
        /// The ARN of the Lambda message processing function.
        public let resourceArn: String

        @inlinable
        public init(invocationType: InvocationType, resourceArn: String) {
            self.invocationType = invocationType
            self.resourceArn = resourceArn
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, max: 2048)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, min: 15)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, pattern: "^arn:aws:lambda:[a-z]{2}-[a-z]+-\\d{1}:\\d{12}:function:[a-zA-Z0-9\\-_\\.]+(:(\\$LATEST|[a-zA-Z0-9\\-_]+))?$")
        }

        private enum CodingKeys: String, CodingKey {
            case invocationType = "InvocationType"
            case resourceArn = "ResourceArn"
        }
    }

    public struct ListChannelBansRequest: AWSEncodableShape {
        /// The ARN of the channel.
        public let channelArn: String
        /// The ARN of the AppInstanceUser or AppInstanceBot  that makes the API call.
        public let chimeBearer: String
        /// The maximum number of bans that you want returned.
        public let maxResults: Int?
        /// The token passed by previous API calls until all requested bans are returned.
        public let nextToken: String?

        @inlinable
        public init(channelArn: String, chimeBearer: String, maxResults: Int? = nil, nextToken: String? = nil) {
            self.channelArn = channelArn
            self.chimeBearer = chimeBearer
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.channelArn, key: "ChannelArn")
            request.encodeHeader(self.chimeBearer, key: "x-amz-chime-bearer")
            request.encodeQuery(self.maxResults, key: "max-results")
            request.encodeQuery(self.nextToken, key: "next-token")
        }

        public func validate(name: String) throws {
            try self.validate(self.channelArn, name: "channelArn", parent: name, max: 1600)
            try self.validate(self.channelArn, name: "channelArn", parent: name, min: 5)
            try self.validate(self.channelArn, name: "channelArn", parent: name, pattern: "^arn:[a-z0-9-\\.]{1,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[^/].{0,1023}$")
            try self.validate(self.chimeBearer, name: "chimeBearer", parent: name, max: 1600)
            try self.validate(self.chimeBearer, name: "chimeBearer", parent: name, min: 5)
            try self.validate(self.chimeBearer, name: "chimeBearer", parent: name, pattern: "^arn:[a-z0-9-\\.]{1,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[^/].{0,1023}$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 50)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 2048)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: ".*")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListChannelBansResponse: AWSDecodableShape {
        /// The ARN of the channel.
        public let channelArn: String?
        /// The information for each requested ban.
        public let channelBans: [ChannelBanSummary]?
        /// The token passed by previous API calls until all requested bans are returned.
        public let nextToken: String?

        @inlinable
        public init(channelArn: String? = nil, channelBans: [ChannelBanSummary]? = nil, nextToken: String? = nil) {
            self.channelArn = channelArn
            self.channelBans = channelBans
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case channelArn = "ChannelArn"
            case channelBans = "ChannelBans"
            case nextToken = "NextToken"
        }
    }

    public struct ListChannelFlowsRequest: AWSEncodableShape {
        /// The ARN of the app instance.
        public let appInstanceArn: String
        /// The maximum number of channel flows that you want to return.
        public let maxResults: Int?
        /// The token passed by previous API calls until all requested channel flows are returned.
        public let nextToken: String?

        @inlinable
        public init(appInstanceArn: String, maxResults: Int? = nil, nextToken: String? = nil) {
            self.appInstanceArn = appInstanceArn
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.appInstanceArn, key: "app-instance-arn")
            request.encodeQuery(self.maxResults, key: "max-results")
            request.encodeQuery(self.nextToken, key: "next-token")
        }

        public func validate(name: String) throws {
            try self.validate(self.appInstanceArn, name: "appInstanceArn", parent: name, max: 1600)
            try self.validate(self.appInstanceArn, name: "appInstanceArn", parent: name, min: 5)
            try self.validate(self.appInstanceArn, name: "appInstanceArn", parent: name, pattern: "^arn:[a-z0-9-\\.]{1,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[^/].{0,1023}$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 50)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 2048)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: ".*")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListChannelFlowsResponse: AWSDecodableShape {
        /// The information about each channel flow.
        public let channelFlows: [ChannelFlowSummary]?
        /// The token passed by previous API calls until all requested channels are returned.
        public let nextToken: String?

        @inlinable
        public init(channelFlows: [ChannelFlowSummary]? = nil, nextToken: String? = nil) {
            self.channelFlows = channelFlows
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case channelFlows = "ChannelFlows"
            case nextToken = "NextToken"
        }
    }

    public struct ListChannelMembershipsForAppInstanceUserRequest: AWSEncodableShape {
        /// The ARN of the user or bot.
        public let appInstanceUserArn: String?
        /// The ARN of the AppInstanceUser or AppInstanceBot  that makes the API call.
        public let chimeBearer: String
        /// The maximum number of users that you want returned.
        public let maxResults: Int?
        /// The token returned from previous API requests until the number of channel memberships is reached.
        public let nextToken: String?

        @inlinable
        public init(appInstanceUserArn: String? = nil, chimeBearer: String, maxResults: Int? = nil, nextToken: String? = nil) {
            self.appInstanceUserArn = appInstanceUserArn
            self.chimeBearer = chimeBearer
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.appInstanceUserArn, key: "app-instance-user-arn")
            request.encodeHeader(self.chimeBearer, key: "x-amz-chime-bearer")
            request.encodeQuery(self.maxResults, key: "max-results")
            request.encodeQuery(self.nextToken, key: "next-token")
        }

        public func validate(name: String) throws {
            try self.validate(self.appInstanceUserArn, name: "appInstanceUserArn", parent: name, max: 1600)
            try self.validate(self.appInstanceUserArn, name: "appInstanceUserArn", parent: name, min: 5)
            try self.validate(self.appInstanceUserArn, name: "appInstanceUserArn", parent: name, pattern: "^arn:[a-z0-9-\\.]{1,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[^/].{0,1023}$")
            try self.validate(self.chimeBearer, name: "chimeBearer", parent: name, max: 1600)
            try self.validate(self.chimeBearer, name: "chimeBearer", parent: name, min: 5)
            try self.validate(self.chimeBearer, name: "chimeBearer", parent: name, pattern: "^arn:[a-z0-9-\\.]{1,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[^/].{0,1023}$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 50)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 2048)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: ".*")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListChannelMembershipsForAppInstanceUserResponse: AWSDecodableShape {
        /// The information for the requested channel memberships.
        public let channelMemberships: [ChannelMembershipForAppInstanceUserSummary]?
        /// The token passed by previous API calls until all requested users are returned.
        public let nextToken: String?

        @inlinable
        public init(channelMemberships: [ChannelMembershipForAppInstanceUserSummary]? = nil, nextToken: String? = nil) {
            self.channelMemberships = channelMemberships
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case channelMemberships = "ChannelMemberships"
            case nextToken = "NextToken"
        }
    }

    public struct ListChannelMembershipsRequest: AWSEncodableShape {
        /// The maximum number of channel memberships that you want returned.
        public let channelArn: String
        /// The ARN of the AppInstanceUser or AppInstanceBot  that makes the API call.
        public let chimeBearer: String
        /// The maximum number of channel memberships that you want returned.
        public let maxResults: Int?
        /// The token passed by previous API calls until all requested channel memberships are returned.
        public let nextToken: String?
        /// The ID of the SubChannel in the request.  Only required when listing a user's memberships in a particular sub-channel of an elastic channel.
        public let subChannelId: String?
        /// The membership type of a user, DEFAULT or HIDDEN. Default members are returned as part of ListChannelMemberships if no type is specified. Hidden members are only returned if the type filter in ListChannelMemberships equals HIDDEN.
        public let type: ChannelMembershipType?

        @inlinable
        public init(channelArn: String, chimeBearer: String, maxResults: Int? = nil, nextToken: String? = nil, subChannelId: String? = nil, type: ChannelMembershipType? = nil) {
            self.channelArn = channelArn
            self.chimeBearer = chimeBearer
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.subChannelId = subChannelId
            self.type = type
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.channelArn, key: "ChannelArn")
            request.encodeHeader(self.chimeBearer, key: "x-amz-chime-bearer")
            request.encodeQuery(self.maxResults, key: "max-results")
            request.encodeQuery(self.nextToken, key: "next-token")
            request.encodeQuery(self.subChannelId, key: "sub-channel-id")
            request.encodeQuery(self.type, key: "type")
        }

        public func validate(name: String) throws {
            try self.validate(self.channelArn, name: "channelArn", parent: name, max: 1600)
            try self.validate(self.channelArn, name: "channelArn", parent: name, min: 5)
            try self.validate(self.channelArn, name: "channelArn", parent: name, pattern: "^arn:[a-z0-9-\\.]{1,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[^/].{0,1023}$")
            try self.validate(self.chimeBearer, name: "chimeBearer", parent: name, max: 1600)
            try self.validate(self.chimeBearer, name: "chimeBearer", parent: name, min: 5)
            try self.validate(self.chimeBearer, name: "chimeBearer", parent: name, pattern: "^arn:[a-z0-9-\\.]{1,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[^/].{0,1023}$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 50)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 2048)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: ".*")
            try self.validate(self.subChannelId, name: "subChannelId", parent: name, max: 128)
            try self.validate(self.subChannelId, name: "subChannelId", parent: name, min: 1)
            try self.validate(self.subChannelId, name: "subChannelId", parent: name, pattern: "^[-_a-zA-Z0-9]*$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListChannelMembershipsResponse: AWSDecodableShape {
        /// The ARN of the channel.
        public let channelArn: String?
        /// The information for the requested channel memberships.
        public let channelMemberships: [ChannelMembershipSummary]?
        /// The token passed by previous API calls until all requested channel memberships are returned.
        public let nextToken: String?

        @inlinable
        public init(channelArn: String? = nil, channelMemberships: [ChannelMembershipSummary]? = nil, nextToken: String? = nil) {
            self.channelArn = channelArn
            self.channelMemberships = channelMemberships
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case channelArn = "ChannelArn"
            case channelMemberships = "ChannelMemberships"
            case nextToken = "NextToken"
        }
    }

    public struct ListChannelMessagesRequest: AWSEncodableShape {
        /// The ARN of the channel.
        public let channelArn: String
        /// The ARN of the AppInstanceUser or AppInstanceBot  that makes the API call.
        public let chimeBearer: String
        /// The maximum number of messages that you want returned.
        public let maxResults: Int?
        /// The token passed by previous API calls until all requested messages are returned.
        public let nextToken: String?
        /// The final or ending time stamp for your requested messages.
        public let notAfter: Date?
        /// The initial or starting time stamp for your requested messages.
        public let notBefore: Date?
        /// The order in which you want messages sorted. Default is Descending, based on time created.
        public let sortOrder: SortOrder?
        /// The ID of the SubChannel in the request.  Only required when listing the messages in a SubChannel that the user belongs to.
        public let subChannelId: String?

        @inlinable
        public init(channelArn: String, chimeBearer: String, maxResults: Int? = nil, nextToken: String? = nil, notAfter: Date? = nil, notBefore: Date? = nil, sortOrder: SortOrder? = nil, subChannelId: String? = nil) {
            self.channelArn = channelArn
            self.chimeBearer = chimeBearer
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.notAfter = notAfter
            self.notBefore = notBefore
            self.sortOrder = sortOrder
            self.subChannelId = subChannelId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.channelArn, key: "ChannelArn")
            request.encodeHeader(self.chimeBearer, key: "x-amz-chime-bearer")
            request.encodeQuery(self.maxResults, key: "max-results")
            request.encodeQuery(self.nextToken, key: "next-token")
            request.encodeQuery(self.notAfter, key: "not-after")
            request.encodeQuery(self.notBefore, key: "not-before")
            request.encodeQuery(self.sortOrder, key: "sort-order")
            request.encodeQuery(self.subChannelId, key: "sub-channel-id")
        }

        public func validate(name: String) throws {
            try self.validate(self.channelArn, name: "channelArn", parent: name, max: 1600)
            try self.validate(self.channelArn, name: "channelArn", parent: name, min: 5)
            try self.validate(self.channelArn, name: "channelArn", parent: name, pattern: "^arn:[a-z0-9-\\.]{1,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[^/].{0,1023}$")
            try self.validate(self.chimeBearer, name: "chimeBearer", parent: name, max: 1600)
            try self.validate(self.chimeBearer, name: "chimeBearer", parent: name, min: 5)
            try self.validate(self.chimeBearer, name: "chimeBearer", parent: name, pattern: "^arn:[a-z0-9-\\.]{1,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[^/].{0,1023}$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 50)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 2048)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: ".*")
            try self.validate(self.subChannelId, name: "subChannelId", parent: name, max: 128)
            try self.validate(self.subChannelId, name: "subChannelId", parent: name, min: 1)
            try self.validate(self.subChannelId, name: "subChannelId", parent: name, pattern: "^[-_a-zA-Z0-9]*$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListChannelMessagesResponse: AWSDecodableShape {
        /// The ARN of the channel containing the requested messages.
        public let channelArn: String?
        /// The information about, and content of, each requested message.
        public let channelMessages: [ChannelMessageSummary]?
        /// The token passed by previous API calls until all requested messages are returned.
        public let nextToken: String?
        /// The ID of the SubChannel in the response.
        public let subChannelId: String?

        @inlinable
        public init(channelArn: String? = nil, channelMessages: [ChannelMessageSummary]? = nil, nextToken: String? = nil, subChannelId: String? = nil) {
            self.channelArn = channelArn
            self.channelMessages = channelMessages
            self.nextToken = nextToken
            self.subChannelId = subChannelId
        }

        private enum CodingKeys: String, CodingKey {
            case channelArn = "ChannelArn"
            case channelMessages = "ChannelMessages"
            case nextToken = "NextToken"
            case subChannelId = "SubChannelId"
        }
    }

    public struct ListChannelModeratorsRequest: AWSEncodableShape {
        /// The ARN of the channel.
        public let channelArn: String
        /// The ARN of the AppInstanceUser or AppInstanceBot  that makes the API call.
        public let chimeBearer: String
        /// The maximum number of moderators that you want returned.
        public let maxResults: Int?
        /// The token passed by previous API calls until all requested moderators are returned.
        public let nextToken: String?

        @inlinable
        public init(channelArn: String, chimeBearer: String, maxResults: Int? = nil, nextToken: String? = nil) {
            self.channelArn = channelArn
            self.chimeBearer = chimeBearer
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.channelArn, key: "ChannelArn")
            request.encodeHeader(self.chimeBearer, key: "x-amz-chime-bearer")
            request.encodeQuery(self.maxResults, key: "max-results")
            request.encodeQuery(self.nextToken, key: "next-token")
        }

        public func validate(name: String) throws {
            try self.validate(self.channelArn, name: "channelArn", parent: name, max: 1600)
            try self.validate(self.channelArn, name: "channelArn", parent: name, min: 5)
            try self.validate(self.channelArn, name: "channelArn", parent: name, pattern: "^arn:[a-z0-9-\\.]{1,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[^/].{0,1023}$")
            try self.validate(self.chimeBearer, name: "chimeBearer", parent: name, max: 1600)
            try self.validate(self.chimeBearer, name: "chimeBearer", parent: name, min: 5)
            try self.validate(self.chimeBearer, name: "chimeBearer", parent: name, pattern: "^arn:[a-z0-9-\\.]{1,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[^/].{0,1023}$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 50)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 2048)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: ".*")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListChannelModeratorsResponse: AWSDecodableShape {
        /// The ARN of the channel.
        public let channelArn: String?
        /// The information about and names of each moderator.
        public let channelModerators: [ChannelModeratorSummary]?
        /// The token passed by previous API calls until all requested moderators are returned.
        public let nextToken: String?

        @inlinable
        public init(channelArn: String? = nil, channelModerators: [ChannelModeratorSummary]? = nil, nextToken: String? = nil) {
            self.channelArn = channelArn
            self.channelModerators = channelModerators
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case channelArn = "ChannelArn"
            case channelModerators = "ChannelModerators"
            case nextToken = "NextToken"
        }
    }

    public struct ListChannelsAssociatedWithChannelFlowRequest: AWSEncodableShape {
        /// The ARN of the channel flow.
        public let channelFlowArn: String
        /// The maximum number of channels that you want to return.
        public let maxResults: Int?
        /// The token passed by previous API calls until all requested channels are returned.
        public let nextToken: String?

        @inlinable
        public init(channelFlowArn: String, maxResults: Int? = nil, nextToken: String? = nil) {
            self.channelFlowArn = channelFlowArn
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.channelFlowArn, key: "channel-flow-arn")
            request.encodeQuery(self.maxResults, key: "max-results")
            request.encodeQuery(self.nextToken, key: "next-token")
        }

        public func validate(name: String) throws {
            try self.validate(self.channelFlowArn, name: "channelFlowArn", parent: name, max: 1600)
            try self.validate(self.channelFlowArn, name: "channelFlowArn", parent: name, min: 5)
            try self.validate(self.channelFlowArn, name: "channelFlowArn", parent: name, pattern: "^arn:[a-z0-9-\\.]{1,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[^/].{0,1023}$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 50)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 2048)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: ".*")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListChannelsAssociatedWithChannelFlowResponse: AWSDecodableShape {
        /// The information about each channel.
        public let channels: [ChannelAssociatedWithFlowSummary]?
        /// The token passed by previous API calls until all requested channels are returned.
        public let nextToken: String?

        @inlinable
        public init(channels: [ChannelAssociatedWithFlowSummary]? = nil, nextToken: String? = nil) {
            self.channels = channels
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case channels = "Channels"
            case nextToken = "NextToken"
        }
    }

    public struct ListChannelsModeratedByAppInstanceUserRequest: AWSEncodableShape {
        /// The ARN of the user or bot in the moderated channel.
        public let appInstanceUserArn: String?
        /// The ARN of the AppInstanceUser or AppInstanceBot  that makes the API call.
        public let chimeBearer: String
        /// The maximum number of channels in the request.
        public let maxResults: Int?
        /// The token returned from previous API requests until the number of channels moderated by the user is reached.
        public let nextToken: String?

        @inlinable
        public init(appInstanceUserArn: String? = nil, chimeBearer: String, maxResults: Int? = nil, nextToken: String? = nil) {
            self.appInstanceUserArn = appInstanceUserArn
            self.chimeBearer = chimeBearer
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.appInstanceUserArn, key: "app-instance-user-arn")
            request.encodeHeader(self.chimeBearer, key: "x-amz-chime-bearer")
            request.encodeQuery(self.maxResults, key: "max-results")
            request.encodeQuery(self.nextToken, key: "next-token")
        }

        public func validate(name: String) throws {
            try self.validate(self.appInstanceUserArn, name: "appInstanceUserArn", parent: name, max: 1600)
            try self.validate(self.appInstanceUserArn, name: "appInstanceUserArn", parent: name, min: 5)
            try self.validate(self.appInstanceUserArn, name: "appInstanceUserArn", parent: name, pattern: "^arn:[a-z0-9-\\.]{1,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[^/].{0,1023}$")
            try self.validate(self.chimeBearer, name: "chimeBearer", parent: name, max: 1600)
            try self.validate(self.chimeBearer, name: "chimeBearer", parent: name, min: 5)
            try self.validate(self.chimeBearer, name: "chimeBearer", parent: name, pattern: "^arn:[a-z0-9-\\.]{1,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[^/].{0,1023}$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 50)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 2048)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: ".*")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListChannelsModeratedByAppInstanceUserResponse: AWSDecodableShape {
        /// The moderated channels in the request.
        public let channels: [ChannelModeratedByAppInstanceUserSummary]?
        /// The token returned from previous API requests until the number of channels moderated by the user is reached.
        public let nextToken: String?

        @inlinable
        public init(channels: [ChannelModeratedByAppInstanceUserSummary]? = nil, nextToken: String? = nil) {
            self.channels = channels
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case channels = "Channels"
            case nextToken = "NextToken"
        }
    }

    public struct ListChannelsRequest: AWSEncodableShape {
        /// The ARN of the AppInstance.
        public let appInstanceArn: String
        /// The ARN of the AppInstanceUser or AppInstanceBot  that makes the API call.
        public let chimeBearer: String
        /// The maximum number of channels that you want to return.
        public let maxResults: Int?
        /// The token passed by previous API calls until all requested channels are returned.
        public let nextToken: String?
        /// The privacy setting. PUBLIC retrieves all the public channels. PRIVATE retrieves private channels. Only an AppInstanceAdmin can retrieve private channels.
        public let privacy: ChannelPrivacy?

        @inlinable
        public init(appInstanceArn: String, chimeBearer: String, maxResults: Int? = nil, nextToken: String? = nil, privacy: ChannelPrivacy? = nil) {
            self.appInstanceArn = appInstanceArn
            self.chimeBearer = chimeBearer
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.privacy = privacy
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.appInstanceArn, key: "app-instance-arn")
            request.encodeHeader(self.chimeBearer, key: "x-amz-chime-bearer")
            request.encodeQuery(self.maxResults, key: "max-results")
            request.encodeQuery(self.nextToken, key: "next-token")
            request.encodeQuery(self.privacy, key: "privacy")
        }

        public func validate(name: String) throws {
            try self.validate(self.appInstanceArn, name: "appInstanceArn", parent: name, max: 1600)
            try self.validate(self.appInstanceArn, name: "appInstanceArn", parent: name, min: 5)
            try self.validate(self.appInstanceArn, name: "appInstanceArn", parent: name, pattern: "^arn:[a-z0-9-\\.]{1,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[^/].{0,1023}$")
            try self.validate(self.chimeBearer, name: "chimeBearer", parent: name, max: 1600)
            try self.validate(self.chimeBearer, name: "chimeBearer", parent: name, min: 5)
            try self.validate(self.chimeBearer, name: "chimeBearer", parent: name, pattern: "^arn:[a-z0-9-\\.]{1,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[^/].{0,1023}$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 50)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 2048)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: ".*")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListChannelsResponse: AWSDecodableShape {
        /// The information about each channel.
        public let channels: [ChannelSummary]?
        /// The token returned from previous API requests until the number of channels is reached.
        public let nextToken: String?

        @inlinable
        public init(channels: [ChannelSummary]? = nil, nextToken: String? = nil) {
            self.channels = channels
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case channels = "Channels"
            case nextToken = "NextToken"
        }
    }

    public struct ListSubChannelsRequest: AWSEncodableShape {
        /// The ARN of elastic channel.
        public let channelArn: String
        /// The AppInstanceUserArn of the user making the API call.
        public let chimeBearer: String
        /// The maximum number of sub-channels that you want to return.
        public let maxResults: Int?
        /// The token passed by previous API calls until all requested sub-channels are returned.
        public let nextToken: String?

        @inlinable
        public init(channelArn: String, chimeBearer: String, maxResults: Int? = nil, nextToken: String? = nil) {
            self.channelArn = channelArn
            self.chimeBearer = chimeBearer
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.channelArn, key: "ChannelArn")
            request.encodeHeader(self.chimeBearer, key: "x-amz-chime-bearer")
            request.encodeQuery(self.maxResults, key: "max-results")
            request.encodeQuery(self.nextToken, key: "next-token")
        }

        public func validate(name: String) throws {
            try self.validate(self.channelArn, name: "channelArn", parent: name, max: 1600)
            try self.validate(self.channelArn, name: "channelArn", parent: name, min: 5)
            try self.validate(self.channelArn, name: "channelArn", parent: name, pattern: "^arn:[a-z0-9-\\.]{1,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[^/].{0,1023}$")
            try self.validate(self.chimeBearer, name: "chimeBearer", parent: name, max: 1600)
            try self.validate(self.chimeBearer, name: "chimeBearer", parent: name, min: 5)
            try self.validate(self.chimeBearer, name: "chimeBearer", parent: name, pattern: "^arn:[a-z0-9-\\.]{1,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[^/].{0,1023}$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 50)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 2048)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: ".*")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListSubChannelsResponse: AWSDecodableShape {
        /// The ARN of elastic channel.
        public let channelArn: String?
        /// The token passed by previous API calls until all requested sub-channels are returned.
        public let nextToken: String?
        /// The information about each sub-channel.
        public let subChannels: [SubChannelSummary]?

        @inlinable
        public init(channelArn: String? = nil, nextToken: String? = nil, subChannels: [SubChannelSummary]? = nil) {
            self.channelArn = channelArn
            self.nextToken = nextToken
            self.subChannels = subChannels
        }

        private enum CodingKeys: String, CodingKey {
            case channelArn = "ChannelArn"
            case nextToken = "NextToken"
            case subChannels = "SubChannels"
        }
    }

    public struct ListTagsForResourceRequest: AWSEncodableShape {
        /// The ARN of the resource.
        public let resourceARN: String

        @inlinable
        public init(resourceARN: String) {
            self.resourceARN = resourceARN
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.resourceARN, key: "arn")
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceARN, name: "resourceARN", parent: name, max: 1600)
            try self.validate(self.resourceARN, name: "resourceARN", parent: name, min: 5)
            try self.validate(self.resourceARN, name: "resourceARN", parent: name, pattern: "^arn:[a-z0-9-\\.]{1,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[^/].{0,1023}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListTagsForResourceResponse: AWSDecodableShape {
        /// The tag key-value pairs.
        public let tags: [Tag]?

        @inlinable
        public init(tags: [Tag]? = nil) {
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case tags = "Tags"
        }
    }

    public struct MessageAttributeValue: AWSEncodableShape & AWSDecodableShape {
        /// The strings in a message attribute value.
        public let stringValues: [String]?

        @inlinable
        public init(stringValues: [String]? = nil) {
            self.stringValues = stringValues
        }

        public func validate(name: String) throws {
            try self.stringValues?.forEach {
                try validate($0, name: "stringValues[]", parent: name, max: 512)
                try validate($0, name: "stringValues[]", parent: name, min: 1)
                try validate($0, name: "stringValues[]", parent: name, pattern: "^[\\s\\S]*$")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case stringValues = "StringValues"
        }
    }

    public struct MessagingSessionEndpoint: AWSDecodableShape {
        /// The endpoint to which you establish a websocket connection.
        public let url: String?

        @inlinable
        public init(url: String? = nil) {
            self.url = url
        }

        private enum CodingKeys: String, CodingKey {
            case url = "Url"
        }
    }

    public struct NotFoundException: AWSErrorShape {
        public let code: ErrorCode?
        public let message: String?

        @inlinable
        public init(code: ErrorCode? = nil, message: String? = nil) {
            self.code = code
            self.message = message
        }

        private enum CodingKeys: String, CodingKey {
            case code = "Code"
            case message = "Message"
        }
    }

    public struct Processor: AWSEncodableShape & AWSDecodableShape {
        /// The information about the type of processor and its identifier.
        public let configuration: ProcessorConfiguration
        /// The sequence in which processors run. If you have multiple processors in a channel flow, message processing goes through each processor in the sequence. The value determines the sequence.  At this point, we support only 1 processor within a flow.
        public let executionOrder: Int
        /// Determines whether to continue with message processing or stop it in cases where communication with a processor fails. If a processor has a fallback action of ABORT and  communication with it fails, the processor sets the message status to FAILED and does not send the message to any recipients. Note that if the last processor in the channel flow sequence  has a fallback action of CONTINUE and communication with the processor fails, then the message is considered processed and sent to recipients of the channel.
        public let fallbackAction: FallbackAction
        /// The name of the channel flow.
        public let name: String

        @inlinable
        public init(configuration: ProcessorConfiguration, executionOrder: Int, fallbackAction: FallbackAction, name: String) {
            self.configuration = configuration
            self.executionOrder = executionOrder
            self.fallbackAction = fallbackAction
            self.name = name
        }

        public func validate(name: String) throws {
            try self.configuration.validate(name: "\(name).configuration")
            try self.validate(self.executionOrder, name: "executionOrder", parent: name, max: 3)
            try self.validate(self.executionOrder, name: "executionOrder", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, max: 256)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[\\u0009\\u000A\\u000D\\u0020-\\u007E\\u0085\\u00A0-\\uD7FF\\uE000-\\uFFFD\\u10000-\\u10FFFF]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case configuration = "Configuration"
            case executionOrder = "ExecutionOrder"
            case fallbackAction = "FallbackAction"
            case name = "Name"
        }
    }

    public struct ProcessorConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// Indicates that the processor is of type Lambda.
        public let lambda: LambdaConfiguration

        @inlinable
        public init(lambda: LambdaConfiguration) {
            self.lambda = lambda
        }

        public func validate(name: String) throws {
            try self.lambda.validate(name: "\(name).lambda")
        }

        private enum CodingKeys: String, CodingKey {
            case lambda = "Lambda"
        }
    }

    public struct PushNotificationConfiguration: AWSEncodableShape {
        /// The body of the push notification.
        public let body: String?
        /// The title of the push notification.
        public let title: String?
        /// Enum value that indicates the type of the push notification for a message. DEFAULT: Normal mobile push notification. VOIP: VOIP mobile push notification.
        public let type: PushNotificationType?

        @inlinable
        public init(body: String? = nil, title: String? = nil, type: PushNotificationType? = nil) {
            self.body = body
            self.title = title
            self.type = type
        }

        public func validate(name: String) throws {
            try self.validate(self.body, name: "body", parent: name, max: 150)
            try self.validate(self.body, name: "body", parent: name, min: 1)
            try self.validate(self.body, name: "body", parent: name, pattern: "^[\\s\\S]*$")
            try self.validate(self.title, name: "title", parent: name, max: 50)
            try self.validate(self.title, name: "title", parent: name, min: 1)
            try self.validate(self.title, name: "title", parent: name, pattern: ".*")
        }

        private enum CodingKeys: String, CodingKey {
            case body = "Body"
            case title = "Title"
            case type = "Type"
        }
    }

    public struct PushNotificationPreferences: AWSEncodableShape & AWSDecodableShape {
        /// Enum value that indicates which push notifications to send to the requested member of a channel. ALL sends all push notifications, NONE sends no push notifications, FILTERED sends only filtered push notifications.
        public let allowNotifications: AllowNotifications
        /// The simple JSON object used to send a subset of a push notification to the requested member.
        public let filterRule: String?

        @inlinable
        public init(allowNotifications: AllowNotifications, filterRule: String? = nil) {
            self.allowNotifications = allowNotifications
            self.filterRule = filterRule
        }

        public func validate(name: String) throws {
            try self.validate(self.filterRule, name: "filterRule", parent: name, min: 1)
            try self.validate(self.filterRule, name: "filterRule", parent: name, pattern: "^[\\s\\S]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case allowNotifications = "AllowNotifications"
            case filterRule = "FilterRule"
        }
    }

    public struct PutChannelExpirationSettingsRequest: AWSEncodableShape {
        /// The ARN of the channel.
        public let channelArn: String
        /// The ARN of the AppInstanceUser or AppInstanceBot that makes the API call.
        public let chimeBearer: String?
        /// Settings that control the interval after which a channel is deleted.
        public let expirationSettings: ExpirationSettings?

        @inlinable
        public init(channelArn: String, chimeBearer: String? = nil, expirationSettings: ExpirationSettings? = nil) {
            self.channelArn = channelArn
            self.chimeBearer = chimeBearer
            self.expirationSettings = expirationSettings
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.channelArn, key: "ChannelArn")
            request.encodeHeader(self.chimeBearer, key: "x-amz-chime-bearer")
            try container.encodeIfPresent(self.expirationSettings, forKey: .expirationSettings)
        }

        public func validate(name: String) throws {
            try self.validate(self.channelArn, name: "channelArn", parent: name, max: 1600)
            try self.validate(self.channelArn, name: "channelArn", parent: name, min: 5)
            try self.validate(self.channelArn, name: "channelArn", parent: name, pattern: "^arn:[a-z0-9-\\.]{1,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[^/].{0,1023}$")
            try self.validate(self.chimeBearer, name: "chimeBearer", parent: name, max: 1600)
            try self.validate(self.chimeBearer, name: "chimeBearer", parent: name, min: 5)
            try self.validate(self.chimeBearer, name: "chimeBearer", parent: name, pattern: "^arn:[a-z0-9-\\.]{1,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[^/].{0,1023}$")
            try self.expirationSettings?.validate(name: "\(name).expirationSettings")
        }

        private enum CodingKeys: String, CodingKey {
            case expirationSettings = "ExpirationSettings"
        }
    }

    public struct PutChannelExpirationSettingsResponse: AWSDecodableShape {
        /// The channel ARN.
        public let channelArn: String?
        /// Settings that control the interval after which a channel is deleted.
        public let expirationSettings: ExpirationSettings?

        @inlinable
        public init(channelArn: String? = nil, expirationSettings: ExpirationSettings? = nil) {
            self.channelArn = channelArn
            self.expirationSettings = expirationSettings
        }

        private enum CodingKeys: String, CodingKey {
            case channelArn = "ChannelArn"
            case expirationSettings = "ExpirationSettings"
        }
    }

    public struct PutChannelMembershipPreferencesRequest: AWSEncodableShape {
        /// The ARN of the channel.
        public let channelArn: String
        /// The ARN of the AppInstanceUser or AppInstanceBot that makes the API call.
        public let chimeBearer: String
        /// The ARN of the member setting the preferences.
        public let memberArn: String
        /// The channel membership preferences of an AppInstanceUser .
        public let preferences: ChannelMembershipPreferences

        @inlinable
        public init(channelArn: String, chimeBearer: String, memberArn: String, preferences: ChannelMembershipPreferences) {
            self.channelArn = channelArn
            self.chimeBearer = chimeBearer
            self.memberArn = memberArn
            self.preferences = preferences
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.channelArn, key: "ChannelArn")
            request.encodeHeader(self.chimeBearer, key: "x-amz-chime-bearer")
            request.encodePath(self.memberArn, key: "MemberArn")
            try container.encode(self.preferences, forKey: .preferences)
        }

        public func validate(name: String) throws {
            try self.validate(self.channelArn, name: "channelArn", parent: name, max: 1600)
            try self.validate(self.channelArn, name: "channelArn", parent: name, min: 5)
            try self.validate(self.channelArn, name: "channelArn", parent: name, pattern: "^arn:[a-z0-9-\\.]{1,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[^/].{0,1023}$")
            try self.validate(self.chimeBearer, name: "chimeBearer", parent: name, max: 1600)
            try self.validate(self.chimeBearer, name: "chimeBearer", parent: name, min: 5)
            try self.validate(self.chimeBearer, name: "chimeBearer", parent: name, pattern: "^arn:[a-z0-9-\\.]{1,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[^/].{0,1023}$")
            try self.validate(self.memberArn, name: "memberArn", parent: name, max: 1600)
            try self.validate(self.memberArn, name: "memberArn", parent: name, min: 5)
            try self.validate(self.memberArn, name: "memberArn", parent: name, pattern: "^arn:[a-z0-9-\\.]{1,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[^/].{0,1023}$")
            try self.preferences.validate(name: "\(name).preferences")
        }

        private enum CodingKeys: String, CodingKey {
            case preferences = "Preferences"
        }
    }

    public struct PutChannelMembershipPreferencesResponse: AWSDecodableShape {
        /// The ARN of the channel.
        public let channelArn: String?
        /// The details of a user.
        public let member: Identity?
        /// The ARN and metadata of the member being added.
        public let preferences: ChannelMembershipPreferences?

        @inlinable
        public init(channelArn: String? = nil, member: Identity? = nil, preferences: ChannelMembershipPreferences? = nil) {
            self.channelArn = channelArn
            self.member = member
            self.preferences = preferences
        }

        private enum CodingKeys: String, CodingKey {
            case channelArn = "ChannelArn"
            case member = "Member"
            case preferences = "Preferences"
        }
    }

    public struct PutMessagingStreamingConfigurationsRequest: AWSEncodableShape {
        /// The ARN of the streaming configuration.
        public let appInstanceArn: String
        /// The streaming configurations.
        public let streamingConfigurations: [StreamingConfiguration]

        @inlinable
        public init(appInstanceArn: String, streamingConfigurations: [StreamingConfiguration]) {
            self.appInstanceArn = appInstanceArn
            self.streamingConfigurations = streamingConfigurations
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.appInstanceArn, key: "AppInstanceArn")
            try container.encode(self.streamingConfigurations, forKey: .streamingConfigurations)
        }

        public func validate(name: String) throws {
            try self.validate(self.appInstanceArn, name: "appInstanceArn", parent: name, max: 1600)
            try self.validate(self.appInstanceArn, name: "appInstanceArn", parent: name, min: 5)
            try self.validate(self.appInstanceArn, name: "appInstanceArn", parent: name, pattern: "^arn:[a-z0-9-\\.]{1,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[^/].{0,1023}$")
            try self.streamingConfigurations.forEach {
                try $0.validate(name: "\(name).streamingConfigurations[]")
            }
            try self.validate(self.streamingConfigurations, name: "streamingConfigurations", parent: name, max: 2)
            try self.validate(self.streamingConfigurations, name: "streamingConfigurations", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case streamingConfigurations = "StreamingConfigurations"
        }
    }

    public struct PutMessagingStreamingConfigurationsResponse: AWSDecodableShape {
        /// The requested streaming configurations.
        public let streamingConfigurations: [StreamingConfiguration]?

        @inlinable
        public init(streamingConfigurations: [StreamingConfiguration]? = nil) {
            self.streamingConfigurations = streamingConfigurations
        }

        private enum CodingKeys: String, CodingKey {
            case streamingConfigurations = "StreamingConfigurations"
        }
    }

    public struct RedactChannelMessageRequest: AWSEncodableShape {
        /// The ARN of the channel containing the messages that you want to redact.
        public let channelArn: String
        /// The ARN of the AppInstanceUser or AppInstanceBot  that makes the API call.
        public let chimeBearer: String
        /// The ID of the message being redacted.
        public let messageId: String
        /// The ID of the SubChannel in the request.
        public let subChannelId: String?

        @inlinable
        public init(channelArn: String, chimeBearer: String, messageId: String, subChannelId: String? = nil) {
            self.channelArn = channelArn
            self.chimeBearer = chimeBearer
            self.messageId = messageId
            self.subChannelId = subChannelId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.channelArn, key: "ChannelArn")
            request.encodeHeader(self.chimeBearer, key: "x-amz-chime-bearer")
            request.encodePath(self.messageId, key: "MessageId")
            try container.encodeIfPresent(self.subChannelId, forKey: .subChannelId)
        }

        public func validate(name: String) throws {
            try self.validate(self.channelArn, name: "channelArn", parent: name, max: 1600)
            try self.validate(self.channelArn, name: "channelArn", parent: name, min: 5)
            try self.validate(self.channelArn, name: "channelArn", parent: name, pattern: "^arn:[a-z0-9-\\.]{1,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[^/].{0,1023}$")
            try self.validate(self.chimeBearer, name: "chimeBearer", parent: name, max: 1600)
            try self.validate(self.chimeBearer, name: "chimeBearer", parent: name, min: 5)
            try self.validate(self.chimeBearer, name: "chimeBearer", parent: name, pattern: "^arn:[a-z0-9-\\.]{1,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[^/].{0,1023}$")
            try self.validate(self.messageId, name: "messageId", parent: name, max: 128)
            try self.validate(self.messageId, name: "messageId", parent: name, min: 1)
            try self.validate(self.messageId, name: "messageId", parent: name, pattern: "^[-_a-zA-Z0-9]*$")
            try self.validate(self.subChannelId, name: "subChannelId", parent: name, max: 128)
            try self.validate(self.subChannelId, name: "subChannelId", parent: name, min: 1)
            try self.validate(self.subChannelId, name: "subChannelId", parent: name, pattern: "^[-_a-zA-Z0-9]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case subChannelId = "SubChannelId"
        }
    }

    public struct RedactChannelMessageResponse: AWSDecodableShape {
        /// The ARN of the channel containing the messages that you want to redact.
        public let channelArn: String?
        /// The ID of the message being redacted.
        public let messageId: String?
        /// The ID of the SubChannel in the response.  Only required when redacting messages in a SubChannel that the user belongs to.
        public let subChannelId: String?

        @inlinable
        public init(channelArn: String? = nil, messageId: String? = nil, subChannelId: String? = nil) {
            self.channelArn = channelArn
            self.messageId = messageId
            self.subChannelId = subChannelId
        }

        private enum CodingKeys: String, CodingKey {
            case channelArn = "ChannelArn"
            case messageId = "MessageId"
            case subChannelId = "SubChannelId"
        }
    }

    public struct ResourceLimitExceededException: AWSErrorShape {
        public let code: ErrorCode?
        public let message: String?

        @inlinable
        public init(code: ErrorCode? = nil, message: String? = nil) {
            self.code = code
            self.message = message
        }

        private enum CodingKeys: String, CodingKey {
            case code = "Code"
            case message = "Message"
        }
    }

    public struct SearchChannelsRequest: AWSEncodableShape {
        /// The AppInstanceUserArn of the user making the API call.
        public let chimeBearer: String?
        /// A list of the Field objects in the channel being searched.
        public let fields: [SearchField]
        /// The maximum number of channels that you want returned.
        public let maxResults: Int?
        /// The token returned from previous API requests until the number of channels is reached.
        public let nextToken: String?

        @inlinable
        public init(chimeBearer: String? = nil, fields: [SearchField], maxResults: Int? = nil, nextToken: String? = nil) {
            self.chimeBearer = chimeBearer
            self.fields = fields
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodeHeader(self.chimeBearer, key: "x-amz-chime-bearer")
            try container.encode(self.fields, forKey: .fields)
            request.encodeQuery(self.maxResults, key: "max-results")
            request.encodeQuery(self.nextToken, key: "next-token")
        }

        public func validate(name: String) throws {
            try self.validate(self.chimeBearer, name: "chimeBearer", parent: name, max: 1600)
            try self.validate(self.chimeBearer, name: "chimeBearer", parent: name, min: 5)
            try self.validate(self.chimeBearer, name: "chimeBearer", parent: name, pattern: "^arn:[a-z0-9-\\.]{1,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[^/].{0,1023}$")
            try self.fields.forEach {
                try $0.validate(name: "\(name).fields[]")
            }
            try self.validate(self.fields, name: "fields", parent: name, max: 20)
            try self.validate(self.fields, name: "fields", parent: name, min: 1)
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 50)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 2048)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: ".*")
        }

        private enum CodingKeys: String, CodingKey {
            case fields = "Fields"
        }
    }

    public struct SearchChannelsResponse: AWSDecodableShape {
        /// A list of the channels in the request.
        public let channels: [ChannelSummary]?
        /// The token returned from previous API responses until the number of channels is reached.
        public let nextToken: String?

        @inlinable
        public init(channels: [ChannelSummary]? = nil, nextToken: String? = nil) {
            self.channels = channels
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case channels = "Channels"
            case nextToken = "NextToken"
        }
    }

    public struct SearchField: AWSEncodableShape {
        /// An enum value that indicates the key to search the channel on. MEMBERS allows you to search channels based on memberships. You can use it with the EQUALS  operator to get channels whose memberships are equal to the specified values, and with the INCLUDES  operator to get channels whose memberships include the specified values.
        public let key: SearchFieldKey
        /// The operator used to compare field values, currently EQUALS or INCLUDES.  Use the EQUALS operator to find channels whose memberships equal the specified values.  Use the INCLUDES operator to find channels whose memberships include the specified values.
        public let `operator`: SearchFieldOperator
        /// The values that you want to search for, a list of strings. The values must be AppInstanceUserArns specified as a list of strings.  This operation isn't supported for AppInstanceUsers with large number of memberships.
        public let values: [String]

        @inlinable
        public init(key: SearchFieldKey, operator: SearchFieldOperator, values: [String]) {
            self.key = key
            self.`operator` = `operator`
            self.values = values
        }

        public func validate(name: String) throws {
            try self.values.forEach {
                try validate($0, name: "values[]", parent: name, max: 512)
                try validate($0, name: "values[]", parent: name, min: 1)
                try validate($0, name: "values[]", parent: name, pattern: "^[\\s\\S]*$")
            }
            try self.validate(self.values, name: "values", parent: name, max: 20)
            try self.validate(self.values, name: "values", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case key = "Key"
            case `operator` = "Operator"
            case values = "Values"
        }
    }

    public struct SendChannelMessageRequest: AWSEncodableShape {
        /// The ARN of the channel.
        public let channelArn: String
        /// The ARN of the AppInstanceUser or AppInstanceBot  that makes the API call.
        public let chimeBearer: String
        /// The Idempotency token for each client request.
        public let clientRequestToken: String
        /// The content of the channel message.
        public let content: String
        /// The content type of the channel message.
        public let contentType: String?
        /// The attributes for the message, used for message filtering along with a FilterRule defined in the PushNotificationPreferences.
        public let messageAttributes: [String: MessageAttributeValue]?
        /// The optional metadata for each message.
        public let metadata: String?
        /// Boolean that controls whether the message is persisted on the back end. Required.
        public let persistence: ChannelMessagePersistenceType
        /// The push notification configuration of the message.
        public let pushNotification: PushNotificationConfiguration?
        /// The ID of the SubChannel in the request.
        public let subChannelId: String?
        /// The target of a message. Must be a member of the channel, such as another user, a bot, or the sender. Only the target and the sender can view targeted messages. Only users who can see targeted messages can take actions on them. However, administrators can delete targeted messages that they can’t see.
        public let target: [Target]?
        /// The type of message, STANDARD or CONTROL.  STANDARD messages can be up to 4KB in size and contain metadata. Metadata is arbitrary,  and you can use it in a variety of ways, such as containing a link to an attachment.  CONTROL messages are limited to 30 bytes and do not contain metadata.
        public let type: ChannelMessageType

        @inlinable
        public init(channelArn: String, chimeBearer: String, clientRequestToken: String = SendChannelMessageRequest.idempotencyToken(), content: String, contentType: String? = nil, messageAttributes: [String: MessageAttributeValue]? = nil, metadata: String? = nil, persistence: ChannelMessagePersistenceType, pushNotification: PushNotificationConfiguration? = nil, subChannelId: String? = nil, target: [Target]? = nil, type: ChannelMessageType) {
            self.channelArn = channelArn
            self.chimeBearer = chimeBearer
            self.clientRequestToken = clientRequestToken
            self.content = content
            self.contentType = contentType
            self.messageAttributes = messageAttributes
            self.metadata = metadata
            self.persistence = persistence
            self.pushNotification = pushNotification
            self.subChannelId = subChannelId
            self.target = target
            self.type = type
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.channelArn, key: "ChannelArn")
            request.encodeHeader(self.chimeBearer, key: "x-amz-chime-bearer")
            try container.encode(self.clientRequestToken, forKey: .clientRequestToken)
            try container.encode(self.content, forKey: .content)
            try container.encodeIfPresent(self.contentType, forKey: .contentType)
            try container.encodeIfPresent(self.messageAttributes, forKey: .messageAttributes)
            try container.encodeIfPresent(self.metadata, forKey: .metadata)
            try container.encode(self.persistence, forKey: .persistence)
            try container.encodeIfPresent(self.pushNotification, forKey: .pushNotification)
            try container.encodeIfPresent(self.subChannelId, forKey: .subChannelId)
            try container.encodeIfPresent(self.target, forKey: .target)
            try container.encode(self.type, forKey: .type)
        }

        public func validate(name: String) throws {
            try self.validate(self.channelArn, name: "channelArn", parent: name, max: 1600)
            try self.validate(self.channelArn, name: "channelArn", parent: name, min: 5)
            try self.validate(self.channelArn, name: "channelArn", parent: name, pattern: "^arn:[a-z0-9-\\.]{1,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[^/].{0,1023}$")
            try self.validate(self.chimeBearer, name: "chimeBearer", parent: name, max: 1600)
            try self.validate(self.chimeBearer, name: "chimeBearer", parent: name, min: 5)
            try self.validate(self.chimeBearer, name: "chimeBearer", parent: name, pattern: "^arn:[a-z0-9-\\.]{1,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[^/].{0,1023}$")
            try self.validate(self.clientRequestToken, name: "clientRequestToken", parent: name, max: 64)
            try self.validate(self.clientRequestToken, name: "clientRequestToken", parent: name, min: 2)
            try self.validate(self.clientRequestToken, name: "clientRequestToken", parent: name, pattern: "^[-_a-zA-Z0-9]*$")
            try self.validate(self.content, name: "content", parent: name, min: 1)
            try self.validate(self.content, name: "content", parent: name, pattern: "^[\\s\\S]*$")
            try self.validate(self.contentType, name: "contentType", parent: name, max: 45)
            try self.validate(self.contentType, name: "contentType", parent: name, pattern: "^[\\s\\S]*$")
            try self.messageAttributes?.forEach {
                try validate($0.key, name: "messageAttributes.key", parent: name, max: 64)
                try validate($0.key, name: "messageAttributes.key", parent: name, min: 1)
                try validate($0.key, name: "messageAttributes.key", parent: name, pattern: "^[\\s\\S]*$")
                try $0.value.validate(name: "\(name).messageAttributes[\"\($0.key)\"]")
            }
            try self.validate(self.metadata, name: "metadata", parent: name, max: 1024)
            try self.validate(self.metadata, name: "metadata", parent: name, pattern: ".*")
            try self.pushNotification?.validate(name: "\(name).pushNotification")
            try self.validate(self.subChannelId, name: "subChannelId", parent: name, max: 128)
            try self.validate(self.subChannelId, name: "subChannelId", parent: name, min: 1)
            try self.validate(self.subChannelId, name: "subChannelId", parent: name, pattern: "^[-_a-zA-Z0-9]*$")
            try self.target?.forEach {
                try $0.validate(name: "\(name).target[]")
            }
            try self.validate(self.target, name: "target", parent: name, max: 1)
            try self.validate(self.target, name: "target", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case clientRequestToken = "ClientRequestToken"
            case content = "Content"
            case contentType = "ContentType"
            case messageAttributes = "MessageAttributes"
            case metadata = "Metadata"
            case persistence = "Persistence"
            case pushNotification = "PushNotification"
            case subChannelId = "SubChannelId"
            case target = "Target"
            case type = "Type"
        }
    }

    public struct SendChannelMessageResponse: AWSDecodableShape {
        /// The ARN of the channel.
        public let channelArn: String?
        /// The ID string assigned to each message.
        public let messageId: String?
        /// The status of the channel message.
        public let status: ChannelMessageStatusStructure?
        /// The ID of the SubChannel in the response.
        public let subChannelId: String?

        @inlinable
        public init(channelArn: String? = nil, messageId: String? = nil, status: ChannelMessageStatusStructure? = nil, subChannelId: String? = nil) {
            self.channelArn = channelArn
            self.messageId = messageId
            self.status = status
            self.subChannelId = subChannelId
        }

        private enum CodingKeys: String, CodingKey {
            case channelArn = "ChannelArn"
            case messageId = "MessageId"
            case status = "Status"
            case subChannelId = "SubChannelId"
        }
    }

    public struct ServiceFailureException: AWSErrorShape {
        public let code: ErrorCode?
        public let message: String?

        @inlinable
        public init(code: ErrorCode? = nil, message: String? = nil) {
            self.code = code
            self.message = message
        }

        private enum CodingKeys: String, CodingKey {
            case code = "Code"
            case message = "Message"
        }
    }

    public struct ServiceUnavailableException: AWSErrorShape {
        public let code: ErrorCode?
        public let message: String?

        @inlinable
        public init(code: ErrorCode? = nil, message: String? = nil) {
            self.code = code
            self.message = message
        }

        private enum CodingKeys: String, CodingKey {
            case code = "Code"
            case message = "Message"
        }
    }

    public struct StreamingConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The data type of the configuration.
        public let dataType: MessagingDataType
        /// The ARN of the resource in the configuration.
        public let resourceArn: String

        @inlinable
        public init(dataType: MessagingDataType, resourceArn: String) {
            self.dataType = dataType
            self.resourceArn = resourceArn
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, max: 1600)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, min: 5)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, pattern: "^arn:[a-z0-9-\\.]{1,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[^/].{0,1023}$")
        }

        private enum CodingKeys: String, CodingKey {
            case dataType = "DataType"
            case resourceArn = "ResourceArn"
        }
    }

    public struct SubChannelSummary: AWSDecodableShape {
        /// The number of members in a SubChannel.
        public let membershipCount: Int?
        /// The unique ID of a SubChannel.
        public let subChannelId: String?

        @inlinable
        public init(membershipCount: Int? = nil, subChannelId: String? = nil) {
            self.membershipCount = membershipCount
            self.subChannelId = subChannelId
        }

        private enum CodingKeys: String, CodingKey {
            case membershipCount = "MembershipCount"
            case subChannelId = "SubChannelId"
        }
    }

    public struct Tag: AWSEncodableShape & AWSDecodableShape {
        /// The key in a tag.
        public let key: String
        /// The value in a tag.
        public let value: String

        @inlinable
        public init(key: String, value: String) {
            self.key = key
            self.value = value
        }

        public func validate(name: String) throws {
            try self.validate(self.key, name: "key", parent: name, max: 128)
            try self.validate(self.key, name: "key", parent: name, min: 1)
            try self.validate(self.value, name: "value", parent: name, max: 256)
            try self.validate(self.value, name: "value", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case key = "Key"
            case value = "Value"
        }
    }

    public struct TagResourceRequest: AWSEncodableShape {
        /// The resource ARN.
        public let resourceARN: String
        /// The tag key-value pairs.
        public let tags: [Tag]

        @inlinable
        public init(resourceARN: String, tags: [Tag]) {
            self.resourceARN = resourceARN
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceARN, name: "resourceARN", parent: name, max: 1600)
            try self.validate(self.resourceARN, name: "resourceARN", parent: name, min: 5)
            try self.validate(self.resourceARN, name: "resourceARN", parent: name, pattern: "^arn:[a-z0-9-\\.]{1,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[^/].{0,1023}$")
            try self.tags.forEach {
                try $0.validate(name: "\(name).tags[]")
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 50)
            try self.validate(self.tags, name: "tags", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case resourceARN = "ResourceARN"
            case tags = "Tags"
        }
    }

    public struct Target: AWSEncodableShape & AWSDecodableShape {
        /// The ARN of the target channel member.
        public let memberArn: String?

        @inlinable
        public init(memberArn: String? = nil) {
            self.memberArn = memberArn
        }

        public func validate(name: String) throws {
            try self.validate(self.memberArn, name: "memberArn", parent: name, max: 1600)
            try self.validate(self.memberArn, name: "memberArn", parent: name, min: 5)
            try self.validate(self.memberArn, name: "memberArn", parent: name, pattern: "^arn:[a-z0-9-\\.]{1,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[^/].{0,1023}$")
        }

        private enum CodingKeys: String, CodingKey {
            case memberArn = "MemberArn"
        }
    }

    public struct ThrottledClientException: AWSErrorShape {
        public let code: ErrorCode?
        public let message: String?

        @inlinable
        public init(code: ErrorCode? = nil, message: String? = nil) {
            self.code = code
            self.message = message
        }

        private enum CodingKeys: String, CodingKey {
            case code = "Code"
            case message = "Message"
        }
    }

    public struct UnauthorizedClientException: AWSErrorShape {
        public let code: ErrorCode?
        public let message: String?

        @inlinable
        public init(code: ErrorCode? = nil, message: String? = nil) {
            self.code = code
            self.message = message
        }

        private enum CodingKeys: String, CodingKey {
            case code = "Code"
            case message = "Message"
        }
    }

    public struct UntagResourceRequest: AWSEncodableShape {
        /// The resource ARN.
        public let resourceARN: String
        /// The tag keys.
        public let tagKeys: [String]

        @inlinable
        public init(resourceARN: String, tagKeys: [String]) {
            self.resourceARN = resourceARN
            self.tagKeys = tagKeys
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceARN, name: "resourceARN", parent: name, max: 1600)
            try self.validate(self.resourceARN, name: "resourceARN", parent: name, min: 5)
            try self.validate(self.resourceARN, name: "resourceARN", parent: name, pattern: "^arn:[a-z0-9-\\.]{1,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[^/].{0,1023}$")
            try self.tagKeys.forEach {
                try validate($0, name: "tagKeys[]", parent: name, max: 128)
                try validate($0, name: "tagKeys[]", parent: name, min: 1)
            }
            try self.validate(self.tagKeys, name: "tagKeys", parent: name, max: 50)
            try self.validate(self.tagKeys, name: "tagKeys", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case resourceARN = "ResourceARN"
            case tagKeys = "TagKeys"
        }
    }

    public struct UpdateChannelFlowRequest: AWSEncodableShape {
        /// The ARN of the channel flow.
        public let channelFlowArn: String
        /// The name of the channel flow.
        public let name: String
        /// Information about the processor Lambda functions
        public let processors: [Processor]

        @inlinable
        public init(channelFlowArn: String, name: String, processors: [Processor]) {
            self.channelFlowArn = channelFlowArn
            self.name = name
            self.processors = processors
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.channelFlowArn, key: "ChannelFlowArn")
            try container.encode(self.name, forKey: .name)
            try container.encode(self.processors, forKey: .processors)
        }

        public func validate(name: String) throws {
            try self.validate(self.channelFlowArn, name: "channelFlowArn", parent: name, max: 1600)
            try self.validate(self.channelFlowArn, name: "channelFlowArn", parent: name, min: 5)
            try self.validate(self.channelFlowArn, name: "channelFlowArn", parent: name, pattern: "^arn:[a-z0-9-\\.]{1,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[^/].{0,1023}$")
            try self.validate(self.name, name: "name", parent: name, max: 256)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[\\u0009\\u000A\\u000D\\u0020-\\u007E\\u0085\\u00A0-\\uD7FF\\uE000-\\uFFFD\\u10000-\\u10FFFF]*$")
            try self.processors.forEach {
                try $0.validate(name: "\(name).processors[]")
            }
            try self.validate(self.processors, name: "processors", parent: name, max: 3)
            try self.validate(self.processors, name: "processors", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case name = "Name"
            case processors = "Processors"
        }
    }

    public struct UpdateChannelFlowResponse: AWSDecodableShape {
        /// The ARN of the channel flow.
        public let channelFlowArn: String?

        @inlinable
        public init(channelFlowArn: String? = nil) {
            self.channelFlowArn = channelFlowArn
        }

        private enum CodingKeys: String, CodingKey {
            case channelFlowArn = "ChannelFlowArn"
        }
    }

    public struct UpdateChannelMessageRequest: AWSEncodableShape {
        /// The ARN of the channel.
        public let channelArn: String
        /// The ARN of the AppInstanceUser or AppInstanceBot  that makes the API call.
        public let chimeBearer: String
        /// The content of the channel message.
        public let content: String
        /// The content type of the channel message.
        public let contentType: String?
        /// The ID string of the message being updated.
        public let messageId: String
        /// The metadata of the message being updated.
        public let metadata: String?
        /// The ID of the SubChannel in the request.  Only required when updating messages in a SubChannel that the user belongs to.
        public let subChannelId: String?

        @inlinable
        public init(channelArn: String, chimeBearer: String, content: String, contentType: String? = nil, messageId: String, metadata: String? = nil, subChannelId: String? = nil) {
            self.channelArn = channelArn
            self.chimeBearer = chimeBearer
            self.content = content
            self.contentType = contentType
            self.messageId = messageId
            self.metadata = metadata
            self.subChannelId = subChannelId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.channelArn, key: "ChannelArn")
            request.encodeHeader(self.chimeBearer, key: "x-amz-chime-bearer")
            try container.encode(self.content, forKey: .content)
            try container.encodeIfPresent(self.contentType, forKey: .contentType)
            request.encodePath(self.messageId, key: "MessageId")
            try container.encodeIfPresent(self.metadata, forKey: .metadata)
            try container.encodeIfPresent(self.subChannelId, forKey: .subChannelId)
        }

        public func validate(name: String) throws {
            try self.validate(self.channelArn, name: "channelArn", parent: name, max: 1600)
            try self.validate(self.channelArn, name: "channelArn", parent: name, min: 5)
            try self.validate(self.channelArn, name: "channelArn", parent: name, pattern: "^arn:[a-z0-9-\\.]{1,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[^/].{0,1023}$")
            try self.validate(self.chimeBearer, name: "chimeBearer", parent: name, max: 1600)
            try self.validate(self.chimeBearer, name: "chimeBearer", parent: name, min: 5)
            try self.validate(self.chimeBearer, name: "chimeBearer", parent: name, pattern: "^arn:[a-z0-9-\\.]{1,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[^/].{0,1023}$")
            try self.validate(self.content, name: "content", parent: name, min: 1)
            try self.validate(self.content, name: "content", parent: name, pattern: "^[\\s\\S]*$")
            try self.validate(self.contentType, name: "contentType", parent: name, max: 45)
            try self.validate(self.contentType, name: "contentType", parent: name, pattern: "^[\\s\\S]*$")
            try self.validate(self.messageId, name: "messageId", parent: name, max: 128)
            try self.validate(self.messageId, name: "messageId", parent: name, min: 1)
            try self.validate(self.messageId, name: "messageId", parent: name, pattern: "^[-_a-zA-Z0-9]*$")
            try self.validate(self.metadata, name: "metadata", parent: name, max: 1024)
            try self.validate(self.metadata, name: "metadata", parent: name, pattern: ".*")
            try self.validate(self.subChannelId, name: "subChannelId", parent: name, max: 128)
            try self.validate(self.subChannelId, name: "subChannelId", parent: name, min: 1)
            try self.validate(self.subChannelId, name: "subChannelId", parent: name, pattern: "^[-_a-zA-Z0-9]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case content = "Content"
            case contentType = "ContentType"
            case metadata = "Metadata"
            case subChannelId = "SubChannelId"
        }
    }

    public struct UpdateChannelMessageResponse: AWSDecodableShape {
        /// The ARN of the channel.
        public let channelArn: String?
        /// The ID string of the message being updated.
        public let messageId: String?
        /// The status of the message update.
        public let status: ChannelMessageStatusStructure?
        /// The ID of the SubChannel in the response.
        public let subChannelId: String?

        @inlinable
        public init(channelArn: String? = nil, messageId: String? = nil, status: ChannelMessageStatusStructure? = nil, subChannelId: String? = nil) {
            self.channelArn = channelArn
            self.messageId = messageId
            self.status = status
            self.subChannelId = subChannelId
        }

        private enum CodingKeys: String, CodingKey {
            case channelArn = "ChannelArn"
            case messageId = "MessageId"
            case status = "Status"
            case subChannelId = "SubChannelId"
        }
    }

    public struct UpdateChannelReadMarkerRequest: AWSEncodableShape {
        /// The ARN of the channel.
        public let channelArn: String
        /// The ARN of the AppInstanceUser or AppInstanceBot  that makes the API call.
        public let chimeBearer: String

        @inlinable
        public init(channelArn: String, chimeBearer: String) {
            self.channelArn = channelArn
            self.chimeBearer = chimeBearer
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.channelArn, key: "ChannelArn")
            request.encodeHeader(self.chimeBearer, key: "x-amz-chime-bearer")
        }

        public func validate(name: String) throws {
            try self.validate(self.channelArn, name: "channelArn", parent: name, max: 1600)
            try self.validate(self.channelArn, name: "channelArn", parent: name, min: 5)
            try self.validate(self.channelArn, name: "channelArn", parent: name, pattern: "^arn:[a-z0-9-\\.]{1,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[^/].{0,1023}$")
            try self.validate(self.chimeBearer, name: "chimeBearer", parent: name, max: 1600)
            try self.validate(self.chimeBearer, name: "chimeBearer", parent: name, min: 5)
            try self.validate(self.chimeBearer, name: "chimeBearer", parent: name, pattern: "^arn:[a-z0-9-\\.]{1,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[^/].{0,1023}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct UpdateChannelReadMarkerResponse: AWSDecodableShape {
        /// The ARN of the channel.
        public let channelArn: String?

        @inlinable
        public init(channelArn: String? = nil) {
            self.channelArn = channelArn
        }

        private enum CodingKeys: String, CodingKey {
            case channelArn = "ChannelArn"
        }
    }

    public struct UpdateChannelRequest: AWSEncodableShape {
        /// The ARN of the channel.
        public let channelArn: String
        /// The ARN of the AppInstanceUser or AppInstanceBot  that makes the API call.
        public let chimeBearer: String
        /// The metadata for the update request.
        public let metadata: String?
        /// The mode of the update request.
        public let mode: ChannelMode?
        /// The name of the channel.
        public let name: String?

        @inlinable
        public init(channelArn: String, chimeBearer: String, metadata: String? = nil, mode: ChannelMode? = nil, name: String? = nil) {
            self.channelArn = channelArn
            self.chimeBearer = chimeBearer
            self.metadata = metadata
            self.mode = mode
            self.name = name
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.channelArn, key: "ChannelArn")
            request.encodeHeader(self.chimeBearer, key: "x-amz-chime-bearer")
            try container.encodeIfPresent(self.metadata, forKey: .metadata)
            try container.encodeIfPresent(self.mode, forKey: .mode)
            try container.encodeIfPresent(self.name, forKey: .name)
        }

        public func validate(name: String) throws {
            try self.validate(self.channelArn, name: "channelArn", parent: name, max: 1600)
            try self.validate(self.channelArn, name: "channelArn", parent: name, min: 5)
            try self.validate(self.channelArn, name: "channelArn", parent: name, pattern: "^arn:[a-z0-9-\\.]{1,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[^/].{0,1023}$")
            try self.validate(self.chimeBearer, name: "chimeBearer", parent: name, max: 1600)
            try self.validate(self.chimeBearer, name: "chimeBearer", parent: name, min: 5)
            try self.validate(self.chimeBearer, name: "chimeBearer", parent: name, pattern: "^arn:[a-z0-9-\\.]{1,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[^/].{0,1023}$")
            try self.validate(self.metadata, name: "metadata", parent: name, max: 1024)
            try self.validate(self.metadata, name: "metadata", parent: name, pattern: ".*")
            try self.validate(self.name, name: "name", parent: name, max: 256)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[\\u0009\\u000A\\u000D\\u0020-\\u007E\\u0085\\u00A0-\\uD7FF\\uE000-\\uFFFD\\u10000-\\u10FFFF]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case metadata = "Metadata"
            case mode = "Mode"
            case name = "Name"
        }
    }

    public struct UpdateChannelResponse: AWSDecodableShape {
        /// The ARN of the channel.
        public let channelArn: String?

        @inlinable
        public init(channelArn: String? = nil) {
            self.channelArn = channelArn
        }

        private enum CodingKeys: String, CodingKey {
            case channelArn = "ChannelArn"
        }
    }
}

// MARK: - Errors

/// Error enum for ChimeSDKMessaging
public struct ChimeSDKMessagingErrorType: AWSErrorType {
    enum Code: String {
        case badRequestException = "BadRequestException"
        case conflictException = "ConflictException"
        case forbiddenException = "ForbiddenException"
        case notFoundException = "NotFoundException"
        case resourceLimitExceededException = "ResourceLimitExceededException"
        case serviceFailureException = "ServiceFailureException"
        case serviceUnavailableException = "ServiceUnavailableException"
        case throttledClientException = "ThrottledClientException"
        case unauthorizedClientException = "UnauthorizedClientException"
    }

    private let error: Code
    public let context: AWSErrorContext?

    /// initialize ChimeSDKMessaging
    public init?(errorCode: String, context: AWSErrorContext) {
        guard let error = Code(rawValue: errorCode) else { return nil }
        self.error = error
        self.context = context
    }

    internal init(_ error: Code) {
        self.error = error
        self.context = nil
    }

    /// return error code string
    public var errorCode: String { self.error.rawValue }

    /// The input parameters don't match the service's restrictions.
    public static var badRequestException: Self { .init(.badRequestException) }
    /// The request could not be processed because of conflict in the current state of the resource.
    public static var conflictException: Self { .init(.conflictException) }
    /// The client is permanently forbidden from making the request.
    public static var forbiddenException: Self { .init(.forbiddenException) }
    /// One or more of the resources in the request does not exist in the system.
    public static var notFoundException: Self { .init(.notFoundException) }
    /// The request exceeds the resource limit.
    public static var resourceLimitExceededException: Self { .init(.resourceLimitExceededException) }
    /// The service encountered an unexpected error.
    public static var serviceFailureException: Self { .init(.serviceFailureException) }
    /// The service is currently unavailable.
    public static var serviceUnavailableException: Self { .init(.serviceUnavailableException) }
    /// The client exceeded its request rate limit.
    public static var throttledClientException: Self { .init(.throttledClientException) }
    /// The client is not currently authorized to make the request.
    public static var unauthorizedClientException: Self { .init(.unauthorizedClientException) }
}

extension ChimeSDKMessagingErrorType: AWSServiceErrorType {
    public static let errorCodeMap: [String: AWSErrorShape.Type] = [
        "BadRequestException": ChimeSDKMessaging.BadRequestException.self,
        "ConflictException": ChimeSDKMessaging.ConflictException.self,
        "ForbiddenException": ChimeSDKMessaging.ForbiddenException.self,
        "NotFoundException": ChimeSDKMessaging.NotFoundException.self,
        "ResourceLimitExceededException": ChimeSDKMessaging.ResourceLimitExceededException.self,
        "ServiceFailureException": ChimeSDKMessaging.ServiceFailureException.self,
        "ServiceUnavailableException": ChimeSDKMessaging.ServiceUnavailableException.self,
        "ThrottledClientException": ChimeSDKMessaging.ThrottledClientException.self,
        "UnauthorizedClientException": ChimeSDKMessaging.UnauthorizedClientException.self
    ]
}

extension ChimeSDKMessagingErrorType: Equatable {
    public static func == (lhs: ChimeSDKMessagingErrorType, rhs: ChimeSDKMessagingErrorType) -> Bool {
        lhs.error == rhs.error
    }
}

extension ChimeSDKMessagingErrorType: CustomStringConvertible {
    public var description: String {
        return "\(self.error.rawValue): \(self.message ?? "")"
    }
}
