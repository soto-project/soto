//===----------------------------------------------------------------------===//
//
// This source file is part of the Soto for AWS open source project
//
// Copyright (c) 2017-2024 the Soto project authors
// Licensed under Apache License v2.0
//
// See LICENSE.txt for license information
// See CONTRIBUTORS.txt for the list of Soto project authors
//
// SPDX-License-Identifier: Apache-2.0
//
//===----------------------------------------------------------------------===//

// THIS FILE IS AUTOMATICALLY GENERATED by https://github.com/soto-project/soto-codegenerator.
// DO NOT EDIT.

#if os(Linux) && compiler(<5.10)
// swift-corelibs-foundation hasn't been updated with Sendable conformances
@preconcurrency import Foundation
#else
import Foundation
#endif
@_exported import SotoCore

/// Service object for interacting with AWS Nimble service.
///
/// Welcome to the Amazon Nimble Studio API reference. This API reference provides methods, schema, resources, parameters, and more to help you get the most out of Nimble Studio. Nimble Studio is a virtual studio that empowers visual effects, animation, and interactive content teams to create content securely within a scalable, private cloud service.
public struct Nimble: AWSService {
    // MARK: Member variables

    /// Client used for communication with AWS
    public let client: AWSClient
    /// Service configuration
    public let config: AWSServiceConfig

    // MARK: Initialization

    /// Initialize the Nimble client
    /// - parameters:
    ///     - client: AWSClient used to process requests
    ///     - region: Region of server you want to communicate with. This will override the partition parameter.
    ///     - partition: AWS partition where service resides, standard (.aws), china (.awscn), government (.awsusgov).
    ///     - endpoint: Custom endpoint URL to use instead of standard AWS servers
    ///     - middleware: Middleware chain used to edit requests before they are sent and responses before they are decoded 
    ///     - timeout: Timeout value for HTTP requests
    ///     - byteBufferAllocator: Allocator for ByteBuffers
    ///     - options: Service options
    public init(
        client: AWSClient,
        region: SotoCore.Region? = nil,
        partition: AWSPartition = .aws,
        endpoint: String? = nil,
        middleware: AWSMiddlewareProtocol? = nil,
        timeout: TimeAmount? = nil,
        byteBufferAllocator: ByteBufferAllocator = ByteBufferAllocator(),
        options: AWSServiceConfig.Options = []
    ) {
        self.client = client
        self.config = AWSServiceConfig(
            region: region,
            partition: region?.partition ?? partition,
            serviceName: "Nimble",
            serviceIdentifier: "nimble",
            serviceProtocol: .restjson,
            apiVersion: "2020-08-01",
            endpoint: endpoint,
            errorType: NimbleErrorType.self,
            middleware: middleware,
            timeout: timeout,
            byteBufferAllocator: byteBufferAllocator,
            options: options
        )
    }





    // MARK: API Calls

    /// Accept EULAs.
    @Sendable
    @inlinable
    public func acceptEulas(_ input: AcceptEulasRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> AcceptEulasResponse {
        try await self.client.execute(
            operation: "AcceptEulas", 
            path: "/2020-08-01/studios/{studioId}/eula-acceptances", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Accept EULAs.
    ///
    /// Parameters:
    ///   - clientToken: Unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If you don’t specify a client token, the Amazon Web Services SDK automatically generates a client token and uses it for the request to ensure idempotency.
    ///   - eulaIds: The EULA ID.
    ///   - studioId: The studio ID.
    ///   - logger: Logger use during operation
    @inlinable
    public func acceptEulas(
        clientToken: String? = AcceptEulasRequest.idempotencyToken(),
        eulaIds: [String]? = nil,
        studioId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> AcceptEulasResponse {
        let input = AcceptEulasRequest(
            clientToken: clientToken, 
            eulaIds: eulaIds, 
            studioId: studioId
        )
        return try await self.acceptEulas(input, logger: logger)
    }

    /// Create a launch profile.
    @Sendable
    @inlinable
    public func createLaunchProfile(_ input: CreateLaunchProfileRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> CreateLaunchProfileResponse {
        try await self.client.execute(
            operation: "CreateLaunchProfile", 
            path: "/2020-08-01/studios/{studioId}/launch-profiles", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Create a launch profile.
    ///
    /// Parameters:
    ///   - clientToken: Unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If you don’t specify a client token, the Amazon Web Services SDK automatically generates a client token and uses it for the request to ensure idempotency.
    ///   - description: The description.
    ///   - ec2SubnetIds: Specifies the IDs of the EC2 subnets where streaming sessions will be accessible from. These subnets must support the specified instance types.
    ///   - launchProfileProtocolVersions: The version number of the protocol that is used by the launch profile. The only valid version is "2021-03-31".
    ///   - name: The name for the launch profile.
    ///   - streamConfiguration: A configuration for a streaming session.
    ///   - studioComponentIds: Unique identifiers for a collection of studio components that can be used with this launch profile.
    ///   - studioId: The studio ID.
    ///   - tags: A collection of labels, in the form of key-value pairs, that apply to this resource.
    ///   - logger: Logger use during operation
    @inlinable
    public func createLaunchProfile(
        clientToken: String? = CreateLaunchProfileRequest.idempotencyToken(),
        description: String? = nil,
        ec2SubnetIds: [String],
        launchProfileProtocolVersions: [String],
        name: String,
        streamConfiguration: StreamConfigurationCreate,
        studioComponentIds: [String],
        studioId: String,
        tags: [String: String]? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> CreateLaunchProfileResponse {
        let input = CreateLaunchProfileRequest(
            clientToken: clientToken, 
            description: description, 
            ec2SubnetIds: ec2SubnetIds, 
            launchProfileProtocolVersions: launchProfileProtocolVersions, 
            name: name, 
            streamConfiguration: streamConfiguration, 
            studioComponentIds: studioComponentIds, 
            studioId: studioId, 
            tags: tags
        )
        return try await self.createLaunchProfile(input, logger: logger)
    }

    /// Creates a streaming image resource in a studio.
    @Sendable
    @inlinable
    public func createStreamingImage(_ input: CreateStreamingImageRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> CreateStreamingImageResponse {
        try await self.client.execute(
            operation: "CreateStreamingImage", 
            path: "/2020-08-01/studios/{studioId}/streaming-images", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Creates a streaming image resource in a studio.
    ///
    /// Parameters:
    ///   - clientToken: Unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If you don’t specify a client token, the Amazon Web Services SDK automatically generates a client token and uses it for the request to ensure idempotency.
    ///   - description: A human-readable description of the streaming image.
    ///   - ec2ImageId: The ID of an EC2 machine image with which to create this streaming image.
    ///   - name: A friendly name for a streaming image resource.
    ///   - studioId: The studio ID.
    ///   - tags: A collection of labels, in the form of key-value pairs, that apply to this resource.
    ///   - logger: Logger use during operation
    @inlinable
    public func createStreamingImage(
        clientToken: String? = CreateStreamingImageRequest.idempotencyToken(),
        description: String? = nil,
        ec2ImageId: String,
        name: String,
        studioId: String,
        tags: [String: String]? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> CreateStreamingImageResponse {
        let input = CreateStreamingImageRequest(
            clientToken: clientToken, 
            description: description, 
            ec2ImageId: ec2ImageId, 
            name: name, 
            studioId: studioId, 
            tags: tags
        )
        return try await self.createStreamingImage(input, logger: logger)
    }

    /// Creates a streaming session in a studio. After invoking this operation, you must poll GetStreamingSession until the streaming session is in the READY state.
    @Sendable
    @inlinable
    public func createStreamingSession(_ input: CreateStreamingSessionRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> CreateStreamingSessionResponse {
        try await self.client.execute(
            operation: "CreateStreamingSession", 
            path: "/2020-08-01/studios/{studioId}/streaming-sessions", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Creates a streaming session in a studio. After invoking this operation, you must poll GetStreamingSession until the streaming session is in the READY state.
    ///
    /// Parameters:
    ///   - clientToken: Unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If you don’t specify a client token, the Amazon Web Services SDK automatically generates a client token and uses it for the request to ensure idempotency.
    ///   - ec2InstanceType: The EC2 Instance type used for the streaming session.
    ///   - launchProfileId: The ID of the launch profile used to control access from the streaming session.
    ///   - ownedBy: The user ID of the user that owns the streaming session. The user that owns the session will be logging into the session and interacting with the virtual workstation.
    ///   - streamingImageId: The ID of the streaming image.
    ///   - studioId: The studio ID.
    ///   - tags: A collection of labels, in the form of key-value pairs, that apply to this resource.
    ///   - logger: Logger use during operation
    @inlinable
    public func createStreamingSession(
        clientToken: String? = CreateStreamingSessionRequest.idempotencyToken(),
        ec2InstanceType: StreamingInstanceType? = nil,
        launchProfileId: String,
        ownedBy: String? = nil,
        streamingImageId: String? = nil,
        studioId: String,
        tags: [String: String]? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> CreateStreamingSessionResponse {
        let input = CreateStreamingSessionRequest(
            clientToken: clientToken, 
            ec2InstanceType: ec2InstanceType, 
            launchProfileId: launchProfileId, 
            ownedBy: ownedBy, 
            streamingImageId: streamingImageId, 
            studioId: studioId, 
            tags: tags
        )
        return try await self.createStreamingSession(input, logger: logger)
    }

    /// Creates a streaming session stream for a streaming session. After invoking this API, invoke GetStreamingSessionStream with the returned streamId to poll the resource until it is in the READY state.
    @Sendable
    @inlinable
    public func createStreamingSessionStream(_ input: CreateStreamingSessionStreamRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> CreateStreamingSessionStreamResponse {
        try await self.client.execute(
            operation: "CreateStreamingSessionStream", 
            path: "/2020-08-01/studios/{studioId}/streaming-sessions/{sessionId}/streams", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Creates a streaming session stream for a streaming session. After invoking this API, invoke GetStreamingSessionStream with the returned streamId to poll the resource until it is in the READY state.
    ///
    /// Parameters:
    ///   - clientToken: Unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If you don’t specify a client token, the Amazon Web Services SDK automatically generates a client token and uses it for the request to ensure idempotency.
    ///   - expirationInSeconds: The expiration time in seconds.
    ///   - sessionId: The streaming session ID.
    ///   - studioId: The studio ID.
    ///   - logger: Logger use during operation
    @inlinable
    public func createStreamingSessionStream(
        clientToken: String? = CreateStreamingSessionStreamRequest.idempotencyToken(),
        expirationInSeconds: Int? = nil,
        sessionId: String,
        studioId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> CreateStreamingSessionStreamResponse {
        let input = CreateStreamingSessionStreamRequest(
            clientToken: clientToken, 
            expirationInSeconds: expirationInSeconds, 
            sessionId: sessionId, 
            studioId: studioId
        )
        return try await self.createStreamingSessionStream(input, logger: logger)
    }

    /// Create a new studio. When creating a studio, two IAM roles must be provided: the admin role and the user role. These roles are assumed by your users when they log in to the Nimble Studio portal. The user role must have the AmazonNimbleStudio-StudioUser managed policy attached for the portal to function properly. The admin role must have the AmazonNimbleStudio-StudioAdmin managed policy attached for the portal to function properly. You may optionally specify a KMS key in the StudioEncryptionConfiguration. In Nimble Studio, resource names, descriptions, initialization scripts, and other data you provide are always encrypted at rest using an KMS key. By default, this key is owned by Amazon Web Services and managed on your behalf. You may provide your own KMS key when calling CreateStudio to encrypt this data using a key you own and manage. When providing an KMS key during studio creation, Nimble Studio creates KMS grants in your account to provide your studio user and admin roles access to these KMS keys. If you delete this grant, the studio will no longer be accessible to your portal users. If you delete the studio KMS key, your studio will no longer be accessible.
    @Sendable
    @inlinable
    public func createStudio(_ input: CreateStudioRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> CreateStudioResponse {
        try await self.client.execute(
            operation: "CreateStudio", 
            path: "/2020-08-01/studios", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Create a new studio. When creating a studio, two IAM roles must be provided: the admin role and the user role. These roles are assumed by your users when they log in to the Nimble Studio portal. The user role must have the AmazonNimbleStudio-StudioUser managed policy attached for the portal to function properly. The admin role must have the AmazonNimbleStudio-StudioAdmin managed policy attached for the portal to function properly. You may optionally specify a KMS key in the StudioEncryptionConfiguration. In Nimble Studio, resource names, descriptions, initialization scripts, and other data you provide are always encrypted at rest using an KMS key. By default, this key is owned by Amazon Web Services and managed on your behalf. You may provide your own KMS key when calling CreateStudio to encrypt this data using a key you own and manage. When providing an KMS key during studio creation, Nimble Studio creates KMS grants in your account to provide your studio user and admin roles access to these KMS keys. If you delete this grant, the studio will no longer be accessible to your portal users. If you delete the studio KMS key, your studio will no longer be accessible.
    ///
    /// Parameters:
    ///   - adminRoleArn: The IAM role that studio admins will assume when logging in to the Nimble Studio portal.
    ///   - clientToken: Unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If you don’t specify a client token, the Amazon Web Services SDK automatically generates a client token and uses it for the request to ensure idempotency.
    ///   - displayName: A friendly name for the studio.
    ///   - studioEncryptionConfiguration: The studio encryption configuration.
    ///   - studioName: The studio name that is used in the URL of the Nimble Studio portal when accessed by Nimble Studio users.
    ///   - tags: A collection of labels, in the form of key-value pairs, that apply to this resource.
    ///   - userRoleArn: The IAM role that studio users will assume when logging in to the Nimble Studio portal.
    ///   - logger: Logger use during operation
    @inlinable
    public func createStudio(
        adminRoleArn: String,
        clientToken: String? = CreateStudioRequest.idempotencyToken(),
        displayName: String,
        studioEncryptionConfiguration: StudioEncryptionConfiguration? = nil,
        studioName: String,
        tags: [String: String]? = nil,
        userRoleArn: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> CreateStudioResponse {
        let input = CreateStudioRequest(
            adminRoleArn: adminRoleArn, 
            clientToken: clientToken, 
            displayName: displayName, 
            studioEncryptionConfiguration: studioEncryptionConfiguration, 
            studioName: studioName, 
            tags: tags, 
            userRoleArn: userRoleArn
        )
        return try await self.createStudio(input, logger: logger)
    }

    /// Creates a studio component resource.
    @Sendable
    @inlinable
    public func createStudioComponent(_ input: CreateStudioComponentRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> CreateStudioComponentResponse {
        try await self.client.execute(
            operation: "CreateStudioComponent", 
            path: "/2020-08-01/studios/{studioId}/studio-components", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Creates a studio component resource.
    ///
    /// Parameters:
    ///   - clientToken: Unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If you don’t specify a client token, the Amazon Web Services SDK automatically generates a client token and uses it for the request to ensure idempotency.
    ///   - configuration: The configuration of the studio component, based on component type.
    ///   - description: The description.
    ///   - ec2SecurityGroupIds: The EC2 security groups that control access to the studio component.
    ///   - initializationScripts: Initialization scripts for studio components.
    ///   - name: The name for the studio component.
    ///   - runtimeRoleArn: An IAM role attached to a Studio Component that gives the studio component access to Amazon Web Services resources at anytime while the instance is running.
    ///   - scriptParameters: Parameters for the studio component scripts.
    ///   - secureInitializationRoleArn: An IAM role attached to Studio Component when the system initialization script runs which give the studio component access to Amazon Web Services resources when the system initialization script runs.
    ///   - studioId: The studio ID.
    ///   - subtype: The specific subtype of a studio component.
    ///   - tags: A collection of labels, in the form of key-value pairs, that apply to this resource.
    ///   - type: The type of the studio component.
    ///   - logger: Logger use during operation
    @inlinable
    public func createStudioComponent(
        clientToken: String? = CreateStudioComponentRequest.idempotencyToken(),
        configuration: StudioComponentConfiguration? = nil,
        description: String? = nil,
        ec2SecurityGroupIds: [String]? = nil,
        initializationScripts: [StudioComponentInitializationScript]? = nil,
        name: String,
        runtimeRoleArn: String? = nil,
        scriptParameters: [ScriptParameterKeyValue]? = nil,
        secureInitializationRoleArn: String? = nil,
        studioId: String,
        subtype: StudioComponentSubtype? = nil,
        tags: [String: String]? = nil,
        type: StudioComponentType,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> CreateStudioComponentResponse {
        let input = CreateStudioComponentRequest(
            clientToken: clientToken, 
            configuration: configuration, 
            description: description, 
            ec2SecurityGroupIds: ec2SecurityGroupIds, 
            initializationScripts: initializationScripts, 
            name: name, 
            runtimeRoleArn: runtimeRoleArn, 
            scriptParameters: scriptParameters, 
            secureInitializationRoleArn: secureInitializationRoleArn, 
            studioId: studioId, 
            subtype: subtype, 
            tags: tags, 
            type: type
        )
        return try await self.createStudioComponent(input, logger: logger)
    }

    /// Permanently delete a launch profile.
    @Sendable
    @inlinable
    public func deleteLaunchProfile(_ input: DeleteLaunchProfileRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> DeleteLaunchProfileResponse {
        try await self.client.execute(
            operation: "DeleteLaunchProfile", 
            path: "/2020-08-01/studios/{studioId}/launch-profiles/{launchProfileId}", 
            httpMethod: .DELETE, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Permanently delete a launch profile.
    ///
    /// Parameters:
    ///   - clientToken: Unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If you don’t specify a client token, the Amazon Web Services SDK automatically generates a client token and uses it for the request to ensure idempotency.
    ///   - launchProfileId: The ID of the launch profile used to control access from the streaming session.
    ///   - studioId: The studio ID.
    ///   - logger: Logger use during operation
    @inlinable
    public func deleteLaunchProfile(
        clientToken: String? = DeleteLaunchProfileRequest.idempotencyToken(),
        launchProfileId: String,
        studioId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> DeleteLaunchProfileResponse {
        let input = DeleteLaunchProfileRequest(
            clientToken: clientToken, 
            launchProfileId: launchProfileId, 
            studioId: studioId
        )
        return try await self.deleteLaunchProfile(input, logger: logger)
    }

    /// Delete a user from launch profile membership.
    @Sendable
    @inlinable
    public func deleteLaunchProfileMember(_ input: DeleteLaunchProfileMemberRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> DeleteLaunchProfileMemberResponse {
        try await self.client.execute(
            operation: "DeleteLaunchProfileMember", 
            path: "/2020-08-01/studios/{studioId}/launch-profiles/{launchProfileId}/membership/{principalId}", 
            httpMethod: .DELETE, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Delete a user from launch profile membership.
    ///
    /// Parameters:
    ///   - clientToken: Unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If you don’t specify a client token, the Amazon Web Services SDK automatically generates a client token and uses it for the request to ensure idempotency.
    ///   - launchProfileId: The ID of the launch profile used to control access from the streaming session.
    ///   - principalId: The principal ID. This currently supports a IAM Identity Center UserId.
    ///   - studioId: The studio ID.
    ///   - logger: Logger use during operation
    @inlinable
    public func deleteLaunchProfileMember(
        clientToken: String? = DeleteLaunchProfileMemberRequest.idempotencyToken(),
        launchProfileId: String,
        principalId: String,
        studioId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> DeleteLaunchProfileMemberResponse {
        let input = DeleteLaunchProfileMemberRequest(
            clientToken: clientToken, 
            launchProfileId: launchProfileId, 
            principalId: principalId, 
            studioId: studioId
        )
        return try await self.deleteLaunchProfileMember(input, logger: logger)
    }

    /// Delete streaming image.
    @Sendable
    @inlinable
    public func deleteStreamingImage(_ input: DeleteStreamingImageRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> DeleteStreamingImageResponse {
        try await self.client.execute(
            operation: "DeleteStreamingImage", 
            path: "/2020-08-01/studios/{studioId}/streaming-images/{streamingImageId}", 
            httpMethod: .DELETE, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Delete streaming image.
    ///
    /// Parameters:
    ///   - clientToken: Unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If you don’t specify a client token, the Amazon Web Services SDK automatically generates a client token and uses it for the request to ensure idempotency.
    ///   - streamingImageId: The streaming image ID.
    ///   - studioId: The studio ID.
    ///   - logger: Logger use during operation
    @inlinable
    public func deleteStreamingImage(
        clientToken: String? = DeleteStreamingImageRequest.idempotencyToken(),
        streamingImageId: String,
        studioId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> DeleteStreamingImageResponse {
        let input = DeleteStreamingImageRequest(
            clientToken: clientToken, 
            streamingImageId: streamingImageId, 
            studioId: studioId
        )
        return try await self.deleteStreamingImage(input, logger: logger)
    }

    /// Deletes streaming session resource. After invoking this operation, use GetStreamingSession to poll the resource until it transitions to a DELETED state. A streaming session will count against your streaming session quota until it is marked DELETED.
    @Sendable
    @inlinable
    public func deleteStreamingSession(_ input: DeleteStreamingSessionRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> DeleteStreamingSessionResponse {
        try await self.client.execute(
            operation: "DeleteStreamingSession", 
            path: "/2020-08-01/studios/{studioId}/streaming-sessions/{sessionId}", 
            httpMethod: .DELETE, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Deletes streaming session resource. After invoking this operation, use GetStreamingSession to poll the resource until it transitions to a DELETED state. A streaming session will count against your streaming session quota until it is marked DELETED.
    ///
    /// Parameters:
    ///   - clientToken: Unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If you don’t specify a client token, the Amazon Web Services SDK automatically generates a client token and uses it for the request to ensure idempotency.
    ///   - sessionId: The streaming session ID.
    ///   - studioId: The studio ID.
    ///   - logger: Logger use during operation
    @inlinable
    public func deleteStreamingSession(
        clientToken: String? = DeleteStreamingSessionRequest.idempotencyToken(),
        sessionId: String,
        studioId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> DeleteStreamingSessionResponse {
        let input = DeleteStreamingSessionRequest(
            clientToken: clientToken, 
            sessionId: sessionId, 
            studioId: studioId
        )
        return try await self.deleteStreamingSession(input, logger: logger)
    }

    /// Delete a studio resource.
    @Sendable
    @inlinable
    public func deleteStudio(_ input: DeleteStudioRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> DeleteStudioResponse {
        try await self.client.execute(
            operation: "DeleteStudio", 
            path: "/2020-08-01/studios/{studioId}", 
            httpMethod: .DELETE, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Delete a studio resource.
    ///
    /// Parameters:
    ///   - clientToken: Unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If you don’t specify a client token, the Amazon Web Services SDK automatically generates a client token and uses it for the request to ensure idempotency.
    ///   - studioId: The studio ID.
    ///   - logger: Logger use during operation
    @inlinable
    public func deleteStudio(
        clientToken: String? = DeleteStudioRequest.idempotencyToken(),
        studioId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> DeleteStudioResponse {
        let input = DeleteStudioRequest(
            clientToken: clientToken, 
            studioId: studioId
        )
        return try await self.deleteStudio(input, logger: logger)
    }

    /// Deletes a studio component resource.
    @Sendable
    @inlinable
    public func deleteStudioComponent(_ input: DeleteStudioComponentRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> DeleteStudioComponentResponse {
        try await self.client.execute(
            operation: "DeleteStudioComponent", 
            path: "/2020-08-01/studios/{studioId}/studio-components/{studioComponentId}", 
            httpMethod: .DELETE, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Deletes a studio component resource.
    ///
    /// Parameters:
    ///   - clientToken: Unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If you don’t specify a client token, the Amazon Web Services SDK automatically generates a client token and uses it for the request to ensure idempotency.
    ///   - studioComponentId: The studio component ID.
    ///   - studioId: The studio ID.
    ///   - logger: Logger use during operation
    @inlinable
    public func deleteStudioComponent(
        clientToken: String? = DeleteStudioComponentRequest.idempotencyToken(),
        studioComponentId: String,
        studioId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> DeleteStudioComponentResponse {
        let input = DeleteStudioComponentRequest(
            clientToken: clientToken, 
            studioComponentId: studioComponentId, 
            studioId: studioId
        )
        return try await self.deleteStudioComponent(input, logger: logger)
    }

    /// Delete a user from studio membership.
    @Sendable
    @inlinable
    public func deleteStudioMember(_ input: DeleteStudioMemberRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> DeleteStudioMemberResponse {
        try await self.client.execute(
            operation: "DeleteStudioMember", 
            path: "/2020-08-01/studios/{studioId}/membership/{principalId}", 
            httpMethod: .DELETE, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Delete a user from studio membership.
    ///
    /// Parameters:
    ///   - clientToken: Unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If you don’t specify a client token, the Amazon Web Services SDK automatically generates a client token and uses it for the request to ensure idempotency.
    ///   - principalId: The principal ID. This currently supports a IAM Identity Center UserId.
    ///   - studioId: The studio ID.
    ///   - logger: Logger use during operation
    @inlinable
    public func deleteStudioMember(
        clientToken: String? = DeleteStudioMemberRequest.idempotencyToken(),
        principalId: String,
        studioId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> DeleteStudioMemberResponse {
        let input = DeleteStudioMemberRequest(
            clientToken: clientToken, 
            principalId: principalId, 
            studioId: studioId
        )
        return try await self.deleteStudioMember(input, logger: logger)
    }

    /// Get EULA.
    @Sendable
    @inlinable
    public func getEula(_ input: GetEulaRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> GetEulaResponse {
        try await self.client.execute(
            operation: "GetEula", 
            path: "/2020-08-01/eulas/{eulaId}", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Get EULA.
    ///
    /// Parameters:
    ///   - eulaId: The EULA ID.
    ///   - logger: Logger use during operation
    @inlinable
    public func getEula(
        eulaId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> GetEulaResponse {
        let input = GetEulaRequest(
            eulaId: eulaId
        )
        return try await self.getEula(input, logger: logger)
    }

    /// Get a launch profile.
    @Sendable
    @inlinable
    public func getLaunchProfile(_ input: GetLaunchProfileRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> GetLaunchProfileResponse {
        try await self.client.execute(
            operation: "GetLaunchProfile", 
            path: "/2020-08-01/studios/{studioId}/launch-profiles/{launchProfileId}", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Get a launch profile.
    ///
    /// Parameters:
    ///   - launchProfileId: The ID of the launch profile used to control access from the streaming session.
    ///   - studioId: The studio ID.
    ///   - logger: Logger use during operation
    @inlinable
    public func getLaunchProfile(
        launchProfileId: String,
        studioId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> GetLaunchProfileResponse {
        let input = GetLaunchProfileRequest(
            launchProfileId: launchProfileId, 
            studioId: studioId
        )
        return try await self.getLaunchProfile(input, logger: logger)
    }

    /// Launch profile details include the launch profile resource and summary information of resources that are used by, or available to, the launch profile. This includes the name and description of all studio components used by the launch profiles, and the name and description of streaming images that can be used with this launch profile.
    @Sendable
    @inlinable
    public func getLaunchProfileDetails(_ input: GetLaunchProfileDetailsRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> GetLaunchProfileDetailsResponse {
        try await self.client.execute(
            operation: "GetLaunchProfileDetails", 
            path: "/2020-08-01/studios/{studioId}/launch-profiles/{launchProfileId}/details", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Launch profile details include the launch profile resource and summary information of resources that are used by, or available to, the launch profile. This includes the name and description of all studio components used by the launch profiles, and the name and description of streaming images that can be used with this launch profile.
    ///
    /// Parameters:
    ///   - launchProfileId: The ID of the launch profile used to control access from the streaming session.
    ///   - studioId: The studio ID.
    ///   - logger: Logger use during operation
    @inlinable
    public func getLaunchProfileDetails(
        launchProfileId: String,
        studioId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> GetLaunchProfileDetailsResponse {
        let input = GetLaunchProfileDetailsRequest(
            launchProfileId: launchProfileId, 
            studioId: studioId
        )
        return try await self.getLaunchProfileDetails(input, logger: logger)
    }

    /// Get a launch profile initialization.
    @Sendable
    @inlinable
    public func getLaunchProfileInitialization(_ input: GetLaunchProfileInitializationRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> GetLaunchProfileInitializationResponse {
        try await self.client.execute(
            operation: "GetLaunchProfileInitialization", 
            path: "/2020-08-01/studios/{studioId}/launch-profiles/{launchProfileId}/init", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Get a launch profile initialization.
    ///
    /// Parameters:
    ///   - launchProfileId: The ID of the launch profile used to control access from the streaming session.
    ///   - launchProfileProtocolVersions: The launch profile protocol versions supported by the client.
    ///   - launchPurpose: The launch purpose.
    ///   - platform: The platform where this Launch Profile will be used, either Windows or Linux.
    ///   - studioId: The studio ID.
    ///   - logger: Logger use during operation
    @inlinable
    public func getLaunchProfileInitialization(
        launchProfileId: String,
        launchProfileProtocolVersions: [String],
        launchPurpose: String,
        platform: String,
        studioId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> GetLaunchProfileInitializationResponse {
        let input = GetLaunchProfileInitializationRequest(
            launchProfileId: launchProfileId, 
            launchProfileProtocolVersions: launchProfileProtocolVersions, 
            launchPurpose: launchPurpose, 
            platform: platform, 
            studioId: studioId
        )
        return try await self.getLaunchProfileInitialization(input, logger: logger)
    }

    /// Get a user persona in launch profile membership.
    @Sendable
    @inlinable
    public func getLaunchProfileMember(_ input: GetLaunchProfileMemberRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> GetLaunchProfileMemberResponse {
        try await self.client.execute(
            operation: "GetLaunchProfileMember", 
            path: "/2020-08-01/studios/{studioId}/launch-profiles/{launchProfileId}/membership/{principalId}", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Get a user persona in launch profile membership.
    ///
    /// Parameters:
    ///   - launchProfileId: The ID of the launch profile used to control access from the streaming session.
    ///   - principalId: The principal ID. This currently supports a IAM Identity Center UserId.
    ///   - studioId: The studio ID.
    ///   - logger: Logger use during operation
    @inlinable
    public func getLaunchProfileMember(
        launchProfileId: String,
        principalId: String,
        studioId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> GetLaunchProfileMemberResponse {
        let input = GetLaunchProfileMemberRequest(
            launchProfileId: launchProfileId, 
            principalId: principalId, 
            studioId: studioId
        )
        return try await self.getLaunchProfileMember(input, logger: logger)
    }

    /// Get streaming image.
    @Sendable
    @inlinable
    public func getStreamingImage(_ input: GetStreamingImageRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> GetStreamingImageResponse {
        try await self.client.execute(
            operation: "GetStreamingImage", 
            path: "/2020-08-01/studios/{studioId}/streaming-images/{streamingImageId}", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Get streaming image.
    ///
    /// Parameters:
    ///   - streamingImageId: The streaming image ID.
    ///   - studioId: The studio ID.
    ///   - logger: Logger use during operation
    @inlinable
    public func getStreamingImage(
        streamingImageId: String,
        studioId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> GetStreamingImageResponse {
        let input = GetStreamingImageRequest(
            streamingImageId: streamingImageId, 
            studioId: studioId
        )
        return try await self.getStreamingImage(input, logger: logger)
    }

    /// Gets StreamingSession resource. Invoke this operation to poll for a streaming session state while creating or deleting a session.
    @Sendable
    @inlinable
    public func getStreamingSession(_ input: GetStreamingSessionRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> GetStreamingSessionResponse {
        try await self.client.execute(
            operation: "GetStreamingSession", 
            path: "/2020-08-01/studios/{studioId}/streaming-sessions/{sessionId}", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Gets StreamingSession resource. Invoke this operation to poll for a streaming session state while creating or deleting a session.
    ///
    /// Parameters:
    ///   - sessionId: The streaming session ID.
    ///   - studioId: The studio ID.
    ///   - logger: Logger use during operation
    @inlinable
    public func getStreamingSession(
        sessionId: String,
        studioId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> GetStreamingSessionResponse {
        let input = GetStreamingSessionRequest(
            sessionId: sessionId, 
            studioId: studioId
        )
        return try await self.getStreamingSession(input, logger: logger)
    }

    /// Gets StreamingSessionBackup resource. Invoke this operation to poll for a streaming session backup while stopping a streaming session.
    @Sendable
    @inlinable
    public func getStreamingSessionBackup(_ input: GetStreamingSessionBackupRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> GetStreamingSessionBackupResponse {
        try await self.client.execute(
            operation: "GetStreamingSessionBackup", 
            path: "/2020-08-01/studios/{studioId}/streaming-session-backups/{backupId}", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Gets StreamingSessionBackup resource. Invoke this operation to poll for a streaming session backup while stopping a streaming session.
    ///
    /// Parameters:
    ///   - backupId: The ID of the backup.
    ///   - studioId: The studio ID.
    ///   - logger: Logger use during operation
    @inlinable
    public func getStreamingSessionBackup(
        backupId: String,
        studioId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> GetStreamingSessionBackupResponse {
        let input = GetStreamingSessionBackupRequest(
            backupId: backupId, 
            studioId: studioId
        )
        return try await self.getStreamingSessionBackup(input, logger: logger)
    }

    /// Gets a StreamingSessionStream for a streaming session. Invoke this operation to poll the resource after invoking CreateStreamingSessionStream. After the StreamingSessionStream changes to the READY state, the url property will contain a stream to be used with the DCV streaming client.
    @Sendable
    @inlinable
    public func getStreamingSessionStream(_ input: GetStreamingSessionStreamRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> GetStreamingSessionStreamResponse {
        try await self.client.execute(
            operation: "GetStreamingSessionStream", 
            path: "/2020-08-01/studios/{studioId}/streaming-sessions/{sessionId}/streams/{streamId}", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Gets a StreamingSessionStream for a streaming session. Invoke this operation to poll the resource after invoking CreateStreamingSessionStream. After the StreamingSessionStream changes to the READY state, the url property will contain a stream to be used with the DCV streaming client.
    ///
    /// Parameters:
    ///   - sessionId: The streaming session ID.
    ///   - streamId: The streaming session stream ID.
    ///   - studioId: The studio ID.
    ///   - logger: Logger use during operation
    @inlinable
    public func getStreamingSessionStream(
        sessionId: String,
        streamId: String,
        studioId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> GetStreamingSessionStreamResponse {
        let input = GetStreamingSessionStreamRequest(
            sessionId: sessionId, 
            streamId: streamId, 
            studioId: studioId
        )
        return try await self.getStreamingSessionStream(input, logger: logger)
    }

    /// Get a studio resource.
    @Sendable
    @inlinable
    public func getStudio(_ input: GetStudioRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> GetStudioResponse {
        try await self.client.execute(
            operation: "GetStudio", 
            path: "/2020-08-01/studios/{studioId}", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Get a studio resource.
    ///
    /// Parameters:
    ///   - studioId: The studio ID.
    ///   - logger: Logger use during operation
    @inlinable
    public func getStudio(
        studioId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> GetStudioResponse {
        let input = GetStudioRequest(
            studioId: studioId
        )
        return try await self.getStudio(input, logger: logger)
    }

    /// Gets a studio component resource.
    @Sendable
    @inlinable
    public func getStudioComponent(_ input: GetStudioComponentRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> GetStudioComponentResponse {
        try await self.client.execute(
            operation: "GetStudioComponent", 
            path: "/2020-08-01/studios/{studioId}/studio-components/{studioComponentId}", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Gets a studio component resource.
    ///
    /// Parameters:
    ///   - studioComponentId: The studio component ID.
    ///   - studioId: The studio ID.
    ///   - logger: Logger use during operation
    @inlinable
    public func getStudioComponent(
        studioComponentId: String,
        studioId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> GetStudioComponentResponse {
        let input = GetStudioComponentRequest(
            studioComponentId: studioComponentId, 
            studioId: studioId
        )
        return try await self.getStudioComponent(input, logger: logger)
    }

    /// Get a user's membership in a studio.
    @Sendable
    @inlinable
    public func getStudioMember(_ input: GetStudioMemberRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> GetStudioMemberResponse {
        try await self.client.execute(
            operation: "GetStudioMember", 
            path: "/2020-08-01/studios/{studioId}/membership/{principalId}", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Get a user's membership in a studio.
    ///
    /// Parameters:
    ///   - principalId: The principal ID. This currently supports a IAM Identity Center UserId.
    ///   - studioId: The studio ID.
    ///   - logger: Logger use during operation
    @inlinable
    public func getStudioMember(
        principalId: String,
        studioId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> GetStudioMemberResponse {
        let input = GetStudioMemberRequest(
            principalId: principalId, 
            studioId: studioId
        )
        return try await self.getStudioMember(input, logger: logger)
    }

    /// List EULA acceptances.
    @Sendable
    @inlinable
    public func listEulaAcceptances(_ input: ListEulaAcceptancesRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> ListEulaAcceptancesResponse {
        try await self.client.execute(
            operation: "ListEulaAcceptances", 
            path: "/2020-08-01/studios/{studioId}/eula-acceptances", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// List EULA acceptances.
    ///
    /// Parameters:
    ///   - eulaIds: The list of EULA IDs that have been previously accepted.
    ///   - nextToken: The token for the next set of results, or null if there are no more results.
    ///   - studioId: The studio ID.
    ///   - logger: Logger use during operation
    @inlinable
    public func listEulaAcceptances(
        eulaIds: [String]? = nil,
        nextToken: String? = nil,
        studioId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ListEulaAcceptancesResponse {
        let input = ListEulaAcceptancesRequest(
            eulaIds: eulaIds, 
            nextToken: nextToken, 
            studioId: studioId
        )
        return try await self.listEulaAcceptances(input, logger: logger)
    }

    /// List EULAs.
    @Sendable
    @inlinable
    public func listEulas(_ input: ListEulasRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> ListEulasResponse {
        try await self.client.execute(
            operation: "ListEulas", 
            path: "/2020-08-01/eulas", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// List EULAs.
    ///
    /// Parameters:
    ///   - eulaIds: The list of EULA IDs that should be returned
    ///   - nextToken: The token for the next set of results, or null if there are no more results.
    ///   - logger: Logger use during operation
    @inlinable
    public func listEulas(
        eulaIds: [String]? = nil,
        nextToken: String? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ListEulasResponse {
        let input = ListEulasRequest(
            eulaIds: eulaIds, 
            nextToken: nextToken
        )
        return try await self.listEulas(input, logger: logger)
    }

    /// Get all users in a given launch profile membership.
    @Sendable
    @inlinable
    public func listLaunchProfileMembers(_ input: ListLaunchProfileMembersRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> ListLaunchProfileMembersResponse {
        try await self.client.execute(
            operation: "ListLaunchProfileMembers", 
            path: "/2020-08-01/studios/{studioId}/launch-profiles/{launchProfileId}/membership", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Get all users in a given launch profile membership.
    ///
    /// Parameters:
    ///   - launchProfileId: The ID of the launch profile used to control access from the streaming session.
    ///   - maxResults: The max number of results to return in the response.
    ///   - nextToken: The token for the next set of results, or null if there are no more results.
    ///   - studioId: The studio ID.
    ///   - logger: Logger use during operation
    @inlinable
    public func listLaunchProfileMembers(
        launchProfileId: String,
        maxResults: Int? = nil,
        nextToken: String? = nil,
        studioId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ListLaunchProfileMembersResponse {
        let input = ListLaunchProfileMembersRequest(
            launchProfileId: launchProfileId, 
            maxResults: maxResults, 
            nextToken: nextToken, 
            studioId: studioId
        )
        return try await self.listLaunchProfileMembers(input, logger: logger)
    }

    /// List all the launch profiles a studio.
    @Sendable
    @inlinable
    public func listLaunchProfiles(_ input: ListLaunchProfilesRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> ListLaunchProfilesResponse {
        try await self.client.execute(
            operation: "ListLaunchProfiles", 
            path: "/2020-08-01/studios/{studioId}/launch-profiles", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// List all the launch profiles a studio.
    ///
    /// Parameters:
    ///   - maxResults: The max number of results to return in the response.
    ///   - nextToken: The token for the next set of results, or null if there are no more results.
    ///   - principalId: The principal ID. This currently supports a IAM Identity Center UserId.
    ///   - states: Filter this request to launch profiles in any of the given states.
    ///   - studioId: The studio ID.
    ///   - logger: Logger use during operation
    @inlinable
    public func listLaunchProfiles(
        maxResults: Int? = nil,
        nextToken: String? = nil,
        principalId: String? = nil,
        states: [LaunchProfileState]? = nil,
        studioId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ListLaunchProfilesResponse {
        let input = ListLaunchProfilesRequest(
            maxResults: maxResults, 
            nextToken: nextToken, 
            principalId: principalId, 
            states: states, 
            studioId: studioId
        )
        return try await self.listLaunchProfiles(input, logger: logger)
    }

    /// List the streaming image resources available to this studio. This list will contain both images provided by Amazon Web Services, as well as streaming images that you have created in your studio.
    @Sendable
    @inlinable
    public func listStreamingImages(_ input: ListStreamingImagesRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> ListStreamingImagesResponse {
        try await self.client.execute(
            operation: "ListStreamingImages", 
            path: "/2020-08-01/studios/{studioId}/streaming-images", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// List the streaming image resources available to this studio. This list will contain both images provided by Amazon Web Services, as well as streaming images that you have created in your studio.
    ///
    /// Parameters:
    ///   - nextToken: The token for the next set of results, or null if there are no more results.
    ///   - owner: Filter this request to streaming images with the given owner
    ///   - studioId: The studio ID.
    ///   - logger: Logger use during operation
    @inlinable
    public func listStreamingImages(
        nextToken: String? = nil,
        owner: String? = nil,
        studioId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ListStreamingImagesResponse {
        let input = ListStreamingImagesRequest(
            nextToken: nextToken, 
            owner: owner, 
            studioId: studioId
        )
        return try await self.listStreamingImages(input, logger: logger)
    }

    /// Lists the backups of a streaming session in a studio.
    @Sendable
    @inlinable
    public func listStreamingSessionBackups(_ input: ListStreamingSessionBackupsRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> ListStreamingSessionBackupsResponse {
        try await self.client.execute(
            operation: "ListStreamingSessionBackups", 
            path: "/2020-08-01/studios/{studioId}/streaming-session-backups", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Lists the backups of a streaming session in a studio.
    ///
    /// Parameters:
    ///   - nextToken: The token for the next set of results, or null if there are no more results.
    ///   - ownedBy: The user ID of the user that owns the streaming session.
    ///   - studioId: The studio ID.
    ///   - logger: Logger use during operation
    @inlinable
    public func listStreamingSessionBackups(
        nextToken: String? = nil,
        ownedBy: String? = nil,
        studioId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ListStreamingSessionBackupsResponse {
        let input = ListStreamingSessionBackupsRequest(
            nextToken: nextToken, 
            ownedBy: ownedBy, 
            studioId: studioId
        )
        return try await self.listStreamingSessionBackups(input, logger: logger)
    }

    /// Lists the streaming sessions in a studio.
    @Sendable
    @inlinable
    public func listStreamingSessions(_ input: ListStreamingSessionsRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> ListStreamingSessionsResponse {
        try await self.client.execute(
            operation: "ListStreamingSessions", 
            path: "/2020-08-01/studios/{studioId}/streaming-sessions", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Lists the streaming sessions in a studio.
    ///
    /// Parameters:
    ///   - createdBy: Filters the request to streaming sessions created by the given user.
    ///   - nextToken: The token for the next set of results, or null if there are no more results.
    ///   - ownedBy: Filters the request to streaming session owned by the given user
    ///   - sessionIds: Filters the request to only the provided session IDs.
    ///   - studioId: The studio ID.
    ///   - logger: Logger use during operation
    @inlinable
    public func listStreamingSessions(
        createdBy: String? = nil,
        nextToken: String? = nil,
        ownedBy: String? = nil,
        sessionIds: String? = nil,
        studioId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ListStreamingSessionsResponse {
        let input = ListStreamingSessionsRequest(
            createdBy: createdBy, 
            nextToken: nextToken, 
            ownedBy: ownedBy, 
            sessionIds: sessionIds, 
            studioId: studioId
        )
        return try await self.listStreamingSessions(input, logger: logger)
    }

    /// Lists the StudioComponents in a studio.
    @Sendable
    @inlinable
    public func listStudioComponents(_ input: ListStudioComponentsRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> ListStudioComponentsResponse {
        try await self.client.execute(
            operation: "ListStudioComponents", 
            path: "/2020-08-01/studios/{studioId}/studio-components", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Lists the StudioComponents in a studio.
    ///
    /// Parameters:
    ///   - maxResults: The max number of results to return in the response.
    ///   - nextToken: The token for the next set of results, or null if there are no more results.
    ///   - states: Filters the request to studio components that are in one of the given states.
    ///   - studioId: The studio ID.
    ///   - types: Filters the request to studio components that are of one of the given types.
    ///   - logger: Logger use during operation
    @inlinable
    public func listStudioComponents(
        maxResults: Int? = nil,
        nextToken: String? = nil,
        states: [StudioComponentState]? = nil,
        studioId: String,
        types: [StudioComponentType]? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ListStudioComponentsResponse {
        let input = ListStudioComponentsRequest(
            maxResults: maxResults, 
            nextToken: nextToken, 
            states: states, 
            studioId: studioId, 
            types: types
        )
        return try await self.listStudioComponents(input, logger: logger)
    }

    /// Get all users in a given studio membership.   ListStudioMembers only returns admin members.
    @Sendable
    @inlinable
    public func listStudioMembers(_ input: ListStudioMembersRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> ListStudioMembersResponse {
        try await self.client.execute(
            operation: "ListStudioMembers", 
            path: "/2020-08-01/studios/{studioId}/membership", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Get all users in a given studio membership.   ListStudioMembers only returns admin members.
    ///
    /// Parameters:
    ///   - maxResults: The max number of results to return in the response.
    ///   - nextToken: The token for the next set of results, or null if there are no more results.
    ///   - studioId: The studio ID.
    ///   - logger: Logger use during operation
    @inlinable
    public func listStudioMembers(
        maxResults: Int? = nil,
        nextToken: String? = nil,
        studioId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ListStudioMembersResponse {
        let input = ListStudioMembersRequest(
            maxResults: maxResults, 
            nextToken: nextToken, 
            studioId: studioId
        )
        return try await self.listStudioMembers(input, logger: logger)
    }

    /// List studios in your Amazon Web Services accounts in the requested Amazon Web Services Region.
    @Sendable
    @inlinable
    public func listStudios(_ input: ListStudiosRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> ListStudiosResponse {
        try await self.client.execute(
            operation: "ListStudios", 
            path: "/2020-08-01/studios", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// List studios in your Amazon Web Services accounts in the requested Amazon Web Services Region.
    ///
    /// Parameters:
    ///   - nextToken: The token for the next set of results, or null if there are no more results.
    ///   - logger: Logger use during operation
    @inlinable
    public func listStudios(
        nextToken: String? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ListStudiosResponse {
        let input = ListStudiosRequest(
            nextToken: nextToken
        )
        return try await self.listStudios(input, logger: logger)
    }

    /// Gets the tags for a resource, given its Amazon Resource Names (ARN). This operation supports ARNs for all resource types in Nimble Studio that support tags, including studio, studio component, launch profile, streaming image, and streaming session. All resources that can be tagged will contain an ARN property, so you do not have to create this ARN yourself.
    @Sendable
    @inlinable
    public func listTagsForResource(_ input: ListTagsForResourceRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> ListTagsForResourceResponse {
        try await self.client.execute(
            operation: "ListTagsForResource", 
            path: "/2020-08-01/tags/{resourceArn}", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Gets the tags for a resource, given its Amazon Resource Names (ARN). This operation supports ARNs for all resource types in Nimble Studio that support tags, including studio, studio component, launch profile, streaming image, and streaming session. All resources that can be tagged will contain an ARN property, so you do not have to create this ARN yourself.
    ///
    /// Parameters:
    ///   - resourceArn: The Amazon Resource Name (ARN) of the resource for which you want to list tags.
    ///   - logger: Logger use during operation
    @inlinable
    public func listTagsForResource(
        resourceArn: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ListTagsForResourceResponse {
        let input = ListTagsForResourceRequest(
            resourceArn: resourceArn
        )
        return try await self.listTagsForResource(input, logger: logger)
    }

    /// Add/update users with given persona to launch profile membership.
    @Sendable
    @inlinable
    public func putLaunchProfileMembers(_ input: PutLaunchProfileMembersRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> PutLaunchProfileMembersResponse {
        try await self.client.execute(
            operation: "PutLaunchProfileMembers", 
            path: "/2020-08-01/studios/{studioId}/launch-profiles/{launchProfileId}/membership", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Add/update users with given persona to launch profile membership.
    ///
    /// Parameters:
    ///   - clientToken: Unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If you don’t specify a client token, the Amazon Web Services SDK automatically generates a client token and uses it for the request to ensure idempotency.
    ///   - identityStoreId: The ID of the identity store.
    ///   - launchProfileId: The ID of the launch profile used to control access from the streaming session.
    ///   - members: A list of members.
    ///   - studioId: The studio ID.
    ///   - logger: Logger use during operation
    @inlinable
    public func putLaunchProfileMembers(
        clientToken: String? = PutLaunchProfileMembersRequest.idempotencyToken(),
        identityStoreId: String,
        launchProfileId: String,
        members: [NewLaunchProfileMember],
        studioId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> PutLaunchProfileMembersResponse {
        let input = PutLaunchProfileMembersRequest(
            clientToken: clientToken, 
            identityStoreId: identityStoreId, 
            launchProfileId: launchProfileId, 
            members: members, 
            studioId: studioId
        )
        return try await self.putLaunchProfileMembers(input, logger: logger)
    }

    /// Add/update users with given persona to studio membership.
    @Sendable
    @inlinable
    public func putStudioMembers(_ input: PutStudioMembersRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> PutStudioMembersResponse {
        try await self.client.execute(
            operation: "PutStudioMembers", 
            path: "/2020-08-01/studios/{studioId}/membership", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Add/update users with given persona to studio membership.
    ///
    /// Parameters:
    ///   - clientToken: Unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If you don’t specify a client token, the Amazon Web Services SDK automatically generates a client token and uses it for the request to ensure idempotency.
    ///   - identityStoreId: The ID of the identity store.
    ///   - members: A list of members.
    ///   - studioId: The studio ID.
    ///   - logger: Logger use during operation
    @inlinable
    public func putStudioMembers(
        clientToken: String? = PutStudioMembersRequest.idempotencyToken(),
        identityStoreId: String,
        members: [NewStudioMember],
        studioId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> PutStudioMembersResponse {
        let input = PutStudioMembersRequest(
            clientToken: clientToken, 
            identityStoreId: identityStoreId, 
            members: members, 
            studioId: studioId
        )
        return try await self.putStudioMembers(input, logger: logger)
    }

    /// Transitions sessions from the STOPPED state into the READY state. The START_IN_PROGRESS state is the intermediate state between the STOPPED and READY states.
    @Sendable
    @inlinable
    public func startStreamingSession(_ input: StartStreamingSessionRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> StartStreamingSessionResponse {
        try await self.client.execute(
            operation: "StartStreamingSession", 
            path: "/2020-08-01/studios/{studioId}/streaming-sessions/{sessionId}/start", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Transitions sessions from the STOPPED state into the READY state. The START_IN_PROGRESS state is the intermediate state between the STOPPED and READY states.
    ///
    /// Parameters:
    ///   - backupId: The ID of the backup.
    ///   - clientToken: Unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If you don’t specify a client token, the Amazon Web Services SDK automatically generates a client token and uses it for the request to ensure idempotency.
    ///   - sessionId: The streaming session ID for the StartStreamingSessionRequest.
    ///   - studioId: The studio ID for the StartStreamingSessionRequest.
    ///   - logger: Logger use during operation
    @inlinable
    public func startStreamingSession(
        backupId: String? = nil,
        clientToken: String? = StartStreamingSessionRequest.idempotencyToken(),
        sessionId: String,
        studioId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> StartStreamingSessionResponse {
        let input = StartStreamingSessionRequest(
            backupId: backupId, 
            clientToken: clientToken, 
            sessionId: sessionId, 
            studioId: studioId
        )
        return try await self.startStreamingSession(input, logger: logger)
    }

    /// Repairs the IAM Identity Center configuration for a given studio. If the studio has a valid IAM Identity Center configuration currently associated with it, this operation will fail with a validation error. If the studio does not have a valid IAM Identity Center configuration currently associated with it, then a new IAM Identity Center application is created for the studio and the studio is changed to the READY state. After the IAM Identity Center application is repaired, you must use the Amazon Nimble Studio console to add administrators and users to your studio.
    @Sendable
    @inlinable
    public func startStudioSSOConfigurationRepair(_ input: StartStudioSSOConfigurationRepairRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> StartStudioSSOConfigurationRepairResponse {
        try await self.client.execute(
            operation: "StartStudioSSOConfigurationRepair", 
            path: "/2020-08-01/studios/{studioId}/sso-configuration", 
            httpMethod: .PUT, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Repairs the IAM Identity Center configuration for a given studio. If the studio has a valid IAM Identity Center configuration currently associated with it, this operation will fail with a validation error. If the studio does not have a valid IAM Identity Center configuration currently associated with it, then a new IAM Identity Center application is created for the studio and the studio is changed to the READY state. After the IAM Identity Center application is repaired, you must use the Amazon Nimble Studio console to add administrators and users to your studio.
    ///
    /// Parameters:
    ///   - clientToken: Unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If you don’t specify a client token, the Amazon Web Services SDK automatically generates a client token and uses it for the request to ensure idempotency.
    ///   - studioId: The studio ID.
    ///   - logger: Logger use during operation
    @inlinable
    public func startStudioSSOConfigurationRepair(
        clientToken: String? = StartStudioSSOConfigurationRepairRequest.idempotencyToken(),
        studioId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> StartStudioSSOConfigurationRepairResponse {
        let input = StartStudioSSOConfigurationRepairRequest(
            clientToken: clientToken, 
            studioId: studioId
        )
        return try await self.startStudioSSOConfigurationRepair(input, logger: logger)
    }

    /// Transitions sessions from the READY state into the STOPPED state. The STOP_IN_PROGRESS state is the intermediate state between the READY and STOPPED states.
    @Sendable
    @inlinable
    public func stopStreamingSession(_ input: StopStreamingSessionRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> StopStreamingSessionResponse {
        try await self.client.execute(
            operation: "StopStreamingSession", 
            path: "/2020-08-01/studios/{studioId}/streaming-sessions/{sessionId}/stop", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Transitions sessions from the READY state into the STOPPED state. The STOP_IN_PROGRESS state is the intermediate state between the READY and STOPPED states.
    ///
    /// Parameters:
    ///   - clientToken: Unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If you don’t specify a client token, the Amazon Web Services SDK automatically generates a client token and uses it for the request to ensure idempotency.
    ///   - sessionId: The streaming session ID for the StopStreamingSessionRequest.
    ///   - studioId: The studioId for the StopStreamingSessionRequest.
    ///   - volumeRetentionMode: Adds additional instructions to a streaming session stop action to either retain the EBS volumes or delete the EBS volumes.
    ///   - logger: Logger use during operation
    @inlinable
    public func stopStreamingSession(
        clientToken: String? = StopStreamingSessionRequest.idempotencyToken(),
        sessionId: String,
        studioId: String,
        volumeRetentionMode: VolumeRetentionMode? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> StopStreamingSessionResponse {
        let input = StopStreamingSessionRequest(
            clientToken: clientToken, 
            sessionId: sessionId, 
            studioId: studioId, 
            volumeRetentionMode: volumeRetentionMode
        )
        return try await self.stopStreamingSession(input, logger: logger)
    }

    /// Creates tags for a resource, given its ARN.
    @Sendable
    @inlinable
    public func tagResource(_ input: TagResourceRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> TagResourceResponse {
        try await self.client.execute(
            operation: "TagResource", 
            path: "/2020-08-01/tags/{resourceArn}", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Creates tags for a resource, given its ARN.
    ///
    /// Parameters:
    ///   - resourceArn: The Amazon Resource Name (ARN) of the resource you want to add tags to.
    ///   - tags: A collection of labels, in the form of key-value pairs, that apply to this resource.
    ///   - logger: Logger use during operation
    @inlinable
    public func tagResource(
        resourceArn: String,
        tags: [String: String]? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> TagResourceResponse {
        let input = TagResourceRequest(
            resourceArn: resourceArn, 
            tags: tags
        )
        return try await self.tagResource(input, logger: logger)
    }

    /// Deletes the tags for a resource.
    @Sendable
    @inlinable
    public func untagResource(_ input: UntagResourceRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> UntagResourceResponse {
        try await self.client.execute(
            operation: "UntagResource", 
            path: "/2020-08-01/tags/{resourceArn}", 
            httpMethod: .DELETE, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Deletes the tags for a resource.
    ///
    /// Parameters:
    ///   - resourceArn: Identifies the Amazon Resource Name(ARN) key from which you are removing tags.
    ///   - tagKeys: One or more tag keys. Specify only the tag keys, not the tag values.
    ///   - logger: Logger use during operation
    @inlinable
    public func untagResource(
        resourceArn: String,
        tagKeys: [String],
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> UntagResourceResponse {
        let input = UntagResourceRequest(
            resourceArn: resourceArn, 
            tagKeys: tagKeys
        )
        return try await self.untagResource(input, logger: logger)
    }

    /// Update a launch profile.
    @Sendable
    @inlinable
    public func updateLaunchProfile(_ input: UpdateLaunchProfileRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> UpdateLaunchProfileResponse {
        try await self.client.execute(
            operation: "UpdateLaunchProfile", 
            path: "/2020-08-01/studios/{studioId}/launch-profiles/{launchProfileId}", 
            httpMethod: .PATCH, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Update a launch profile.
    ///
    /// Parameters:
    ///   - clientToken: Unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If you don’t specify a client token, the Amazon Web Services SDK automatically generates a client token and uses it for the request to ensure idempotency.
    ///   - description: The description.
    ///   - launchProfileId: The ID of the launch profile used to control access from the streaming session.
    ///   - launchProfileProtocolVersions: The version number of the protocol that is used by the launch profile. The only valid version is "2021-03-31".
    ///   - name: The name for the launch profile.
    ///   - streamConfiguration: A configuration for a streaming session.
    ///   - studioComponentIds: Unique identifiers for a collection of studio components that can be used with this launch profile.
    ///   - studioId: The studio ID.
    ///   - logger: Logger use during operation
    @inlinable
    public func updateLaunchProfile(
        clientToken: String? = UpdateLaunchProfileRequest.idempotencyToken(),
        description: String? = nil,
        launchProfileId: String,
        launchProfileProtocolVersions: [String]? = nil,
        name: String? = nil,
        streamConfiguration: StreamConfigurationCreate? = nil,
        studioComponentIds: [String]? = nil,
        studioId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> UpdateLaunchProfileResponse {
        let input = UpdateLaunchProfileRequest(
            clientToken: clientToken, 
            description: description, 
            launchProfileId: launchProfileId, 
            launchProfileProtocolVersions: launchProfileProtocolVersions, 
            name: name, 
            streamConfiguration: streamConfiguration, 
            studioComponentIds: studioComponentIds, 
            studioId: studioId
        )
        return try await self.updateLaunchProfile(input, logger: logger)
    }

    /// Update a user persona in launch profile membership.
    @Sendable
    @inlinable
    public func updateLaunchProfileMember(_ input: UpdateLaunchProfileMemberRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> UpdateLaunchProfileMemberResponse {
        try await self.client.execute(
            operation: "UpdateLaunchProfileMember", 
            path: "/2020-08-01/studios/{studioId}/launch-profiles/{launchProfileId}/membership/{principalId}", 
            httpMethod: .PATCH, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Update a user persona in launch profile membership.
    ///
    /// Parameters:
    ///   - clientToken: Unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If you don’t specify a client token, the Amazon Web Services SDK automatically generates a client token and uses it for the request to ensure idempotency.
    ///   - launchProfileId: The ID of the launch profile used to control access from the streaming session.
    ///   - persona: The persona.
    ///   - principalId: The principal ID. This currently supports a IAM Identity Center UserId.
    ///   - studioId: The studio ID.
    ///   - logger: Logger use during operation
    @inlinable
    public func updateLaunchProfileMember(
        clientToken: String? = UpdateLaunchProfileMemberRequest.idempotencyToken(),
        launchProfileId: String,
        persona: LaunchProfilePersona,
        principalId: String,
        studioId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> UpdateLaunchProfileMemberResponse {
        let input = UpdateLaunchProfileMemberRequest(
            clientToken: clientToken, 
            launchProfileId: launchProfileId, 
            persona: persona, 
            principalId: principalId, 
            studioId: studioId
        )
        return try await self.updateLaunchProfileMember(input, logger: logger)
    }

    /// Update streaming image.
    @Sendable
    @inlinable
    public func updateStreamingImage(_ input: UpdateStreamingImageRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> UpdateStreamingImageResponse {
        try await self.client.execute(
            operation: "UpdateStreamingImage", 
            path: "/2020-08-01/studios/{studioId}/streaming-images/{streamingImageId}", 
            httpMethod: .PATCH, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Update streaming image.
    ///
    /// Parameters:
    ///   - clientToken: Unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If you don’t specify a client token, the Amazon Web Services SDK automatically generates a client token and uses it for the request to ensure idempotency.
    ///   - description: The description.
    ///   - name: The name for the streaming image.
    ///   - streamingImageId: The streaming image ID.
    ///   - studioId: The studio ID.
    ///   - logger: Logger use during operation
    @inlinable
    public func updateStreamingImage(
        clientToken: String? = UpdateStreamingImageRequest.idempotencyToken(),
        description: String? = nil,
        name: String? = nil,
        streamingImageId: String,
        studioId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> UpdateStreamingImageResponse {
        let input = UpdateStreamingImageRequest(
            clientToken: clientToken, 
            description: description, 
            name: name, 
            streamingImageId: streamingImageId, 
            studioId: studioId
        )
        return try await self.updateStreamingImage(input, logger: logger)
    }

    /// Update a Studio resource. Currently, this operation only supports updating the displayName of your studio.
    @Sendable
    @inlinable
    public func updateStudio(_ input: UpdateStudioRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> UpdateStudioResponse {
        try await self.client.execute(
            operation: "UpdateStudio", 
            path: "/2020-08-01/studios/{studioId}", 
            httpMethod: .PATCH, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Update a Studio resource. Currently, this operation only supports updating the displayName of your studio.
    ///
    /// Parameters:
    ///   - adminRoleArn: The IAM role that Studio Admins will assume when logging in to the Nimble Studio portal.
    ///   - clientToken: Unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If you don’t specify a client token, the Amazon Web Services SDK automatically generates a client token and uses it for the request to ensure idempotency.
    ///   - displayName: A friendly name for the studio.
    ///   - studioId: The studio ID.
    ///   - userRoleArn: The IAM role that Studio Users will assume when logging in to the Nimble Studio portal.
    ///   - logger: Logger use during operation
    @inlinable
    public func updateStudio(
        adminRoleArn: String? = nil,
        clientToken: String? = UpdateStudioRequest.idempotencyToken(),
        displayName: String? = nil,
        studioId: String,
        userRoleArn: String? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> UpdateStudioResponse {
        let input = UpdateStudioRequest(
            adminRoleArn: adminRoleArn, 
            clientToken: clientToken, 
            displayName: displayName, 
            studioId: studioId, 
            userRoleArn: userRoleArn
        )
        return try await self.updateStudio(input, logger: logger)
    }

    /// Updates a studio component resource.
    @Sendable
    @inlinable
    public func updateStudioComponent(_ input: UpdateStudioComponentRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> UpdateStudioComponentResponse {
        try await self.client.execute(
            operation: "UpdateStudioComponent", 
            path: "/2020-08-01/studios/{studioId}/studio-components/{studioComponentId}", 
            httpMethod: .PATCH, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Updates a studio component resource.
    ///
    /// Parameters:
    ///   - clientToken: Unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If you don’t specify a client token, the Amazon Web Services SDK automatically generates a client token and uses it for the request to ensure idempotency.
    ///   - configuration: The configuration of the studio component, based on component type.
    ///   - description: The description.
    ///   - ec2SecurityGroupIds: The EC2 security groups that control access to the studio component.
    ///   - initializationScripts: Initialization scripts for studio components.
    ///   - name: The name for the studio component.
    ///   - runtimeRoleArn: An IAM role attached to a Studio Component that gives the studio component access to Amazon Web Services resources at anytime while the instance is running.
    ///   - scriptParameters: Parameters for the studio component scripts.
    ///   - secureInitializationRoleArn: An IAM role attached to Studio Component when the system initialization script runs which give the studio component access to Amazon Web Services resources when the system initialization script runs.
    ///   - studioComponentId: The studio component ID.
    ///   - studioId: The studio ID.
    ///   - subtype: The specific subtype of a studio component.
    ///   - type: The type of the studio component.
    ///   - logger: Logger use during operation
    @inlinable
    public func updateStudioComponent(
        clientToken: String? = UpdateStudioComponentRequest.idempotencyToken(),
        configuration: StudioComponentConfiguration? = nil,
        description: String? = nil,
        ec2SecurityGroupIds: [String]? = nil,
        initializationScripts: [StudioComponentInitializationScript]? = nil,
        name: String? = nil,
        runtimeRoleArn: String? = nil,
        scriptParameters: [ScriptParameterKeyValue]? = nil,
        secureInitializationRoleArn: String? = nil,
        studioComponentId: String,
        studioId: String,
        subtype: StudioComponentSubtype? = nil,
        type: StudioComponentType? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> UpdateStudioComponentResponse {
        let input = UpdateStudioComponentRequest(
            clientToken: clientToken, 
            configuration: configuration, 
            description: description, 
            ec2SecurityGroupIds: ec2SecurityGroupIds, 
            initializationScripts: initializationScripts, 
            name: name, 
            runtimeRoleArn: runtimeRoleArn, 
            scriptParameters: scriptParameters, 
            secureInitializationRoleArn: secureInitializationRoleArn, 
            studioComponentId: studioComponentId, 
            studioId: studioId, 
            subtype: subtype, 
            type: type
        )
        return try await self.updateStudioComponent(input, logger: logger)
    }
}

extension Nimble {
    /// Initializer required by `AWSService.with(middlewares:timeout:byteBufferAllocator:options)`. You are not able to use this initializer directly as there are not public
    /// initializers for `AWSServiceConfig.Patch`. Please use `AWSService.with(middlewares:timeout:byteBufferAllocator:options)` instead.
    public init(from: Nimble, patch: AWSServiceConfig.Patch) {
        self.client = from.client
        self.config = from.config.with(patch: patch)
    }
}

// MARK: Paginators

@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension Nimble {
    /// Return PaginatorSequence for operation ``listEulaAcceptances(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func listEulaAcceptancesPaginator(
        _ input: ListEulaAcceptancesRequest,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<ListEulaAcceptancesRequest, ListEulaAcceptancesResponse> {
        return .init(
            input: input,
            command: self.listEulaAcceptances,
            inputKey: \ListEulaAcceptancesRequest.nextToken,
            outputKey: \ListEulaAcceptancesResponse.nextToken,
            logger: logger
        )
    }
    /// Return PaginatorSequence for operation ``listEulaAcceptances(_:logger:)``.
    ///
    /// - Parameters:
    ///   - eulaIds: The list of EULA IDs that have been previously accepted.
    ///   - studioId: The studio ID.
    ///   - logger: Logger used for logging
    @inlinable
    public func listEulaAcceptancesPaginator(
        eulaIds: [String]? = nil,
        studioId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) -> AWSClient.PaginatorSequence<ListEulaAcceptancesRequest, ListEulaAcceptancesResponse> {
        let input = ListEulaAcceptancesRequest(
            eulaIds: eulaIds, 
            studioId: studioId
        )
        return self.listEulaAcceptancesPaginator(input, logger: logger)
    }

    /// Return PaginatorSequence for operation ``listEulas(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func listEulasPaginator(
        _ input: ListEulasRequest,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<ListEulasRequest, ListEulasResponse> {
        return .init(
            input: input,
            command: self.listEulas,
            inputKey: \ListEulasRequest.nextToken,
            outputKey: \ListEulasResponse.nextToken,
            logger: logger
        )
    }
    /// Return PaginatorSequence for operation ``listEulas(_:logger:)``.
    ///
    /// - Parameters:
    ///   - eulaIds: The list of EULA IDs that should be returned
    ///   - logger: Logger used for logging
    @inlinable
    public func listEulasPaginator(
        eulaIds: [String]? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) -> AWSClient.PaginatorSequence<ListEulasRequest, ListEulasResponse> {
        let input = ListEulasRequest(
            eulaIds: eulaIds
        )
        return self.listEulasPaginator(input, logger: logger)
    }

    /// Return PaginatorSequence for operation ``listLaunchProfileMembers(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func listLaunchProfileMembersPaginator(
        _ input: ListLaunchProfileMembersRequest,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<ListLaunchProfileMembersRequest, ListLaunchProfileMembersResponse> {
        return .init(
            input: input,
            command: self.listLaunchProfileMembers,
            inputKey: \ListLaunchProfileMembersRequest.nextToken,
            outputKey: \ListLaunchProfileMembersResponse.nextToken,
            logger: logger
        )
    }
    /// Return PaginatorSequence for operation ``listLaunchProfileMembers(_:logger:)``.
    ///
    /// - Parameters:
    ///   - launchProfileId: The ID of the launch profile used to control access from the streaming session.
    ///   - maxResults: The max number of results to return in the response.
    ///   - studioId: The studio ID.
    ///   - logger: Logger used for logging
    @inlinable
    public func listLaunchProfileMembersPaginator(
        launchProfileId: String,
        maxResults: Int? = nil,
        studioId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) -> AWSClient.PaginatorSequence<ListLaunchProfileMembersRequest, ListLaunchProfileMembersResponse> {
        let input = ListLaunchProfileMembersRequest(
            launchProfileId: launchProfileId, 
            maxResults: maxResults, 
            studioId: studioId
        )
        return self.listLaunchProfileMembersPaginator(input, logger: logger)
    }

    /// Return PaginatorSequence for operation ``listLaunchProfiles(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func listLaunchProfilesPaginator(
        _ input: ListLaunchProfilesRequest,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<ListLaunchProfilesRequest, ListLaunchProfilesResponse> {
        return .init(
            input: input,
            command: self.listLaunchProfiles,
            inputKey: \ListLaunchProfilesRequest.nextToken,
            outputKey: \ListLaunchProfilesResponse.nextToken,
            logger: logger
        )
    }
    /// Return PaginatorSequence for operation ``listLaunchProfiles(_:logger:)``.
    ///
    /// - Parameters:
    ///   - maxResults: The max number of results to return in the response.
    ///   - principalId: The principal ID. This currently supports a IAM Identity Center UserId.
    ///   - states: Filter this request to launch profiles in any of the given states.
    ///   - studioId: The studio ID.
    ///   - logger: Logger used for logging
    @inlinable
    public func listLaunchProfilesPaginator(
        maxResults: Int? = nil,
        principalId: String? = nil,
        states: [LaunchProfileState]? = nil,
        studioId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) -> AWSClient.PaginatorSequence<ListLaunchProfilesRequest, ListLaunchProfilesResponse> {
        let input = ListLaunchProfilesRequest(
            maxResults: maxResults, 
            principalId: principalId, 
            states: states, 
            studioId: studioId
        )
        return self.listLaunchProfilesPaginator(input, logger: logger)
    }

    /// Return PaginatorSequence for operation ``listStreamingImages(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func listStreamingImagesPaginator(
        _ input: ListStreamingImagesRequest,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<ListStreamingImagesRequest, ListStreamingImagesResponse> {
        return .init(
            input: input,
            command: self.listStreamingImages,
            inputKey: \ListStreamingImagesRequest.nextToken,
            outputKey: \ListStreamingImagesResponse.nextToken,
            logger: logger
        )
    }
    /// Return PaginatorSequence for operation ``listStreamingImages(_:logger:)``.
    ///
    /// - Parameters:
    ///   - owner: Filter this request to streaming images with the given owner
    ///   - studioId: The studio ID.
    ///   - logger: Logger used for logging
    @inlinable
    public func listStreamingImagesPaginator(
        owner: String? = nil,
        studioId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) -> AWSClient.PaginatorSequence<ListStreamingImagesRequest, ListStreamingImagesResponse> {
        let input = ListStreamingImagesRequest(
            owner: owner, 
            studioId: studioId
        )
        return self.listStreamingImagesPaginator(input, logger: logger)
    }

    /// Return PaginatorSequence for operation ``listStreamingSessionBackups(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func listStreamingSessionBackupsPaginator(
        _ input: ListStreamingSessionBackupsRequest,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<ListStreamingSessionBackupsRequest, ListStreamingSessionBackupsResponse> {
        return .init(
            input: input,
            command: self.listStreamingSessionBackups,
            inputKey: \ListStreamingSessionBackupsRequest.nextToken,
            outputKey: \ListStreamingSessionBackupsResponse.nextToken,
            logger: logger
        )
    }
    /// Return PaginatorSequence for operation ``listStreamingSessionBackups(_:logger:)``.
    ///
    /// - Parameters:
    ///   - ownedBy: The user ID of the user that owns the streaming session.
    ///   - studioId: The studio ID.
    ///   - logger: Logger used for logging
    @inlinable
    public func listStreamingSessionBackupsPaginator(
        ownedBy: String? = nil,
        studioId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) -> AWSClient.PaginatorSequence<ListStreamingSessionBackupsRequest, ListStreamingSessionBackupsResponse> {
        let input = ListStreamingSessionBackupsRequest(
            ownedBy: ownedBy, 
            studioId: studioId
        )
        return self.listStreamingSessionBackupsPaginator(input, logger: logger)
    }

    /// Return PaginatorSequence for operation ``listStreamingSessions(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func listStreamingSessionsPaginator(
        _ input: ListStreamingSessionsRequest,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<ListStreamingSessionsRequest, ListStreamingSessionsResponse> {
        return .init(
            input: input,
            command: self.listStreamingSessions,
            inputKey: \ListStreamingSessionsRequest.nextToken,
            outputKey: \ListStreamingSessionsResponse.nextToken,
            logger: logger
        )
    }
    /// Return PaginatorSequence for operation ``listStreamingSessions(_:logger:)``.
    ///
    /// - Parameters:
    ///   - createdBy: Filters the request to streaming sessions created by the given user.
    ///   - ownedBy: Filters the request to streaming session owned by the given user
    ///   - sessionIds: Filters the request to only the provided session IDs.
    ///   - studioId: The studio ID.
    ///   - logger: Logger used for logging
    @inlinable
    public func listStreamingSessionsPaginator(
        createdBy: String? = nil,
        ownedBy: String? = nil,
        sessionIds: String? = nil,
        studioId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) -> AWSClient.PaginatorSequence<ListStreamingSessionsRequest, ListStreamingSessionsResponse> {
        let input = ListStreamingSessionsRequest(
            createdBy: createdBy, 
            ownedBy: ownedBy, 
            sessionIds: sessionIds, 
            studioId: studioId
        )
        return self.listStreamingSessionsPaginator(input, logger: logger)
    }

    /// Return PaginatorSequence for operation ``listStudioComponents(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func listStudioComponentsPaginator(
        _ input: ListStudioComponentsRequest,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<ListStudioComponentsRequest, ListStudioComponentsResponse> {
        return .init(
            input: input,
            command: self.listStudioComponents,
            inputKey: \ListStudioComponentsRequest.nextToken,
            outputKey: \ListStudioComponentsResponse.nextToken,
            logger: logger
        )
    }
    /// Return PaginatorSequence for operation ``listStudioComponents(_:logger:)``.
    ///
    /// - Parameters:
    ///   - maxResults: The max number of results to return in the response.
    ///   - states: Filters the request to studio components that are in one of the given states.
    ///   - studioId: The studio ID.
    ///   - types: Filters the request to studio components that are of one of the given types.
    ///   - logger: Logger used for logging
    @inlinable
    public func listStudioComponentsPaginator(
        maxResults: Int? = nil,
        states: [StudioComponentState]? = nil,
        studioId: String,
        types: [StudioComponentType]? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) -> AWSClient.PaginatorSequence<ListStudioComponentsRequest, ListStudioComponentsResponse> {
        let input = ListStudioComponentsRequest(
            maxResults: maxResults, 
            states: states, 
            studioId: studioId, 
            types: types
        )
        return self.listStudioComponentsPaginator(input, logger: logger)
    }

    /// Return PaginatorSequence for operation ``listStudioMembers(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func listStudioMembersPaginator(
        _ input: ListStudioMembersRequest,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<ListStudioMembersRequest, ListStudioMembersResponse> {
        return .init(
            input: input,
            command: self.listStudioMembers,
            inputKey: \ListStudioMembersRequest.nextToken,
            outputKey: \ListStudioMembersResponse.nextToken,
            logger: logger
        )
    }
    /// Return PaginatorSequence for operation ``listStudioMembers(_:logger:)``.
    ///
    /// - Parameters:
    ///   - maxResults: The max number of results to return in the response.
    ///   - studioId: The studio ID.
    ///   - logger: Logger used for logging
    @inlinable
    public func listStudioMembersPaginator(
        maxResults: Int? = nil,
        studioId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) -> AWSClient.PaginatorSequence<ListStudioMembersRequest, ListStudioMembersResponse> {
        let input = ListStudioMembersRequest(
            maxResults: maxResults, 
            studioId: studioId
        )
        return self.listStudioMembersPaginator(input, logger: logger)
    }

    /// Return PaginatorSequence for operation ``listStudios(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func listStudiosPaginator(
        _ input: ListStudiosRequest,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<ListStudiosRequest, ListStudiosResponse> {
        return .init(
            input: input,
            command: self.listStudios,
            inputKey: \ListStudiosRequest.nextToken,
            outputKey: \ListStudiosResponse.nextToken,
            logger: logger
        )
    }
    /// Return PaginatorSequence for operation ``listStudios(_:logger:)``.
    ///
    /// - Parameters:
    ///   - logger: Logger used for logging
    @inlinable
    public func listStudiosPaginator(
        logger: Logger = AWSClient.loggingDisabled        
    ) -> AWSClient.PaginatorSequence<ListStudiosRequest, ListStudiosResponse> {
        let input = ListStudiosRequest(
        )
        return self.listStudiosPaginator(input, logger: logger)
    }
}

extension Nimble.ListEulaAcceptancesRequest: AWSPaginateToken {
    @inlinable
    public func usingPaginationToken(_ token: String) -> Nimble.ListEulaAcceptancesRequest {
        return .init(
            eulaIds: self.eulaIds,
            nextToken: token,
            studioId: self.studioId
        )
    }
}

extension Nimble.ListEulasRequest: AWSPaginateToken {
    @inlinable
    public func usingPaginationToken(_ token: String) -> Nimble.ListEulasRequest {
        return .init(
            eulaIds: self.eulaIds,
            nextToken: token
        )
    }
}

extension Nimble.ListLaunchProfileMembersRequest: AWSPaginateToken {
    @inlinable
    public func usingPaginationToken(_ token: String) -> Nimble.ListLaunchProfileMembersRequest {
        return .init(
            launchProfileId: self.launchProfileId,
            maxResults: self.maxResults,
            nextToken: token,
            studioId: self.studioId
        )
    }
}

extension Nimble.ListLaunchProfilesRequest: AWSPaginateToken {
    @inlinable
    public func usingPaginationToken(_ token: String) -> Nimble.ListLaunchProfilesRequest {
        return .init(
            maxResults: self.maxResults,
            nextToken: token,
            principalId: self.principalId,
            states: self.states,
            studioId: self.studioId
        )
    }
}

extension Nimble.ListStreamingImagesRequest: AWSPaginateToken {
    @inlinable
    public func usingPaginationToken(_ token: String) -> Nimble.ListStreamingImagesRequest {
        return .init(
            nextToken: token,
            owner: self.owner,
            studioId: self.studioId
        )
    }
}

extension Nimble.ListStreamingSessionBackupsRequest: AWSPaginateToken {
    @inlinable
    public func usingPaginationToken(_ token: String) -> Nimble.ListStreamingSessionBackupsRequest {
        return .init(
            nextToken: token,
            ownedBy: self.ownedBy,
            studioId: self.studioId
        )
    }
}

extension Nimble.ListStreamingSessionsRequest: AWSPaginateToken {
    @inlinable
    public func usingPaginationToken(_ token: String) -> Nimble.ListStreamingSessionsRequest {
        return .init(
            createdBy: self.createdBy,
            nextToken: token,
            ownedBy: self.ownedBy,
            sessionIds: self.sessionIds,
            studioId: self.studioId
        )
    }
}

extension Nimble.ListStudioComponentsRequest: AWSPaginateToken {
    @inlinable
    public func usingPaginationToken(_ token: String) -> Nimble.ListStudioComponentsRequest {
        return .init(
            maxResults: self.maxResults,
            nextToken: token,
            states: self.states,
            studioId: self.studioId,
            types: self.types
        )
    }
}

extension Nimble.ListStudioMembersRequest: AWSPaginateToken {
    @inlinable
    public func usingPaginationToken(_ token: String) -> Nimble.ListStudioMembersRequest {
        return .init(
            maxResults: self.maxResults,
            nextToken: token,
            studioId: self.studioId
        )
    }
}

extension Nimble.ListStudiosRequest: AWSPaginateToken {
    @inlinable
    public func usingPaginationToken(_ token: String) -> Nimble.ListStudiosRequest {
        return .init(
            nextToken: token
        )
    }
}

// MARK: Waiters

@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension Nimble {
    /// Waiter for operation ``getLaunchProfile(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func waitUntilLaunchProfileDeleted(
        _ input: GetLaunchProfileRequest,
        maxWaitTime: TimeAmount? = nil,
        logger: Logger = AWSClient.loggingDisabled
    ) async throws {
        let waiter = AWSClient.Waiter<GetLaunchProfileRequest, _>(
            acceptors: [
                .init(state: .success, matcher: try! JMESPathMatcher("launchProfile.state", expected: "DELETED")),
                .init(state: .failure, matcher: try! JMESPathMatcher("launchProfile.state", expected: "DELETE_FAILED")),
            ],
            minDelayTime: .seconds(5),
            maxDelayTime: .seconds(750),
            command: self.getLaunchProfile
        )
        return try await self.client.waitUntil(input, waiter: waiter, maxWaitTime: maxWaitTime, logger: logger)
    }
    /// Waiter for operation ``getLaunchProfile(_:logger:)``.
    ///
    /// - Parameters:
    ///   - launchProfileId: The ID of the launch profile used to control access from the streaming session.
    ///   - studioId: The studio ID.
    ///   - logger: Logger used for logging
    @inlinable
    public func waitUntilLaunchProfileDeleted(
        launchProfileId: String,
        studioId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws {
        let input = GetLaunchProfileRequest(
            launchProfileId: launchProfileId, 
            studioId: studioId
        )
        try await self.waitUntilLaunchProfileDeleted(input, logger: logger)
    }

    /// Waiter for operation ``getLaunchProfile(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func waitUntilLaunchProfileReady(
        _ input: GetLaunchProfileRequest,
        maxWaitTime: TimeAmount? = nil,
        logger: Logger = AWSClient.loggingDisabled
    ) async throws {
        let waiter = AWSClient.Waiter<GetLaunchProfileRequest, _>(
            acceptors: [
                .init(state: .success, matcher: try! JMESPathMatcher("launchProfile.state", expected: "READY")),
                .init(state: .failure, matcher: try! JMESPathMatcher("launchProfile.state", expected: "CREATE_FAILED")),
                .init(state: .failure, matcher: try! JMESPathMatcher("launchProfile.state", expected: "UPDATE_FAILED")),
            ],
            minDelayTime: .seconds(5),
            maxDelayTime: .seconds(750),
            command: self.getLaunchProfile
        )
        return try await self.client.waitUntil(input, waiter: waiter, maxWaitTime: maxWaitTime, logger: logger)
    }
    /// Waiter for operation ``getLaunchProfile(_:logger:)``.
    ///
    /// - Parameters:
    ///   - launchProfileId: The ID of the launch profile used to control access from the streaming session.
    ///   - studioId: The studio ID.
    ///   - logger: Logger used for logging
    @inlinable
    public func waitUntilLaunchProfileReady(
        launchProfileId: String,
        studioId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws {
        let input = GetLaunchProfileRequest(
            launchProfileId: launchProfileId, 
            studioId: studioId
        )
        try await self.waitUntilLaunchProfileReady(input, logger: logger)
    }

    /// Waiter for operation ``getStreamingImage(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func waitUntilStreamingImageDeleted(
        _ input: GetStreamingImageRequest,
        maxWaitTime: TimeAmount? = nil,
        logger: Logger = AWSClient.loggingDisabled
    ) async throws {
        let waiter = AWSClient.Waiter<GetStreamingImageRequest, _>(
            acceptors: [
                .init(state: .success, matcher: try! JMESPathMatcher("streamingImage.state", expected: "DELETED")),
                .init(state: .failure, matcher: try! JMESPathMatcher("streamingImage.state", expected: "DELETE_FAILED")),
            ],
            command: self.getStreamingImage
        )
        return try await self.client.waitUntil(input, waiter: waiter, maxWaitTime: maxWaitTime, logger: logger)
    }
    /// Waiter for operation ``getStreamingImage(_:logger:)``.
    ///
    /// - Parameters:
    ///   - streamingImageId: The streaming image ID.
    ///   - studioId: The studio ID.
    ///   - logger: Logger used for logging
    @inlinable
    public func waitUntilStreamingImageDeleted(
        streamingImageId: String,
        studioId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws {
        let input = GetStreamingImageRequest(
            streamingImageId: streamingImageId, 
            studioId: studioId
        )
        try await self.waitUntilStreamingImageDeleted(input, logger: logger)
    }

    /// Waiter for operation ``getStreamingImage(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func waitUntilStreamingImageReady(
        _ input: GetStreamingImageRequest,
        maxWaitTime: TimeAmount? = nil,
        logger: Logger = AWSClient.loggingDisabled
    ) async throws {
        let waiter = AWSClient.Waiter<GetStreamingImageRequest, _>(
            acceptors: [
                .init(state: .success, matcher: try! JMESPathMatcher("streamingImage.state", expected: "READY")),
                .init(state: .failure, matcher: try! JMESPathMatcher("streamingImage.state", expected: "CREATE_FAILED")),
                .init(state: .failure, matcher: try! JMESPathMatcher("streamingImage.state", expected: "UPDATE_FAILED")),
            ],
            command: self.getStreamingImage
        )
        return try await self.client.waitUntil(input, waiter: waiter, maxWaitTime: maxWaitTime, logger: logger)
    }
    /// Waiter for operation ``getStreamingImage(_:logger:)``.
    ///
    /// - Parameters:
    ///   - streamingImageId: The streaming image ID.
    ///   - studioId: The studio ID.
    ///   - logger: Logger used for logging
    @inlinable
    public func waitUntilStreamingImageReady(
        streamingImageId: String,
        studioId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws {
        let input = GetStreamingImageRequest(
            streamingImageId: streamingImageId, 
            studioId: studioId
        )
        try await self.waitUntilStreamingImageReady(input, logger: logger)
    }

    /// Waiter for operation ``getStreamingSession(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func waitUntilStreamingSessionDeleted(
        _ input: GetStreamingSessionRequest,
        maxWaitTime: TimeAmount? = nil,
        logger: Logger = AWSClient.loggingDisabled
    ) async throws {
        let waiter = AWSClient.Waiter<GetStreamingSessionRequest, _>(
            acceptors: [
                .init(state: .success, matcher: try! JMESPathMatcher("session.state", expected: "DELETED")),
                .init(state: .failure, matcher: try! JMESPathMatcher("session.state", expected: "DELETE_FAILED")),
            ],
            minDelayTime: .seconds(5),
            maxDelayTime: .seconds(900),
            command: self.getStreamingSession
        )
        return try await self.client.waitUntil(input, waiter: waiter, maxWaitTime: maxWaitTime, logger: logger)
    }
    /// Waiter for operation ``getStreamingSession(_:logger:)``.
    ///
    /// - Parameters:
    ///   - sessionId: The streaming session ID.
    ///   - studioId: The studio ID.
    ///   - logger: Logger used for logging
    @inlinable
    public func waitUntilStreamingSessionDeleted(
        sessionId: String,
        studioId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws {
        let input = GetStreamingSessionRequest(
            sessionId: sessionId, 
            studioId: studioId
        )
        try await self.waitUntilStreamingSessionDeleted(input, logger: logger)
    }

    /// Waiter for operation ``getStreamingSession(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func waitUntilStreamingSessionReady(
        _ input: GetStreamingSessionRequest,
        maxWaitTime: TimeAmount? = nil,
        logger: Logger = AWSClient.loggingDisabled
    ) async throws {
        let waiter = AWSClient.Waiter<GetStreamingSessionRequest, _>(
            acceptors: [
                .init(state: .success, matcher: try! JMESPathMatcher("session.state", expected: "READY")),
                .init(state: .failure, matcher: try! JMESPathMatcher("session.state", expected: "CREATE_FAILED")),
                .init(state: .failure, matcher: try! JMESPathMatcher("session.state", expected: "START_FAILED")),
            ],
            minDelayTime: .seconds(10),
            maxDelayTime: .seconds(1800),
            command: self.getStreamingSession
        )
        return try await self.client.waitUntil(input, waiter: waiter, maxWaitTime: maxWaitTime, logger: logger)
    }
    /// Waiter for operation ``getStreamingSession(_:logger:)``.
    ///
    /// - Parameters:
    ///   - sessionId: The streaming session ID.
    ///   - studioId: The studio ID.
    ///   - logger: Logger used for logging
    @inlinable
    public func waitUntilStreamingSessionReady(
        sessionId: String,
        studioId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws {
        let input = GetStreamingSessionRequest(
            sessionId: sessionId, 
            studioId: studioId
        )
        try await self.waitUntilStreamingSessionReady(input, logger: logger)
    }

    /// Waiter for operation ``getStreamingSession(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func waitUntilStreamingSessionStopped(
        _ input: GetStreamingSessionRequest,
        maxWaitTime: TimeAmount? = nil,
        logger: Logger = AWSClient.loggingDisabled
    ) async throws {
        let waiter = AWSClient.Waiter<GetStreamingSessionRequest, _>(
            acceptors: [
                .init(state: .success, matcher: try! JMESPathMatcher("session.state", expected: "STOPPED")),
                .init(state: .failure, matcher: try! JMESPathMatcher("session.state", expected: "STOP_FAILED")),
            ],
            minDelayTime: .seconds(5),
            maxDelayTime: .seconds(900),
            command: self.getStreamingSession
        )
        return try await self.client.waitUntil(input, waiter: waiter, maxWaitTime: maxWaitTime, logger: logger)
    }
    /// Waiter for operation ``getStreamingSession(_:logger:)``.
    ///
    /// - Parameters:
    ///   - sessionId: The streaming session ID.
    ///   - studioId: The studio ID.
    ///   - logger: Logger used for logging
    @inlinable
    public func waitUntilStreamingSessionStopped(
        sessionId: String,
        studioId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws {
        let input = GetStreamingSessionRequest(
            sessionId: sessionId, 
            studioId: studioId
        )
        try await self.waitUntilStreamingSessionStopped(input, logger: logger)
    }

    /// Waiter for operation ``getStreamingSessionStream(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func waitUntilStreamingSessionStreamReady(
        _ input: GetStreamingSessionStreamRequest,
        maxWaitTime: TimeAmount? = nil,
        logger: Logger = AWSClient.loggingDisabled
    ) async throws {
        let waiter = AWSClient.Waiter<GetStreamingSessionStreamRequest, _>(
            acceptors: [
                .init(state: .success, matcher: try! JMESPathMatcher("stream.state", expected: "READY")),
                .init(state: .failure, matcher: try! JMESPathMatcher("stream.state", expected: "CREATE_FAILED")),
            ],
            minDelayTime: .seconds(5),
            maxDelayTime: .seconds(150),
            command: self.getStreamingSessionStream
        )
        return try await self.client.waitUntil(input, waiter: waiter, maxWaitTime: maxWaitTime, logger: logger)
    }
    /// Waiter for operation ``getStreamingSessionStream(_:logger:)``.
    ///
    /// - Parameters:
    ///   - sessionId: The streaming session ID.
    ///   - streamId: The streaming session stream ID.
    ///   - studioId: The studio ID.
    ///   - logger: Logger used for logging
    @inlinable
    public func waitUntilStreamingSessionStreamReady(
        sessionId: String,
        streamId: String,
        studioId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws {
        let input = GetStreamingSessionStreamRequest(
            sessionId: sessionId, 
            streamId: streamId, 
            studioId: studioId
        )
        try await self.waitUntilStreamingSessionStreamReady(input, logger: logger)
    }

    /// Waiter for operation ``getStudioComponent(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func waitUntilStudioComponentDeleted(
        _ input: GetStudioComponentRequest,
        maxWaitTime: TimeAmount? = nil,
        logger: Logger = AWSClient.loggingDisabled
    ) async throws {
        let waiter = AWSClient.Waiter<GetStudioComponentRequest, _>(
            acceptors: [
                .init(state: .success, matcher: try! JMESPathMatcher("studioComponent.state", expected: "DELETED")),
                .init(state: .failure, matcher: try! JMESPathMatcher("studioComponent.state", expected: "DELETE_FAILED")),
            ],
            minDelayTime: .seconds(1),
            maxDelayTime: .seconds(120),
            command: self.getStudioComponent
        )
        return try await self.client.waitUntil(input, waiter: waiter, maxWaitTime: maxWaitTime, logger: logger)
    }
    /// Waiter for operation ``getStudioComponent(_:logger:)``.
    ///
    /// - Parameters:
    ///   - studioComponentId: The studio component ID.
    ///   - studioId: The studio ID.
    ///   - logger: Logger used for logging
    @inlinable
    public func waitUntilStudioComponentDeleted(
        studioComponentId: String,
        studioId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws {
        let input = GetStudioComponentRequest(
            studioComponentId: studioComponentId, 
            studioId: studioId
        )
        try await self.waitUntilStudioComponentDeleted(input, logger: logger)
    }

    /// Waiter for operation ``getStudioComponent(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func waitUntilStudioComponentReady(
        _ input: GetStudioComponentRequest,
        maxWaitTime: TimeAmount? = nil,
        logger: Logger = AWSClient.loggingDisabled
    ) async throws {
        let waiter = AWSClient.Waiter<GetStudioComponentRequest, _>(
            acceptors: [
                .init(state: .success, matcher: try! JMESPathMatcher("studioComponent.state", expected: "READY")),
                .init(state: .failure, matcher: try! JMESPathMatcher("studioComponent.state", expected: "CREATE_FAILED")),
                .init(state: .failure, matcher: try! JMESPathMatcher("studioComponent.state", expected: "UPDATE_FAILED")),
            ],
            command: self.getStudioComponent
        )
        return try await self.client.waitUntil(input, waiter: waiter, maxWaitTime: maxWaitTime, logger: logger)
    }
    /// Waiter for operation ``getStudioComponent(_:logger:)``.
    ///
    /// - Parameters:
    ///   - studioComponentId: The studio component ID.
    ///   - studioId: The studio ID.
    ///   - logger: Logger used for logging
    @inlinable
    public func waitUntilStudioComponentReady(
        studioComponentId: String,
        studioId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws {
        let input = GetStudioComponentRequest(
            studioComponentId: studioComponentId, 
            studioId: studioId
        )
        try await self.waitUntilStudioComponentReady(input, logger: logger)
    }

    /// Waiter for operation ``getStudio(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func waitUntilStudioDeleted(
        _ input: GetStudioRequest,
        maxWaitTime: TimeAmount? = nil,
        logger: Logger = AWSClient.loggingDisabled
    ) async throws {
        let waiter = AWSClient.Waiter<GetStudioRequest, _>(
            acceptors: [
                .init(state: .success, matcher: try! JMESPathMatcher("studio.state", expected: "DELETED")),
                .init(state: .failure, matcher: try! JMESPathMatcher("studio.state", expected: "DELETE_FAILED")),
            ],
            command: self.getStudio
        )
        return try await self.client.waitUntil(input, waiter: waiter, maxWaitTime: maxWaitTime, logger: logger)
    }
    /// Waiter for operation ``getStudio(_:logger:)``.
    ///
    /// - Parameters:
    ///   - studioId: The studio ID.
    ///   - logger: Logger used for logging
    @inlinable
    public func waitUntilStudioDeleted(
        studioId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws {
        let input = GetStudioRequest(
            studioId: studioId
        )
        try await self.waitUntilStudioDeleted(input, logger: logger)
    }

    /// Waiter for operation ``getStudio(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func waitUntilStudioReady(
        _ input: GetStudioRequest,
        maxWaitTime: TimeAmount? = nil,
        logger: Logger = AWSClient.loggingDisabled
    ) async throws {
        let waiter = AWSClient.Waiter<GetStudioRequest, _>(
            acceptors: [
                .init(state: .success, matcher: try! JMESPathMatcher("studio.state", expected: "READY")),
                .init(state: .failure, matcher: try! JMESPathMatcher("studio.state", expected: "CREATE_FAILED")),
                .init(state: .failure, matcher: try! JMESPathMatcher("studio.state", expected: "UPDATE_FAILED")),
            ],
            command: self.getStudio
        )
        return try await self.client.waitUntil(input, waiter: waiter, maxWaitTime: maxWaitTime, logger: logger)
    }
    /// Waiter for operation ``getStudio(_:logger:)``.
    ///
    /// - Parameters:
    ///   - studioId: The studio ID.
    ///   - logger: Logger used for logging
    @inlinable
    public func waitUntilStudioReady(
        studioId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws {
        let input = GetStudioRequest(
            studioId: studioId
        )
        try await self.waitUntilStudioReady(input, logger: logger)
    }
}
