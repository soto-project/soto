//===----------------------------------------------------------------------===//
//
// This source file is part of the Soto for AWS open source project
//
// Copyright (c) 2017-2022 the Soto project authors
// Licensed under Apache License v2.0
//
// See LICENSE.txt for license information
// See CONTRIBUTORS.txt for the list of Soto project authors
//
// SPDX-License-Identifier: Apache-2.0
//
//===----------------------------------------------------------------------===//

// THIS FILE IS AUTOMATICALLY GENERATED by https://github.com/soto-project/soto-codegenerator.
// DO NOT EDIT.

import Foundation
import SotoCore

extension Nimble {
    // MARK: Enums

    public enum AutomaticTerminationMode: String, CustomStringConvertible, Codable, _SotoSendable {
        case activated = "ACTIVATED"
        case deactivated = "DEACTIVATED"
        public var description: String { return self.rawValue }
    }

    public enum LaunchProfilePersona: String, CustomStringConvertible, Codable, _SotoSendable {
        case user = "USER"
        public var description: String { return self.rawValue }
    }

    public enum LaunchProfilePlatform: String, CustomStringConvertible, Codable, _SotoSendable {
        case linux = "LINUX"
        case windows = "WINDOWS"
        public var description: String { return self.rawValue }
    }

    public enum LaunchProfileState: String, CustomStringConvertible, Codable, _SotoSendable {
        case createFailed = "CREATE_FAILED"
        case createInProgress = "CREATE_IN_PROGRESS"
        case deleteFailed = "DELETE_FAILED"
        case deleteInProgress = "DELETE_IN_PROGRESS"
        case deleted = "DELETED"
        case ready = "READY"
        case updateFailed = "UPDATE_FAILED"
        case updateInProgress = "UPDATE_IN_PROGRESS"
        public var description: String { return self.rawValue }
    }

    public enum LaunchProfileStatusCode: String, CustomStringConvertible, Codable, _SotoSendable {
        case encryptionKeyAccessDenied = "ENCRYPTION_KEY_ACCESS_DENIED"
        case encryptionKeyNotFound = "ENCRYPTION_KEY_NOT_FOUND"
        case internalError = "INTERNAL_ERROR"
        case invalidInstanceTypesProvided = "INVALID_INSTANCE_TYPES_PROVIDED"
        case invalidSubnetsCombination = "INVALID_SUBNETS_COMBINATION"
        case invalidSubnetsProvided = "INVALID_SUBNETS_PROVIDED"
        case launchProfileCreateInProgress = "LAUNCH_PROFILE_CREATE_IN_PROGRESS"
        case launchProfileCreated = "LAUNCH_PROFILE_CREATED"
        case launchProfileDeleteInProgress = "LAUNCH_PROFILE_DELETE_IN_PROGRESS"
        case launchProfileDeleted = "LAUNCH_PROFILE_DELETED"
        case launchProfileUpdateInProgress = "LAUNCH_PROFILE_UPDATE_IN_PROGRESS"
        case launchProfileUpdated = "LAUNCH_PROFILE_UPDATED"
        case launchProfileWithStreamSessionsNotDeleted = "LAUNCH_PROFILE_WITH_STREAM_SESSIONS_NOT_DELETED"
        case streamingImageNotFound = "STREAMING_IMAGE_NOT_FOUND"
        case streamingImageNotReady = "STREAMING_IMAGE_NOT_READY"
        public var description: String { return self.rawValue }
    }

    public enum LaunchProfileValidationState: String, CustomStringConvertible, Codable, _SotoSendable {
        case validationFailed = "VALIDATION_FAILED"
        case validationFailedInternalServerError = "VALIDATION_FAILED_INTERNAL_SERVER_ERROR"
        case validationInProgress = "VALIDATION_IN_PROGRESS"
        case validationNotStarted = "VALIDATION_NOT_STARTED"
        case validationSuccess = "VALIDATION_SUCCESS"
        public var description: String { return self.rawValue }
    }

    public enum LaunchProfileValidationStatusCode: String, CustomStringConvertible, Codable, _SotoSendable {
        case validationFailedInternalServerError = "VALIDATION_FAILED_INTERNAL_SERVER_ERROR"
        case validationFailedInvalidActiveDirectory = "VALIDATION_FAILED_INVALID_ACTIVE_DIRECTORY"
        case validationFailedInvalidSecurityGroupAssociation = "VALIDATION_FAILED_INVALID_SECURITY_GROUP_ASSOCIATION"
        case validationFailedInvalidSubnetRouteTableAssociation = "VALIDATION_FAILED_INVALID_SUBNET_ROUTE_TABLE_ASSOCIATION"
        case validationFailedSubnetNotFound = "VALIDATION_FAILED_SUBNET_NOT_FOUND"
        case validationFailedUnauthorized = "VALIDATION_FAILED_UNAUTHORIZED"
        case validationInProgress = "VALIDATION_IN_PROGRESS"
        case validationNotStarted = "VALIDATION_NOT_STARTED"
        case validationSuccess = "VALIDATION_SUCCESS"
        public var description: String { return self.rawValue }
    }

    public enum LaunchProfileValidationType: String, CustomStringConvertible, Codable, _SotoSendable {
        case validateActiveDirectoryStudioComponent = "VALIDATE_ACTIVE_DIRECTORY_STUDIO_COMPONENT"
        case validateNetworkAclAssociation = "VALIDATE_NETWORK_ACL_ASSOCIATION"
        case validateSecurityGroupAssociation = "VALIDATE_SECURITY_GROUP_ASSOCIATION"
        case validateSubnetAssociation = "VALIDATE_SUBNET_ASSOCIATION"
        public var description: String { return self.rawValue }
    }

    public enum SessionBackupMode: String, CustomStringConvertible, Codable, _SotoSendable {
        case automatic = "AUTOMATIC"
        case deactivated = "DEACTIVATED"
        public var description: String { return self.rawValue }
    }

    public enum SessionPersistenceMode: String, CustomStringConvertible, Codable, _SotoSendable {
        case activated = "ACTIVATED"
        case deactivated = "DEACTIVATED"
        public var description: String { return self.rawValue }
    }

    public enum StreamingClipboardMode: String, CustomStringConvertible, Codable, _SotoSendable {
        case disabled = "DISABLED"
        case enabled = "ENABLED"
        public var description: String { return self.rawValue }
    }

    public enum StreamingImageEncryptionConfigurationKeyType: String, CustomStringConvertible, Codable, _SotoSendable {
        case customerManagedKey = "CUSTOMER_MANAGED_KEY"
        public var description: String { return self.rawValue }
    }

    public enum StreamingImageState: String, CustomStringConvertible, Codable, _SotoSendable {
        case createFailed = "CREATE_FAILED"
        case createInProgress = "CREATE_IN_PROGRESS"
        case deleteFailed = "DELETE_FAILED"
        case deleteInProgress = "DELETE_IN_PROGRESS"
        case deleted = "DELETED"
        case ready = "READY"
        case updateFailed = "UPDATE_FAILED"
        case updateInProgress = "UPDATE_IN_PROGRESS"
        public var description: String { return self.rawValue }
    }

    public enum StreamingImageStatusCode: String, CustomStringConvertible, Codable, _SotoSendable {
        case accessDenied = "ACCESS_DENIED"
        case internalError = "INTERNAL_ERROR"
        case streamingImageCreateInProgress = "STREAMING_IMAGE_CREATE_IN_PROGRESS"
        case streamingImageDeleteInProgress = "STREAMING_IMAGE_DELETE_IN_PROGRESS"
        case streamingImageDeleted = "STREAMING_IMAGE_DELETED"
        case streamingImageReady = "STREAMING_IMAGE_READY"
        case streamingImageUpdateInProgress = "STREAMING_IMAGE_UPDATE_IN_PROGRESS"
        public var description: String { return self.rawValue }
    }

    public enum StreamingInstanceType: String, CustomStringConvertible, Codable, _SotoSendable {
        case g34Xlarge = "g3.4xlarge"
        case g3sXlarge = "g3s.xlarge"
        case g4dn12Xlarge = "g4dn.12xlarge"
        case g4dn16Xlarge = "g4dn.16xlarge"
        case g4dn2Xlarge = "g4dn.2xlarge"
        case g4dn4Xlarge = "g4dn.4xlarge"
        case g4dn8Xlarge = "g4dn.8xlarge"
        case g4dnXlarge = "g4dn.xlarge"
        case g516Xlarge = "g5.16xlarge"
        case g52Xlarge = "g5.2xlarge"
        case g54Xlarge = "g5.4xlarge"
        case g58Xlarge = "g5.8xlarge"
        case g5Xlarge = "g5.xlarge"
        public var description: String { return self.rawValue }
    }

    public enum StreamingSessionState: String, CustomStringConvertible, Codable, _SotoSendable {
        case createFailed = "CREATE_FAILED"
        case createInProgress = "CREATE_IN_PROGRESS"
        case deleteFailed = "DELETE_FAILED"
        case deleteInProgress = "DELETE_IN_PROGRESS"
        case deleted = "DELETED"
        case ready = "READY"
        case startFailed = "START_FAILED"
        case startInProgress = "START_IN_PROGRESS"
        case stopFailed = "STOP_FAILED"
        case stopInProgress = "STOP_IN_PROGRESS"
        case stopped = "STOPPED"
        public var description: String { return self.rawValue }
    }

    public enum StreamingSessionStatusCode: String, CustomStringConvertible, Codable, _SotoSendable {
        case activeDirectoryDomainJoinError = "ACTIVE_DIRECTORY_DOMAIN_JOIN_ERROR"
        case amiValidationError = "AMI_VALIDATION_ERROR"
        case decryptStreamingImageError = "DECRYPT_STREAMING_IMAGE_ERROR"
        case initializationScriptError = "INITIALIZATION_SCRIPT_ERROR"
        case insufficientCapacity = "INSUFFICIENT_CAPACITY"
        case internalError = "INTERNAL_ERROR"
        case networkConnectionError = "NETWORK_CONNECTION_ERROR"
        case networkInterfaceError = "NETWORK_INTERFACE_ERROR"
        case streamingSessionCreateInProgress = "STREAMING_SESSION_CREATE_IN_PROGRESS"
        case streamingSessionDeleteInProgress = "STREAMING_SESSION_DELETE_IN_PROGRESS"
        case streamingSessionDeleted = "STREAMING_SESSION_DELETED"
        case streamingSessionReady = "STREAMING_SESSION_READY"
        case streamingSessionStartInProgress = "STREAMING_SESSION_START_IN_PROGRESS"
        case streamingSessionStarted = "STREAMING_SESSION_STARTED"
        case streamingSessionStopInProgress = "STREAMING_SESSION_STOP_IN_PROGRESS"
        case streamingSessionStopped = "STREAMING_SESSION_STOPPED"
        public var description: String { return self.rawValue }
    }

    public enum StreamingSessionStorageMode: String, CustomStringConvertible, Codable, _SotoSendable {
        case upload = "UPLOAD"
        public var description: String { return self.rawValue }
    }

    public enum StreamingSessionStreamState: String, CustomStringConvertible, Codable, _SotoSendable {
        case createFailed = "CREATE_FAILED"
        case createInProgress = "CREATE_IN_PROGRESS"
        case deleteFailed = "DELETE_FAILED"
        case deleteInProgress = "DELETE_IN_PROGRESS"
        case deleted = "DELETED"
        case ready = "READY"
        public var description: String { return self.rawValue }
    }

    public enum StreamingSessionStreamStatusCode: String, CustomStringConvertible, Codable, _SotoSendable {
        case internalError = "INTERNAL_ERROR"
        case networkConnectionError = "NETWORK_CONNECTION_ERROR"
        case streamCreateInProgress = "STREAM_CREATE_IN_PROGRESS"
        case streamDeleteInProgress = "STREAM_DELETE_IN_PROGRESS"
        case streamDeleted = "STREAM_DELETED"
        case streamReady = "STREAM_READY"
        public var description: String { return self.rawValue }
    }

    public enum StudioComponentInitializationScriptRunContext: String, CustomStringConvertible, Codable, _SotoSendable {
        case systemInitialization = "SYSTEM_INITIALIZATION"
        case userInitialization = "USER_INITIALIZATION"
        public var description: String { return self.rawValue }
    }

    public enum StudioComponentState: String, CustomStringConvertible, Codable, _SotoSendable {
        case createFailed = "CREATE_FAILED"
        case createInProgress = "CREATE_IN_PROGRESS"
        case deleteFailed = "DELETE_FAILED"
        case deleteInProgress = "DELETE_IN_PROGRESS"
        case deleted = "DELETED"
        case ready = "READY"
        case updateFailed = "UPDATE_FAILED"
        case updateInProgress = "UPDATE_IN_PROGRESS"
        public var description: String { return self.rawValue }
    }

    public enum StudioComponentStatusCode: String, CustomStringConvertible, Codable, _SotoSendable {
        case activeDirectoryAlreadyExists = "ACTIVE_DIRECTORY_ALREADY_EXISTS"
        case encryptionKeyAccessDenied = "ENCRYPTION_KEY_ACCESS_DENIED"
        case encryptionKeyNotFound = "ENCRYPTION_KEY_NOT_FOUND"
        case internalError = "INTERNAL_ERROR"
        case studioComponentCreateInProgress = "STUDIO_COMPONENT_CREATE_IN_PROGRESS"
        case studioComponentCreated = "STUDIO_COMPONENT_CREATED"
        case studioComponentDeleteInProgress = "STUDIO_COMPONENT_DELETE_IN_PROGRESS"
        case studioComponentDeleted = "STUDIO_COMPONENT_DELETED"
        case studioComponentUpdateInProgress = "STUDIO_COMPONENT_UPDATE_IN_PROGRESS"
        case studioComponentUpdated = "STUDIO_COMPONENT_UPDATED"
        public var description: String { return self.rawValue }
    }

    public enum StudioComponentSubtype: String, CustomStringConvertible, Codable, _SotoSendable {
        case amazonFsxForLustre = "AMAZON_FSX_FOR_LUSTRE"
        case amazonFsxForWindows = "AMAZON_FSX_FOR_WINDOWS"
        case awsManagedMicrosoftAd = "AWS_MANAGED_MICROSOFT_AD"
        case custom = "CUSTOM"
        public var description: String { return self.rawValue }
    }

    public enum StudioComponentType: String, CustomStringConvertible, Codable, _SotoSendable {
        case activeDirectory = "ACTIVE_DIRECTORY"
        case computeFarm = "COMPUTE_FARM"
        case custom = "CUSTOM"
        case licenseService = "LICENSE_SERVICE"
        case sharedFileSystem = "SHARED_FILE_SYSTEM"
        public var description: String { return self.rawValue }
    }

    public enum StudioEncryptionConfigurationKeyType: String, CustomStringConvertible, Codable, _SotoSendable {
        case awsOwnedKey = "AWS_OWNED_KEY"
        case customerManagedKey = "CUSTOMER_MANAGED_KEY"
        public var description: String { return self.rawValue }
    }

    public enum StudioPersona: String, CustomStringConvertible, Codable, _SotoSendable {
        case administrator = "ADMINISTRATOR"
        public var description: String { return self.rawValue }
    }

    public enum StudioState: String, CustomStringConvertible, Codable, _SotoSendable {
        case createFailed = "CREATE_FAILED"
        case createInProgress = "CREATE_IN_PROGRESS"
        case deleteFailed = "DELETE_FAILED"
        case deleteInProgress = "DELETE_IN_PROGRESS"
        case deleted = "DELETED"
        case ready = "READY"
        case updateFailed = "UPDATE_FAILED"
        case updateInProgress = "UPDATE_IN_PROGRESS"
        public var description: String { return self.rawValue }
    }

    public enum StudioStatusCode: String, CustomStringConvertible, Codable, _SotoSendable {
        case awsSsoAccessDenied = "AWS_SSO_ACCESS_DENIED"
        case awsSsoConfigurationRepairInProgress = "AWS_SSO_CONFIGURATION_REPAIR_IN_PROGRESS"
        case awsSsoConfigurationRepaired = "AWS_SSO_CONFIGURATION_REPAIRED"
        case awsSsoNotEnabled = "AWS_SSO_NOT_ENABLED"
        case awsStsRegionDisabled = "AWS_STS_REGION_DISABLED"
        case encryptionKeyAccessDenied = "ENCRYPTION_KEY_ACCESS_DENIED"
        case encryptionKeyNotFound = "ENCRYPTION_KEY_NOT_FOUND"
        case internalError = "INTERNAL_ERROR"
        case roleCouldNotBeAssumed = "ROLE_COULD_NOT_BE_ASSUMED"
        case roleNotOwnedByStudioOwner = "ROLE_NOT_OWNED_BY_STUDIO_OWNER"
        case studioCreateInProgress = "STUDIO_CREATE_IN_PROGRESS"
        case studioCreated = "STUDIO_CREATED"
        case studioDeleteInProgress = "STUDIO_DELETE_IN_PROGRESS"
        case studioDeleted = "STUDIO_DELETED"
        case studioUpdateInProgress = "STUDIO_UPDATE_IN_PROGRESS"
        case studioUpdated = "STUDIO_UPDATED"
        case studioWithLaunchProfilesNotDeleted = "STUDIO_WITH_LAUNCH_PROFILES_NOT_DELETED"
        case studioWithStreamingImagesNotDeleted = "STUDIO_WITH_STREAMING_IMAGES_NOT_DELETED"
        case studioWithStudioComponentsNotDeleted = "STUDIO_WITH_STUDIO_COMPONENTS_NOT_DELETED"
        public var description: String { return self.rawValue }
    }

    public enum VolumeRetentionMode: String, CustomStringConvertible, Codable, _SotoSendable {
        case delete = "DELETE"
        case retain = "RETAIN"
        public var description: String { return self.rawValue }
    }

    public enum StudioComponentConfiguration: AWSEncodableShape & AWSDecodableShape, _SotoSendable {
        /// The configuration for a Directory Service for Microsoft Active Directory studio resource.
        case activeDirectoryConfiguration(ActiveDirectoryConfiguration)
        /// The configuration for a render farm that is associated with a studio resource.
        case computeFarmConfiguration(ComputeFarmConfiguration)
        /// The configuration for a license service that is associated with a studio resource.
        case licenseServiceConfiguration(LicenseServiceConfiguration)
        /// The configuration for a shared file storage system that is associated with a studio resource.
        case sharedFileSystemConfiguration(SharedFileSystemConfiguration)

        public init(from decoder: Decoder) throws {
            let container = try decoder.container(keyedBy: CodingKeys.self)
            guard container.allKeys.count == 1, let key = container.allKeys.first else {
                let context = DecodingError.Context(
                    codingPath: container.codingPath,
                    debugDescription: "Expected exactly one key, but got \(container.allKeys.count)"
                )
                throw DecodingError.dataCorrupted(context)
            }
            switch key {
            case .activeDirectoryConfiguration:
                let value = try container.decode(ActiveDirectoryConfiguration.self, forKey: .activeDirectoryConfiguration)
                self = .activeDirectoryConfiguration(value)
            case .computeFarmConfiguration:
                let value = try container.decode(ComputeFarmConfiguration.self, forKey: .computeFarmConfiguration)
                self = .computeFarmConfiguration(value)
            case .licenseServiceConfiguration:
                let value = try container.decode(LicenseServiceConfiguration.self, forKey: .licenseServiceConfiguration)
                self = .licenseServiceConfiguration(value)
            case .sharedFileSystemConfiguration:
                let value = try container.decode(SharedFileSystemConfiguration.self, forKey: .sharedFileSystemConfiguration)
                self = .sharedFileSystemConfiguration(value)
            }
        }

        public func encode(to encoder: Encoder) throws {
            var container = encoder.container(keyedBy: CodingKeys.self)
            switch self {
            case .activeDirectoryConfiguration(let value):
                try container.encode(value, forKey: .activeDirectoryConfiguration)
            case .computeFarmConfiguration(let value):
                try container.encode(value, forKey: .computeFarmConfiguration)
            case .licenseServiceConfiguration(let value):
                try container.encode(value, forKey: .licenseServiceConfiguration)
            case .sharedFileSystemConfiguration(let value):
                try container.encode(value, forKey: .sharedFileSystemConfiguration)
            }
        }

        public func validate(name: String) throws {
            switch self {
            case .activeDirectoryConfiguration(let value):
                try value.validate(name: "\(name).activeDirectoryConfiguration")
            case .sharedFileSystemConfiguration(let value):
                try value.validate(name: "\(name).sharedFileSystemConfiguration")
            default:
                break
            }
        }

        private enum CodingKeys: String, CodingKey {
            case activeDirectoryConfiguration
            case computeFarmConfiguration
            case licenseServiceConfiguration
            case sharedFileSystemConfiguration
        }
    }

    // MARK: Shapes

    public struct AcceptEulasRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "clientToken", location: .header("X-Amz-Client-Token")),
            AWSMemberEncoding(label: "studioId", location: .uri("studioId"))
        ]

        /// Unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If you don’t specify a client token, the Amazon Web Services SDK automatically generates a client token and uses it for the request to ensure idempotency.
        public let clientToken: String?
        /// The EULA ID.
        public let eulaIds: [String]?
        /// The studio ID.
        public let studioId: String

        public init(clientToken: String? = AcceptEulasRequest.idempotencyToken(), eulaIds: [String]? = nil, studioId: String) {
            self.clientToken = clientToken
            self.eulaIds = eulaIds
            self.studioId = studioId
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 64)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case eulaIds
        }
    }

    public struct AcceptEulasResponse: AWSDecodableShape {
        /// A collection of EULA acceptances.
        public let eulaAcceptances: [EulaAcceptance]?

        public init(eulaAcceptances: [EulaAcceptance]? = nil) {
            self.eulaAcceptances = eulaAcceptances
        }

        private enum CodingKeys: String, CodingKey {
            case eulaAcceptances
        }
    }

    public struct ActiveDirectoryComputerAttribute: AWSEncodableShape & AWSDecodableShape {
        /// The name for the LDAP attribute.
        public let name: String?
        /// The value for the LDAP attribute.
        public let value: String?

        public init(name: String? = nil, value: String? = nil) {
            self.name = name
            self.value = value
        }

        public func validate(name: String) throws {
            try self.validate(self.name, name: "name", parent: name, max: 40)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.value, name: "value", parent: name, max: 64)
            try self.validate(self.value, name: "value", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case name
            case value
        }
    }

    public struct ActiveDirectoryConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// A collection of custom attributes for an Active Directory computer.
        public let computerAttributes: [ActiveDirectoryComputerAttribute]?
        /// The directory ID of the Directory Service for Microsoft Active Directory to access using this studio component.
        public let directoryId: String?
        /// The distinguished name (DN) and organizational unit (OU) of an Active Directory computer.
        public let organizationalUnitDistinguishedName: String?

        public init(computerAttributes: [ActiveDirectoryComputerAttribute]? = nil, directoryId: String? = nil, organizationalUnitDistinguishedName: String? = nil) {
            self.computerAttributes = computerAttributes
            self.directoryId = directoryId
            self.organizationalUnitDistinguishedName = organizationalUnitDistinguishedName
        }

        public func validate(name: String) throws {
            try self.computerAttributes?.forEach {
                try $0.validate(name: "\(name).computerAttributes[]")
            }
            try self.validate(self.computerAttributes, name: "computerAttributes", parent: name, max: 50)
            try self.validate(self.organizationalUnitDistinguishedName, name: "organizationalUnitDistinguishedName", parent: name, max: 2000)
            try self.validate(self.organizationalUnitDistinguishedName, name: "organizationalUnitDistinguishedName", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case computerAttributes
            case directoryId
            case organizationalUnitDistinguishedName
        }
    }

    public struct ComputeFarmConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The name of an Active Directory user that is used on ComputeFarm worker instances.
        public let activeDirectoryUser: String?
        /// The endpoint of the ComputeFarm that is accessed by the studio component resource.
        public let endpoint: String?

        public init(activeDirectoryUser: String? = nil, endpoint: String? = nil) {
            self.activeDirectoryUser = activeDirectoryUser
            self.endpoint = endpoint
        }

        private enum CodingKeys: String, CodingKey {
            case activeDirectoryUser
            case endpoint
        }
    }

    public struct CreateLaunchProfileRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "clientToken", location: .header("X-Amz-Client-Token")),
            AWSMemberEncoding(label: "studioId", location: .uri("studioId"))
        ]

        /// Unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If you don’t specify a client token, the Amazon Web Services SDK automatically generates a client token and uses it for the request to ensure idempotency.
        public let clientToken: String?
        /// The description.
        public let description: String?
        /// Specifies the IDs of the EC2 subnets where streaming sessions will be accessible from. These subnets must support the specified instance types.
        public let ec2SubnetIds: [String]
        /// The version number of the protocol that is used by the launch profile. The only valid version is "2021-03-31".
        public let launchProfileProtocolVersions: [String]
        /// The name for the launch profile.
        public let name: String
        /// A configuration for a streaming session.
        public let streamConfiguration: StreamConfigurationCreate
        /// Unique identifiers for a collection of studio components that can be used with this launch profile.
        public let studioComponentIds: [String]
        /// The studio ID.
        public let studioId: String
        /// A collection of labels, in the form of key-value pairs, that apply to this resource.
        public let tags: [String: String]?

        public init(clientToken: String? = CreateLaunchProfileRequest.idempotencyToken(), description: String? = nil, ec2SubnetIds: [String], launchProfileProtocolVersions: [String], name: String, streamConfiguration: StreamConfigurationCreate, studioComponentIds: [String], studioId: String, tags: [String: String]? = nil) {
            self.clientToken = clientToken
            self.description = description
            self.ec2SubnetIds = ec2SubnetIds
            self.launchProfileProtocolVersions = launchProfileProtocolVersions
            self.name = name
            self.streamConfiguration = streamConfiguration
            self.studioComponentIds = studioComponentIds
            self.studioId = studioId
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 64)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.validate(self.description, name: "description", parent: name, max: 256)
            try self.validate(self.ec2SubnetIds, name: "ec2SubnetIds", parent: name, max: 6)
            try self.launchProfileProtocolVersions.forEach {
                try validate($0, name: "launchProfileProtocolVersions[]", parent: name, max: 10)
                try validate($0, name: "launchProfileProtocolVersions[]", parent: name, pattern: "^2021\\-03\\-31$")
            }
            try self.validate(self.name, name: "name", parent: name, max: 64)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.streamConfiguration.validate(name: "\(name).streamConfiguration")
            try self.validate(self.studioComponentIds, name: "studioComponentIds", parent: name, max: 100)
            try self.validate(self.studioComponentIds, name: "studioComponentIds", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case description
            case ec2SubnetIds
            case launchProfileProtocolVersions
            case name
            case streamConfiguration
            case studioComponentIds
            case tags
        }
    }

    public struct CreateLaunchProfileResponse: AWSDecodableShape {
        /// The launch profile.
        public let launchProfile: LaunchProfile?

        public init(launchProfile: LaunchProfile? = nil) {
            self.launchProfile = launchProfile
        }

        private enum CodingKeys: String, CodingKey {
            case launchProfile
        }
    }

    public struct CreateStreamingImageRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "clientToken", location: .header("X-Amz-Client-Token")),
            AWSMemberEncoding(label: "studioId", location: .uri("studioId"))
        ]

        /// Unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If you don’t specify a client token, the Amazon Web Services SDK automatically generates a client token and uses it for the request to ensure idempotency.
        public let clientToken: String?
        /// A human-readable description of the streaming image.
        public let description: String?
        /// The ID of an EC2 machine image with which to create this streaming image.
        public let ec2ImageId: String
        /// A friendly name for a streaming image resource.
        public let name: String
        /// The studio ID.
        public let studioId: String
        /// A collection of labels, in the form of key-value pairs, that apply to this resource.
        public let tags: [String: String]?

        public init(clientToken: String? = CreateStreamingImageRequest.idempotencyToken(), description: String? = nil, ec2ImageId: String, name: String, studioId: String, tags: [String: String]? = nil) {
            self.clientToken = clientToken
            self.description = description
            self.ec2ImageId = ec2ImageId
            self.name = name
            self.studioId = studioId
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 64)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.validate(self.description, name: "description", parent: name, max: 256)
            try self.validate(self.ec2ImageId, name: "ec2ImageId", parent: name, pattern: "^ami-[0-9A-z]+$")
            try self.validate(self.name, name: "name", parent: name, max: 64)
        }

        private enum CodingKeys: String, CodingKey {
            case description
            case ec2ImageId
            case name
            case tags
        }
    }

    public struct CreateStreamingImageResponse: AWSDecodableShape {
        /// The streaming image.
        public let streamingImage: StreamingImage?

        public init(streamingImage: StreamingImage? = nil) {
            self.streamingImage = streamingImage
        }

        private enum CodingKeys: String, CodingKey {
            case streamingImage
        }
    }

    public struct CreateStreamingSessionRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "clientToken", location: .header("X-Amz-Client-Token")),
            AWSMemberEncoding(label: "studioId", location: .uri("studioId"))
        ]

        /// Unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If you don’t specify a client token, the Amazon Web Services SDK automatically generates a client token and uses it for the request to ensure idempotency.
        public let clientToken: String?
        /// The EC2 Instance type used for the streaming session.
        public let ec2InstanceType: StreamingInstanceType?
        /// The ID of the launch profile used to control access from the streaming session.
        public let launchProfileId: String
        /// The user ID of the user that owns the streaming session. The user that owns the session will be logging into the session and interacting with the virtual workstation.
        public let ownedBy: String?
        /// The ID of the streaming image.
        public let streamingImageId: String?
        /// The studio ID.
        public let studioId: String
        /// A collection of labels, in the form of key-value pairs, that apply to this resource.
        public let tags: [String: String]?

        public init(clientToken: String? = CreateStreamingSessionRequest.idempotencyToken(), ec2InstanceType: StreamingInstanceType? = nil, launchProfileId: String, ownedBy: String? = nil, streamingImageId: String? = nil, studioId: String, tags: [String: String]? = nil) {
            self.clientToken = clientToken
            self.ec2InstanceType = ec2InstanceType
            self.launchProfileId = launchProfileId
            self.ownedBy = ownedBy
            self.streamingImageId = streamingImageId
            self.studioId = studioId
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 64)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.validate(self.streamingImageId, name: "streamingImageId", parent: name, max: 22)
            try self.validate(self.streamingImageId, name: "streamingImageId", parent: name, pattern: "^[a-zA-Z0-9-_]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case ec2InstanceType
            case launchProfileId
            case ownedBy
            case streamingImageId
            case tags
        }
    }

    public struct CreateStreamingSessionResponse: AWSDecodableShape {
        /// The session.
        public let session: StreamingSession?

        public init(session: StreamingSession? = nil) {
            self.session = session
        }

        private enum CodingKeys: String, CodingKey {
            case session
        }
    }

    public struct CreateStreamingSessionStreamRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "clientToken", location: .header("X-Amz-Client-Token")),
            AWSMemberEncoding(label: "sessionId", location: .uri("sessionId")),
            AWSMemberEncoding(label: "studioId", location: .uri("studioId"))
        ]

        /// Unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If you don’t specify a client token, the Amazon Web Services SDK automatically generates a client token and uses it for the request to ensure idempotency.
        public let clientToken: String?
        /// The expiration time in seconds.
        public let expirationInSeconds: Int?
        /// The streaming session ID.
        public let sessionId: String
        /// The studio ID.
        public let studioId: String

        public init(clientToken: String? = CreateStreamingSessionStreamRequest.idempotencyToken(), expirationInSeconds: Int? = nil, sessionId: String, studioId: String) {
            self.clientToken = clientToken
            self.expirationInSeconds = expirationInSeconds
            self.sessionId = sessionId
            self.studioId = studioId
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 64)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.validate(self.expirationInSeconds, name: "expirationInSeconds", parent: name, max: 3600)
            try self.validate(self.expirationInSeconds, name: "expirationInSeconds", parent: name, min: 60)
        }

        private enum CodingKeys: String, CodingKey {
            case expirationInSeconds
        }
    }

    public struct CreateStreamingSessionStreamResponse: AWSDecodableShape {
        /// The stream.
        public let stream: StreamingSessionStream?

        public init(stream: StreamingSessionStream? = nil) {
            self.stream = stream
        }

        private enum CodingKeys: String, CodingKey {
            case stream
        }
    }

    public struct CreateStudioComponentRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "clientToken", location: .header("X-Amz-Client-Token")),
            AWSMemberEncoding(label: "studioId", location: .uri("studioId"))
        ]

        /// Unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If you don’t specify a client token, the Amazon Web Services SDK automatically generates a client token and uses it for the request to ensure idempotency.
        public let clientToken: String?
        /// The configuration of the studio component, based on component type.
        public let configuration: StudioComponentConfiguration?
        /// The description.
        public let description: String?
        /// The EC2 security groups that control access to the studio component.
        public let ec2SecurityGroupIds: [String]?
        /// Initialization scripts for studio components.
        public let initializationScripts: [StudioComponentInitializationScript]?
        /// The name for the studio component.
        public let name: String
        /// An IAM role attached to a Studio Component that gives the studio component access to Amazon Web Services resources at anytime while the instance is running.
        public let runtimeRoleArn: String?
        /// Parameters for the studio component scripts.
        public let scriptParameters: [ScriptParameterKeyValue]?
        /// An IAM role attached to Studio Component when the system initialization script runs which give the studio component access to Amazon Web Services resources when the system initialization script runs.
        public let secureInitializationRoleArn: String?
        /// The studio ID.
        public let studioId: String
        /// The specific subtype of a studio component.
        public let subtype: StudioComponentSubtype?
        /// A collection of labels, in the form of key-value pairs, that apply to this resource.
        public let tags: [String: String]?
        /// The type of the studio component.
        public let type: StudioComponentType

        public init(clientToken: String? = CreateStudioComponentRequest.idempotencyToken(), configuration: StudioComponentConfiguration? = nil, description: String? = nil, ec2SecurityGroupIds: [String]? = nil, initializationScripts: [StudioComponentInitializationScript]? = nil, name: String, runtimeRoleArn: String? = nil, scriptParameters: [ScriptParameterKeyValue]? = nil, secureInitializationRoleArn: String? = nil, studioId: String, subtype: StudioComponentSubtype? = nil, tags: [String: String]? = nil, type: StudioComponentType) {
            self.clientToken = clientToken
            self.configuration = configuration
            self.description = description
            self.ec2SecurityGroupIds = ec2SecurityGroupIds
            self.initializationScripts = initializationScripts
            self.name = name
            self.runtimeRoleArn = runtimeRoleArn
            self.scriptParameters = scriptParameters
            self.secureInitializationRoleArn = secureInitializationRoleArn
            self.studioId = studioId
            self.subtype = subtype
            self.tags = tags
            self.type = type
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 64)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.configuration?.validate(name: "\(name).configuration")
            try self.validate(self.description, name: "description", parent: name, max: 256)
            try self.validate(self.ec2SecurityGroupIds, name: "ec2SecurityGroupIds", parent: name, max: 30)
            try self.initializationScripts?.forEach {
                try $0.validate(name: "\(name).initializationScripts[]")
            }
            try self.validate(self.name, name: "name", parent: name, max: 64)
            try self.validate(self.runtimeRoleArn, name: "runtimeRoleArn", parent: name, max: 2048)
            try self.scriptParameters?.forEach {
                try $0.validate(name: "\(name).scriptParameters[]")
            }
            try self.validate(self.scriptParameters, name: "scriptParameters", parent: name, max: 30)
            try self.validate(self.secureInitializationRoleArn, name: "secureInitializationRoleArn", parent: name, max: 2048)
        }

        private enum CodingKeys: String, CodingKey {
            case configuration
            case description
            case ec2SecurityGroupIds
            case initializationScripts
            case name
            case runtimeRoleArn
            case scriptParameters
            case secureInitializationRoleArn
            case subtype
            case tags
            case type
        }
    }

    public struct CreateStudioComponentResponse: AWSDecodableShape {
        /// Information about the studio component.
        public let studioComponent: StudioComponent?

        public init(studioComponent: StudioComponent? = nil) {
            self.studioComponent = studioComponent
        }

        private enum CodingKeys: String, CodingKey {
            case studioComponent
        }
    }

    public struct CreateStudioRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "clientToken", location: .header("X-Amz-Client-Token"))
        ]

        /// The IAM role that studio admins will assume when logging in to the Nimble Studio portal.
        public let adminRoleArn: String
        /// Unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If you don’t specify a client token, the Amazon Web Services SDK automatically generates a client token and uses it for the request to ensure idempotency.
        public let clientToken: String?
        /// A friendly name for the studio.
        public let displayName: String
        /// The studio encryption configuration.
        public let studioEncryptionConfiguration: StudioEncryptionConfiguration?
        /// The studio name that is used in the URL of the Nimble Studio portal when accessed by Nimble Studio users.
        public let studioName: String
        /// A collection of labels, in the form of key-value pairs, that apply to this resource.
        public let tags: [String: String]?
        /// The IAM role that studio users will assume when logging in to the Nimble Studio portal.
        public let userRoleArn: String

        public init(adminRoleArn: String, clientToken: String? = CreateStudioRequest.idempotencyToken(), displayName: String, studioEncryptionConfiguration: StudioEncryptionConfiguration? = nil, studioName: String, tags: [String: String]? = nil, userRoleArn: String) {
            self.adminRoleArn = adminRoleArn
            self.clientToken = clientToken
            self.displayName = displayName
            self.studioEncryptionConfiguration = studioEncryptionConfiguration
            self.studioName = studioName
            self.tags = tags
            self.userRoleArn = userRoleArn
        }

        public func validate(name: String) throws {
            try self.validate(self.adminRoleArn, name: "adminRoleArn", parent: name, max: 2048)
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 64)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.validate(self.displayName, name: "displayName", parent: name, max: 64)
            try self.studioEncryptionConfiguration?.validate(name: "\(name).studioEncryptionConfiguration")
            try self.validate(self.studioName, name: "studioName", parent: name, max: 64)
            try self.validate(self.studioName, name: "studioName", parent: name, min: 3)
            try self.validate(self.studioName, name: "studioName", parent: name, pattern: "^[a-z0-9]*$")
            try self.validate(self.userRoleArn, name: "userRoleArn", parent: name, max: 2048)
        }

        private enum CodingKeys: String, CodingKey {
            case adminRoleArn
            case displayName
            case studioEncryptionConfiguration
            case studioName
            case tags
            case userRoleArn
        }
    }

    public struct CreateStudioResponse: AWSDecodableShape {
        /// Information about a studio.
        public let studio: Studio?

        public init(studio: Studio? = nil) {
            self.studio = studio
        }

        private enum CodingKeys: String, CodingKey {
            case studio
        }
    }

    public struct DeleteLaunchProfileMemberRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "clientToken", location: .header("X-Amz-Client-Token")),
            AWSMemberEncoding(label: "launchProfileId", location: .uri("launchProfileId")),
            AWSMemberEncoding(label: "principalId", location: .uri("principalId")),
            AWSMemberEncoding(label: "studioId", location: .uri("studioId"))
        ]

        /// Unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If you don’t specify a client token, the Amazon Web Services SDK automatically generates a client token and uses it for the request to ensure idempotency.
        public let clientToken: String?
        /// The ID of the launch profile used to control access from the streaming session.
        public let launchProfileId: String
        /// The principal ID. This currently supports a IAM Identity Center UserId.
        public let principalId: String
        /// The studio ID.
        public let studioId: String

        public init(clientToken: String? = DeleteLaunchProfileMemberRequest.idempotencyToken(), launchProfileId: String, principalId: String, studioId: String) {
            self.clientToken = clientToken
            self.launchProfileId = launchProfileId
            self.principalId = principalId
            self.studioId = studioId
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 64)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteLaunchProfileMemberResponse: AWSDecodableShape {
        public init() {}
    }

    public struct DeleteLaunchProfileRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "clientToken", location: .header("X-Amz-Client-Token")),
            AWSMemberEncoding(label: "launchProfileId", location: .uri("launchProfileId")),
            AWSMemberEncoding(label: "studioId", location: .uri("studioId"))
        ]

        /// Unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If you don’t specify a client token, the Amazon Web Services SDK automatically generates a client token and uses it for the request to ensure idempotency.
        public let clientToken: String?
        /// The ID of the launch profile used to control access from the streaming session.
        public let launchProfileId: String
        /// The studio ID.
        public let studioId: String

        public init(clientToken: String? = DeleteLaunchProfileRequest.idempotencyToken(), launchProfileId: String, studioId: String) {
            self.clientToken = clientToken
            self.launchProfileId = launchProfileId
            self.studioId = studioId
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 64)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteLaunchProfileResponse: AWSDecodableShape {
        /// The launch profile.
        public let launchProfile: LaunchProfile?

        public init(launchProfile: LaunchProfile? = nil) {
            self.launchProfile = launchProfile
        }

        private enum CodingKeys: String, CodingKey {
            case launchProfile
        }
    }

    public struct DeleteStreamingImageRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "clientToken", location: .header("X-Amz-Client-Token")),
            AWSMemberEncoding(label: "streamingImageId", location: .uri("streamingImageId")),
            AWSMemberEncoding(label: "studioId", location: .uri("studioId"))
        ]

        /// Unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If you don’t specify a client token, the Amazon Web Services SDK automatically generates a client token and uses it for the request to ensure idempotency.
        public let clientToken: String?
        /// The streaming image ID.
        public let streamingImageId: String
        /// The studio ID.
        public let studioId: String

        public init(clientToken: String? = DeleteStreamingImageRequest.idempotencyToken(), streamingImageId: String, studioId: String) {
            self.clientToken = clientToken
            self.streamingImageId = streamingImageId
            self.studioId = studioId
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 64)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteStreamingImageResponse: AWSDecodableShape {
        /// The streaming image.
        public let streamingImage: StreamingImage?

        public init(streamingImage: StreamingImage? = nil) {
            self.streamingImage = streamingImage
        }

        private enum CodingKeys: String, CodingKey {
            case streamingImage
        }
    }

    public struct DeleteStreamingSessionRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "clientToken", location: .header("X-Amz-Client-Token")),
            AWSMemberEncoding(label: "sessionId", location: .uri("sessionId")),
            AWSMemberEncoding(label: "studioId", location: .uri("studioId"))
        ]

        /// Unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If you don’t specify a client token, the Amazon Web Services SDK automatically generates a client token and uses it for the request to ensure idempotency.
        public let clientToken: String?
        /// The streaming session ID.
        public let sessionId: String
        /// The studio ID.
        public let studioId: String

        public init(clientToken: String? = DeleteStreamingSessionRequest.idempotencyToken(), sessionId: String, studioId: String) {
            self.clientToken = clientToken
            self.sessionId = sessionId
            self.studioId = studioId
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 64)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteStreamingSessionResponse: AWSDecodableShape {
        /// The session.
        public let session: StreamingSession?

        public init(session: StreamingSession? = nil) {
            self.session = session
        }

        private enum CodingKeys: String, CodingKey {
            case session
        }
    }

    public struct DeleteStudioComponentRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "clientToken", location: .header("X-Amz-Client-Token")),
            AWSMemberEncoding(label: "studioComponentId", location: .uri("studioComponentId")),
            AWSMemberEncoding(label: "studioId", location: .uri("studioId"))
        ]

        /// Unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If you don’t specify a client token, the Amazon Web Services SDK automatically generates a client token and uses it for the request to ensure idempotency.
        public let clientToken: String?
        /// The studio component ID.
        public let studioComponentId: String
        /// The studio ID.
        public let studioId: String

        public init(clientToken: String? = DeleteStudioComponentRequest.idempotencyToken(), studioComponentId: String, studioId: String) {
            self.clientToken = clientToken
            self.studioComponentId = studioComponentId
            self.studioId = studioId
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 64)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteStudioComponentResponse: AWSDecodableShape {
        /// Information about the studio component.
        public let studioComponent: StudioComponent?

        public init(studioComponent: StudioComponent? = nil) {
            self.studioComponent = studioComponent
        }

        private enum CodingKeys: String, CodingKey {
            case studioComponent
        }
    }

    public struct DeleteStudioMemberRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "clientToken", location: .header("X-Amz-Client-Token")),
            AWSMemberEncoding(label: "principalId", location: .uri("principalId")),
            AWSMemberEncoding(label: "studioId", location: .uri("studioId"))
        ]

        /// Unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If you don’t specify a client token, the Amazon Web Services SDK automatically generates a client token and uses it for the request to ensure idempotency.
        public let clientToken: String?
        /// The principal ID. This currently supports a IAM Identity Center UserId.
        public let principalId: String
        /// The studio ID.
        public let studioId: String

        public init(clientToken: String? = DeleteStudioMemberRequest.idempotencyToken(), principalId: String, studioId: String) {
            self.clientToken = clientToken
            self.principalId = principalId
            self.studioId = studioId
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 64)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteStudioMemberResponse: AWSDecodableShape {
        public init() {}
    }

    public struct DeleteStudioRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "clientToken", location: .header("X-Amz-Client-Token")),
            AWSMemberEncoding(label: "studioId", location: .uri("studioId"))
        ]

        /// Unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If you don’t specify a client token, the Amazon Web Services SDK automatically generates a client token and uses it for the request to ensure idempotency.
        public let clientToken: String?
        /// The studio ID.
        public let studioId: String

        public init(clientToken: String? = DeleteStudioRequest.idempotencyToken(), studioId: String) {
            self.clientToken = clientToken
            self.studioId = studioId
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 64)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteStudioResponse: AWSDecodableShape {
        /// Information about a studio.
        public let studio: Studio

        public init(studio: Studio) {
            self.studio = studio
        }

        private enum CodingKeys: String, CodingKey {
            case studio
        }
    }

    public struct Eula: AWSDecodableShape {
        /// The EULA content.
        public let content: String?
        /// The ISO timestamp in seconds for when the resource was created.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var createdAt: Date?
        /// The EULA ID.
        public let eulaId: String?
        /// The name for the EULA.
        public let name: String?
        /// The ISO timestamp in seconds for when the resource was updated.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var updatedAt: Date?

        public init(content: String? = nil, createdAt: Date? = nil, eulaId: String? = nil, name: String? = nil, updatedAt: Date? = nil) {
            self.content = content
            self.createdAt = createdAt
            self.eulaId = eulaId
            self.name = name
            self.updatedAt = updatedAt
        }

        private enum CodingKeys: String, CodingKey {
            case content
            case createdAt
            case eulaId
            case name
            case updatedAt
        }
    }

    public struct EulaAcceptance: AWSDecodableShape {
        /// The ISO timestamp in seconds for when the EULA was accepted.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var acceptedAt: Date?
        /// The ID of the person who accepted the EULA.
        public let acceptedBy: String?
        /// The ID of the acceptee.
        public let accepteeId: String?
        /// The EULA acceptance ID.
        public let eulaAcceptanceId: String?
        /// The EULA ID.
        public let eulaId: String?

        public init(acceptedAt: Date? = nil, acceptedBy: String? = nil, accepteeId: String? = nil, eulaAcceptanceId: String? = nil, eulaId: String? = nil) {
            self.acceptedAt = acceptedAt
            self.acceptedBy = acceptedBy
            self.accepteeId = accepteeId
            self.eulaAcceptanceId = eulaAcceptanceId
            self.eulaId = eulaId
        }

        private enum CodingKeys: String, CodingKey {
            case acceptedAt
            case acceptedBy
            case accepteeId
            case eulaAcceptanceId
            case eulaId
        }
    }

    public struct GetEulaRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "eulaId", location: .uri("eulaId"))
        ]

        /// The EULA ID.
        public let eulaId: String

        public init(eulaId: String) {
            self.eulaId = eulaId
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetEulaResponse: AWSDecodableShape {
        /// The EULA.
        public let eula: Eula?

        public init(eula: Eula? = nil) {
            self.eula = eula
        }

        private enum CodingKeys: String, CodingKey {
            case eula
        }
    }

    public struct GetLaunchProfileDetailsRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "launchProfileId", location: .uri("launchProfileId")),
            AWSMemberEncoding(label: "studioId", location: .uri("studioId"))
        ]

        /// The ID of the launch profile used to control access from the streaming session.
        public let launchProfileId: String
        /// The studio ID.
        public let studioId: String

        public init(launchProfileId: String, studioId: String) {
            self.launchProfileId = launchProfileId
            self.studioId = studioId
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetLaunchProfileDetailsResponse: AWSDecodableShape {
        /// The launch profile.
        public let launchProfile: LaunchProfile?
        /// A collection of streaming images.
        public let streamingImages: [StreamingImage]?
        /// A collection of studio component summaries.
        public let studioComponentSummaries: [StudioComponentSummary]?

        public init(launchProfile: LaunchProfile? = nil, streamingImages: [StreamingImage]? = nil, studioComponentSummaries: [StudioComponentSummary]? = nil) {
            self.launchProfile = launchProfile
            self.streamingImages = streamingImages
            self.studioComponentSummaries = studioComponentSummaries
        }

        private enum CodingKeys: String, CodingKey {
            case launchProfile
            case streamingImages
            case studioComponentSummaries
        }
    }

    public struct GetLaunchProfileInitializationRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "launchProfileId", location: .uri("launchProfileId")),
            AWSMemberEncoding(label: "launchProfileProtocolVersions", location: .querystring("launchProfileProtocolVersions")),
            AWSMemberEncoding(label: "launchPurpose", location: .querystring("launchPurpose")),
            AWSMemberEncoding(label: "platform", location: .querystring("platform")),
            AWSMemberEncoding(label: "studioId", location: .uri("studioId"))
        ]

        /// The ID of the launch profile used to control access from the streaming session.
        public let launchProfileId: String
        /// The launch profile protocol versions supported by the client.
        public let launchProfileProtocolVersions: [String]
        /// The launch purpose.
        public let launchPurpose: String
        /// The platform where this Launch Profile will be used, either Windows or Linux.
        public let platform: String
        /// The studio ID.
        public let studioId: String

        public init(launchProfileId: String, launchProfileProtocolVersions: [String], launchPurpose: String, platform: String, studioId: String) {
            self.launchProfileId = launchProfileId
            self.launchProfileProtocolVersions = launchProfileProtocolVersions
            self.launchPurpose = launchPurpose
            self.platform = platform
            self.studioId = studioId
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetLaunchProfileInitializationResponse: AWSDecodableShape {
        /// The launch profile initialization.
        public let launchProfileInitialization: LaunchProfileInitialization?

        public init(launchProfileInitialization: LaunchProfileInitialization? = nil) {
            self.launchProfileInitialization = launchProfileInitialization
        }

        private enum CodingKeys: String, CodingKey {
            case launchProfileInitialization
        }
    }

    public struct GetLaunchProfileMemberRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "launchProfileId", location: .uri("launchProfileId")),
            AWSMemberEncoding(label: "principalId", location: .uri("principalId")),
            AWSMemberEncoding(label: "studioId", location: .uri("studioId"))
        ]

        /// The ID of the launch profile used to control access from the streaming session.
        public let launchProfileId: String
        /// The principal ID. This currently supports a IAM Identity Center UserId.
        public let principalId: String
        /// The studio ID.
        public let studioId: String

        public init(launchProfileId: String, principalId: String, studioId: String) {
            self.launchProfileId = launchProfileId
            self.principalId = principalId
            self.studioId = studioId
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetLaunchProfileMemberResponse: AWSDecodableShape {
        /// The member.
        public let member: LaunchProfileMembership?

        public init(member: LaunchProfileMembership? = nil) {
            self.member = member
        }

        private enum CodingKeys: String, CodingKey {
            case member
        }
    }

    public struct GetLaunchProfileRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "launchProfileId", location: .uri("launchProfileId")),
            AWSMemberEncoding(label: "studioId", location: .uri("studioId"))
        ]

        /// The ID of the launch profile used to control access from the streaming session.
        public let launchProfileId: String
        /// The studio ID.
        public let studioId: String

        public init(launchProfileId: String, studioId: String) {
            self.launchProfileId = launchProfileId
            self.studioId = studioId
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetLaunchProfileResponse: AWSDecodableShape {
        /// The launch profile.
        public let launchProfile: LaunchProfile?

        public init(launchProfile: LaunchProfile? = nil) {
            self.launchProfile = launchProfile
        }

        private enum CodingKeys: String, CodingKey {
            case launchProfile
        }
    }

    public struct GetStreamingImageRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "streamingImageId", location: .uri("streamingImageId")),
            AWSMemberEncoding(label: "studioId", location: .uri("studioId"))
        ]

        /// The streaming image ID.
        public let streamingImageId: String
        /// The studio ID.
        public let studioId: String

        public init(streamingImageId: String, studioId: String) {
            self.streamingImageId = streamingImageId
            self.studioId = studioId
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetStreamingImageResponse: AWSDecodableShape {
        /// The streaming image.
        public let streamingImage: StreamingImage?

        public init(streamingImage: StreamingImage? = nil) {
            self.streamingImage = streamingImage
        }

        private enum CodingKeys: String, CodingKey {
            case streamingImage
        }
    }

    public struct GetStreamingSessionBackupRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "backupId", location: .uri("backupId")),
            AWSMemberEncoding(label: "studioId", location: .uri("studioId"))
        ]

        /// The ID of the backup.
        public let backupId: String
        /// The studio ID.
        public let studioId: String

        public init(backupId: String, studioId: String) {
            self.backupId = backupId
            self.studioId = studioId
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetStreamingSessionBackupResponse: AWSDecodableShape {
        /// Information about the streaming session backup.
        public let streamingSessionBackup: StreamingSessionBackup?

        public init(streamingSessionBackup: StreamingSessionBackup? = nil) {
            self.streamingSessionBackup = streamingSessionBackup
        }

        private enum CodingKeys: String, CodingKey {
            case streamingSessionBackup
        }
    }

    public struct GetStreamingSessionRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "sessionId", location: .uri("sessionId")),
            AWSMemberEncoding(label: "studioId", location: .uri("studioId"))
        ]

        /// The streaming session ID.
        public let sessionId: String
        /// The studio ID.
        public let studioId: String

        public init(sessionId: String, studioId: String) {
            self.sessionId = sessionId
            self.studioId = studioId
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetStreamingSessionResponse: AWSDecodableShape {
        /// The session.
        public let session: StreamingSession?

        public init(session: StreamingSession? = nil) {
            self.session = session
        }

        private enum CodingKeys: String, CodingKey {
            case session
        }
    }

    public struct GetStreamingSessionStreamRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "sessionId", location: .uri("sessionId")),
            AWSMemberEncoding(label: "streamId", location: .uri("streamId")),
            AWSMemberEncoding(label: "studioId", location: .uri("studioId"))
        ]

        /// The streaming session ID.
        public let sessionId: String
        /// The streaming session stream ID.
        public let streamId: String
        /// The studio ID.
        public let studioId: String

        public init(sessionId: String, streamId: String, studioId: String) {
            self.sessionId = sessionId
            self.streamId = streamId
            self.studioId = studioId
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetStreamingSessionStreamResponse: AWSDecodableShape {
        /// The stream.
        public let stream: StreamingSessionStream?

        public init(stream: StreamingSessionStream? = nil) {
            self.stream = stream
        }

        private enum CodingKeys: String, CodingKey {
            case stream
        }
    }

    public struct GetStudioComponentRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "studioComponentId", location: .uri("studioComponentId")),
            AWSMemberEncoding(label: "studioId", location: .uri("studioId"))
        ]

        /// The studio component ID.
        public let studioComponentId: String
        /// The studio ID.
        public let studioId: String

        public init(studioComponentId: String, studioId: String) {
            self.studioComponentId = studioComponentId
            self.studioId = studioId
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetStudioComponentResponse: AWSDecodableShape {
        /// Information about the studio component.
        public let studioComponent: StudioComponent?

        public init(studioComponent: StudioComponent? = nil) {
            self.studioComponent = studioComponent
        }

        private enum CodingKeys: String, CodingKey {
            case studioComponent
        }
    }

    public struct GetStudioMemberRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "principalId", location: .uri("principalId")),
            AWSMemberEncoding(label: "studioId", location: .uri("studioId"))
        ]

        /// The principal ID. This currently supports a IAM Identity Center UserId.
        public let principalId: String
        /// The studio ID.
        public let studioId: String

        public init(principalId: String, studioId: String) {
            self.principalId = principalId
            self.studioId = studioId
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetStudioMemberResponse: AWSDecodableShape {
        /// The member.
        public let member: StudioMembership?

        public init(member: StudioMembership? = nil) {
            self.member = member
        }

        private enum CodingKeys: String, CodingKey {
            case member
        }
    }

    public struct GetStudioRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "studioId", location: .uri("studioId"))
        ]

        /// The studio ID.
        public let studioId: String

        public init(studioId: String) {
            self.studioId = studioId
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetStudioResponse: AWSDecodableShape {
        /// Information about a studio.
        public let studio: Studio

        public init(studio: Studio) {
            self.studio = studio
        }

        private enum CodingKeys: String, CodingKey {
            case studio
        }
    }

    public struct LaunchProfile: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) that is assigned to a studio resource and uniquely identifies it. ARNs are unique across all Regions.
        public let arn: String?
        /// The ISO timestamp in seconds for when the resource was created.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var createdAt: Date?
        /// The user ID of the user that created the launch profile.
        public let createdBy: String?
        /// A human-readable description of the launch profile.
        public let description: String?
        /// Unique identifiers for a collection of EC2 subnets.
        public let ec2SubnetIds: [String]?
        /// The ID of the launch profile used to control access from the streaming session.
        public let launchProfileId: String?
        /// The version number of the protocol that is used by the launch profile. The only valid version is "2021-03-31".
        public let launchProfileProtocolVersions: [String]?
        /// A friendly name for the launch profile.
        public let name: String?
        /// The current state.
        public let state: LaunchProfileState?
        /// The status code.
        public let statusCode: LaunchProfileStatusCode?
        /// The status message for the launch profile.
        public let statusMessage: String?
        /// A configuration for a streaming session.
        public let streamConfiguration: StreamConfiguration?
        /// Unique identifiers for a collection of studio components that can be used with this launch profile.
        public let studioComponentIds: [String]?
        /// A collection of labels, in the form of key-value pairs, that apply to this resource.
        public let tags: [String: String]?
        /// The ISO timestamp in seconds for when the resource was updated.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var updatedAt: Date?
        /// The user ID of the user that most recently updated the resource.
        public let updatedBy: String?
        /// The list of the latest validation results.
        public let validationResults: [ValidationResult]?

        public init(arn: String? = nil, createdAt: Date? = nil, createdBy: String? = nil, description: String? = nil, ec2SubnetIds: [String]? = nil, launchProfileId: String? = nil, launchProfileProtocolVersions: [String]? = nil, name: String? = nil, state: LaunchProfileState? = nil, statusCode: LaunchProfileStatusCode? = nil, statusMessage: String? = nil, streamConfiguration: StreamConfiguration? = nil, studioComponentIds: [String]? = nil, tags: [String: String]? = nil, updatedAt: Date? = nil, updatedBy: String? = nil, validationResults: [ValidationResult]? = nil) {
            self.arn = arn
            self.createdAt = createdAt
            self.createdBy = createdBy
            self.description = description
            self.ec2SubnetIds = ec2SubnetIds
            self.launchProfileId = launchProfileId
            self.launchProfileProtocolVersions = launchProfileProtocolVersions
            self.name = name
            self.state = state
            self.statusCode = statusCode
            self.statusMessage = statusMessage
            self.streamConfiguration = streamConfiguration
            self.studioComponentIds = studioComponentIds
            self.tags = tags
            self.updatedAt = updatedAt
            self.updatedBy = updatedBy
            self.validationResults = validationResults
        }

        private enum CodingKeys: String, CodingKey {
            case arn
            case createdAt
            case createdBy
            case description
            case ec2SubnetIds
            case launchProfileId
            case launchProfileProtocolVersions
            case name
            case state
            case statusCode
            case statusMessage
            case streamConfiguration
            case studioComponentIds
            case tags
            case updatedAt
            case updatedBy
            case validationResults
        }
    }

    public struct LaunchProfileInitialization: AWSDecodableShape {
        /// A LaunchProfileInitializationActiveDirectory resource.
        public let activeDirectory: LaunchProfileInitializationActiveDirectory?
        /// The EC2 security groups that control access to the studio component.
        public let ec2SecurityGroupIds: [String]?
        /// The ID of the launch profile used to control access from the streaming session.
        public let launchProfileId: String?
        /// The version number of the protocol that is used by the launch profile. The only valid version is "2021-03-31".
        public let launchProfileProtocolVersion: String?
        /// The launch purpose.
        public let launchPurpose: String?
        /// The name for the launch profile.
        public let name: String?
        /// The platform of the launch platform, either Windows or Linux.
        public let platform: LaunchProfilePlatform?
        /// The system initializtion scripts.
        public let systemInitializationScripts: [LaunchProfileInitializationScript]?
        /// The user initializtion scripts.
        public let userInitializationScripts: [LaunchProfileInitializationScript]?

        public init(activeDirectory: LaunchProfileInitializationActiveDirectory? = nil, ec2SecurityGroupIds: [String]? = nil, launchProfileId: String? = nil, launchProfileProtocolVersion: String? = nil, launchPurpose: String? = nil, name: String? = nil, platform: LaunchProfilePlatform? = nil, systemInitializationScripts: [LaunchProfileInitializationScript]? = nil, userInitializationScripts: [LaunchProfileInitializationScript]? = nil) {
            self.activeDirectory = activeDirectory
            self.ec2SecurityGroupIds = ec2SecurityGroupIds
            self.launchProfileId = launchProfileId
            self.launchProfileProtocolVersion = launchProfileProtocolVersion
            self.launchPurpose = launchPurpose
            self.name = name
            self.platform = platform
            self.systemInitializationScripts = systemInitializationScripts
            self.userInitializationScripts = userInitializationScripts
        }

        private enum CodingKeys: String, CodingKey {
            case activeDirectory
            case ec2SecurityGroupIds
            case launchProfileId
            case launchProfileProtocolVersion
            case launchPurpose
            case name
            case platform
            case systemInitializationScripts
            case userInitializationScripts
        }
    }

    public struct LaunchProfileInitializationActiveDirectory: AWSDecodableShape {
        /// A collection of custom attributes for an Active Directory computer.
        public let computerAttributes: [ActiveDirectoryComputerAttribute]?
        /// The directory ID of the Directory Service for Microsoft Active Directory to access using this launch profile.
        public let directoryId: String?
        /// The directory name.
        public let directoryName: String?
        /// The DNS IP address.
        public let dnsIpAddresses: [String]?
        /// The name for the organizational unit distinguished name.
        public let organizationalUnitDistinguishedName: String?
        /// The unique identifier for a studio component resource.
        public let studioComponentId: String?
        /// The name for the studio component.
        public let studioComponentName: String?

        public init(computerAttributes: [ActiveDirectoryComputerAttribute]? = nil, directoryId: String? = nil, directoryName: String? = nil, dnsIpAddresses: [String]? = nil, organizationalUnitDistinguishedName: String? = nil, studioComponentId: String? = nil, studioComponentName: String? = nil) {
            self.computerAttributes = computerAttributes
            self.directoryId = directoryId
            self.directoryName = directoryName
            self.dnsIpAddresses = dnsIpAddresses
            self.organizationalUnitDistinguishedName = organizationalUnitDistinguishedName
            self.studioComponentId = studioComponentId
            self.studioComponentName = studioComponentName
        }

        private enum CodingKeys: String, CodingKey {
            case computerAttributes
            case directoryId
            case directoryName
            case dnsIpAddresses
            case organizationalUnitDistinguishedName
            case studioComponentId
            case studioComponentName
        }
    }

    public struct LaunchProfileInitializationScript: AWSDecodableShape {
        /// An IAM role attached to a Studio Component that gives the studio component access to Amazon Web Services resources at anytime while the instance is running.
        public let runtimeRoleArn: String?
        /// The initialization script.
        public let script: String?
        /// An IAM role attached to Studio Component when the system initialization script runs which give the studio component access to Amazon Web Services resources when the system initialization script runs.
        public let secureInitializationRoleArn: String?
        /// The unique identifier for a studio component resource.
        public let studioComponentId: String?
        /// The name for the studio component.
        public let studioComponentName: String?

        public init(runtimeRoleArn: String? = nil, script: String? = nil, secureInitializationRoleArn: String? = nil, studioComponentId: String? = nil, studioComponentName: String? = nil) {
            self.runtimeRoleArn = runtimeRoleArn
            self.script = script
            self.secureInitializationRoleArn = secureInitializationRoleArn
            self.studioComponentId = studioComponentId
            self.studioComponentName = studioComponentName
        }

        private enum CodingKeys: String, CodingKey {
            case runtimeRoleArn
            case script
            case secureInitializationRoleArn
            case studioComponentId
            case studioComponentName
        }
    }

    public struct LaunchProfileMembership: AWSDecodableShape {
        /// The ID of the identity store.
        public let identityStoreId: String?
        /// The persona.
        public let persona: LaunchProfilePersona?
        /// The principal ID.
        public let principalId: String?
        /// The Active Directory Security Identifier for this user, if available.
        public let sid: String?

        public init(identityStoreId: String? = nil, persona: LaunchProfilePersona? = nil, principalId: String? = nil, sid: String? = nil) {
            self.identityStoreId = identityStoreId
            self.persona = persona
            self.principalId = principalId
            self.sid = sid
        }

        private enum CodingKeys: String, CodingKey {
            case identityStoreId
            case persona
            case principalId
            case sid
        }
    }

    public struct LicenseServiceConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The endpoint of the license service that is accessed by the studio component resource.
        public let endpoint: String?

        public init(endpoint: String? = nil) {
            self.endpoint = endpoint
        }

        private enum CodingKeys: String, CodingKey {
            case endpoint
        }
    }

    public struct ListEulaAcceptancesRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "eulaIds", location: .querystring("eulaIds")),
            AWSMemberEncoding(label: "nextToken", location: .querystring("nextToken")),
            AWSMemberEncoding(label: "studioId", location: .uri("studioId"))
        ]

        /// The list of EULA IDs that have been previously accepted.
        public let eulaIds: [String]?
        /// The token for the next set of results, or null if there are no more results.
        public let nextToken: String?
        /// The studio ID.
        public let studioId: String

        public init(eulaIds: [String]? = nil, nextToken: String? = nil, studioId: String) {
            self.eulaIds = eulaIds
            self.nextToken = nextToken
            self.studioId = studioId
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListEulaAcceptancesResponse: AWSDecodableShape {
        /// A collection of EULA acceptances.
        public let eulaAcceptances: [EulaAcceptance]?
        /// The token for the next set of results, or null if there are no more results.
        public let nextToken: String?

        public init(eulaAcceptances: [EulaAcceptance]? = nil, nextToken: String? = nil) {
            self.eulaAcceptances = eulaAcceptances
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case eulaAcceptances
            case nextToken
        }
    }

    public struct ListEulasRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "eulaIds", location: .querystring("eulaIds")),
            AWSMemberEncoding(label: "nextToken", location: .querystring("nextToken"))
        ]

        /// The list of EULA IDs that should be returned
        public let eulaIds: [String]?
        /// The token for the next set of results, or null if there are no more results.
        public let nextToken: String?

        public init(eulaIds: [String]? = nil, nextToken: String? = nil) {
            self.eulaIds = eulaIds
            self.nextToken = nextToken
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListEulasResponse: AWSDecodableShape {
        /// A collection of EULA resources.
        public let eulas: [Eula]?
        /// The token for the next set of results, or null if there are no more results.
        public let nextToken: String?

        public init(eulas: [Eula]? = nil, nextToken: String? = nil) {
            self.eulas = eulas
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case eulas
            case nextToken
        }
    }

    public struct ListLaunchProfileMembersRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "launchProfileId", location: .uri("launchProfileId")),
            AWSMemberEncoding(label: "maxResults", location: .querystring("maxResults")),
            AWSMemberEncoding(label: "nextToken", location: .querystring("nextToken")),
            AWSMemberEncoding(label: "studioId", location: .uri("studioId"))
        ]

        /// The ID of the launch profile used to control access from the streaming session.
        public let launchProfileId: String
        /// The max number of results to return in the response.
        public let maxResults: Int?
        /// The token for the next set of results, or null if there are no more results.
        public let nextToken: String?
        /// The studio ID.
        public let studioId: String

        public init(launchProfileId: String, maxResults: Int? = nil, nextToken: String? = nil, studioId: String) {
            self.launchProfileId = launchProfileId
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.studioId = studioId
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListLaunchProfileMembersResponse: AWSDecodableShape {
        /// A list of members.
        public let members: [LaunchProfileMembership]?
        /// The token for the next set of results, or null if there are no more results.
        public let nextToken: String?

        public init(members: [LaunchProfileMembership]? = nil, nextToken: String? = nil) {
            self.members = members
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case members
            case nextToken
        }
    }

    public struct ListLaunchProfilesRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "maxResults", location: .querystring("maxResults")),
            AWSMemberEncoding(label: "nextToken", location: .querystring("nextToken")),
            AWSMemberEncoding(label: "principalId", location: .querystring("principalId")),
            AWSMemberEncoding(label: "states", location: .querystring("states")),
            AWSMemberEncoding(label: "studioId", location: .uri("studioId"))
        ]

        /// The max number of results to return in the response.
        public let maxResults: Int?
        /// The token for the next set of results, or null if there are no more results.
        public let nextToken: String?
        /// The principal ID. This currently supports a IAM Identity Center UserId.
        public let principalId: String?
        /// Filter this request to launch profiles in any of the given states.
        public let states: [LaunchProfileState]?
        /// The studio ID.
        public let studioId: String

        public init(maxResults: Int? = nil, nextToken: String? = nil, principalId: String? = nil, states: [LaunchProfileState]? = nil, studioId: String) {
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.principalId = principalId
            self.states = states
            self.studioId = studioId
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListLaunchProfilesResponse: AWSDecodableShape {
        /// A collection of launch profiles.
        public let launchProfiles: [LaunchProfile]?
        /// The token for the next set of results, or null if there are no more results.
        public let nextToken: String?

        public init(launchProfiles: [LaunchProfile]? = nil, nextToken: String? = nil) {
            self.launchProfiles = launchProfiles
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case launchProfiles
            case nextToken
        }
    }

    public struct ListStreamingImagesRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "nextToken", location: .querystring("nextToken")),
            AWSMemberEncoding(label: "owner", location: .querystring("owner")),
            AWSMemberEncoding(label: "studioId", location: .uri("studioId"))
        ]

        /// The token for the next set of results, or null if there are no more results.
        public let nextToken: String?
        /// Filter this request to streaming images with the given owner
        public let owner: String?
        /// The studio ID.
        public let studioId: String

        public init(nextToken: String? = nil, owner: String? = nil, studioId: String) {
            self.nextToken = nextToken
            self.owner = owner
            self.studioId = studioId
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListStreamingImagesResponse: AWSDecodableShape {
        /// The token for the next set of results, or null if there are no more results.
        public let nextToken: String?
        /// A collection of streaming images.
        public let streamingImages: [StreamingImage]?

        public init(nextToken: String? = nil, streamingImages: [StreamingImage]? = nil) {
            self.nextToken = nextToken
            self.streamingImages = streamingImages
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken
            case streamingImages
        }
    }

    public struct ListStreamingSessionBackupsRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "nextToken", location: .querystring("nextToken")),
            AWSMemberEncoding(label: "ownedBy", location: .querystring("ownedBy")),
            AWSMemberEncoding(label: "studioId", location: .uri("studioId"))
        ]

        /// The token for the next set of results, or null if there are no more results.
        public let nextToken: String?
        /// The user ID of the user that owns the streaming session.
        public let ownedBy: String?
        /// The studio ID.
        public let studioId: String

        public init(nextToken: String? = nil, ownedBy: String? = nil, studioId: String) {
            self.nextToken = nextToken
            self.ownedBy = ownedBy
            self.studioId = studioId
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListStreamingSessionBackupsResponse: AWSDecodableShape {
        /// The token for the next set of results, or null if there are no more results.
        public let nextToken: String?
        /// Information about the streaming session backups.
        public let streamingSessionBackups: [StreamingSessionBackup]?

        public init(nextToken: String? = nil, streamingSessionBackups: [StreamingSessionBackup]? = nil) {
            self.nextToken = nextToken
            self.streamingSessionBackups = streamingSessionBackups
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken
            case streamingSessionBackups
        }
    }

    public struct ListStreamingSessionsRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "createdBy", location: .querystring("createdBy")),
            AWSMemberEncoding(label: "nextToken", location: .querystring("nextToken")),
            AWSMemberEncoding(label: "ownedBy", location: .querystring("ownedBy")),
            AWSMemberEncoding(label: "sessionIds", location: .querystring("sessionIds")),
            AWSMemberEncoding(label: "studioId", location: .uri("studioId"))
        ]

        /// Filters the request to streaming sessions created by the given user.
        public let createdBy: String?
        /// The token for the next set of results, or null if there are no more results.
        public let nextToken: String?
        /// Filters the request to streaming session owned by the given user
        public let ownedBy: String?
        /// Filters the request to only the provided session IDs.
        public let sessionIds: String?
        /// The studio ID.
        public let studioId: String

        public init(createdBy: String? = nil, nextToken: String? = nil, ownedBy: String? = nil, sessionIds: String? = nil, studioId: String) {
            self.createdBy = createdBy
            self.nextToken = nextToken
            self.ownedBy = ownedBy
            self.sessionIds = sessionIds
            self.studioId = studioId
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListStreamingSessionsResponse: AWSDecodableShape {
        /// The token for the next set of results, or null if there are no more results.
        public let nextToken: String?
        /// A collection of streaming sessions.
        public let sessions: [StreamingSession]?

        public init(nextToken: String? = nil, sessions: [StreamingSession]? = nil) {
            self.nextToken = nextToken
            self.sessions = sessions
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken
            case sessions
        }
    }

    public struct ListStudioComponentsRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "maxResults", location: .querystring("maxResults")),
            AWSMemberEncoding(label: "nextToken", location: .querystring("nextToken")),
            AWSMemberEncoding(label: "states", location: .querystring("states")),
            AWSMemberEncoding(label: "studioId", location: .uri("studioId")),
            AWSMemberEncoding(label: "types", location: .querystring("types"))
        ]

        /// The max number of results to return in the response.
        public let maxResults: Int?
        /// The token for the next set of results, or null if there are no more results.
        public let nextToken: String?
        /// Filters the request to studio components that are in one of the given states.
        public let states: [StudioComponentState]?
        /// The studio ID.
        public let studioId: String
        /// Filters the request to studio components that are of one of the given types.
        public let types: [StudioComponentType]?

        public init(maxResults: Int? = nil, nextToken: String? = nil, states: [StudioComponentState]? = nil, studioId: String, types: [StudioComponentType]? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.states = states
            self.studioId = studioId
            self.types = types
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListStudioComponentsResponse: AWSDecodableShape {
        /// The token for the next set of results, or null if there are no more results.
        public let nextToken: String?
        /// A collection of studio components.
        public let studioComponents: [StudioComponent]?

        public init(nextToken: String? = nil, studioComponents: [StudioComponent]? = nil) {
            self.nextToken = nextToken
            self.studioComponents = studioComponents
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken
            case studioComponents
        }
    }

    public struct ListStudioMembersRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "maxResults", location: .querystring("maxResults")),
            AWSMemberEncoding(label: "nextToken", location: .querystring("nextToken")),
            AWSMemberEncoding(label: "studioId", location: .uri("studioId"))
        ]

        /// The max number of results to return in the response.
        public let maxResults: Int?
        /// The token for the next set of results, or null if there are no more results.
        public let nextToken: String?
        /// The studio ID.
        public let studioId: String

        public init(maxResults: Int? = nil, nextToken: String? = nil, studioId: String) {
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.studioId = studioId
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListStudioMembersResponse: AWSDecodableShape {
        /// A list of admin members.
        public let members: [StudioMembership]?
        /// The token for the next set of results, or null if there are no more results.
        public let nextToken: String?

        public init(members: [StudioMembership]? = nil, nextToken: String? = nil) {
            self.members = members
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case members
            case nextToken
        }
    }

    public struct ListStudiosRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "nextToken", location: .querystring("nextToken"))
        ]

        /// The token for the next set of results, or null if there are no more results.
        public let nextToken: String?

        public init(nextToken: String? = nil) {
            self.nextToken = nextToken
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListStudiosResponse: AWSDecodableShape {
        /// The token for the next set of results, or null if there are no more results.
        public let nextToken: String?
        /// A collection of studios.
        public let studios: [Studio]

        public init(nextToken: String? = nil, studios: [Studio]) {
            self.nextToken = nextToken
            self.studios = studios
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken
            case studios
        }
    }

    public struct ListTagsForResourceRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "resourceArn", location: .uri("resourceArn"))
        ]

        /// The Amazon Resource Name (ARN) of the resource for which you want to list tags.
        public let resourceArn: String

        public init(resourceArn: String) {
            self.resourceArn = resourceArn
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListTagsForResourceResponse: AWSDecodableShape {
        /// A collection of labels, in the form of key-value pairs, that apply to this resource.
        public let tags: [String: String]?

        public init(tags: [String: String]? = nil) {
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case tags
        }
    }

    public struct NewLaunchProfileMember: AWSEncodableShape {
        /// The persona.
        public let persona: LaunchProfilePersona
        /// The principal ID.
        public let principalId: String

        public init(persona: LaunchProfilePersona, principalId: String) {
            self.persona = persona
            self.principalId = principalId
        }

        private enum CodingKeys: String, CodingKey {
            case persona
            case principalId
        }
    }

    public struct NewStudioMember: AWSEncodableShape {
        /// The persona.
        public let persona: StudioPersona
        /// The principal ID.
        public let principalId: String

        public init(persona: StudioPersona, principalId: String) {
            self.persona = persona
            self.principalId = principalId
        }

        private enum CodingKeys: String, CodingKey {
            case persona
            case principalId
        }
    }

    public struct PutLaunchProfileMembersRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "clientToken", location: .header("X-Amz-Client-Token")),
            AWSMemberEncoding(label: "launchProfileId", location: .uri("launchProfileId")),
            AWSMemberEncoding(label: "studioId", location: .uri("studioId"))
        ]

        /// Unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If you don’t specify a client token, the Amazon Web Services SDK automatically generates a client token and uses it for the request to ensure idempotency.
        public let clientToken: String?
        /// The ID of the identity store.
        public let identityStoreId: String
        /// The ID of the launch profile used to control access from the streaming session.
        public let launchProfileId: String
        /// A list of members.
        public let members: [NewLaunchProfileMember]
        /// The studio ID.
        public let studioId: String

        public init(clientToken: String? = PutLaunchProfileMembersRequest.idempotencyToken(), identityStoreId: String, launchProfileId: String, members: [NewLaunchProfileMember], studioId: String) {
            self.clientToken = clientToken
            self.identityStoreId = identityStoreId
            self.launchProfileId = launchProfileId
            self.members = members
            self.studioId = studioId
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 64)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.validate(self.members, name: "members", parent: name, max: 20)
            try self.validate(self.members, name: "members", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case identityStoreId
            case members
        }
    }

    public struct PutLaunchProfileMembersResponse: AWSDecodableShape {
        public init() {}
    }

    public struct PutStudioMembersRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "clientToken", location: .header("X-Amz-Client-Token")),
            AWSMemberEncoding(label: "studioId", location: .uri("studioId"))
        ]

        /// Unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If you don’t specify a client token, the Amazon Web Services SDK automatically generates a client token and uses it for the request to ensure idempotency.
        public let clientToken: String?
        /// The ID of the identity store.
        public let identityStoreId: String
        /// A list of members.
        public let members: [NewStudioMember]
        /// The studio ID.
        public let studioId: String

        public init(clientToken: String? = PutStudioMembersRequest.idempotencyToken(), identityStoreId: String, members: [NewStudioMember], studioId: String) {
            self.clientToken = clientToken
            self.identityStoreId = identityStoreId
            self.members = members
            self.studioId = studioId
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 64)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.validate(self.members, name: "members", parent: name, max: 20)
            try self.validate(self.members, name: "members", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case identityStoreId
            case members
        }
    }

    public struct PutStudioMembersResponse: AWSDecodableShape {
        public init() {}
    }

    public struct ScriptParameterKeyValue: AWSEncodableShape & AWSDecodableShape {
        /// A script parameter key.
        public let key: String?
        /// A script parameter value.
        public let value: String?

        public init(key: String? = nil, value: String? = nil) {
            self.key = key
            self.value = value
        }

        public func validate(name: String) throws {
            try self.validate(self.key, name: "key", parent: name, max: 64)
            try self.validate(self.key, name: "key", parent: name, min: 1)
            try self.validate(self.key, name: "key", parent: name, pattern: "^[a-zA-Z_][a-zA-Z0-9_]+$")
            try self.validate(self.value, name: "value", parent: name, max: 256)
            try self.validate(self.value, name: "value", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case key
            case value
        }
    }

    public struct SharedFileSystemConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The endpoint of the shared file system that is accessed by the studio component resource.
        public let endpoint: String?
        /// The unique identifier for a file system.
        public let fileSystemId: String?
        /// The mount location for a shared file system on a Linux virtual workstation.
        public let linuxMountPoint: String?
        /// The name of the file share.
        public let shareName: String?
        /// The mount location for a shared file system on a Windows virtual workstation.
        public let windowsMountDrive: String?

        public init(endpoint: String? = nil, fileSystemId: String? = nil, linuxMountPoint: String? = nil, shareName: String? = nil, windowsMountDrive: String? = nil) {
            self.endpoint = endpoint
            self.fileSystemId = fileSystemId
            self.linuxMountPoint = linuxMountPoint
            self.shareName = shareName
            self.windowsMountDrive = windowsMountDrive
        }

        public func validate(name: String) throws {
            try self.validate(self.linuxMountPoint, name: "linuxMountPoint", parent: name, max: 128)
            try self.validate(self.linuxMountPoint, name: "linuxMountPoint", parent: name, pattern: "^(/?|(\\$HOME)?(/[^/\\n\\s\\\\]+)*)$")
            try self.validate(self.windowsMountDrive, name: "windowsMountDrive", parent: name, pattern: "^[A-Z]$")
        }

        private enum CodingKeys: String, CodingKey {
            case endpoint
            case fileSystemId
            case linuxMountPoint
            case shareName
            case windowsMountDrive
        }
    }

    public struct StartStreamingSessionRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "clientToken", location: .header("X-Amz-Client-Token")),
            AWSMemberEncoding(label: "sessionId", location: .uri("sessionId")),
            AWSMemberEncoding(label: "studioId", location: .uri("studioId"))
        ]

        /// The ID of the backup.
        public let backupId: String?
        /// Unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If you don’t specify a client token, the Amazon Web Services SDK automatically generates a client token and uses it for the request to ensure idempotency.
        public let clientToken: String?
        /// The streaming session ID for the StartStreamingSessionRequest.
        public let sessionId: String
        /// The studio ID for the StartStreamingSessionRequest.
        public let studioId: String

        public init(backupId: String? = nil, clientToken: String? = StartStreamingSessionRequest.idempotencyToken(), sessionId: String, studioId: String) {
            self.backupId = backupId
            self.clientToken = clientToken
            self.sessionId = sessionId
            self.studioId = studioId
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 64)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case backupId
        }
    }

    public struct StartStreamingSessionResponse: AWSDecodableShape {
        public let session: StreamingSession?

        public init(session: StreamingSession? = nil) {
            self.session = session
        }

        private enum CodingKeys: String, CodingKey {
            case session
        }
    }

    public struct StartStudioSSOConfigurationRepairRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "clientToken", location: .header("X-Amz-Client-Token")),
            AWSMemberEncoding(label: "studioId", location: .uri("studioId"))
        ]

        /// Unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If you don’t specify a client token, the Amazon Web Services SDK automatically generates a client token and uses it for the request to ensure idempotency.
        public let clientToken: String?
        /// The studio ID.
        public let studioId: String

        public init(clientToken: String? = StartStudioSSOConfigurationRepairRequest.idempotencyToken(), studioId: String) {
            self.clientToken = clientToken
            self.studioId = studioId
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 64)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct StartStudioSSOConfigurationRepairResponse: AWSDecodableShape {
        /// Information about a studio.
        public let studio: Studio

        public init(studio: Studio) {
            self.studio = studio
        }

        private enum CodingKeys: String, CodingKey {
            case studio
        }
    }

    public struct StopStreamingSessionRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "clientToken", location: .header("X-Amz-Client-Token")),
            AWSMemberEncoding(label: "sessionId", location: .uri("sessionId")),
            AWSMemberEncoding(label: "studioId", location: .uri("studioId"))
        ]

        /// Unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If you don’t specify a client token, the Amazon Web Services SDK automatically generates a client token and uses it for the request to ensure idempotency.
        public let clientToken: String?
        /// The streaming session ID for the StopStreamingSessionRequest.
        public let sessionId: String
        /// The studioId for the StopStreamingSessionRequest.
        public let studioId: String
        /// Adds additional instructions to a streaming session stop action to either retain the EBS volumes or delete the EBS volumes.
        public let volumeRetentionMode: VolumeRetentionMode?

        public init(clientToken: String? = StopStreamingSessionRequest.idempotencyToken(), sessionId: String, studioId: String, volumeRetentionMode: VolumeRetentionMode? = nil) {
            self.clientToken = clientToken
            self.sessionId = sessionId
            self.studioId = studioId
            self.volumeRetentionMode = volumeRetentionMode
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 64)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case volumeRetentionMode
        }
    }

    public struct StopStreamingSessionResponse: AWSDecodableShape {
        public let session: StreamingSession?

        public init(session: StreamingSession? = nil) {
            self.session = session
        }

        private enum CodingKeys: String, CodingKey {
            case session
        }
    }

    public struct StreamConfiguration: AWSDecodableShape {
        /// Indicates if a streaming session created from this launch profile should be terminated automatically or retained without termination after being in a STOPPED state.   When ACTIVATED, the streaming session is scheduled for termination after being in the STOPPED state for the time specified in maxStoppedSessionLengthInMinutes.   When DEACTIVATED, the streaming session can remain in the STOPPED state indefinitely.   This parameter is only allowed when sessionPersistenceMode is ACTIVATED. When allowed, the default value for this parameter is DEACTIVATED.
        public let automaticTerminationMode: AutomaticTerminationMode?
        /// Allows or deactivates the use of the system clipboard to copy and paste between the streaming session and streaming client.
        public let clipboardMode: StreamingClipboardMode
        /// The EC2 instance types that users can select from when launching a streaming session with this launch profile.
        public let ec2InstanceTypes: [StreamingInstanceType]
        /// The length of time, in minutes, that a streaming session can be active before it is stopped or terminated. After this point, Nimble Studio automatically terminates or stops the session. The default length of time is 690 minutes, and the maximum length of time is 30 days.
        public let maxSessionLengthInMinutes: Int?
        /// Integer that determines if you can start and stop your sessions and how long a session can stay in the STOPPED state. The default value is 0. The maximum value is 5760. This field is allowed only when sessionPersistenceMode is ACTIVATED and automaticTerminationMode is ACTIVATED. If the value is set to 0, your sessions can’t be STOPPED. If you then call StopStreamingSession, the session fails. If the time that a session stays in the READY state exceeds the maxSessionLengthInMinutes value, the session will automatically be terminated (instead of STOPPED). If the value is set to a positive number, the session can be stopped. You can call StopStreamingSession to stop sessions in the READY state. If the time that a session stays in the READY state exceeds the maxSessionLengthInMinutes value, the session will automatically be stopped (instead of terminated).
        public let maxStoppedSessionLengthInMinutes: Int?
        /// Information about the streaming session backup.
        public let sessionBackup: StreamConfigurationSessionBackup?
        /// Determine if a streaming session created from this launch profile can configure persistent storage. This means that volumeConfiguration and automaticTerminationMode are configured.
        public let sessionPersistenceMode: SessionPersistenceMode?
        /// The upload storage for a streaming session.
        public let sessionStorage: StreamConfigurationSessionStorage?
        /// The streaming images that users can select from when launching a streaming session with this launch profile.
        public let streamingImageIds: [String]
        /// Custom volume configuration for the root volumes that are attached to streaming sessions. This parameter is only allowed when sessionPersistenceMode is ACTIVATED.
        public let volumeConfiguration: VolumeConfiguration?

        public init(automaticTerminationMode: AutomaticTerminationMode? = nil, clipboardMode: StreamingClipboardMode, ec2InstanceTypes: [StreamingInstanceType], maxSessionLengthInMinutes: Int? = nil, maxStoppedSessionLengthInMinutes: Int? = nil, sessionBackup: StreamConfigurationSessionBackup? = nil, sessionPersistenceMode: SessionPersistenceMode? = nil, sessionStorage: StreamConfigurationSessionStorage? = nil, streamingImageIds: [String], volumeConfiguration: VolumeConfiguration? = nil) {
            self.automaticTerminationMode = automaticTerminationMode
            self.clipboardMode = clipboardMode
            self.ec2InstanceTypes = ec2InstanceTypes
            self.maxSessionLengthInMinutes = maxSessionLengthInMinutes
            self.maxStoppedSessionLengthInMinutes = maxStoppedSessionLengthInMinutes
            self.sessionBackup = sessionBackup
            self.sessionPersistenceMode = sessionPersistenceMode
            self.sessionStorage = sessionStorage
            self.streamingImageIds = streamingImageIds
            self.volumeConfiguration = volumeConfiguration
        }

        private enum CodingKeys: String, CodingKey {
            case automaticTerminationMode
            case clipboardMode
            case ec2InstanceTypes
            case maxSessionLengthInMinutes
            case maxStoppedSessionLengthInMinutes
            case sessionBackup
            case sessionPersistenceMode
            case sessionStorage
            case streamingImageIds
            case volumeConfiguration
        }
    }

    public struct StreamConfigurationCreate: AWSEncodableShape {
        /// Indicates if a streaming session created from this launch profile should be terminated automatically or retained without termination after being in a STOPPED state.   When ACTIVATED, the streaming session is scheduled for termination after being in the STOPPED state for the time specified in maxStoppedSessionLengthInMinutes.   When DEACTIVATED, the streaming session can remain in the STOPPED state indefinitely.   This parameter is only allowed when sessionPersistenceMode is ACTIVATED. When allowed, the default value for this parameter is DEACTIVATED.
        public let automaticTerminationMode: AutomaticTerminationMode?
        /// Allows or deactivates the use of the system clipboard to copy and paste between the streaming session and streaming client.
        public let clipboardMode: StreamingClipboardMode
        /// The EC2 instance types that users can select from when launching a streaming session with this launch profile.
        public let ec2InstanceTypes: [StreamingInstanceType]
        /// The length of time, in minutes, that a streaming session can be active before it is stopped or terminated. After this point, Nimble Studio automatically terminates or stops the session. The default length of time is 690 minutes, and the maximum length of time is 30 days.
        public let maxSessionLengthInMinutes: Int?
        /// Integer that determines if you can start and stop your sessions and how long a session can stay in the STOPPED state. The default value is 0. The maximum value is 5760. This field is allowed only when sessionPersistenceMode is ACTIVATED and automaticTerminationMode is ACTIVATED. If the value is set to 0, your sessions can’t be STOPPED. If you then call StopStreamingSession, the session fails. If the time that a session stays in the READY state exceeds the maxSessionLengthInMinutes value, the session will automatically be terminated (instead of STOPPED). If the value is set to a positive number, the session can be stopped. You can call StopStreamingSession to stop sessions in the READY state. If the time that a session stays in the READY state exceeds the maxSessionLengthInMinutes value, the session will automatically be stopped (instead of terminated).
        public let maxStoppedSessionLengthInMinutes: Int?
        /// Configures how streaming sessions are backed up when launched from this launch profile.
        public let sessionBackup: StreamConfigurationSessionBackup?
        /// Determine if a streaming session created from this launch profile can configure persistent storage. This means that volumeConfiguration and automaticTerminationMode are configured.
        public let sessionPersistenceMode: SessionPersistenceMode?
        /// The upload storage for a streaming workstation that is created using this launch profile.
        public let sessionStorage: StreamConfigurationSessionStorage?
        /// The streaming images that users can select from when launching a streaming session with this launch profile.
        public let streamingImageIds: [String]
        /// Custom volume configuration for the root volumes that are attached to streaming sessions. This parameter is only allowed when sessionPersistenceMode is ACTIVATED.
        public let volumeConfiguration: VolumeConfiguration?

        public init(automaticTerminationMode: AutomaticTerminationMode? = nil, clipboardMode: StreamingClipboardMode, ec2InstanceTypes: [StreamingInstanceType], maxSessionLengthInMinutes: Int? = nil, maxStoppedSessionLengthInMinutes: Int? = nil, sessionBackup: StreamConfigurationSessionBackup? = nil, sessionPersistenceMode: SessionPersistenceMode? = nil, sessionStorage: StreamConfigurationSessionStorage? = nil, streamingImageIds: [String], volumeConfiguration: VolumeConfiguration? = nil) {
            self.automaticTerminationMode = automaticTerminationMode
            self.clipboardMode = clipboardMode
            self.ec2InstanceTypes = ec2InstanceTypes
            self.maxSessionLengthInMinutes = maxSessionLengthInMinutes
            self.maxStoppedSessionLengthInMinutes = maxStoppedSessionLengthInMinutes
            self.sessionBackup = sessionBackup
            self.sessionPersistenceMode = sessionPersistenceMode
            self.sessionStorage = sessionStorage
            self.streamingImageIds = streamingImageIds
            self.volumeConfiguration = volumeConfiguration
        }

        public func validate(name: String) throws {
            try self.validate(self.ec2InstanceTypes, name: "ec2InstanceTypes", parent: name, max: 30)
            try self.validate(self.ec2InstanceTypes, name: "ec2InstanceTypes", parent: name, min: 1)
            try self.validate(self.maxSessionLengthInMinutes, name: "maxSessionLengthInMinutes", parent: name, max: 43200)
            try self.validate(self.maxSessionLengthInMinutes, name: "maxSessionLengthInMinutes", parent: name, min: 1)
            try self.validate(self.maxStoppedSessionLengthInMinutes, name: "maxStoppedSessionLengthInMinutes", parent: name, max: 5760)
            try self.validate(self.maxStoppedSessionLengthInMinutes, name: "maxStoppedSessionLengthInMinutes", parent: name, min: 0)
            try self.sessionBackup?.validate(name: "\(name).sessionBackup")
            try self.sessionStorage?.validate(name: "\(name).sessionStorage")
            try self.streamingImageIds.forEach {
                try validate($0, name: "streamingImageIds[]", parent: name, max: 22)
                try validate($0, name: "streamingImageIds[]", parent: name, pattern: "^[a-zA-Z0-9-_]*$")
            }
            try self.validate(self.streamingImageIds, name: "streamingImageIds", parent: name, max: 20)
            try self.validate(self.streamingImageIds, name: "streamingImageIds", parent: name, min: 1)
            try self.volumeConfiguration?.validate(name: "\(name).volumeConfiguration")
        }

        private enum CodingKeys: String, CodingKey {
            case automaticTerminationMode
            case clipboardMode
            case ec2InstanceTypes
            case maxSessionLengthInMinutes
            case maxStoppedSessionLengthInMinutes
            case sessionBackup
            case sessionPersistenceMode
            case sessionStorage
            case streamingImageIds
            case volumeConfiguration
        }
    }

    public struct StreamConfigurationSessionBackup: AWSEncodableShape & AWSDecodableShape {
        /// The maximum number of backups that each streaming session created from this launch profile can have.
        public let maxBackupsToRetain: Int?
        /// Specifies how artists sessions are backed up. Configures backups for streaming sessions launched with this launch profile. The default value is DEACTIVATED, which means that backups are deactivated. To allow backups, set this value to AUTOMATIC.
        public let mode: SessionBackupMode?

        public init(maxBackupsToRetain: Int? = nil, mode: SessionBackupMode? = nil) {
            self.maxBackupsToRetain = maxBackupsToRetain
            self.mode = mode
        }

        public func validate(name: String) throws {
            try self.validate(self.maxBackupsToRetain, name: "maxBackupsToRetain", parent: name, max: 10)
            try self.validate(self.maxBackupsToRetain, name: "maxBackupsToRetain", parent: name, min: 0)
        }

        private enum CodingKeys: String, CodingKey {
            case maxBackupsToRetain
            case mode
        }
    }

    public struct StreamConfigurationSessionStorage: AWSEncodableShape & AWSDecodableShape {
        /// Allows artists to upload files to their workstations. The only valid option is UPLOAD.
        public let mode: [StreamingSessionStorageMode]
        /// The configuration for the upload storage root of the streaming session.
        public let root: StreamingSessionStorageRoot?

        public init(mode: [StreamingSessionStorageMode], root: StreamingSessionStorageRoot? = nil) {
            self.mode = mode
            self.root = root
        }

        public func validate(name: String) throws {
            try self.validate(self.mode, name: "mode", parent: name, min: 1)
            try self.root?.validate(name: "\(name).root")
        }

        private enum CodingKeys: String, CodingKey {
            case mode
            case root
        }
    }

    public struct StreamingImage: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) that is assigned to a studio resource and uniquely identifies it. ARNs are unique across all Regions.
        public let arn: String?
        /// A human-readable description of the streaming image.
        public let description: String?
        /// The ID of an EC2 machine image with which to create the streaming image.
        public let ec2ImageId: String?
        /// The encryption configuration.
        public let encryptionConfiguration: StreamingImageEncryptionConfiguration?
        /// The list of EULAs that must be accepted before a Streaming Session can be started using this streaming image.
        public let eulaIds: [String]?
        /// A friendly name for a streaming image resource.
        public let name: String?
        /// The owner of the streaming image, either the studioId that contains the streaming image, or amazon for images that are provided by Amazon Nimble Studio.
        public let owner: String?
        /// The platform of the streaming image, either Windows or Linux.
        public let platform: String?
        /// The current state.
        public let state: StreamingImageState?
        /// The status code.
        public let statusCode: StreamingImageStatusCode?
        /// The status message for the streaming image.
        public let statusMessage: String?
        /// The ID of the streaming image.
        public let streamingImageId: String?
        /// A collection of labels, in the form of key-value pairs, that apply to this resource.
        public let tags: [String: String]?

        public init(arn: String? = nil, description: String? = nil, ec2ImageId: String? = nil, encryptionConfiguration: StreamingImageEncryptionConfiguration? = nil, eulaIds: [String]? = nil, name: String? = nil, owner: String? = nil, platform: String? = nil, state: StreamingImageState? = nil, statusCode: StreamingImageStatusCode? = nil, statusMessage: String? = nil, streamingImageId: String? = nil, tags: [String: String]? = nil) {
            self.arn = arn
            self.description = description
            self.ec2ImageId = ec2ImageId
            self.encryptionConfiguration = encryptionConfiguration
            self.eulaIds = eulaIds
            self.name = name
            self.owner = owner
            self.platform = platform
            self.state = state
            self.statusCode = statusCode
            self.statusMessage = statusMessage
            self.streamingImageId = streamingImageId
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case arn
            case description
            case ec2ImageId
            case encryptionConfiguration
            case eulaIds
            case name
            case owner
            case platform
            case state
            case statusCode
            case statusMessage
            case streamingImageId
            case tags
        }
    }

    public struct StreamingImageEncryptionConfiguration: AWSDecodableShape {
        /// The ARN for a KMS key that is used to encrypt studio data.
        public let keyArn: String?
        /// The type of KMS key that is used to encrypt studio data.
        public let keyType: StreamingImageEncryptionConfigurationKeyType

        public init(keyArn: String? = nil, keyType: StreamingImageEncryptionConfigurationKeyType) {
            self.keyArn = keyArn
            self.keyType = keyType
        }

        private enum CodingKeys: String, CodingKey {
            case keyArn
            case keyType
        }
    }

    public struct StreamingSession: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) that is assigned to a studio resource and uniquely identifies it. ARNs are unique across all Regions.
        public let arn: String?
        /// Indicates if a streaming session created from this launch profile should be terminated automatically or retained without termination after being in a STOPPED state.   When ACTIVATED, the streaming session is scheduled for termination after being in the STOPPED state for the time specified in maxStoppedSessionLengthInMinutes.   When DEACTIVATED, the streaming session can remain in the STOPPED state indefinitely.   This parameter is only allowed when sessionPersistenceMode is ACTIVATED. When allowed, the default value for this parameter is DEACTIVATED.
        public let automaticTerminationMode: AutomaticTerminationMode?
        /// Shows the current backup setting of the session.
        public let backupMode: SessionBackupMode?
        /// The ISO timestamp in seconds for when the resource was created.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var createdAt: Date?
        /// The user ID of the user that created the streaming session.
        public let createdBy: String?
        /// The EC2 Instance type used for the streaming session.
        public let ec2InstanceType: String?
        /// The ID of the launch profile used to control access from the streaming session.
        public let launchProfileId: String?
        /// The maximum number of backups of a streaming session that you can have. When the maximum number of backups is reached, the oldest backup is deleted.
        public let maxBackupsToRetain: Int?
        /// The user ID of the user that owns the streaming session. The user that owns the session will be logging into the session and interacting with the virtual workstation.
        public let ownedBy: String?
        /// The session ID.
        public let sessionId: String?
        /// Determine if a streaming session created from this launch profile can configure persistent storage. This means that volumeConfiguration and automaticTerminationMode are configured.
        public let sessionPersistenceMode: SessionPersistenceMode?
        /// The time the session entered START_IN_PROGRESS state.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var startedAt: Date?
        /// The user ID of the user that started the streaming session.
        public let startedBy: String?
        /// The backup ID used to restore a streaming session.
        public let startedFromBackupId: String?
        /// The current state.
        public let state: StreamingSessionState?
        /// The status code.
        public let statusCode: StreamingSessionStatusCode?
        /// The status message for the streaming session.
        public let statusMessage: String?
        /// The time the streaming session will automatically be stopped if the user doesn’t stop the session themselves.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var stopAt: Date?
        /// The time the session entered STOP_IN_PROGRESS state.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var stoppedAt: Date?
        /// The user ID of the user that stopped the streaming session.
        public let stoppedBy: String?
        /// The ID of the streaming image.
        public let streamingImageId: String?
        /// A collection of labels, in the form of key-value pairs, that apply to this resource.
        public let tags: [String: String]?
        /// The time the streaming session will automatically terminate if not terminated by the user.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var terminateAt: Date?
        /// The ISO timestamp in seconds for when the resource was updated.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var updatedAt: Date?
        /// The user ID of the user that most recently updated the resource.
        public let updatedBy: String?
        /// Custom volume configuration for the root volumes that are attached to streaming sessions. This parameter is only allowed when sessionPersistenceMode is ACTIVATED.
        public let volumeConfiguration: VolumeConfiguration?
        /// Determine if an EBS volume created from this streaming session will be backed up.
        public let volumeRetentionMode: VolumeRetentionMode?

        public init(arn: String? = nil, automaticTerminationMode: AutomaticTerminationMode? = nil, backupMode: SessionBackupMode? = nil, createdAt: Date? = nil, createdBy: String? = nil, ec2InstanceType: String? = nil, launchProfileId: String? = nil, maxBackupsToRetain: Int? = nil, ownedBy: String? = nil, sessionId: String? = nil, sessionPersistenceMode: SessionPersistenceMode? = nil, startedAt: Date? = nil, startedBy: String? = nil, startedFromBackupId: String? = nil, state: StreamingSessionState? = nil, statusCode: StreamingSessionStatusCode? = nil, statusMessage: String? = nil, stopAt: Date? = nil, stoppedAt: Date? = nil, stoppedBy: String? = nil, streamingImageId: String? = nil, tags: [String: String]? = nil, terminateAt: Date? = nil, updatedAt: Date? = nil, updatedBy: String? = nil, volumeConfiguration: VolumeConfiguration? = nil, volumeRetentionMode: VolumeRetentionMode? = nil) {
            self.arn = arn
            self.automaticTerminationMode = automaticTerminationMode
            self.backupMode = backupMode
            self.createdAt = createdAt
            self.createdBy = createdBy
            self.ec2InstanceType = ec2InstanceType
            self.launchProfileId = launchProfileId
            self.maxBackupsToRetain = maxBackupsToRetain
            self.ownedBy = ownedBy
            self.sessionId = sessionId
            self.sessionPersistenceMode = sessionPersistenceMode
            self.startedAt = startedAt
            self.startedBy = startedBy
            self.startedFromBackupId = startedFromBackupId
            self.state = state
            self.statusCode = statusCode
            self.statusMessage = statusMessage
            self.stopAt = stopAt
            self.stoppedAt = stoppedAt
            self.stoppedBy = stoppedBy
            self.streamingImageId = streamingImageId
            self.tags = tags
            self.terminateAt = terminateAt
            self.updatedAt = updatedAt
            self.updatedBy = updatedBy
            self.volumeConfiguration = volumeConfiguration
            self.volumeRetentionMode = volumeRetentionMode
        }

        private enum CodingKeys: String, CodingKey {
            case arn
            case automaticTerminationMode
            case backupMode
            case createdAt
            case createdBy
            case ec2InstanceType
            case launchProfileId
            case maxBackupsToRetain
            case ownedBy
            case sessionId
            case sessionPersistenceMode
            case startedAt
            case startedBy
            case startedFromBackupId
            case state
            case statusCode
            case statusMessage
            case stopAt
            case stoppedAt
            case stoppedBy
            case streamingImageId
            case tags
            case terminateAt
            case updatedAt
            case updatedBy
            case volumeConfiguration
            case volumeRetentionMode
        }
    }

    public struct StreamingSessionBackup: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) that is assigned to a studio resource and uniquely identifies it. ARNs are unique across all Regions.
        public let arn: String?
        /// The ID of the backup.
        public let backupId: String?
        /// The ISO timestamp in for when the resource was created.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var createdAt: Date?
        /// The ID of the launch profile which allowed the backups for the streaming session.
        public let launchProfileId: String?
        /// The user ID of the user that owns the streaming session.
        public let ownedBy: String?
        /// The streaming session ID for the StreamingSessionBackup.
        public let sessionId: String?
        public let state: StreamingSessionState?
        /// The status code.
        public let statusCode: StreamingSessionStatusCode?
        /// The status message for the streaming session backup.
        public let statusMessage: String?
        /// A collection of labels, in the form of key-value pairs, that apply to this resource.
        public let tags: [String: String]?

        public init(arn: String? = nil, backupId: String? = nil, createdAt: Date? = nil, launchProfileId: String? = nil, ownedBy: String? = nil, sessionId: String? = nil, state: StreamingSessionState? = nil, statusCode: StreamingSessionStatusCode? = nil, statusMessage: String? = nil, tags: [String: String]? = nil) {
            self.arn = arn
            self.backupId = backupId
            self.createdAt = createdAt
            self.launchProfileId = launchProfileId
            self.ownedBy = ownedBy
            self.sessionId = sessionId
            self.state = state
            self.statusCode = statusCode
            self.statusMessage = statusMessage
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case arn
            case backupId
            case createdAt
            case launchProfileId
            case ownedBy
            case sessionId
            case state
            case statusCode
            case statusMessage
            case tags
        }
    }

    public struct StreamingSessionStorageRoot: AWSEncodableShape & AWSDecodableShape {
        /// The folder path in Linux workstations where files are uploaded.
        public let linux: String?
        /// The folder path in Windows workstations where files are uploaded.
        public let windows: String?

        public init(linux: String? = nil, windows: String? = nil) {
            self.linux = linux
            self.windows = windows
        }

        public func validate(name: String) throws {
            try self.validate(self.linux, name: "linux", parent: name, max: 128)
            try self.validate(self.linux, name: "linux", parent: name, min: 1)
            try self.validate(self.linux, name: "linux", parent: name, pattern: "^(\\$HOME|/)[/]?([A-Za-z0-9-_]+/)*([A-Za-z0-9_-]+)$")
            try self.validate(self.windows, name: "windows", parent: name, max: 128)
            try self.validate(self.windows, name: "windows", parent: name, min: 1)
            try self.validate(self.windows, name: "windows", parent: name, pattern: "^((\\%HOMEPATH\\%)|[a-zA-Z]:)[\\\\/](?:[a-zA-Z0-9_-]+[\\\\/])*[a-zA-Z0-9_-]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case linux
            case windows
        }
    }

    public struct StreamingSessionStream: AWSDecodableShape {
        /// The ISO timestamp in seconds for when the resource was created.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var createdAt: Date?
        /// The user ID of the user that created the streaming session stream.
        public let createdBy: String?
        /// The ISO timestamp in seconds for when the resource expires.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var expiresAt: Date?
        /// The user ID of the user that owns the streaming session. The user that owns the session will be logging into the session and interacting with the virtual workstation.
        public let ownedBy: String?
        /// The current state.
        public let state: StreamingSessionStreamState?
        /// The streaming session stream status code.
        public let statusCode: StreamingSessionStreamStatusCode?
        /// The stream ID.
        public let streamId: String?
        /// The URL to connect to this stream using the DCV client.
        public let url: String?

        public init(createdAt: Date? = nil, createdBy: String? = nil, expiresAt: Date? = nil, ownedBy: String? = nil, state: StreamingSessionStreamState? = nil, statusCode: StreamingSessionStreamStatusCode? = nil, streamId: String? = nil, url: String? = nil) {
            self.createdAt = createdAt
            self.createdBy = createdBy
            self.expiresAt = expiresAt
            self.ownedBy = ownedBy
            self.state = state
            self.statusCode = statusCode
            self.streamId = streamId
            self.url = url
        }

        private enum CodingKeys: String, CodingKey {
            case createdAt
            case createdBy
            case expiresAt
            case ownedBy
            case state
            case statusCode
            case streamId
            case url
        }
    }

    public struct Studio: AWSDecodableShape {
        /// The IAM role that studio admins assume when logging in to the Nimble Studio portal.
        public let adminRoleArn: String?
        /// The Amazon Resource Name (ARN) that is assigned to a studio resource and uniquely identifies it. ARNs are unique across all Regions.
        public let arn: String?
        /// The ISO timestamp in seconds for when the resource was created.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var createdAt: Date?
        /// A friendly name for the studio.
        public let displayName: String?
        /// The Amazon Web Services Region where the studio resource is located.
        public let homeRegion: String?
        /// The IAM Identity Center application client ID used to integrate with IAM Identity Center. This ID allows IAM Identity Center users to log in to Nimble Studio portal.
        public let ssoClientId: String?
        /// The current state of the studio resource.
        public let state: StudioState?
        /// Status codes that provide additional detail on the studio state.
        public let statusCode: StudioStatusCode?
        /// Additional detail on the studio state.
        public let statusMessage: String?
        /// Configuration of the encryption method that is used for the studio.
        public let studioEncryptionConfiguration: StudioEncryptionConfiguration?
        /// The unique identifier for a studio resource. In Nimble Studio, all other resources are contained in a studio resource.
        public let studioId: String?
        /// The name of the studio, as included in the URL when accessing it in the Nimble Studio portal.
        public let studioName: String?
        /// The address of the web page for the studio.
        public let studioUrl: String?
        /// A collection of labels, in the form of key-value pairs, that apply to this resource.
        public let tags: [String: String]?
        /// The ISO timestamp in seconds for when the resource was updated.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var updatedAt: Date?
        /// The IAM role that studio users assume when logging in to the Nimble Studio portal.
        public let userRoleArn: String?

        public init(adminRoleArn: String? = nil, arn: String? = nil, createdAt: Date? = nil, displayName: String? = nil, homeRegion: String? = nil, ssoClientId: String? = nil, state: StudioState? = nil, statusCode: StudioStatusCode? = nil, statusMessage: String? = nil, studioEncryptionConfiguration: StudioEncryptionConfiguration? = nil, studioId: String? = nil, studioName: String? = nil, studioUrl: String? = nil, tags: [String: String]? = nil, updatedAt: Date? = nil, userRoleArn: String? = nil) {
            self.adminRoleArn = adminRoleArn
            self.arn = arn
            self.createdAt = createdAt
            self.displayName = displayName
            self.homeRegion = homeRegion
            self.ssoClientId = ssoClientId
            self.state = state
            self.statusCode = statusCode
            self.statusMessage = statusMessage
            self.studioEncryptionConfiguration = studioEncryptionConfiguration
            self.studioId = studioId
            self.studioName = studioName
            self.studioUrl = studioUrl
            self.tags = tags
            self.updatedAt = updatedAt
            self.userRoleArn = userRoleArn
        }

        private enum CodingKeys: String, CodingKey {
            case adminRoleArn
            case arn
            case createdAt
            case displayName
            case homeRegion
            case ssoClientId
            case state
            case statusCode
            case statusMessage
            case studioEncryptionConfiguration
            case studioId
            case studioName
            case studioUrl
            case tags
            case updatedAt
            case userRoleArn
        }
    }

    public struct StudioComponent: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) that is assigned to a studio resource and uniquely identifies it. ARNs are unique across all Regions.
        public let arn: String?
        /// The configuration of the studio component, based on component type.
        public let configuration: StudioComponentConfiguration?
        /// The ISO timestamp in seconds for when the resource was created.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var createdAt: Date?
        /// The user ID of the user that created the studio component.
        public let createdBy: String?
        /// A human-readable description for the studio component resource.
        public let description: String?
        /// The EC2 security groups that control access to the studio component.
        public let ec2SecurityGroupIds: [String]?
        /// Initialization scripts for studio components.
        public let initializationScripts: [StudioComponentInitializationScript]?
        /// A friendly name for the studio component resource.
        public let name: String?
        /// An IAM role attached to a Studio Component that gives the studio component access to Amazon Web Services resources at anytime while the instance is running.
        public let runtimeRoleArn: String?
        /// Parameters for the studio component scripts.
        public let scriptParameters: [ScriptParameterKeyValue]?
        /// An IAM role attached to Studio Component when the system initialization script runs which give the studio component access to Amazon Web Services resources when the system initialization script runs.
        public let secureInitializationRoleArn: String?
        /// The current state.
        public let state: StudioComponentState?
        /// The status code.
        public let statusCode: StudioComponentStatusCode?
        /// The status message for the studio component.
        public let statusMessage: String?
        /// The unique identifier for a studio component resource.
        public let studioComponentId: String?
        /// The specific subtype of a studio component.
        public let subtype: StudioComponentSubtype?
        /// A collection of labels, in the form of key-value pairs, that apply to this resource.
        public let tags: [String: String]?
        /// The type of the studio component.
        public let type: StudioComponentType?
        /// The ISO timestamp in seconds for when the resource was updated.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var updatedAt: Date?
        /// The user ID of the user that most recently updated the resource.
        public let updatedBy: String?

        public init(arn: String? = nil, configuration: StudioComponentConfiguration? = nil, createdAt: Date? = nil, createdBy: String? = nil, description: String? = nil, ec2SecurityGroupIds: [String]? = nil, initializationScripts: [StudioComponentInitializationScript]? = nil, name: String? = nil, runtimeRoleArn: String? = nil, scriptParameters: [ScriptParameterKeyValue]? = nil, secureInitializationRoleArn: String? = nil, state: StudioComponentState? = nil, statusCode: StudioComponentStatusCode? = nil, statusMessage: String? = nil, studioComponentId: String? = nil, subtype: StudioComponentSubtype? = nil, tags: [String: String]? = nil, type: StudioComponentType? = nil, updatedAt: Date? = nil, updatedBy: String? = nil) {
            self.arn = arn
            self.configuration = configuration
            self.createdAt = createdAt
            self.createdBy = createdBy
            self.description = description
            self.ec2SecurityGroupIds = ec2SecurityGroupIds
            self.initializationScripts = initializationScripts
            self.name = name
            self.runtimeRoleArn = runtimeRoleArn
            self.scriptParameters = scriptParameters
            self.secureInitializationRoleArn = secureInitializationRoleArn
            self.state = state
            self.statusCode = statusCode
            self.statusMessage = statusMessage
            self.studioComponentId = studioComponentId
            self.subtype = subtype
            self.tags = tags
            self.type = type
            self.updatedAt = updatedAt
            self.updatedBy = updatedBy
        }

        private enum CodingKeys: String, CodingKey {
            case arn
            case configuration
            case createdAt
            case createdBy
            case description
            case ec2SecurityGroupIds
            case initializationScripts
            case name
            case runtimeRoleArn
            case scriptParameters
            case secureInitializationRoleArn
            case state
            case statusCode
            case statusMessage
            case studioComponentId
            case subtype
            case tags
            case type
            case updatedAt
            case updatedBy
        }
    }

    public struct StudioComponentInitializationScript: AWSEncodableShape & AWSDecodableShape {
        /// The version number of the protocol that is used by the launch profile. The only valid version is "2021-03-31".
        public let launchProfileProtocolVersion: String?
        /// The platform of the initialization script, either Windows or Linux.
        public let platform: LaunchProfilePlatform?
        /// The method to use when running the initialization script.
        public let runContext: StudioComponentInitializationScriptRunContext?
        /// The initialization script.
        public let script: String?

        public init(launchProfileProtocolVersion: String? = nil, platform: LaunchProfilePlatform? = nil, runContext: StudioComponentInitializationScriptRunContext? = nil, script: String? = nil) {
            self.launchProfileProtocolVersion = launchProfileProtocolVersion
            self.platform = platform
            self.runContext = runContext
            self.script = script
        }

        public func validate(name: String) throws {
            try self.validate(self.launchProfileProtocolVersion, name: "launchProfileProtocolVersion", parent: name, max: 10)
            try self.validate(self.launchProfileProtocolVersion, name: "launchProfileProtocolVersion", parent: name, pattern: "^2021\\-03\\-31$")
            try self.validate(self.script, name: "script", parent: name, max: 5120)
            try self.validate(self.script, name: "script", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case launchProfileProtocolVersion
            case platform
            case runContext
            case script
        }
    }

    public struct StudioComponentSummary: AWSDecodableShape {
        /// The ISO timestamp in seconds for when the resource was created.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var createdAt: Date?
        /// The user ID of the user that created the studio component.
        public let createdBy: String?
        /// The description.
        public let description: String?
        /// The name for the studio component.
        public let name: String?
        /// The unique identifier for a studio component resource.
        public let studioComponentId: String?
        /// The specific subtype of a studio component.
        public let subtype: StudioComponentSubtype?
        /// The type of the studio component.
        public let type: StudioComponentType?
        /// The ISO timestamp in seconds for when the resource was updated.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var updatedAt: Date?
        /// The user ID of the user that most recently updated the resource.
        public let updatedBy: String?

        public init(createdAt: Date? = nil, createdBy: String? = nil, description: String? = nil, name: String? = nil, studioComponentId: String? = nil, subtype: StudioComponentSubtype? = nil, type: StudioComponentType? = nil, updatedAt: Date? = nil, updatedBy: String? = nil) {
            self.createdAt = createdAt
            self.createdBy = createdBy
            self.description = description
            self.name = name
            self.studioComponentId = studioComponentId
            self.subtype = subtype
            self.type = type
            self.updatedAt = updatedAt
            self.updatedBy = updatedBy
        }

        private enum CodingKeys: String, CodingKey {
            case createdAt
            case createdBy
            case description
            case name
            case studioComponentId
            case subtype
            case type
            case updatedAt
            case updatedBy
        }
    }

    public struct StudioEncryptionConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The ARN for a KMS key that is used to encrypt studio data.
        public let keyArn: String?
        /// The type of KMS key that is used to encrypt studio data.
        public let keyType: StudioEncryptionConfigurationKeyType

        public init(keyArn: String? = nil, keyType: StudioEncryptionConfigurationKeyType) {
            self.keyArn = keyArn
            self.keyType = keyType
        }

        public func validate(name: String) throws {
            try self.validate(self.keyArn, name: "keyArn", parent: name, min: 4)
            try self.validate(self.keyArn, name: "keyArn", parent: name, pattern: "^arn:.*")
        }

        private enum CodingKeys: String, CodingKey {
            case keyArn
            case keyType
        }
    }

    public struct StudioMembership: AWSDecodableShape {
        /// The ID of the identity store.
        public let identityStoreId: String?
        /// The persona.
        public let persona: StudioPersona?
        /// The principal ID.
        public let principalId: String?
        /// The Active Directory Security Identifier for this user, if available.
        public let sid: String?

        public init(identityStoreId: String? = nil, persona: StudioPersona? = nil, principalId: String? = nil, sid: String? = nil) {
            self.identityStoreId = identityStoreId
            self.persona = persona
            self.principalId = principalId
            self.sid = sid
        }

        private enum CodingKeys: String, CodingKey {
            case identityStoreId
            case persona
            case principalId
            case sid
        }
    }

    public struct TagResourceRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "resourceArn", location: .uri("resourceArn"))
        ]

        /// The Amazon Resource Name (ARN) of the resource you want to add tags to.
        public let resourceArn: String
        /// A collection of labels, in the form of key-value pairs, that apply to this resource.
        public let tags: [String: String]?

        public init(resourceArn: String, tags: [String: String]? = nil) {
            self.resourceArn = resourceArn
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case tags
        }
    }

    public struct TagResourceResponse: AWSDecodableShape {
        public init() {}
    }

    public struct UntagResourceRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "resourceArn", location: .uri("resourceArn")),
            AWSMemberEncoding(label: "tagKeys", location: .querystring("tagKeys"))
        ]

        /// Identifies the Amazon Resource Name(ARN) key from which you are removing tags.
        public let resourceArn: String
        /// One or more tag keys. Specify only the tag keys, not the tag values.
        public let tagKeys: [String]

        public init(resourceArn: String, tagKeys: [String]) {
            self.resourceArn = resourceArn
            self.tagKeys = tagKeys
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct UntagResourceResponse: AWSDecodableShape {
        public init() {}
    }

    public struct UpdateLaunchProfileMemberRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "clientToken", location: .header("X-Amz-Client-Token")),
            AWSMemberEncoding(label: "launchProfileId", location: .uri("launchProfileId")),
            AWSMemberEncoding(label: "principalId", location: .uri("principalId")),
            AWSMemberEncoding(label: "studioId", location: .uri("studioId"))
        ]

        /// Unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If you don’t specify a client token, the Amazon Web Services SDK automatically generates a client token and uses it for the request to ensure idempotency.
        public let clientToken: String?
        /// The ID of the launch profile used to control access from the streaming session.
        public let launchProfileId: String
        /// The persona.
        public let persona: LaunchProfilePersona
        /// The principal ID. This currently supports a IAM Identity Center UserId.
        public let principalId: String
        /// The studio ID.
        public let studioId: String

        public init(clientToken: String? = UpdateLaunchProfileMemberRequest.idempotencyToken(), launchProfileId: String, persona: LaunchProfilePersona, principalId: String, studioId: String) {
            self.clientToken = clientToken
            self.launchProfileId = launchProfileId
            self.persona = persona
            self.principalId = principalId
            self.studioId = studioId
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 64)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case persona
        }
    }

    public struct UpdateLaunchProfileMemberResponse: AWSDecodableShape {
        /// The updated member.
        public let member: LaunchProfileMembership?

        public init(member: LaunchProfileMembership? = nil) {
            self.member = member
        }

        private enum CodingKeys: String, CodingKey {
            case member
        }
    }

    public struct UpdateLaunchProfileRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "clientToken", location: .header("X-Amz-Client-Token")),
            AWSMemberEncoding(label: "launchProfileId", location: .uri("launchProfileId")),
            AWSMemberEncoding(label: "studioId", location: .uri("studioId"))
        ]

        /// Unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If you don’t specify a client token, the Amazon Web Services SDK automatically generates a client token and uses it for the request to ensure idempotency.
        public let clientToken: String?
        /// The description.
        public let description: String?
        /// The ID of the launch profile used to control access from the streaming session.
        public let launchProfileId: String
        /// The version number of the protocol that is used by the launch profile. The only valid version is "2021-03-31".
        public let launchProfileProtocolVersions: [String]?
        /// The name for the launch profile.
        public let name: String?
        /// A configuration for a streaming session.
        public let streamConfiguration: StreamConfigurationCreate?
        /// Unique identifiers for a collection of studio components that can be used with this launch profile.
        public let studioComponentIds: [String]?
        /// The studio ID.
        public let studioId: String

        public init(clientToken: String? = UpdateLaunchProfileRequest.idempotencyToken(), description: String? = nil, launchProfileId: String, launchProfileProtocolVersions: [String]? = nil, name: String? = nil, streamConfiguration: StreamConfigurationCreate? = nil, studioComponentIds: [String]? = nil, studioId: String) {
            self.clientToken = clientToken
            self.description = description
            self.launchProfileId = launchProfileId
            self.launchProfileProtocolVersions = launchProfileProtocolVersions
            self.name = name
            self.streamConfiguration = streamConfiguration
            self.studioComponentIds = studioComponentIds
            self.studioId = studioId
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 64)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.validate(self.description, name: "description", parent: name, max: 256)
            try self.launchProfileProtocolVersions?.forEach {
                try validate($0, name: "launchProfileProtocolVersions[]", parent: name, max: 10)
                try validate($0, name: "launchProfileProtocolVersions[]", parent: name, pattern: "^2021\\-03\\-31$")
            }
            try self.validate(self.name, name: "name", parent: name, max: 64)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.streamConfiguration?.validate(name: "\(name).streamConfiguration")
            try self.validate(self.studioComponentIds, name: "studioComponentIds", parent: name, max: 100)
            try self.validate(self.studioComponentIds, name: "studioComponentIds", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case description
            case launchProfileProtocolVersions
            case name
            case streamConfiguration
            case studioComponentIds
        }
    }

    public struct UpdateLaunchProfileResponse: AWSDecodableShape {
        /// The launch profile.
        public let launchProfile: LaunchProfile?

        public init(launchProfile: LaunchProfile? = nil) {
            self.launchProfile = launchProfile
        }

        private enum CodingKeys: String, CodingKey {
            case launchProfile
        }
    }

    public struct UpdateStreamingImageRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "clientToken", location: .header("X-Amz-Client-Token")),
            AWSMemberEncoding(label: "streamingImageId", location: .uri("streamingImageId")),
            AWSMemberEncoding(label: "studioId", location: .uri("studioId"))
        ]

        /// Unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If you don’t specify a client token, the Amazon Web Services SDK automatically generates a client token and uses it for the request to ensure idempotency.
        public let clientToken: String?
        /// The description.
        public let description: String?
        /// The name for the streaming image.
        public let name: String?
        /// The streaming image ID.
        public let streamingImageId: String
        /// The studio ID.
        public let studioId: String

        public init(clientToken: String? = UpdateStreamingImageRequest.idempotencyToken(), description: String? = nil, name: String? = nil, streamingImageId: String, studioId: String) {
            self.clientToken = clientToken
            self.description = description
            self.name = name
            self.streamingImageId = streamingImageId
            self.studioId = studioId
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 64)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.validate(self.description, name: "description", parent: name, max: 256)
            try self.validate(self.name, name: "name", parent: name, max: 64)
        }

        private enum CodingKeys: String, CodingKey {
            case description
            case name
        }
    }

    public struct UpdateStreamingImageResponse: AWSDecodableShape {
        public let streamingImage: StreamingImage?

        public init(streamingImage: StreamingImage? = nil) {
            self.streamingImage = streamingImage
        }

        private enum CodingKeys: String, CodingKey {
            case streamingImage
        }
    }

    public struct UpdateStudioComponentRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "clientToken", location: .header("X-Amz-Client-Token")),
            AWSMemberEncoding(label: "studioComponentId", location: .uri("studioComponentId")),
            AWSMemberEncoding(label: "studioId", location: .uri("studioId"))
        ]

        /// Unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If you don’t specify a client token, the Amazon Web Services SDK automatically generates a client token and uses it for the request to ensure idempotency.
        public let clientToken: String?
        /// The configuration of the studio component, based on component type.
        public let configuration: StudioComponentConfiguration?
        /// The description.
        public let description: String?
        /// The EC2 security groups that control access to the studio component.
        public let ec2SecurityGroupIds: [String]?
        /// Initialization scripts for studio components.
        public let initializationScripts: [StudioComponentInitializationScript]?
        /// The name for the studio component.
        public let name: String?
        /// An IAM role attached to a Studio Component that gives the studio component access to Amazon Web Services resources at anytime while the instance is running.
        public let runtimeRoleArn: String?
        /// Parameters for the studio component scripts.
        public let scriptParameters: [ScriptParameterKeyValue]?
        /// An IAM role attached to Studio Component when the system initialization script runs which give the studio component access to Amazon Web Services resources when the system initialization script runs.
        public let secureInitializationRoleArn: String?
        /// The studio component ID.
        public let studioComponentId: String
        /// The studio ID.
        public let studioId: String
        /// The specific subtype of a studio component.
        public let subtype: StudioComponentSubtype?
        /// The type of the studio component.
        public let type: StudioComponentType?

        public init(clientToken: String? = UpdateStudioComponentRequest.idempotencyToken(), configuration: StudioComponentConfiguration? = nil, description: String? = nil, ec2SecurityGroupIds: [String]? = nil, initializationScripts: [StudioComponentInitializationScript]? = nil, name: String? = nil, runtimeRoleArn: String? = nil, scriptParameters: [ScriptParameterKeyValue]? = nil, secureInitializationRoleArn: String? = nil, studioComponentId: String, studioId: String, subtype: StudioComponentSubtype? = nil, type: StudioComponentType? = nil) {
            self.clientToken = clientToken
            self.configuration = configuration
            self.description = description
            self.ec2SecurityGroupIds = ec2SecurityGroupIds
            self.initializationScripts = initializationScripts
            self.name = name
            self.runtimeRoleArn = runtimeRoleArn
            self.scriptParameters = scriptParameters
            self.secureInitializationRoleArn = secureInitializationRoleArn
            self.studioComponentId = studioComponentId
            self.studioId = studioId
            self.subtype = subtype
            self.type = type
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 64)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.configuration?.validate(name: "\(name).configuration")
            try self.validate(self.description, name: "description", parent: name, max: 256)
            try self.validate(self.ec2SecurityGroupIds, name: "ec2SecurityGroupIds", parent: name, max: 30)
            try self.initializationScripts?.forEach {
                try $0.validate(name: "\(name).initializationScripts[]")
            }
            try self.validate(self.name, name: "name", parent: name, max: 64)
            try self.validate(self.runtimeRoleArn, name: "runtimeRoleArn", parent: name, max: 2048)
            try self.scriptParameters?.forEach {
                try $0.validate(name: "\(name).scriptParameters[]")
            }
            try self.validate(self.scriptParameters, name: "scriptParameters", parent: name, max: 30)
            try self.validate(self.secureInitializationRoleArn, name: "secureInitializationRoleArn", parent: name, max: 2048)
        }

        private enum CodingKeys: String, CodingKey {
            case configuration
            case description
            case ec2SecurityGroupIds
            case initializationScripts
            case name
            case runtimeRoleArn
            case scriptParameters
            case secureInitializationRoleArn
            case subtype
            case type
        }
    }

    public struct UpdateStudioComponentResponse: AWSDecodableShape {
        /// Information about the studio component.
        public let studioComponent: StudioComponent?

        public init(studioComponent: StudioComponent? = nil) {
            self.studioComponent = studioComponent
        }

        private enum CodingKeys: String, CodingKey {
            case studioComponent
        }
    }

    public struct UpdateStudioRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "clientToken", location: .header("X-Amz-Client-Token")),
            AWSMemberEncoding(label: "studioId", location: .uri("studioId"))
        ]

        /// The IAM role that Studio Admins will assume when logging in to the Nimble Studio portal.
        public let adminRoleArn: String?
        /// Unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If you don’t specify a client token, the Amazon Web Services SDK automatically generates a client token and uses it for the request to ensure idempotency.
        public let clientToken: String?
        /// A friendly name for the studio.
        public let displayName: String?
        /// The studio ID.
        public let studioId: String
        /// The IAM role that Studio Users will assume when logging in to the Nimble Studio portal.
        public let userRoleArn: String?

        public init(adminRoleArn: String? = nil, clientToken: String? = UpdateStudioRequest.idempotencyToken(), displayName: String? = nil, studioId: String, userRoleArn: String? = nil) {
            self.adminRoleArn = adminRoleArn
            self.clientToken = clientToken
            self.displayName = displayName
            self.studioId = studioId
            self.userRoleArn = userRoleArn
        }

        public func validate(name: String) throws {
            try self.validate(self.adminRoleArn, name: "adminRoleArn", parent: name, max: 2048)
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 64)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.validate(self.displayName, name: "displayName", parent: name, max: 64)
            try self.validate(self.userRoleArn, name: "userRoleArn", parent: name, max: 2048)
        }

        private enum CodingKeys: String, CodingKey {
            case adminRoleArn
            case displayName
            case userRoleArn
        }
    }

    public struct UpdateStudioResponse: AWSDecodableShape {
        /// Information about a studio.
        public let studio: Studio

        public init(studio: Studio) {
            self.studio = studio
        }

        private enum CodingKeys: String, CodingKey {
            case studio
        }
    }

    public struct ValidationResult: AWSDecodableShape {
        /// The current state.
        public let state: LaunchProfileValidationState
        /// The status code. This will contain the failure reason if the state is VALIDATION_FAILED.
        public let statusCode: LaunchProfileValidationStatusCode
        /// The status message for the validation result.
        public let statusMessage: String
        /// The type of the validation result.
        public let type: LaunchProfileValidationType

        public init(state: LaunchProfileValidationState, statusCode: LaunchProfileValidationStatusCode, statusMessage: String, type: LaunchProfileValidationType) {
            self.state = state
            self.statusCode = statusCode
            self.statusMessage = statusMessage
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case state
            case statusCode
            case statusMessage
            case type
        }
    }

    public struct VolumeConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The number of I/O operations per second for the root volume that is attached to streaming session.
        public let iops: Int?
        /// The size of the root volume that is attached to the streaming session. The root volume size is measured in GiBs.
        public let size: Int?
        /// The throughput to provision for the root volume that is attached to the streaming session. The throughput is measured in MiB/s.
        public let throughput: Int?

        public init(iops: Int? = nil, size: Int? = nil, throughput: Int? = nil) {
            self.iops = iops
            self.size = size
            self.throughput = throughput
        }

        public func validate(name: String) throws {
            try self.validate(self.iops, name: "iops", parent: name, max: 16000)
            try self.validate(self.iops, name: "iops", parent: name, min: 3000)
            try self.validate(self.size, name: "size", parent: name, max: 16000)
            try self.validate(self.size, name: "size", parent: name, min: 100)
            try self.validate(self.throughput, name: "throughput", parent: name, max: 1000)
            try self.validate(self.throughput, name: "throughput", parent: name, min: 125)
        }

        private enum CodingKeys: String, CodingKey {
            case iops
            case size
            case throughput
        }
    }
}

// MARK: - Errors

/// Error enum for Nimble
public struct NimbleErrorType: AWSErrorType {
    enum Code: String {
        case accessDeniedException = "AccessDeniedException"
        case conflictException = "ConflictException"
        case internalServerErrorException = "InternalServerErrorException"
        case resourceNotFoundException = "ResourceNotFoundException"
        case serviceQuotaExceededException = "ServiceQuotaExceededException"
        case throttlingException = "ThrottlingException"
        case validationException = "ValidationException"
    }

    private let error: Code
    public let context: AWSErrorContext?

    /// initialize Nimble
    public init?(errorCode: String, context: AWSErrorContext) {
        guard let error = Code(rawValue: errorCode) else { return nil }
        self.error = error
        self.context = context
    }

    internal init(_ error: Code) {
        self.error = error
        self.context = nil
    }

    /// return error code string
    public var errorCode: String { self.error.rawValue }

    /// You are not authorized to perform this operation. Check your IAM policies, and ensure that you are using the correct access keys.
    public static var accessDeniedException: Self { .init(.accessDeniedException) }
    /// Another operation is in progress.
    public static var conflictException: Self { .init(.conflictException) }
    /// An internal error has occurred. Please retry your request.
    public static var internalServerErrorException: Self { .init(.internalServerErrorException) }
    /// The specified resource could not be found.
    public static var resourceNotFoundException: Self { .init(.resourceNotFoundException) }
    /// Your current quota does not allow you to perform the request action. You can request increases for some quotas, and other quotas cannot be increased. Please use Amazon Web Services Service Quotas to request an increase.
    public static var serviceQuotaExceededException: Self { .init(.serviceQuotaExceededException) }
    /// The request throughput limit was exceeded.
    public static var throttlingException: Self { .init(.throttlingException) }
    /// One of the parameters in the request is invalid.
    public static var validationException: Self { .init(.validationException) }
}

extension NimbleErrorType: Equatable {
    public static func == (lhs: NimbleErrorType, rhs: NimbleErrorType) -> Bool {
        lhs.error == rhs.error
    }
}

extension NimbleErrorType: CustomStringConvertible {
    public var description: String {
        return "\(self.error.rawValue): \(self.message ?? "")"
    }
}
