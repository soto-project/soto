//===----------------------------------------------------------------------===//
//
// This source file is part of the Soto for AWS open source project
//
// Copyright (c) 2017-2023 the Soto project authors
// Licensed under Apache License v2.0
//
// See LICENSE.txt for license information
// See CONTRIBUTORS.txt for the list of Soto project authors
//
// SPDX-License-Identifier: Apache-2.0
//
//===----------------------------------------------------------------------===//

// THIS FILE IS AUTOMATICALLY GENERATED by https://github.com/soto-project/soto-codegenerator.
// DO NOT EDIT.

#if os(Linux) && compiler(<5.10)
// swift-corelibs-foundation hasn't been updated with Sendable conformances
@preconcurrency import Foundation
#else
import Foundation
#endif
@_spi(SotoInternal) import SotoCore

extension Nimble {
    // MARK: Enums

    public enum AutomaticTerminationMode: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case activated = "ACTIVATED"
        case deactivated = "DEACTIVATED"
        public var description: String { return self.rawValue }
    }

    public enum LaunchProfilePersona: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case user = "USER"
        public var description: String { return self.rawValue }
    }

    public enum LaunchProfilePlatform: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case linux = "LINUX"
        case windows = "WINDOWS"
        public var description: String { return self.rawValue }
    }

    public enum LaunchProfileState: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case createFailed = "CREATE_FAILED"
        case createInProgress = "CREATE_IN_PROGRESS"
        case deleteFailed = "DELETE_FAILED"
        case deleteInProgress = "DELETE_IN_PROGRESS"
        case deleted = "DELETED"
        case ready = "READY"
        case updateFailed = "UPDATE_FAILED"
        case updateInProgress = "UPDATE_IN_PROGRESS"
        public var description: String { return self.rawValue }
    }

    public enum LaunchProfileStatusCode: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case encryptionKeyAccessDenied = "ENCRYPTION_KEY_ACCESS_DENIED"
        case encryptionKeyNotFound = "ENCRYPTION_KEY_NOT_FOUND"
        case internalError = "INTERNAL_ERROR"
        case invalidInstanceTypesProvided = "INVALID_INSTANCE_TYPES_PROVIDED"
        case invalidSubnetsCombination = "INVALID_SUBNETS_COMBINATION"
        case invalidSubnetsProvided = "INVALID_SUBNETS_PROVIDED"
        case launchProfileCreateInProgress = "LAUNCH_PROFILE_CREATE_IN_PROGRESS"
        case launchProfileCreated = "LAUNCH_PROFILE_CREATED"
        case launchProfileDeleteInProgress = "LAUNCH_PROFILE_DELETE_IN_PROGRESS"
        case launchProfileDeleted = "LAUNCH_PROFILE_DELETED"
        case launchProfileUpdateInProgress = "LAUNCH_PROFILE_UPDATE_IN_PROGRESS"
        case launchProfileUpdated = "LAUNCH_PROFILE_UPDATED"
        case launchProfileWithStreamSessionsNotDeleted = "LAUNCH_PROFILE_WITH_STREAM_SESSIONS_NOT_DELETED"
        case streamingImageNotFound = "STREAMING_IMAGE_NOT_FOUND"
        case streamingImageNotReady = "STREAMING_IMAGE_NOT_READY"
        public var description: String { return self.rawValue }
    }

    public enum LaunchProfileValidationState: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case validationFailed = "VALIDATION_FAILED"
        case validationFailedInternalServerError = "VALIDATION_FAILED_INTERNAL_SERVER_ERROR"
        case validationInProgress = "VALIDATION_IN_PROGRESS"
        case validationNotStarted = "VALIDATION_NOT_STARTED"
        case validationSuccess = "VALIDATION_SUCCESS"
        public var description: String { return self.rawValue }
    }

    public enum LaunchProfileValidationStatusCode: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case validationFailedInternalServerError = "VALIDATION_FAILED_INTERNAL_SERVER_ERROR"
        case validationFailedInvalidActiveDirectory = "VALIDATION_FAILED_INVALID_ACTIVE_DIRECTORY"
        case validationFailedInvalidSecurityGroupAssociation = "VALIDATION_FAILED_INVALID_SECURITY_GROUP_ASSOCIATION"
        case validationFailedInvalidSubnetRouteTableAssociation = "VALIDATION_FAILED_INVALID_SUBNET_ROUTE_TABLE_ASSOCIATION"
        case validationFailedSubnetNotFound = "VALIDATION_FAILED_SUBNET_NOT_FOUND"
        case validationFailedUnauthorized = "VALIDATION_FAILED_UNAUTHORIZED"
        case validationInProgress = "VALIDATION_IN_PROGRESS"
        case validationNotStarted = "VALIDATION_NOT_STARTED"
        case validationSuccess = "VALIDATION_SUCCESS"
        public var description: String { return self.rawValue }
    }

    public enum LaunchProfileValidationType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case validateActiveDirectoryStudioComponent = "VALIDATE_ACTIVE_DIRECTORY_STUDIO_COMPONENT"
        case validateNetworkAclAssociation = "VALIDATE_NETWORK_ACL_ASSOCIATION"
        case validateSecurityGroupAssociation = "VALIDATE_SECURITY_GROUP_ASSOCIATION"
        case validateSubnetAssociation = "VALIDATE_SUBNET_ASSOCIATION"
        public var description: String { return self.rawValue }
    }

    public enum SessionBackupMode: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case automatic = "AUTOMATIC"
        case deactivated = "DEACTIVATED"
        public var description: String { return self.rawValue }
    }

    public enum SessionPersistenceMode: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case activated = "ACTIVATED"
        case deactivated = "DEACTIVATED"
        public var description: String { return self.rawValue }
    }

    public enum StreamingClipboardMode: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case disabled = "DISABLED"
        case enabled = "ENABLED"
        public var description: String { return self.rawValue }
    }

    public enum StreamingImageEncryptionConfigurationKeyType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case customerManagedKey = "CUSTOMER_MANAGED_KEY"
        public var description: String { return self.rawValue }
    }

    public enum StreamingImageState: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case createFailed = "CREATE_FAILED"
        case createInProgress = "CREATE_IN_PROGRESS"
        case deleteFailed = "DELETE_FAILED"
        case deleteInProgress = "DELETE_IN_PROGRESS"
        case deleted = "DELETED"
        case ready = "READY"
        case updateFailed = "UPDATE_FAILED"
        case updateInProgress = "UPDATE_IN_PROGRESS"
        public var description: String { return self.rawValue }
    }

    public enum StreamingImageStatusCode: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case accessDenied = "ACCESS_DENIED"
        case internalError = "INTERNAL_ERROR"
        case streamingImageCreateInProgress = "STREAMING_IMAGE_CREATE_IN_PROGRESS"
        case streamingImageDeleteInProgress = "STREAMING_IMAGE_DELETE_IN_PROGRESS"
        case streamingImageDeleted = "STREAMING_IMAGE_DELETED"
        case streamingImageReady = "STREAMING_IMAGE_READY"
        case streamingImageUpdateInProgress = "STREAMING_IMAGE_UPDATE_IN_PROGRESS"
        public var description: String { return self.rawValue }
    }

    public enum StreamingInstanceType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case g34Xlarge = "g3.4xlarge"
        case g3sXlarge = "g3s.xlarge"
        case g4dn12Xlarge = "g4dn.12xlarge"
        case g4dn16Xlarge = "g4dn.16xlarge"
        case g4dn2Xlarge = "g4dn.2xlarge"
        case g4dn4Xlarge = "g4dn.4xlarge"
        case g4dn8Xlarge = "g4dn.8xlarge"
        case g4dnXlarge = "g4dn.xlarge"
        case g516Xlarge = "g5.16xlarge"
        case g52Xlarge = "g5.2xlarge"
        case g54Xlarge = "g5.4xlarge"
        case g58Xlarge = "g5.8xlarge"
        case g5Xlarge = "g5.xlarge"
        public var description: String { return self.rawValue }
    }

    public enum StreamingSessionState: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case createFailed = "CREATE_FAILED"
        case createInProgress = "CREATE_IN_PROGRESS"
        case deleteFailed = "DELETE_FAILED"
        case deleteInProgress = "DELETE_IN_PROGRESS"
        case deleted = "DELETED"
        case ready = "READY"
        case startFailed = "START_FAILED"
        case startInProgress = "START_IN_PROGRESS"
        case stopFailed = "STOP_FAILED"
        case stopInProgress = "STOP_IN_PROGRESS"
        case stopped = "STOPPED"
        public var description: String { return self.rawValue }
    }

    public enum StreamingSessionStatusCode: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case activeDirectoryDomainJoinError = "ACTIVE_DIRECTORY_DOMAIN_JOIN_ERROR"
        case amiValidationError = "AMI_VALIDATION_ERROR"
        case decryptStreamingImageError = "DECRYPT_STREAMING_IMAGE_ERROR"
        case initializationScriptError = "INITIALIZATION_SCRIPT_ERROR"
        case insufficientCapacity = "INSUFFICIENT_CAPACITY"
        case internalError = "INTERNAL_ERROR"
        case networkConnectionError = "NETWORK_CONNECTION_ERROR"
        case networkInterfaceError = "NETWORK_INTERFACE_ERROR"
        case streamingSessionCreateInProgress = "STREAMING_SESSION_CREATE_IN_PROGRESS"
        case streamingSessionDeleteInProgress = "STREAMING_SESSION_DELETE_IN_PROGRESS"
        case streamingSessionDeleted = "STREAMING_SESSION_DELETED"
        case streamingSessionReady = "STREAMING_SESSION_READY"
        case streamingSessionStartInProgress = "STREAMING_SESSION_START_IN_PROGRESS"
        case streamingSessionStarted = "STREAMING_SESSION_STARTED"
        case streamingSessionStopInProgress = "STREAMING_SESSION_STOP_IN_PROGRESS"
        case streamingSessionStopped = "STREAMING_SESSION_STOPPED"
        public var description: String { return self.rawValue }
    }

    public enum StreamingSessionStorageMode: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case upload = "UPLOAD"
        public var description: String { return self.rawValue }
    }

    public enum StreamingSessionStreamState: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case createFailed = "CREATE_FAILED"
        case createInProgress = "CREATE_IN_PROGRESS"
        case deleteFailed = "DELETE_FAILED"
        case deleteInProgress = "DELETE_IN_PROGRESS"
        case deleted = "DELETED"
        case ready = "READY"
        public var description: String { return self.rawValue }
    }

    public enum StreamingSessionStreamStatusCode: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case internalError = "INTERNAL_ERROR"
        case networkConnectionError = "NETWORK_CONNECTION_ERROR"
        case streamCreateInProgress = "STREAM_CREATE_IN_PROGRESS"
        case streamDeleteInProgress = "STREAM_DELETE_IN_PROGRESS"
        case streamDeleted = "STREAM_DELETED"
        case streamReady = "STREAM_READY"
        public var description: String { return self.rawValue }
    }

    public enum StudioComponentInitializationScriptRunContext: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case systemInitialization = "SYSTEM_INITIALIZATION"
        case userInitialization = "USER_INITIALIZATION"
        public var description: String { return self.rawValue }
    }

    public enum StudioComponentState: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case createFailed = "CREATE_FAILED"
        case createInProgress = "CREATE_IN_PROGRESS"
        case deleteFailed = "DELETE_FAILED"
        case deleteInProgress = "DELETE_IN_PROGRESS"
        case deleted = "DELETED"
        case ready = "READY"
        case updateFailed = "UPDATE_FAILED"
        case updateInProgress = "UPDATE_IN_PROGRESS"
        public var description: String { return self.rawValue }
    }

    public enum StudioComponentStatusCode: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case activeDirectoryAlreadyExists = "ACTIVE_DIRECTORY_ALREADY_EXISTS"
        case encryptionKeyAccessDenied = "ENCRYPTION_KEY_ACCESS_DENIED"
        case encryptionKeyNotFound = "ENCRYPTION_KEY_NOT_FOUND"
        case internalError = "INTERNAL_ERROR"
        case studioComponentCreateInProgress = "STUDIO_COMPONENT_CREATE_IN_PROGRESS"
        case studioComponentCreated = "STUDIO_COMPONENT_CREATED"
        case studioComponentDeleteInProgress = "STUDIO_COMPONENT_DELETE_IN_PROGRESS"
        case studioComponentDeleted = "STUDIO_COMPONENT_DELETED"
        case studioComponentUpdateInProgress = "STUDIO_COMPONENT_UPDATE_IN_PROGRESS"
        case studioComponentUpdated = "STUDIO_COMPONENT_UPDATED"
        public var description: String { return self.rawValue }
    }

    public enum StudioComponentSubtype: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case amazonFsxForLustre = "AMAZON_FSX_FOR_LUSTRE"
        case amazonFsxForWindows = "AMAZON_FSX_FOR_WINDOWS"
        case awsManagedMicrosoftAd = "AWS_MANAGED_MICROSOFT_AD"
        case custom = "CUSTOM"
        public var description: String { return self.rawValue }
    }

    public enum StudioComponentType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case activeDirectory = "ACTIVE_DIRECTORY"
        case computeFarm = "COMPUTE_FARM"
        case custom = "CUSTOM"
        case licenseService = "LICENSE_SERVICE"
        case sharedFileSystem = "SHARED_FILE_SYSTEM"
        public var description: String { return self.rawValue }
    }

    public enum StudioEncryptionConfigurationKeyType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case awsOwnedKey = "AWS_OWNED_KEY"
        case customerManagedKey = "CUSTOMER_MANAGED_KEY"
        public var description: String { return self.rawValue }
    }

    public enum StudioPersona: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case administrator = "ADMINISTRATOR"
        public var description: String { return self.rawValue }
    }

    public enum StudioState: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case createFailed = "CREATE_FAILED"
        case createInProgress = "CREATE_IN_PROGRESS"
        case deleteFailed = "DELETE_FAILED"
        case deleteInProgress = "DELETE_IN_PROGRESS"
        case deleted = "DELETED"
        case ready = "READY"
        case updateFailed = "UPDATE_FAILED"
        case updateInProgress = "UPDATE_IN_PROGRESS"
        public var description: String { return self.rawValue }
    }

    public enum StudioStatusCode: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case awsSsoAccessDenied = "AWS_SSO_ACCESS_DENIED"
        case awsSsoConfigurationRepairInProgress = "AWS_SSO_CONFIGURATION_REPAIR_IN_PROGRESS"
        case awsSsoConfigurationRepaired = "AWS_SSO_CONFIGURATION_REPAIRED"
        case awsSsoNotEnabled = "AWS_SSO_NOT_ENABLED"
        case awsStsRegionDisabled = "AWS_STS_REGION_DISABLED"
        case encryptionKeyAccessDenied = "ENCRYPTION_KEY_ACCESS_DENIED"
        case encryptionKeyNotFound = "ENCRYPTION_KEY_NOT_FOUND"
        case internalError = "INTERNAL_ERROR"
        case roleCouldNotBeAssumed = "ROLE_COULD_NOT_BE_ASSUMED"
        case roleNotOwnedByStudioOwner = "ROLE_NOT_OWNED_BY_STUDIO_OWNER"
        case studioCreateInProgress = "STUDIO_CREATE_IN_PROGRESS"
        case studioCreated = "STUDIO_CREATED"
        case studioDeleteInProgress = "STUDIO_DELETE_IN_PROGRESS"
        case studioDeleted = "STUDIO_DELETED"
        case studioUpdateInProgress = "STUDIO_UPDATE_IN_PROGRESS"
        case studioUpdated = "STUDIO_UPDATED"
        case studioWithLaunchProfilesNotDeleted = "STUDIO_WITH_LAUNCH_PROFILES_NOT_DELETED"
        case studioWithStreamingImagesNotDeleted = "STUDIO_WITH_STREAMING_IMAGES_NOT_DELETED"
        case studioWithStudioComponentsNotDeleted = "STUDIO_WITH_STUDIO_COMPONENTS_NOT_DELETED"
        public var description: String { return self.rawValue }
    }

    public enum VolumeRetentionMode: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case delete = "DELETE"
        case retain = "RETAIN"
        public var description: String { return self.rawValue }
    }

    public enum StudioComponentConfiguration: AWSEncodableShape & AWSDecodableShape, Sendable {
        /// The configuration for a Directory Service for Microsoft Active Directory studio resource.
        case activeDirectoryConfiguration(ActiveDirectoryConfiguration)
        /// The configuration for a render farm that is associated with a studio resource.
        case computeFarmConfiguration(ComputeFarmConfiguration)
        /// The configuration for a license service that is associated with a studio resource.
        case licenseServiceConfiguration(LicenseServiceConfiguration)
        /// The configuration for a shared file storage system that is associated with a studio resource.
        case sharedFileSystemConfiguration(SharedFileSystemConfiguration)

        public init(from decoder: Decoder) throws {
            let container = try decoder.container(keyedBy: CodingKeys.self)
            guard container.allKeys.count == 1, let key = container.allKeys.first else {
                let context = DecodingError.Context(
                    codingPath: container.codingPath,
                    debugDescription: "Expected exactly one key, but got \(container.allKeys.count)"
                )
                throw DecodingError.dataCorrupted(context)
            }
            switch key {
            case .activeDirectoryConfiguration:
                let value = try container.decode(ActiveDirectoryConfiguration.self, forKey: .activeDirectoryConfiguration)
                self = .activeDirectoryConfiguration(value)
            case .computeFarmConfiguration:
                let value = try container.decode(ComputeFarmConfiguration.self, forKey: .computeFarmConfiguration)
                self = .computeFarmConfiguration(value)
            case .licenseServiceConfiguration:
                let value = try container.decode(LicenseServiceConfiguration.self, forKey: .licenseServiceConfiguration)
                self = .licenseServiceConfiguration(value)
            case .sharedFileSystemConfiguration:
                let value = try container.decode(SharedFileSystemConfiguration.self, forKey: .sharedFileSystemConfiguration)
                self = .sharedFileSystemConfiguration(value)
            }
        }

        public func encode(to encoder: Encoder) throws {
            var container = encoder.container(keyedBy: CodingKeys.self)
            switch self {
            case .activeDirectoryConfiguration(let value):
                try container.encode(value, forKey: .activeDirectoryConfiguration)
            case .computeFarmConfiguration(let value):
                try container.encode(value, forKey: .computeFarmConfiguration)
            case .licenseServiceConfiguration(let value):
                try container.encode(value, forKey: .licenseServiceConfiguration)
            case .sharedFileSystemConfiguration(let value):
                try container.encode(value, forKey: .sharedFileSystemConfiguration)
            }
        }

        public func validate(name: String) throws {
            switch self {
            case .activeDirectoryConfiguration(let value):
                try value.validate(name: "\(name).activeDirectoryConfiguration")
            case .sharedFileSystemConfiguration(let value):
                try value.validate(name: "\(name).sharedFileSystemConfiguration")
            default:
                break
            }
        }

        private enum CodingKeys: String, CodingKey {
            case activeDirectoryConfiguration = "activeDirectoryConfiguration"
            case computeFarmConfiguration = "computeFarmConfiguration"
            case licenseServiceConfiguration = "licenseServiceConfiguration"
            case sharedFileSystemConfiguration = "sharedFileSystemConfiguration"
        }
    }

    // MARK: Shapes

    public struct AcceptEulasRequest: AWSEncodableShape {
        /// Unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If you don’t specify a client token, the Amazon Web Services SDK automatically generates a client token and uses it for the request to ensure idempotency.
        public let clientToken: String?
        /// The EULA ID.
        public let eulaIds: [String]?
        /// The studio ID.
        public let studioId: String

        public init(clientToken: String? = AcceptEulasRequest.idempotencyToken(), eulaIds: [String]? = nil, studioId: String) {
            self.clientToken = clientToken
            self.eulaIds = eulaIds
            self.studioId = studioId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodeHeader(self.clientToken, key: "X-Amz-Client-Token")
            try container.encodeIfPresent(self.eulaIds, forKey: .eulaIds)
            request.encodePath(self.studioId, key: "studioId")
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 64)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case eulaIds = "eulaIds"
        }
    }

    public struct AcceptEulasResponse: AWSDecodableShape {
        /// A collection of EULA acceptances.
        public let eulaAcceptances: [EulaAcceptance]?

        public init(eulaAcceptances: [EulaAcceptance]? = nil) {
            self.eulaAcceptances = eulaAcceptances
        }

        private enum CodingKeys: String, CodingKey {
            case eulaAcceptances = "eulaAcceptances"
        }
    }

    public struct ActiveDirectoryComputerAttribute: AWSEncodableShape & AWSDecodableShape {
        /// The name for the LDAP attribute.
        public let name: String?
        /// The value for the LDAP attribute.
        public let value: String?

        public init(name: String? = nil, value: String? = nil) {
            self.name = name
            self.value = value
        }

        public func validate(name: String) throws {
            try self.validate(self.name, name: "name", parent: name, max: 40)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.value, name: "value", parent: name, max: 64)
            try self.validate(self.value, name: "value", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case name = "name"
            case value = "value"
        }
    }

    public struct ActiveDirectoryConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// A collection of custom attributes for an Active Directory computer.
        public let computerAttributes: [ActiveDirectoryComputerAttribute]?
        /// The directory ID of the Directory Service for Microsoft Active Directory to access using this studio component.
        public let directoryId: String?
        /// The distinguished name (DN) and organizational unit (OU) of an Active Directory computer.
        public let organizationalUnitDistinguishedName: String?

        public init(computerAttributes: [ActiveDirectoryComputerAttribute]? = nil, directoryId: String? = nil, organizationalUnitDistinguishedName: String? = nil) {
            self.computerAttributes = computerAttributes
            self.directoryId = directoryId
            self.organizationalUnitDistinguishedName = organizationalUnitDistinguishedName
        }

        public func validate(name: String) throws {
            try self.computerAttributes?.forEach {
                try $0.validate(name: "\(name).computerAttributes[]")
            }
            try self.validate(self.computerAttributes, name: "computerAttributes", parent: name, max: 50)
            try self.validate(self.organizationalUnitDistinguishedName, name: "organizationalUnitDistinguishedName", parent: name, max: 2000)
            try self.validate(self.organizationalUnitDistinguishedName, name: "organizationalUnitDistinguishedName", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case computerAttributes = "computerAttributes"
            case directoryId = "directoryId"
            case organizationalUnitDistinguishedName = "organizationalUnitDistinguishedName"
        }
    }

    public struct ComputeFarmConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The name of an Active Directory user that is used on ComputeFarm worker instances.
        public let activeDirectoryUser: String?
        /// The endpoint of the ComputeFarm that is accessed by the studio component resource.
        public let endpoint: String?

        public init(activeDirectoryUser: String? = nil, endpoint: String? = nil) {
            self.activeDirectoryUser = activeDirectoryUser
            self.endpoint = endpoint
        }

        private enum CodingKeys: String, CodingKey {
            case activeDirectoryUser = "activeDirectoryUser"
            case endpoint = "endpoint"
        }
    }

    public struct CreateLaunchProfileRequest: AWSEncodableShape {
        /// Unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If you don’t specify a client token, the Amazon Web Services SDK automatically generates a client token and uses it for the request to ensure idempotency.
        public let clientToken: String?
        /// The description.
        public let description: String?
        /// Specifies the IDs of the EC2 subnets where streaming sessions will be accessible from. These subnets must support the specified instance types.
        public let ec2SubnetIds: [String]
        /// The version number of the protocol that is used by the launch profile. The only valid version is "2021-03-31".
        public let launchProfileProtocolVersions: [String]
        /// The name for the launch profile.
        public let name: String
        /// A configuration for a streaming session.
        public let streamConfiguration: StreamConfigurationCreate
        /// Unique identifiers for a collection of studio components that can be used with this launch profile.
        public let studioComponentIds: [String]
        /// The studio ID.
        public let studioId: String
        /// A collection of labels, in the form of key-value pairs, that apply to this resource.
        public let tags: [String: String]?

        public init(clientToken: String? = CreateLaunchProfileRequest.idempotencyToken(), description: String? = nil, ec2SubnetIds: [String], launchProfileProtocolVersions: [String], name: String, streamConfiguration: StreamConfigurationCreate, studioComponentIds: [String], studioId: String, tags: [String: String]? = nil) {
            self.clientToken = clientToken
            self.description = description
            self.ec2SubnetIds = ec2SubnetIds
            self.launchProfileProtocolVersions = launchProfileProtocolVersions
            self.name = name
            self.streamConfiguration = streamConfiguration
            self.studioComponentIds = studioComponentIds
            self.studioId = studioId
            self.tags = tags
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodeHeader(self.clientToken, key: "X-Amz-Client-Token")
            try container.encodeIfPresent(self.description, forKey: .description)
            try container.encode(self.ec2SubnetIds, forKey: .ec2SubnetIds)
            try container.encode(self.launchProfileProtocolVersions, forKey: .launchProfileProtocolVersions)
            try container.encode(self.name, forKey: .name)
            try container.encode(self.streamConfiguration, forKey: .streamConfiguration)
            try container.encode(self.studioComponentIds, forKey: .studioComponentIds)
            request.encodePath(self.studioId, key: "studioId")
            try container.encodeIfPresent(self.tags, forKey: .tags)
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 64)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.validate(self.description, name: "description", parent: name, max: 256)
            try self.validate(self.ec2SubnetIds, name: "ec2SubnetIds", parent: name, max: 6)
            try self.launchProfileProtocolVersions.forEach {
                try validate($0, name: "launchProfileProtocolVersions[]", parent: name, max: 10)
                try validate($0, name: "launchProfileProtocolVersions[]", parent: name, pattern: "^2021\\-03\\-31$")
            }
            try self.validate(self.name, name: "name", parent: name, max: 64)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.streamConfiguration.validate(name: "\(name).streamConfiguration")
            try self.validate(self.studioComponentIds, name: "studioComponentIds", parent: name, max: 100)
            try self.validate(self.studioComponentIds, name: "studioComponentIds", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case description = "description"
            case ec2SubnetIds = "ec2SubnetIds"
            case launchProfileProtocolVersions = "launchProfileProtocolVersions"
            case name = "name"
            case streamConfiguration = "streamConfiguration"
            case studioComponentIds = "studioComponentIds"
            case tags = "tags"
        }
    }

    public struct CreateLaunchProfileResponse: AWSDecodableShape {
        /// The launch profile.
        public let launchProfile: LaunchProfile?

        public init(launchProfile: LaunchProfile? = nil) {
            self.launchProfile = launchProfile
        }

        private enum CodingKeys: String, CodingKey {
            case launchProfile = "launchProfile"
        }
    }

    public struct CreateStreamingImageRequest: AWSEncodableShape {
        /// Unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If you don’t specify a client token, the Amazon Web Services SDK automatically generates a client token and uses it for the request to ensure idempotency.
        public let clientToken: String?
        /// A human-readable description of the streaming image.
        public let description: String?
        /// The ID of an EC2 machine image with which to create this streaming image.
        public let ec2ImageId: String
        /// A friendly name for a streaming image resource.
        public let name: String
        /// The studio ID.
        public let studioId: String
        /// A collection of labels, in the form of key-value pairs, that apply to this resource.
        public let tags: [String: String]?

        public init(clientToken: String? = CreateStreamingImageRequest.idempotencyToken(), description: String? = nil, ec2ImageId: String, name: String, studioId: String, tags: [String: String]? = nil) {
            self.clientToken = clientToken
            self.description = description
            self.ec2ImageId = ec2ImageId
            self.name = name
            self.studioId = studioId
            self.tags = tags
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodeHeader(self.clientToken, key: "X-Amz-Client-Token")
            try container.encodeIfPresent(self.description, forKey: .description)
            try container.encode(self.ec2ImageId, forKey: .ec2ImageId)
            try container.encode(self.name, forKey: .name)
            request.encodePath(self.studioId, key: "studioId")
            try container.encodeIfPresent(self.tags, forKey: .tags)
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 64)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.validate(self.description, name: "description", parent: name, max: 256)
            try self.validate(self.ec2ImageId, name: "ec2ImageId", parent: name, pattern: "^ami-[0-9A-z]+$")
            try self.validate(self.name, name: "name", parent: name, max: 64)
        }

        private enum CodingKeys: String, CodingKey {
            case description = "description"
            case ec2ImageId = "ec2ImageId"
            case name = "name"
            case tags = "tags"
        }
    }

    public struct CreateStreamingImageResponse: AWSDecodableShape {
        /// The streaming image.
        public let streamingImage: StreamingImage?

        public init(streamingImage: StreamingImage? = nil) {
            self.streamingImage = streamingImage
        }

        private enum CodingKeys: String, CodingKey {
            case streamingImage = "streamingImage"
        }
    }

    public struct CreateStreamingSessionRequest: AWSEncodableShape {
        /// Unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If you don’t specify a client token, the Amazon Web Services SDK automatically generates a client token and uses it for the request to ensure idempotency.
        public let clientToken: String?
        /// The EC2 Instance type used for the streaming session.
        public let ec2InstanceType: StreamingInstanceType?
        /// The ID of the launch profile used to control access from the streaming session.
        public let launchProfileId: String
        /// The user ID of the user that owns the streaming session. The user that owns the session will be logging into the session and interacting with the virtual workstation.
        public let ownedBy: String?
        /// The ID of the streaming image.
        public let streamingImageId: String?
        /// The studio ID.
        public let studioId: String
        /// A collection of labels, in the form of key-value pairs, that apply to this resource.
        public let tags: [String: String]?

        public init(clientToken: String? = CreateStreamingSessionRequest.idempotencyToken(), ec2InstanceType: StreamingInstanceType? = nil, launchProfileId: String, ownedBy: String? = nil, streamingImageId: String? = nil, studioId: String, tags: [String: String]? = nil) {
            self.clientToken = clientToken
            self.ec2InstanceType = ec2InstanceType
            self.launchProfileId = launchProfileId
            self.ownedBy = ownedBy
            self.streamingImageId = streamingImageId
            self.studioId = studioId
            self.tags = tags
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodeHeader(self.clientToken, key: "X-Amz-Client-Token")
            try container.encodeIfPresent(self.ec2InstanceType, forKey: .ec2InstanceType)
            try container.encode(self.launchProfileId, forKey: .launchProfileId)
            try container.encodeIfPresent(self.ownedBy, forKey: .ownedBy)
            try container.encodeIfPresent(self.streamingImageId, forKey: .streamingImageId)
            request.encodePath(self.studioId, key: "studioId")
            try container.encodeIfPresent(self.tags, forKey: .tags)
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 64)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.validate(self.streamingImageId, name: "streamingImageId", parent: name, max: 22)
            try self.validate(self.streamingImageId, name: "streamingImageId", parent: name, pattern: "^[a-zA-Z0-9-_]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case ec2InstanceType = "ec2InstanceType"
            case launchProfileId = "launchProfileId"
            case ownedBy = "ownedBy"
            case streamingImageId = "streamingImageId"
            case tags = "tags"
        }
    }

    public struct CreateStreamingSessionResponse: AWSDecodableShape {
        /// The session.
        public let session: StreamingSession?

        public init(session: StreamingSession? = nil) {
            self.session = session
        }

        private enum CodingKeys: String, CodingKey {
            case session = "session"
        }
    }

    public struct CreateStreamingSessionStreamRequest: AWSEncodableShape {
        /// Unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If you don’t specify a client token, the Amazon Web Services SDK automatically generates a client token and uses it for the request to ensure idempotency.
        public let clientToken: String?
        /// The expiration time in seconds.
        public let expirationInSeconds: Int?
        /// The streaming session ID.
        public let sessionId: String
        /// The studio ID.
        public let studioId: String

        public init(clientToken: String? = CreateStreamingSessionStreamRequest.idempotencyToken(), expirationInSeconds: Int? = nil, sessionId: String, studioId: String) {
            self.clientToken = clientToken
            self.expirationInSeconds = expirationInSeconds
            self.sessionId = sessionId
            self.studioId = studioId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodeHeader(self.clientToken, key: "X-Amz-Client-Token")
            try container.encodeIfPresent(self.expirationInSeconds, forKey: .expirationInSeconds)
            request.encodePath(self.sessionId, key: "sessionId")
            request.encodePath(self.studioId, key: "studioId")
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 64)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.validate(self.expirationInSeconds, name: "expirationInSeconds", parent: name, max: 3600)
            try self.validate(self.expirationInSeconds, name: "expirationInSeconds", parent: name, min: 60)
        }

        private enum CodingKeys: String, CodingKey {
            case expirationInSeconds = "expirationInSeconds"
        }
    }

    public struct CreateStreamingSessionStreamResponse: AWSDecodableShape {
        /// The stream.
        public let stream: StreamingSessionStream?

        public init(stream: StreamingSessionStream? = nil) {
            self.stream = stream
        }

        private enum CodingKeys: String, CodingKey {
            case stream = "stream"
        }
    }

    public struct CreateStudioComponentRequest: AWSEncodableShape {
        /// Unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If you don’t specify a client token, the Amazon Web Services SDK automatically generates a client token and uses it for the request to ensure idempotency.
        public let clientToken: String?
        /// The configuration of the studio component, based on component type.
        public let configuration: StudioComponentConfiguration?
        /// The description.
        public let description: String?
        /// The EC2 security groups that control access to the studio component.
        public let ec2SecurityGroupIds: [String]?
        /// Initialization scripts for studio components.
        public let initializationScripts: [StudioComponentInitializationScript]?
        /// The name for the studio component.
        public let name: String
        /// An IAM role attached to a Studio Component that gives the studio component access to Amazon Web Services resources at anytime while the instance is running.
        public let runtimeRoleArn: String?
        /// Parameters for the studio component scripts.
        public let scriptParameters: [ScriptParameterKeyValue]?
        /// An IAM role attached to Studio Component when the system initialization script runs which give the studio component access to Amazon Web Services resources when the system initialization script runs.
        public let secureInitializationRoleArn: String?
        /// The studio ID.
        public let studioId: String
        /// The specific subtype of a studio component.
        public let subtype: StudioComponentSubtype?
        /// A collection of labels, in the form of key-value pairs, that apply to this resource.
        public let tags: [String: String]?
        /// The type of the studio component.
        public let type: StudioComponentType

        public init(clientToken: String? = CreateStudioComponentRequest.idempotencyToken(), configuration: StudioComponentConfiguration? = nil, description: String? = nil, ec2SecurityGroupIds: [String]? = nil, initializationScripts: [StudioComponentInitializationScript]? = nil, name: String, runtimeRoleArn: String? = nil, scriptParameters: [ScriptParameterKeyValue]? = nil, secureInitializationRoleArn: String? = nil, studioId: String, subtype: StudioComponentSubtype? = nil, tags: [String: String]? = nil, type: StudioComponentType) {
            self.clientToken = clientToken
            self.configuration = configuration
            self.description = description
            self.ec2SecurityGroupIds = ec2SecurityGroupIds
            self.initializationScripts = initializationScripts
            self.name = name
            self.runtimeRoleArn = runtimeRoleArn
            self.scriptParameters = scriptParameters
            self.secureInitializationRoleArn = secureInitializationRoleArn
            self.studioId = studioId
            self.subtype = subtype
            self.tags = tags
            self.type = type
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodeHeader(self.clientToken, key: "X-Amz-Client-Token")
            try container.encodeIfPresent(self.configuration, forKey: .configuration)
            try container.encodeIfPresent(self.description, forKey: .description)
            try container.encodeIfPresent(self.ec2SecurityGroupIds, forKey: .ec2SecurityGroupIds)
            try container.encodeIfPresent(self.initializationScripts, forKey: .initializationScripts)
            try container.encode(self.name, forKey: .name)
            try container.encodeIfPresent(self.runtimeRoleArn, forKey: .runtimeRoleArn)
            try container.encodeIfPresent(self.scriptParameters, forKey: .scriptParameters)
            try container.encodeIfPresent(self.secureInitializationRoleArn, forKey: .secureInitializationRoleArn)
            request.encodePath(self.studioId, key: "studioId")
            try container.encodeIfPresent(self.subtype, forKey: .subtype)
            try container.encodeIfPresent(self.tags, forKey: .tags)
            try container.encode(self.type, forKey: .type)
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 64)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.configuration?.validate(name: "\(name).configuration")
            try self.validate(self.description, name: "description", parent: name, max: 256)
            try self.validate(self.ec2SecurityGroupIds, name: "ec2SecurityGroupIds", parent: name, max: 30)
            try self.initializationScripts?.forEach {
                try $0.validate(name: "\(name).initializationScripts[]")
            }
            try self.validate(self.name, name: "name", parent: name, max: 64)
            try self.validate(self.runtimeRoleArn, name: "runtimeRoleArn", parent: name, max: 2048)
            try self.scriptParameters?.forEach {
                try $0.validate(name: "\(name).scriptParameters[]")
            }
            try self.validate(self.scriptParameters, name: "scriptParameters", parent: name, max: 30)
            try self.validate(self.secureInitializationRoleArn, name: "secureInitializationRoleArn", parent: name, max: 2048)
        }

        private enum CodingKeys: String, CodingKey {
            case configuration = "configuration"
            case description = "description"
            case ec2SecurityGroupIds = "ec2SecurityGroupIds"
            case initializationScripts = "initializationScripts"
            case name = "name"
            case runtimeRoleArn = "runtimeRoleArn"
            case scriptParameters = "scriptParameters"
            case secureInitializationRoleArn = "secureInitializationRoleArn"
            case subtype = "subtype"
            case tags = "tags"
            case type = "type"
        }
    }

    public struct CreateStudioComponentResponse: AWSDecodableShape {
        /// Information about the studio component.
        public let studioComponent: StudioComponent?

        public init(studioComponent: StudioComponent? = nil) {
            self.studioComponent = studioComponent
        }

        private enum CodingKeys: String, CodingKey {
            case studioComponent = "studioComponent"
        }
    }

    public struct CreateStudioRequest: AWSEncodableShape {
        /// The IAM role that studio admins will assume when logging in to the Nimble Studio portal.
        public let adminRoleArn: String
        /// Unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If you don’t specify a client token, the Amazon Web Services SDK automatically generates a client token and uses it for the request to ensure idempotency.
        public let clientToken: String?
        /// A friendly name for the studio.
        public let displayName: String
        /// The studio encryption configuration.
        public let studioEncryptionConfiguration: StudioEncryptionConfiguration?
        /// The studio name that is used in the URL of the Nimble Studio portal when accessed by Nimble Studio users.
        public let studioName: String
        /// A collection of labels, in the form of key-value pairs, that apply to this resource.
        public let tags: [String: String]?
        /// The IAM role that studio users will assume when logging in to the Nimble Studio portal.
        public let userRoleArn: String

        public init(adminRoleArn: String, clientToken: String? = CreateStudioRequest.idempotencyToken(), displayName: String, studioEncryptionConfiguration: StudioEncryptionConfiguration? = nil, studioName: String, tags: [String: String]? = nil, userRoleArn: String) {
            self.adminRoleArn = adminRoleArn
            self.clientToken = clientToken
            self.displayName = displayName
            self.studioEncryptionConfiguration = studioEncryptionConfiguration
            self.studioName = studioName
            self.tags = tags
            self.userRoleArn = userRoleArn
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encode(self.adminRoleArn, forKey: .adminRoleArn)
            request.encodeHeader(self.clientToken, key: "X-Amz-Client-Token")
            try container.encode(self.displayName, forKey: .displayName)
            try container.encodeIfPresent(self.studioEncryptionConfiguration, forKey: .studioEncryptionConfiguration)
            try container.encode(self.studioName, forKey: .studioName)
            try container.encodeIfPresent(self.tags, forKey: .tags)
            try container.encode(self.userRoleArn, forKey: .userRoleArn)
        }

        public func validate(name: String) throws {
            try self.validate(self.adminRoleArn, name: "adminRoleArn", parent: name, max: 2048)
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 64)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.validate(self.displayName, name: "displayName", parent: name, max: 64)
            try self.studioEncryptionConfiguration?.validate(name: "\(name).studioEncryptionConfiguration")
            try self.validate(self.studioName, name: "studioName", parent: name, max: 64)
            try self.validate(self.studioName, name: "studioName", parent: name, min: 3)
            try self.validate(self.studioName, name: "studioName", parent: name, pattern: "^[a-z0-9]*$")
            try self.validate(self.userRoleArn, name: "userRoleArn", parent: name, max: 2048)
        }

        private enum CodingKeys: String, CodingKey {
            case adminRoleArn = "adminRoleArn"
            case displayName = "displayName"
            case studioEncryptionConfiguration = "studioEncryptionConfiguration"
            case studioName = "studioName"
            case tags = "tags"
            case userRoleArn = "userRoleArn"
        }
    }

    public struct CreateStudioResponse: AWSDecodableShape {
        /// Information about a studio.
        public let studio: Studio?

        public init(studio: Studio? = nil) {
            self.studio = studio
        }

        private enum CodingKeys: String, CodingKey {
            case studio = "studio"
        }
    }

    public struct DeleteLaunchProfileMemberRequest: AWSEncodableShape {
        /// Unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If you don’t specify a client token, the Amazon Web Services SDK automatically generates a client token and uses it for the request to ensure idempotency.
        public let clientToken: String?
        /// The ID of the launch profile used to control access from the streaming session.
        public let launchProfileId: String
        /// The principal ID. This currently supports a IAM Identity Center UserId.
        public let principalId: String
        /// The studio ID.
        public let studioId: String

        public init(clientToken: String? = DeleteLaunchProfileMemberRequest.idempotencyToken(), launchProfileId: String, principalId: String, studioId: String) {
            self.clientToken = clientToken
            self.launchProfileId = launchProfileId
            self.principalId = principalId
            self.studioId = studioId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeHeader(self.clientToken, key: "X-Amz-Client-Token")
            request.encodePath(self.launchProfileId, key: "launchProfileId")
            request.encodePath(self.principalId, key: "principalId")
            request.encodePath(self.studioId, key: "studioId")
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 64)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteLaunchProfileMemberResponse: AWSDecodableShape {
        public init() {}
    }

    public struct DeleteLaunchProfileRequest: AWSEncodableShape {
        /// Unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If you don’t specify a client token, the Amazon Web Services SDK automatically generates a client token and uses it for the request to ensure idempotency.
        public let clientToken: String?
        /// The ID of the launch profile used to control access from the streaming session.
        public let launchProfileId: String
        /// The studio ID.
        public let studioId: String

        public init(clientToken: String? = DeleteLaunchProfileRequest.idempotencyToken(), launchProfileId: String, studioId: String) {
            self.clientToken = clientToken
            self.launchProfileId = launchProfileId
            self.studioId = studioId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeHeader(self.clientToken, key: "X-Amz-Client-Token")
            request.encodePath(self.launchProfileId, key: "launchProfileId")
            request.encodePath(self.studioId, key: "studioId")
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 64)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteLaunchProfileResponse: AWSDecodableShape {
        /// The launch profile.
        public let launchProfile: LaunchProfile?

        public init(launchProfile: LaunchProfile? = nil) {
            self.launchProfile = launchProfile
        }

        private enum CodingKeys: String, CodingKey {
            case launchProfile = "launchProfile"
        }
    }

    public struct DeleteStreamingImageRequest: AWSEncodableShape {
        /// Unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If you don’t specify a client token, the Amazon Web Services SDK automatically generates a client token and uses it for the request to ensure idempotency.
        public let clientToken: String?
        /// The streaming image ID.
        public let streamingImageId: String
        /// The studio ID.
        public let studioId: String

        public init(clientToken: String? = DeleteStreamingImageRequest.idempotencyToken(), streamingImageId: String, studioId: String) {
            self.clientToken = clientToken
            self.streamingImageId = streamingImageId
            self.studioId = studioId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeHeader(self.clientToken, key: "X-Amz-Client-Token")
            request.encodePath(self.streamingImageId, key: "streamingImageId")
            request.encodePath(self.studioId, key: "studioId")
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 64)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteStreamingImageResponse: AWSDecodableShape {
        /// The streaming image.
        public let streamingImage: StreamingImage?

        public init(streamingImage: StreamingImage? = nil) {
            self.streamingImage = streamingImage
        }

        private enum CodingKeys: String, CodingKey {
            case streamingImage = "streamingImage"
        }
    }

    public struct DeleteStreamingSessionRequest: AWSEncodableShape {
        /// Unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If you don’t specify a client token, the Amazon Web Services SDK automatically generates a client token and uses it for the request to ensure idempotency.
        public let clientToken: String?
        /// The streaming session ID.
        public let sessionId: String
        /// The studio ID.
        public let studioId: String

        public init(clientToken: String? = DeleteStreamingSessionRequest.idempotencyToken(), sessionId: String, studioId: String) {
            self.clientToken = clientToken
            self.sessionId = sessionId
            self.studioId = studioId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeHeader(self.clientToken, key: "X-Amz-Client-Token")
            request.encodePath(self.sessionId, key: "sessionId")
            request.encodePath(self.studioId, key: "studioId")
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 64)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteStreamingSessionResponse: AWSDecodableShape {
        /// The session.
        public let session: StreamingSession?

        public init(session: StreamingSession? = nil) {
            self.session = session
        }

        private enum CodingKeys: String, CodingKey {
            case session = "session"
        }
    }

    public struct DeleteStudioComponentRequest: AWSEncodableShape {
        /// Unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If you don’t specify a client token, the Amazon Web Services SDK automatically generates a client token and uses it for the request to ensure idempotency.
        public let clientToken: String?
        /// The studio component ID.
        public let studioComponentId: String
        /// The studio ID.
        public let studioId: String

        public init(clientToken: String? = DeleteStudioComponentRequest.idempotencyToken(), studioComponentId: String, studioId: String) {
            self.clientToken = clientToken
            self.studioComponentId = studioComponentId
            self.studioId = studioId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeHeader(self.clientToken, key: "X-Amz-Client-Token")
            request.encodePath(self.studioComponentId, key: "studioComponentId")
            request.encodePath(self.studioId, key: "studioId")
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 64)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteStudioComponentResponse: AWSDecodableShape {
        /// Information about the studio component.
        public let studioComponent: StudioComponent?

        public init(studioComponent: StudioComponent? = nil) {
            self.studioComponent = studioComponent
        }

        private enum CodingKeys: String, CodingKey {
            case studioComponent = "studioComponent"
        }
    }

    public struct DeleteStudioMemberRequest: AWSEncodableShape {
        /// Unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If you don’t specify a client token, the Amazon Web Services SDK automatically generates a client token and uses it for the request to ensure idempotency.
        public let clientToken: String?
        /// The principal ID. This currently supports a IAM Identity Center UserId.
        public let principalId: String
        /// The studio ID.
        public let studioId: String

        public init(clientToken: String? = DeleteStudioMemberRequest.idempotencyToken(), principalId: String, studioId: String) {
            self.clientToken = clientToken
            self.principalId = principalId
            self.studioId = studioId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeHeader(self.clientToken, key: "X-Amz-Client-Token")
            request.encodePath(self.principalId, key: "principalId")
            request.encodePath(self.studioId, key: "studioId")
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 64)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteStudioMemberResponse: AWSDecodableShape {
        public init() {}
    }

    public struct DeleteStudioRequest: AWSEncodableShape {
        /// Unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If you don’t specify a client token, the Amazon Web Services SDK automatically generates a client token and uses it for the request to ensure idempotency.
        public let clientToken: String?
        /// The studio ID.
        public let studioId: String

        public init(clientToken: String? = DeleteStudioRequest.idempotencyToken(), studioId: String) {
            self.clientToken = clientToken
            self.studioId = studioId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeHeader(self.clientToken, key: "X-Amz-Client-Token")
            request.encodePath(self.studioId, key: "studioId")
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 64)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteStudioResponse: AWSDecodableShape {
        /// Information about a studio.
        public let studio: Studio

        public init(studio: Studio) {
            self.studio = studio
        }

        private enum CodingKeys: String, CodingKey {
            case studio = "studio"
        }
    }

    public struct Eula: AWSDecodableShape {
        /// The EULA content.
        public let content: String?
        /// The ISO timestamp in seconds for when the resource was created.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var createdAt: Date?
        /// The EULA ID.
        public let eulaId: String?
        /// The name for the EULA.
        public let name: String?
        /// The ISO timestamp in seconds for when the resource was updated.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var updatedAt: Date?

        public init(content: String? = nil, createdAt: Date? = nil, eulaId: String? = nil, name: String? = nil, updatedAt: Date? = nil) {
            self.content = content
            self.createdAt = createdAt
            self.eulaId = eulaId
            self.name = name
            self.updatedAt = updatedAt
        }

        private enum CodingKeys: String, CodingKey {
            case content = "content"
            case createdAt = "createdAt"
            case eulaId = "eulaId"
            case name = "name"
            case updatedAt = "updatedAt"
        }
    }

    public struct EulaAcceptance: AWSDecodableShape {
        /// The ISO timestamp in seconds for when the EULA was accepted.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var acceptedAt: Date?
        /// The ID of the person who accepted the EULA.
        public let acceptedBy: String?
        /// The ID of the acceptee.
        public let accepteeId: String?
        /// The EULA acceptance ID.
        public let eulaAcceptanceId: String?
        /// The EULA ID.
        public let eulaId: String?

        public init(acceptedAt: Date? = nil, acceptedBy: String? = nil, accepteeId: String? = nil, eulaAcceptanceId: String? = nil, eulaId: String? = nil) {
            self.acceptedAt = acceptedAt
            self.acceptedBy = acceptedBy
            self.accepteeId = accepteeId
            self.eulaAcceptanceId = eulaAcceptanceId
            self.eulaId = eulaId
        }

        private enum CodingKeys: String, CodingKey {
            case acceptedAt = "acceptedAt"
            case acceptedBy = "acceptedBy"
            case accepteeId = "accepteeId"
            case eulaAcceptanceId = "eulaAcceptanceId"
            case eulaId = "eulaId"
        }
    }

    public struct GetEulaRequest: AWSEncodableShape {
        /// The EULA ID.
        public let eulaId: String

        public init(eulaId: String) {
            self.eulaId = eulaId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.eulaId, key: "eulaId")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetEulaResponse: AWSDecodableShape {
        /// The EULA.
        public let eula: Eula?

        public init(eula: Eula? = nil) {
            self.eula = eula
        }

        private enum CodingKeys: String, CodingKey {
            case eula = "eula"
        }
    }

    public struct GetLaunchProfileDetailsRequest: AWSEncodableShape {
        /// The ID of the launch profile used to control access from the streaming session.
        public let launchProfileId: String
        /// The studio ID.
        public let studioId: String

        public init(launchProfileId: String, studioId: String) {
            self.launchProfileId = launchProfileId
            self.studioId = studioId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.launchProfileId, key: "launchProfileId")
            request.encodePath(self.studioId, key: "studioId")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetLaunchProfileDetailsResponse: AWSDecodableShape {
        /// The launch profile.
        public let launchProfile: LaunchProfile?
        /// A collection of streaming images.
        public let streamingImages: [StreamingImage]?
        /// A collection of studio component summaries.
        public let studioComponentSummaries: [StudioComponentSummary]?

        public init(launchProfile: LaunchProfile? = nil, streamingImages: [StreamingImage]? = nil, studioComponentSummaries: [StudioComponentSummary]? = nil) {
            self.launchProfile = launchProfile
            self.streamingImages = streamingImages
            self.studioComponentSummaries = studioComponentSummaries
        }

        private enum CodingKeys: String, CodingKey {
            case launchProfile = "launchProfile"
            case streamingImages = "streamingImages"
            case studioComponentSummaries = "studioComponentSummaries"
        }
    }

    public struct GetLaunchProfileInitializationRequest: AWSEncodableShape {
        /// The ID of the launch profile used to control access from the streaming session.
        public let launchProfileId: String
        /// The launch profile protocol versions supported by the client.
        public let launchProfileProtocolVersions: [String]
        /// The launch purpose.
        public let launchPurpose: String
        /// The platform where this Launch Profile will be used, either Windows or Linux.
        public let platform: String
        /// The studio ID.
        public let studioId: String

        public init(launchProfileId: String, launchProfileProtocolVersions: [String], launchPurpose: String, platform: String, studioId: String) {
            self.launchProfileId = launchProfileId
            self.launchProfileProtocolVersions = launchProfileProtocolVersions
            self.launchPurpose = launchPurpose
            self.platform = platform
            self.studioId = studioId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.launchProfileId, key: "launchProfileId")
            request.encodeQuery(self.launchProfileProtocolVersions, key: "launchProfileProtocolVersions")
            request.encodeQuery(self.launchPurpose, key: "launchPurpose")
            request.encodeQuery(self.platform, key: "platform")
            request.encodePath(self.studioId, key: "studioId")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetLaunchProfileInitializationResponse: AWSDecodableShape {
        /// The launch profile initialization.
        public let launchProfileInitialization: LaunchProfileInitialization?

        public init(launchProfileInitialization: LaunchProfileInitialization? = nil) {
            self.launchProfileInitialization = launchProfileInitialization
        }

        private enum CodingKeys: String, CodingKey {
            case launchProfileInitialization = "launchProfileInitialization"
        }
    }

    public struct GetLaunchProfileMemberRequest: AWSEncodableShape {
        /// The ID of the launch profile used to control access from the streaming session.
        public let launchProfileId: String
        /// The principal ID. This currently supports a IAM Identity Center UserId.
        public let principalId: String
        /// The studio ID.
        public let studioId: String

        public init(launchProfileId: String, principalId: String, studioId: String) {
            self.launchProfileId = launchProfileId
            self.principalId = principalId
            self.studioId = studioId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.launchProfileId, key: "launchProfileId")
            request.encodePath(self.principalId, key: "principalId")
            request.encodePath(self.studioId, key: "studioId")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetLaunchProfileMemberResponse: AWSDecodableShape {
        /// The member.
        public let member: LaunchProfileMembership?

        public init(member: LaunchProfileMembership? = nil) {
            self.member = member
        }

        private enum CodingKeys: String, CodingKey {
            case member = "member"
        }
    }

    public struct GetLaunchProfileRequest: AWSEncodableShape {
        /// The ID of the launch profile used to control access from the streaming session.
        public let launchProfileId: String
        /// The studio ID.
        public let studioId: String

        public init(launchProfileId: String, studioId: String) {
            self.launchProfileId = launchProfileId
            self.studioId = studioId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.launchProfileId, key: "launchProfileId")
            request.encodePath(self.studioId, key: "studioId")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetLaunchProfileResponse: AWSDecodableShape {
        /// The launch profile.
        public let launchProfile: LaunchProfile?

        public init(launchProfile: LaunchProfile? = nil) {
            self.launchProfile = launchProfile
        }

        private enum CodingKeys: String, CodingKey {
            case launchProfile = "launchProfile"
        }
    }

    public struct GetStreamingImageRequest: AWSEncodableShape {
        /// The streaming image ID.
        public let streamingImageId: String
        /// The studio ID.
        public let studioId: String

        public init(streamingImageId: String, studioId: String) {
            self.streamingImageId = streamingImageId
            self.studioId = studioId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.streamingImageId, key: "streamingImageId")
            request.encodePath(self.studioId, key: "studioId")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetStreamingImageResponse: AWSDecodableShape {
        /// The streaming image.
        public let streamingImage: StreamingImage?

        public init(streamingImage: StreamingImage? = nil) {
            self.streamingImage = streamingImage
        }

        private enum CodingKeys: String, CodingKey {
            case streamingImage = "streamingImage"
        }
    }

    public struct GetStreamingSessionBackupRequest: AWSEncodableShape {
        /// The ID of the backup.
        public let backupId: String
        /// The studio ID.
        public let studioId: String

        public init(backupId: String, studioId: String) {
            self.backupId = backupId
            self.studioId = studioId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.backupId, key: "backupId")
            request.encodePath(self.studioId, key: "studioId")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetStreamingSessionBackupResponse: AWSDecodableShape {
        /// Information about the streaming session backup.
        public let streamingSessionBackup: StreamingSessionBackup?

        public init(streamingSessionBackup: StreamingSessionBackup? = nil) {
            self.streamingSessionBackup = streamingSessionBackup
        }

        private enum CodingKeys: String, CodingKey {
            case streamingSessionBackup = "streamingSessionBackup"
        }
    }

    public struct GetStreamingSessionRequest: AWSEncodableShape {
        /// The streaming session ID.
        public let sessionId: String
        /// The studio ID.
        public let studioId: String

        public init(sessionId: String, studioId: String) {
            self.sessionId = sessionId
            self.studioId = studioId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.sessionId, key: "sessionId")
            request.encodePath(self.studioId, key: "studioId")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetStreamingSessionResponse: AWSDecodableShape {
        /// The session.
        public let session: StreamingSession?

        public init(session: StreamingSession? = nil) {
            self.session = session
        }

        private enum CodingKeys: String, CodingKey {
            case session = "session"
        }
    }

    public struct GetStreamingSessionStreamRequest: AWSEncodableShape {
        /// The streaming session ID.
        public let sessionId: String
        /// The streaming session stream ID.
        public let streamId: String
        /// The studio ID.
        public let studioId: String

        public init(sessionId: String, streamId: String, studioId: String) {
            self.sessionId = sessionId
            self.streamId = streamId
            self.studioId = studioId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.sessionId, key: "sessionId")
            request.encodePath(self.streamId, key: "streamId")
            request.encodePath(self.studioId, key: "studioId")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetStreamingSessionStreamResponse: AWSDecodableShape {
        /// The stream.
        public let stream: StreamingSessionStream?

        public init(stream: StreamingSessionStream? = nil) {
            self.stream = stream
        }

        private enum CodingKeys: String, CodingKey {
            case stream = "stream"
        }
    }

    public struct GetStudioComponentRequest: AWSEncodableShape {
        /// The studio component ID.
        public let studioComponentId: String
        /// The studio ID.
        public let studioId: String

        public init(studioComponentId: String, studioId: String) {
            self.studioComponentId = studioComponentId
            self.studioId = studioId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.studioComponentId, key: "studioComponentId")
            request.encodePath(self.studioId, key: "studioId")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetStudioComponentResponse: AWSDecodableShape {
        /// Information about the studio component.
        public let studioComponent: StudioComponent?

        public init(studioComponent: StudioComponent? = nil) {
            self.studioComponent = studioComponent
        }

        private enum CodingKeys: String, CodingKey {
            case studioComponent = "studioComponent"
        }
    }

    public struct GetStudioMemberRequest: AWSEncodableShape {
        /// The principal ID. This currently supports a IAM Identity Center UserId.
        public let principalId: String
        /// The studio ID.
        public let studioId: String

        public init(principalId: String, studioId: String) {
            self.principalId = principalId
            self.studioId = studioId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.principalId, key: "principalId")
            request.encodePath(self.studioId, key: "studioId")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetStudioMemberResponse: AWSDecodableShape {
        /// The member.
        public let member: StudioMembership?

        public init(member: StudioMembership? = nil) {
            self.member = member
        }

        private enum CodingKeys: String, CodingKey {
            case member = "member"
        }
    }

    public struct GetStudioRequest: AWSEncodableShape {
        /// The studio ID.
        public let studioId: String

        public init(studioId: String) {
            self.studioId = studioId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.studioId, key: "studioId")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetStudioResponse: AWSDecodableShape {
        /// Information about a studio.
        public let studio: Studio

        public init(studio: Studio) {
            self.studio = studio
        }

        private enum CodingKeys: String, CodingKey {
            case studio = "studio"
        }
    }

    public struct LaunchProfile: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) that is assigned to a studio resource and uniquely identifies it. ARNs are unique across all Regions.
        public let arn: String?
        /// The ISO timestamp in seconds for when the resource was created.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var createdAt: Date?
        /// The user ID of the user that created the launch profile.
        public let createdBy: String?
        /// A human-readable description of the launch profile.
        public let description: String?
        /// Unique identifiers for a collection of EC2 subnets.
        public let ec2SubnetIds: [String]?
        /// The ID of the launch profile used to control access from the streaming session.
        public let launchProfileId: String?
        /// The version number of the protocol that is used by the launch profile. The only valid version is "2021-03-31".
        public let launchProfileProtocolVersions: [String]?
        /// A friendly name for the launch profile.
        public let name: String?
        /// The current state.
        public let state: LaunchProfileState?
        /// The status code.
        public let statusCode: LaunchProfileStatusCode?
        /// The status message for the launch profile.
        public let statusMessage: String?
        /// A configuration for a streaming session.
        public let streamConfiguration: StreamConfiguration?
        /// Unique identifiers for a collection of studio components that can be used with this launch profile.
        public let studioComponentIds: [String]?
        /// A collection of labels, in the form of key-value pairs, that apply to this resource.
        public let tags: [String: String]?
        /// The ISO timestamp in seconds for when the resource was updated.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var updatedAt: Date?
        /// The user ID of the user that most recently updated the resource.
        public let updatedBy: String?
        /// The list of the latest validation results.
        public let validationResults: [ValidationResult]?

        public init(arn: String? = nil, createdAt: Date? = nil, createdBy: String? = nil, description: String? = nil, ec2SubnetIds: [String]? = nil, launchProfileId: String? = nil, launchProfileProtocolVersions: [String]? = nil, name: String? = nil, state: LaunchProfileState? = nil, statusCode: LaunchProfileStatusCode? = nil, statusMessage: String? = nil, streamConfiguration: StreamConfiguration? = nil, studioComponentIds: [String]? = nil, tags: [String: String]? = nil, updatedAt: Date? = nil, updatedBy: String? = nil, validationResults: [ValidationResult]? = nil) {
            self.arn = arn
            self.createdAt = createdAt
            self.createdBy = createdBy
            self.description = description
            self.ec2SubnetIds = ec2SubnetIds
            self.launchProfileId = launchProfileId
            self.launchProfileProtocolVersions = launchProfileProtocolVersions
            self.name = name
            self.state = state
            self.statusCode = statusCode
            self.statusMessage = statusMessage
            self.streamConfiguration = streamConfiguration
            self.studioComponentIds = studioComponentIds
            self.tags = tags
            self.updatedAt = updatedAt
            self.updatedBy = updatedBy
            self.validationResults = validationResults
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case createdAt = "createdAt"
            case createdBy = "createdBy"
            case description = "description"
            case ec2SubnetIds = "ec2SubnetIds"
            case launchProfileId = "launchProfileId"
            case launchProfileProtocolVersions = "launchProfileProtocolVersions"
            case name = "name"
            case state = "state"
            case statusCode = "statusCode"
            case statusMessage = "statusMessage"
            case streamConfiguration = "streamConfiguration"
            case studioComponentIds = "studioComponentIds"
            case tags = "tags"
            case updatedAt = "updatedAt"
            case updatedBy = "updatedBy"
            case validationResults = "validationResults"
        }
    }

    public struct LaunchProfileInitialization: AWSDecodableShape {
        /// A LaunchProfileInitializationActiveDirectory resource.
        public let activeDirectory: LaunchProfileInitializationActiveDirectory?
        /// The EC2 security groups that control access to the studio component.
        public let ec2SecurityGroupIds: [String]?
        /// The ID of the launch profile used to control access from the streaming session.
        public let launchProfileId: String?
        /// The version number of the protocol that is used by the launch profile. The only valid version is "2021-03-31".
        public let launchProfileProtocolVersion: String?
        /// The launch purpose.
        public let launchPurpose: String?
        /// The name for the launch profile.
        public let name: String?
        /// The platform of the launch platform, either Windows or Linux.
        public let platform: LaunchProfilePlatform?
        /// The system initializtion scripts.
        public let systemInitializationScripts: [LaunchProfileInitializationScript]?
        /// The user initializtion scripts.
        public let userInitializationScripts: [LaunchProfileInitializationScript]?

        public init(activeDirectory: LaunchProfileInitializationActiveDirectory? = nil, ec2SecurityGroupIds: [String]? = nil, launchProfileId: String? = nil, launchProfileProtocolVersion: String? = nil, launchPurpose: String? = nil, name: String? = nil, platform: LaunchProfilePlatform? = nil, systemInitializationScripts: [LaunchProfileInitializationScript]? = nil, userInitializationScripts: [LaunchProfileInitializationScript]? = nil) {
            self.activeDirectory = activeDirectory
            self.ec2SecurityGroupIds = ec2SecurityGroupIds
            self.launchProfileId = launchProfileId
            self.launchProfileProtocolVersion = launchProfileProtocolVersion
            self.launchPurpose = launchPurpose
            self.name = name
            self.platform = platform
            self.systemInitializationScripts = systemInitializationScripts
            self.userInitializationScripts = userInitializationScripts
        }

        private enum CodingKeys: String, CodingKey {
            case activeDirectory = "activeDirectory"
            case ec2SecurityGroupIds = "ec2SecurityGroupIds"
            case launchProfileId = "launchProfileId"
            case launchProfileProtocolVersion = "launchProfileProtocolVersion"
            case launchPurpose = "launchPurpose"
            case name = "name"
            case platform = "platform"
            case systemInitializationScripts = "systemInitializationScripts"
            case userInitializationScripts = "userInitializationScripts"
        }
    }

    public struct LaunchProfileInitializationActiveDirectory: AWSDecodableShape {
        /// A collection of custom attributes for an Active Directory computer.
        public let computerAttributes: [ActiveDirectoryComputerAttribute]?
        /// The directory ID of the Directory Service for Microsoft Active Directory to access using this launch profile.
        public let directoryId: String?
        /// The directory name.
        public let directoryName: String?
        /// The DNS IP address.
        public let dnsIpAddresses: [String]?
        /// The name for the organizational unit distinguished name.
        public let organizationalUnitDistinguishedName: String?
        /// The unique identifier for a studio component resource.
        public let studioComponentId: String?
        /// The name for the studio component.
        public let studioComponentName: String?

        public init(computerAttributes: [ActiveDirectoryComputerAttribute]? = nil, directoryId: String? = nil, directoryName: String? = nil, dnsIpAddresses: [String]? = nil, organizationalUnitDistinguishedName: String? = nil, studioComponentId: String? = nil, studioComponentName: String? = nil) {
            self.computerAttributes = computerAttributes
            self.directoryId = directoryId
            self.directoryName = directoryName
            self.dnsIpAddresses = dnsIpAddresses
            self.organizationalUnitDistinguishedName = organizationalUnitDistinguishedName
            self.studioComponentId = studioComponentId
            self.studioComponentName = studioComponentName
        }

        private enum CodingKeys: String, CodingKey {
            case computerAttributes = "computerAttributes"
            case directoryId = "directoryId"
            case directoryName = "directoryName"
            case dnsIpAddresses = "dnsIpAddresses"
            case organizationalUnitDistinguishedName = "organizationalUnitDistinguishedName"
            case studioComponentId = "studioComponentId"
            case studioComponentName = "studioComponentName"
        }
    }

    public struct LaunchProfileInitializationScript: AWSDecodableShape {
        /// An IAM role attached to a Studio Component that gives the studio component access to Amazon Web Services resources at anytime while the instance is running.
        public let runtimeRoleArn: String?
        /// The initialization script.
        public let script: String?
        /// An IAM role attached to Studio Component when the system initialization script runs which give the studio component access to Amazon Web Services resources when the system initialization script runs.
        public let secureInitializationRoleArn: String?
        /// The unique identifier for a studio component resource.
        public let studioComponentId: String?
        /// The name for the studio component.
        public let studioComponentName: String?

        public init(runtimeRoleArn: String? = nil, script: String? = nil, secureInitializationRoleArn: String? = nil, studioComponentId: String? = nil, studioComponentName: String? = nil) {
            self.runtimeRoleArn = runtimeRoleArn
            self.script = script
            self.secureInitializationRoleArn = secureInitializationRoleArn
            self.studioComponentId = studioComponentId
            self.studioComponentName = studioComponentName
        }

        private enum CodingKeys: String, CodingKey {
            case runtimeRoleArn = "runtimeRoleArn"
            case script = "script"
            case secureInitializationRoleArn = "secureInitializationRoleArn"
            case studioComponentId = "studioComponentId"
            case studioComponentName = "studioComponentName"
        }
    }

    public struct LaunchProfileMembership: AWSDecodableShape {
        /// The ID of the identity store.
        public let identityStoreId: String?
        /// The persona.
        public let persona: LaunchProfilePersona?
        /// The principal ID.
        public let principalId: String?
        /// The Active Directory Security Identifier for this user, if available.
        public let sid: String?

        public init(identityStoreId: String? = nil, persona: LaunchProfilePersona? = nil, principalId: String? = nil, sid: String? = nil) {
            self.identityStoreId = identityStoreId
            self.persona = persona
            self.principalId = principalId
            self.sid = sid
        }

        private enum CodingKeys: String, CodingKey {
            case identityStoreId = "identityStoreId"
            case persona = "persona"
            case principalId = "principalId"
            case sid = "sid"
        }
    }

    public struct LicenseServiceConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The endpoint of the license service that is accessed by the studio component resource.
        public let endpoint: String?

        public init(endpoint: String? = nil) {
            self.endpoint = endpoint
        }

        private enum CodingKeys: String, CodingKey {
            case endpoint = "endpoint"
        }
    }

    public struct ListEulaAcceptancesRequest: AWSEncodableShape {
        /// The list of EULA IDs that have been previously accepted.
        public let eulaIds: [String]?
        /// The token for the next set of results, or null if there are no more results.
        public let nextToken: String?
        /// The studio ID.
        public let studioId: String

        public init(eulaIds: [String]? = nil, nextToken: String? = nil, studioId: String) {
            self.eulaIds = eulaIds
            self.nextToken = nextToken
            self.studioId = studioId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.eulaIds, key: "eulaIds")
            request.encodeQuery(self.nextToken, key: "nextToken")
            request.encodePath(self.studioId, key: "studioId")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListEulaAcceptancesResponse: AWSDecodableShape {
        /// A collection of EULA acceptances.
        public let eulaAcceptances: [EulaAcceptance]?
        /// The token for the next set of results, or null if there are no more results.
        public let nextToken: String?

        public init(eulaAcceptances: [EulaAcceptance]? = nil, nextToken: String? = nil) {
            self.eulaAcceptances = eulaAcceptances
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case eulaAcceptances = "eulaAcceptances"
            case nextToken = "nextToken"
        }
    }

    public struct ListEulasRequest: AWSEncodableShape {
        /// The list of EULA IDs that should be returned
        public let eulaIds: [String]?
        /// The token for the next set of results, or null if there are no more results.
        public let nextToken: String?

        public init(eulaIds: [String]? = nil, nextToken: String? = nil) {
            self.eulaIds = eulaIds
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.eulaIds, key: "eulaIds")
            request.encodeQuery(self.nextToken, key: "nextToken")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListEulasResponse: AWSDecodableShape {
        /// A collection of EULA resources.
        public let eulas: [Eula]?
        /// The token for the next set of results, or null if there are no more results.
        public let nextToken: String?

        public init(eulas: [Eula]? = nil, nextToken: String? = nil) {
            self.eulas = eulas
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case eulas = "eulas"
            case nextToken = "nextToken"
        }
    }

    public struct ListLaunchProfileMembersRequest: AWSEncodableShape {
        /// The ID of the launch profile used to control access from the streaming session.
        public let launchProfileId: String
        /// The max number of results to return in the response.
        public let maxResults: Int?
        /// The token for the next set of results, or null if there are no more results.
        public let nextToken: String?
        /// The studio ID.
        public let studioId: String

        public init(launchProfileId: String, maxResults: Int? = nil, nextToken: String? = nil, studioId: String) {
            self.launchProfileId = launchProfileId
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.studioId = studioId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.launchProfileId, key: "launchProfileId")
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
            request.encodePath(self.studioId, key: "studioId")
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListLaunchProfileMembersResponse: AWSDecodableShape {
        /// A list of members.
        public let members: [LaunchProfileMembership]?
        /// The token for the next set of results, or null if there are no more results.
        public let nextToken: String?

        public init(members: [LaunchProfileMembership]? = nil, nextToken: String? = nil) {
            self.members = members
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case members = "members"
            case nextToken = "nextToken"
        }
    }

    public struct ListLaunchProfilesRequest: AWSEncodableShape {
        /// The max number of results to return in the response.
        public let maxResults: Int?
        /// The token for the next set of results, or null if there are no more results.
        public let nextToken: String?
        /// The principal ID. This currently supports a IAM Identity Center UserId.
        public let principalId: String?
        /// Filter this request to launch profiles in any of the given states.
        public let states: [LaunchProfileState]?
        /// The studio ID.
        public let studioId: String

        public init(maxResults: Int? = nil, nextToken: String? = nil, principalId: String? = nil, states: [LaunchProfileState]? = nil, studioId: String) {
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.principalId = principalId
            self.states = states
            self.studioId = studioId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
            request.encodeQuery(self.principalId, key: "principalId")
            request.encodeQuery(self.states, key: "states")
            request.encodePath(self.studioId, key: "studioId")
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListLaunchProfilesResponse: AWSDecodableShape {
        /// A collection of launch profiles.
        public let launchProfiles: [LaunchProfile]?
        /// The token for the next set of results, or null if there are no more results.
        public let nextToken: String?

        public init(launchProfiles: [LaunchProfile]? = nil, nextToken: String? = nil) {
            self.launchProfiles = launchProfiles
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case launchProfiles = "launchProfiles"
            case nextToken = "nextToken"
        }
    }

    public struct ListStreamingImagesRequest: AWSEncodableShape {
        /// The token for the next set of results, or null if there are no more results.
        public let nextToken: String?
        /// Filter this request to streaming images with the given owner
        public let owner: String?
        /// The studio ID.
        public let studioId: String

        public init(nextToken: String? = nil, owner: String? = nil, studioId: String) {
            self.nextToken = nextToken
            self.owner = owner
            self.studioId = studioId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.nextToken, key: "nextToken")
            request.encodeQuery(self.owner, key: "owner")
            request.encodePath(self.studioId, key: "studioId")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListStreamingImagesResponse: AWSDecodableShape {
        /// The token for the next set of results, or null if there are no more results.
        public let nextToken: String?
        /// A collection of streaming images.
        public let streamingImages: [StreamingImage]?

        public init(nextToken: String? = nil, streamingImages: [StreamingImage]? = nil) {
            self.nextToken = nextToken
            self.streamingImages = streamingImages
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "nextToken"
            case streamingImages = "streamingImages"
        }
    }

    public struct ListStreamingSessionBackupsRequest: AWSEncodableShape {
        /// The token for the next set of results, or null if there are no more results.
        public let nextToken: String?
        /// The user ID of the user that owns the streaming session.
        public let ownedBy: String?
        /// The studio ID.
        public let studioId: String

        public init(nextToken: String? = nil, ownedBy: String? = nil, studioId: String) {
            self.nextToken = nextToken
            self.ownedBy = ownedBy
            self.studioId = studioId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.nextToken, key: "nextToken")
            request.encodeQuery(self.ownedBy, key: "ownedBy")
            request.encodePath(self.studioId, key: "studioId")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListStreamingSessionBackupsResponse: AWSDecodableShape {
        /// The token for the next set of results, or null if there are no more results.
        public let nextToken: String?
        /// Information about the streaming session backups.
        public let streamingSessionBackups: [StreamingSessionBackup]?

        public init(nextToken: String? = nil, streamingSessionBackups: [StreamingSessionBackup]? = nil) {
            self.nextToken = nextToken
            self.streamingSessionBackups = streamingSessionBackups
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "nextToken"
            case streamingSessionBackups = "streamingSessionBackups"
        }
    }

    public struct ListStreamingSessionsRequest: AWSEncodableShape {
        /// Filters the request to streaming sessions created by the given user.
        public let createdBy: String?
        /// The token for the next set of results, or null if there are no more results.
        public let nextToken: String?
        /// Filters the request to streaming session owned by the given user
        public let ownedBy: String?
        /// Filters the request to only the provided session IDs.
        public let sessionIds: String?
        /// The studio ID.
        public let studioId: String

        public init(createdBy: String? = nil, nextToken: String? = nil, ownedBy: String? = nil, sessionIds: String? = nil, studioId: String) {
            self.createdBy = createdBy
            self.nextToken = nextToken
            self.ownedBy = ownedBy
            self.sessionIds = sessionIds
            self.studioId = studioId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.createdBy, key: "createdBy")
            request.encodeQuery(self.nextToken, key: "nextToken")
            request.encodeQuery(self.ownedBy, key: "ownedBy")
            request.encodeQuery(self.sessionIds, key: "sessionIds")
            request.encodePath(self.studioId, key: "studioId")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListStreamingSessionsResponse: AWSDecodableShape {
        /// The token for the next set of results, or null if there are no more results.
        public let nextToken: String?
        /// A collection of streaming sessions.
        public let sessions: [StreamingSession]?

        public init(nextToken: String? = nil, sessions: [StreamingSession]? = nil) {
            self.nextToken = nextToken
            self.sessions = sessions
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "nextToken"
            case sessions = "sessions"
        }
    }

    public struct ListStudioComponentsRequest: AWSEncodableShape {
        /// The max number of results to return in the response.
        public let maxResults: Int?
        /// The token for the next set of results, or null if there are no more results.
        public let nextToken: String?
        /// Filters the request to studio components that are in one of the given states.
        public let states: [StudioComponentState]?
        /// The studio ID.
        public let studioId: String
        /// Filters the request to studio components that are of one of the given types.
        public let types: [StudioComponentType]?

        public init(maxResults: Int? = nil, nextToken: String? = nil, states: [StudioComponentState]? = nil, studioId: String, types: [StudioComponentType]? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.states = states
            self.studioId = studioId
            self.types = types
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
            request.encodeQuery(self.states, key: "states")
            request.encodePath(self.studioId, key: "studioId")
            request.encodeQuery(self.types, key: "types")
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListStudioComponentsResponse: AWSDecodableShape {
        /// The token for the next set of results, or null if there are no more results.
        public let nextToken: String?
        /// A collection of studio components.
        public let studioComponents: [StudioComponent]?

        public init(nextToken: String? = nil, studioComponents: [StudioComponent]? = nil) {
            self.nextToken = nextToken
            self.studioComponents = studioComponents
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "nextToken"
            case studioComponents = "studioComponents"
        }
    }

    public struct ListStudioMembersRequest: AWSEncodableShape {
        /// The max number of results to return in the response.
        public let maxResults: Int?
        /// The token for the next set of results, or null if there are no more results.
        public let nextToken: String?
        /// The studio ID.
        public let studioId: String

        public init(maxResults: Int? = nil, nextToken: String? = nil, studioId: String) {
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.studioId = studioId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
            request.encodePath(self.studioId, key: "studioId")
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListStudioMembersResponse: AWSDecodableShape {
        /// A list of admin members.
        public let members: [StudioMembership]?
        /// The token for the next set of results, or null if there are no more results.
        public let nextToken: String?

        public init(members: [StudioMembership]? = nil, nextToken: String? = nil) {
            self.members = members
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case members = "members"
            case nextToken = "nextToken"
        }
    }

    public struct ListStudiosRequest: AWSEncodableShape {
        /// The token for the next set of results, or null if there are no more results.
        public let nextToken: String?

        public init(nextToken: String? = nil) {
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.nextToken, key: "nextToken")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListStudiosResponse: AWSDecodableShape {
        /// The token for the next set of results, or null if there are no more results.
        public let nextToken: String?
        /// A collection of studios.
        public let studios: [Studio]

        public init(nextToken: String? = nil, studios: [Studio]) {
            self.nextToken = nextToken
            self.studios = studios
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "nextToken"
            case studios = "studios"
        }
    }

    public struct ListTagsForResourceRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the resource for which you want to list tags.
        public let resourceArn: String

        public init(resourceArn: String) {
            self.resourceArn = resourceArn
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.resourceArn, key: "resourceArn")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListTagsForResourceResponse: AWSDecodableShape {
        /// A collection of labels, in the form of key-value pairs, that apply to this resource.
        public let tags: [String: String]?

        public init(tags: [String: String]? = nil) {
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case tags = "tags"
        }
    }

    public struct NewLaunchProfileMember: AWSEncodableShape {
        /// The persona.
        public let persona: LaunchProfilePersona
        /// The principal ID.
        public let principalId: String

        public init(persona: LaunchProfilePersona, principalId: String) {
            self.persona = persona
            self.principalId = principalId
        }

        private enum CodingKeys: String, CodingKey {
            case persona = "persona"
            case principalId = "principalId"
        }
    }

    public struct NewStudioMember: AWSEncodableShape {
        /// The persona.
        public let persona: StudioPersona
        /// The principal ID.
        public let principalId: String

        public init(persona: StudioPersona, principalId: String) {
            self.persona = persona
            self.principalId = principalId
        }

        private enum CodingKeys: String, CodingKey {
            case persona = "persona"
            case principalId = "principalId"
        }
    }

    public struct PutLaunchProfileMembersRequest: AWSEncodableShape {
        /// Unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If you don’t specify a client token, the Amazon Web Services SDK automatically generates a client token and uses it for the request to ensure idempotency.
        public let clientToken: String?
        /// The ID of the identity store.
        public let identityStoreId: String
        /// The ID of the launch profile used to control access from the streaming session.
        public let launchProfileId: String
        /// A list of members.
        public let members: [NewLaunchProfileMember]
        /// The studio ID.
        public let studioId: String

        public init(clientToken: String? = PutLaunchProfileMembersRequest.idempotencyToken(), identityStoreId: String, launchProfileId: String, members: [NewLaunchProfileMember], studioId: String) {
            self.clientToken = clientToken
            self.identityStoreId = identityStoreId
            self.launchProfileId = launchProfileId
            self.members = members
            self.studioId = studioId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodeHeader(self.clientToken, key: "X-Amz-Client-Token")
            try container.encode(self.identityStoreId, forKey: .identityStoreId)
            request.encodePath(self.launchProfileId, key: "launchProfileId")
            try container.encode(self.members, forKey: .members)
            request.encodePath(self.studioId, key: "studioId")
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 64)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.validate(self.members, name: "members", parent: name, max: 20)
            try self.validate(self.members, name: "members", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case identityStoreId = "identityStoreId"
            case members = "members"
        }
    }

    public struct PutLaunchProfileMembersResponse: AWSDecodableShape {
        public init() {}
    }

    public struct PutStudioMembersRequest: AWSEncodableShape {
        /// Unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If you don’t specify a client token, the Amazon Web Services SDK automatically generates a client token and uses it for the request to ensure idempotency.
        public let clientToken: String?
        /// The ID of the identity store.
        public let identityStoreId: String
        /// A list of members.
        public let members: [NewStudioMember]
        /// The studio ID.
        public let studioId: String

        public init(clientToken: String? = PutStudioMembersRequest.idempotencyToken(), identityStoreId: String, members: [NewStudioMember], studioId: String) {
            self.clientToken = clientToken
            self.identityStoreId = identityStoreId
            self.members = members
            self.studioId = studioId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodeHeader(self.clientToken, key: "X-Amz-Client-Token")
            try container.encode(self.identityStoreId, forKey: .identityStoreId)
            try container.encode(self.members, forKey: .members)
            request.encodePath(self.studioId, key: "studioId")
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 64)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.validate(self.members, name: "members", parent: name, max: 20)
            try self.validate(self.members, name: "members", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case identityStoreId = "identityStoreId"
            case members = "members"
        }
    }

    public struct PutStudioMembersResponse: AWSDecodableShape {
        public init() {}
    }

    public struct ScriptParameterKeyValue: AWSEncodableShape & AWSDecodableShape {
        /// A script parameter key.
        public let key: String?
        /// A script parameter value.
        public let value: String?

        public init(key: String? = nil, value: String? = nil) {
            self.key = key
            self.value = value
        }

        public func validate(name: String) throws {
            try self.validate(self.key, name: "key", parent: name, max: 64)
            try self.validate(self.key, name: "key", parent: name, min: 1)
            try self.validate(self.key, name: "key", parent: name, pattern: "^[a-zA-Z_][a-zA-Z0-9_]+$")
            try self.validate(self.value, name: "value", parent: name, max: 256)
            try self.validate(self.value, name: "value", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case key = "key"
            case value = "value"
        }
    }

    public struct SharedFileSystemConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The endpoint of the shared file system that is accessed by the studio component resource.
        public let endpoint: String?
        /// The unique identifier for a file system.
        public let fileSystemId: String?
        /// The mount location for a shared file system on a Linux virtual workstation.
        public let linuxMountPoint: String?
        /// The name of the file share.
        public let shareName: String?
        /// The mount location for a shared file system on a Windows virtual workstation.
        public let windowsMountDrive: String?

        public init(endpoint: String? = nil, fileSystemId: String? = nil, linuxMountPoint: String? = nil, shareName: String? = nil, windowsMountDrive: String? = nil) {
            self.endpoint = endpoint
            self.fileSystemId = fileSystemId
            self.linuxMountPoint = linuxMountPoint
            self.shareName = shareName
            self.windowsMountDrive = windowsMountDrive
        }

        public func validate(name: String) throws {
            try self.validate(self.linuxMountPoint, name: "linuxMountPoint", parent: name, max: 128)
            try self.validate(self.linuxMountPoint, name: "linuxMountPoint", parent: name, pattern: "^(/?|(\\$HOME)?(/[^/\\n\\s\\\\]+)*)$")
            try self.validate(self.windowsMountDrive, name: "windowsMountDrive", parent: name, pattern: "^[A-Z]$")
        }

        private enum CodingKeys: String, CodingKey {
            case endpoint = "endpoint"
            case fileSystemId = "fileSystemId"
            case linuxMountPoint = "linuxMountPoint"
            case shareName = "shareName"
            case windowsMountDrive = "windowsMountDrive"
        }
    }

    public struct StartStreamingSessionRequest: AWSEncodableShape {
        /// The ID of the backup.
        public let backupId: String?
        /// Unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If you don’t specify a client token, the Amazon Web Services SDK automatically generates a client token and uses it for the request to ensure idempotency.
        public let clientToken: String?
        /// The streaming session ID for the StartStreamingSessionRequest.
        public let sessionId: String
        /// The studio ID for the StartStreamingSessionRequest.
        public let studioId: String

        public init(backupId: String? = nil, clientToken: String? = StartStreamingSessionRequest.idempotencyToken(), sessionId: String, studioId: String) {
            self.backupId = backupId
            self.clientToken = clientToken
            self.sessionId = sessionId
            self.studioId = studioId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.backupId, forKey: .backupId)
            request.encodeHeader(self.clientToken, key: "X-Amz-Client-Token")
            request.encodePath(self.sessionId, key: "sessionId")
            request.encodePath(self.studioId, key: "studioId")
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 64)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case backupId = "backupId"
        }
    }

    public struct StartStreamingSessionResponse: AWSDecodableShape {
        public let session: StreamingSession?

        public init(session: StreamingSession? = nil) {
            self.session = session
        }

        private enum CodingKeys: String, CodingKey {
            case session = "session"
        }
    }

    public struct StartStudioSSOConfigurationRepairRequest: AWSEncodableShape {
        /// Unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If you don’t specify a client token, the Amazon Web Services SDK automatically generates a client token and uses it for the request to ensure idempotency.
        public let clientToken: String?
        /// The studio ID.
        public let studioId: String

        public init(clientToken: String? = StartStudioSSOConfigurationRepairRequest.idempotencyToken(), studioId: String) {
            self.clientToken = clientToken
            self.studioId = studioId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeHeader(self.clientToken, key: "X-Amz-Client-Token")
            request.encodePath(self.studioId, key: "studioId")
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 64)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct StartStudioSSOConfigurationRepairResponse: AWSDecodableShape {
        /// Information about a studio.
        public let studio: Studio

        public init(studio: Studio) {
            self.studio = studio
        }

        private enum CodingKeys: String, CodingKey {
            case studio = "studio"
        }
    }

    public struct StopStreamingSessionRequest: AWSEncodableShape {
        /// Unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If you don’t specify a client token, the Amazon Web Services SDK automatically generates a client token and uses it for the request to ensure idempotency.
        public let clientToken: String?
        /// The streaming session ID for the StopStreamingSessionRequest.
        public let sessionId: String
        /// The studioId for the StopStreamingSessionRequest.
        public let studioId: String
        /// Adds additional instructions to a streaming session stop action to either retain the EBS volumes or delete the EBS volumes.
        public let volumeRetentionMode: VolumeRetentionMode?

        public init(clientToken: String? = StopStreamingSessionRequest.idempotencyToken(), sessionId: String, studioId: String, volumeRetentionMode: VolumeRetentionMode? = nil) {
            self.clientToken = clientToken
            self.sessionId = sessionId
            self.studioId = studioId
            self.volumeRetentionMode = volumeRetentionMode
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodeHeader(self.clientToken, key: "X-Amz-Client-Token")
            request.encodePath(self.sessionId, key: "sessionId")
            request.encodePath(self.studioId, key: "studioId")
            try container.encodeIfPresent(self.volumeRetentionMode, forKey: .volumeRetentionMode)
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 64)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case volumeRetentionMode = "volumeRetentionMode"
        }
    }

    public struct StopStreamingSessionResponse: AWSDecodableShape {
        public let session: StreamingSession?

        public init(session: StreamingSession? = nil) {
            self.session = session
        }

        private enum CodingKeys: String, CodingKey {
            case session = "session"
        }
    }

    public struct StreamConfiguration: AWSDecodableShape {
        /// Indicates if a streaming session created from this launch profile should be terminated automatically or retained without termination after being in a STOPPED state.   When ACTIVATED, the streaming session is scheduled for termination after being in the STOPPED state for the time specified in maxStoppedSessionLengthInMinutes.   When DEACTIVATED, the streaming session can remain in the STOPPED state indefinitely.   This parameter is only allowed when sessionPersistenceMode is ACTIVATED. When allowed, the default value for this parameter is DEACTIVATED.
        public let automaticTerminationMode: AutomaticTerminationMode?
        /// Allows or deactivates the use of the system clipboard to copy and paste between the streaming session and streaming client.
        public let clipboardMode: StreamingClipboardMode
        /// The EC2 instance types that users can select from when launching a streaming session with this launch profile.
        public let ec2InstanceTypes: [StreamingInstanceType]
        /// The length of time, in minutes, that a streaming session can be active before it is stopped or terminated. After this point, Nimble Studio automatically terminates or stops the session. The default length of time is 690 minutes, and the maximum length of time is 30 days.
        public let maxSessionLengthInMinutes: Int?
        /// Integer that determines if you can start and stop your sessions and how long a session can stay in the STOPPED state. The default value is 0. The maximum value is 5760. This field is allowed only when sessionPersistenceMode is ACTIVATED and automaticTerminationMode is ACTIVATED. If the value is set to 0, your sessions can’t be STOPPED. If you then call StopStreamingSession, the session fails. If the time that a session stays in the READY state exceeds the maxSessionLengthInMinutes value, the session will automatically be terminated (instead of STOPPED). If the value is set to a positive number, the session can be stopped. You can call StopStreamingSession to stop sessions in the READY state. If the time that a session stays in the READY state exceeds the maxSessionLengthInMinutes value, the session will automatically be stopped (instead of terminated).
        public let maxStoppedSessionLengthInMinutes: Int?
        /// Information about the streaming session backup.
        public let sessionBackup: StreamConfigurationSessionBackup?
        /// Determine if a streaming session created from this launch profile can configure persistent storage. This means that volumeConfiguration and automaticTerminationMode are configured.
        public let sessionPersistenceMode: SessionPersistenceMode?
        /// The upload storage for a streaming session.
        public let sessionStorage: StreamConfigurationSessionStorage?
        /// The streaming images that users can select from when launching a streaming session with this launch profile.
        public let streamingImageIds: [String]
        /// Custom volume configuration for the root volumes that are attached to streaming sessions. This parameter is only allowed when sessionPersistenceMode is ACTIVATED.
        public let volumeConfiguration: VolumeConfiguration?

        public init(automaticTerminationMode: AutomaticTerminationMode? = nil, clipboardMode: StreamingClipboardMode, ec2InstanceTypes: [StreamingInstanceType], maxSessionLengthInMinutes: Int? = nil, maxStoppedSessionLengthInMinutes: Int? = nil, sessionBackup: StreamConfigurationSessionBackup? = nil, sessionPersistenceMode: SessionPersistenceMode? = nil, sessionStorage: StreamConfigurationSessionStorage? = nil, streamingImageIds: [String], volumeConfiguration: VolumeConfiguration? = nil) {
            self.automaticTerminationMode = automaticTerminationMode
            self.clipboardMode = clipboardMode
            self.ec2InstanceTypes = ec2InstanceTypes
            self.maxSessionLengthInMinutes = maxSessionLengthInMinutes
            self.maxStoppedSessionLengthInMinutes = maxStoppedSessionLengthInMinutes
            self.sessionBackup = sessionBackup
            self.sessionPersistenceMode = sessionPersistenceMode
            self.sessionStorage = sessionStorage
            self.streamingImageIds = streamingImageIds
            self.volumeConfiguration = volumeConfiguration
        }

        private enum CodingKeys: String, CodingKey {
            case automaticTerminationMode = "automaticTerminationMode"
            case clipboardMode = "clipboardMode"
            case ec2InstanceTypes = "ec2InstanceTypes"
            case maxSessionLengthInMinutes = "maxSessionLengthInMinutes"
            case maxStoppedSessionLengthInMinutes = "maxStoppedSessionLengthInMinutes"
            case sessionBackup = "sessionBackup"
            case sessionPersistenceMode = "sessionPersistenceMode"
            case sessionStorage = "sessionStorage"
            case streamingImageIds = "streamingImageIds"
            case volumeConfiguration = "volumeConfiguration"
        }
    }

    public struct StreamConfigurationCreate: AWSEncodableShape {
        /// Indicates if a streaming session created from this launch profile should be terminated automatically or retained without termination after being in a STOPPED state.   When ACTIVATED, the streaming session is scheduled for termination after being in the STOPPED state for the time specified in maxStoppedSessionLengthInMinutes.   When DEACTIVATED, the streaming session can remain in the STOPPED state indefinitely.   This parameter is only allowed when sessionPersistenceMode is ACTIVATED. When allowed, the default value for this parameter is DEACTIVATED.
        public let automaticTerminationMode: AutomaticTerminationMode?
        /// Allows or deactivates the use of the system clipboard to copy and paste between the streaming session and streaming client.
        public let clipboardMode: StreamingClipboardMode
        /// The EC2 instance types that users can select from when launching a streaming session with this launch profile.
        public let ec2InstanceTypes: [StreamingInstanceType]
        /// The length of time, in minutes, that a streaming session can be active before it is stopped or terminated. After this point, Nimble Studio automatically terminates or stops the session. The default length of time is 690 minutes, and the maximum length of time is 30 days.
        public let maxSessionLengthInMinutes: Int?
        /// Integer that determines if you can start and stop your sessions and how long a session can stay in the STOPPED state. The default value is 0. The maximum value is 5760. This field is allowed only when sessionPersistenceMode is ACTIVATED and automaticTerminationMode is ACTIVATED. If the value is set to 0, your sessions can’t be STOPPED. If you then call StopStreamingSession, the session fails. If the time that a session stays in the READY state exceeds the maxSessionLengthInMinutes value, the session will automatically be terminated (instead of STOPPED). If the value is set to a positive number, the session can be stopped. You can call StopStreamingSession to stop sessions in the READY state. If the time that a session stays in the READY state exceeds the maxSessionLengthInMinutes value, the session will automatically be stopped (instead of terminated).
        public let maxStoppedSessionLengthInMinutes: Int?
        /// Configures how streaming sessions are backed up when launched from this launch profile.
        public let sessionBackup: StreamConfigurationSessionBackup?
        /// Determine if a streaming session created from this launch profile can configure persistent storage. This means that volumeConfiguration and automaticTerminationMode are configured.
        public let sessionPersistenceMode: SessionPersistenceMode?
        /// The upload storage for a streaming workstation that is created using this launch profile.
        public let sessionStorage: StreamConfigurationSessionStorage?
        /// The streaming images that users can select from when launching a streaming session with this launch profile.
        public let streamingImageIds: [String]
        /// Custom volume configuration for the root volumes that are attached to streaming sessions. This parameter is only allowed when sessionPersistenceMode is ACTIVATED.
        public let volumeConfiguration: VolumeConfiguration?

        public init(automaticTerminationMode: AutomaticTerminationMode? = nil, clipboardMode: StreamingClipboardMode, ec2InstanceTypes: [StreamingInstanceType], maxSessionLengthInMinutes: Int? = nil, maxStoppedSessionLengthInMinutes: Int? = nil, sessionBackup: StreamConfigurationSessionBackup? = nil, sessionPersistenceMode: SessionPersistenceMode? = nil, sessionStorage: StreamConfigurationSessionStorage? = nil, streamingImageIds: [String], volumeConfiguration: VolumeConfiguration? = nil) {
            self.automaticTerminationMode = automaticTerminationMode
            self.clipboardMode = clipboardMode
            self.ec2InstanceTypes = ec2InstanceTypes
            self.maxSessionLengthInMinutes = maxSessionLengthInMinutes
            self.maxStoppedSessionLengthInMinutes = maxStoppedSessionLengthInMinutes
            self.sessionBackup = sessionBackup
            self.sessionPersistenceMode = sessionPersistenceMode
            self.sessionStorage = sessionStorage
            self.streamingImageIds = streamingImageIds
            self.volumeConfiguration = volumeConfiguration
        }

        public func validate(name: String) throws {
            try self.validate(self.ec2InstanceTypes, name: "ec2InstanceTypes", parent: name, max: 30)
            try self.validate(self.ec2InstanceTypes, name: "ec2InstanceTypes", parent: name, min: 1)
            try self.validate(self.maxSessionLengthInMinutes, name: "maxSessionLengthInMinutes", parent: name, max: 43200)
            try self.validate(self.maxSessionLengthInMinutes, name: "maxSessionLengthInMinutes", parent: name, min: 1)
            try self.validate(self.maxStoppedSessionLengthInMinutes, name: "maxStoppedSessionLengthInMinutes", parent: name, max: 5760)
            try self.validate(self.maxStoppedSessionLengthInMinutes, name: "maxStoppedSessionLengthInMinutes", parent: name, min: 0)
            try self.sessionBackup?.validate(name: "\(name).sessionBackup")
            try self.sessionStorage?.validate(name: "\(name).sessionStorage")
            try self.streamingImageIds.forEach {
                try validate($0, name: "streamingImageIds[]", parent: name, max: 22)
                try validate($0, name: "streamingImageIds[]", parent: name, pattern: "^[a-zA-Z0-9-_]*$")
            }
            try self.validate(self.streamingImageIds, name: "streamingImageIds", parent: name, max: 20)
            try self.validate(self.streamingImageIds, name: "streamingImageIds", parent: name, min: 1)
            try self.volumeConfiguration?.validate(name: "\(name).volumeConfiguration")
        }

        private enum CodingKeys: String, CodingKey {
            case automaticTerminationMode = "automaticTerminationMode"
            case clipboardMode = "clipboardMode"
            case ec2InstanceTypes = "ec2InstanceTypes"
            case maxSessionLengthInMinutes = "maxSessionLengthInMinutes"
            case maxStoppedSessionLengthInMinutes = "maxStoppedSessionLengthInMinutes"
            case sessionBackup = "sessionBackup"
            case sessionPersistenceMode = "sessionPersistenceMode"
            case sessionStorage = "sessionStorage"
            case streamingImageIds = "streamingImageIds"
            case volumeConfiguration = "volumeConfiguration"
        }
    }

    public struct StreamConfigurationSessionBackup: AWSEncodableShape & AWSDecodableShape {
        /// The maximum number of backups that each streaming session created from this launch profile can have.
        public let maxBackupsToRetain: Int?
        /// Specifies how artists sessions are backed up. Configures backups for streaming sessions launched with this launch profile. The default value is DEACTIVATED, which means that backups are deactivated. To allow backups, set this value to AUTOMATIC.
        public let mode: SessionBackupMode?

        public init(maxBackupsToRetain: Int? = nil, mode: SessionBackupMode? = nil) {
            self.maxBackupsToRetain = maxBackupsToRetain
            self.mode = mode
        }

        public func validate(name: String) throws {
            try self.validate(self.maxBackupsToRetain, name: "maxBackupsToRetain", parent: name, max: 10)
            try self.validate(self.maxBackupsToRetain, name: "maxBackupsToRetain", parent: name, min: 0)
        }

        private enum CodingKeys: String, CodingKey {
            case maxBackupsToRetain = "maxBackupsToRetain"
            case mode = "mode"
        }
    }

    public struct StreamConfigurationSessionStorage: AWSEncodableShape & AWSDecodableShape {
        /// Allows artists to upload files to their workstations. The only valid option is UPLOAD.
        public let mode: [StreamingSessionStorageMode]
        /// The configuration for the upload storage root of the streaming session.
        public let root: StreamingSessionStorageRoot?

        public init(mode: [StreamingSessionStorageMode], root: StreamingSessionStorageRoot? = nil) {
            self.mode = mode
            self.root = root
        }

        public func validate(name: String) throws {
            try self.validate(self.mode, name: "mode", parent: name, min: 1)
            try self.root?.validate(name: "\(name).root")
        }

        private enum CodingKeys: String, CodingKey {
            case mode = "mode"
            case root = "root"
        }
    }

    public struct StreamingImage: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) that is assigned to a studio resource and uniquely identifies it. ARNs are unique across all Regions.
        public let arn: String?
        /// A human-readable description of the streaming image.
        public let description: String?
        /// The ID of an EC2 machine image with which to create the streaming image.
        public let ec2ImageId: String?
        /// The encryption configuration.
        public let encryptionConfiguration: StreamingImageEncryptionConfiguration?
        /// The list of EULAs that must be accepted before a Streaming Session can be started using this streaming image.
        public let eulaIds: [String]?
        /// A friendly name for a streaming image resource.
        public let name: String?
        /// The owner of the streaming image, either the studioId that contains the streaming image, or amazon for images that are provided by Amazon Nimble Studio.
        public let owner: String?
        /// The platform of the streaming image, either Windows or Linux.
        public let platform: String?
        /// The current state.
        public let state: StreamingImageState?
        /// The status code.
        public let statusCode: StreamingImageStatusCode?
        /// The status message for the streaming image.
        public let statusMessage: String?
        /// The ID of the streaming image.
        public let streamingImageId: String?
        /// A collection of labels, in the form of key-value pairs, that apply to this resource.
        public let tags: [String: String]?

        public init(arn: String? = nil, description: String? = nil, ec2ImageId: String? = nil, encryptionConfiguration: StreamingImageEncryptionConfiguration? = nil, eulaIds: [String]? = nil, name: String? = nil, owner: String? = nil, platform: String? = nil, state: StreamingImageState? = nil, statusCode: StreamingImageStatusCode? = nil, statusMessage: String? = nil, streamingImageId: String? = nil, tags: [String: String]? = nil) {
            self.arn = arn
            self.description = description
            self.ec2ImageId = ec2ImageId
            self.encryptionConfiguration = encryptionConfiguration
            self.eulaIds = eulaIds
            self.name = name
            self.owner = owner
            self.platform = platform
            self.state = state
            self.statusCode = statusCode
            self.statusMessage = statusMessage
            self.streamingImageId = streamingImageId
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case description = "description"
            case ec2ImageId = "ec2ImageId"
            case encryptionConfiguration = "encryptionConfiguration"
            case eulaIds = "eulaIds"
            case name = "name"
            case owner = "owner"
            case platform = "platform"
            case state = "state"
            case statusCode = "statusCode"
            case statusMessage = "statusMessage"
            case streamingImageId = "streamingImageId"
            case tags = "tags"
        }
    }

    public struct StreamingImageEncryptionConfiguration: AWSDecodableShape {
        /// The ARN for a KMS key that is used to encrypt studio data.
        public let keyArn: String?
        /// The type of KMS key that is used to encrypt studio data.
        public let keyType: StreamingImageEncryptionConfigurationKeyType

        public init(keyArn: String? = nil, keyType: StreamingImageEncryptionConfigurationKeyType) {
            self.keyArn = keyArn
            self.keyType = keyType
        }

        private enum CodingKeys: String, CodingKey {
            case keyArn = "keyArn"
            case keyType = "keyType"
        }
    }

    public struct StreamingSession: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) that is assigned to a studio resource and uniquely identifies it. ARNs are unique across all Regions.
        public let arn: String?
        /// Indicates if a streaming session created from this launch profile should be terminated automatically or retained without termination after being in a STOPPED state.   When ACTIVATED, the streaming session is scheduled for termination after being in the STOPPED state for the time specified in maxStoppedSessionLengthInMinutes.   When DEACTIVATED, the streaming session can remain in the STOPPED state indefinitely.   This parameter is only allowed when sessionPersistenceMode is ACTIVATED. When allowed, the default value for this parameter is DEACTIVATED.
        public let automaticTerminationMode: AutomaticTerminationMode?
        /// Shows the current backup setting of the session.
        public let backupMode: SessionBackupMode?
        /// The ISO timestamp in seconds for when the resource was created.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var createdAt: Date?
        /// The user ID of the user that created the streaming session.
        public let createdBy: String?
        /// The EC2 Instance type used for the streaming session.
        public let ec2InstanceType: String?
        /// The ID of the launch profile used to control access from the streaming session.
        public let launchProfileId: String?
        /// The maximum number of backups of a streaming session that you can have. When the maximum number of backups is reached, the oldest backup is deleted.
        public let maxBackupsToRetain: Int?
        /// The user ID of the user that owns the streaming session. The user that owns the session will be logging into the session and interacting with the virtual workstation.
        public let ownedBy: String?
        /// The session ID.
        public let sessionId: String?
        /// Determine if a streaming session created from this launch profile can configure persistent storage. This means that volumeConfiguration and automaticTerminationMode are configured.
        public let sessionPersistenceMode: SessionPersistenceMode?
        /// The time the session entered START_IN_PROGRESS state.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var startedAt: Date?
        /// The user ID of the user that started the streaming session.
        public let startedBy: String?
        /// The backup ID used to restore a streaming session.
        public let startedFromBackupId: String?
        /// The current state.
        public let state: StreamingSessionState?
        /// The status code.
        public let statusCode: StreamingSessionStatusCode?
        /// The status message for the streaming session.
        public let statusMessage: String?
        /// The time the streaming session will automatically be stopped if the user doesn’t stop the session themselves.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var stopAt: Date?
        /// The time the session entered STOP_IN_PROGRESS state.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var stoppedAt: Date?
        /// The user ID of the user that stopped the streaming session.
        public let stoppedBy: String?
        /// The ID of the streaming image.
        public let streamingImageId: String?
        /// A collection of labels, in the form of key-value pairs, that apply to this resource.
        public let tags: [String: String]?
        /// The time the streaming session will automatically terminate if not terminated by the user.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var terminateAt: Date?
        /// The ISO timestamp in seconds for when the resource was updated.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var updatedAt: Date?
        /// The user ID of the user that most recently updated the resource.
        public let updatedBy: String?
        /// Custom volume configuration for the root volumes that are attached to streaming sessions. This parameter is only allowed when sessionPersistenceMode is ACTIVATED.
        public let volumeConfiguration: VolumeConfiguration?
        /// Determine if an EBS volume created from this streaming session will be backed up.
        public let volumeRetentionMode: VolumeRetentionMode?

        public init(arn: String? = nil, automaticTerminationMode: AutomaticTerminationMode? = nil, backupMode: SessionBackupMode? = nil, createdAt: Date? = nil, createdBy: String? = nil, ec2InstanceType: String? = nil, launchProfileId: String? = nil, maxBackupsToRetain: Int? = nil, ownedBy: String? = nil, sessionId: String? = nil, sessionPersistenceMode: SessionPersistenceMode? = nil, startedAt: Date? = nil, startedBy: String? = nil, startedFromBackupId: String? = nil, state: StreamingSessionState? = nil, statusCode: StreamingSessionStatusCode? = nil, statusMessage: String? = nil, stopAt: Date? = nil, stoppedAt: Date? = nil, stoppedBy: String? = nil, streamingImageId: String? = nil, tags: [String: String]? = nil, terminateAt: Date? = nil, updatedAt: Date? = nil, updatedBy: String? = nil, volumeConfiguration: VolumeConfiguration? = nil, volumeRetentionMode: VolumeRetentionMode? = nil) {
            self.arn = arn
            self.automaticTerminationMode = automaticTerminationMode
            self.backupMode = backupMode
            self.createdAt = createdAt
            self.createdBy = createdBy
            self.ec2InstanceType = ec2InstanceType
            self.launchProfileId = launchProfileId
            self.maxBackupsToRetain = maxBackupsToRetain
            self.ownedBy = ownedBy
            self.sessionId = sessionId
            self.sessionPersistenceMode = sessionPersistenceMode
            self.startedAt = startedAt
            self.startedBy = startedBy
            self.startedFromBackupId = startedFromBackupId
            self.state = state
            self.statusCode = statusCode
            self.statusMessage = statusMessage
            self.stopAt = stopAt
            self.stoppedAt = stoppedAt
            self.stoppedBy = stoppedBy
            self.streamingImageId = streamingImageId
            self.tags = tags
            self.terminateAt = terminateAt
            self.updatedAt = updatedAt
            self.updatedBy = updatedBy
            self.volumeConfiguration = volumeConfiguration
            self.volumeRetentionMode = volumeRetentionMode
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case automaticTerminationMode = "automaticTerminationMode"
            case backupMode = "backupMode"
            case createdAt = "createdAt"
            case createdBy = "createdBy"
            case ec2InstanceType = "ec2InstanceType"
            case launchProfileId = "launchProfileId"
            case maxBackupsToRetain = "maxBackupsToRetain"
            case ownedBy = "ownedBy"
            case sessionId = "sessionId"
            case sessionPersistenceMode = "sessionPersistenceMode"
            case startedAt = "startedAt"
            case startedBy = "startedBy"
            case startedFromBackupId = "startedFromBackupId"
            case state = "state"
            case statusCode = "statusCode"
            case statusMessage = "statusMessage"
            case stopAt = "stopAt"
            case stoppedAt = "stoppedAt"
            case stoppedBy = "stoppedBy"
            case streamingImageId = "streamingImageId"
            case tags = "tags"
            case terminateAt = "terminateAt"
            case updatedAt = "updatedAt"
            case updatedBy = "updatedBy"
            case volumeConfiguration = "volumeConfiguration"
            case volumeRetentionMode = "volumeRetentionMode"
        }
    }

    public struct StreamingSessionBackup: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) that is assigned to a studio resource and uniquely identifies it. ARNs are unique across all Regions.
        public let arn: String?
        /// The ID of the backup.
        public let backupId: String?
        /// The ISO timestamp in for when the resource was created.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var createdAt: Date?
        /// The ID of the launch profile which allowed the backups for the streaming session.
        public let launchProfileId: String?
        /// The user ID of the user that owns the streaming session.
        public let ownedBy: String?
        /// The streaming session ID for the StreamingSessionBackup.
        public let sessionId: String?
        public let state: StreamingSessionState?
        /// The status code.
        public let statusCode: StreamingSessionStatusCode?
        /// The status message for the streaming session backup.
        public let statusMessage: String?
        /// A collection of labels, in the form of key-value pairs, that apply to this resource.
        public let tags: [String: String]?

        public init(arn: String? = nil, backupId: String? = nil, createdAt: Date? = nil, launchProfileId: String? = nil, ownedBy: String? = nil, sessionId: String? = nil, state: StreamingSessionState? = nil, statusCode: StreamingSessionStatusCode? = nil, statusMessage: String? = nil, tags: [String: String]? = nil) {
            self.arn = arn
            self.backupId = backupId
            self.createdAt = createdAt
            self.launchProfileId = launchProfileId
            self.ownedBy = ownedBy
            self.sessionId = sessionId
            self.state = state
            self.statusCode = statusCode
            self.statusMessage = statusMessage
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case backupId = "backupId"
            case createdAt = "createdAt"
            case launchProfileId = "launchProfileId"
            case ownedBy = "ownedBy"
            case sessionId = "sessionId"
            case state = "state"
            case statusCode = "statusCode"
            case statusMessage = "statusMessage"
            case tags = "tags"
        }
    }

    public struct StreamingSessionStorageRoot: AWSEncodableShape & AWSDecodableShape {
        /// The folder path in Linux workstations where files are uploaded.
        public let linux: String?
        /// The folder path in Windows workstations where files are uploaded.
        public let windows: String?

        public init(linux: String? = nil, windows: String? = nil) {
            self.linux = linux
            self.windows = windows
        }

        public func validate(name: String) throws {
            try self.validate(self.linux, name: "linux", parent: name, max: 128)
            try self.validate(self.linux, name: "linux", parent: name, min: 1)
            try self.validate(self.linux, name: "linux", parent: name, pattern: "^(\\$HOME|/)[/]?([A-Za-z0-9-_]+/)*([A-Za-z0-9_-]+)$")
            try self.validate(self.windows, name: "windows", parent: name, max: 128)
            try self.validate(self.windows, name: "windows", parent: name, min: 1)
            try self.validate(self.windows, name: "windows", parent: name, pattern: "^((\\%HOMEPATH\\%)|[a-zA-Z]:)[\\\\/](?:[a-zA-Z0-9_-]+[\\\\/])*[a-zA-Z0-9_-]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case linux = "linux"
            case windows = "windows"
        }
    }

    public struct StreamingSessionStream: AWSDecodableShape {
        /// The ISO timestamp in seconds for when the resource was created.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var createdAt: Date?
        /// The user ID of the user that created the streaming session stream.
        public let createdBy: String?
        /// The ISO timestamp in seconds for when the resource expires.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var expiresAt: Date?
        /// The user ID of the user that owns the streaming session. The user that owns the session will be logging into the session and interacting with the virtual workstation.
        public let ownedBy: String?
        /// The current state.
        public let state: StreamingSessionStreamState?
        /// The streaming session stream status code.
        public let statusCode: StreamingSessionStreamStatusCode?
        /// The stream ID.
        public let streamId: String?
        /// The URL to connect to this stream using the DCV client.
        public let url: String?

        public init(createdAt: Date? = nil, createdBy: String? = nil, expiresAt: Date? = nil, ownedBy: String? = nil, state: StreamingSessionStreamState? = nil, statusCode: StreamingSessionStreamStatusCode? = nil, streamId: String? = nil, url: String? = nil) {
            self.createdAt = createdAt
            self.createdBy = createdBy
            self.expiresAt = expiresAt
            self.ownedBy = ownedBy
            self.state = state
            self.statusCode = statusCode
            self.streamId = streamId
            self.url = url
        }

        private enum CodingKeys: String, CodingKey {
            case createdAt = "createdAt"
            case createdBy = "createdBy"
            case expiresAt = "expiresAt"
            case ownedBy = "ownedBy"
            case state = "state"
            case statusCode = "statusCode"
            case streamId = "streamId"
            case url = "url"
        }
    }

    public struct Studio: AWSDecodableShape {
        /// The IAM role that studio admins assume when logging in to the Nimble Studio portal.
        public let adminRoleArn: String?
        /// The Amazon Resource Name (ARN) that is assigned to a studio resource and uniquely identifies it. ARNs are unique across all Regions.
        public let arn: String?
        /// The ISO timestamp in seconds for when the resource was created.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var createdAt: Date?
        /// A friendly name for the studio.
        public let displayName: String?
        /// The Amazon Web Services Region where the studio resource is located.
        public let homeRegion: String?
        /// The IAM Identity Center application client ID used to integrate with IAM Identity Center. This ID allows IAM Identity Center users to log in to Nimble Studio portal.
        public let ssoClientId: String?
        /// The current state of the studio resource.
        public let state: StudioState?
        /// Status codes that provide additional detail on the studio state.
        public let statusCode: StudioStatusCode?
        /// Additional detail on the studio state.
        public let statusMessage: String?
        /// Configuration of the encryption method that is used for the studio.
        public let studioEncryptionConfiguration: StudioEncryptionConfiguration?
        /// The unique identifier for a studio resource. In Nimble Studio, all other resources are contained in a studio resource.
        public let studioId: String?
        /// The name of the studio, as included in the URL when accessing it in the Nimble Studio portal.
        public let studioName: String?
        /// The address of the web page for the studio.
        public let studioUrl: String?
        /// A collection of labels, in the form of key-value pairs, that apply to this resource.
        public let tags: [String: String]?
        /// The ISO timestamp in seconds for when the resource was updated.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var updatedAt: Date?
        /// The IAM role that studio users assume when logging in to the Nimble Studio portal.
        public let userRoleArn: String?

        public init(adminRoleArn: String? = nil, arn: String? = nil, createdAt: Date? = nil, displayName: String? = nil, homeRegion: String? = nil, ssoClientId: String? = nil, state: StudioState? = nil, statusCode: StudioStatusCode? = nil, statusMessage: String? = nil, studioEncryptionConfiguration: StudioEncryptionConfiguration? = nil, studioId: String? = nil, studioName: String? = nil, studioUrl: String? = nil, tags: [String: String]? = nil, updatedAt: Date? = nil, userRoleArn: String? = nil) {
            self.adminRoleArn = adminRoleArn
            self.arn = arn
            self.createdAt = createdAt
            self.displayName = displayName
            self.homeRegion = homeRegion
            self.ssoClientId = ssoClientId
            self.state = state
            self.statusCode = statusCode
            self.statusMessage = statusMessage
            self.studioEncryptionConfiguration = studioEncryptionConfiguration
            self.studioId = studioId
            self.studioName = studioName
            self.studioUrl = studioUrl
            self.tags = tags
            self.updatedAt = updatedAt
            self.userRoleArn = userRoleArn
        }

        private enum CodingKeys: String, CodingKey {
            case adminRoleArn = "adminRoleArn"
            case arn = "arn"
            case createdAt = "createdAt"
            case displayName = "displayName"
            case homeRegion = "homeRegion"
            case ssoClientId = "ssoClientId"
            case state = "state"
            case statusCode = "statusCode"
            case statusMessage = "statusMessage"
            case studioEncryptionConfiguration = "studioEncryptionConfiguration"
            case studioId = "studioId"
            case studioName = "studioName"
            case studioUrl = "studioUrl"
            case tags = "tags"
            case updatedAt = "updatedAt"
            case userRoleArn = "userRoleArn"
        }
    }

    public struct StudioComponent: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) that is assigned to a studio resource and uniquely identifies it. ARNs are unique across all Regions.
        public let arn: String?
        /// The configuration of the studio component, based on component type.
        public let configuration: StudioComponentConfiguration?
        /// The ISO timestamp in seconds for when the resource was created.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var createdAt: Date?
        /// The user ID of the user that created the studio component.
        public let createdBy: String?
        /// A human-readable description for the studio component resource.
        public let description: String?
        /// The EC2 security groups that control access to the studio component.
        public let ec2SecurityGroupIds: [String]?
        /// Initialization scripts for studio components.
        public let initializationScripts: [StudioComponentInitializationScript]?
        /// A friendly name for the studio component resource.
        public let name: String?
        /// An IAM role attached to a Studio Component that gives the studio component access to Amazon Web Services resources at anytime while the instance is running.
        public let runtimeRoleArn: String?
        /// Parameters for the studio component scripts.
        public let scriptParameters: [ScriptParameterKeyValue]?
        /// An IAM role attached to Studio Component when the system initialization script runs which give the studio component access to Amazon Web Services resources when the system initialization script runs.
        public let secureInitializationRoleArn: String?
        /// The current state.
        public let state: StudioComponentState?
        /// The status code.
        public let statusCode: StudioComponentStatusCode?
        /// The status message for the studio component.
        public let statusMessage: String?
        /// The unique identifier for a studio component resource.
        public let studioComponentId: String?
        /// The specific subtype of a studio component.
        public let subtype: StudioComponentSubtype?
        /// A collection of labels, in the form of key-value pairs, that apply to this resource.
        public let tags: [String: String]?
        /// The type of the studio component.
        public let type: StudioComponentType?
        /// The ISO timestamp in seconds for when the resource was updated.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var updatedAt: Date?
        /// The user ID of the user that most recently updated the resource.
        public let updatedBy: String?

        public init(arn: String? = nil, configuration: StudioComponentConfiguration? = nil, createdAt: Date? = nil, createdBy: String? = nil, description: String? = nil, ec2SecurityGroupIds: [String]? = nil, initializationScripts: [StudioComponentInitializationScript]? = nil, name: String? = nil, runtimeRoleArn: String? = nil, scriptParameters: [ScriptParameterKeyValue]? = nil, secureInitializationRoleArn: String? = nil, state: StudioComponentState? = nil, statusCode: StudioComponentStatusCode? = nil, statusMessage: String? = nil, studioComponentId: String? = nil, subtype: StudioComponentSubtype? = nil, tags: [String: String]? = nil, type: StudioComponentType? = nil, updatedAt: Date? = nil, updatedBy: String? = nil) {
            self.arn = arn
            self.configuration = configuration
            self.createdAt = createdAt
            self.createdBy = createdBy
            self.description = description
            self.ec2SecurityGroupIds = ec2SecurityGroupIds
            self.initializationScripts = initializationScripts
            self.name = name
            self.runtimeRoleArn = runtimeRoleArn
            self.scriptParameters = scriptParameters
            self.secureInitializationRoleArn = secureInitializationRoleArn
            self.state = state
            self.statusCode = statusCode
            self.statusMessage = statusMessage
            self.studioComponentId = studioComponentId
            self.subtype = subtype
            self.tags = tags
            self.type = type
            self.updatedAt = updatedAt
            self.updatedBy = updatedBy
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case configuration = "configuration"
            case createdAt = "createdAt"
            case createdBy = "createdBy"
            case description = "description"
            case ec2SecurityGroupIds = "ec2SecurityGroupIds"
            case initializationScripts = "initializationScripts"
            case name = "name"
            case runtimeRoleArn = "runtimeRoleArn"
            case scriptParameters = "scriptParameters"
            case secureInitializationRoleArn = "secureInitializationRoleArn"
            case state = "state"
            case statusCode = "statusCode"
            case statusMessage = "statusMessage"
            case studioComponentId = "studioComponentId"
            case subtype = "subtype"
            case tags = "tags"
            case type = "type"
            case updatedAt = "updatedAt"
            case updatedBy = "updatedBy"
        }
    }

    public struct StudioComponentInitializationScript: AWSEncodableShape & AWSDecodableShape {
        /// The version number of the protocol that is used by the launch profile. The only valid version is "2021-03-31".
        public let launchProfileProtocolVersion: String?
        /// The platform of the initialization script, either Windows or Linux.
        public let platform: LaunchProfilePlatform?
        /// The method to use when running the initialization script.
        public let runContext: StudioComponentInitializationScriptRunContext?
        /// The initialization script.
        public let script: String?

        public init(launchProfileProtocolVersion: String? = nil, platform: LaunchProfilePlatform? = nil, runContext: StudioComponentInitializationScriptRunContext? = nil, script: String? = nil) {
            self.launchProfileProtocolVersion = launchProfileProtocolVersion
            self.platform = platform
            self.runContext = runContext
            self.script = script
        }

        public func validate(name: String) throws {
            try self.validate(self.launchProfileProtocolVersion, name: "launchProfileProtocolVersion", parent: name, max: 10)
            try self.validate(self.launchProfileProtocolVersion, name: "launchProfileProtocolVersion", parent: name, pattern: "^2021\\-03\\-31$")
            try self.validate(self.script, name: "script", parent: name, max: 5120)
            try self.validate(self.script, name: "script", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case launchProfileProtocolVersion = "launchProfileProtocolVersion"
            case platform = "platform"
            case runContext = "runContext"
            case script = "script"
        }
    }

    public struct StudioComponentSummary: AWSDecodableShape {
        /// The ISO timestamp in seconds for when the resource was created.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var createdAt: Date?
        /// The user ID of the user that created the studio component.
        public let createdBy: String?
        /// The description.
        public let description: String?
        /// The name for the studio component.
        public let name: String?
        /// The unique identifier for a studio component resource.
        public let studioComponentId: String?
        /// The specific subtype of a studio component.
        public let subtype: StudioComponentSubtype?
        /// The type of the studio component.
        public let type: StudioComponentType?
        /// The ISO timestamp in seconds for when the resource was updated.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var updatedAt: Date?
        /// The user ID of the user that most recently updated the resource.
        public let updatedBy: String?

        public init(createdAt: Date? = nil, createdBy: String? = nil, description: String? = nil, name: String? = nil, studioComponentId: String? = nil, subtype: StudioComponentSubtype? = nil, type: StudioComponentType? = nil, updatedAt: Date? = nil, updatedBy: String? = nil) {
            self.createdAt = createdAt
            self.createdBy = createdBy
            self.description = description
            self.name = name
            self.studioComponentId = studioComponentId
            self.subtype = subtype
            self.type = type
            self.updatedAt = updatedAt
            self.updatedBy = updatedBy
        }

        private enum CodingKeys: String, CodingKey {
            case createdAt = "createdAt"
            case createdBy = "createdBy"
            case description = "description"
            case name = "name"
            case studioComponentId = "studioComponentId"
            case subtype = "subtype"
            case type = "type"
            case updatedAt = "updatedAt"
            case updatedBy = "updatedBy"
        }
    }

    public struct StudioEncryptionConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The ARN for a KMS key that is used to encrypt studio data.
        public let keyArn: String?
        /// The type of KMS key that is used to encrypt studio data.
        public let keyType: StudioEncryptionConfigurationKeyType

        public init(keyArn: String? = nil, keyType: StudioEncryptionConfigurationKeyType) {
            self.keyArn = keyArn
            self.keyType = keyType
        }

        public func validate(name: String) throws {
            try self.validate(self.keyArn, name: "keyArn", parent: name, min: 4)
            try self.validate(self.keyArn, name: "keyArn", parent: name, pattern: "^arn:.*")
        }

        private enum CodingKeys: String, CodingKey {
            case keyArn = "keyArn"
            case keyType = "keyType"
        }
    }

    public struct StudioMembership: AWSDecodableShape {
        /// The ID of the identity store.
        public let identityStoreId: String?
        /// The persona.
        public let persona: StudioPersona?
        /// The principal ID.
        public let principalId: String?
        /// The Active Directory Security Identifier for this user, if available.
        public let sid: String?

        public init(identityStoreId: String? = nil, persona: StudioPersona? = nil, principalId: String? = nil, sid: String? = nil) {
            self.identityStoreId = identityStoreId
            self.persona = persona
            self.principalId = principalId
            self.sid = sid
        }

        private enum CodingKeys: String, CodingKey {
            case identityStoreId = "identityStoreId"
            case persona = "persona"
            case principalId = "principalId"
            case sid = "sid"
        }
    }

    public struct TagResourceRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the resource you want to add tags to.
        public let resourceArn: String
        /// A collection of labels, in the form of key-value pairs, that apply to this resource.
        public let tags: [String: String]?

        public init(resourceArn: String, tags: [String: String]? = nil) {
            self.resourceArn = resourceArn
            self.tags = tags
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.resourceArn, key: "resourceArn")
            try container.encodeIfPresent(self.tags, forKey: .tags)
        }

        private enum CodingKeys: String, CodingKey {
            case tags = "tags"
        }
    }

    public struct TagResourceResponse: AWSDecodableShape {
        public init() {}
    }

    public struct UntagResourceRequest: AWSEncodableShape {
        /// Identifies the Amazon Resource Name(ARN) key from which you are removing tags.
        public let resourceArn: String
        /// One or more tag keys. Specify only the tag keys, not the tag values.
        public let tagKeys: [String]

        public init(resourceArn: String, tagKeys: [String]) {
            self.resourceArn = resourceArn
            self.tagKeys = tagKeys
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.resourceArn, key: "resourceArn")
            request.encodeQuery(self.tagKeys, key: "tagKeys")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct UntagResourceResponse: AWSDecodableShape {
        public init() {}
    }

    public struct UpdateLaunchProfileMemberRequest: AWSEncodableShape {
        /// Unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If you don’t specify a client token, the Amazon Web Services SDK automatically generates a client token and uses it for the request to ensure idempotency.
        public let clientToken: String?
        /// The ID of the launch profile used to control access from the streaming session.
        public let launchProfileId: String
        /// The persona.
        public let persona: LaunchProfilePersona
        /// The principal ID. This currently supports a IAM Identity Center UserId.
        public let principalId: String
        /// The studio ID.
        public let studioId: String

        public init(clientToken: String? = UpdateLaunchProfileMemberRequest.idempotencyToken(), launchProfileId: String, persona: LaunchProfilePersona, principalId: String, studioId: String) {
            self.clientToken = clientToken
            self.launchProfileId = launchProfileId
            self.persona = persona
            self.principalId = principalId
            self.studioId = studioId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodeHeader(self.clientToken, key: "X-Amz-Client-Token")
            request.encodePath(self.launchProfileId, key: "launchProfileId")
            try container.encode(self.persona, forKey: .persona)
            request.encodePath(self.principalId, key: "principalId")
            request.encodePath(self.studioId, key: "studioId")
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 64)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case persona = "persona"
        }
    }

    public struct UpdateLaunchProfileMemberResponse: AWSDecodableShape {
        /// The updated member.
        public let member: LaunchProfileMembership?

        public init(member: LaunchProfileMembership? = nil) {
            self.member = member
        }

        private enum CodingKeys: String, CodingKey {
            case member = "member"
        }
    }

    public struct UpdateLaunchProfileRequest: AWSEncodableShape {
        /// Unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If you don’t specify a client token, the Amazon Web Services SDK automatically generates a client token and uses it for the request to ensure idempotency.
        public let clientToken: String?
        /// The description.
        public let description: String?
        /// The ID of the launch profile used to control access from the streaming session.
        public let launchProfileId: String
        /// The version number of the protocol that is used by the launch profile. The only valid version is "2021-03-31".
        public let launchProfileProtocolVersions: [String]?
        /// The name for the launch profile.
        public let name: String?
        /// A configuration for a streaming session.
        public let streamConfiguration: StreamConfigurationCreate?
        /// Unique identifiers for a collection of studio components that can be used with this launch profile.
        public let studioComponentIds: [String]?
        /// The studio ID.
        public let studioId: String

        public init(clientToken: String? = UpdateLaunchProfileRequest.idempotencyToken(), description: String? = nil, launchProfileId: String, launchProfileProtocolVersions: [String]? = nil, name: String? = nil, streamConfiguration: StreamConfigurationCreate? = nil, studioComponentIds: [String]? = nil, studioId: String) {
            self.clientToken = clientToken
            self.description = description
            self.launchProfileId = launchProfileId
            self.launchProfileProtocolVersions = launchProfileProtocolVersions
            self.name = name
            self.streamConfiguration = streamConfiguration
            self.studioComponentIds = studioComponentIds
            self.studioId = studioId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodeHeader(self.clientToken, key: "X-Amz-Client-Token")
            try container.encodeIfPresent(self.description, forKey: .description)
            request.encodePath(self.launchProfileId, key: "launchProfileId")
            try container.encodeIfPresent(self.launchProfileProtocolVersions, forKey: .launchProfileProtocolVersions)
            try container.encodeIfPresent(self.name, forKey: .name)
            try container.encodeIfPresent(self.streamConfiguration, forKey: .streamConfiguration)
            try container.encodeIfPresent(self.studioComponentIds, forKey: .studioComponentIds)
            request.encodePath(self.studioId, key: "studioId")
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 64)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.validate(self.description, name: "description", parent: name, max: 256)
            try self.launchProfileProtocolVersions?.forEach {
                try validate($0, name: "launchProfileProtocolVersions[]", parent: name, max: 10)
                try validate($0, name: "launchProfileProtocolVersions[]", parent: name, pattern: "^2021\\-03\\-31$")
            }
            try self.validate(self.name, name: "name", parent: name, max: 64)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.streamConfiguration?.validate(name: "\(name).streamConfiguration")
            try self.validate(self.studioComponentIds, name: "studioComponentIds", parent: name, max: 100)
            try self.validate(self.studioComponentIds, name: "studioComponentIds", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case description = "description"
            case launchProfileProtocolVersions = "launchProfileProtocolVersions"
            case name = "name"
            case streamConfiguration = "streamConfiguration"
            case studioComponentIds = "studioComponentIds"
        }
    }

    public struct UpdateLaunchProfileResponse: AWSDecodableShape {
        /// The launch profile.
        public let launchProfile: LaunchProfile?

        public init(launchProfile: LaunchProfile? = nil) {
            self.launchProfile = launchProfile
        }

        private enum CodingKeys: String, CodingKey {
            case launchProfile = "launchProfile"
        }
    }

    public struct UpdateStreamingImageRequest: AWSEncodableShape {
        /// Unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If you don’t specify a client token, the Amazon Web Services SDK automatically generates a client token and uses it for the request to ensure idempotency.
        public let clientToken: String?
        /// The description.
        public let description: String?
        /// The name for the streaming image.
        public let name: String?
        /// The streaming image ID.
        public let streamingImageId: String
        /// The studio ID.
        public let studioId: String

        public init(clientToken: String? = UpdateStreamingImageRequest.idempotencyToken(), description: String? = nil, name: String? = nil, streamingImageId: String, studioId: String) {
            self.clientToken = clientToken
            self.description = description
            self.name = name
            self.streamingImageId = streamingImageId
            self.studioId = studioId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodeHeader(self.clientToken, key: "X-Amz-Client-Token")
            try container.encodeIfPresent(self.description, forKey: .description)
            try container.encodeIfPresent(self.name, forKey: .name)
            request.encodePath(self.streamingImageId, key: "streamingImageId")
            request.encodePath(self.studioId, key: "studioId")
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 64)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.validate(self.description, name: "description", parent: name, max: 256)
            try self.validate(self.name, name: "name", parent: name, max: 64)
        }

        private enum CodingKeys: String, CodingKey {
            case description = "description"
            case name = "name"
        }
    }

    public struct UpdateStreamingImageResponse: AWSDecodableShape {
        public let streamingImage: StreamingImage?

        public init(streamingImage: StreamingImage? = nil) {
            self.streamingImage = streamingImage
        }

        private enum CodingKeys: String, CodingKey {
            case streamingImage = "streamingImage"
        }
    }

    public struct UpdateStudioComponentRequest: AWSEncodableShape {
        /// Unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If you don’t specify a client token, the Amazon Web Services SDK automatically generates a client token and uses it for the request to ensure idempotency.
        public let clientToken: String?
        /// The configuration of the studio component, based on component type.
        public let configuration: StudioComponentConfiguration?
        /// The description.
        public let description: String?
        /// The EC2 security groups that control access to the studio component.
        public let ec2SecurityGroupIds: [String]?
        /// Initialization scripts for studio components.
        public let initializationScripts: [StudioComponentInitializationScript]?
        /// The name for the studio component.
        public let name: String?
        /// An IAM role attached to a Studio Component that gives the studio component access to Amazon Web Services resources at anytime while the instance is running.
        public let runtimeRoleArn: String?
        /// Parameters for the studio component scripts.
        public let scriptParameters: [ScriptParameterKeyValue]?
        /// An IAM role attached to Studio Component when the system initialization script runs which give the studio component access to Amazon Web Services resources when the system initialization script runs.
        public let secureInitializationRoleArn: String?
        /// The studio component ID.
        public let studioComponentId: String
        /// The studio ID.
        public let studioId: String
        /// The specific subtype of a studio component.
        public let subtype: StudioComponentSubtype?
        /// The type of the studio component.
        public let type: StudioComponentType?

        public init(clientToken: String? = UpdateStudioComponentRequest.idempotencyToken(), configuration: StudioComponentConfiguration? = nil, description: String? = nil, ec2SecurityGroupIds: [String]? = nil, initializationScripts: [StudioComponentInitializationScript]? = nil, name: String? = nil, runtimeRoleArn: String? = nil, scriptParameters: [ScriptParameterKeyValue]? = nil, secureInitializationRoleArn: String? = nil, studioComponentId: String, studioId: String, subtype: StudioComponentSubtype? = nil, type: StudioComponentType? = nil) {
            self.clientToken = clientToken
            self.configuration = configuration
            self.description = description
            self.ec2SecurityGroupIds = ec2SecurityGroupIds
            self.initializationScripts = initializationScripts
            self.name = name
            self.runtimeRoleArn = runtimeRoleArn
            self.scriptParameters = scriptParameters
            self.secureInitializationRoleArn = secureInitializationRoleArn
            self.studioComponentId = studioComponentId
            self.studioId = studioId
            self.subtype = subtype
            self.type = type
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodeHeader(self.clientToken, key: "X-Amz-Client-Token")
            try container.encodeIfPresent(self.configuration, forKey: .configuration)
            try container.encodeIfPresent(self.description, forKey: .description)
            try container.encodeIfPresent(self.ec2SecurityGroupIds, forKey: .ec2SecurityGroupIds)
            try container.encodeIfPresent(self.initializationScripts, forKey: .initializationScripts)
            try container.encodeIfPresent(self.name, forKey: .name)
            try container.encodeIfPresent(self.runtimeRoleArn, forKey: .runtimeRoleArn)
            try container.encodeIfPresent(self.scriptParameters, forKey: .scriptParameters)
            try container.encodeIfPresent(self.secureInitializationRoleArn, forKey: .secureInitializationRoleArn)
            request.encodePath(self.studioComponentId, key: "studioComponentId")
            request.encodePath(self.studioId, key: "studioId")
            try container.encodeIfPresent(self.subtype, forKey: .subtype)
            try container.encodeIfPresent(self.type, forKey: .type)
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 64)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.configuration?.validate(name: "\(name).configuration")
            try self.validate(self.description, name: "description", parent: name, max: 256)
            try self.validate(self.ec2SecurityGroupIds, name: "ec2SecurityGroupIds", parent: name, max: 30)
            try self.initializationScripts?.forEach {
                try $0.validate(name: "\(name).initializationScripts[]")
            }
            try self.validate(self.name, name: "name", parent: name, max: 64)
            try self.validate(self.runtimeRoleArn, name: "runtimeRoleArn", parent: name, max: 2048)
            try self.scriptParameters?.forEach {
                try $0.validate(name: "\(name).scriptParameters[]")
            }
            try self.validate(self.scriptParameters, name: "scriptParameters", parent: name, max: 30)
            try self.validate(self.secureInitializationRoleArn, name: "secureInitializationRoleArn", parent: name, max: 2048)
        }

        private enum CodingKeys: String, CodingKey {
            case configuration = "configuration"
            case description = "description"
            case ec2SecurityGroupIds = "ec2SecurityGroupIds"
            case initializationScripts = "initializationScripts"
            case name = "name"
            case runtimeRoleArn = "runtimeRoleArn"
            case scriptParameters = "scriptParameters"
            case secureInitializationRoleArn = "secureInitializationRoleArn"
            case subtype = "subtype"
            case type = "type"
        }
    }

    public struct UpdateStudioComponentResponse: AWSDecodableShape {
        /// Information about the studio component.
        public let studioComponent: StudioComponent?

        public init(studioComponent: StudioComponent? = nil) {
            self.studioComponent = studioComponent
        }

        private enum CodingKeys: String, CodingKey {
            case studioComponent = "studioComponent"
        }
    }

    public struct UpdateStudioRequest: AWSEncodableShape {
        /// The IAM role that Studio Admins will assume when logging in to the Nimble Studio portal.
        public let adminRoleArn: String?
        /// Unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If you don’t specify a client token, the Amazon Web Services SDK automatically generates a client token and uses it for the request to ensure idempotency.
        public let clientToken: String?
        /// A friendly name for the studio.
        public let displayName: String?
        /// The studio ID.
        public let studioId: String
        /// The IAM role that Studio Users will assume when logging in to the Nimble Studio portal.
        public let userRoleArn: String?

        public init(adminRoleArn: String? = nil, clientToken: String? = UpdateStudioRequest.idempotencyToken(), displayName: String? = nil, studioId: String, userRoleArn: String? = nil) {
            self.adminRoleArn = adminRoleArn
            self.clientToken = clientToken
            self.displayName = displayName
            self.studioId = studioId
            self.userRoleArn = userRoleArn
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.adminRoleArn, forKey: .adminRoleArn)
            request.encodeHeader(self.clientToken, key: "X-Amz-Client-Token")
            try container.encodeIfPresent(self.displayName, forKey: .displayName)
            request.encodePath(self.studioId, key: "studioId")
            try container.encodeIfPresent(self.userRoleArn, forKey: .userRoleArn)
        }

        public func validate(name: String) throws {
            try self.validate(self.adminRoleArn, name: "adminRoleArn", parent: name, max: 2048)
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 64)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.validate(self.displayName, name: "displayName", parent: name, max: 64)
            try self.validate(self.userRoleArn, name: "userRoleArn", parent: name, max: 2048)
        }

        private enum CodingKeys: String, CodingKey {
            case adminRoleArn = "adminRoleArn"
            case displayName = "displayName"
            case userRoleArn = "userRoleArn"
        }
    }

    public struct UpdateStudioResponse: AWSDecodableShape {
        /// Information about a studio.
        public let studio: Studio

        public init(studio: Studio) {
            self.studio = studio
        }

        private enum CodingKeys: String, CodingKey {
            case studio = "studio"
        }
    }

    public struct ValidationResult: AWSDecodableShape {
        /// The current state.
        public let state: LaunchProfileValidationState
        /// The status code. This will contain the failure reason if the state is VALIDATION_FAILED.
        public let statusCode: LaunchProfileValidationStatusCode
        /// The status message for the validation result.
        public let statusMessage: String
        /// The type of the validation result.
        public let type: LaunchProfileValidationType

        public init(state: LaunchProfileValidationState, statusCode: LaunchProfileValidationStatusCode, statusMessage: String, type: LaunchProfileValidationType) {
            self.state = state
            self.statusCode = statusCode
            self.statusMessage = statusMessage
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case state = "state"
            case statusCode = "statusCode"
            case statusMessage = "statusMessage"
            case type = "type"
        }
    }

    public struct VolumeConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The number of I/O operations per second for the root volume that is attached to streaming session.
        public let iops: Int?
        /// The size of the root volume that is attached to the streaming session. The root volume size is measured in GiBs.
        public let size: Int?
        /// The throughput to provision for the root volume that is attached to the streaming session. The throughput is measured in MiB/s.
        public let throughput: Int?

        public init(iops: Int? = nil, size: Int? = nil, throughput: Int? = nil) {
            self.iops = iops
            self.size = size
            self.throughput = throughput
        }

        public func validate(name: String) throws {
            try self.validate(self.iops, name: "iops", parent: name, max: 16000)
            try self.validate(self.iops, name: "iops", parent: name, min: 3000)
            try self.validate(self.size, name: "size", parent: name, max: 16000)
            try self.validate(self.size, name: "size", parent: name, min: 100)
            try self.validate(self.throughput, name: "throughput", parent: name, max: 1000)
            try self.validate(self.throughput, name: "throughput", parent: name, min: 125)
        }

        private enum CodingKeys: String, CodingKey {
            case iops = "iops"
            case size = "size"
            case throughput = "throughput"
        }
    }
}

// MARK: - Errors

/// Error enum for Nimble
public struct NimbleErrorType: AWSErrorType {
    enum Code: String {
        case accessDeniedException = "AccessDeniedException"
        case conflictException = "ConflictException"
        case internalServerErrorException = "InternalServerErrorException"
        case resourceNotFoundException = "ResourceNotFoundException"
        case serviceQuotaExceededException = "ServiceQuotaExceededException"
        case throttlingException = "ThrottlingException"
        case validationException = "ValidationException"
    }

    private let error: Code
    public let context: AWSErrorContext?

    /// initialize Nimble
    public init?(errorCode: String, context: AWSErrorContext) {
        guard let error = Code(rawValue: errorCode) else { return nil }
        self.error = error
        self.context = context
    }

    internal init(_ error: Code) {
        self.error = error
        self.context = nil
    }

    /// return error code string
    public var errorCode: String { self.error.rawValue }

    /// You are not authorized to perform this operation. Check your IAM policies, and ensure that you are using the correct access keys.
    public static var accessDeniedException: Self { .init(.accessDeniedException) }
    /// Another operation is in progress.
    public static var conflictException: Self { .init(.conflictException) }
    /// An internal error has occurred. Please retry your request.
    public static var internalServerErrorException: Self { .init(.internalServerErrorException) }
    /// The specified resource could not be found.
    public static var resourceNotFoundException: Self { .init(.resourceNotFoundException) }
    /// Your current quota does not allow you to perform the request action. You can request increases for some quotas, and other quotas cannot be increased. Please use Amazon Web Services Service Quotas to request an increase.
    public static var serviceQuotaExceededException: Self { .init(.serviceQuotaExceededException) }
    /// The request throughput limit was exceeded.
    public static var throttlingException: Self { .init(.throttlingException) }
    /// One of the parameters in the request is invalid.
    public static var validationException: Self { .init(.validationException) }
}

extension NimbleErrorType: Equatable {
    public static func == (lhs: NimbleErrorType, rhs: NimbleErrorType) -> Bool {
        lhs.error == rhs.error
    }
}

extension NimbleErrorType: CustomStringConvertible {
    public var description: String {
        return "\(self.error.rawValue): \(self.message ?? "")"
    }
}
