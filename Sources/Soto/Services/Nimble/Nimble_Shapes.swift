//===----------------------------------------------------------------------===//
//
// This source file is part of the Soto for AWS open source project
//
// Copyright (c) 2017-2021 the Soto project authors
// Licensed under Apache License v2.0
//
// See LICENSE.txt for license information
// See CONTRIBUTORS.txt for the list of Soto project authors
//
// SPDX-License-Identifier: Apache-2.0
//
//===----------------------------------------------------------------------===//

// THIS FILE IS AUTOMATICALLY GENERATED by https://github.com/soto-project/soto-codegenerator.
// DO NOT EDIT.

import Foundation
import SotoCore

extension Nimble {
    // MARK: Enums

    public enum LaunchProfilePersona: String, CustomStringConvertible, Codable {
        case user = "USER"
        public var description: String { return self.rawValue }
    }

    public enum LaunchProfilePlatform: String, CustomStringConvertible, Codable {
        case linux = "LINUX"
        case windows = "WINDOWS"
        public var description: String { return self.rawValue }
    }

    public enum LaunchProfileState: String, CustomStringConvertible, Codable {
        case createFailed = "CREATE_FAILED"
        case createInProgress = "CREATE_IN_PROGRESS"
        case deleted = "DELETED"
        case deleteFailed = "DELETE_FAILED"
        case deleteInProgress = "DELETE_IN_PROGRESS"
        case ready = "READY"
        case updateFailed = "UPDATE_FAILED"
        case updateInProgress = "UPDATE_IN_PROGRESS"
        public var description: String { return self.rawValue }
    }

    public enum LaunchProfileStatusCode: String, CustomStringConvertible, Codable {
        case encryptionKeyAccessDenied = "ENCRYPTION_KEY_ACCESS_DENIED"
        case encryptionKeyNotFound = "ENCRYPTION_KEY_NOT_FOUND"
        case internalError = "INTERNAL_ERROR"
        case invalidSubnetsProvided = "INVALID_SUBNETS_PROVIDED"
        case launchProfileCreated = "LAUNCH_PROFILE_CREATED"
        case launchProfileCreateInProgress = "LAUNCH_PROFILE_CREATE_IN_PROGRESS"
        case launchProfileDeleted = "LAUNCH_PROFILE_DELETED"
        case launchProfileDeleteInProgress = "LAUNCH_PROFILE_DELETE_IN_PROGRESS"
        case launchProfileUpdated = "LAUNCH_PROFILE_UPDATED"
        case launchProfileUpdateInProgress = "LAUNCH_PROFILE_UPDATE_IN_PROGRESS"
        case launchProfileWithStreamSessionsNotDeleted = "LAUNCH_PROFILE_WITH_STREAM_SESSIONS_NOT_DELETED"
        case streamingImageNotFound = "STREAMING_IMAGE_NOT_FOUND"
        case streamingImageNotReady = "STREAMING_IMAGE_NOT_READY"
        public var description: String { return self.rawValue }
    }

    public enum LaunchProfileValidationState: String, CustomStringConvertible, Codable {
        case validationFailed = "VALIDATION_FAILED"
        case validationFailedInternalServerError = "VALIDATION_FAILED_INTERNAL_SERVER_ERROR"
        case validationInProgress = "VALIDATION_IN_PROGRESS"
        case validationNotStarted = "VALIDATION_NOT_STARTED"
        case validationSuccess = "VALIDATION_SUCCESS"
        public var description: String { return self.rawValue }
    }

    public enum LaunchProfileValidationStatusCode: String, CustomStringConvertible, Codable {
        case validationFailedInternalServerError = "VALIDATION_FAILED_INTERNAL_SERVER_ERROR"
        case validationFailedInvalidActiveDirectory = "VALIDATION_FAILED_INVALID_ACTIVE_DIRECTORY"
        case validationFailedInvalidSecurityGroupAssociation = "VALIDATION_FAILED_INVALID_SECURITY_GROUP_ASSOCIATION"
        case validationFailedInvalidSubnetRouteTableAssociation = "VALIDATION_FAILED_INVALID_SUBNET_ROUTE_TABLE_ASSOCIATION"
        case validationFailedSubnetNotFound = "VALIDATION_FAILED_SUBNET_NOT_FOUND"
        case validationFailedUnauthorized = "VALIDATION_FAILED_UNAUTHORIZED"
        case validationInProgress = "VALIDATION_IN_PROGRESS"
        case validationNotStarted = "VALIDATION_NOT_STARTED"
        case validationSuccess = "VALIDATION_SUCCESS"
        public var description: String { return self.rawValue }
    }

    public enum LaunchProfileValidationType: String, CustomStringConvertible, Codable {
        case validateActiveDirectoryStudioComponent = "VALIDATE_ACTIVE_DIRECTORY_STUDIO_COMPONENT"
        case validateNetworkAclAssociation = "VALIDATE_NETWORK_ACL_ASSOCIATION"
        case validateSecurityGroupAssociation = "VALIDATE_SECURITY_GROUP_ASSOCIATION"
        case validateSubnetAssociation = "VALIDATE_SUBNET_ASSOCIATION"
        public var description: String { return self.rawValue }
    }

    public enum StreamingClipboardMode: String, CustomStringConvertible, Codable {
        case disabled = "DISABLED"
        case enabled = "ENABLED"
        public var description: String { return self.rawValue }
    }

    public enum StreamingImageEncryptionConfigurationKeyType: String, CustomStringConvertible, Codable {
        case customerManagedKey = "CUSTOMER_MANAGED_KEY"
        public var description: String { return self.rawValue }
    }

    public enum StreamingImageState: String, CustomStringConvertible, Codable {
        case createFailed = "CREATE_FAILED"
        case createInProgress = "CREATE_IN_PROGRESS"
        case deleted = "DELETED"
        case deleteFailed = "DELETE_FAILED"
        case deleteInProgress = "DELETE_IN_PROGRESS"
        case ready = "READY"
        case updateFailed = "UPDATE_FAILED"
        case updateInProgress = "UPDATE_IN_PROGRESS"
        public var description: String { return self.rawValue }
    }

    public enum StreamingImageStatusCode: String, CustomStringConvertible, Codable {
        case accessDenied = "ACCESS_DENIED"
        case internalError = "INTERNAL_ERROR"
        case streamingImageCreateInProgress = "STREAMING_IMAGE_CREATE_IN_PROGRESS"
        case streamingImageDeleted = "STREAMING_IMAGE_DELETED"
        case streamingImageDeleteInProgress = "STREAMING_IMAGE_DELETE_IN_PROGRESS"
        case streamingImageReady = "STREAMING_IMAGE_READY"
        case streamingImageUpdateInProgress = "STREAMING_IMAGE_UPDATE_IN_PROGRESS"
        public var description: String { return self.rawValue }
    }

    public enum StreamingInstanceType: String, CustomStringConvertible, Codable {
        case g4dn12Xlarge = "g4dn.12xlarge"
        case g4dn16Xlarge = "g4dn.16xlarge"
        case g4dn2Xlarge = "g4dn.2xlarge"
        case g4dn4Xlarge = "g4dn.4xlarge"
        case g4dn8Xlarge = "g4dn.8xlarge"
        case g4dnXlarge = "g4dn.xlarge"
        public var description: String { return self.rawValue }
    }

    public enum StreamingSessionState: String, CustomStringConvertible, Codable {
        case createFailed = "CREATE_FAILED"
        case createInProgress = "CREATE_IN_PROGRESS"
        case deleted = "DELETED"
        case deleteFailed = "DELETE_FAILED"
        case deleteInProgress = "DELETE_IN_PROGRESS"
        case ready = "READY"
        case startFailed = "START_FAILED"
        case startInProgress = "START_IN_PROGRESS"
        case stopped = "STOPPED"
        case stopFailed = "STOP_FAILED"
        case stopInProgress = "STOP_IN_PROGRESS"
        public var description: String { return self.rawValue }
    }

    public enum StreamingSessionStatusCode: String, CustomStringConvertible, Codable {
        case activeDirectoryDomainJoinError = "ACTIVE_DIRECTORY_DOMAIN_JOIN_ERROR"
        case amiValidationError = "AMI_VALIDATION_ERROR"
        case decryptStreamingImageError = "DECRYPT_STREAMING_IMAGE_ERROR"
        case initializationScriptError = "INITIALIZATION_SCRIPT_ERROR"
        case insufficientCapacity = "INSUFFICIENT_CAPACITY"
        case internalError = "INTERNAL_ERROR"
        case networkConnectionError = "NETWORK_CONNECTION_ERROR"
        case networkInterfaceError = "NETWORK_INTERFACE_ERROR"
        case streamingSessionCreateInProgress = "STREAMING_SESSION_CREATE_IN_PROGRESS"
        case streamingSessionDeleted = "STREAMING_SESSION_DELETED"
        case streamingSessionDeleteInProgress = "STREAMING_SESSION_DELETE_IN_PROGRESS"
        case streamingSessionReady = "STREAMING_SESSION_READY"
        case streamingSessionStarted = "STREAMING_SESSION_STARTED"
        case streamingSessionStartInProgress = "STREAMING_SESSION_START_IN_PROGRESS"
        case streamingSessionStopped = "STREAMING_SESSION_STOPPED"
        case streamingSessionStopInProgress = "STREAMING_SESSION_STOP_IN_PROGRESS"
        public var description: String { return self.rawValue }
    }

    public enum StreamingSessionStorageMode: String, CustomStringConvertible, Codable {
        case upload = "UPLOAD"
        public var description: String { return self.rawValue }
    }

    public enum StreamingSessionStreamState: String, CustomStringConvertible, Codable {
        case createFailed = "CREATE_FAILED"
        case createInProgress = "CREATE_IN_PROGRESS"
        case deleted = "DELETED"
        case deleteFailed = "DELETE_FAILED"
        case deleteInProgress = "DELETE_IN_PROGRESS"
        case ready = "READY"
        public var description: String { return self.rawValue }
    }

    public enum StreamingSessionStreamStatusCode: String, CustomStringConvertible, Codable {
        case internalError = "INTERNAL_ERROR"
        case networkConnectionError = "NETWORK_CONNECTION_ERROR"
        case streamCreateInProgress = "STREAM_CREATE_IN_PROGRESS"
        case streamDeleted = "STREAM_DELETED"
        case streamDeleteInProgress = "STREAM_DELETE_IN_PROGRESS"
        case streamReady = "STREAM_READY"
        public var description: String { return self.rawValue }
    }

    public enum StudioComponentInitializationScriptRunContext: String, CustomStringConvertible, Codable {
        case systemInitialization = "SYSTEM_INITIALIZATION"
        case userInitialization = "USER_INITIALIZATION"
        public var description: String { return self.rawValue }
    }

    public enum StudioComponentState: String, CustomStringConvertible, Codable {
        case createFailed = "CREATE_FAILED"
        case createInProgress = "CREATE_IN_PROGRESS"
        case deleted = "DELETED"
        case deleteFailed = "DELETE_FAILED"
        case deleteInProgress = "DELETE_IN_PROGRESS"
        case ready = "READY"
        case updateFailed = "UPDATE_FAILED"
        case updateInProgress = "UPDATE_IN_PROGRESS"
        public var description: String { return self.rawValue }
    }

    public enum StudioComponentStatusCode: String, CustomStringConvertible, Codable {
        case activeDirectoryAlreadyExists = "ACTIVE_DIRECTORY_ALREADY_EXISTS"
        case encryptionKeyAccessDenied = "ENCRYPTION_KEY_ACCESS_DENIED"
        case encryptionKeyNotFound = "ENCRYPTION_KEY_NOT_FOUND"
        case internalError = "INTERNAL_ERROR"
        case studioComponentCreated = "STUDIO_COMPONENT_CREATED"
        case studioComponentCreateInProgress = "STUDIO_COMPONENT_CREATE_IN_PROGRESS"
        case studioComponentDeleted = "STUDIO_COMPONENT_DELETED"
        case studioComponentDeleteInProgress = "STUDIO_COMPONENT_DELETE_IN_PROGRESS"
        case studioComponentUpdated = "STUDIO_COMPONENT_UPDATED"
        case studioComponentUpdateInProgress = "STUDIO_COMPONENT_UPDATE_IN_PROGRESS"
        public var description: String { return self.rawValue }
    }

    public enum StudioComponentSubtype: String, CustomStringConvertible, Codable {
        case amazonFsxForLustre = "AMAZON_FSX_FOR_LUSTRE"
        case amazonFsxForWindows = "AMAZON_FSX_FOR_WINDOWS"
        case awsManagedMicrosoftAd = "AWS_MANAGED_MICROSOFT_AD"
        case custom = "CUSTOM"
        public var description: String { return self.rawValue }
    }

    public enum StudioComponentType: String, CustomStringConvertible, Codable {
        case activeDirectory = "ACTIVE_DIRECTORY"
        case computeFarm = "COMPUTE_FARM"
        case custom = "CUSTOM"
        case licenseService = "LICENSE_SERVICE"
        case sharedFileSystem = "SHARED_FILE_SYSTEM"
        public var description: String { return self.rawValue }
    }

    public enum StudioEncryptionConfigurationKeyType: String, CustomStringConvertible, Codable {
        case awsOwnedKey = "AWS_OWNED_KEY"
        case customerManagedKey = "CUSTOMER_MANAGED_KEY"
        public var description: String { return self.rawValue }
    }

    public enum StudioPersona: String, CustomStringConvertible, Codable {
        case administrator = "ADMINISTRATOR"
        public var description: String { return self.rawValue }
    }

    public enum StudioState: String, CustomStringConvertible, Codable {
        case createFailed = "CREATE_FAILED"
        case createInProgress = "CREATE_IN_PROGRESS"
        case deleted = "DELETED"
        case deleteFailed = "DELETE_FAILED"
        case deleteInProgress = "DELETE_IN_PROGRESS"
        case ready = "READY"
        case updateFailed = "UPDATE_FAILED"
        case updateInProgress = "UPDATE_IN_PROGRESS"
        public var description: String { return self.rawValue }
    }

    public enum StudioStatusCode: String, CustomStringConvertible, Codable {
        case awsSsoAccessDenied = "AWS_SSO_ACCESS_DENIED"
        case awsSsoConfigurationRepaired = "AWS_SSO_CONFIGURATION_REPAIRED"
        case awsSsoConfigurationRepairInProgress = "AWS_SSO_CONFIGURATION_REPAIR_IN_PROGRESS"
        case awsSsoNotEnabled = "AWS_SSO_NOT_ENABLED"
        case encryptionKeyAccessDenied = "ENCRYPTION_KEY_ACCESS_DENIED"
        case encryptionKeyNotFound = "ENCRYPTION_KEY_NOT_FOUND"
        case internalError = "INTERNAL_ERROR"
        case roleCouldNotBeAssumed = "ROLE_COULD_NOT_BE_ASSUMED"
        case roleNotOwnedByStudioOwner = "ROLE_NOT_OWNED_BY_STUDIO_OWNER"
        case studioCreated = "STUDIO_CREATED"
        case studioCreateInProgress = "STUDIO_CREATE_IN_PROGRESS"
        case studioDeleted = "STUDIO_DELETED"
        case studioDeleteInProgress = "STUDIO_DELETE_IN_PROGRESS"
        case studioUpdated = "STUDIO_UPDATED"
        case studioUpdateInProgress = "STUDIO_UPDATE_IN_PROGRESS"
        case studioWithLaunchProfilesNotDeleted = "STUDIO_WITH_LAUNCH_PROFILES_NOT_DELETED"
        case studioWithStreamingImagesNotDeleted = "STUDIO_WITH_STREAMING_IMAGES_NOT_DELETED"
        case studioWithStudioComponentsNotDeleted = "STUDIO_WITH_STUDIO_COMPONENTS_NOT_DELETED"
        public var description: String { return self.rawValue }
    }

    public enum StudioComponentConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The configuration for a Microsoft Active Directory (Microsoft AD) studio resource.
        case activeDirectoryConfiguration(ActiveDirectoryConfiguration)
        /// The configuration for a render farm that is associated with a studio resource.
        case computeFarmConfiguration(ComputeFarmConfiguration)
        /// The configuration for a license service that is associated with a studio resource.
        case licenseServiceConfiguration(LicenseServiceConfiguration)
        /// The configuration for a shared file storage system that is associated with a studio resource.
        case sharedFileSystemConfiguration(SharedFileSystemConfiguration)

        public init(from decoder: Decoder) throws {
            let container = try decoder.container(keyedBy: CodingKeys.self)
            guard container.allKeys.count == 1, let key = container.allKeys.first else {
                let context = DecodingError.Context(
                    codingPath: container.codingPath,
                    debugDescription: "Expected exactly one key, but got \(container.allKeys.count)"
                )
                throw DecodingError.dataCorrupted(context)
            }
            switch key {
            case .activeDirectoryConfiguration:
                let value = try container.decode(ActiveDirectoryConfiguration.self, forKey: .activeDirectoryConfiguration)
                self = .activeDirectoryConfiguration(value)
            case .computeFarmConfiguration:
                let value = try container.decode(ComputeFarmConfiguration.self, forKey: .computeFarmConfiguration)
                self = .computeFarmConfiguration(value)
            case .licenseServiceConfiguration:
                let value = try container.decode(LicenseServiceConfiguration.self, forKey: .licenseServiceConfiguration)
                self = .licenseServiceConfiguration(value)
            case .sharedFileSystemConfiguration:
                let value = try container.decode(SharedFileSystemConfiguration.self, forKey: .sharedFileSystemConfiguration)
                self = .sharedFileSystemConfiguration(value)
            }
        }

        public func encode(to encoder: Encoder) throws {
            var container = encoder.container(keyedBy: CodingKeys.self)
            switch self {
            case .activeDirectoryConfiguration(let value):
                try container.encode(value, forKey: .activeDirectoryConfiguration)
            case .computeFarmConfiguration(let value):
                try container.encode(value, forKey: .computeFarmConfiguration)
            case .licenseServiceConfiguration(let value):
                try container.encode(value, forKey: .licenseServiceConfiguration)
            case .sharedFileSystemConfiguration(let value):
                try container.encode(value, forKey: .sharedFileSystemConfiguration)
            }
        }

        public func validate(name: String) throws {
            switch self {
            case .activeDirectoryConfiguration(let value):
                try value.validate(name: "\(name).activeDirectoryConfiguration")
            case .sharedFileSystemConfiguration(let value):
                try value.validate(name: "\(name).sharedFileSystemConfiguration")
            default:
                break
            }
        }

        private enum CodingKeys: String, CodingKey {
            case activeDirectoryConfiguration
            case computeFarmConfiguration
            case licenseServiceConfiguration
            case sharedFileSystemConfiguration
        }
    }

    // MARK: Shapes

    public struct AcceptEulasRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "clientToken", location: .header("X-Amz-Client-Token")),
            AWSMemberEncoding(label: "studioId", location: .uri("studioId"))
        ]

        /// Unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If you don’t specify a client token, the AWS SDK automatically generates a client token and uses it for the request to ensure idempotency.
        public let clientToken: String?
        /// The EULA ID.
        public let eulaIds: [String]?
        /// A collection of EULA IDs.
        public let studioId: String

        public init(clientToken: String? = AcceptEulasRequest.idempotencyToken(), eulaIds: [String]? = nil, studioId: String) {
            self.clientToken = clientToken
            self.eulaIds = eulaIds
            self.studioId = studioId
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 64)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case eulaIds
        }
    }

    public struct AcceptEulasResponse: AWSDecodableShape {
        /// A collection of EULA acceptances.
        public let eulaAcceptances: [EulaAcceptance]?

        public init(eulaAcceptances: [EulaAcceptance]? = nil) {
            self.eulaAcceptances = eulaAcceptances
        }

        private enum CodingKeys: String, CodingKey {
            case eulaAcceptances
        }
    }

    public struct ActiveDirectoryComputerAttribute: AWSEncodableShape & AWSDecodableShape {
        /// The name for the LDAP attribute.
        public let name: String?
        /// The value for the LDAP attribute.
        public let value: String?

        public init(name: String? = nil, value: String? = nil) {
            self.name = name
            self.value = value
        }

        public func validate(name: String) throws {
            try self.validate(self.name, name: "name", parent: name, max: 40)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.value, name: "value", parent: name, max: 64)
            try self.validate(self.value, name: "value", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case name
            case value
        }
    }

    public struct ActiveDirectoryConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// A collection of custom attributes for an Active Directory computer.
        public let computerAttributes: [ActiveDirectoryComputerAttribute]?
        /// The directory ID of the Directory Service for Microsoft Active Directory to access using this studio component.
        public let directoryId: String?
        /// The distinguished name (DN) and organizational unit (OU) of an Active Directory computer.
        public let organizationalUnitDistinguishedName: String?

        public init(computerAttributes: [ActiveDirectoryComputerAttribute]? = nil, directoryId: String? = nil, organizationalUnitDistinguishedName: String? = nil) {
            self.computerAttributes = computerAttributes
            self.directoryId = directoryId
            self.organizationalUnitDistinguishedName = organizationalUnitDistinguishedName
        }

        public func validate(name: String) throws {
            try self.computerAttributes?.forEach {
                try $0.validate(name: "\(name).computerAttributes[]")
            }
            try self.validate(self.computerAttributes, name: "computerAttributes", parent: name, max: 50)
            try self.validate(self.organizationalUnitDistinguishedName, name: "organizationalUnitDistinguishedName", parent: name, max: 2000)
            try self.validate(self.organizationalUnitDistinguishedName, name: "organizationalUnitDistinguishedName", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case computerAttributes
            case directoryId
            case organizationalUnitDistinguishedName
        }
    }

    public struct ComputeFarmConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The name of an Active Directory user that is used on ComputeFarm worker instances.
        public let activeDirectoryUser: String?
        /// The endpoint of the ComputeFarm that is accessed by the studio component resource.
        public let endpoint: String?

        public init(activeDirectoryUser: String? = nil, endpoint: String? = nil) {
            self.activeDirectoryUser = activeDirectoryUser
            self.endpoint = endpoint
        }

        private enum CodingKeys: String, CodingKey {
            case activeDirectoryUser
            case endpoint
        }
    }

    public struct CreateLaunchProfileRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "clientToken", location: .header("X-Amz-Client-Token")),
            AWSMemberEncoding(label: "studioId", location: .uri("studioId"))
        ]

        /// Unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If you don’t specify a client token, the AWS SDK automatically generates a client token and uses it for the request to ensure idempotency.
        public let clientToken: String?
        /// The description.
        public let description: String?
        /// Specifies the IDs of the EC2 subnets where streaming sessions will be accessible from. These subnets must support the specified instance types.
        public let ec2SubnetIds: [String]
        /// The version number of the protocol that is used by the launch profile. The only valid version is "2021-03-31".
        public let launchProfileProtocolVersions: [String]
        /// The name for the launch profile.
        public let name: String
        /// A configuration for a streaming session.
        public let streamConfiguration: StreamConfigurationCreate
        /// Unique identifiers for a collection of studio components that can be used with this launch profile.
        public let studioComponentIds: [String]
        /// The studio ID.
        public let studioId: String
        /// A collection of labels, in the form of key:value pairs, that apply to this resource.
        public let tags: [String: String]?

        public init(clientToken: String? = CreateLaunchProfileRequest.idempotencyToken(), description: String? = nil, ec2SubnetIds: [String], launchProfileProtocolVersions: [String], name: String, streamConfiguration: StreamConfigurationCreate, studioComponentIds: [String], studioId: String, tags: [String: String]? = nil) {
            self.clientToken = clientToken
            self.description = description
            self.ec2SubnetIds = ec2SubnetIds
            self.launchProfileProtocolVersions = launchProfileProtocolVersions
            self.name = name
            self.streamConfiguration = streamConfiguration
            self.studioComponentIds = studioComponentIds
            self.studioId = studioId
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 64)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.validate(self.description, name: "description", parent: name, max: 256)
            try self.validate(self.ec2SubnetIds, name: "ec2SubnetIds", parent: name, max: 6)
            try self.launchProfileProtocolVersions.forEach {
                try validate($0, name: "launchProfileProtocolVersions[]", parent: name, max: 10)
                try validate($0, name: "launchProfileProtocolVersions[]", parent: name, pattern: "^2021\\-03\\-31$")
            }
            try self.validate(self.name, name: "name", parent: name, max: 64)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.streamConfiguration.validate(name: "\(name).streamConfiguration")
            try self.validate(self.studioComponentIds, name: "studioComponentIds", parent: name, max: 100)
            try self.validate(self.studioComponentIds, name: "studioComponentIds", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case description
            case ec2SubnetIds
            case launchProfileProtocolVersions
            case name
            case streamConfiguration
            case studioComponentIds
            case tags
        }
    }

    public struct CreateLaunchProfileResponse: AWSDecodableShape {
        /// The launch profile.
        public let launchProfile: LaunchProfile?

        public init(launchProfile: LaunchProfile? = nil) {
            self.launchProfile = launchProfile
        }

        private enum CodingKeys: String, CodingKey {
            case launchProfile
        }
    }

    public struct CreateStreamingImageRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "clientToken", location: .header("X-Amz-Client-Token")),
            AWSMemberEncoding(label: "studioId", location: .uri("studioId"))
        ]

        /// Unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If you don’t specify a client token, the AWS SDK automatically generates a client token and uses it for the request to ensure idempotency.
        public let clientToken: String?
        /// A human-readable description of the streaming image.
        public let description: String?
        /// The ID of an EC2 machine image with which to create this streaming image.
        public let ec2ImageId: String
        /// A friendly name for a streaming image resource.
        public let name: String
        /// The studio ID.
        public let studioId: String
        /// A collection of labels, in the form of key:value pairs, that apply to this resource.
        public let tags: [String: String]?

        public init(clientToken: String? = CreateStreamingImageRequest.idempotencyToken(), description: String? = nil, ec2ImageId: String, name: String, studioId: String, tags: [String: String]? = nil) {
            self.clientToken = clientToken
            self.description = description
            self.ec2ImageId = ec2ImageId
            self.name = name
            self.studioId = studioId
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 64)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.validate(self.description, name: "description", parent: name, max: 256)
            try self.validate(self.ec2ImageId, name: "ec2ImageId", parent: name, pattern: "^ami-[0-9A-z]+$")
            try self.validate(self.name, name: "name", parent: name, max: 64)
        }

        private enum CodingKeys: String, CodingKey {
            case description
            case ec2ImageId
            case name
            case tags
        }
    }

    public struct CreateStreamingImageResponse: AWSDecodableShape {
        /// The streaming image.
        public let streamingImage: StreamingImage?

        public init(streamingImage: StreamingImage? = nil) {
            self.streamingImage = streamingImage
        }

        private enum CodingKeys: String, CodingKey {
            case streamingImage
        }
    }

    public struct CreateStreamingSessionRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "clientToken", location: .header("X-Amz-Client-Token")),
            AWSMemberEncoding(label: "studioId", location: .uri("studioId"))
        ]

        /// Unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If you don’t specify a client token, the AWS SDK automatically generates a client token and uses it for the request to ensure idempotency.
        public let clientToken: String?
        /// The EC2 Instance type used for the streaming session.
        public let ec2InstanceType: StreamingInstanceType?
        /// The launch profile ID.
        public let launchProfileId: String?
        /// The user ID of the user that owns the streaming session. The user that owns the session will be logging into the session and interacting with the virtual workstation.
        public let ownedBy: String?
        /// The ID of the streaming image.
        public let streamingImageId: String?
        /// The studio ID.
        public let studioId: String
        /// A collection of labels, in the form of key:value pairs, that apply to this resource.
        public let tags: [String: String]?

        public init(clientToken: String? = CreateStreamingSessionRequest.idempotencyToken(), ec2InstanceType: StreamingInstanceType? = nil, launchProfileId: String? = nil, ownedBy: String? = nil, streamingImageId: String? = nil, studioId: String, tags: [String: String]? = nil) {
            self.clientToken = clientToken
            self.ec2InstanceType = ec2InstanceType
            self.launchProfileId = launchProfileId
            self.ownedBy = ownedBy
            self.streamingImageId = streamingImageId
            self.studioId = studioId
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 64)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.validate(self.streamingImageId, name: "streamingImageId", parent: name, max: 22)
            try self.validate(self.streamingImageId, name: "streamingImageId", parent: name, pattern: "^[a-zA-Z0-9-_]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case ec2InstanceType
            case launchProfileId
            case ownedBy
            case streamingImageId
            case tags
        }
    }

    public struct CreateStreamingSessionResponse: AWSDecodableShape {
        /// The session.
        public let session: StreamingSession?

        public init(session: StreamingSession? = nil) {
            self.session = session
        }

        private enum CodingKeys: String, CodingKey {
            case session
        }
    }

    public struct CreateStreamingSessionStreamRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "clientToken", location: .header("X-Amz-Client-Token")),
            AWSMemberEncoding(label: "sessionId", location: .uri("sessionId")),
            AWSMemberEncoding(label: "studioId", location: .uri("studioId"))
        ]

        /// Unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If you don’t specify a client token, the AWS SDK automatically generates a client token and uses it for the request to ensure idempotency.
        public let clientToken: String?
        /// The expiration time in seconds.
        public let expirationInSeconds: Int?
        /// The streaming session ID.
        public let sessionId: String
        /// The studio ID.
        public let studioId: String

        public init(clientToken: String? = CreateStreamingSessionStreamRequest.idempotencyToken(), expirationInSeconds: Int? = nil, sessionId: String, studioId: String) {
            self.clientToken = clientToken
            self.expirationInSeconds = expirationInSeconds
            self.sessionId = sessionId
            self.studioId = studioId
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 64)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.validate(self.expirationInSeconds, name: "expirationInSeconds", parent: name, max: 3600)
            try self.validate(self.expirationInSeconds, name: "expirationInSeconds", parent: name, min: 60)
        }

        private enum CodingKeys: String, CodingKey {
            case expirationInSeconds
        }
    }

    public struct CreateStreamingSessionStreamResponse: AWSDecodableShape {
        /// The stream.
        public let stream: StreamingSessionStream?

        public init(stream: StreamingSessionStream? = nil) {
            self.stream = stream
        }

        private enum CodingKeys: String, CodingKey {
            case stream
        }
    }

    public struct CreateStudioComponentRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "clientToken", location: .header("X-Amz-Client-Token")),
            AWSMemberEncoding(label: "studioId", location: .uri("studioId"))
        ]

        /// Unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If you don’t specify a client token, the AWS SDK automatically generates a client token and uses it for the request to ensure idempotency.
        public let clientToken: String?
        /// The configuration of the studio component, based on component type.
        public let configuration: StudioComponentConfiguration?
        /// The description.
        public let description: String?
        /// The EC2 security groups that control access to the studio component.
        public let ec2SecurityGroupIds: [String]?
        /// Initialization scripts for studio components.
        public let initializationScripts: [StudioComponentInitializationScript]?
        /// The name for the studio component.
        public let name: String
        /// Parameters for the studio component scripts.
        public let scriptParameters: [ScriptParameterKeyValue]?
        /// The studio ID.
        public let studioId: String
        /// The specific subtype of a studio component.
        public let subtype: StudioComponentSubtype?
        /// A collection of labels, in the form of key:value pairs, that apply to this resource.
        public let tags: [String: String]?
        /// The type of the studio component.
        public let type: StudioComponentType

        public init(clientToken: String? = CreateStudioComponentRequest.idempotencyToken(), configuration: StudioComponentConfiguration? = nil, description: String? = nil, ec2SecurityGroupIds: [String]? = nil, initializationScripts: [StudioComponentInitializationScript]? = nil, name: String, scriptParameters: [ScriptParameterKeyValue]? = nil, studioId: String, subtype: StudioComponentSubtype? = nil, tags: [String: String]? = nil, type: StudioComponentType) {
            self.clientToken = clientToken
            self.configuration = configuration
            self.description = description
            self.ec2SecurityGroupIds = ec2SecurityGroupIds
            self.initializationScripts = initializationScripts
            self.name = name
            self.scriptParameters = scriptParameters
            self.studioId = studioId
            self.subtype = subtype
            self.tags = tags
            self.type = type
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 64)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.configuration?.validate(name: "\(name).configuration")
            try self.validate(self.description, name: "description", parent: name, max: 256)
            try self.validate(self.ec2SecurityGroupIds, name: "ec2SecurityGroupIds", parent: name, max: 30)
            try self.initializationScripts?.forEach {
                try $0.validate(name: "\(name).initializationScripts[]")
            }
            try self.validate(self.name, name: "name", parent: name, max: 64)
            try self.scriptParameters?.forEach {
                try $0.validate(name: "\(name).scriptParameters[]")
            }
            try self.validate(self.scriptParameters, name: "scriptParameters", parent: name, max: 30)
        }

        private enum CodingKeys: String, CodingKey {
            case configuration
            case description
            case ec2SecurityGroupIds
            case initializationScripts
            case name
            case scriptParameters
            case subtype
            case tags
            case type
        }
    }

    public struct CreateStudioComponentResponse: AWSDecodableShape {
        /// Information about the studio component.
        public let studioComponent: StudioComponent?

        public init(studioComponent: StudioComponent? = nil) {
            self.studioComponent = studioComponent
        }

        private enum CodingKeys: String, CodingKey {
            case studioComponent
        }
    }

    public struct CreateStudioRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "clientToken", location: .header("X-Amz-Client-Token"))
        ]

        /// The IAM role that Studio Admins will assume when logging in to the Nimble Studio portal.
        public let adminRoleArn: String
        /// Unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If you don’t specify a client token, the AWS SDK automatically generates a client token and uses it for the request to ensure idempotency.
        public let clientToken: String?
        /// A friendly name for the studio.
        public let displayName: String
        /// The studio encryption configuration.
        public let studioEncryptionConfiguration: StudioEncryptionConfiguration?
        /// The studio name that is used in the URL of the Nimble Studio portal when accessed by Nimble Studio users.
        public let studioName: String
        /// A collection of labels, in the form of key:value pairs, that apply to this resource.
        public let tags: [String: String]?
        /// The IAM role that Studio Users will assume when logging in to the Nimble Studio portal.
        public let userRoleArn: String

        public init(adminRoleArn: String, clientToken: String? = CreateStudioRequest.idempotencyToken(), displayName: String, studioEncryptionConfiguration: StudioEncryptionConfiguration? = nil, studioName: String, tags: [String: String]? = nil, userRoleArn: String) {
            self.adminRoleArn = adminRoleArn
            self.clientToken = clientToken
            self.displayName = displayName
            self.studioEncryptionConfiguration = studioEncryptionConfiguration
            self.studioName = studioName
            self.tags = tags
            self.userRoleArn = userRoleArn
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 64)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.validate(self.displayName, name: "displayName", parent: name, max: 64)
            try self.studioEncryptionConfiguration?.validate(name: "\(name).studioEncryptionConfiguration")
            try self.validate(self.studioName, name: "studioName", parent: name, max: 64)
            try self.validate(self.studioName, name: "studioName", parent: name, min: 3)
            try self.validate(self.studioName, name: "studioName", parent: name, pattern: "^[a-z0-9]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case adminRoleArn
            case displayName
            case studioEncryptionConfiguration
            case studioName
            case tags
            case userRoleArn
        }
    }

    public struct CreateStudioResponse: AWSDecodableShape {
        /// Information about a studio.
        public let studio: Studio?

        public init(studio: Studio? = nil) {
            self.studio = studio
        }

        private enum CodingKeys: String, CodingKey {
            case studio
        }
    }

    public struct DeleteLaunchProfileMemberRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "clientToken", location: .header("X-Amz-Client-Token")),
            AWSMemberEncoding(label: "launchProfileId", location: .uri("launchProfileId")),
            AWSMemberEncoding(label: "principalId", location: .uri("principalId")),
            AWSMemberEncoding(label: "studioId", location: .uri("studioId"))
        ]

        /// Unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If you don’t specify a client token, the AWS SDK automatically generates a client token and uses it for the request to ensure idempotency.
        public let clientToken: String?
        /// The Launch Profile ID.
        public let launchProfileId: String
        /// The principal ID. This currently supports a Amazon Web Services SSO UserId.
        public let principalId: String
        /// The studio ID.
        public let studioId: String

        public init(clientToken: String? = DeleteLaunchProfileMemberRequest.idempotencyToken(), launchProfileId: String, principalId: String, studioId: String) {
            self.clientToken = clientToken
            self.launchProfileId = launchProfileId
            self.principalId = principalId
            self.studioId = studioId
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 64)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteLaunchProfileMemberResponse: AWSDecodableShape {
        public init() {}
    }

    public struct DeleteLaunchProfileRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "clientToken", location: .header("X-Amz-Client-Token")),
            AWSMemberEncoding(label: "launchProfileId", location: .uri("launchProfileId")),
            AWSMemberEncoding(label: "studioId", location: .uri("studioId"))
        ]

        /// Unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If you don’t specify a client token, the AWS SDK automatically generates a client token and uses it for the request to ensure idempotency.
        public let clientToken: String?
        /// The Launch Profile ID.
        public let launchProfileId: String
        /// The studio ID.
        public let studioId: String

        public init(clientToken: String? = DeleteLaunchProfileRequest.idempotencyToken(), launchProfileId: String, studioId: String) {
            self.clientToken = clientToken
            self.launchProfileId = launchProfileId
            self.studioId = studioId
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 64)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteLaunchProfileResponse: AWSDecodableShape {
        /// The launch profile.
        public let launchProfile: LaunchProfile?

        public init(launchProfile: LaunchProfile? = nil) {
            self.launchProfile = launchProfile
        }

        private enum CodingKeys: String, CodingKey {
            case launchProfile
        }
    }

    public struct DeleteStreamingImageRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "clientToken", location: .header("X-Amz-Client-Token")),
            AWSMemberEncoding(label: "streamingImageId", location: .uri("streamingImageId")),
            AWSMemberEncoding(label: "studioId", location: .uri("studioId"))
        ]

        /// Unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If you don’t specify a client token, the AWS SDK automatically generates a client token and uses it for the request to ensure idempotency.
        public let clientToken: String?
        /// The streaming image ID.
        public let streamingImageId: String
        /// The studio ID.
        public let studioId: String

        public init(clientToken: String? = DeleteStreamingImageRequest.idempotencyToken(), streamingImageId: String, studioId: String) {
            self.clientToken = clientToken
            self.streamingImageId = streamingImageId
            self.studioId = studioId
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 64)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteStreamingImageResponse: AWSDecodableShape {
        /// The streaming image.
        public let streamingImage: StreamingImage?

        public init(streamingImage: StreamingImage? = nil) {
            self.streamingImage = streamingImage
        }

        private enum CodingKeys: String, CodingKey {
            case streamingImage
        }
    }

    public struct DeleteStreamingSessionRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "clientToken", location: .header("X-Amz-Client-Token")),
            AWSMemberEncoding(label: "sessionId", location: .uri("sessionId")),
            AWSMemberEncoding(label: "studioId", location: .uri("studioId"))
        ]

        /// Unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If you don’t specify a client token, the AWS SDK automatically generates a client token and uses it for the request to ensure idempotency.
        public let clientToken: String?
        /// The streaming session ID.
        public let sessionId: String
        /// The studio ID.
        public let studioId: String

        public init(clientToken: String? = DeleteStreamingSessionRequest.idempotencyToken(), sessionId: String, studioId: String) {
            self.clientToken = clientToken
            self.sessionId = sessionId
            self.studioId = studioId
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 64)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteStreamingSessionResponse: AWSDecodableShape {
        /// The session.
        public let session: StreamingSession?

        public init(session: StreamingSession? = nil) {
            self.session = session
        }

        private enum CodingKeys: String, CodingKey {
            case session
        }
    }

    public struct DeleteStudioComponentRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "clientToken", location: .header("X-Amz-Client-Token")),
            AWSMemberEncoding(label: "studioComponentId", location: .uri("studioComponentId")),
            AWSMemberEncoding(label: "studioId", location: .uri("studioId"))
        ]

        /// Unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If you don’t specify a client token, the AWS SDK automatically generates a client token and uses it for the request to ensure idempotency.
        public let clientToken: String?
        /// The studio component ID.
        public let studioComponentId: String
        /// The studio ID.
        public let studioId: String

        public init(clientToken: String? = DeleteStudioComponentRequest.idempotencyToken(), studioComponentId: String, studioId: String) {
            self.clientToken = clientToken
            self.studioComponentId = studioComponentId
            self.studioId = studioId
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 64)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteStudioComponentResponse: AWSDecodableShape {
        /// Information about the studio component.
        public let studioComponent: StudioComponent?

        public init(studioComponent: StudioComponent? = nil) {
            self.studioComponent = studioComponent
        }

        private enum CodingKeys: String, CodingKey {
            case studioComponent
        }
    }

    public struct DeleteStudioMemberRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "clientToken", location: .header("X-Amz-Client-Token")),
            AWSMemberEncoding(label: "principalId", location: .uri("principalId")),
            AWSMemberEncoding(label: "studioId", location: .uri("studioId"))
        ]

        /// Unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If you don’t specify a client token, the AWS SDK automatically generates a client token and uses it for the request to ensure idempotency.
        public let clientToken: String?
        /// The principal ID. This currently supports a Amazon Web Services SSO UserId.
        public let principalId: String
        /// The studio ID.
        public let studioId: String

        public init(clientToken: String? = DeleteStudioMemberRequest.idempotencyToken(), principalId: String, studioId: String) {
            self.clientToken = clientToken
            self.principalId = principalId
            self.studioId = studioId
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 64)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteStudioMemberResponse: AWSDecodableShape {
        public init() {}
    }

    public struct DeleteStudioRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "clientToken", location: .header("X-Amz-Client-Token")),
            AWSMemberEncoding(label: "studioId", location: .uri("studioId"))
        ]

        /// Unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If you don’t specify a client token, the AWS SDK automatically generates a client token and uses it for the request to ensure idempotency.
        public let clientToken: String?
        /// The studio ID.
        public let studioId: String

        public init(clientToken: String? = DeleteStudioRequest.idempotencyToken(), studioId: String) {
            self.clientToken = clientToken
            self.studioId = studioId
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 64)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteStudioResponse: AWSDecodableShape {
        /// Information about a studio.
        public let studio: Studio

        public init(studio: Studio) {
            self.studio = studio
        }

        private enum CodingKeys: String, CodingKey {
            case studio
        }
    }

    public struct Eula: AWSDecodableShape {
        /// The EULA content.
        public let content: String?
        /// The Unix epoch timestamp in seconds for when the resource was created.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var createdAt: Date?
        /// The EULA ID.
        public let eulaId: String?
        /// The name for the EULA.
        public let name: String?
        /// The Unix epoch timestamp in seconds for when the resource was updated.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var updatedAt: Date?

        public init(content: String? = nil, createdAt: Date? = nil, eulaId: String? = nil, name: String? = nil, updatedAt: Date? = nil) {
            self.content = content
            self.createdAt = createdAt
            self.eulaId = eulaId
            self.name = name
            self.updatedAt = updatedAt
        }

        private enum CodingKeys: String, CodingKey {
            case content
            case createdAt
            case eulaId
            case name
            case updatedAt
        }
    }

    public struct EulaAcceptance: AWSDecodableShape {
        /// The Unix epoch timestamp in seconds for when the EULA was accepted.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var acceptedAt: Date?
        /// The ID of the person who accepted the EULA.
        public let acceptedBy: String?
        /// The ID of the acceptee.
        public let accepteeId: String?
        /// The EULA acceptance ID.
        public let eulaAcceptanceId: String?
        /// The EULA ID.
        public let eulaId: String?

        public init(acceptedAt: Date? = nil, acceptedBy: String? = nil, accepteeId: String? = nil, eulaAcceptanceId: String? = nil, eulaId: String? = nil) {
            self.acceptedAt = acceptedAt
            self.acceptedBy = acceptedBy
            self.accepteeId = accepteeId
            self.eulaAcceptanceId = eulaAcceptanceId
            self.eulaId = eulaId
        }

        private enum CodingKeys: String, CodingKey {
            case acceptedAt
            case acceptedBy
            case accepteeId
            case eulaAcceptanceId
            case eulaId
        }
    }

    public struct GetEulaRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "eulaId", location: .uri("eulaId"))
        ]

        /// The EULA ID.
        public let eulaId: String

        public init(eulaId: String) {
            self.eulaId = eulaId
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetEulaResponse: AWSDecodableShape {
        /// The EULA.
        public let eula: Eula?

        public init(eula: Eula? = nil) {
            self.eula = eula
        }

        private enum CodingKeys: String, CodingKey {
            case eula
        }
    }

    public struct GetLaunchProfileDetailsRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "launchProfileId", location: .uri("launchProfileId")),
            AWSMemberEncoding(label: "studioId", location: .uri("studioId"))
        ]

        /// The Launch Profile ID.
        public let launchProfileId: String
        /// The studio ID.
        public let studioId: String

        public init(launchProfileId: String, studioId: String) {
            self.launchProfileId = launchProfileId
            self.studioId = studioId
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetLaunchProfileDetailsResponse: AWSDecodableShape {
        /// The launch profile.
        public let launchProfile: LaunchProfile?
        /// A collection of streaming images.
        public let streamingImages: [StreamingImage]?
        /// A collection of studio component summaries.
        public let studioComponentSummaries: [StudioComponentSummary]?

        public init(launchProfile: LaunchProfile? = nil, streamingImages: [StreamingImage]? = nil, studioComponentSummaries: [StudioComponentSummary]? = nil) {
            self.launchProfile = launchProfile
            self.streamingImages = streamingImages
            self.studioComponentSummaries = studioComponentSummaries
        }

        private enum CodingKeys: String, CodingKey {
            case launchProfile
            case streamingImages
            case studioComponentSummaries
        }
    }

    public struct GetLaunchProfileInitializationRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "launchProfileId", location: .uri("launchProfileId")),
            AWSMemberEncoding(label: "launchProfileProtocolVersions", location: .querystring("launchProfileProtocolVersions")),
            AWSMemberEncoding(label: "launchPurpose", location: .querystring("launchPurpose")),
            AWSMemberEncoding(label: "platform", location: .querystring("platform")),
            AWSMemberEncoding(label: "studioId", location: .uri("studioId"))
        ]

        /// The Launch Profile ID.
        public let launchProfileId: String
        /// The launch profile protocol versions supported by the client.
        public let launchProfileProtocolVersions: [String]
        /// The launch purpose.
        public let launchPurpose: String
        /// The platform where this Launch Profile will be used, either WINDOWS or LINUX.
        public let platform: String
        /// The studio ID.
        public let studioId: String

        public init(launchProfileId: String, launchProfileProtocolVersions: [String], launchPurpose: String, platform: String, studioId: String) {
            self.launchProfileId = launchProfileId
            self.launchProfileProtocolVersions = launchProfileProtocolVersions
            self.launchPurpose = launchPurpose
            self.platform = platform
            self.studioId = studioId
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetLaunchProfileInitializationResponse: AWSDecodableShape {
        /// The launch profile initialization.
        public let launchProfileInitialization: LaunchProfileInitialization?

        public init(launchProfileInitialization: LaunchProfileInitialization? = nil) {
            self.launchProfileInitialization = launchProfileInitialization
        }

        private enum CodingKeys: String, CodingKey {
            case launchProfileInitialization
        }
    }

    public struct GetLaunchProfileMemberRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "launchProfileId", location: .uri("launchProfileId")),
            AWSMemberEncoding(label: "principalId", location: .uri("principalId")),
            AWSMemberEncoding(label: "studioId", location: .uri("studioId"))
        ]

        /// The Launch Profile ID.
        public let launchProfileId: String
        /// The principal ID. This currently supports a Amazon Web Services SSO UserId.
        public let principalId: String
        /// The studio ID.
        public let studioId: String

        public init(launchProfileId: String, principalId: String, studioId: String) {
            self.launchProfileId = launchProfileId
            self.principalId = principalId
            self.studioId = studioId
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetLaunchProfileMemberResponse: AWSDecodableShape {
        /// The member.
        public let member: LaunchProfileMembership?

        public init(member: LaunchProfileMembership? = nil) {
            self.member = member
        }

        private enum CodingKeys: String, CodingKey {
            case member
        }
    }

    public struct GetLaunchProfileRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "launchProfileId", location: .uri("launchProfileId")),
            AWSMemberEncoding(label: "studioId", location: .uri("studioId"))
        ]

        /// The Launch Profile ID.
        public let launchProfileId: String
        /// The studio ID.
        public let studioId: String

        public init(launchProfileId: String, studioId: String) {
            self.launchProfileId = launchProfileId
            self.studioId = studioId
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetLaunchProfileResponse: AWSDecodableShape {
        /// The launch profile.
        public let launchProfile: LaunchProfile?

        public init(launchProfile: LaunchProfile? = nil) {
            self.launchProfile = launchProfile
        }

        private enum CodingKeys: String, CodingKey {
            case launchProfile
        }
    }

    public struct GetStreamingImageRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "streamingImageId", location: .uri("streamingImageId")),
            AWSMemberEncoding(label: "studioId", location: .uri("studioId"))
        ]

        /// The streaming image ID.
        public let streamingImageId: String
        /// The studio ID.
        public let studioId: String

        public init(streamingImageId: String, studioId: String) {
            self.streamingImageId = streamingImageId
            self.studioId = studioId
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetStreamingImageResponse: AWSDecodableShape {
        /// The streaming image.
        public let streamingImage: StreamingImage?

        public init(streamingImage: StreamingImage? = nil) {
            self.streamingImage = streamingImage
        }

        private enum CodingKeys: String, CodingKey {
            case streamingImage
        }
    }

    public struct GetStreamingSessionRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "sessionId", location: .uri("sessionId")),
            AWSMemberEncoding(label: "studioId", location: .uri("studioId"))
        ]

        /// The streaming session ID.
        public let sessionId: String
        /// The studio ID.
        public let studioId: String

        public init(sessionId: String, studioId: String) {
            self.sessionId = sessionId
            self.studioId = studioId
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetStreamingSessionResponse: AWSDecodableShape {
        /// The session.
        public let session: StreamingSession?

        public init(session: StreamingSession? = nil) {
            self.session = session
        }

        private enum CodingKeys: String, CodingKey {
            case session
        }
    }

    public struct GetStreamingSessionStreamRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "sessionId", location: .uri("sessionId")),
            AWSMemberEncoding(label: "streamId", location: .uri("streamId")),
            AWSMemberEncoding(label: "studioId", location: .uri("studioId"))
        ]

        /// The streaming session ID.
        public let sessionId: String
        /// The streaming session stream ID.
        public let streamId: String
        /// The studio ID.
        public let studioId: String

        public init(sessionId: String, streamId: String, studioId: String) {
            self.sessionId = sessionId
            self.streamId = streamId
            self.studioId = studioId
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetStreamingSessionStreamResponse: AWSDecodableShape {
        /// The stream.
        public let stream: StreamingSessionStream?

        public init(stream: StreamingSessionStream? = nil) {
            self.stream = stream
        }

        private enum CodingKeys: String, CodingKey {
            case stream
        }
    }

    public struct GetStudioComponentRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "studioComponentId", location: .uri("studioComponentId")),
            AWSMemberEncoding(label: "studioId", location: .uri("studioId"))
        ]

        /// The studio component ID.
        public let studioComponentId: String
        /// The studio ID.
        public let studioId: String

        public init(studioComponentId: String, studioId: String) {
            self.studioComponentId = studioComponentId
            self.studioId = studioId
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetStudioComponentResponse: AWSDecodableShape {
        /// Information about the studio component.
        public let studioComponent: StudioComponent?

        public init(studioComponent: StudioComponent? = nil) {
            self.studioComponent = studioComponent
        }

        private enum CodingKeys: String, CodingKey {
            case studioComponent
        }
    }

    public struct GetStudioMemberRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "principalId", location: .uri("principalId")),
            AWSMemberEncoding(label: "studioId", location: .uri("studioId"))
        ]

        /// The principal ID. This currently supports a Amazon Web Services SSO UserId.
        public let principalId: String
        /// The studio ID.
        public let studioId: String

        public init(principalId: String, studioId: String) {
            self.principalId = principalId
            self.studioId = studioId
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetStudioMemberResponse: AWSDecodableShape {
        /// The member.
        public let member: StudioMembership?

        public init(member: StudioMembership? = nil) {
            self.member = member
        }

        private enum CodingKeys: String, CodingKey {
            case member
        }
    }

    public struct GetStudioRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "studioId", location: .uri("studioId"))
        ]

        /// The studio ID.
        public let studioId: String

        public init(studioId: String) {
            self.studioId = studioId
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetStudioResponse: AWSDecodableShape {
        /// Information about a studio.
        public let studio: Studio

        public init(studio: Studio) {
            self.studio = studio
        }

        private enum CodingKeys: String, CodingKey {
            case studio
        }
    }

    public struct LaunchProfile: AWSDecodableShape {
        /// The ARN of the resource.
        public let arn: String?
        /// The Unix epoch timestamp in seconds for when the resource was created.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var createdAt: Date?
        /// The user ID of the user that created the launch profile.
        public let createdBy: String?
        /// A human-readable description of the launch profile.
        public let description: String?
        /// Unique identifiers for a collection of EC2 subnets.
        public let ec2SubnetIds: [String]?
        /// The launch profile ID.
        public let launchProfileId: String?
        /// The version number of the protocol that is used by the launch profile. The only valid version is "2021-03-31".
        public let launchProfileProtocolVersions: [String]?
        /// A friendly name for the launch profile.
        public let name: String?
        /// The current state.
        public let state: LaunchProfileState?
        /// The status code.
        public let statusCode: LaunchProfileStatusCode?
        /// The status message for the launch profile.
        public let statusMessage: String?
        /// A configuration for a streaming session.
        public let streamConfiguration: StreamConfiguration?
        /// Unique identifiers for a collection of studio components that can be used with this launch profile.
        public let studioComponentIds: [String]?
        /// A collection of labels, in the form of key:value pairs, that apply to this resource.
        public let tags: [String: String]?
        /// The Unix epoch timestamp in seconds for when the resource was updated.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var updatedAt: Date?
        /// The user ID of the user that most recently updated the resource.
        public let updatedBy: String?
        /// The list of the latest validation results.
        public let validationResults: [ValidationResult]?

        public init(arn: String? = nil, createdAt: Date? = nil, createdBy: String? = nil, description: String? = nil, ec2SubnetIds: [String]? = nil, launchProfileId: String? = nil, launchProfileProtocolVersions: [String]? = nil, name: String? = nil, state: LaunchProfileState? = nil, statusCode: LaunchProfileStatusCode? = nil, statusMessage: String? = nil, streamConfiguration: StreamConfiguration? = nil, studioComponentIds: [String]? = nil, tags: [String: String]? = nil, updatedAt: Date? = nil, updatedBy: String? = nil, validationResults: [ValidationResult]? = nil) {
            self.arn = arn
            self.createdAt = createdAt
            self.createdBy = createdBy
            self.description = description
            self.ec2SubnetIds = ec2SubnetIds
            self.launchProfileId = launchProfileId
            self.launchProfileProtocolVersions = launchProfileProtocolVersions
            self.name = name
            self.state = state
            self.statusCode = statusCode
            self.statusMessage = statusMessage
            self.streamConfiguration = streamConfiguration
            self.studioComponentIds = studioComponentIds
            self.tags = tags
            self.updatedAt = updatedAt
            self.updatedBy = updatedBy
            self.validationResults = validationResults
        }

        private enum CodingKeys: String, CodingKey {
            case arn
            case createdAt
            case createdBy
            case description
            case ec2SubnetIds
            case launchProfileId
            case launchProfileProtocolVersions
            case name
            case state
            case statusCode
            case statusMessage
            case streamConfiguration
            case studioComponentIds
            case tags
            case updatedAt
            case updatedBy
            case validationResults
        }
    }

    public struct LaunchProfileInitialization: AWSDecodableShape {
        /// A LaunchProfileInitializationActiveDirectory resource.
        public let activeDirectory: LaunchProfileInitializationActiveDirectory?
        /// The EC2 security groups that control access to the studio component.
        public let ec2SecurityGroupIds: [String]?
        /// The launch profile ID.
        public let launchProfileId: String?
        /// The version number of the protocol that is used by the launch profile. The only valid version is "2021-03-31".
        public let launchProfileProtocolVersion: String?
        /// The launch purpose.
        public let launchPurpose: String?
        /// The name for the launch profile.
        public let name: String?
        /// The platform of the launch platform, either WINDOWS or LINUX.
        public let platform: LaunchProfilePlatform?
        /// The system initializtion scripts.
        public let systemInitializationScripts: [LaunchProfileInitializationScript]?
        /// The user initializtion scripts.
        public let userInitializationScripts: [LaunchProfileInitializationScript]?

        public init(activeDirectory: LaunchProfileInitializationActiveDirectory? = nil, ec2SecurityGroupIds: [String]? = nil, launchProfileId: String? = nil, launchProfileProtocolVersion: String? = nil, launchPurpose: String? = nil, name: String? = nil, platform: LaunchProfilePlatform? = nil, systemInitializationScripts: [LaunchProfileInitializationScript]? = nil, userInitializationScripts: [LaunchProfileInitializationScript]? = nil) {
            self.activeDirectory = activeDirectory
            self.ec2SecurityGroupIds = ec2SecurityGroupIds
            self.launchProfileId = launchProfileId
            self.launchProfileProtocolVersion = launchProfileProtocolVersion
            self.launchPurpose = launchPurpose
            self.name = name
            self.platform = platform
            self.systemInitializationScripts = systemInitializationScripts
            self.userInitializationScripts = userInitializationScripts
        }

        private enum CodingKeys: String, CodingKey {
            case activeDirectory
            case ec2SecurityGroupIds
            case launchProfileId
            case launchProfileProtocolVersion
            case launchPurpose
            case name
            case platform
            case systemInitializationScripts
            case userInitializationScripts
        }
    }

    public struct LaunchProfileInitializationActiveDirectory: AWSDecodableShape {
        /// A collection of custom attributes for an Active Directory computer.
        public let computerAttributes: [ActiveDirectoryComputerAttribute]?
        /// The directory ID of the Directory Service for Microsoft Active Directory to access using this launch profile.
        public let directoryId: String?
        /// The directory name.
        public let directoryName: String?
        /// The DNS IP address.
        public let dnsIpAddresses: [String]?
        /// The name for the organizational unit distinguished name.
        public let organizationalUnitDistinguishedName: String?
        /// The unique identifier for a studio component resource.
        public let studioComponentId: String?
        /// The name for the studio component.
        public let studioComponentName: String?

        public init(computerAttributes: [ActiveDirectoryComputerAttribute]? = nil, directoryId: String? = nil, directoryName: String? = nil, dnsIpAddresses: [String]? = nil, organizationalUnitDistinguishedName: String? = nil, studioComponentId: String? = nil, studioComponentName: String? = nil) {
            self.computerAttributes = computerAttributes
            self.directoryId = directoryId
            self.directoryName = directoryName
            self.dnsIpAddresses = dnsIpAddresses
            self.organizationalUnitDistinguishedName = organizationalUnitDistinguishedName
            self.studioComponentId = studioComponentId
            self.studioComponentName = studioComponentName
        }

        private enum CodingKeys: String, CodingKey {
            case computerAttributes
            case directoryId
            case directoryName
            case dnsIpAddresses
            case organizationalUnitDistinguishedName
            case studioComponentId
            case studioComponentName
        }
    }

    public struct LaunchProfileInitializationScript: AWSDecodableShape {
        /// The initialization script.
        public let script: String?
        /// The unique identifier for a studio component resource.
        public let studioComponentId: String?
        /// The name for the studio component.
        public let studioComponentName: String?

        public init(script: String? = nil, studioComponentId: String? = nil, studioComponentName: String? = nil) {
            self.script = script
            self.studioComponentId = studioComponentId
            self.studioComponentName = studioComponentName
        }

        private enum CodingKeys: String, CodingKey {
            case script
            case studioComponentId
            case studioComponentName
        }
    }

    public struct LaunchProfileMembership: AWSDecodableShape {
        /// The ID of the identity store.
        public let identityStoreId: String?
        /// The persona.
        public let persona: LaunchProfilePersona?
        /// The principal ID.
        public let principalId: String?
        /// The Active Directory Security Identifier for this user, if available.
        public let sid: String?

        public init(identityStoreId: String? = nil, persona: LaunchProfilePersona? = nil, principalId: String? = nil, sid: String? = nil) {
            self.identityStoreId = identityStoreId
            self.persona = persona
            self.principalId = principalId
            self.sid = sid
        }

        private enum CodingKeys: String, CodingKey {
            case identityStoreId
            case persona
            case principalId
            case sid
        }
    }

    public struct LicenseServiceConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The endpoint of the license service that is accessed by the studio component resource.
        public let endpoint: String?

        public init(endpoint: String? = nil) {
            self.endpoint = endpoint
        }

        private enum CodingKeys: String, CodingKey {
            case endpoint
        }
    }

    public struct ListEulaAcceptancesRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "eulaIds", location: .querystring("eulaIds")),
            AWSMemberEncoding(label: "nextToken", location: .querystring("nextToken")),
            AWSMemberEncoding(label: "studioId", location: .uri("studioId"))
        ]

        /// The list of EULA IDs that have been previously accepted.
        public let eulaIds: [String]?
        /// The token to request the next page of results.
        public let nextToken: String?
        /// The studio ID.
        public let studioId: String

        public init(eulaIds: [String]? = nil, nextToken: String? = nil, studioId: String) {
            self.eulaIds = eulaIds
            self.nextToken = nextToken
            self.studioId = studioId
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListEulaAcceptancesResponse: AWSDecodableShape {
        /// A collection of EULA acceptances.
        public let eulaAcceptances: [EulaAcceptance]?
        /// The token for the next set of results, or null if there are no more results.
        public let nextToken: String?

        public init(eulaAcceptances: [EulaAcceptance]? = nil, nextToken: String? = nil) {
            self.eulaAcceptances = eulaAcceptances
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case eulaAcceptances
            case nextToken
        }
    }

    public struct ListEulasRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "eulaIds", location: .querystring("eulaIds")),
            AWSMemberEncoding(label: "nextToken", location: .querystring("nextToken"))
        ]

        /// The list of EULA IDs that should be returned
        public let eulaIds: [String]?
        /// The token to request the next page of results.
        public let nextToken: String?

        public init(eulaIds: [String]? = nil, nextToken: String? = nil) {
            self.eulaIds = eulaIds
            self.nextToken = nextToken
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListEulasResponse: AWSDecodableShape {
        /// A collection of EULA resources.
        public let eulas: [Eula]?
        /// The token for the next set of results, or null if there are no more results.
        public let nextToken: String?

        public init(eulas: [Eula]? = nil, nextToken: String? = nil) {
            self.eulas = eulas
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case eulas
            case nextToken
        }
    }

    public struct ListLaunchProfileMembersRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "launchProfileId", location: .uri("launchProfileId")),
            AWSMemberEncoding(label: "maxResults", location: .querystring("maxResults")),
            AWSMemberEncoding(label: "nextToken", location: .querystring("nextToken")),
            AWSMemberEncoding(label: "studioId", location: .uri("studioId"))
        ]

        /// The Launch Profile ID.
        public let launchProfileId: String
        /// The max number of results to return in the response.
        public let maxResults: Int?
        /// The token to request the next page of results.
        public let nextToken: String?
        /// The studio ID.
        public let studioId: String

        public init(launchProfileId: String, maxResults: Int? = nil, nextToken: String? = nil, studioId: String) {
            self.launchProfileId = launchProfileId
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.studioId = studioId
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListLaunchProfileMembersResponse: AWSDecodableShape {
        /// A list of members.
        public let members: [LaunchProfileMembership]?
        /// The token for the next set of results, or null if there are no more results.
        public let nextToken: String?

        public init(members: [LaunchProfileMembership]? = nil, nextToken: String? = nil) {
            self.members = members
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case members
            case nextToken
        }
    }

    public struct ListLaunchProfilesRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "maxResults", location: .querystring("maxResults")),
            AWSMemberEncoding(label: "nextToken", location: .querystring("nextToken")),
            AWSMemberEncoding(label: "principalId", location: .querystring("principalId")),
            AWSMemberEncoding(label: "states", location: .querystring("states")),
            AWSMemberEncoding(label: "studioId", location: .uri("studioId"))
        ]

        /// The max number of results to return in the response.
        public let maxResults: Int?
        /// The token to request the next page of results.
        public let nextToken: String?
        /// The principal ID. This currently supports a Amazon Web Services SSO UserId.
        public let principalId: String?
        /// Filter this request to launch profiles in any of the given states.
        public let states: [LaunchProfileState]?
        /// The studio ID.
        public let studioId: String

        public init(maxResults: Int? = nil, nextToken: String? = nil, principalId: String? = nil, states: [LaunchProfileState]? = nil, studioId: String) {
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.principalId = principalId
            self.states = states
            self.studioId = studioId
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListLaunchProfilesResponse: AWSDecodableShape {
        /// A collection of launch profiles.
        public let launchProfiles: [LaunchProfile]?
        /// The token for the next set of results, or null if there are no more results.
        public let nextToken: String?

        public init(launchProfiles: [LaunchProfile]? = nil, nextToken: String? = nil) {
            self.launchProfiles = launchProfiles
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case launchProfiles
            case nextToken
        }
    }

    public struct ListStreamingImagesRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "nextToken", location: .querystring("nextToken")),
            AWSMemberEncoding(label: "owner", location: .querystring("owner")),
            AWSMemberEncoding(label: "studioId", location: .uri("studioId"))
        ]

        /// The token to request the next page of results.
        public let nextToken: String?
        /// Filter this request to streaming images with the given owner
        public let owner: String?
        /// The studio ID.
        public let studioId: String

        public init(nextToken: String? = nil, owner: String? = nil, studioId: String) {
            self.nextToken = nextToken
            self.owner = owner
            self.studioId = studioId
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListStreamingImagesResponse: AWSDecodableShape {
        /// The token for the next set of results, or null if there are no more results.
        public let nextToken: String?
        /// A collection of streaming images.
        public let streamingImages: [StreamingImage]?

        public init(nextToken: String? = nil, streamingImages: [StreamingImage]? = nil) {
            self.nextToken = nextToken
            self.streamingImages = streamingImages
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken
            case streamingImages
        }
    }

    public struct ListStreamingSessionsRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "createdBy", location: .querystring("createdBy")),
            AWSMemberEncoding(label: "nextToken", location: .querystring("nextToken")),
            AWSMemberEncoding(label: "ownedBy", location: .querystring("ownedBy")),
            AWSMemberEncoding(label: "sessionIds", location: .querystring("sessionIds")),
            AWSMemberEncoding(label: "studioId", location: .uri("studioId"))
        ]

        /// Filters the request to streaming sessions created by the given user.
        public let createdBy: String?
        /// The token to request the next page of results.
        public let nextToken: String?
        /// Filters the request to streaming session owned by the given user
        public let ownedBy: String?
        /// Filters the request to only the provided session IDs.
        public let sessionIds: String?
        /// The studio ID.
        public let studioId: String

        public init(createdBy: String? = nil, nextToken: String? = nil, ownedBy: String? = nil, sessionIds: String? = nil, studioId: String) {
            self.createdBy = createdBy
            self.nextToken = nextToken
            self.ownedBy = ownedBy
            self.sessionIds = sessionIds
            self.studioId = studioId
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListStreamingSessionsResponse: AWSDecodableShape {
        /// The token for the next set of results, or null if there are no more results.
        public let nextToken: String?
        /// A collection of streaming sessions.
        public let sessions: [StreamingSession]?

        public init(nextToken: String? = nil, sessions: [StreamingSession]? = nil) {
            self.nextToken = nextToken
            self.sessions = sessions
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken
            case sessions
        }
    }

    public struct ListStudioComponentsRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "maxResults", location: .querystring("maxResults")),
            AWSMemberEncoding(label: "nextToken", location: .querystring("nextToken")),
            AWSMemberEncoding(label: "states", location: .querystring("states")),
            AWSMemberEncoding(label: "studioId", location: .uri("studioId")),
            AWSMemberEncoding(label: "types", location: .querystring("types"))
        ]

        /// The max number of results to return in the response.
        public let maxResults: Int?
        /// The token to request the next page of results.
        public let nextToken: String?
        /// Filters the request to studio components that are in one of the given states.
        public let states: [StudioComponentState]?
        /// The studio ID.
        public let studioId: String
        /// Filters the request to studio components that are of one of the given types.
        public let types: [StudioComponentType]?

        public init(maxResults: Int? = nil, nextToken: String? = nil, states: [StudioComponentState]? = nil, studioId: String, types: [StudioComponentType]? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.states = states
            self.studioId = studioId
            self.types = types
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListStudioComponentsResponse: AWSDecodableShape {
        /// The token for the next set of results, or null if there are no more results.
        public let nextToken: String?
        /// A collection of studio components.
        public let studioComponents: [StudioComponent]?

        public init(nextToken: String? = nil, studioComponents: [StudioComponent]? = nil) {
            self.nextToken = nextToken
            self.studioComponents = studioComponents
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken
            case studioComponents
        }
    }

    public struct ListStudioMembersRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "maxResults", location: .querystring("maxResults")),
            AWSMemberEncoding(label: "nextToken", location: .querystring("nextToken")),
            AWSMemberEncoding(label: "studioId", location: .uri("studioId"))
        ]

        /// The max number of results to return in the response.
        public let maxResults: Int?
        /// The token to request the next page of results.
        public let nextToken: String?
        /// The studio ID.
        public let studioId: String

        public init(maxResults: Int? = nil, nextToken: String? = nil, studioId: String) {
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.studioId = studioId
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListStudioMembersResponse: AWSDecodableShape {
        /// A list of admin members.
        public let members: [StudioMembership]?
        /// The token for the next set of results, or null if there are no more results.
        public let nextToken: String?

        public init(members: [StudioMembership]? = nil, nextToken: String? = nil) {
            self.members = members
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case members
            case nextToken
        }
    }

    public struct ListStudiosRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "nextToken", location: .querystring("nextToken"))
        ]

        /// The token to request the next page of results.
        public let nextToken: String?

        public init(nextToken: String? = nil) {
            self.nextToken = nextToken
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListStudiosResponse: AWSDecodableShape {
        /// The token for the next set of results, or null if there are no more results.
        public let nextToken: String?
        /// A collection of studios.
        public let studios: [Studio]

        public init(nextToken: String? = nil, studios: [Studio]) {
            self.nextToken = nextToken
            self.studios = studios
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken
            case studios
        }
    }

    public struct ListTagsForResourceRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "resourceArn", location: .uri("resourceArn"))
        ]

        /// The Amazon Resource Name (ARN) of the resource for which you want to list tags.
        public let resourceArn: String

        public init(resourceArn: String) {
            self.resourceArn = resourceArn
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListTagsForResourceResponse: AWSDecodableShape {
        /// A collection of labels, in the form of key:value pairs, that apply to this resource.
        public let tags: [String: String]?

        public init(tags: [String: String]? = nil) {
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case tags
        }
    }

    public struct NewLaunchProfileMember: AWSEncodableShape {
        /// The persona.
        public let persona: LaunchProfilePersona
        /// The principal ID.
        public let principalId: String

        public init(persona: LaunchProfilePersona, principalId: String) {
            self.persona = persona
            self.principalId = principalId
        }

        private enum CodingKeys: String, CodingKey {
            case persona
            case principalId
        }
    }

    public struct NewStudioMember: AWSEncodableShape {
        /// The persona.
        public let persona: StudioPersona
        /// The principal ID.
        public let principalId: String

        public init(persona: StudioPersona, principalId: String) {
            self.persona = persona
            self.principalId = principalId
        }

        private enum CodingKeys: String, CodingKey {
            case persona
            case principalId
        }
    }

    public struct PutLaunchProfileMembersRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "clientToken", location: .header("X-Amz-Client-Token")),
            AWSMemberEncoding(label: "launchProfileId", location: .uri("launchProfileId")),
            AWSMemberEncoding(label: "studioId", location: .uri("studioId"))
        ]

        /// Unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If you don’t specify a client token, the AWS SDK automatically generates a client token and uses it for the request to ensure idempotency.
        public let clientToken: String?
        /// The ID of the identity store.
        public let identityStoreId: String
        /// The Launch Profile ID.
        public let launchProfileId: String
        /// A list of members.
        public let members: [NewLaunchProfileMember]
        /// The studio ID.
        public let studioId: String

        public init(clientToken: String? = PutLaunchProfileMembersRequest.idempotencyToken(), identityStoreId: String, launchProfileId: String, members: [NewLaunchProfileMember], studioId: String) {
            self.clientToken = clientToken
            self.identityStoreId = identityStoreId
            self.launchProfileId = launchProfileId
            self.members = members
            self.studioId = studioId
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 64)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.validate(self.members, name: "members", parent: name, max: 20)
            try self.validate(self.members, name: "members", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case identityStoreId
            case members
        }
    }

    public struct PutLaunchProfileMembersResponse: AWSDecodableShape {
        public init() {}
    }

    public struct PutStudioMembersRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "clientToken", location: .header("X-Amz-Client-Token")),
            AWSMemberEncoding(label: "studioId", location: .uri("studioId"))
        ]

        /// Unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If you don’t specify a client token, the AWS SDK automatically generates a client token and uses it for the request to ensure idempotency.
        public let clientToken: String?
        /// The ID of the identity store.
        public let identityStoreId: String
        /// A list of members.
        public let members: [NewStudioMember]
        /// The studio ID.
        public let studioId: String

        public init(clientToken: String? = PutStudioMembersRequest.idempotencyToken(), identityStoreId: String, members: [NewStudioMember], studioId: String) {
            self.clientToken = clientToken
            self.identityStoreId = identityStoreId
            self.members = members
            self.studioId = studioId
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 64)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.validate(self.members, name: "members", parent: name, max: 20)
            try self.validate(self.members, name: "members", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case identityStoreId
            case members
        }
    }

    public struct PutStudioMembersResponse: AWSDecodableShape {
        public init() {}
    }

    public struct ScriptParameterKeyValue: AWSEncodableShape & AWSDecodableShape {
        /// A script parameter key.
        public let key: String?
        /// A script parameter value.
        public let value: String?

        public init(key: String? = nil, value: String? = nil) {
            self.key = key
            self.value = value
        }

        public func validate(name: String) throws {
            try self.validate(self.key, name: "key", parent: name, max: 64)
            try self.validate(self.key, name: "key", parent: name, min: 1)
            try self.validate(self.key, name: "key", parent: name, pattern: "^[a-zA-Z_][a-zA-Z0-9_]+$")
            try self.validate(self.value, name: "value", parent: name, max: 256)
            try self.validate(self.value, name: "value", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case key
            case value
        }
    }

    public struct SharedFileSystemConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The endpoint of the shared file system that is accessed by the studio component resource.
        public let endpoint: String?
        /// The unique identifier for a file system.
        public let fileSystemId: String?
        /// The mount location for a shared file system on a Linux virtual workstation.
        public let linuxMountPoint: String?
        /// The name of the file share.
        public let shareName: String?
        /// The mount location for a shared file system on a Windows virtual workstation.
        public let windowsMountDrive: String?

        public init(endpoint: String? = nil, fileSystemId: String? = nil, linuxMountPoint: String? = nil, shareName: String? = nil, windowsMountDrive: String? = nil) {
            self.endpoint = endpoint
            self.fileSystemId = fileSystemId
            self.linuxMountPoint = linuxMountPoint
            self.shareName = shareName
            self.windowsMountDrive = windowsMountDrive
        }

        public func validate(name: String) throws {
            try self.validate(self.linuxMountPoint, name: "linuxMountPoint", parent: name, max: 128)
            try self.validate(self.linuxMountPoint, name: "linuxMountPoint", parent: name, pattern: "^(/?|(\\$HOME)?(/[^/\\n\\s\\\\]+)*)$")
            try self.validate(self.windowsMountDrive, name: "windowsMountDrive", parent: name, pattern: "^[A-Z]$")
        }

        private enum CodingKeys: String, CodingKey {
            case endpoint
            case fileSystemId
            case linuxMountPoint
            case shareName
            case windowsMountDrive
        }
    }

    public struct StartStreamingSessionRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "clientToken", location: .header("X-Amz-Client-Token")),
            AWSMemberEncoding(label: "sessionId", location: .uri("sessionId")),
            AWSMemberEncoding(label: "studioId", location: .uri("studioId"))
        ]

        /// Unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If you don’t specify a client token, the AWS SDK automatically generates a client token and uses it for the request to ensure idempotency.
        public let clientToken: String?
        /// The streaming session ID for the StartStreamingSessionRequest.
        public let sessionId: String
        /// The studio ID for the StartStreamingSessionRequest.
        public let studioId: String

        public init(clientToken: String? = StartStreamingSessionRequest.idempotencyToken(), sessionId: String, studioId: String) {
            self.clientToken = clientToken
            self.sessionId = sessionId
            self.studioId = studioId
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 64)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct StartStreamingSessionResponse: AWSDecodableShape {
        public let session: StreamingSession?

        public init(session: StreamingSession? = nil) {
            self.session = session
        }

        private enum CodingKeys: String, CodingKey {
            case session
        }
    }

    public struct StartStudioSSOConfigurationRepairRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "clientToken", location: .header("X-Amz-Client-Token")),
            AWSMemberEncoding(label: "studioId", location: .uri("studioId"))
        ]

        /// Unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If you don’t specify a client token, the AWS SDK automatically generates a client token and uses it for the request to ensure idempotency.
        public let clientToken: String?
        /// The studio ID.
        public let studioId: String

        public init(clientToken: String? = StartStudioSSOConfigurationRepairRequest.idempotencyToken(), studioId: String) {
            self.clientToken = clientToken
            self.studioId = studioId
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 64)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct StartStudioSSOConfigurationRepairResponse: AWSDecodableShape {
        /// Information about a studio.
        public let studio: Studio

        public init(studio: Studio) {
            self.studio = studio
        }

        private enum CodingKeys: String, CodingKey {
            case studio
        }
    }

    public struct StopStreamingSessionRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "clientToken", location: .header("X-Amz-Client-Token")),
            AWSMemberEncoding(label: "sessionId", location: .uri("sessionId")),
            AWSMemberEncoding(label: "studioId", location: .uri("studioId"))
        ]

        /// Unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If you don’t specify a client token, the AWS SDK automatically generates a client token and uses it for the request to ensure idempotency.
        public let clientToken: String?
        /// The streaming session ID for the StopStreamingSessionRequest.
        public let sessionId: String
        /// The studioId for the StopStreamingSessionRequest.
        public let studioId: String

        public init(clientToken: String? = StopStreamingSessionRequest.idempotencyToken(), sessionId: String, studioId: String) {
            self.clientToken = clientToken
            self.sessionId = sessionId
            self.studioId = studioId
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 64)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct StopStreamingSessionResponse: AWSDecodableShape {
        public let session: StreamingSession?

        public init(session: StreamingSession? = nil) {
            self.session = session
        }

        private enum CodingKeys: String, CodingKey {
            case session
        }
    }

    public struct StreamConfiguration: AWSDecodableShape {
        /// Enable or disable the use of the system clipboard to copy and paste between the streaming session and streaming client.
        public let clipboardMode: StreamingClipboardMode
        /// The EC2 instance types that users can select from when launching a streaming session with this launch profile.
        public let ec2InstanceTypes: [StreamingInstanceType]
        /// The length of time, in minutes, that a streaming session can be active before it is stopped or terminated. After this point, Nimble Studio automatically terminates or stops the session. The default length of time is 690 minutes, and the maximum length of time is 30 days.
        public let maxSessionLengthInMinutes: Int?
        /// Integer that determines if you can start and stop your sessions and how long a session can stay in the STOPPED state. The default value is 0. The maximum value is 5760. If the value is missing or set to 0, your sessions can’t be stopped. If you then call StopStreamingSession, the session fails. If the time that a session stays in the READY state exceeds the maxSessionLengthInMinutes value, the session will automatically be terminated by AWS (instead of stopped). If the value is set to a positive number, the session can be stopped. You can call StopStreamingSession to stop sessions in the READY state. If the time that a session stays in the READY state exceeds the maxSessionLengthInMinutes value, the session will automatically be stopped by AWS (instead of terminated).
        public let maxStoppedSessionLengthInMinutes: Int?
        /// (Optional) The upload storage for a streaming session.
        public let sessionStorage: StreamConfigurationSessionStorage?
        /// The streaming images that users can select from when launching a streaming session with this launch profile.
        public let streamingImageIds: [String]

        public init(clipboardMode: StreamingClipboardMode, ec2InstanceTypes: [StreamingInstanceType], maxSessionLengthInMinutes: Int? = nil, maxStoppedSessionLengthInMinutes: Int? = nil, sessionStorage: StreamConfigurationSessionStorage? = nil, streamingImageIds: [String]) {
            self.clipboardMode = clipboardMode
            self.ec2InstanceTypes = ec2InstanceTypes
            self.maxSessionLengthInMinutes = maxSessionLengthInMinutes
            self.maxStoppedSessionLengthInMinutes = maxStoppedSessionLengthInMinutes
            self.sessionStorage = sessionStorage
            self.streamingImageIds = streamingImageIds
        }

        private enum CodingKeys: String, CodingKey {
            case clipboardMode
            case ec2InstanceTypes
            case maxSessionLengthInMinutes
            case maxStoppedSessionLengthInMinutes
            case sessionStorage
            case streamingImageIds
        }
    }

    public struct StreamConfigurationCreate: AWSEncodableShape {
        /// Enable or disable the use of the system clipboard to copy and paste between the streaming session and streaming client.
        public let clipboardMode: StreamingClipboardMode
        /// The EC2 instance types that users can select from when launching a streaming session with this launch profile.
        public let ec2InstanceTypes: [StreamingInstanceType]
        /// The length of time, in minutes, that a streaming session can be active before it is stopped or terminated. After this point, Nimble Studio automatically terminates or stops the session. The default length of time is 690 minutes, and the maximum length of time is 30 days.
        public let maxSessionLengthInMinutes: Int?
        /// Integer that determines if you can start and stop your sessions and how long a session can stay in the STOPPED state. The default value is 0. The maximum value is 5760. If the value is missing or set to 0, your sessions can’t be stopped. If you then call StopStreamingSession, the session fails. If the time that a session stays in the READY state exceeds the maxSessionLengthInMinutes value, the session will automatically be terminated by AWS (instead of stopped). If the value is set to a positive number, the session can be stopped. You can call StopStreamingSession to stop sessions in the READY state. If the time that a session stays in the READY state exceeds the maxSessionLengthInMinutes value, the session will automatically be stopped by AWS (instead of terminated).
        public let maxStoppedSessionLengthInMinutes: Int?
        /// (Optional) The upload storage for a streaming workstation that is created using this launch profile.
        public let sessionStorage: StreamConfigurationSessionStorage?
        /// The streaming images that users can select from when launching a streaming session with this launch profile.
        public let streamingImageIds: [String]

        public init(clipboardMode: StreamingClipboardMode, ec2InstanceTypes: [StreamingInstanceType], maxSessionLengthInMinutes: Int? = nil, maxStoppedSessionLengthInMinutes: Int? = nil, sessionStorage: StreamConfigurationSessionStorage? = nil, streamingImageIds: [String]) {
            self.clipboardMode = clipboardMode
            self.ec2InstanceTypes = ec2InstanceTypes
            self.maxSessionLengthInMinutes = maxSessionLengthInMinutes
            self.maxStoppedSessionLengthInMinutes = maxStoppedSessionLengthInMinutes
            self.sessionStorage = sessionStorage
            self.streamingImageIds = streamingImageIds
        }

        public func validate(name: String) throws {
            try self.validate(self.ec2InstanceTypes, name: "ec2InstanceTypes", parent: name, max: 30)
            try self.validate(self.ec2InstanceTypes, name: "ec2InstanceTypes", parent: name, min: 1)
            try self.validate(self.maxSessionLengthInMinutes, name: "maxSessionLengthInMinutes", parent: name, max: 43200)
            try self.validate(self.maxSessionLengthInMinutes, name: "maxSessionLengthInMinutes", parent: name, min: 1)
            try self.validate(self.maxStoppedSessionLengthInMinutes, name: "maxStoppedSessionLengthInMinutes", parent: name, max: 5760)
            try self.validate(self.maxStoppedSessionLengthInMinutes, name: "maxStoppedSessionLengthInMinutes", parent: name, min: 0)
            try self.sessionStorage?.validate(name: "\(name).sessionStorage")
            try self.streamingImageIds.forEach {
                try validate($0, name: "streamingImageIds[]", parent: name, max: 22)
                try validate($0, name: "streamingImageIds[]", parent: name, pattern: "^[a-zA-Z0-9-_]*$")
            }
            try self.validate(self.streamingImageIds, name: "streamingImageIds", parent: name, max: 20)
            try self.validate(self.streamingImageIds, name: "streamingImageIds", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case clipboardMode
            case ec2InstanceTypes
            case maxSessionLengthInMinutes
            case maxStoppedSessionLengthInMinutes
            case sessionStorage
            case streamingImageIds
        }
    }

    public struct StreamConfigurationSessionStorage: AWSEncodableShape & AWSDecodableShape {
        /// Allows artists to upload files to their workstations. The only valid option is UPLOAD.
        public let mode: [StreamingSessionStorageMode]
        /// The configuration for the upload storage root of the streaming session.
        public let root: StreamingSessionStorageRoot?

        public init(mode: [StreamingSessionStorageMode], root: StreamingSessionStorageRoot? = nil) {
            self.mode = mode
            self.root = root
        }

        public func validate(name: String) throws {
            try self.validate(self.mode, name: "mode", parent: name, min: 1)
            try self.root?.validate(name: "\(name).root")
        }

        private enum CodingKeys: String, CodingKey {
            case mode
            case root
        }
    }

    public struct StreamingImage: AWSDecodableShape {
        /// The ARN of the resource.
        public let arn: String?
        /// A human-readable description of the streaming image.
        public let description: String?
        /// The ID of an EC2 machine image with which to create the streaming image.
        public let ec2ImageId: String?
        /// The encryption configuration.
        public let encryptionConfiguration: StreamingImageEncryptionConfiguration?
        /// The list of EULAs that must be accepted before a Streaming Session can be started using this streaming image.
        public let eulaIds: [String]?
        /// A friendly name for a streaming image resource.
        public let name: String?
        /// The owner of the streaming image, either the studioId that contains the streaming image, or 'amazon' for images that are provided by Amazon Nimble Studio.
        public let owner: String?
        /// The platform of the streaming image, either WINDOWS or LINUX.
        public let platform: String?
        /// The current state.
        public let state: StreamingImageState?
        /// The status code.
        public let statusCode: StreamingImageStatusCode?
        /// The status message for the streaming image.
        public let statusMessage: String?
        /// The ID of the streaming image.
        public let streamingImageId: String?
        /// A collection of labels, in the form of key:value pairs, that apply to this resource.
        public let tags: [String: String]?

        public init(arn: String? = nil, description: String? = nil, ec2ImageId: String? = nil, encryptionConfiguration: StreamingImageEncryptionConfiguration? = nil, eulaIds: [String]? = nil, name: String? = nil, owner: String? = nil, platform: String? = nil, state: StreamingImageState? = nil, statusCode: StreamingImageStatusCode? = nil, statusMessage: String? = nil, streamingImageId: String? = nil, tags: [String: String]? = nil) {
            self.arn = arn
            self.description = description
            self.ec2ImageId = ec2ImageId
            self.encryptionConfiguration = encryptionConfiguration
            self.eulaIds = eulaIds
            self.name = name
            self.owner = owner
            self.platform = platform
            self.state = state
            self.statusCode = statusCode
            self.statusMessage = statusMessage
            self.streamingImageId = streamingImageId
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case arn
            case description
            case ec2ImageId
            case encryptionConfiguration
            case eulaIds
            case name
            case owner
            case platform
            case state
            case statusCode
            case statusMessage
            case streamingImageId
            case tags
        }
    }

    public struct StreamingImageEncryptionConfiguration: AWSDecodableShape {
        /// The ARN for a KMS key that is used to encrypt studio data.
        public let keyArn: String?
        /// The type of KMS key that is used to encrypt studio data.
        public let keyType: StreamingImageEncryptionConfigurationKeyType

        public init(keyArn: String? = nil, keyType: StreamingImageEncryptionConfigurationKeyType) {
            self.keyArn = keyArn
            self.keyType = keyType
        }

        private enum CodingKeys: String, CodingKey {
            case keyArn
            case keyType
        }
    }

    public struct StreamingSession: AWSDecodableShape {
        /// The ARN of the resource.
        public let arn: String?
        /// The Unix epoch timestamp in seconds for when the resource was created.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var createdAt: Date?
        /// The user ID of the user that created the streaming session.
        public let createdBy: String?
        /// The EC2 Instance type used for the streaming session.
        public let ec2InstanceType: String?
        /// The ID of the launch profile used to control access from the streaming session.
        public let launchProfileId: String?
        /// The user ID of the user that owns the streaming session. The user that owns the session will be logging into the session and interacting with the virtual workstation.
        public let ownedBy: String?
        /// The session ID.
        public let sessionId: String?
        /// The time the session entered START_IN_PROGRESS state.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var startedAt: Date?
        /// The user ID of the user that started the streaming session.
        public let startedBy: String?
        /// The current state.
        public let state: StreamingSessionState?
        /// The status code.
        public let statusCode: StreamingSessionStatusCode?
        /// The status message for the streaming session.
        public let statusMessage: String?
        /// The time the streaming session will automatically be stopped if the user doesn’t stop the session themselves.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var stopAt: Date?
        /// The time the session entered STOP_IN_PROGRESS state.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var stoppedAt: Date?
        /// The user ID of the user that stopped the streaming session.
        public let stoppedBy: String?
        /// The ID of the streaming image.
        public let streamingImageId: String?
        /// A collection of labels, in the form of key:value pairs, that apply to this resource.
        public let tags: [String: String]?
        /// The time the streaming session will automatically terminate if not terminated by the user.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var terminateAt: Date?
        /// The Unix epoch timestamp in seconds for when the resource was updated.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var updatedAt: Date?
        /// The user ID of the user that most recently updated the resource.
        public let updatedBy: String?

        public init(arn: String? = nil, createdAt: Date? = nil, createdBy: String? = nil, ec2InstanceType: String? = nil, launchProfileId: String? = nil, ownedBy: String? = nil, sessionId: String? = nil, startedAt: Date? = nil, startedBy: String? = nil, state: StreamingSessionState? = nil, statusCode: StreamingSessionStatusCode? = nil, statusMessage: String? = nil, stopAt: Date? = nil, stoppedAt: Date? = nil, stoppedBy: String? = nil, streamingImageId: String? = nil, tags: [String: String]? = nil, terminateAt: Date? = nil, updatedAt: Date? = nil, updatedBy: String? = nil) {
            self.arn = arn
            self.createdAt = createdAt
            self.createdBy = createdBy
            self.ec2InstanceType = ec2InstanceType
            self.launchProfileId = launchProfileId
            self.ownedBy = ownedBy
            self.sessionId = sessionId
            self.startedAt = startedAt
            self.startedBy = startedBy
            self.state = state
            self.statusCode = statusCode
            self.statusMessage = statusMessage
            self.stopAt = stopAt
            self.stoppedAt = stoppedAt
            self.stoppedBy = stoppedBy
            self.streamingImageId = streamingImageId
            self.tags = tags
            self.terminateAt = terminateAt
            self.updatedAt = updatedAt
            self.updatedBy = updatedBy
        }

        private enum CodingKeys: String, CodingKey {
            case arn
            case createdAt
            case createdBy
            case ec2InstanceType
            case launchProfileId
            case ownedBy
            case sessionId
            case startedAt
            case startedBy
            case state
            case statusCode
            case statusMessage
            case stopAt
            case stoppedAt
            case stoppedBy
            case streamingImageId
            case tags
            case terminateAt
            case updatedAt
            case updatedBy
        }
    }

    public struct StreamingSessionStorageRoot: AWSEncodableShape & AWSDecodableShape {
        /// The folder path in Linux workstations where files are uploaded.
        public let linux: String?
        /// The folder path in Windows workstations where files are uploaded.
        public let windows: String?

        public init(linux: String? = nil, windows: String? = nil) {
            self.linux = linux
            self.windows = windows
        }

        public func validate(name: String) throws {
            try self.validate(self.linux, name: "linux", parent: name, max: 128)
            try self.validate(self.linux, name: "linux", parent: name, min: 1)
            try self.validate(self.linux, name: "linux", parent: name, pattern: "^(\\$HOME|/)[/]?([A-Za-z0-9-_]+/)*([A-Za-z0-9_-]+)$")
            try self.validate(self.windows, name: "windows", parent: name, max: 128)
            try self.validate(self.windows, name: "windows", parent: name, min: 1)
            try self.validate(self.windows, name: "windows", parent: name, pattern: "^((\\%HOMEPATH\\%)|[a-zA-Z]:)[\\\\/](?:[a-zA-Z0-9_-]+[\\\\/])*[a-zA-Z0-9_-]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case linux
            case windows
        }
    }

    public struct StreamingSessionStream: AWSDecodableShape {
        /// The Unix epoch timestamp in seconds for when the resource was created.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var createdAt: Date?
        /// The user ID of the user that created the streaming session stream.
        public let createdBy: String?
        /// The Unix epoch timestamp in seconds for when the resource expires.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var expiresAt: Date?
        /// The user ID of the user that owns the streaming session. The user that owns the session will be logging into the session and interacting with the virtual workstation.
        public let ownedBy: String?
        /// The current state.
        public let state: StreamingSessionStreamState?
        /// The streaming session stream status code.
        public let statusCode: StreamingSessionStreamStatusCode?
        /// The stream ID.
        public let streamId: String?
        /// The URL to connect to this stream using the DCV client.
        public let url: String?

        public init(createdAt: Date? = nil, createdBy: String? = nil, expiresAt: Date? = nil, ownedBy: String? = nil, state: StreamingSessionStreamState? = nil, statusCode: StreamingSessionStreamStatusCode? = nil, streamId: String? = nil, url: String? = nil) {
            self.createdAt = createdAt
            self.createdBy = createdBy
            self.expiresAt = expiresAt
            self.ownedBy = ownedBy
            self.state = state
            self.statusCode = statusCode
            self.streamId = streamId
            self.url = url
        }

        private enum CodingKeys: String, CodingKey {
            case createdAt
            case createdBy
            case expiresAt
            case ownedBy
            case state
            case statusCode
            case streamId
            case url
        }
    }

    public struct Studio: AWSDecodableShape {
        /// The IAM role that studio admins assume when logging in to the Nimble Studio portal.
        public let adminRoleArn: String?
        /// The Amazon Resource Name (ARN) that is assigned to a studio resource and uniquely identifies it. ARNs are unique across all Regions.
        public let arn: String?
        /// The Unix epoch timestamp in seconds for when the resource was created.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var createdAt: Date?
        /// A friendly name for the studio.
        public let displayName: String?
        /// The Amazon Web Services Region where the studio resource is located.
        public let homeRegion: String?
        /// The Amazon Web Services SSO application client ID used to integrate with Amazon Web Services SSO to enable Amazon Web Services SSO users to log in to Nimble Studio portal.
        public let ssoClientId: String?
        /// The current state of the studio resource.
        public let state: StudioState?
        /// Status codes that provide additional detail on the studio state.
        public let statusCode: StudioStatusCode?
        /// Additional detail on the studio state.
        public let statusMessage: String?
        /// Configuration of the encryption method that is used for the studio.
        public let studioEncryptionConfiguration: StudioEncryptionConfiguration?
        /// The unique identifier for a studio resource. In Nimble Studio, all other resources are contained in a studio resource.
        public let studioId: String?
        /// The name of the studio, as included in the URL when accessing it in the Nimble Studio portal.
        public let studioName: String?
        /// The address of the web page for the studio.
        public let studioUrl: String?
        /// A collection of labels, in the form of key:value pairs, that apply to this resource.
        public let tags: [String: String]?
        /// The Unix epoch timestamp in seconds for when the resource was updated.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var updatedAt: Date?
        /// The IAM role that studio users assume when logging in to the Nimble Studio portal.
        public let userRoleArn: String?

        public init(adminRoleArn: String? = nil, arn: String? = nil, createdAt: Date? = nil, displayName: String? = nil, homeRegion: String? = nil, ssoClientId: String? = nil, state: StudioState? = nil, statusCode: StudioStatusCode? = nil, statusMessage: String? = nil, studioEncryptionConfiguration: StudioEncryptionConfiguration? = nil, studioId: String? = nil, studioName: String? = nil, studioUrl: String? = nil, tags: [String: String]? = nil, updatedAt: Date? = nil, userRoleArn: String? = nil) {
            self.adminRoleArn = adminRoleArn
            self.arn = arn
            self.createdAt = createdAt
            self.displayName = displayName
            self.homeRegion = homeRegion
            self.ssoClientId = ssoClientId
            self.state = state
            self.statusCode = statusCode
            self.statusMessage = statusMessage
            self.studioEncryptionConfiguration = studioEncryptionConfiguration
            self.studioId = studioId
            self.studioName = studioName
            self.studioUrl = studioUrl
            self.tags = tags
            self.updatedAt = updatedAt
            self.userRoleArn = userRoleArn
        }

        private enum CodingKeys: String, CodingKey {
            case adminRoleArn
            case arn
            case createdAt
            case displayName
            case homeRegion
            case ssoClientId
            case state
            case statusCode
            case statusMessage
            case studioEncryptionConfiguration
            case studioId
            case studioName
            case studioUrl
            case tags
            case updatedAt
            case userRoleArn
        }
    }

    public struct StudioComponent: AWSDecodableShape {
        /// The ARN of the resource.
        public let arn: String?
        /// The configuration of the studio component, based on component type.
        public let configuration: StudioComponentConfiguration?
        /// The Unix epoch timestamp in seconds for when the resource was created.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var createdAt: Date?
        /// The user ID of the user that created the studio component.
        public let createdBy: String?
        /// A human-readable description for the studio component resource.
        public let description: String?
        /// The EC2 security groups that control access to the studio component.
        public let ec2SecurityGroupIds: [String]?
        /// Initialization scripts for studio components.
        public let initializationScripts: [StudioComponentInitializationScript]?
        /// A friendly name for the studio component resource.
        public let name: String?
        /// Parameters for the studio component scripts.
        public let scriptParameters: [ScriptParameterKeyValue]?
        /// The current state.
        public let state: StudioComponentState?
        /// The status code.
        public let statusCode: StudioComponentStatusCode?
        /// The status message for the studio component.
        public let statusMessage: String?
        /// The unique identifier for a studio component resource.
        public let studioComponentId: String?
        /// The specific subtype of a studio component.
        public let subtype: StudioComponentSubtype?
        /// A collection of labels, in the form of key:value pairs, that apply to this resource.
        public let tags: [String: String]?
        /// The type of the studio component.
        public let type: StudioComponentType?
        /// The Unix epoch timestamp in seconds for when the resource was updated.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var updatedAt: Date?
        /// The user ID of the user that most recently updated the resource.
        public let updatedBy: String?

        public init(arn: String? = nil, configuration: StudioComponentConfiguration? = nil, createdAt: Date? = nil, createdBy: String? = nil, description: String? = nil, ec2SecurityGroupIds: [String]? = nil, initializationScripts: [StudioComponentInitializationScript]? = nil, name: String? = nil, scriptParameters: [ScriptParameterKeyValue]? = nil, state: StudioComponentState? = nil, statusCode: StudioComponentStatusCode? = nil, statusMessage: String? = nil, studioComponentId: String? = nil, subtype: StudioComponentSubtype? = nil, tags: [String: String]? = nil, type: StudioComponentType? = nil, updatedAt: Date? = nil, updatedBy: String? = nil) {
            self.arn = arn
            self.configuration = configuration
            self.createdAt = createdAt
            self.createdBy = createdBy
            self.description = description
            self.ec2SecurityGroupIds = ec2SecurityGroupIds
            self.initializationScripts = initializationScripts
            self.name = name
            self.scriptParameters = scriptParameters
            self.state = state
            self.statusCode = statusCode
            self.statusMessage = statusMessage
            self.studioComponentId = studioComponentId
            self.subtype = subtype
            self.tags = tags
            self.type = type
            self.updatedAt = updatedAt
            self.updatedBy = updatedBy
        }

        private enum CodingKeys: String, CodingKey {
            case arn
            case configuration
            case createdAt
            case createdBy
            case description
            case ec2SecurityGroupIds
            case initializationScripts
            case name
            case scriptParameters
            case state
            case statusCode
            case statusMessage
            case studioComponentId
            case subtype
            case tags
            case type
            case updatedAt
            case updatedBy
        }
    }

    public struct StudioComponentInitializationScript: AWSEncodableShape & AWSDecodableShape {
        /// The version number of the protocol that is used by the launch profile. The only valid version is "2021-03-31".
        public let launchProfileProtocolVersion: String?
        /// The platform of the initialization script, either WINDOWS or LINUX.
        public let platform: LaunchProfilePlatform?
        /// The method to use when running the initialization script.
        public let runContext: StudioComponentInitializationScriptRunContext?
        /// The initialization script.
        public let script: String?

        public init(launchProfileProtocolVersion: String? = nil, platform: LaunchProfilePlatform? = nil, runContext: StudioComponentInitializationScriptRunContext? = nil, script: String? = nil) {
            self.launchProfileProtocolVersion = launchProfileProtocolVersion
            self.platform = platform
            self.runContext = runContext
            self.script = script
        }

        public func validate(name: String) throws {
            try self.validate(self.launchProfileProtocolVersion, name: "launchProfileProtocolVersion", parent: name, max: 10)
            try self.validate(self.launchProfileProtocolVersion, name: "launchProfileProtocolVersion", parent: name, pattern: "^2021\\-03\\-31$")
            try self.validate(self.script, name: "script", parent: name, max: 5120)
            try self.validate(self.script, name: "script", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case launchProfileProtocolVersion
            case platform
            case runContext
            case script
        }
    }

    public struct StudioComponentSummary: AWSDecodableShape {
        /// The Unix epoch timestamp in seconds for when the resource was created.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var createdAt: Date?
        /// The user ID of the user that created the studio component.
        public let createdBy: String?
        /// The description.
        public let description: String?
        /// The name for the studio component.
        public let name: String?
        /// The unique identifier for a studio component resource.
        public let studioComponentId: String?
        /// The specific subtype of a studio component.
        public let subtype: StudioComponentSubtype?
        /// The type of the studio component.
        public let type: StudioComponentType?
        /// The Unix epoch timestamp in seconds for when the resource was updated.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var updatedAt: Date?
        /// The user ID of the user that most recently updated the resource.
        public let updatedBy: String?

        public init(createdAt: Date? = nil, createdBy: String? = nil, description: String? = nil, name: String? = nil, studioComponentId: String? = nil, subtype: StudioComponentSubtype? = nil, type: StudioComponentType? = nil, updatedAt: Date? = nil, updatedBy: String? = nil) {
            self.createdAt = createdAt
            self.createdBy = createdBy
            self.description = description
            self.name = name
            self.studioComponentId = studioComponentId
            self.subtype = subtype
            self.type = type
            self.updatedAt = updatedAt
            self.updatedBy = updatedBy
        }

        private enum CodingKeys: String, CodingKey {
            case createdAt
            case createdBy
            case description
            case name
            case studioComponentId
            case subtype
            case type
            case updatedAt
            case updatedBy
        }
    }

    public struct StudioEncryptionConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The ARN for a KMS key that is used to encrypt studio data.
        public let keyArn: String?
        /// The type of KMS key that is used to encrypt studio data.
        public let keyType: StudioEncryptionConfigurationKeyType

        public init(keyArn: String? = nil, keyType: StudioEncryptionConfigurationKeyType) {
            self.keyArn = keyArn
            self.keyType = keyType
        }

        public func validate(name: String) throws {
            try self.validate(self.keyArn, name: "keyArn", parent: name, min: 4)
            try self.validate(self.keyArn, name: "keyArn", parent: name, pattern: "^arn:.*")
        }

        private enum CodingKeys: String, CodingKey {
            case keyArn
            case keyType
        }
    }

    public struct StudioMembership: AWSDecodableShape {
        /// The ID of the identity store.
        public let identityStoreId: String?
        /// The persona.
        public let persona: StudioPersona?
        /// The principal ID.
        public let principalId: String?
        /// The Active Directory Security Identifier for this user, if available.
        public let sid: String?

        public init(identityStoreId: String? = nil, persona: StudioPersona? = nil, principalId: String? = nil, sid: String? = nil) {
            self.identityStoreId = identityStoreId
            self.persona = persona
            self.principalId = principalId
            self.sid = sid
        }

        private enum CodingKeys: String, CodingKey {
            case identityStoreId
            case persona
            case principalId
            case sid
        }
    }

    public struct TagResourceRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "resourceArn", location: .uri("resourceArn"))
        ]

        ///  The Amazon Resource Name (ARN) of the resource you want to add tags to.
        public let resourceArn: String
        /// A collection of labels, in the form of key:value pairs, that apply to this resource.
        public let tags: [String: String]?

        public init(resourceArn: String, tags: [String: String]? = nil) {
            self.resourceArn = resourceArn
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case tags
        }
    }

    public struct TagResourceResponse: AWSDecodableShape {
        public init() {}
    }

    public struct UntagResourceRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "resourceArn", location: .uri("resourceArn")),
            AWSMemberEncoding(label: "tagKeys", location: .querystring("tagKeys"))
        ]

        /// Identifies the Amazon Resource Name(ARN) key from which you are removing tags.
        public let resourceArn: String
        /// One or more tag keys. Specify only the tag keys, not the tag values.
        public let tagKeys: [String]

        public init(resourceArn: String, tagKeys: [String]) {
            self.resourceArn = resourceArn
            self.tagKeys = tagKeys
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct UntagResourceResponse: AWSDecodableShape {
        public init() {}
    }

    public struct UpdateLaunchProfileMemberRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "clientToken", location: .header("X-Amz-Client-Token")),
            AWSMemberEncoding(label: "launchProfileId", location: .uri("launchProfileId")),
            AWSMemberEncoding(label: "principalId", location: .uri("principalId")),
            AWSMemberEncoding(label: "studioId", location: .uri("studioId"))
        ]

        /// Unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If you don’t specify a client token, the AWS SDK automatically generates a client token and uses it for the request to ensure idempotency.
        public let clientToken: String?
        /// The Launch Profile ID.
        public let launchProfileId: String
        /// The persona.
        public let persona: LaunchProfilePersona
        /// The principal ID. This currently supports a Amazon Web Services SSO UserId.
        public let principalId: String
        /// The studio ID.
        public let studioId: String

        public init(clientToken: String? = UpdateLaunchProfileMemberRequest.idempotencyToken(), launchProfileId: String, persona: LaunchProfilePersona, principalId: String, studioId: String) {
            self.clientToken = clientToken
            self.launchProfileId = launchProfileId
            self.persona = persona
            self.principalId = principalId
            self.studioId = studioId
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 64)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case persona
        }
    }

    public struct UpdateLaunchProfileMemberResponse: AWSDecodableShape {
        /// The updated member.
        public let member: LaunchProfileMembership?

        public init(member: LaunchProfileMembership? = nil) {
            self.member = member
        }

        private enum CodingKeys: String, CodingKey {
            case member
        }
    }

    public struct UpdateLaunchProfileRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "clientToken", location: .header("X-Amz-Client-Token")),
            AWSMemberEncoding(label: "launchProfileId", location: .uri("launchProfileId")),
            AWSMemberEncoding(label: "studioId", location: .uri("studioId"))
        ]

        /// Unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If you don’t specify a client token, the AWS SDK automatically generates a client token and uses it for the request to ensure idempotency.
        public let clientToken: String?
        /// The description.
        public let description: String?
        /// The Launch Profile ID.
        public let launchProfileId: String
        /// The version number of the protocol that is used by the launch profile. The only valid version is "2021-03-31".
        public let launchProfileProtocolVersions: [String]?
        /// The name for the launch profile.
        public let name: String?
        /// A configuration for a streaming session.
        public let streamConfiguration: StreamConfigurationCreate?
        /// Unique identifiers for a collection of studio components that can be used with this launch profile.
        public let studioComponentIds: [String]?
        /// The studio ID.
        public let studioId: String

        public init(clientToken: String? = UpdateLaunchProfileRequest.idempotencyToken(), description: String? = nil, launchProfileId: String, launchProfileProtocolVersions: [String]? = nil, name: String? = nil, streamConfiguration: StreamConfigurationCreate? = nil, studioComponentIds: [String]? = nil, studioId: String) {
            self.clientToken = clientToken
            self.description = description
            self.launchProfileId = launchProfileId
            self.launchProfileProtocolVersions = launchProfileProtocolVersions
            self.name = name
            self.streamConfiguration = streamConfiguration
            self.studioComponentIds = studioComponentIds
            self.studioId = studioId
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 64)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.validate(self.description, name: "description", parent: name, max: 256)
            try self.launchProfileProtocolVersions?.forEach {
                try validate($0, name: "launchProfileProtocolVersions[]", parent: name, max: 10)
                try validate($0, name: "launchProfileProtocolVersions[]", parent: name, pattern: "^2021\\-03\\-31$")
            }
            try self.validate(self.name, name: "name", parent: name, max: 64)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.streamConfiguration?.validate(name: "\(name).streamConfiguration")
            try self.validate(self.studioComponentIds, name: "studioComponentIds", parent: name, max: 100)
            try self.validate(self.studioComponentIds, name: "studioComponentIds", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case description
            case launchProfileProtocolVersions
            case name
            case streamConfiguration
            case studioComponentIds
        }
    }

    public struct UpdateLaunchProfileResponse: AWSDecodableShape {
        /// The launch profile.
        public let launchProfile: LaunchProfile?

        public init(launchProfile: LaunchProfile? = nil) {
            self.launchProfile = launchProfile
        }

        private enum CodingKeys: String, CodingKey {
            case launchProfile
        }
    }

    public struct UpdateStreamingImageRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "clientToken", location: .header("X-Amz-Client-Token")),
            AWSMemberEncoding(label: "streamingImageId", location: .uri("streamingImageId")),
            AWSMemberEncoding(label: "studioId", location: .uri("studioId"))
        ]

        /// Unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If you don’t specify a client token, the AWS SDK automatically generates a client token and uses it for the request to ensure idempotency.
        public let clientToken: String?
        /// The description.
        public let description: String?
        /// The name for the streaming image.
        public let name: String?
        /// The streaming image ID.
        public let streamingImageId: String
        /// The studio ID.
        public let studioId: String

        public init(clientToken: String? = UpdateStreamingImageRequest.idempotencyToken(), description: String? = nil, name: String? = nil, streamingImageId: String, studioId: String) {
            self.clientToken = clientToken
            self.description = description
            self.name = name
            self.streamingImageId = streamingImageId
            self.studioId = studioId
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 64)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.validate(self.description, name: "description", parent: name, max: 256)
            try self.validate(self.name, name: "name", parent: name, max: 64)
        }

        private enum CodingKeys: String, CodingKey {
            case description
            case name
        }
    }

    public struct UpdateStreamingImageResponse: AWSDecodableShape {
        public let streamingImage: StreamingImage?

        public init(streamingImage: StreamingImage? = nil) {
            self.streamingImage = streamingImage
        }

        private enum CodingKeys: String, CodingKey {
            case streamingImage
        }
    }

    public struct UpdateStudioComponentRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "clientToken", location: .header("X-Amz-Client-Token")),
            AWSMemberEncoding(label: "studioComponentId", location: .uri("studioComponentId")),
            AWSMemberEncoding(label: "studioId", location: .uri("studioId"))
        ]

        /// Unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If you don’t specify a client token, the AWS SDK automatically generates a client token and uses it for the request to ensure idempotency.
        public let clientToken: String?
        /// The configuration of the studio component, based on component type.
        public let configuration: StudioComponentConfiguration?
        /// The description.
        public let description: String?
        /// The EC2 security groups that control access to the studio component.
        public let ec2SecurityGroupIds: [String]?
        /// Initialization scripts for studio components.
        public let initializationScripts: [StudioComponentInitializationScript]?
        /// The name for the studio component.
        public let name: String?
        /// Parameters for the studio component scripts.
        public let scriptParameters: [ScriptParameterKeyValue]?
        /// The studio component ID.
        public let studioComponentId: String
        /// The studio ID.
        public let studioId: String
        /// The specific subtype of a studio component.
        public let subtype: StudioComponentSubtype?
        /// The type of the studio component.
        public let type: StudioComponentType?

        public init(clientToken: String? = UpdateStudioComponentRequest.idempotencyToken(), configuration: StudioComponentConfiguration? = nil, description: String? = nil, ec2SecurityGroupIds: [String]? = nil, initializationScripts: [StudioComponentInitializationScript]? = nil, name: String? = nil, scriptParameters: [ScriptParameterKeyValue]? = nil, studioComponentId: String, studioId: String, subtype: StudioComponentSubtype? = nil, type: StudioComponentType? = nil) {
            self.clientToken = clientToken
            self.configuration = configuration
            self.description = description
            self.ec2SecurityGroupIds = ec2SecurityGroupIds
            self.initializationScripts = initializationScripts
            self.name = name
            self.scriptParameters = scriptParameters
            self.studioComponentId = studioComponentId
            self.studioId = studioId
            self.subtype = subtype
            self.type = type
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 64)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.configuration?.validate(name: "\(name).configuration")
            try self.validate(self.description, name: "description", parent: name, max: 256)
            try self.validate(self.ec2SecurityGroupIds, name: "ec2SecurityGroupIds", parent: name, max: 30)
            try self.initializationScripts?.forEach {
                try $0.validate(name: "\(name).initializationScripts[]")
            }
            try self.validate(self.name, name: "name", parent: name, max: 64)
            try self.scriptParameters?.forEach {
                try $0.validate(name: "\(name).scriptParameters[]")
            }
            try self.validate(self.scriptParameters, name: "scriptParameters", parent: name, max: 30)
        }

        private enum CodingKeys: String, CodingKey {
            case configuration
            case description
            case ec2SecurityGroupIds
            case initializationScripts
            case name
            case scriptParameters
            case subtype
            case type
        }
    }

    public struct UpdateStudioComponentResponse: AWSDecodableShape {
        /// Information about the studio component.
        public let studioComponent: StudioComponent?

        public init(studioComponent: StudioComponent? = nil) {
            self.studioComponent = studioComponent
        }

        private enum CodingKeys: String, CodingKey {
            case studioComponent
        }
    }

    public struct UpdateStudioRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "clientToken", location: .header("X-Amz-Client-Token")),
            AWSMemberEncoding(label: "studioId", location: .uri("studioId"))
        ]

        /// The IAM role that Studio Admins will assume when logging in to the Nimble Studio portal.
        public let adminRoleArn: String?
        /// Unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If you don’t specify a client token, the AWS SDK automatically generates a client token and uses it for the request to ensure idempotency.
        public let clientToken: String?
        /// A friendly name for the studio.
        public let displayName: String?
        /// The studio ID.
        public let studioId: String
        /// The IAM role that Studio Users will assume when logging in to the Nimble Studio portal.
        public let userRoleArn: String?

        public init(adminRoleArn: String? = nil, clientToken: String? = UpdateStudioRequest.idempotencyToken(), displayName: String? = nil, studioId: String, userRoleArn: String? = nil) {
            self.adminRoleArn = adminRoleArn
            self.clientToken = clientToken
            self.displayName = displayName
            self.studioId = studioId
            self.userRoleArn = userRoleArn
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 64)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.validate(self.displayName, name: "displayName", parent: name, max: 64)
        }

        private enum CodingKeys: String, CodingKey {
            case adminRoleArn
            case displayName
            case userRoleArn
        }
    }

    public struct UpdateStudioResponse: AWSDecodableShape {
        /// Information about a studio.
        public let studio: Studio

        public init(studio: Studio) {
            self.studio = studio
        }

        private enum CodingKeys: String, CodingKey {
            case studio
        }
    }

    public struct ValidationResult: AWSDecodableShape {
        /// The current state.
        public let state: LaunchProfileValidationState
        /// The status code. This will contain the failure reason if the state is VALIDATION_FAILED.
        public let statusCode: LaunchProfileValidationStatusCode
        /// The status message for the validation result.
        public let statusMessage: String
        /// The type of the validation result.
        public let type: LaunchProfileValidationType

        public init(state: LaunchProfileValidationState, statusCode: LaunchProfileValidationStatusCode, statusMessage: String, type: LaunchProfileValidationType) {
            self.state = state
            self.statusCode = statusCode
            self.statusMessage = statusMessage
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case state
            case statusCode
            case statusMessage
            case type
        }
    }
}
