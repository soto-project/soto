//===----------------------------------------------------------------------===//
//
// This source file is part of the Soto for AWS open source project
//
// Copyright (c) 2017-2021 the Soto project authors
// Licensed under Apache License v2.0
//
// See LICENSE.txt for license information
// See CONTRIBUTORS.txt for the list of Soto project authors
//
// SPDX-License-Identifier: Apache-2.0
//
//===----------------------------------------------------------------------===//

// THIS FILE IS AUTOMATICALLY GENERATED by https://github.com/soto-project/soto-codegenerator.
// DO NOT EDIT.

import Foundation
import SotoCore

extension Nimble {
    // MARK: Enums

    public enum LaunchProfilePersona: String, CustomStringConvertible, Codable {
        case user = "USER"
        public var description: String { return self.rawValue }
    }

    public enum LaunchProfilePlatform: String, CustomStringConvertible, Codable {
        case linux = "LINUX"
        case windows = "WINDOWS"
        public var description: String { return self.rawValue }
    }

    public enum LaunchProfileState: String, CustomStringConvertible, Codable {
        case createFailed = "CREATE_FAILED"
        case createInProgress = "CREATE_IN_PROGRESS"
        case deleted = "DELETED"
        case deleteFailed = "DELETE_FAILED"
        case deleteInProgress = "DELETE_IN_PROGRESS"
        case ready = "READY"
        case updateFailed = "UPDATE_FAILED"
        case updateInProgress = "UPDATE_IN_PROGRESS"
        public var description: String { return self.rawValue }
    }

    public enum LaunchProfileStatusCode: String, CustomStringConvertible, Codable {
        case encryptionKeyAccessDenied = "ENCRYPTION_KEY_ACCESS_DENIED"
        case encryptionKeyNotFound = "ENCRYPTION_KEY_NOT_FOUND"
        case internalError = "INTERNAL_ERROR"
        case invalidSubnetsProvided = "INVALID_SUBNETS_PROVIDED"
        case launchProfileCreated = "LAUNCH_PROFILE_CREATED"
        case launchProfileCreateInProgress = "LAUNCH_PROFILE_CREATE_IN_PROGRESS"
        case launchProfileDeleted = "LAUNCH_PROFILE_DELETED"
        case launchProfileDeleteInProgress = "LAUNCH_PROFILE_DELETE_IN_PROGRESS"
        case launchProfileUpdated = "LAUNCH_PROFILE_UPDATED"
        case launchProfileUpdateInProgress = "LAUNCH_PROFILE_UPDATE_IN_PROGRESS"
        case launchProfileWithStreamSessionsNotDeleted = "LAUNCH_PROFILE_WITH_STREAM_SESSIONS_NOT_DELETED"
        case streamingImageNotFound = "STREAMING_IMAGE_NOT_FOUND"
        case streamingImageNotReady = "STREAMING_IMAGE_NOT_READY"
        public var description: String { return self.rawValue }
    }

    public enum StreamingClipboardMode: String, CustomStringConvertible, Codable {
        case disabled = "DISABLED"
        case enabled = "ENABLED"
        public var description: String { return self.rawValue }
    }

    public enum StreamingImageEncryptionConfigurationKeyType: String, CustomStringConvertible, Codable {
        case customerManagedKey = "CUSTOMER_MANAGED_KEY"
        public var description: String { return self.rawValue }
    }

    public enum StreamingImageState: String, CustomStringConvertible, Codable {
        case createFailed = "CREATE_FAILED"
        case createInProgress = "CREATE_IN_PROGRESS"
        case deleted = "DELETED"
        case deleteFailed = "DELETE_FAILED"
        case deleteInProgress = "DELETE_IN_PROGRESS"
        case ready = "READY"
        case updateFailed = "UPDATE_FAILED"
        case updateInProgress = "UPDATE_IN_PROGRESS"
        public var description: String { return self.rawValue }
    }

    public enum StreamingImageStatusCode: String, CustomStringConvertible, Codable {
        case internalError = "INTERNAL_ERROR"
        case streamingImageCreateInProgress = "STREAMING_IMAGE_CREATE_IN_PROGRESS"
        case streamingImageDeleted = "STREAMING_IMAGE_DELETED"
        case streamingImageDeleteInProgress = "STREAMING_IMAGE_DELETE_IN_PROGRESS"
        case streamingImageReady = "STREAMING_IMAGE_READY"
        case streamingImageUpdateInProgress = "STREAMING_IMAGE_UPDATE_IN_PROGRESS"
        public var description: String { return self.rawValue }
    }

    public enum StreamingInstanceType: String, CustomStringConvertible, Codable {
        case g4dn12Xlarge = "g4dn.12xlarge"
        case g4dn16Xlarge = "g4dn.16xlarge"
        case g4dn2Xlarge = "g4dn.2xlarge"
        case g4dn4Xlarge = "g4dn.4xlarge"
        case g4dn8Xlarge = "g4dn.8xlarge"
        case g4dnXlarge = "g4dn.xlarge"
        public var description: String { return self.rawValue }
    }

    public enum StreamingSessionState: String, CustomStringConvertible, Codable {
        case createFailed = "CREATE_FAILED"
        case createInProgress = "CREATE_IN_PROGRESS"
        case deleted = "DELETED"
        case deleteFailed = "DELETE_FAILED"
        case deleteInProgress = "DELETE_IN_PROGRESS"
        case ready = "READY"
        public var description: String { return self.rawValue }
    }

    public enum StreamingSessionStatusCode: String, CustomStringConvertible, Codable {
        case activeDirectoryDomainJoinError = "ACTIVE_DIRECTORY_DOMAIN_JOIN_ERROR"
        case decryptStreamingImageError = "DECRYPT_STREAMING_IMAGE_ERROR"
        case initializationScriptError = "INITIALIZATION_SCRIPT_ERROR"
        case insufficientCapacity = "INSUFFICIENT_CAPACITY"
        case internalError = "INTERNAL_ERROR"
        case networkConnectionError = "NETWORK_CONNECTION_ERROR"
        case networkInterfaceError = "NETWORK_INTERFACE_ERROR"
        case streamingSessionCreateInProgress = "STREAMING_SESSION_CREATE_IN_PROGRESS"
        case streamingSessionDeleted = "STREAMING_SESSION_DELETED"
        case streamingSessionDeleteInProgress = "STREAMING_SESSION_DELETE_IN_PROGRESS"
        case streamingSessionReady = "STREAMING_SESSION_READY"
        public var description: String { return self.rawValue }
    }

    public enum StreamingSessionStreamState: String, CustomStringConvertible, Codable {
        case createFailed = "CREATE_FAILED"
        case createInProgress = "CREATE_IN_PROGRESS"
        case deleted = "DELETED"
        case deleteFailed = "DELETE_FAILED"
        case deleteInProgress = "DELETE_IN_PROGRESS"
        case ready = "READY"
        public var description: String { return self.rawValue }
    }

    public enum StreamingSessionStreamStatusCode: String, CustomStringConvertible, Codable {
        case internalError = "INTERNAL_ERROR"
        case networkConnectionError = "NETWORK_CONNECTION_ERROR"
        case streamCreateInProgress = "STREAM_CREATE_IN_PROGRESS"
        case streamDeleted = "STREAM_DELETED"
        case streamDeleteInProgress = "STREAM_DELETE_IN_PROGRESS"
        case streamReady = "STREAM_READY"
        public var description: String { return self.rawValue }
    }

    public enum StudioComponentInitializationScriptRunContext: String, CustomStringConvertible, Codable {
        case systemInitialization = "SYSTEM_INITIALIZATION"
        case userInitialization = "USER_INITIALIZATION"
        public var description: String { return self.rawValue }
    }

    public enum StudioComponentState: String, CustomStringConvertible, Codable {
        case createFailed = "CREATE_FAILED"
        case createInProgress = "CREATE_IN_PROGRESS"
        case deleted = "DELETED"
        case deleteFailed = "DELETE_FAILED"
        case deleteInProgress = "DELETE_IN_PROGRESS"
        case ready = "READY"
        case updateFailed = "UPDATE_FAILED"
        case updateInProgress = "UPDATE_IN_PROGRESS"
        public var description: String { return self.rawValue }
    }

    public enum StudioComponentStatusCode: String, CustomStringConvertible, Codable {
        case activeDirectoryAlreadyExists = "ACTIVE_DIRECTORY_ALREADY_EXISTS"
        case encryptionKeyAccessDenied = "ENCRYPTION_KEY_ACCESS_DENIED"
        case encryptionKeyNotFound = "ENCRYPTION_KEY_NOT_FOUND"
        case internalError = "INTERNAL_ERROR"
        case studioComponentCreated = "STUDIO_COMPONENT_CREATED"
        case studioComponentCreateInProgress = "STUDIO_COMPONENT_CREATE_IN_PROGRESS"
        case studioComponentDeleted = "STUDIO_COMPONENT_DELETED"
        case studioComponentDeleteInProgress = "STUDIO_COMPONENT_DELETE_IN_PROGRESS"
        case studioComponentUpdated = "STUDIO_COMPONENT_UPDATED"
        case studioComponentUpdateInProgress = "STUDIO_COMPONENT_UPDATE_IN_PROGRESS"
        public var description: String { return self.rawValue }
    }

    public enum StudioComponentSubtype: String, CustomStringConvertible, Codable {
        case amazonFsxForLustre = "AMAZON_FSX_FOR_LUSTRE"
        case amazonFsxForWindows = "AMAZON_FSX_FOR_WINDOWS"
        case awsManagedMicrosoftAd = "AWS_MANAGED_MICROSOFT_AD"
        case custom = "CUSTOM"
        public var description: String { return self.rawValue }
    }

    public enum StudioComponentType: String, CustomStringConvertible, Codable {
        case activeDirectory = "ACTIVE_DIRECTORY"
        case computeFarm = "COMPUTE_FARM"
        case custom = "CUSTOM"
        case licenseService = "LICENSE_SERVICE"
        case sharedFileSystem = "SHARED_FILE_SYSTEM"
        public var description: String { return self.rawValue }
    }

    public enum StudioEncryptionConfigurationKeyType: String, CustomStringConvertible, Codable {
        case awsOwnedKey = "AWS_OWNED_KEY"
        case customerManagedKey = "CUSTOMER_MANAGED_KEY"
        public var description: String { return self.rawValue }
    }

    public enum StudioPersona: String, CustomStringConvertible, Codable {
        case administrator = "ADMINISTRATOR"
        public var description: String { return self.rawValue }
    }

    public enum StudioState: String, CustomStringConvertible, Codable {
        case createFailed = "CREATE_FAILED"
        case createInProgress = "CREATE_IN_PROGRESS"
        case deleted = "DELETED"
        case deleteFailed = "DELETE_FAILED"
        case deleteInProgress = "DELETE_IN_PROGRESS"
        case ready = "READY"
        case updateFailed = "UPDATE_FAILED"
        case updateInProgress = "UPDATE_IN_PROGRESS"
        public var description: String { return self.rawValue }
    }

    public enum StudioStatusCode: String, CustomStringConvertible, Codable {
        case awsSsoAccessDenied = "AWS_SSO_ACCESS_DENIED"
        case awsSsoConfigurationRepaired = "AWS_SSO_CONFIGURATION_REPAIRED"
        case awsSsoConfigurationRepairInProgress = "AWS_SSO_CONFIGURATION_REPAIR_IN_PROGRESS"
        case awsSsoNotEnabled = "AWS_SSO_NOT_ENABLED"
        case encryptionKeyAccessDenied = "ENCRYPTION_KEY_ACCESS_DENIED"
        case encryptionKeyNotFound = "ENCRYPTION_KEY_NOT_FOUND"
        case internalError = "INTERNAL_ERROR"
        case roleCouldNotBeAssumed = "ROLE_COULD_NOT_BE_ASSUMED"
        case roleNotOwnedByStudioOwner = "ROLE_NOT_OWNED_BY_STUDIO_OWNER"
        case studioCreated = "STUDIO_CREATED"
        case studioCreateInProgress = "STUDIO_CREATE_IN_PROGRESS"
        case studioDeleted = "STUDIO_DELETED"
        case studioDeleteInProgress = "STUDIO_DELETE_IN_PROGRESS"
        case studioUpdated = "STUDIO_UPDATED"
        case studioUpdateInProgress = "STUDIO_UPDATE_IN_PROGRESS"
        case studioWithLaunchProfilesNotDeleted = "STUDIO_WITH_LAUNCH_PROFILES_NOT_DELETED"
        case studioWithStreamingImagesNotDeleted = "STUDIO_WITH_STREAMING_IMAGES_NOT_DELETED"
        case studioWithStudioComponentsNotDeleted = "STUDIO_WITH_STUDIO_COMPONENTS_NOT_DELETED"
        public var description: String { return self.rawValue }
    }

    // MARK: Shapes

    public struct AcceptEulasRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "clientToken", location: .header(locationName: "X-Amz-Client-Token")),
            AWSMemberEncoding(label: "studioId", location: .uri(locationName: "studioId"))
        ]

        /// To make an idempotent API request using one of these actions, specify a client token in the request. You should not reuse the same client token for other API requests. If you retry a request that completed successfully using the same client token and the same parameters, the retry succeeds without performing any further actions. If you retry a successful request using the same client token, but one or more of the parameters are different, the retry fails with a ValidationException error.
        public let clientToken: String?
        /// The EULA ID.
        public let eulaIds: [String]?
        /// The studio ID.
        public let studioId: String

        public init(clientToken: String? = AcceptEulasRequest.idempotencyToken(), eulaIds: [String]? = nil, studioId: String) {
            self.clientToken = clientToken
            self.eulaIds = eulaIds
            self.studioId = studioId
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 64)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case eulaIds
        }
    }

    public struct AcceptEulasResponse: AWSDecodableShape {
        /// A collection of EULA acceptances.
        public let eulaAcceptances: [EulaAcceptance]?

        public init(eulaAcceptances: [EulaAcceptance]? = nil) {
            self.eulaAcceptances = eulaAcceptances
        }

        private enum CodingKeys: String, CodingKey {
            case eulaAcceptances
        }
    }

    public struct ActiveDirectoryComputerAttribute: AWSEncodableShape & AWSDecodableShape {
        /// The name for the LDAP attribute.
        public let name: String?
        /// The value for the LDAP attribute.
        public let value: String?

        public init(name: String? = nil, value: String? = nil) {
            self.name = name
            self.value = value
        }

        public func validate(name: String) throws {
            try self.validate(self.name, name: "name", parent: name, max: 40)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.value, name: "value", parent: name, max: 64)
            try self.validate(self.value, name: "value", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case name
            case value
        }
    }

    public struct ActiveDirectoryConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// A collection of custom attributes for an Active Directory computer.
        public let computerAttributes: [ActiveDirectoryComputerAttribute]?
        /// The directory ID of the Directory Service for Microsoft Active Directory to access using this studio component.
        public let directoryId: String?
        /// The distinguished name (DN) and organizational unit (OU) of an Active Directory computer.
        public let organizationalUnitDistinguishedName: String?

        public init(computerAttributes: [ActiveDirectoryComputerAttribute]? = nil, directoryId: String? = nil, organizationalUnitDistinguishedName: String? = nil) {
            self.computerAttributes = computerAttributes
            self.directoryId = directoryId
            self.organizationalUnitDistinguishedName = organizationalUnitDistinguishedName
        }

        public func validate(name: String) throws {
            try self.computerAttributes?.forEach {
                try $0.validate(name: "\(name).computerAttributes[]")
            }
            try self.validate(self.computerAttributes, name: "computerAttributes", parent: name, max: 50)
            try self.validate(self.organizationalUnitDistinguishedName, name: "organizationalUnitDistinguishedName", parent: name, max: 2000)
            try self.validate(self.organizationalUnitDistinguishedName, name: "organizationalUnitDistinguishedName", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case computerAttributes
            case directoryId
            case organizationalUnitDistinguishedName
        }
    }

    public struct ComputeFarmConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The name of an Active Directory user that is used on ComputeFarm worker instances.
        public let activeDirectoryUser: String?
        /// The endpoint of the ComputeFarm that is accessed by the studio component resource.
        public let endpoint: String?

        public init(activeDirectoryUser: String? = nil, endpoint: String? = nil) {
            self.activeDirectoryUser = activeDirectoryUser
            self.endpoint = endpoint
        }

        private enum CodingKeys: String, CodingKey {
            case activeDirectoryUser
            case endpoint
        }
    }

    public struct CreateLaunchProfileRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "clientToken", location: .header(locationName: "X-Amz-Client-Token")),
            AWSMemberEncoding(label: "studioId", location: .uri(locationName: "studioId"))
        ]

        /// To make an idempotent API request using one of these actions, specify a client token in the request. You should not reuse the same client token for other API requests. If you retry a request that completed successfully using the same client token and the same parameters, the retry succeeds without performing any further actions. If you retry a successful request using the same client token, but one or more of the parameters are different, the retry fails with a ValidationException error.
        public let clientToken: String?
        /// The description.
        public let description: String?
        public let ec2SubnetIds: [String]
        /// The version number of the protocol that is used by the launch profile. The only valid version is "2021-03-31".
        public let launchProfileProtocolVersions: [String]
        /// The name for the launch profile.
        public let name: String
        /// A configuration for a streaming session.
        public let streamConfiguration: StreamConfigurationCreate
        /// Unique identifiers for a collection of studio components that can be used with this launch profile.
        public let studioComponentIds: [String]
        /// The studio ID.
        public let studioId: String
        /// A collection of labels, in the form of key:value pairs, that apply to this resource.
        public let tags: [String: String]?

        public init(clientToken: String? = CreateLaunchProfileRequest.idempotencyToken(), description: String? = nil, ec2SubnetIds: [String], launchProfileProtocolVersions: [String], name: String, streamConfiguration: StreamConfigurationCreate, studioComponentIds: [String], studioId: String, tags: [String: String]? = nil) {
            self.clientToken = clientToken
            self.description = description
            self.ec2SubnetIds = ec2SubnetIds
            self.launchProfileProtocolVersions = launchProfileProtocolVersions
            self.name = name
            self.streamConfiguration = streamConfiguration
            self.studioComponentIds = studioComponentIds
            self.studioId = studioId
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 64)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.validate(self.description, name: "description", parent: name, max: 256)
            try self.validate(self.ec2SubnetIds, name: "ec2SubnetIds", parent: name, max: 6)
            try self.launchProfileProtocolVersions.forEach {
                try validate($0, name: "launchProfileProtocolVersions[]", parent: name, max: 10)
                try validate($0, name: "launchProfileProtocolVersions[]", parent: name, pattern: "^2021\\-03\\-31$")
            }
            try self.validate(self.name, name: "name", parent: name, max: 64)
            try self.streamConfiguration.validate(name: "\(name).streamConfiguration")
            try self.validate(self.studioComponentIds, name: "studioComponentIds", parent: name, max: 100)
            try self.validate(self.studioComponentIds, name: "studioComponentIds", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case description
            case ec2SubnetIds
            case launchProfileProtocolVersions
            case name
            case streamConfiguration
            case studioComponentIds
            case tags
        }
    }

    public struct CreateLaunchProfileResponse: AWSDecodableShape {
        /// The launch profile.
        public let launchProfile: LaunchProfile?

        public init(launchProfile: LaunchProfile? = nil) {
            self.launchProfile = launchProfile
        }

        private enum CodingKeys: String, CodingKey {
            case launchProfile
        }
    }

    public struct CreateStreamingImageRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "clientToken", location: .header(locationName: "X-Amz-Client-Token")),
            AWSMemberEncoding(label: "studioId", location: .uri(locationName: "studioId"))
        ]

        /// To make an idempotent API request using one of these actions, specify a client token in the request. You should not reuse the same client token for other API requests. If you retry a request that completed successfully using the same client token and the same parameters, the retry succeeds without performing any further actions. If you retry a successful request using the same client token, but one or more of the parameters are different, the retry fails with a ValidationException error.
        public let clientToken: String?
        /// A human-readable description of the streaming image.
        public let description: String?
        /// The ID of an EC2 machine image with which to create this streaming image.
        public let ec2ImageId: String
        /// A friendly name for a streaming image resource.
        public let name: String
        /// The studio ID.
        public let studioId: String
        /// A collection of labels, in the form of key:value pairs, that apply to this resource.
        public let tags: [String: String]?

        public init(clientToken: String? = CreateStreamingImageRequest.idempotencyToken(), description: String? = nil, ec2ImageId: String, name: String, studioId: String, tags: [String: String]? = nil) {
            self.clientToken = clientToken
            self.description = description
            self.ec2ImageId = ec2ImageId
            self.name = name
            self.studioId = studioId
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 64)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.validate(self.description, name: "description", parent: name, max: 256)
            try self.validate(self.ec2ImageId, name: "ec2ImageId", parent: name, pattern: "^ami-[0-9A-z]+$")
            try self.validate(self.name, name: "name", parent: name, max: 64)
        }

        private enum CodingKeys: String, CodingKey {
            case description
            case ec2ImageId
            case name
            case tags
        }
    }

    public struct CreateStreamingImageResponse: AWSDecodableShape {
        public let streamingImage: StreamingImage?

        public init(streamingImage: StreamingImage? = nil) {
            self.streamingImage = streamingImage
        }

        private enum CodingKeys: String, CodingKey {
            case streamingImage
        }
    }

    public struct CreateStreamingSessionRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "clientToken", location: .header(locationName: "X-Amz-Client-Token")),
            AWSMemberEncoding(label: "studioId", location: .uri(locationName: "studioId"))
        ]

        /// To make an idempotent API request using one of these actions, specify a client token in the request. You should not reuse the same client token for other API requests. If you retry a request that completed successfully using the same client token and the same parameters, the retry succeeds without performing any further actions. If you retry a successful request using the same client token, but one or more of the parameters are different, the retry fails with a ValidationException error.
        public let clientToken: String?
        /// The EC2 Instance type used for the streaming session.
        public let ec2InstanceType: StreamingInstanceType?
        /// The launch profile ID.
        public let launchProfileId: String?
        /// The user ID of the user that owns the streaming session.
        public let ownedBy: String?
        /// The ID of the streaming image.
        public let streamingImageId: String?
        /// The studio ID.
        public let studioId: String
        /// A collection of labels, in the form of key:value pairs, that apply to this resource.
        public let tags: [String: String]?

        public init(clientToken: String? = CreateStreamingSessionRequest.idempotencyToken(), ec2InstanceType: StreamingInstanceType? = nil, launchProfileId: String? = nil, ownedBy: String? = nil, streamingImageId: String? = nil, studioId: String, tags: [String: String]? = nil) {
            self.clientToken = clientToken
            self.ec2InstanceType = ec2InstanceType
            self.launchProfileId = launchProfileId
            self.ownedBy = ownedBy
            self.streamingImageId = streamingImageId
            self.studioId = studioId
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 64)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.validate(self.streamingImageId, name: "streamingImageId", parent: name, max: 22)
            try self.validate(self.streamingImageId, name: "streamingImageId", parent: name, pattern: "^[a-zA-Z0-9-_]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case ec2InstanceType
            case launchProfileId
            case ownedBy
            case streamingImageId
            case tags
        }
    }

    public struct CreateStreamingSessionResponse: AWSDecodableShape {
        /// The session.
        public let session: StreamingSession?

        public init(session: StreamingSession? = nil) {
            self.session = session
        }

        private enum CodingKeys: String, CodingKey {
            case session
        }
    }

    public struct CreateStreamingSessionStreamRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "clientToken", location: .header(locationName: "X-Amz-Client-Token")),
            AWSMemberEncoding(label: "sessionId", location: .uri(locationName: "sessionId")),
            AWSMemberEncoding(label: "studioId", location: .uri(locationName: "studioId"))
        ]

        /// To make an idempotent API request using one of these actions, specify a client token in the request. You should not reuse the same client token for other API requests. If you retry a request that completed successfully using the same client token and the same parameters, the retry succeeds without performing any further actions. If you retry a successful request using the same client token, but one or more of the parameters are different, the retry fails with a ValidationException error.
        public let clientToken: String?
        /// The expiration time in seconds.
        public let expirationInSeconds: Int?
        /// The session ID.
        public let sessionId: String
        /// The studio ID.
        public let studioId: String

        public init(clientToken: String? = CreateStreamingSessionStreamRequest.idempotencyToken(), expirationInSeconds: Int? = nil, sessionId: String, studioId: String) {
            self.clientToken = clientToken
            self.expirationInSeconds = expirationInSeconds
            self.sessionId = sessionId
            self.studioId = studioId
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 64)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.validate(self.expirationInSeconds, name: "expirationInSeconds", parent: name, max: 3600)
            try self.validate(self.expirationInSeconds, name: "expirationInSeconds", parent: name, min: 60)
        }

        private enum CodingKeys: String, CodingKey {
            case expirationInSeconds
        }
    }

    public struct CreateStreamingSessionStreamResponse: AWSDecodableShape {
        /// The stream.
        public let stream: StreamingSessionStream?

        public init(stream: StreamingSessionStream? = nil) {
            self.stream = stream
        }

        private enum CodingKeys: String, CodingKey {
            case stream
        }
    }

    public struct CreateStudioComponentRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "clientToken", location: .header(locationName: "X-Amz-Client-Token")),
            AWSMemberEncoding(label: "studioId", location: .uri(locationName: "studioId"))
        ]

        /// To make an idempotent API request using one of these actions, specify a client token in the request. You should not reuse the same client token for other API requests. If you retry a request that completed successfully using the same client token and the same parameters, the retry succeeds without performing any further actions. If you retry a successful request using the same client token, but one or more of the parameters are different, the retry fails with a ValidationException error.
        public let clientToken: String?
        /// The configuration of the studio component, based on component type.
        public let configuration: StudioComponentConfiguration?
        /// The description.
        public let description: String?
        /// The EC2 security groups that control access to the studio component.
        public let ec2SecurityGroupIds: [String]?
        /// Initialization scripts for studio components.
        public let initializationScripts: [StudioComponentInitializationScript]?
        /// The name for the studio component.
        public let name: String
        /// Parameters for the studio component scripts.
        public let scriptParameters: [ScriptParameterKeyValue]?
        /// The studio ID.
        public let studioId: String
        /// The specific subtype of a studio component.
        public let subtype: StudioComponentSubtype?
        /// A collection of labels, in the form of key:value pairs, that apply to this resource.
        public let tags: [String: String]?
        /// The type of the studio component.
        public let type: StudioComponentType

        public init(clientToken: String? = CreateStudioComponentRequest.idempotencyToken(), configuration: StudioComponentConfiguration? = nil, description: String? = nil, ec2SecurityGroupIds: [String]? = nil, initializationScripts: [StudioComponentInitializationScript]? = nil, name: String, scriptParameters: [ScriptParameterKeyValue]? = nil, studioId: String, subtype: StudioComponentSubtype? = nil, tags: [String: String]? = nil, type: StudioComponentType) {
            self.clientToken = clientToken
            self.configuration = configuration
            self.description = description
            self.ec2SecurityGroupIds = ec2SecurityGroupIds
            self.initializationScripts = initializationScripts
            self.name = name
            self.scriptParameters = scriptParameters
            self.studioId = studioId
            self.subtype = subtype
            self.tags = tags
            self.type = type
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 64)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.configuration?.validate(name: "\(name).configuration")
            try self.validate(self.description, name: "description", parent: name, max: 256)
            try self.validate(self.ec2SecurityGroupIds, name: "ec2SecurityGroupIds", parent: name, max: 30)
            try self.validate(self.ec2SecurityGroupIds, name: "ec2SecurityGroupIds", parent: name, min: 1)
            try self.initializationScripts?.forEach {
                try $0.validate(name: "\(name).initializationScripts[]")
            }
            try self.validate(self.name, name: "name", parent: name, max: 64)
            try self.scriptParameters?.forEach {
                try $0.validate(name: "\(name).scriptParameters[]")
            }
            try self.validate(self.scriptParameters, name: "scriptParameters", parent: name, max: 30)
        }

        private enum CodingKeys: String, CodingKey {
            case configuration
            case description
            case ec2SecurityGroupIds
            case initializationScripts
            case name
            case scriptParameters
            case subtype
            case tags
            case type
        }
    }

    public struct CreateStudioComponentResponse: AWSDecodableShape {
        /// Information about the studio component.
        public let studioComponent: StudioComponent?

        public init(studioComponent: StudioComponent? = nil) {
            self.studioComponent = studioComponent
        }

        private enum CodingKeys: String, CodingKey {
            case studioComponent
        }
    }

    public struct CreateStudioRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "clientToken", location: .header(locationName: "X-Amz-Client-Token"))
        ]

        /// The IAM role that Studio Admins will assume when logging in to the Nimble Studio portal.
        public let adminRoleArn: String
        /// To make an idempotent API request using one of these actions, specify a client token in the request. You should not reuse the same client token for other API requests. If you retry a request that completed successfully using the same client token and the same parameters, the retry succeeds without performing any further actions. If you retry a successful request using the same client token, but one or more of the parameters are different, the retry fails with a ValidationException error.
        public let clientToken: String?
        /// A friendly name for the studio.
        public let displayName: String
        /// The studio encryption configuration.
        public let studioEncryptionConfiguration: StudioEncryptionConfiguration?
        /// The studio name that is used in the URL of the Nimble Studio portal when accessed by Nimble Studio users.
        public let studioName: String
        /// A collection of labels, in the form of key:value pairs, that apply to this resource.
        public let tags: [String: String]?
        /// The IAM role that Studio Users will assume when logging in to the Nimble Studio portal.
        public let userRoleArn: String

        public init(adminRoleArn: String, clientToken: String? = CreateStudioRequest.idempotencyToken(), displayName: String, studioEncryptionConfiguration: StudioEncryptionConfiguration? = nil, studioName: String, tags: [String: String]? = nil, userRoleArn: String) {
            self.adminRoleArn = adminRoleArn
            self.clientToken = clientToken
            self.displayName = displayName
            self.studioEncryptionConfiguration = studioEncryptionConfiguration
            self.studioName = studioName
            self.tags = tags
            self.userRoleArn = userRoleArn
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 64)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.validate(self.displayName, name: "displayName", parent: name, max: 64)
            try self.studioEncryptionConfiguration?.validate(name: "\(name).studioEncryptionConfiguration")
            try self.validate(self.studioName, name: "studioName", parent: name, max: 64)
            try self.validate(self.studioName, name: "studioName", parent: name, min: 3)
            try self.validate(self.studioName, name: "studioName", parent: name, pattern: "^[a-z0-9]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case adminRoleArn
            case displayName
            case studioEncryptionConfiguration
            case studioName
            case tags
            case userRoleArn
        }
    }

    public struct CreateStudioResponse: AWSDecodableShape {
        /// Information about a studio.
        public let studio: Studio?

        public init(studio: Studio? = nil) {
            self.studio = studio
        }

        private enum CodingKeys: String, CodingKey {
            case studio
        }
    }

    public struct DeleteLaunchProfileMemberRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "clientToken", location: .header(locationName: "X-Amz-Client-Token")),
            AWSMemberEncoding(label: "launchProfileId", location: .uri(locationName: "launchProfileId")),
            AWSMemberEncoding(label: "principalId", location: .uri(locationName: "principalId")),
            AWSMemberEncoding(label: "studioId", location: .uri(locationName: "studioId"))
        ]

        /// To make an idempotent API request using one of these actions, specify a client token in the request. You should not reuse the same client token for other API requests. If you retry a request that completed successfully using the same client token and the same parameters, the retry succeeds without performing any further actions. If you retry a successful request using the same client token, but one or more of the parameters are different, the retry fails with a ValidationException error.
        public let clientToken: String?
        /// The launch profile ID.
        public let launchProfileId: String
        /// The principal ID.
        public let principalId: String
        /// The studio ID.
        public let studioId: String

        public init(clientToken: String? = DeleteLaunchProfileMemberRequest.idempotencyToken(), launchProfileId: String, principalId: String, studioId: String) {
            self.clientToken = clientToken
            self.launchProfileId = launchProfileId
            self.principalId = principalId
            self.studioId = studioId
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 64)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteLaunchProfileMemberResponse: AWSDecodableShape {
        public init() {}
    }

    public struct DeleteLaunchProfileRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "clientToken", location: .header(locationName: "X-Amz-Client-Token")),
            AWSMemberEncoding(label: "launchProfileId", location: .uri(locationName: "launchProfileId")),
            AWSMemberEncoding(label: "studioId", location: .uri(locationName: "studioId"))
        ]

        /// To make an idempotent API request using one of these actions, specify a client token in the request. You should not reuse the same client token for other API requests. If you retry a request that completed successfully using the same client token and the same parameters, the retry succeeds without performing any further actions. If you retry a successful request using the same client token, but one or more of the parameters are different, the retry fails with a ValidationException error.
        public let clientToken: String?
        /// The launch profile ID.
        public let launchProfileId: String
        /// The studio ID.
        public let studioId: String

        public init(clientToken: String? = DeleteLaunchProfileRequest.idempotencyToken(), launchProfileId: String, studioId: String) {
            self.clientToken = clientToken
            self.launchProfileId = launchProfileId
            self.studioId = studioId
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 64)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteLaunchProfileResponse: AWSDecodableShape {
        /// The launch profile.
        public let launchProfile: LaunchProfile?

        public init(launchProfile: LaunchProfile? = nil) {
            self.launchProfile = launchProfile
        }

        private enum CodingKeys: String, CodingKey {
            case launchProfile
        }
    }

    public struct DeleteStreamingImageRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "clientToken", location: .header(locationName: "X-Amz-Client-Token")),
            AWSMemberEncoding(label: "streamingImageId", location: .uri(locationName: "streamingImageId")),
            AWSMemberEncoding(label: "studioId", location: .uri(locationName: "studioId"))
        ]

        /// To make an idempotent API request using one of these actions, specify a client token in the request. You should not reuse the same client token for other API requests. If you retry a request that completed successfully using the same client token and the same parameters, the retry succeeds without performing any further actions. If you retry a successful request using the same client token, but one or more of the parameters are different, the retry fails with a ValidationException error.
        public let clientToken: String?
        /// The streaming image ID.
        public let streamingImageId: String
        /// The studio ID.
        public let studioId: String

        public init(clientToken: String? = DeleteStreamingImageRequest.idempotencyToken(), streamingImageId: String, studioId: String) {
            self.clientToken = clientToken
            self.streamingImageId = streamingImageId
            self.studioId = studioId
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 64)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteStreamingImageResponse: AWSDecodableShape {
        /// The streaming image.
        public let streamingImage: StreamingImage?

        public init(streamingImage: StreamingImage? = nil) {
            self.streamingImage = streamingImage
        }

        private enum CodingKeys: String, CodingKey {
            case streamingImage
        }
    }

    public struct DeleteStreamingSessionRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "clientToken", location: .header(locationName: "X-Amz-Client-Token")),
            AWSMemberEncoding(label: "sessionId", location: .uri(locationName: "sessionId")),
            AWSMemberEncoding(label: "studioId", location: .uri(locationName: "studioId"))
        ]

        /// To make an idempotent API request using one of these actions, specify a client token in the request. You should not reuse the same client token for other API requests. If you retry a request that completed successfully using the same client token and the same parameters, the retry succeeds without performing any further actions. If you retry a successful request using the same client token, but one or more of the parameters are different, the retry fails with a ValidationException error.
        public let clientToken: String?
        /// The session ID.
        public let sessionId: String
        /// The studio ID.
        public let studioId: String

        public init(clientToken: String? = DeleteStreamingSessionRequest.idempotencyToken(), sessionId: String, studioId: String) {
            self.clientToken = clientToken
            self.sessionId = sessionId
            self.studioId = studioId
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 64)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteStreamingSessionResponse: AWSDecodableShape {
        /// The session.
        public let session: StreamingSession?

        public init(session: StreamingSession? = nil) {
            self.session = session
        }

        private enum CodingKeys: String, CodingKey {
            case session
        }
    }

    public struct DeleteStudioComponentRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "clientToken", location: .header(locationName: "X-Amz-Client-Token")),
            AWSMemberEncoding(label: "studioComponentId", location: .uri(locationName: "studioComponentId")),
            AWSMemberEncoding(label: "studioId", location: .uri(locationName: "studioId"))
        ]

        /// To make an idempotent API request using one of these actions, specify a client token in the request. You should not reuse the same client token for other API requests. If you retry a request that completed successfully using the same client token and the same parameters, the retry succeeds without performing any further actions. If you retry a successful request using the same client token, but one or more of the parameters are different, the retry fails with a ValidationException error.
        public let clientToken: String?
        /// The studio component ID.
        public let studioComponentId: String
        /// The studio ID.
        public let studioId: String

        public init(clientToken: String? = DeleteStudioComponentRequest.idempotencyToken(), studioComponentId: String, studioId: String) {
            self.clientToken = clientToken
            self.studioComponentId = studioComponentId
            self.studioId = studioId
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 64)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteStudioComponentResponse: AWSDecodableShape {
        /// Information about the studio component.
        public let studioComponent: StudioComponent?

        public init(studioComponent: StudioComponent? = nil) {
            self.studioComponent = studioComponent
        }

        private enum CodingKeys: String, CodingKey {
            case studioComponent
        }
    }

    public struct DeleteStudioMemberRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "clientToken", location: .header(locationName: "X-Amz-Client-Token")),
            AWSMemberEncoding(label: "principalId", location: .uri(locationName: "principalId")),
            AWSMemberEncoding(label: "studioId", location: .uri(locationName: "studioId"))
        ]

        /// To make an idempotent API request using one of these actions, specify a client token in the request. You should not reuse the same client token for other API requests. If you retry a request that completed successfully using the same client token and the same parameters, the retry succeeds without performing any further actions. If you retry a successful request using the same client token, but one or more of the parameters are different, the retry fails with a ValidationException error.
        public let clientToken: String?
        /// The principal ID.
        public let principalId: String
        /// The studio ID.
        public let studioId: String

        public init(clientToken: String? = DeleteStudioMemberRequest.idempotencyToken(), principalId: String, studioId: String) {
            self.clientToken = clientToken
            self.principalId = principalId
            self.studioId = studioId
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 64)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteStudioMemberResponse: AWSDecodableShape {
        public init() {}
    }

    public struct DeleteStudioRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "clientToken", location: .header(locationName: "X-Amz-Client-Token")),
            AWSMemberEncoding(label: "studioId", location: .uri(locationName: "studioId"))
        ]

        /// To make an idempotent API request using one of these actions, specify a client token in the request. You should not reuse the same client token for other API requests. If you retry a request that completed successfully using the same client token and the same parameters, the retry succeeds without performing any further actions. If you retry a successful request using the same client token, but one or more of the parameters are different, the retry fails with a ValidationException error.
        public let clientToken: String?
        /// The studio ID.
        public let studioId: String

        public init(clientToken: String? = DeleteStudioRequest.idempotencyToken(), studioId: String) {
            self.clientToken = clientToken
            self.studioId = studioId
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 64)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteStudioResponse: AWSDecodableShape {
        /// Information about a studio.
        public let studio: Studio?

        public init(studio: Studio? = nil) {
            self.studio = studio
        }

        private enum CodingKeys: String, CodingKey {
            case studio
        }
    }

    public struct Eula: AWSDecodableShape {
        /// The EULA content.
        public let content: String?
        /// The Unix epoch timestamp in seconds for when the resource was created.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var createdAt: Date?
        /// The EULA ID.
        public let eulaId: String?
        /// The name for the EULA.
        public let name: String?
        /// The Unix epoch timestamp in seconds for when the resource was updated.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var updatedAt: Date?

        public init(content: String? = nil, createdAt: Date? = nil, eulaId: String? = nil, name: String? = nil, updatedAt: Date? = nil) {
            self.content = content
            self.createdAt = createdAt
            self.eulaId = eulaId
            self.name = name
            self.updatedAt = updatedAt
        }

        private enum CodingKeys: String, CodingKey {
            case content
            case createdAt
            case eulaId
            case name
            case updatedAt
        }
    }

    public struct EulaAcceptance: AWSDecodableShape {
        /// The Unix epoch timestamp in seconds for when the EULA was accepted.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var acceptedAt: Date?
        /// The ID of the person who accepted the EULA.
        public let acceptedBy: String?
        /// The ID of the acceptee.
        public let accepteeId: String?
        /// The EULA acceptance ID.
        public let eulaAcceptanceId: String?
        /// The EULA ID.
        public let eulaId: String?

        public init(acceptedAt: Date? = nil, acceptedBy: String? = nil, accepteeId: String? = nil, eulaAcceptanceId: String? = nil, eulaId: String? = nil) {
            self.acceptedAt = acceptedAt
            self.acceptedBy = acceptedBy
            self.accepteeId = accepteeId
            self.eulaAcceptanceId = eulaAcceptanceId
            self.eulaId = eulaId
        }

        private enum CodingKeys: String, CodingKey {
            case acceptedAt
            case acceptedBy
            case accepteeId
            case eulaAcceptanceId
            case eulaId
        }
    }

    public struct GetEulaRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "eulaId", location: .uri(locationName: "eulaId"))
        ]

        /// The EULA ID.
        public let eulaId: String

        public init(eulaId: String) {
            self.eulaId = eulaId
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetEulaResponse: AWSDecodableShape {
        /// The EULA.
        public let eula: Eula?

        public init(eula: Eula? = nil) {
            self.eula = eula
        }

        private enum CodingKeys: String, CodingKey {
            case eula
        }
    }

    public struct GetLaunchProfileDetailsRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "launchProfileId", location: .uri(locationName: "launchProfileId")),
            AWSMemberEncoding(label: "studioId", location: .uri(locationName: "studioId"))
        ]

        /// The launch profile ID.
        public let launchProfileId: String
        /// The studio ID.
        public let studioId: String

        public init(launchProfileId: String, studioId: String) {
            self.launchProfileId = launchProfileId
            self.studioId = studioId
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetLaunchProfileDetailsResponse: AWSDecodableShape {
        /// The launch profile.
        public let launchProfile: LaunchProfile?
        /// A collection of streaming images.
        public let streamingImages: [StreamingImage]?
        /// A collection of studio component summaries.
        public let studioComponentSummaries: [StudioComponentSummary]?

        public init(launchProfile: LaunchProfile? = nil, streamingImages: [StreamingImage]? = nil, studioComponentSummaries: [StudioComponentSummary]? = nil) {
            self.launchProfile = launchProfile
            self.streamingImages = streamingImages
            self.studioComponentSummaries = studioComponentSummaries
        }

        private enum CodingKeys: String, CodingKey {
            case launchProfile
            case streamingImages
            case studioComponentSummaries
        }
    }

    public struct GetLaunchProfileInitializationRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "launchProfileId", location: .uri(locationName: "launchProfileId")),
            AWSMemberEncoding(label: "launchProfileProtocolVersions", location: .querystring(locationName: "launchProfileProtocolVersions")),
            AWSMemberEncoding(label: "launchPurpose", location: .querystring(locationName: "launchPurpose")),
            AWSMemberEncoding(label: "platform", location: .querystring(locationName: "platform")),
            AWSMemberEncoding(label: "studioId", location: .uri(locationName: "studioId"))
        ]

        /// The launch profile ID.
        public let launchProfileId: String
        /// A collection of launch profile protocol versions.
        public let launchProfileProtocolVersions: [String]
        /// The launch purpose.
        public let launchPurpose: String
        /// The platform.
        public let platform: String
        /// The studio ID.
        public let studioId: String

        public init(launchProfileId: String, launchProfileProtocolVersions: [String], launchPurpose: String, platform: String, studioId: String) {
            self.launchProfileId = launchProfileId
            self.launchProfileProtocolVersions = launchProfileProtocolVersions
            self.launchPurpose = launchPurpose
            self.platform = platform
            self.studioId = studioId
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetLaunchProfileInitializationResponse: AWSDecodableShape {
        /// The launch profile initialization.
        public let launchProfileInitialization: LaunchProfileInitialization?

        public init(launchProfileInitialization: LaunchProfileInitialization? = nil) {
            self.launchProfileInitialization = launchProfileInitialization
        }

        private enum CodingKeys: String, CodingKey {
            case launchProfileInitialization
        }
    }

    public struct GetLaunchProfileMemberRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "launchProfileId", location: .uri(locationName: "launchProfileId")),
            AWSMemberEncoding(label: "principalId", location: .uri(locationName: "principalId")),
            AWSMemberEncoding(label: "studioId", location: .uri(locationName: "studioId"))
        ]

        /// The launch profile ID.
        public let launchProfileId: String
        /// The principal ID.
        public let principalId: String
        /// The studio ID.
        public let studioId: String

        public init(launchProfileId: String, principalId: String, studioId: String) {
            self.launchProfileId = launchProfileId
            self.principalId = principalId
            self.studioId = studioId
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetLaunchProfileMemberResponse: AWSDecodableShape {
        /// The member.
        public let member: LaunchProfileMembership?

        public init(member: LaunchProfileMembership? = nil) {
            self.member = member
        }

        private enum CodingKeys: String, CodingKey {
            case member
        }
    }

    public struct GetLaunchProfileRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "launchProfileId", location: .uri(locationName: "launchProfileId")),
            AWSMemberEncoding(label: "studioId", location: .uri(locationName: "studioId"))
        ]

        /// The launch profile ID.
        public let launchProfileId: String
        /// The studio ID.
        public let studioId: String

        public init(launchProfileId: String, studioId: String) {
            self.launchProfileId = launchProfileId
            self.studioId = studioId
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetLaunchProfileResponse: AWSDecodableShape {
        /// The launch profile.
        public let launchProfile: LaunchProfile?

        public init(launchProfile: LaunchProfile? = nil) {
            self.launchProfile = launchProfile
        }

        private enum CodingKeys: String, CodingKey {
            case launchProfile
        }
    }

    public struct GetStreamingImageRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "streamingImageId", location: .uri(locationName: "streamingImageId")),
            AWSMemberEncoding(label: "studioId", location: .uri(locationName: "studioId"))
        ]

        /// The streaming image ID.
        public let streamingImageId: String
        /// The studio ID.
        public let studioId: String

        public init(streamingImageId: String, studioId: String) {
            self.streamingImageId = streamingImageId
            self.studioId = studioId
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetStreamingImageResponse: AWSDecodableShape {
        /// The streaming image.
        public let streamingImage: StreamingImage?

        public init(streamingImage: StreamingImage? = nil) {
            self.streamingImage = streamingImage
        }

        private enum CodingKeys: String, CodingKey {
            case streamingImage
        }
    }

    public struct GetStreamingSessionRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "sessionId", location: .uri(locationName: "sessionId")),
            AWSMemberEncoding(label: "studioId", location: .uri(locationName: "studioId"))
        ]

        /// The session ID.
        public let sessionId: String
        /// The studio ID.
        public let studioId: String

        public init(sessionId: String, studioId: String) {
            self.sessionId = sessionId
            self.studioId = studioId
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetStreamingSessionResponse: AWSDecodableShape {
        /// The session.
        public let session: StreamingSession?

        public init(session: StreamingSession? = nil) {
            self.session = session
        }

        private enum CodingKeys: String, CodingKey {
            case session
        }
    }

    public struct GetStreamingSessionStreamRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "sessionId", location: .uri(locationName: "sessionId")),
            AWSMemberEncoding(label: "streamId", location: .uri(locationName: "streamId")),
            AWSMemberEncoding(label: "studioId", location: .uri(locationName: "studioId"))
        ]

        /// The session ID.
        public let sessionId: String
        /// The stream ID.
        public let streamId: String
        /// The studio ID.
        public let studioId: String

        public init(sessionId: String, streamId: String, studioId: String) {
            self.sessionId = sessionId
            self.streamId = streamId
            self.studioId = studioId
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetStreamingSessionStreamResponse: AWSDecodableShape {
        /// The stream.
        public let stream: StreamingSessionStream?

        public init(stream: StreamingSessionStream? = nil) {
            self.stream = stream
        }

        private enum CodingKeys: String, CodingKey {
            case stream
        }
    }

    public struct GetStudioComponentRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "studioComponentId", location: .uri(locationName: "studioComponentId")),
            AWSMemberEncoding(label: "studioId", location: .uri(locationName: "studioId"))
        ]

        /// The studio component ID.
        public let studioComponentId: String
        /// The studio ID.
        public let studioId: String

        public init(studioComponentId: String, studioId: String) {
            self.studioComponentId = studioComponentId
            self.studioId = studioId
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetStudioComponentResponse: AWSDecodableShape {
        /// Information about the studio component.
        public let studioComponent: StudioComponent?

        public init(studioComponent: StudioComponent? = nil) {
            self.studioComponent = studioComponent
        }

        private enum CodingKeys: String, CodingKey {
            case studioComponent
        }
    }

    public struct GetStudioMemberRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "principalId", location: .uri(locationName: "principalId")),
            AWSMemberEncoding(label: "studioId", location: .uri(locationName: "studioId"))
        ]

        /// The principal ID.
        public let principalId: String
        /// The studio ID.
        public let studioId: String

        public init(principalId: String, studioId: String) {
            self.principalId = principalId
            self.studioId = studioId
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetStudioMemberResponse: AWSDecodableShape {
        /// The member.
        public let member: StudioMembership?

        public init(member: StudioMembership? = nil) {
            self.member = member
        }

        private enum CodingKeys: String, CodingKey {
            case member
        }
    }

    public struct GetStudioRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "studioId", location: .uri(locationName: "studioId"))
        ]

        /// The studio ID.
        public let studioId: String

        public init(studioId: String) {
            self.studioId = studioId
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetStudioResponse: AWSDecodableShape {
        /// Information about a studio.
        public let studio: Studio?

        public init(studio: Studio? = nil) {
            self.studio = studio
        }

        private enum CodingKeys: String, CodingKey {
            case studio
        }
    }

    public struct LaunchProfile: AWSDecodableShape {
        /// The ARN of the resource.
        public let arn: String?
        /// The Unix epoch timestamp in seconds for when the resource was created.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var createdAt: Date?
        /// The user ID of the user that created the launch profile.
        public let createdBy: String?
        /// A human-readable description of the launch profile.
        public let description: String?
        /// Unique identifiers for a collection of EC2 subnets.
        public let ec2SubnetIds: [String]?
        /// The launch profile ID.
        public let launchProfileId: String?
        /// The version number of the protocol that is used by the launch profile. The only valid version is "2021-03-31".
        public let launchProfileProtocolVersions: [String]?
        /// A friendly name for the launch profile.
        public let name: String?
        /// The current state.
        public let state: LaunchProfileState?
        /// The status code.
        public let statusCode: LaunchProfileStatusCode?
        /// The status message for the launch profile.
        public let statusMessage: String?
        /// A configuration for a streaming session.
        public let streamConfiguration: StreamConfiguration?
        /// Unique identifiers for a collection of studio components that can be used with this launch profile.
        public let studioComponentIds: [String]?
        /// A collection of labels, in the form of key:value pairs, that apply to this resource.
        public let tags: [String: String]?
        /// The Unix epoch timestamp in seconds for when the resource was updated.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var updatedAt: Date?
        /// The user ID of the user that most recently updated the resource.
        public let updatedBy: String?

        public init(arn: String? = nil, createdAt: Date? = nil, createdBy: String? = nil, description: String? = nil, ec2SubnetIds: [String]? = nil, launchProfileId: String? = nil, launchProfileProtocolVersions: [String]? = nil, name: String? = nil, state: LaunchProfileState? = nil, statusCode: LaunchProfileStatusCode? = nil, statusMessage: String? = nil, streamConfiguration: StreamConfiguration? = nil, studioComponentIds: [String]? = nil, tags: [String: String]? = nil, updatedAt: Date? = nil, updatedBy: String? = nil) {
            self.arn = arn
            self.createdAt = createdAt
            self.createdBy = createdBy
            self.description = description
            self.ec2SubnetIds = ec2SubnetIds
            self.launchProfileId = launchProfileId
            self.launchProfileProtocolVersions = launchProfileProtocolVersions
            self.name = name
            self.state = state
            self.statusCode = statusCode
            self.statusMessage = statusMessage
            self.streamConfiguration = streamConfiguration
            self.studioComponentIds = studioComponentIds
            self.tags = tags
            self.updatedAt = updatedAt
            self.updatedBy = updatedBy
        }

        private enum CodingKeys: String, CodingKey {
            case arn
            case createdAt
            case createdBy
            case description
            case ec2SubnetIds
            case launchProfileId
            case launchProfileProtocolVersions
            case name
            case state
            case statusCode
            case statusMessage
            case streamConfiguration
            case studioComponentIds
            case tags
            case updatedAt
            case updatedBy
        }
    }

    public struct LaunchProfileInitialization: AWSDecodableShape {
        /// A LaunchProfileInitializationActiveDirectory resource.
        public let activeDirectory: LaunchProfileInitializationActiveDirectory?
        /// The EC2 security groups that control access to the studio component.
        public let ec2SecurityGroupIds: [String]?
        /// The launch profile ID.
        public let launchProfileId: String?
        /// The version number of the protocol that is used by the launch profile. The only valid version is "2021-03-31".
        public let launchProfileProtocolVersion: String?
        /// The launch purpose.
        public let launchPurpose: String?
        /// The name for the launch profile.
        public let name: String?
        /// The platform of the launch platform, either WINDOWS or LINUX.
        public let platform: LaunchProfilePlatform?
        /// The system initializtion scripts.
        public let systemInitializationScripts: [LaunchProfileInitializationScript]?
        /// The user initializtion scripts.
        public let userInitializationScripts: [LaunchProfileInitializationScript]?

        public init(activeDirectory: LaunchProfileInitializationActiveDirectory? = nil, ec2SecurityGroupIds: [String]? = nil, launchProfileId: String? = nil, launchProfileProtocolVersion: String? = nil, launchPurpose: String? = nil, name: String? = nil, platform: LaunchProfilePlatform? = nil, systemInitializationScripts: [LaunchProfileInitializationScript]? = nil, userInitializationScripts: [LaunchProfileInitializationScript]? = nil) {
            self.activeDirectory = activeDirectory
            self.ec2SecurityGroupIds = ec2SecurityGroupIds
            self.launchProfileId = launchProfileId
            self.launchProfileProtocolVersion = launchProfileProtocolVersion
            self.launchPurpose = launchPurpose
            self.name = name
            self.platform = platform
            self.systemInitializationScripts = systemInitializationScripts
            self.userInitializationScripts = userInitializationScripts
        }

        private enum CodingKeys: String, CodingKey {
            case activeDirectory
            case ec2SecurityGroupIds
            case launchProfileId
            case launchProfileProtocolVersion
            case launchPurpose
            case name
            case platform
            case systemInitializationScripts
            case userInitializationScripts
        }
    }

    public struct LaunchProfileInitializationActiveDirectory: AWSDecodableShape {
        /// A collection of custom attributes for an Active Directory computer.
        public let computerAttributes: [ActiveDirectoryComputerAttribute]?
        /// The directory ID of the Directory Service for Microsoft Active Directory to access using this launch profile.
        public let directoryId: String?
        /// The directory name.
        public let directoryName: String?
        /// The DNS IP address.
        public let dnsIpAddresses: [String]?
        /// The name for the organizational unit distinguished name.
        public let organizationalUnitDistinguishedName: String?
        /// The unique identifier for a studio component resource.
        public let studioComponentId: String?
        /// The name for the studio component.
        public let studioComponentName: String?

        public init(computerAttributes: [ActiveDirectoryComputerAttribute]? = nil, directoryId: String? = nil, directoryName: String? = nil, dnsIpAddresses: [String]? = nil, organizationalUnitDistinguishedName: String? = nil, studioComponentId: String? = nil, studioComponentName: String? = nil) {
            self.computerAttributes = computerAttributes
            self.directoryId = directoryId
            self.directoryName = directoryName
            self.dnsIpAddresses = dnsIpAddresses
            self.organizationalUnitDistinguishedName = organizationalUnitDistinguishedName
            self.studioComponentId = studioComponentId
            self.studioComponentName = studioComponentName
        }

        private enum CodingKeys: String, CodingKey {
            case computerAttributes
            case directoryId
            case directoryName
            case dnsIpAddresses
            case organizationalUnitDistinguishedName
            case studioComponentId
            case studioComponentName
        }
    }

    public struct LaunchProfileInitializationScript: AWSDecodableShape {
        /// The initialization script.
        public let script: String?
        /// The unique identifier for a studio component resource.
        public let studioComponentId: String?
        /// The name for the studio component.
        public let studioComponentName: String?

        public init(script: String? = nil, studioComponentId: String? = nil, studioComponentName: String? = nil) {
            self.script = script
            self.studioComponentId = studioComponentId
            self.studioComponentName = studioComponentName
        }

        private enum CodingKeys: String, CodingKey {
            case script
            case studioComponentId
            case studioComponentName
        }
    }

    public struct LaunchProfileMembership: AWSDecodableShape {
        /// The ID of the identity store.
        public let identityStoreId: String?
        /// The persona.
        public let persona: LaunchProfilePersona?
        /// The principal ID.
        public let principalId: String?

        public init(identityStoreId: String? = nil, persona: LaunchProfilePersona? = nil, principalId: String? = nil) {
            self.identityStoreId = identityStoreId
            self.persona = persona
            self.principalId = principalId
        }

        private enum CodingKeys: String, CodingKey {
            case identityStoreId
            case persona
            case principalId
        }
    }

    public struct LicenseServiceConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The endpoint of the license service that is accessed by the studio component resource.
        public let endpoint: String?

        public init(endpoint: String? = nil) {
            self.endpoint = endpoint
        }

        private enum CodingKeys: String, CodingKey {
            case endpoint
        }
    }

    public struct ListEulaAcceptancesRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "eulaIds", location: .querystring(locationName: "eulaIds")),
            AWSMemberEncoding(label: "nextToken", location: .querystring(locationName: "nextToken")),
            AWSMemberEncoding(label: "studioId", location: .uri(locationName: "studioId"))
        ]

        /// A collection of EULA IDs.
        public let eulaIds: [String]?
        /// The token for the next set of results, or null if there are no more results.
        public let nextToken: String?
        /// The studio ID.
        public let studioId: String

        public init(eulaIds: [String]? = nil, nextToken: String? = nil, studioId: String) {
            self.eulaIds = eulaIds
            self.nextToken = nextToken
            self.studioId = studioId
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListEulaAcceptancesResponse: AWSDecodableShape {
        /// A collection of EULA acceptances.
        public let eulaAcceptances: [EulaAcceptance]?
        /// The token for the next set of results, or null if there are no more results.
        public let nextToken: String?

        public init(eulaAcceptances: [EulaAcceptance]? = nil, nextToken: String? = nil) {
            self.eulaAcceptances = eulaAcceptances
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case eulaAcceptances
            case nextToken
        }
    }

    public struct ListEulasRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "eulaIds", location: .querystring(locationName: "eulaIds")),
            AWSMemberEncoding(label: "nextToken", location: .querystring(locationName: "nextToken"))
        ]

        /// A collection of EULA IDs.
        public let eulaIds: [String]?
        /// The token for the next set of results, or null if there are no more results.
        public let nextToken: String?

        public init(eulaIds: [String]? = nil, nextToken: String? = nil) {
            self.eulaIds = eulaIds
            self.nextToken = nextToken
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListEulasResponse: AWSDecodableShape {
        /// A collection of EULA resources.
        public let eulas: [Eula]?
        /// The token for the next set of results, or null if there are no more results.
        public let nextToken: String?

        public init(eulas: [Eula]? = nil, nextToken: String? = nil) {
            self.eulas = eulas
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case eulas
            case nextToken
        }
    }

    public struct ListLaunchProfileMembersRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "launchProfileId", location: .uri(locationName: "launchProfileId")),
            AWSMemberEncoding(label: "maxResults", location: .querystring(locationName: "maxResults")),
            AWSMemberEncoding(label: "nextToken", location: .querystring(locationName: "nextToken")),
            AWSMemberEncoding(label: "studioId", location: .uri(locationName: "studioId"))
        ]

        /// The launch profile ID.
        public let launchProfileId: String
        /// The maximum number of results to be returned per request.
        public let maxResults: Int?
        /// The token for the next set of results, or null if there are no more results.
        public let nextToken: String?
        /// The studio ID.
        public let studioId: String

        public init(launchProfileId: String, maxResults: Int? = nil, nextToken: String? = nil, studioId: String) {
            self.launchProfileId = launchProfileId
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.studioId = studioId
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListLaunchProfileMembersResponse: AWSDecodableShape {
        /// A list of members.
        public let members: [LaunchProfileMembership]?
        /// The token for the next set of results, or null if there are no more results.
        public let nextToken: String?

        public init(members: [LaunchProfileMembership]? = nil, nextToken: String? = nil) {
            self.members = members
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case members
            case nextToken
        }
    }

    public struct ListLaunchProfilesRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "maxResults", location: .querystring(locationName: "maxResults")),
            AWSMemberEncoding(label: "nextToken", location: .querystring(locationName: "nextToken")),
            AWSMemberEncoding(label: "principalId", location: .querystring(locationName: "principalId")),
            AWSMemberEncoding(label: "states", location: .querystring(locationName: "states")),
            AWSMemberEncoding(label: "studioId", location: .uri(locationName: "studioId"))
        ]

        /// The maximum number of results to be returned per request.
        public let maxResults: Int?
        /// The token for the next set of results, or null if there are no more results.
        public let nextToken: String?
        /// The principal ID.
        public let principalId: String?
        /// A list of states.
        public let states: [String]?
        /// The studio ID.
        public let studioId: String

        public init(maxResults: Int? = nil, nextToken: String? = nil, principalId: String? = nil, states: [String]? = nil, studioId: String) {
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.principalId = principalId
            self.states = states
            self.studioId = studioId
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListLaunchProfilesResponse: AWSDecodableShape {
        /// A collection of launch profiles.
        public let launchProfiles: [LaunchProfile]?
        /// The token for the next set of results, or null if there are no more results.
        public let nextToken: String?

        public init(launchProfiles: [LaunchProfile]? = nil, nextToken: String? = nil) {
            self.launchProfiles = launchProfiles
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case launchProfiles
            case nextToken
        }
    }

    public struct ListStreamingImagesRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "nextToken", location: .querystring(locationName: "nextToken")),
            AWSMemberEncoding(label: "owner", location: .querystring(locationName: "owner")),
            AWSMemberEncoding(label: "studioId", location: .uri(locationName: "studioId"))
        ]

        /// The token for the next set of results, or null if there are no more results.
        public let nextToken: String?
        /// The owner.
        public let owner: String?
        /// The studio ID.
        public let studioId: String

        public init(nextToken: String? = nil, owner: String? = nil, studioId: String) {
            self.nextToken = nextToken
            self.owner = owner
            self.studioId = studioId
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListStreamingImagesResponse: AWSDecodableShape {
        /// The token for the next set of results, or null if there are no more results.
        public let nextToken: String?
        /// A collection of streaming images.
        public let streamingImages: [StreamingImage]?

        public init(nextToken: String? = nil, streamingImages: [StreamingImage]? = nil) {
            self.nextToken = nextToken
            self.streamingImages = streamingImages
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken
            case streamingImages
        }
    }

    public struct ListStreamingSessionsRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "createdBy", location: .querystring(locationName: "createdBy")),
            AWSMemberEncoding(label: "nextToken", location: .querystring(locationName: "nextToken")),
            AWSMemberEncoding(label: "ownedBy", location: .querystring(locationName: "ownedBy")),
            AWSMemberEncoding(label: "sessionIds", location: .querystring(locationName: "sessionIds")),
            AWSMemberEncoding(label: "studioId", location: .uri(locationName: "studioId"))
        ]

        /// The user ID of the user that created the streaming session.
        public let createdBy: String?
        /// The token for the next set of results, or null if there are no more results.
        public let nextToken: String?
        /// The user ID of the user that owns the streaming session.
        public let ownedBy: String?
        /// A collection of session IDs.
        public let sessionIds: String?
        /// The studio ID.
        public let studioId: String

        public init(createdBy: String? = nil, nextToken: String? = nil, ownedBy: String? = nil, sessionIds: String? = nil, studioId: String) {
            self.createdBy = createdBy
            self.nextToken = nextToken
            self.ownedBy = ownedBy
            self.sessionIds = sessionIds
            self.studioId = studioId
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListStreamingSessionsResponse: AWSDecodableShape {
        /// The token for the next set of results, or null if there are no more results.
        public let nextToken: String?
        /// A collection of streaming sessions.
        public let sessions: [StreamingSession]?

        public init(nextToken: String? = nil, sessions: [StreamingSession]? = nil) {
            self.nextToken = nextToken
            self.sessions = sessions
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken
            case sessions
        }
    }

    public struct ListStudioComponentsRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "maxResults", location: .querystring(locationName: "maxResults")),
            AWSMemberEncoding(label: "nextToken", location: .querystring(locationName: "nextToken")),
            AWSMemberEncoding(label: "states", location: .querystring(locationName: "states")),
            AWSMemberEncoding(label: "studioId", location: .uri(locationName: "studioId")),
            AWSMemberEncoding(label: "types", location: .querystring(locationName: "types"))
        ]

        /// The maximum number of results to be returned per request.
        public let maxResults: Int?
        /// The token for the next set of results, or null if there are no more results.
        public let nextToken: String?
        /// A list of states.
        public let states: [String]?
        /// The studio ID.
        public let studioId: String
        /// The types.
        public let types: [String]?

        public init(maxResults: Int? = nil, nextToken: String? = nil, states: [String]? = nil, studioId: String, types: [String]? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.states = states
            self.studioId = studioId
            self.types = types
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListStudioComponentsResponse: AWSDecodableShape {
        /// The token for the next set of results, or null if there are no more results.
        public let nextToken: String?
        /// A collection of studio components.
        public let studioComponents: [StudioComponent]?

        public init(nextToken: String? = nil, studioComponents: [StudioComponent]? = nil) {
            self.nextToken = nextToken
            self.studioComponents = studioComponents
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken
            case studioComponents
        }
    }

    public struct ListStudioMembersRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "maxResults", location: .querystring(locationName: "maxResults")),
            AWSMemberEncoding(label: "nextToken", location: .querystring(locationName: "nextToken")),
            AWSMemberEncoding(label: "studioId", location: .uri(locationName: "studioId"))
        ]

        /// The maximum number of results to be returned per request.
        public let maxResults: Int?
        /// The token for the next set of results, or null if there are no more results.
        public let nextToken: String?
        /// The studio ID.
        public let studioId: String

        public init(maxResults: Int? = nil, nextToken: String? = nil, studioId: String) {
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.studioId = studioId
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListStudioMembersResponse: AWSDecodableShape {
        /// A list of members.
        public let members: [StudioMembership]?
        /// The token for the next set of results, or null if there are no more results.
        public let nextToken: String?

        public init(members: [StudioMembership]? = nil, nextToken: String? = nil) {
            self.members = members
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case members
            case nextToken
        }
    }

    public struct ListStudiosRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "nextToken", location: .querystring(locationName: "nextToken"))
        ]

        /// The token for the next set of results, or null if there are no more results.
        public let nextToken: String?

        public init(nextToken: String? = nil) {
            self.nextToken = nextToken
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListStudiosResponse: AWSDecodableShape {
        /// The token for the next set of results, or null if there are no more results.
        public let nextToken: String?
        /// A collection of studios.
        public let studios: [Studio]?

        public init(nextToken: String? = nil, studios: [Studio]? = nil) {
            self.nextToken = nextToken
            self.studios = studios
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken
            case studios
        }
    }

    public struct ListTagsForResourceRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "resourceArn", location: .uri(locationName: "resourceArn"))
        ]

        /// The ARN of the target resource for tagging operations.
        public let resourceArn: String

        public init(resourceArn: String) {
            self.resourceArn = resourceArn
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListTagsForResourceResponse: AWSDecodableShape {
        /// A collection of labels, in the form of key:value pairs, that apply to this resource.
        public let tags: [String: String]?

        public init(tags: [String: String]? = nil) {
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case tags
        }
    }

    public struct NewLaunchProfileMember: AWSEncodableShape {
        /// The persona.
        public let persona: LaunchProfilePersona
        /// The principal ID.
        public let principalId: String

        public init(persona: LaunchProfilePersona, principalId: String) {
            self.persona = persona
            self.principalId = principalId
        }

        private enum CodingKeys: String, CodingKey {
            case persona
            case principalId
        }
    }

    public struct NewStudioMember: AWSEncodableShape {
        /// The persona.
        public let persona: StudioPersona
        /// The principal ID.
        public let principalId: String

        public init(persona: StudioPersona, principalId: String) {
            self.persona = persona
            self.principalId = principalId
        }

        private enum CodingKeys: String, CodingKey {
            case persona
            case principalId
        }
    }

    public struct PutLaunchProfileMembersRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "clientToken", location: .header(locationName: "X-Amz-Client-Token")),
            AWSMemberEncoding(label: "launchProfileId", location: .uri(locationName: "launchProfileId")),
            AWSMemberEncoding(label: "studioId", location: .uri(locationName: "studioId"))
        ]

        /// To make an idempotent API request using one of these actions, specify a client token in the request. You should not reuse the same client token for other API requests. If you retry a request that completed successfully using the same client token and the same parameters, the retry succeeds without performing any further actions. If you retry a successful request using the same client token, but one or more of the parameters are different, the retry fails with a ValidationException error.
        public let clientToken: String?
        /// The ID of the identity store.
        public let identityStoreId: String
        /// The launch profile ID.
        public let launchProfileId: String
        /// A list of members.
        public let members: [NewLaunchProfileMember]
        /// The studio ID.
        public let studioId: String

        public init(clientToken: String? = PutLaunchProfileMembersRequest.idempotencyToken(), identityStoreId: String, launchProfileId: String, members: [NewLaunchProfileMember], studioId: String) {
            self.clientToken = clientToken
            self.identityStoreId = identityStoreId
            self.launchProfileId = launchProfileId
            self.members = members
            self.studioId = studioId
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 64)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.validate(self.members, name: "members", parent: name, max: 20)
            try self.validate(self.members, name: "members", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case identityStoreId
            case members
        }
    }

    public struct PutLaunchProfileMembersResponse: AWSDecodableShape {
        public init() {}
    }

    public struct PutStudioMembersRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "clientToken", location: .header(locationName: "X-Amz-Client-Token")),
            AWSMemberEncoding(label: "studioId", location: .uri(locationName: "studioId"))
        ]

        /// To make an idempotent API request using one of these actions, specify a client token in the request. You should not reuse the same client token for other API requests. If you retry a request that completed successfully using the same client token and the same parameters, the retry succeeds without performing any further actions. If you retry a successful request using the same client token, but one or more of the parameters are different, the retry fails with a ValidationException error.
        public let clientToken: String?
        /// The ID of the identity store.
        public let identityStoreId: String
        /// A list of members.
        public let members: [NewStudioMember]
        /// The studio ID.
        public let studioId: String

        public init(clientToken: String? = PutStudioMembersRequest.idempotencyToken(), identityStoreId: String, members: [NewStudioMember], studioId: String) {
            self.clientToken = clientToken
            self.identityStoreId = identityStoreId
            self.members = members
            self.studioId = studioId
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 64)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.validate(self.members, name: "members", parent: name, max: 20)
            try self.validate(self.members, name: "members", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case identityStoreId
            case members
        }
    }

    public struct PutStudioMembersResponse: AWSDecodableShape {
        public init() {}
    }

    public struct ScriptParameterKeyValue: AWSEncodableShape & AWSDecodableShape {
        /// A script parameter key.
        public let key: String?
        /// A script parameter value.
        public let value: String?

        public init(key: String? = nil, value: String? = nil) {
            self.key = key
            self.value = value
        }

        public func validate(name: String) throws {
            try self.validate(self.key, name: "key", parent: name, max: 64)
            try self.validate(self.key, name: "key", parent: name, min: 1)
            try self.validate(self.key, name: "key", parent: name, pattern: "^[a-zA-Z_][a-zA-Z0-9_]+$")
            try self.validate(self.value, name: "value", parent: name, max: 256)
            try self.validate(self.value, name: "value", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case key
            case value
        }
    }

    public struct SharedFileSystemConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The endpoint of the shared file system that is accessed by the studio component resource.
        public let endpoint: String?
        /// The unique identifier for a file system.
        public let fileSystemId: String?
        /// The mount location for a shared file system on a Linux virtual workstation.
        public let linuxMountPoint: String?
        /// The name of the file share.
        public let shareName: String?
        /// The mount location for a shared file system on a Windows virtual workstation.
        public let windowsMountDrive: String?

        public init(endpoint: String? = nil, fileSystemId: String? = nil, linuxMountPoint: String? = nil, shareName: String? = nil, windowsMountDrive: String? = nil) {
            self.endpoint = endpoint
            self.fileSystemId = fileSystemId
            self.linuxMountPoint = linuxMountPoint
            self.shareName = shareName
            self.windowsMountDrive = windowsMountDrive
        }

        public func validate(name: String) throws {
            try self.validate(self.linuxMountPoint, name: "linuxMountPoint", parent: name, max: 128)
            try self.validate(self.linuxMountPoint, name: "linuxMountPoint", parent: name, pattern: "^(/?|(\\$HOME)?(/[^/\\n\\s\\\\]+)*)$")
            try self.validate(self.windowsMountDrive, name: "windowsMountDrive", parent: name, pattern: "^[A-Z]$")
        }

        private enum CodingKeys: String, CodingKey {
            case endpoint
            case fileSystemId
            case linuxMountPoint
            case shareName
            case windowsMountDrive
        }
    }

    public struct StartStudioSSOConfigurationRepairRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "clientToken", location: .header(locationName: "X-Amz-Client-Token")),
            AWSMemberEncoding(label: "studioId", location: .uri(locationName: "studioId"))
        ]

        /// To make an idempotent API request using one of these actions, specify a client token in the request. You should not reuse the same client token for other API requests. If you retry a request that completed successfully using the same client token and the same parameters, the retry succeeds without performing any further actions. If you retry a successful request using the same client token, but one or more of the parameters are different, the retry fails with a ValidationException error.
        public let clientToken: String?
        /// The studio ID.
        public let studioId: String

        public init(clientToken: String? = StartStudioSSOConfigurationRepairRequest.idempotencyToken(), studioId: String) {
            self.clientToken = clientToken
            self.studioId = studioId
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 64)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct StartStudioSSOConfigurationRepairResponse: AWSDecodableShape {
        /// Information about a studio.
        public let studio: Studio?

        public init(studio: Studio? = nil) {
            self.studio = studio
        }

        private enum CodingKeys: String, CodingKey {
            case studio
        }
    }

    public struct StreamConfiguration: AWSDecodableShape {
        /// Enable or disable the use of the system clipboard to copy and paste between the streaming session and streaming client.
        public let clipboardMode: StreamingClipboardMode?
        /// The EC2 instance types that users can select from when launching a streaming session with this launch profile.
        public let ec2InstanceTypes: [StreamingInstanceType]?
        /// The length of time, in minutes, that a streaming session can run. After this point, Nimble Studio automatically terminates the session.
        public let maxSessionLengthInMinutes: Int?
        /// The streaming images that users can select from when launching a streaming session with this launch profile.
        public let streamingImageIds: [String]?

        public init(clipboardMode: StreamingClipboardMode? = nil, ec2InstanceTypes: [StreamingInstanceType]? = nil, maxSessionLengthInMinutes: Int? = nil, streamingImageIds: [String]? = nil) {
            self.clipboardMode = clipboardMode
            self.ec2InstanceTypes = ec2InstanceTypes
            self.maxSessionLengthInMinutes = maxSessionLengthInMinutes
            self.streamingImageIds = streamingImageIds
        }

        private enum CodingKeys: String, CodingKey {
            case clipboardMode
            case ec2InstanceTypes
            case maxSessionLengthInMinutes
            case streamingImageIds
        }
    }

    public struct StreamConfigurationCreate: AWSEncodableShape {
        /// Enable or disable the use of the system clipboard to copy and paste between the streaming session and streaming client.
        public let clipboardMode: StreamingClipboardMode
        /// The EC2 instance types that users can select from when launching a streaming session with this launch profile.
        public let ec2InstanceTypes: [StreamingInstanceType]
        /// The length of time, in minutes, that a streaming session can run. After this point, Nimble Studio automatically terminates the session.
        public let maxSessionLengthInMinutes: Int?
        /// The streaming images that users can select from when launching a streaming session with this launch profile.
        public let streamingImageIds: [String]

        public init(clipboardMode: StreamingClipboardMode, ec2InstanceTypes: [StreamingInstanceType], maxSessionLengthInMinutes: Int? = nil, streamingImageIds: [String]) {
            self.clipboardMode = clipboardMode
            self.ec2InstanceTypes = ec2InstanceTypes
            self.maxSessionLengthInMinutes = maxSessionLengthInMinutes
            self.streamingImageIds = streamingImageIds
        }

        public func validate(name: String) throws {
            try self.validate(self.ec2InstanceTypes, name: "ec2InstanceTypes", parent: name, max: 30)
            try self.validate(self.ec2InstanceTypes, name: "ec2InstanceTypes", parent: name, min: 1)
            try self.validate(self.maxSessionLengthInMinutes, name: "maxSessionLengthInMinutes", parent: name, max: 690)
            try self.validate(self.maxSessionLengthInMinutes, name: "maxSessionLengthInMinutes", parent: name, min: 1)
            try self.streamingImageIds.forEach {
                try validate($0, name: "streamingImageIds[]", parent: name, max: 22)
                try validate($0, name: "streamingImageIds[]", parent: name, pattern: "^[a-zA-Z0-9-_]*$")
            }
            try self.validate(self.streamingImageIds, name: "streamingImageIds", parent: name, max: 20)
        }

        private enum CodingKeys: String, CodingKey {
            case clipboardMode
            case ec2InstanceTypes
            case maxSessionLengthInMinutes
            case streamingImageIds
        }
    }

    public struct StreamingImage: AWSDecodableShape {
        /// The ARN of the resource.
        public let arn: String?
        /// A human-readable description of the streaming image.
        public let description: String?
        /// The ID of an EC2 machine image with which to create the streaming image.
        public let ec2ImageId: String?
        /// The encryption configuration.
        public let encryptionConfiguration: StreamingImageEncryptionConfiguration?
        /// The list of EULAs that must be accepted before a Streaming Session can be started using this streaming image.
        public let eulaIds: [String]?
        /// A friendly name for a streaming image resource.
        public let name: String?
        /// The owner of the streaming image, either the studioId that contains the streaming image, or 'amazon' for images that are provided by Amazon Nimble Studio.
        public let owner: String?
        /// The platform of the streaming image, either WINDOWS or LINUX.
        public let platform: String?
        /// The current state.
        public let state: StreamingImageState?
        /// The status code.
        public let statusCode: StreamingImageStatusCode?
        /// The status message for the streaming image.
        public let statusMessage: String?
        /// The ID of the streaming image.
        public let streamingImageId: String?
        /// A collection of labels, in the form of key:value pairs, that apply to this resource.
        public let tags: [String: String]?

        public init(arn: String? = nil, description: String? = nil, ec2ImageId: String? = nil, encryptionConfiguration: StreamingImageEncryptionConfiguration? = nil, eulaIds: [String]? = nil, name: String? = nil, owner: String? = nil, platform: String? = nil, state: StreamingImageState? = nil, statusCode: StreamingImageStatusCode? = nil, statusMessage: String? = nil, streamingImageId: String? = nil, tags: [String: String]? = nil) {
            self.arn = arn
            self.description = description
            self.ec2ImageId = ec2ImageId
            self.encryptionConfiguration = encryptionConfiguration
            self.eulaIds = eulaIds
            self.name = name
            self.owner = owner
            self.platform = platform
            self.state = state
            self.statusCode = statusCode
            self.statusMessage = statusMessage
            self.streamingImageId = streamingImageId
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case arn
            case description
            case ec2ImageId
            case encryptionConfiguration
            case eulaIds
            case name
            case owner
            case platform
            case state
            case statusCode
            case statusMessage
            case streamingImageId
            case tags
        }
    }

    public struct StreamingImageEncryptionConfiguration: AWSDecodableShape {
        /// The ARN for a KMS key that is used to encrypt studio data.
        public let keyArn: String?
        /// The type of KMS key that is used to encrypt studio data.
        public let keyType: StreamingImageEncryptionConfigurationKeyType

        public init(keyArn: String? = nil, keyType: StreamingImageEncryptionConfigurationKeyType) {
            self.keyArn = keyArn
            self.keyType = keyType
        }

        private enum CodingKeys: String, CodingKey {
            case keyArn
            case keyType
        }
    }

    public struct StreamingSession: AWSDecodableShape {
        /// The ARN of the resource.
        public let arn: String?
        /// The Unix epoch timestamp in seconds for when the resource was created.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var createdAt: Date?
        /// The user ID of the user that created the streaming session.
        public let createdBy: String?
        /// The EC2 Instance type used for the streaming session.
        public let ec2InstanceType: String?
        /// The ID of the launch profile used to control access from the streaming session.
        public let launchProfileId: String?
        /// The user ID of the user that owns the streaming session.
        public let ownedBy: String?
        /// The session ID.
        public let sessionId: String?
        /// The current state.
        public let state: StreamingSessionState?
        /// The status code.
        public let statusCode: StreamingSessionStatusCode?
        /// The status message for the streaming session.
        public let statusMessage: String?
        /// The ID of the streaming image.
        public let streamingImageId: String?
        /// A collection of labels, in the form of key:value pairs, that apply to this resource.
        public let tags: [String: String]?
        /// The time the streaming session will automatically terminate if not terminated by the user.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var terminateAt: Date?
        /// The Unix epoch timestamp in seconds for when the resource was updated.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var updatedAt: Date?
        /// The user ID of the user that most recently updated the resource.
        public let updatedBy: String?

        public init(arn: String? = nil, createdAt: Date? = nil, createdBy: String? = nil, ec2InstanceType: String? = nil, launchProfileId: String? = nil, ownedBy: String? = nil, sessionId: String? = nil, state: StreamingSessionState? = nil, statusCode: StreamingSessionStatusCode? = nil, statusMessage: String? = nil, streamingImageId: String? = nil, tags: [String: String]? = nil, terminateAt: Date? = nil, updatedAt: Date? = nil, updatedBy: String? = nil) {
            self.arn = arn
            self.createdAt = createdAt
            self.createdBy = createdBy
            self.ec2InstanceType = ec2InstanceType
            self.launchProfileId = launchProfileId
            self.ownedBy = ownedBy
            self.sessionId = sessionId
            self.state = state
            self.statusCode = statusCode
            self.statusMessage = statusMessage
            self.streamingImageId = streamingImageId
            self.tags = tags
            self.terminateAt = terminateAt
            self.updatedAt = updatedAt
            self.updatedBy = updatedBy
        }

        private enum CodingKeys: String, CodingKey {
            case arn
            case createdAt
            case createdBy
            case ec2InstanceType
            case launchProfileId
            case ownedBy
            case sessionId
            case state
            case statusCode
            case statusMessage
            case streamingImageId
            case tags
            case terminateAt
            case updatedAt
            case updatedBy
        }
    }

    public struct StreamingSessionStream: AWSDecodableShape {
        /// The Unix epoch timestamp in seconds for when the resource was created.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var createdAt: Date?
        /// The user ID of the user that created the streaming session stream.
        public let createdBy: String?
        /// The Unix epoch timestamp in seconds for when the resource expires.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var expiresAt: Date?
        /// The user ID of the user that owns the streaming session.
        public let ownedBy: String?
        /// The current state.
        public let state: StreamingSessionStreamState?
        /// The streaming session stream status code.
        public let statusCode: StreamingSessionStreamStatusCode?
        /// The stream ID.
        public let streamId: String?
        /// The URL to connect to this stream using the DCV client.
        public let url: String?

        public init(createdAt: Date? = nil, createdBy: String? = nil, expiresAt: Date? = nil, ownedBy: String? = nil, state: StreamingSessionStreamState? = nil, statusCode: StreamingSessionStreamStatusCode? = nil, streamId: String? = nil, url: String? = nil) {
            self.createdAt = createdAt
            self.createdBy = createdBy
            self.expiresAt = expiresAt
            self.ownedBy = ownedBy
            self.state = state
            self.statusCode = statusCode
            self.streamId = streamId
            self.url = url
        }

        private enum CodingKeys: String, CodingKey {
            case createdAt
            case createdBy
            case expiresAt
            case ownedBy
            case state
            case statusCode
            case streamId
            case url
        }
    }

    public struct Studio: AWSDecodableShape {
        /// The IAM role that studio admins assume when logging in to the Nimble Studio portal.
        public let adminRoleArn: String?
        /// The Amazon Resource Name (ARN) that is assigned to a studio resource and uniquely identifies it. ARNs are unique across all Regions.
        public let arn: String?
        /// The Unix epoch timestamp in seconds for when the resource was created.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var createdAt: Date?
        /// A friendly name for the studio.
        public let displayName: String?
        /// The Amazon Web Services Region where the studio resource is located.
        public let homeRegion: String?
        /// The Amazon Web Services SSO application client ID used to integrate with Amazon Web Services SSO to enable Amazon Web Services SSO users to log in to Nimble portal.
        public let ssoClientId: String?
        /// The current state of the studio resource.
        public let state: StudioState?
        /// Status codes that provide additional detail on the studio state.
        public let statusCode: StudioStatusCode?
        /// Additional detail on the studio state.
        public let statusMessage: String?
        /// Configuration of the encryption method that is used for the studio.
        public let studioEncryptionConfiguration: StudioEncryptionConfiguration?
        /// The unique identifier for a studio resource. In Nimble Studio, all other resources are contained in a studio resource.
        public let studioId: String?
        /// The name of the studio, as included in the URL when accessing it in the Nimble Studio portal.
        public let studioName: String?
        /// The address of the web page for the studio.
        public let studioUrl: String?
        /// A collection of labels, in the form of key:value pairs, that apply to this resource.
        public let tags: [String: String]?
        /// The Unix epoch timestamp in seconds for when the resource was updated.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var updatedAt: Date?
        /// The IAM role that studio users assume when logging in to the Nimble Studio portal.
        public let userRoleArn: String?

        public init(adminRoleArn: String? = nil, arn: String? = nil, createdAt: Date? = nil, displayName: String? = nil, homeRegion: String? = nil, ssoClientId: String? = nil, state: StudioState? = nil, statusCode: StudioStatusCode? = nil, statusMessage: String? = nil, studioEncryptionConfiguration: StudioEncryptionConfiguration? = nil, studioId: String? = nil, studioName: String? = nil, studioUrl: String? = nil, tags: [String: String]? = nil, updatedAt: Date? = nil, userRoleArn: String? = nil) {
            self.adminRoleArn = adminRoleArn
            self.arn = arn
            self.createdAt = createdAt
            self.displayName = displayName
            self.homeRegion = homeRegion
            self.ssoClientId = ssoClientId
            self.state = state
            self.statusCode = statusCode
            self.statusMessage = statusMessage
            self.studioEncryptionConfiguration = studioEncryptionConfiguration
            self.studioId = studioId
            self.studioName = studioName
            self.studioUrl = studioUrl
            self.tags = tags
            self.updatedAt = updatedAt
            self.userRoleArn = userRoleArn
        }

        private enum CodingKeys: String, CodingKey {
            case adminRoleArn
            case arn
            case createdAt
            case displayName
            case homeRegion
            case ssoClientId
            case state
            case statusCode
            case statusMessage
            case studioEncryptionConfiguration
            case studioId
            case studioName
            case studioUrl
            case tags
            case updatedAt
            case userRoleArn
        }
    }

    public struct StudioComponent: AWSDecodableShape {
        /// The ARN of the resource.
        public let arn: String?
        /// The configuration of the studio component, based on component type.
        public let configuration: StudioComponentConfiguration?
        /// The Unix epoch timestamp in seconds for when the resource was created.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var createdAt: Date?
        /// The user ID of the user that created the studio component.
        public let createdBy: String?
        /// A human-readable description for the studio component resource.
        public let description: String?
        /// The EC2 security groups that control access to the studio component.
        public let ec2SecurityGroupIds: [String]?
        /// Initialization scripts for studio components.
        public let initializationScripts: [StudioComponentInitializationScript]?
        /// A friendly name for the studio component resource.
        public let name: String?
        /// Parameters for the studio component scripts.
        public let scriptParameters: [ScriptParameterKeyValue]?
        /// The current state.
        public let state: StudioComponentState?
        /// The status code.
        public let statusCode: StudioComponentStatusCode?
        /// The status message for the studio component.
        public let statusMessage: String?
        /// The unique identifier for a studio component resource.
        public let studioComponentId: String?
        /// The specific subtype of a studio component.
        public let subtype: StudioComponentSubtype?
        /// A collection of labels, in the form of key:value pairs, that apply to this resource.
        public let tags: [String: String]?
        /// The type of the studio component.
        public let type: StudioComponentType?
        /// The Unix epoch timestamp in seconds for when the resource was updated.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var updatedAt: Date?
        /// The user ID of the user that most recently updated the resource.
        public let updatedBy: String?

        public init(arn: String? = nil, configuration: StudioComponentConfiguration? = nil, createdAt: Date? = nil, createdBy: String? = nil, description: String? = nil, ec2SecurityGroupIds: [String]? = nil, initializationScripts: [StudioComponentInitializationScript]? = nil, name: String? = nil, scriptParameters: [ScriptParameterKeyValue]? = nil, state: StudioComponentState? = nil, statusCode: StudioComponentStatusCode? = nil, statusMessage: String? = nil, studioComponentId: String? = nil, subtype: StudioComponentSubtype? = nil, tags: [String: String]? = nil, type: StudioComponentType? = nil, updatedAt: Date? = nil, updatedBy: String? = nil) {
            self.arn = arn
            self.configuration = configuration
            self.createdAt = createdAt
            self.createdBy = createdBy
            self.description = description
            self.ec2SecurityGroupIds = ec2SecurityGroupIds
            self.initializationScripts = initializationScripts
            self.name = name
            self.scriptParameters = scriptParameters
            self.state = state
            self.statusCode = statusCode
            self.statusMessage = statusMessage
            self.studioComponentId = studioComponentId
            self.subtype = subtype
            self.tags = tags
            self.type = type
            self.updatedAt = updatedAt
            self.updatedBy = updatedBy
        }

        private enum CodingKeys: String, CodingKey {
            case arn
            case configuration
            case createdAt
            case createdBy
            case description
            case ec2SecurityGroupIds
            case initializationScripts
            case name
            case scriptParameters
            case state
            case statusCode
            case statusMessage
            case studioComponentId
            case subtype
            case tags
            case type
            case updatedAt
            case updatedBy
        }
    }

    public struct StudioComponentConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The configuration for a Microsoft Active Directory (Microsoft AD) studio resource.
        public let activeDirectoryConfiguration: ActiveDirectoryConfiguration?
        /// The configuration for a render farm that is associated with a studio resource.
        public let computeFarmConfiguration: ComputeFarmConfiguration?
        /// The configuration for a license service that is associated with a studio resource.
        public let licenseServiceConfiguration: LicenseServiceConfiguration?
        /// The configuration for a shared file storage system that is associated with a studio resource.
        public let sharedFileSystemConfiguration: SharedFileSystemConfiguration?

        public init(activeDirectoryConfiguration: ActiveDirectoryConfiguration? = nil, computeFarmConfiguration: ComputeFarmConfiguration? = nil, licenseServiceConfiguration: LicenseServiceConfiguration? = nil, sharedFileSystemConfiguration: SharedFileSystemConfiguration? = nil) {
            self.activeDirectoryConfiguration = activeDirectoryConfiguration
            self.computeFarmConfiguration = computeFarmConfiguration
            self.licenseServiceConfiguration = licenseServiceConfiguration
            self.sharedFileSystemConfiguration = sharedFileSystemConfiguration
        }

        public func validate(name: String) throws {
            try self.activeDirectoryConfiguration?.validate(name: "\(name).activeDirectoryConfiguration")
            try self.sharedFileSystemConfiguration?.validate(name: "\(name).sharedFileSystemConfiguration")
        }

        private enum CodingKeys: String, CodingKey {
            case activeDirectoryConfiguration
            case computeFarmConfiguration
            case licenseServiceConfiguration
            case sharedFileSystemConfiguration
        }
    }

    public struct StudioComponentInitializationScript: AWSEncodableShape & AWSDecodableShape {
        /// The version number of the protocol that is used by the launch profile. The only valid version is "2021-03-31".
        public let launchProfileProtocolVersion: String?
        /// The platform of the initialization script, either WINDOWS or LINUX.
        public let platform: LaunchProfilePlatform?
        /// The method to use when running the initialization script.
        public let runContext: StudioComponentInitializationScriptRunContext?
        /// The initialization script.
        public let script: String?

        public init(launchProfileProtocolVersion: String? = nil, platform: LaunchProfilePlatform? = nil, runContext: StudioComponentInitializationScriptRunContext? = nil, script: String? = nil) {
            self.launchProfileProtocolVersion = launchProfileProtocolVersion
            self.platform = platform
            self.runContext = runContext
            self.script = script
        }

        public func validate(name: String) throws {
            try self.validate(self.launchProfileProtocolVersion, name: "launchProfileProtocolVersion", parent: name, max: 10)
            try self.validate(self.launchProfileProtocolVersion, name: "launchProfileProtocolVersion", parent: name, pattern: "^2021\\-03\\-31$")
            try self.validate(self.script, name: "script", parent: name, max: 5120)
            try self.validate(self.script, name: "script", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case launchProfileProtocolVersion
            case platform
            case runContext
            case script
        }
    }

    public struct StudioComponentSummary: AWSDecodableShape {
        /// The Unix epoch timestamp in seconds for when the resource was created.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var createdAt: Date?
        /// The user ID of the user that created the studio component.
        public let createdBy: String?
        /// The description.
        public let description: String?
        /// The name for the studio component.
        public let name: String?
        /// The unique identifier for a studio component resource.
        public let studioComponentId: String?
        /// The specific subtype of a studio component.
        public let subtype: StudioComponentSubtype?
        /// The type of the studio component.
        public let type: StudioComponentType?
        /// The Unix epoch timestamp in seconds for when the resource was updated.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var updatedAt: Date?
        /// The user ID of the user that most recently updated the resource.
        public let updatedBy: String?

        public init(createdAt: Date? = nil, createdBy: String? = nil, description: String? = nil, name: String? = nil, studioComponentId: String? = nil, subtype: StudioComponentSubtype? = nil, type: StudioComponentType? = nil, updatedAt: Date? = nil, updatedBy: String? = nil) {
            self.createdAt = createdAt
            self.createdBy = createdBy
            self.description = description
            self.name = name
            self.studioComponentId = studioComponentId
            self.subtype = subtype
            self.type = type
            self.updatedAt = updatedAt
            self.updatedBy = updatedBy
        }

        private enum CodingKeys: String, CodingKey {
            case createdAt
            case createdBy
            case description
            case name
            case studioComponentId
            case subtype
            case type
            case updatedAt
            case updatedBy
        }
    }

    public struct StudioEncryptionConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The ARN for a KMS key that is used to encrypt studio data.
        public let keyArn: String?
        /// The type of KMS key that is used to encrypt studio data.
        public let keyType: StudioEncryptionConfigurationKeyType

        public init(keyArn: String? = nil, keyType: StudioEncryptionConfigurationKeyType) {
            self.keyArn = keyArn
            self.keyType = keyType
        }

        public func validate(name: String) throws {
            try self.validate(self.keyArn, name: "keyArn", parent: name, min: 4)
            try self.validate(self.keyArn, name: "keyArn", parent: name, pattern: "^arn:")
        }

        private enum CodingKeys: String, CodingKey {
            case keyArn
            case keyType
        }
    }

    public struct StudioMembership: AWSDecodableShape {
        /// The ID of the identity store.
        public let identityStoreId: String?
        /// The persona.
        public let persona: StudioPersona?
        /// The principal ID.
        public let principalId: String?

        public init(identityStoreId: String? = nil, persona: StudioPersona? = nil, principalId: String? = nil) {
            self.identityStoreId = identityStoreId
            self.persona = persona
            self.principalId = principalId
        }

        private enum CodingKeys: String, CodingKey {
            case identityStoreId
            case persona
            case principalId
        }
    }

    public struct TagResourceRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "resourceArn", location: .uri(locationName: "resourceArn"))
        ]

        /// The ARN of the target resource for tagging operations.
        public let resourceArn: String
        /// A collection of labels, in the form of key:value pairs, that apply to this resource.
        public let tags: [String: String]?

        public init(resourceArn: String, tags: [String: String]? = nil) {
            self.resourceArn = resourceArn
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case tags
        }
    }

    public struct TagResourceResponse: AWSDecodableShape {
        public init() {}
    }

    public struct UntagResourceRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "resourceArn", location: .uri(locationName: "resourceArn")),
            AWSMemberEncoding(label: "tagKeys", location: .querystring(locationName: "tagKeys"))
        ]

        /// The ARN of the target resource for tagging operations.
        public let resourceArn: String
        /// An array of tag keys to delete.
        public let tagKeys: [String]

        public init(resourceArn: String, tagKeys: [String]) {
            self.resourceArn = resourceArn
            self.tagKeys = tagKeys
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct UntagResourceResponse: AWSDecodableShape {
        public init() {}
    }

    public struct UpdateLaunchProfileMemberRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "clientToken", location: .header(locationName: "X-Amz-Client-Token")),
            AWSMemberEncoding(label: "launchProfileId", location: .uri(locationName: "launchProfileId")),
            AWSMemberEncoding(label: "principalId", location: .uri(locationName: "principalId")),
            AWSMemberEncoding(label: "studioId", location: .uri(locationName: "studioId"))
        ]

        /// To make an idempotent API request using one of these actions, specify a client token in the request. You should not reuse the same client token for other API requests. If you retry a request that completed successfully using the same client token and the same parameters, the retry succeeds without performing any further actions. If you retry a successful request using the same client token, but one or more of the parameters are different, the retry fails with a ValidationException error.
        public let clientToken: String?
        /// The launch profile ID.
        public let launchProfileId: String
        /// The persona.
        public let persona: LaunchProfilePersona
        /// The principal ID.
        public let principalId: String
        /// The studio ID.
        public let studioId: String

        public init(clientToken: String? = UpdateLaunchProfileMemberRequest.idempotencyToken(), launchProfileId: String, persona: LaunchProfilePersona, principalId: String, studioId: String) {
            self.clientToken = clientToken
            self.launchProfileId = launchProfileId
            self.persona = persona
            self.principalId = principalId
            self.studioId = studioId
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 64)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case persona
        }
    }

    public struct UpdateLaunchProfileMemberResponse: AWSDecodableShape {
        /// The member.
        public let member: LaunchProfileMembership?

        public init(member: LaunchProfileMembership? = nil) {
            self.member = member
        }

        private enum CodingKeys: String, CodingKey {
            case member
        }
    }

    public struct UpdateLaunchProfileRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "clientToken", location: .header(locationName: "X-Amz-Client-Token")),
            AWSMemberEncoding(label: "launchProfileId", location: .uri(locationName: "launchProfileId")),
            AWSMemberEncoding(label: "studioId", location: .uri(locationName: "studioId"))
        ]

        /// To make an idempotent API request using one of these actions, specify a client token in the request. You should not reuse the same client token for other API requests. If you retry a request that completed successfully using the same client token and the same parameters, the retry succeeds without performing any further actions. If you retry a successful request using the same client token, but one or more of the parameters are different, the retry fails with a ValidationException error.
        public let clientToken: String?
        /// The description.
        public let description: String?
        /// The launch profile ID.
        public let launchProfileId: String
        /// The version number of the protocol that is used by the launch profile. The only valid version is "2021-03-31".
        public let launchProfileProtocolVersions: [String]?
        /// The name for the launch profile.
        public let name: String?
        /// A configuration for a streaming session.
        public let streamConfiguration: StreamConfigurationCreate?
        /// Unique identifiers for a collection of studio components that can be used with this launch profile.
        public let studioComponentIds: [String]?
        /// The studio ID.
        public let studioId: String

        public init(clientToken: String? = UpdateLaunchProfileRequest.idempotencyToken(), description: String? = nil, launchProfileId: String, launchProfileProtocolVersions: [String]? = nil, name: String? = nil, streamConfiguration: StreamConfigurationCreate? = nil, studioComponentIds: [String]? = nil, studioId: String) {
            self.clientToken = clientToken
            self.description = description
            self.launchProfileId = launchProfileId
            self.launchProfileProtocolVersions = launchProfileProtocolVersions
            self.name = name
            self.streamConfiguration = streamConfiguration
            self.studioComponentIds = studioComponentIds
            self.studioId = studioId
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 64)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.validate(self.description, name: "description", parent: name, max: 256)
            try self.launchProfileProtocolVersions?.forEach {
                try validate($0, name: "launchProfileProtocolVersions[]", parent: name, max: 10)
                try validate($0, name: "launchProfileProtocolVersions[]", parent: name, pattern: "^2021\\-03\\-31$")
            }
            try self.validate(self.name, name: "name", parent: name, max: 64)
            try self.streamConfiguration?.validate(name: "\(name).streamConfiguration")
            try self.validate(self.studioComponentIds, name: "studioComponentIds", parent: name, max: 100)
            try self.validate(self.studioComponentIds, name: "studioComponentIds", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case description
            case launchProfileProtocolVersions
            case name
            case streamConfiguration
            case studioComponentIds
        }
    }

    public struct UpdateLaunchProfileResponse: AWSDecodableShape {
        /// The launch profile.
        public let launchProfile: LaunchProfile?

        public init(launchProfile: LaunchProfile? = nil) {
            self.launchProfile = launchProfile
        }

        private enum CodingKeys: String, CodingKey {
            case launchProfile
        }
    }

    public struct UpdateStreamingImageRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "clientToken", location: .header(locationName: "X-Amz-Client-Token")),
            AWSMemberEncoding(label: "streamingImageId", location: .uri(locationName: "streamingImageId")),
            AWSMemberEncoding(label: "studioId", location: .uri(locationName: "studioId"))
        ]

        /// To make an idempotent API request using one of these actions, specify a client token in the request. You should not reuse the same client token for other API requests. If you retry a request that completed successfully using the same client token and the same parameters, the retry succeeds without performing any further actions. If you retry a successful request using the same client token, but one or more of the parameters are different, the retry fails with a ValidationException error.
        public let clientToken: String?
        /// The description.
        public let description: String?
        /// The name for the streaming image.
        public let name: String?
        /// The streaming image ID.
        public let streamingImageId: String
        /// The studio ID.
        public let studioId: String

        public init(clientToken: String? = UpdateStreamingImageRequest.idempotencyToken(), description: String? = nil, name: String? = nil, streamingImageId: String, studioId: String) {
            self.clientToken = clientToken
            self.description = description
            self.name = name
            self.streamingImageId = streamingImageId
            self.studioId = studioId
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 64)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.validate(self.description, name: "description", parent: name, max: 256)
            try self.validate(self.name, name: "name", parent: name, max: 64)
        }

        private enum CodingKeys: String, CodingKey {
            case description
            case name
        }
    }

    public struct UpdateStreamingImageResponse: AWSDecodableShape {
        public let streamingImage: StreamingImage?

        public init(streamingImage: StreamingImage? = nil) {
            self.streamingImage = streamingImage
        }

        private enum CodingKeys: String, CodingKey {
            case streamingImage
        }
    }

    public struct UpdateStudioComponentRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "clientToken", location: .header(locationName: "X-Amz-Client-Token")),
            AWSMemberEncoding(label: "studioComponentId", location: .uri(locationName: "studioComponentId")),
            AWSMemberEncoding(label: "studioId", location: .uri(locationName: "studioId"))
        ]

        /// To make an idempotent API request using one of these actions, specify a client token in the request. You should not reuse the same client token for other API requests. If you retry a request that completed successfully using the same client token and the same parameters, the retry succeeds without performing any further actions. If you retry a successful request using the same client token, but one or more of the parameters are different, the retry fails with a ValidationException error.
        public let clientToken: String?
        /// The configuration of the studio component, based on component type.
        public let configuration: StudioComponentConfiguration?
        /// The description.
        public let description: String?
        /// The EC2 security groups that control access to the studio component.
        public let ec2SecurityGroupIds: [String]?
        /// Initialization scripts for studio components.
        public let initializationScripts: [StudioComponentInitializationScript]?
        /// The name for the studio component.
        public let name: String?
        /// Parameters for the studio component scripts.
        public let scriptParameters: [ScriptParameterKeyValue]?
        /// The studio component ID.
        public let studioComponentId: String
        /// The studio ID.
        public let studioId: String
        /// The specific subtype of a studio component.
        public let subtype: StudioComponentSubtype?
        /// The type of the studio component.
        public let type: StudioComponentType?

        public init(clientToken: String? = UpdateStudioComponentRequest.idempotencyToken(), configuration: StudioComponentConfiguration? = nil, description: String? = nil, ec2SecurityGroupIds: [String]? = nil, initializationScripts: [StudioComponentInitializationScript]? = nil, name: String? = nil, scriptParameters: [ScriptParameterKeyValue]? = nil, studioComponentId: String, studioId: String, subtype: StudioComponentSubtype? = nil, type: StudioComponentType? = nil) {
            self.clientToken = clientToken
            self.configuration = configuration
            self.description = description
            self.ec2SecurityGroupIds = ec2SecurityGroupIds
            self.initializationScripts = initializationScripts
            self.name = name
            self.scriptParameters = scriptParameters
            self.studioComponentId = studioComponentId
            self.studioId = studioId
            self.subtype = subtype
            self.type = type
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 64)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.configuration?.validate(name: "\(name).configuration")
            try self.validate(self.description, name: "description", parent: name, max: 256)
            try self.validate(self.ec2SecurityGroupIds, name: "ec2SecurityGroupIds", parent: name, max: 30)
            try self.validate(self.ec2SecurityGroupIds, name: "ec2SecurityGroupIds", parent: name, min: 1)
            try self.initializationScripts?.forEach {
                try $0.validate(name: "\(name).initializationScripts[]")
            }
            try self.validate(self.name, name: "name", parent: name, max: 64)
            try self.scriptParameters?.forEach {
                try $0.validate(name: "\(name).scriptParameters[]")
            }
            try self.validate(self.scriptParameters, name: "scriptParameters", parent: name, max: 30)
        }

        private enum CodingKeys: String, CodingKey {
            case configuration
            case description
            case ec2SecurityGroupIds
            case initializationScripts
            case name
            case scriptParameters
            case subtype
            case type
        }
    }

    public struct UpdateStudioComponentResponse: AWSDecodableShape {
        /// Information about the studio component.
        public let studioComponent: StudioComponent?

        public init(studioComponent: StudioComponent? = nil) {
            self.studioComponent = studioComponent
        }

        private enum CodingKeys: String, CodingKey {
            case studioComponent
        }
    }

    public struct UpdateStudioRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "clientToken", location: .header(locationName: "X-Amz-Client-Token")),
            AWSMemberEncoding(label: "studioId", location: .uri(locationName: "studioId"))
        ]

        /// The IAM role that Studio Admins will assume when logging in to the Nimble Studio portal.
        public let adminRoleArn: String?
        /// To make an idempotent API request using one of these actions, specify a client token in the request. You should not reuse the same client token for other API requests. If you retry a request that completed successfully using the same client token and the same parameters, the retry succeeds without performing any further actions. If you retry a successful request using the same client token, but one or more of the parameters are different, the retry fails with a ValidationException error.
        public let clientToken: String?
        /// A friendly name for the studio.
        public let displayName: String?
        /// The studio ID.
        public let studioId: String
        /// The IAM role that Studio Users will assume when logging in to the Nimble Studio portal.
        public let userRoleArn: String?

        public init(adminRoleArn: String? = nil, clientToken: String? = UpdateStudioRequest.idempotencyToken(), displayName: String? = nil, studioId: String, userRoleArn: String? = nil) {
            self.adminRoleArn = adminRoleArn
            self.clientToken = clientToken
            self.displayName = displayName
            self.studioId = studioId
            self.userRoleArn = userRoleArn
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 64)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.validate(self.displayName, name: "displayName", parent: name, max: 64)
        }

        private enum CodingKeys: String, CodingKey {
            case adminRoleArn
            case displayName
            case userRoleArn
        }
    }

    public struct UpdateStudioResponse: AWSDecodableShape {
        /// Information about a studio.
        public let studio: Studio?

        public init(studio: Studio? = nil) {
            self.studio = studio
        }

        private enum CodingKeys: String, CodingKey {
            case studio
        }
    }
}
