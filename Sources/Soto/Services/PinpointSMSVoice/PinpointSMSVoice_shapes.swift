//===----------------------------------------------------------------------===//
//
// This source file is part of the Soto for AWS open source project
//
// Copyright (c) 2017-2024 the Soto project authors
// Licensed under Apache License v2.0
//
// See LICENSE.txt for license information
// See CONTRIBUTORS.txt for the list of Soto project authors
//
// SPDX-License-Identifier: Apache-2.0
//
//===----------------------------------------------------------------------===//

// THIS FILE IS AUTOMATICALLY GENERATED by https://github.com/soto-project/soto-codegenerator.
// DO NOT EDIT.

#if canImport(FoundationEssentials)
import FoundationEssentials
#else
import Foundation
#endif
@_spi(SotoInternal) import SotoCore

extension PinpointSMSVoice {
    // MARK: Enums

    public enum EventType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case answered = "ANSWERED"
        case busy = "BUSY"
        case completedCall = "COMPLETED_CALL"
        case failed = "FAILED"
        case initiatedCall = "INITIATED_CALL"
        case noAnswer = "NO_ANSWER"
        case ringing = "RINGING"
        public var description: String { return self.rawValue }
    }

    // MARK: Shapes

    public struct CallInstructionsMessageType: AWSEncodableShape {
        /// The language to use when delivering the message. For a complete list of supported languages, see the Amazon Polly Developer Guide.
        public let text: String?

        @inlinable
        public init(text: String? = nil) {
            self.text = text
        }

        private enum CodingKeys: String, CodingKey {
            case text = "Text"
        }
    }

    public struct CloudWatchLogsDestination: AWSEncodableShape & AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of an Amazon Identity and Access Management (IAM) role that is able to write event data to an Amazon CloudWatch destination.
        public let iamRoleArn: String?
        /// The name of the Amazon CloudWatch Log Group that you want to record events in.
        public let logGroupArn: String?

        @inlinable
        public init(iamRoleArn: String? = nil, logGroupArn: String? = nil) {
            self.iamRoleArn = iamRoleArn
            self.logGroupArn = logGroupArn
        }

        private enum CodingKeys: String, CodingKey {
            case iamRoleArn = "IamRoleArn"
            case logGroupArn = "LogGroupArn"
        }
    }

    public struct CreateConfigurationSetEventDestinationRequest: AWSEncodableShape {
        /// ConfigurationSetName
        public let configurationSetName: String
        public let eventDestination: EventDestinationDefinition?
        /// A name that identifies the event destination.
        public let eventDestinationName: String?

        @inlinable
        public init(configurationSetName: String, eventDestination: EventDestinationDefinition? = nil, eventDestinationName: String? = nil) {
            self.configurationSetName = configurationSetName
            self.eventDestination = eventDestination
            self.eventDestinationName = eventDestinationName
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.configurationSetName, key: "ConfigurationSetName")
            try container.encodeIfPresent(self.eventDestination, forKey: .eventDestination)
            try container.encodeIfPresent(self.eventDestinationName, forKey: .eventDestinationName)
        }

        private enum CodingKeys: String, CodingKey {
            case eventDestination = "EventDestination"
            case eventDestinationName = "EventDestinationName"
        }
    }

    public struct CreateConfigurationSetEventDestinationResponse: AWSDecodableShape {
        public init() {}
    }

    public struct CreateConfigurationSetRequest: AWSEncodableShape {
        /// The name that you want to give the configuration set.
        public let configurationSetName: String?

        @inlinable
        public init(configurationSetName: String? = nil) {
            self.configurationSetName = configurationSetName
        }

        private enum CodingKeys: String, CodingKey {
            case configurationSetName = "ConfigurationSetName"
        }
    }

    public struct CreateConfigurationSetResponse: AWSDecodableShape {
        public init() {}
    }

    public struct DeleteConfigurationSetEventDestinationRequest: AWSEncodableShape {
        /// ConfigurationSetName
        public let configurationSetName: String
        /// EventDestinationName
        public let eventDestinationName: String

        @inlinable
        public init(configurationSetName: String, eventDestinationName: String) {
            self.configurationSetName = configurationSetName
            self.eventDestinationName = eventDestinationName
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.configurationSetName, key: "ConfigurationSetName")
            request.encodePath(self.eventDestinationName, key: "EventDestinationName")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteConfigurationSetEventDestinationResponse: AWSDecodableShape {
        public init() {}
    }

    public struct DeleteConfigurationSetRequest: AWSEncodableShape {
        /// ConfigurationSetName
        public let configurationSetName: String

        @inlinable
        public init(configurationSetName: String) {
            self.configurationSetName = configurationSetName
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.configurationSetName, key: "ConfigurationSetName")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteConfigurationSetResponse: AWSDecodableShape {
        public init() {}
    }

    public struct EventDestination: AWSDecodableShape {
        public let cloudWatchLogsDestination: CloudWatchLogsDestination?
        /// Indicates whether or not the event destination is enabled. If the event destination is enabled, then Amazon Pinpoint sends response data to the specified event destination.
        public let enabled: Bool?
        public let kinesisFirehoseDestination: KinesisFirehoseDestination?
        public let matchingEventTypes: [EventType]?
        /// A name that identifies the event destination configuration.
        public let name: String?
        public let snsDestination: SnsDestination?

        @inlinable
        public init(cloudWatchLogsDestination: CloudWatchLogsDestination? = nil, enabled: Bool? = nil, kinesisFirehoseDestination: KinesisFirehoseDestination? = nil, matchingEventTypes: [EventType]? = nil, name: String? = nil, snsDestination: SnsDestination? = nil) {
            self.cloudWatchLogsDestination = cloudWatchLogsDestination
            self.enabled = enabled
            self.kinesisFirehoseDestination = kinesisFirehoseDestination
            self.matchingEventTypes = matchingEventTypes
            self.name = name
            self.snsDestination = snsDestination
        }

        private enum CodingKeys: String, CodingKey {
            case cloudWatchLogsDestination = "CloudWatchLogsDestination"
            case enabled = "Enabled"
            case kinesisFirehoseDestination = "KinesisFirehoseDestination"
            case matchingEventTypes = "MatchingEventTypes"
            case name = "Name"
            case snsDestination = "SnsDestination"
        }
    }

    public struct EventDestinationDefinition: AWSEncodableShape {
        public let cloudWatchLogsDestination: CloudWatchLogsDestination?
        /// Indicates whether or not the event destination is enabled. If the event destination is enabled, then Amazon Pinpoint sends response data to the specified event destination.
        public let enabled: Bool?
        public let kinesisFirehoseDestination: KinesisFirehoseDestination?
        public let matchingEventTypes: [EventType]?
        public let snsDestination: SnsDestination?

        @inlinable
        public init(cloudWatchLogsDestination: CloudWatchLogsDestination? = nil, enabled: Bool? = nil, kinesisFirehoseDestination: KinesisFirehoseDestination? = nil, matchingEventTypes: [EventType]? = nil, snsDestination: SnsDestination? = nil) {
            self.cloudWatchLogsDestination = cloudWatchLogsDestination
            self.enabled = enabled
            self.kinesisFirehoseDestination = kinesisFirehoseDestination
            self.matchingEventTypes = matchingEventTypes
            self.snsDestination = snsDestination
        }

        private enum CodingKeys: String, CodingKey {
            case cloudWatchLogsDestination = "CloudWatchLogsDestination"
            case enabled = "Enabled"
            case kinesisFirehoseDestination = "KinesisFirehoseDestination"
            case matchingEventTypes = "MatchingEventTypes"
            case snsDestination = "SnsDestination"
        }
    }

    public struct GetConfigurationSetEventDestinationsRequest: AWSEncodableShape {
        /// ConfigurationSetName
        public let configurationSetName: String

        @inlinable
        public init(configurationSetName: String) {
            self.configurationSetName = configurationSetName
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.configurationSetName, key: "ConfigurationSetName")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetConfigurationSetEventDestinationsResponse: AWSDecodableShape {
        public let eventDestinations: [EventDestination]?

        @inlinable
        public init(eventDestinations: [EventDestination]? = nil) {
            self.eventDestinations = eventDestinations
        }

        private enum CodingKeys: String, CodingKey {
            case eventDestinations = "EventDestinations"
        }
    }

    public struct KinesisFirehoseDestination: AWSEncodableShape & AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of an IAM role that can write data to an Amazon Kinesis Data Firehose stream.
        public let deliveryStreamArn: String?
        /// The Amazon Resource Name (ARN) of the Amazon Kinesis Data Firehose destination that you want to use in the event destination.
        public let iamRoleArn: String?

        @inlinable
        public init(deliveryStreamArn: String? = nil, iamRoleArn: String? = nil) {
            self.deliveryStreamArn = deliveryStreamArn
            self.iamRoleArn = iamRoleArn
        }

        private enum CodingKeys: String, CodingKey {
            case deliveryStreamArn = "DeliveryStreamArn"
            case iamRoleArn = "IamRoleArn"
        }
    }

    public struct ListConfigurationSetsRequest: AWSEncodableShape {
        /// A token returned from a previous call to the API that indicates the position in the list of results.
        public let nextToken: String?
        /// Used to specify the number of items that should be returned in the response.
        public let pageSize: String?

        @inlinable
        public init(nextToken: String? = nil, pageSize: String? = nil) {
            self.nextToken = nextToken
            self.pageSize = pageSize
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.nextToken, key: "NextToken")
            request.encodeQuery(self.pageSize, key: "PageSize")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListConfigurationSetsResponse: AWSDecodableShape {
        /// An object that contains a list of configuration sets for your account in the current region.
        public let configurationSets: [String]?
        /// A token returned from a previous call to ListConfigurationSets to indicate the position in the list of configuration sets.
        public let nextToken: String?

        @inlinable
        public init(configurationSets: [String]? = nil, nextToken: String? = nil) {
            self.configurationSets = configurationSets
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case configurationSets = "ConfigurationSets"
            case nextToken = "NextToken"
        }
    }

    public struct PlainTextMessageType: AWSEncodableShape {
        /// The language to use when delivering the message. For a complete list of supported languages, see the Amazon Polly Developer Guide.
        public let languageCode: String?
        /// The plain (not SSML-formatted) text to deliver to the recipient.
        public let text: String?
        /// The name of the voice that you want to use to deliver the message. For a complete list of supported voices, see the Amazon Polly Developer Guide.
        public let voiceId: String?

        @inlinable
        public init(languageCode: String? = nil, text: String? = nil, voiceId: String? = nil) {
            self.languageCode = languageCode
            self.text = text
            self.voiceId = voiceId
        }

        private enum CodingKeys: String, CodingKey {
            case languageCode = "LanguageCode"
            case text = "Text"
            case voiceId = "VoiceId"
        }
    }

    public struct SSMLMessageType: AWSEncodableShape {
        /// The language to use when delivering the message. For a complete list of supported languages, see the Amazon Polly Developer Guide.
        public let languageCode: String?
        /// The SSML-formatted text to deliver to the recipient.
        public let text: String?
        /// The name of the voice that you want to use to deliver the message. For a complete list of supported voices, see the Amazon Polly Developer Guide.
        public let voiceId: String?

        @inlinable
        public init(languageCode: String? = nil, text: String? = nil, voiceId: String? = nil) {
            self.languageCode = languageCode
            self.text = text
            self.voiceId = voiceId
        }

        private enum CodingKeys: String, CodingKey {
            case languageCode = "LanguageCode"
            case text = "Text"
            case voiceId = "VoiceId"
        }
    }

    public struct SendVoiceMessageRequest: AWSEncodableShape {
        /// The phone number that appears on recipients' devices when they receive the message.
        public let callerId: String?
        /// The name of the configuration set that you want to use to send the message.
        public let configurationSetName: String?
        public let content: VoiceMessageContent?
        /// The phone number that you want to send the voice message to.
        public let destinationPhoneNumber: String?
        /// The phone number that Amazon Pinpoint should use to send the voice message. This isn't necessarily the phone number that appears on recipients' devices when they receive the message, because you can specify a CallerId parameter in the request.
        public let originationPhoneNumber: String?

        @inlinable
        public init(callerId: String? = nil, configurationSetName: String? = nil, content: VoiceMessageContent? = nil, destinationPhoneNumber: String? = nil, originationPhoneNumber: String? = nil) {
            self.callerId = callerId
            self.configurationSetName = configurationSetName
            self.content = content
            self.destinationPhoneNumber = destinationPhoneNumber
            self.originationPhoneNumber = originationPhoneNumber
        }

        private enum CodingKeys: String, CodingKey {
            case callerId = "CallerId"
            case configurationSetName = "ConfigurationSetName"
            case content = "Content"
            case destinationPhoneNumber = "DestinationPhoneNumber"
            case originationPhoneNumber = "OriginationPhoneNumber"
        }
    }

    public struct SendVoiceMessageResponse: AWSDecodableShape {
        /// A unique identifier for the voice message.
        public let messageId: String?

        @inlinable
        public init(messageId: String? = nil) {
            self.messageId = messageId
        }

        private enum CodingKeys: String, CodingKey {
            case messageId = "MessageId"
        }
    }

    public struct SnsDestination: AWSEncodableShape & AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the Amazon SNS topic that you want to publish events to.
        public let topicArn: String?

        @inlinable
        public init(topicArn: String? = nil) {
            self.topicArn = topicArn
        }

        private enum CodingKeys: String, CodingKey {
            case topicArn = "TopicArn"
        }
    }

    public struct UpdateConfigurationSetEventDestinationRequest: AWSEncodableShape {
        /// ConfigurationSetName
        public let configurationSetName: String
        public let eventDestination: EventDestinationDefinition?
        /// EventDestinationName
        public let eventDestinationName: String

        @inlinable
        public init(configurationSetName: String, eventDestination: EventDestinationDefinition? = nil, eventDestinationName: String) {
            self.configurationSetName = configurationSetName
            self.eventDestination = eventDestination
            self.eventDestinationName = eventDestinationName
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.configurationSetName, key: "ConfigurationSetName")
            try container.encodeIfPresent(self.eventDestination, forKey: .eventDestination)
            request.encodePath(self.eventDestinationName, key: "EventDestinationName")
        }

        private enum CodingKeys: String, CodingKey {
            case eventDestination = "EventDestination"
        }
    }

    public struct UpdateConfigurationSetEventDestinationResponse: AWSDecodableShape {
        public init() {}
    }

    public struct VoiceMessageContent: AWSEncodableShape {
        public let callInstructionsMessage: CallInstructionsMessageType?
        public let plainTextMessage: PlainTextMessageType?
        public let ssmlMessage: SSMLMessageType?

        @inlinable
        public init(callInstructionsMessage: CallInstructionsMessageType? = nil, plainTextMessage: PlainTextMessageType? = nil, ssmlMessage: SSMLMessageType? = nil) {
            self.callInstructionsMessage = callInstructionsMessage
            self.plainTextMessage = plainTextMessage
            self.ssmlMessage = ssmlMessage
        }

        private enum CodingKeys: String, CodingKey {
            case callInstructionsMessage = "CallInstructionsMessage"
            case plainTextMessage = "PlainTextMessage"
            case ssmlMessage = "SSMLMessage"
        }
    }
}

// MARK: - Errors

/// Error enum for PinpointSMSVoice
public struct PinpointSMSVoiceErrorType: AWSErrorType {
    enum Code: String {
        case alreadyExistsException = "AlreadyExistsException"
        case badRequestException = "BadRequestException"
        case internalServiceErrorException = "InternalServiceErrorException"
        case limitExceededException = "LimitExceededException"
        case notFoundException = "NotFoundException"
        case tooManyRequestsException = "TooManyRequestsException"
    }

    private let error: Code
    public let context: AWSErrorContext?

    /// initialize PinpointSMSVoice
    public init?(errorCode: String, context: AWSErrorContext) {
        guard let error = Code(rawValue: errorCode) else { return nil }
        self.error = error
        self.context = context
    }

    internal init(_ error: Code) {
        self.error = error
        self.context = nil
    }

    /// return error code string
    public var errorCode: String { self.error.rawValue }

    /// The resource specified in your request already exists.
    public static var alreadyExistsException: Self { .init(.alreadyExistsException) }
    /// The input you provided is invalid.
    public static var badRequestException: Self { .init(.badRequestException) }
    /// The API encountered an unexpected error and couldn't complete the request. You might be able to successfully issue the request again in the future.
    public static var internalServiceErrorException: Self { .init(.internalServiceErrorException) }
    /// There are too many instances of the specified resource type.
    public static var limitExceededException: Self { .init(.limitExceededException) }
    /// The resource you attempted to access doesn't exist.
    public static var notFoundException: Self { .init(.notFoundException) }
    /// You've issued too many requests to the resource. Wait a few minutes, and then try again.
    public static var tooManyRequestsException: Self { .init(.tooManyRequestsException) }
}

extension PinpointSMSVoiceErrorType: Equatable {
    public static func == (lhs: PinpointSMSVoiceErrorType, rhs: PinpointSMSVoiceErrorType) -> Bool {
        lhs.error == rhs.error
    }
}

extension PinpointSMSVoiceErrorType: CustomStringConvertible {
    public var description: String {
        return "\(self.error.rawValue): \(self.message ?? "")"
    }
}
