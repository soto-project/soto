//===----------------------------------------------------------------------===//
//
// This source file is part of the Soto for AWS open source project
//
// Copyright (c) 2017-2024 the Soto project authors
// Licensed under Apache License v2.0
//
// See LICENSE.txt for license information
// See CONTRIBUTORS.txt for the list of Soto project authors
//
// SPDX-License-Identifier: Apache-2.0
//
//===----------------------------------------------------------------------===//

// THIS FILE IS AUTOMATICALLY GENERATED by https://github.com/soto-project/soto-codegenerator.
// DO NOT EDIT.

#if os(Linux) && compiler(<5.10)
// swift-corelibs-foundation hasn't been updated with Sendable conformances
@preconcurrency import Foundation
#else
import Foundation
#endif
@_exported import SotoCore

/// Service object for interacting with AWS MediaConvert service.
///
/// AWS Elemental MediaConvert
public struct MediaConvert: AWSService {
    // MARK: Member variables

    /// Client used for communication with AWS
    public let client: AWSClient
    /// Service configuration
    public let config: AWSServiceConfig

    // MARK: Initialization

    /// Initialize the MediaConvert client
    /// - parameters:
    ///     - client: AWSClient used to process requests
    ///     - region: Region of server you want to communicate with. This will override the partition parameter.
    ///     - partition: AWS partition where service resides, standard (.aws), china (.awscn), government (.awsusgov).
    ///     - endpoint: Custom endpoint URL to use instead of standard AWS servers
    ///     - middleware: Middleware chain used to edit requests before they are sent and responses before they are decoded 
    ///     - timeout: Timeout value for HTTP requests
    ///     - byteBufferAllocator: Allocator for ByteBuffers
    ///     - options: Service options
    public init(
        client: AWSClient,
        region: SotoCore.Region? = nil,
        partition: AWSPartition = .aws,
        endpoint: String? = nil,
        middleware: AWSMiddlewareProtocol? = nil,
        timeout: TimeAmount? = nil,
        byteBufferAllocator: ByteBufferAllocator = ByteBufferAllocator(),
        options: AWSServiceConfig.Options = []
    ) {
        self.client = client
        self.config = AWSServiceConfig(
            region: region,
            partition: region?.partition ?? partition,
            serviceName: "MediaConvert",
            serviceIdentifier: "mediaconvert",
            serviceProtocol: .restjson,
            apiVersion: "2017-08-29",
            endpoint: endpoint,
            serviceEndpoints: Self.serviceEndpoints,
            variantEndpoints: Self.variantEndpoints,
            errorType: MediaConvertErrorType.self,
            middleware: middleware,
            timeout: timeout,
            byteBufferAllocator: byteBufferAllocator,
            options: options
        )
    }


    /// custom endpoints for regions
    static var serviceEndpoints: [String: String] {[
        "cn-northwest-1": "mediaconvert.cn-northwest-1.amazonaws.com.cn"
    ]}


    /// FIPS and dualstack endpoints
    static var variantEndpoints: [EndpointVariantType: AWSServiceConfig.EndpointVariant] {[
        [.fips]: .init(endpoints: [
            "ca-central-1": "mediaconvert-fips.ca-central-1.amazonaws.com",
            "us-east-1": "mediaconvert-fips.us-east-1.amazonaws.com",
            "us-east-2": "mediaconvert-fips.us-east-2.amazonaws.com",
            "us-gov-west-1": "mediaconvert.us-gov-west-1.amazonaws.com",
            "us-west-1": "mediaconvert-fips.us-west-1.amazonaws.com",
            "us-west-2": "mediaconvert-fips.us-west-2.amazonaws.com"
        ])
    ]}

    // MARK: API Calls

    /// Associates an AWS Certificate Manager (ACM) Amazon Resource Name (ARN) with AWS Elemental MediaConvert.
    @Sendable
    @inlinable
    public func associateCertificate(_ input: AssociateCertificateRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> AssociateCertificateResponse {
        try await self.client.execute(
            operation: "AssociateCertificate", 
            path: "/2017-08-29/certificates", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Associates an AWS Certificate Manager (ACM) Amazon Resource Name (ARN) with AWS Elemental MediaConvert.
    ///
    /// Parameters:
    ///   - arn: The ARN of the ACM certificate that you want to associate with your MediaConvert resource.
    ///   - logger: Logger use during operation
    @inlinable
    public func associateCertificate(
        arn: String? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> AssociateCertificateResponse {
        let input = AssociateCertificateRequest(
            arn: arn
        )
        return try await self.associateCertificate(input, logger: logger)
    }

    /// Permanently cancel a job. Once you have canceled a job, you can't start it again.
    @Sendable
    @inlinable
    public func cancelJob(_ input: CancelJobRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> CancelJobResponse {
        try await self.client.execute(
            operation: "CancelJob", 
            path: "/2017-08-29/jobs/{Id}", 
            httpMethod: .DELETE, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Permanently cancel a job. Once you have canceled a job, you can't start it again.
    ///
    /// Parameters:
    ///   - id: The Job ID of the job to be cancelled.
    ///   - logger: Logger use during operation
    @inlinable
    public func cancelJob(
        id: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> CancelJobResponse {
        let input = CancelJobRequest(
            id: id
        )
        return try await self.cancelJob(input, logger: logger)
    }

    /// Create a new transcoding job. For information about jobs and job settings, see the User Guide at http://docs.aws.amazon.com/mediaconvert/latest/ug/what-is.html
    @Sendable
    @inlinable
    public func createJob(_ input: CreateJobRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> CreateJobResponse {
        try await self.client.execute(
            operation: "CreateJob", 
            path: "/2017-08-29/jobs", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Create a new transcoding job. For information about jobs and job settings, see the User Guide at http://docs.aws.amazon.com/mediaconvert/latest/ug/what-is.html
    ///
    /// Parameters:
    ///   - accelerationSettings: Optional. Accelerated transcoding can significantly speed up jobs with long, visually complex content. Outputs that use this feature incur pro-tier pricing. For information about feature limitations, see the AWS Elemental MediaConvert User Guide.
    ///   - billingTagsSource: Optional. Choose a tag type that AWS Billing and Cost Management will use to sort your AWS Elemental MediaConvert costs on any billing report that you set up. Any transcoding outputs that don't have an associated tag will appear in your billing report unsorted. If you don't choose a valid value for this field, your job outputs will appear on the billing report unsorted.
    ///   - clientRequestToken: Prevent duplicate jobs from being created and ensure idempotency for your requests. A client request token can be any string that includes up to 64 ASCII characters. If you reuse a client request token within one minute of a successful request, the API returns the job details of the original request instead. For more information see https://docs.aws.amazon.com/mediaconvert/latest/apireference/idempotency.html.
    ///   - hopDestinations: Optional. Use queue hopping to avoid overly long waits in the backlog of the queue that you submit your job to. Specify an alternate queue and the maximum time that your job will wait in the initial queue before hopping. For more information about this feature, see the AWS Elemental MediaConvert User Guide.
    ///   - jobEngineVersion: Use Job engine versions to run jobs for your production workflow on one version, while you test and validate the latest version. To specify a Job engine version: Enter a date in a YYYY-MM-DD format. For a list of valid Job engine versions, submit a ListVersions request. To not specify a Job engine version: Leave blank.
    ///   - jobTemplate: Optional. When you create a job, you can either specify a job template or specify the transcoding settings individually.
    ///   - priority: Optional. Specify the relative priority for this job. In any given queue, the service begins processing the job with the highest value first. When more than one job has the same priority, the service begins processing the job that you submitted first. If you don't specify a priority, the service uses the default value 0.
    ///   - queue: Optional. When you create a job, you can specify a queue to send it to. If you don't specify, the job will go to the default queue. For more about queues, see the User Guide topic at https://docs.aws.amazon.com/mediaconvert/latest/ug/what-is.html.
    ///   - role: Required. The IAM role you use for creating this job. For details about permissions, see the User Guide topic at the User Guide at https://docs.aws.amazon.com/mediaconvert/latest/ug/iam-role.html.
    ///   - settings: JobSettings contains all the transcode settings for a job.
    ///   - simulateReservedQueue: Optional. Enable this setting when you run a test job to estimate how many reserved transcoding slots (RTS) you need. When this is enabled, MediaConvert runs your job from an on-demand queue with similar performance to what you will see with one RTS in a reserved queue. This setting is disabled by default.
    ///   - statusUpdateInterval: Optional. Specify how often MediaConvert sends STATUS_UPDATE events to Amazon CloudWatch Events. Set the interval, in seconds, between status updates. MediaConvert sends an update at this interval from the time the service begins processing your job to the time it completes the transcode or encounters an error.
    ///   - tags: Optional. The tags that you want to add to the resource. You can tag resources with a key-value pair or with only a key.  Use standard AWS tags on your job for automatic integration with AWS services and for custom integrations and workflows.
    ///   - userMetadata: Optional. User-defined metadata that you want to associate with an MediaConvert job. You specify metadata in key/value pairs.  Use only for existing integrations or workflows that rely on job metadata tags. Otherwise, we recommend that you use standard AWS tags.
    ///   - logger: Logger use during operation
    @inlinable
    public func createJob(
        accelerationSettings: AccelerationSettings? = nil,
        billingTagsSource: BillingTagsSource? = nil,
        clientRequestToken: String? = CreateJobRequest.idempotencyToken(),
        hopDestinations: [HopDestination]? = nil,
        jobEngineVersion: String? = nil,
        jobTemplate: String? = nil,
        priority: Int? = nil,
        queue: String? = nil,
        role: String? = nil,
        settings: JobSettings? = nil,
        simulateReservedQueue: SimulateReservedQueue? = nil,
        statusUpdateInterval: StatusUpdateInterval? = nil,
        tags: [String: String]? = nil,
        userMetadata: [String: String]? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> CreateJobResponse {
        let input = CreateJobRequest(
            accelerationSettings: accelerationSettings, 
            billingTagsSource: billingTagsSource, 
            clientRequestToken: clientRequestToken, 
            hopDestinations: hopDestinations, 
            jobEngineVersion: jobEngineVersion, 
            jobTemplate: jobTemplate, 
            priority: priority, 
            queue: queue, 
            role: role, 
            settings: settings, 
            simulateReservedQueue: simulateReservedQueue, 
            statusUpdateInterval: statusUpdateInterval, 
            tags: tags, 
            userMetadata: userMetadata
        )
        return try await self.createJob(input, logger: logger)
    }

    /// Create a new job template. For information about job templates see the User Guide at http://docs.aws.amazon.com/mediaconvert/latest/ug/what-is.html
    @Sendable
    @inlinable
    public func createJobTemplate(_ input: CreateJobTemplateRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> CreateJobTemplateResponse {
        try await self.client.execute(
            operation: "CreateJobTemplate", 
            path: "/2017-08-29/jobTemplates", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Create a new job template. For information about job templates see the User Guide at http://docs.aws.amazon.com/mediaconvert/latest/ug/what-is.html
    ///
    /// Parameters:
    ///   - accelerationSettings: Accelerated transcoding can significantly speed up jobs with long, visually complex content. Outputs that use this feature incur pro-tier pricing. For information about feature limitations, see the AWS Elemental MediaConvert User Guide.
    ///   - category: Optional. A category for the job template you are creating
    ///   - description: Optional. A description of the job template you are creating.
    ///   - hopDestinations: Optional. Use queue hopping to avoid overly long waits in the backlog of the queue that you submit your job to. Specify an alternate queue and the maximum time that your job will wait in the initial queue before hopping. For more information about this feature, see the AWS Elemental MediaConvert User Guide.
    ///   - name: The name of the job template you are creating.
    ///   - priority: Specify the relative priority for this job. In any given queue, the service begins processing the job with the highest value first. When more than one job has the same priority, the service begins processing the job that you submitted first. If you don't specify a priority, the service uses the default value 0.
    ///   - queue: Optional. The queue that jobs created from this template are assigned to. If you don't specify this, jobs will go to the default queue.
    ///   - settings: JobTemplateSettings contains all the transcode settings saved in the template that will be applied to jobs created from it.
    ///   - statusUpdateInterval: Specify how often MediaConvert sends STATUS_UPDATE events to Amazon CloudWatch Events. Set the interval, in seconds, between status updates. MediaConvert sends an update at this interval from the time the service begins processing your job to the time it completes the transcode or encounters an error.
    ///   - tags: The tags that you want to add to the resource. You can tag resources with a key-value pair or with only a key.
    ///   - logger: Logger use during operation
    @inlinable
    public func createJobTemplate(
        accelerationSettings: AccelerationSettings? = nil,
        category: String? = nil,
        description: String? = nil,
        hopDestinations: [HopDestination]? = nil,
        name: String? = nil,
        priority: Int? = nil,
        queue: String? = nil,
        settings: JobTemplateSettings? = nil,
        statusUpdateInterval: StatusUpdateInterval? = nil,
        tags: [String: String]? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> CreateJobTemplateResponse {
        let input = CreateJobTemplateRequest(
            accelerationSettings: accelerationSettings, 
            category: category, 
            description: description, 
            hopDestinations: hopDestinations, 
            name: name, 
            priority: priority, 
            queue: queue, 
            settings: settings, 
            statusUpdateInterval: statusUpdateInterval, 
            tags: tags
        )
        return try await self.createJobTemplate(input, logger: logger)
    }

    /// Create a new preset. For information about job templates see the User Guide at http://docs.aws.amazon.com/mediaconvert/latest/ug/what-is.html
    @Sendable
    @inlinable
    public func createPreset(_ input: CreatePresetRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> CreatePresetResponse {
        try await self.client.execute(
            operation: "CreatePreset", 
            path: "/2017-08-29/presets", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Create a new preset. For information about job templates see the User Guide at http://docs.aws.amazon.com/mediaconvert/latest/ug/what-is.html
    ///
    /// Parameters:
    ///   - category: Optional. A category for the preset you are creating.
    ///   - description: Optional. A description of the preset you are creating.
    ///   - name: The name of the preset you are creating.
    ///   - settings: Settings for preset
    ///   - tags: The tags that you want to add to the resource. You can tag resources with a key-value pair or with only a key.
    ///   - logger: Logger use during operation
    @inlinable
    public func createPreset(
        category: String? = nil,
        description: String? = nil,
        name: String? = nil,
        settings: PresetSettings? = nil,
        tags: [String: String]? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> CreatePresetResponse {
        let input = CreatePresetRequest(
            category: category, 
            description: description, 
            name: name, 
            settings: settings, 
            tags: tags
        )
        return try await self.createPreset(input, logger: logger)
    }

    /// Create a new transcoding queue. For information about queues, see Working With Queues in the User Guide at https://docs.aws.amazon.com/mediaconvert/latest/ug/working-with-queues.html
    @Sendable
    @inlinable
    public func createQueue(_ input: CreateQueueRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> CreateQueueResponse {
        try await self.client.execute(
            operation: "CreateQueue", 
            path: "/2017-08-29/queues", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Create a new transcoding queue. For information about queues, see Working With Queues in the User Guide at https://docs.aws.amazon.com/mediaconvert/latest/ug/working-with-queues.html
    ///
    /// Parameters:
    ///   - concurrentJobs: Specify the maximum number of jobs your queue can process concurrently. For on-demand queues, the value you enter is constrained by your service quotas for Maximum concurrent jobs, per on-demand queue and Maximum concurrent jobs, per account. For reserved queues, specify the number of jobs you can process concurrently in your reservation plan instead.
    ///   - description: Optional. A description of the queue that you are creating.
    ///   - name: The name of the queue that you are creating.
    ///   - pricingPlan: Specifies whether the pricing plan for the queue is on-demand or reserved. For on-demand, you pay per minute, billed in increments of .01 minute. For reserved, you pay for the transcoding capacity of the entire queue, regardless of how much or how little you use it. Reserved pricing requires a 12-month commitment. When you use the API to create a queue, the default is on-demand.
    ///   - reservationPlanSettings: Details about the pricing plan for your reserved queue. Required for reserved queues and not applicable to on-demand queues.
    ///   - status: Initial state of the queue. If you create a paused queue, then jobs in that queue won't begin.
    ///   - tags: The tags that you want to add to the resource. You can tag resources with a key-value pair or with only a key.
    ///   - logger: Logger use during operation
    @inlinable
    public func createQueue(
        concurrentJobs: Int? = nil,
        description: String? = nil,
        name: String? = nil,
        pricingPlan: PricingPlan? = nil,
        reservationPlanSettings: ReservationPlanSettings? = nil,
        status: QueueStatus? = nil,
        tags: [String: String]? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> CreateQueueResponse {
        let input = CreateQueueRequest(
            concurrentJobs: concurrentJobs, 
            description: description, 
            name: name, 
            pricingPlan: pricingPlan, 
            reservationPlanSettings: reservationPlanSettings, 
            status: status, 
            tags: tags
        )
        return try await self.createQueue(input, logger: logger)
    }

    /// Permanently delete a job template you have created.
    @Sendable
    @inlinable
    public func deleteJobTemplate(_ input: DeleteJobTemplateRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> DeleteJobTemplateResponse {
        try await self.client.execute(
            operation: "DeleteJobTemplate", 
            path: "/2017-08-29/jobTemplates/{Name}", 
            httpMethod: .DELETE, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Permanently delete a job template you have created.
    ///
    /// Parameters:
    ///   - name: The name of the job template to be deleted.
    ///   - logger: Logger use during operation
    @inlinable
    public func deleteJobTemplate(
        name: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> DeleteJobTemplateResponse {
        let input = DeleteJobTemplateRequest(
            name: name
        )
        return try await self.deleteJobTemplate(input, logger: logger)
    }

    /// Permanently delete a policy that you created.
    @Sendable
    @inlinable
    public func deletePolicy(_ input: DeletePolicyRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> DeletePolicyResponse {
        try await self.client.execute(
            operation: "DeletePolicy", 
            path: "/2017-08-29/policy", 
            httpMethod: .DELETE, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Permanently delete a policy that you created.
    ///
    /// Parameters:
    ///   - logger: Logger use during operation
    @inlinable
    public func deletePolicy(
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> DeletePolicyResponse {
        let input = DeletePolicyRequest(
        )
        return try await self.deletePolicy(input, logger: logger)
    }

    /// Permanently delete a preset you have created.
    @Sendable
    @inlinable
    public func deletePreset(_ input: DeletePresetRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> DeletePresetResponse {
        try await self.client.execute(
            operation: "DeletePreset", 
            path: "/2017-08-29/presets/{Name}", 
            httpMethod: .DELETE, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Permanently delete a preset you have created.
    ///
    /// Parameters:
    ///   - name: The name of the preset to be deleted.
    ///   - logger: Logger use during operation
    @inlinable
    public func deletePreset(
        name: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> DeletePresetResponse {
        let input = DeletePresetRequest(
            name: name
        )
        return try await self.deletePreset(input, logger: logger)
    }

    /// Permanently delete a queue you have created.
    @Sendable
    @inlinable
    public func deleteQueue(_ input: DeleteQueueRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> DeleteQueueResponse {
        try await self.client.execute(
            operation: "DeleteQueue", 
            path: "/2017-08-29/queues/{Name}", 
            httpMethod: .DELETE, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Permanently delete a queue you have created.
    ///
    /// Parameters:
    ///   - name: The name of the queue that you want to delete.
    ///   - logger: Logger use during operation
    @inlinable
    public func deleteQueue(
        name: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> DeleteQueueResponse {
        let input = DeleteQueueRequest(
            name: name
        )
        return try await self.deleteQueue(input, logger: logger)
    }

    /// Send a request with an empty body to the regional API endpoint to get your account API endpoint. Note that DescribeEndpoints is no longer required. We recommend that you send your requests directly to the regional endpoint instead.
    @available(*, deprecated, message: "DescribeEndpoints and account specific endpoints are no longer required. We recommend that you send your requests directly to the regional endpoint instead.")
    @Sendable
    @inlinable
    public func describeEndpoints(_ input: DescribeEndpointsRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> DescribeEndpointsResponse {
        try await self.client.execute(
            operation: "DescribeEndpoints", 
            path: "/2017-08-29/endpoints", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Send a request with an empty body to the regional API endpoint to get your account API endpoint. Note that DescribeEndpoints is no longer required. We recommend that you send your requests directly to the regional endpoint instead.
    ///
    /// Parameters:
    ///   - maxResults: Optional. Max number of endpoints, up to twenty, that will be returned at one time.
    ///   - mode: Optional field, defaults to DEFAULT. Specify DEFAULT for this operation to return your endpoints if any exist, or to create an endpoint for you and return it if one doesn't already exist. Specify GET_ONLY to return your endpoints if any exist, or an empty list if none exist.
    ///   - nextToken: Use this string, provided with the response to a previous request, to request the next batch of endpoints.
    ///   - logger: Logger use during operation
    @available(*, deprecated, message: "DescribeEndpoints and account specific endpoints are no longer required. We recommend that you send your requests directly to the regional endpoint instead.")
    @inlinable
    public func describeEndpoints(
        maxResults: Int? = nil,
        mode: DescribeEndpointsMode? = nil,
        nextToken: String? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> DescribeEndpointsResponse {
        let input = DescribeEndpointsRequest(
            maxResults: maxResults, 
            mode: mode, 
            nextToken: nextToken
        )
        return try await self.describeEndpoints(input, logger: logger)
    }

    /// Removes an association between the Amazon Resource Name (ARN) of an AWS Certificate Manager (ACM) certificate and an AWS Elemental MediaConvert resource.
    @Sendable
    @inlinable
    public func disassociateCertificate(_ input: DisassociateCertificateRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> DisassociateCertificateResponse {
        try await self.client.execute(
            operation: "DisassociateCertificate", 
            path: "/2017-08-29/certificates/{Arn}", 
            httpMethod: .DELETE, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Removes an association between the Amazon Resource Name (ARN) of an AWS Certificate Manager (ACM) certificate and an AWS Elemental MediaConvert resource.
    ///
    /// Parameters:
    ///   - arn: The ARN of the ACM certificate that you want to disassociate from your MediaConvert resource.
    ///   - logger: Logger use during operation
    @inlinable
    public func disassociateCertificate(
        arn: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> DisassociateCertificateResponse {
        let input = DisassociateCertificateRequest(
            arn: arn
        )
        return try await self.disassociateCertificate(input, logger: logger)
    }

    /// Retrieve the JSON for a specific transcoding job.
    @Sendable
    @inlinable
    public func getJob(_ input: GetJobRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> GetJobResponse {
        try await self.client.execute(
            operation: "GetJob", 
            path: "/2017-08-29/jobs/{Id}", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Retrieve the JSON for a specific transcoding job.
    ///
    /// Parameters:
    ///   - id: the job ID of the job.
    ///   - logger: Logger use during operation
    @inlinable
    public func getJob(
        id: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> GetJobResponse {
        let input = GetJobRequest(
            id: id
        )
        return try await self.getJob(input, logger: logger)
    }

    /// Retrieve the JSON for a specific job template.
    @Sendable
    @inlinable
    public func getJobTemplate(_ input: GetJobTemplateRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> GetJobTemplateResponse {
        try await self.client.execute(
            operation: "GetJobTemplate", 
            path: "/2017-08-29/jobTemplates/{Name}", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Retrieve the JSON for a specific job template.
    ///
    /// Parameters:
    ///   - name: The name of the job template.
    ///   - logger: Logger use during operation
    @inlinable
    public func getJobTemplate(
        name: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> GetJobTemplateResponse {
        let input = GetJobTemplateRequest(
            name: name
        )
        return try await self.getJobTemplate(input, logger: logger)
    }

    /// Retrieve the JSON for your policy.
    @Sendable
    @inlinable
    public func getPolicy(_ input: GetPolicyRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> GetPolicyResponse {
        try await self.client.execute(
            operation: "GetPolicy", 
            path: "/2017-08-29/policy", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Retrieve the JSON for your policy.
    ///
    /// Parameters:
    ///   - logger: Logger use during operation
    @inlinable
    public func getPolicy(
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> GetPolicyResponse {
        let input = GetPolicyRequest(
        )
        return try await self.getPolicy(input, logger: logger)
    }

    /// Retrieve the JSON for a specific preset.
    @Sendable
    @inlinable
    public func getPreset(_ input: GetPresetRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> GetPresetResponse {
        try await self.client.execute(
            operation: "GetPreset", 
            path: "/2017-08-29/presets/{Name}", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Retrieve the JSON for a specific preset.
    ///
    /// Parameters:
    ///   - name: The name of the preset.
    ///   - logger: Logger use during operation
    @inlinable
    public func getPreset(
        name: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> GetPresetResponse {
        let input = GetPresetRequest(
            name: name
        )
        return try await self.getPreset(input, logger: logger)
    }

    /// Retrieve the JSON for a specific queue.
    @Sendable
    @inlinable
    public func getQueue(_ input: GetQueueRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> GetQueueResponse {
        try await self.client.execute(
            operation: "GetQueue", 
            path: "/2017-08-29/queues/{Name}", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Retrieve the JSON for a specific queue.
    ///
    /// Parameters:
    ///   - name: The name of the queue that you want information about.
    ///   - logger: Logger use during operation
    @inlinable
    public func getQueue(
        name: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> GetQueueResponse {
        let input = GetQueueRequest(
            name: name
        )
        return try await self.getQueue(input, logger: logger)
    }

    /// Retrieve a JSON array of up to twenty of your job templates. This will return the templates themselves, not just a list of them. To retrieve the next twenty templates, use the nextToken string returned with the array
    @Sendable
    @inlinable
    public func listJobTemplates(_ input: ListJobTemplatesRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> ListJobTemplatesResponse {
        try await self.client.execute(
            operation: "ListJobTemplates", 
            path: "/2017-08-29/jobTemplates", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Retrieve a JSON array of up to twenty of your job templates. This will return the templates themselves, not just a list of them. To retrieve the next twenty templates, use the nextToken string returned with the array
    ///
    /// Parameters:
    ///   - category: Optionally, specify a job template category to limit responses to only job templates from that category.
    ///   - listBy: Optional. When you request a list of job templates, you can choose to list them alphabetically by NAME or chronologically by CREATION_DATE. If you don't specify, the service will list them by name.
    ///   - maxResults: Optional. Number of job templates, up to twenty, that will be returned at one time.
    ///   - nextToken: Use this string, provided with the response to a previous request, to request the next batch of job templates.
    ///   - order: Optional. When you request lists of resources, you can specify whether they are sorted in ASCENDING or DESCENDING order. Default varies by resource.
    ///   - logger: Logger use during operation
    @inlinable
    public func listJobTemplates(
        category: String? = nil,
        listBy: JobTemplateListBy? = nil,
        maxResults: Int? = nil,
        nextToken: String? = nil,
        order: Order? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ListJobTemplatesResponse {
        let input = ListJobTemplatesRequest(
            category: category, 
            listBy: listBy, 
            maxResults: maxResults, 
            nextToken: nextToken, 
            order: order
        )
        return try await self.listJobTemplates(input, logger: logger)
    }

    /// Retrieve a JSON array of up to twenty of your most recently created jobs. This array includes in-process, completed, and errored jobs. This will return the jobs themselves, not just a list of the jobs. To retrieve the twenty next most recent jobs, use the nextToken string returned with the array.
    @Sendable
    @inlinable
    public func listJobs(_ input: ListJobsRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> ListJobsResponse {
        try await self.client.execute(
            operation: "ListJobs", 
            path: "/2017-08-29/jobs", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Retrieve a JSON array of up to twenty of your most recently created jobs. This array includes in-process, completed, and errored jobs. This will return the jobs themselves, not just a list of the jobs. To retrieve the twenty next most recent jobs, use the nextToken string returned with the array.
    ///
    /// Parameters:
    ///   - maxResults: Optional. Number of jobs, up to twenty, that will be returned at one time.
    ///   - nextToken: Optional. Use this string, provided with the response to a previous request, to request the next batch of jobs.
    ///   - order: Optional. When you request lists of resources, you can specify whether they are sorted in ASCENDING or DESCENDING order. Default varies by resource.
    ///   - queue: Optional. Provide a queue name to get back only jobs from that queue.
    ///   - status: Optional. A job's status can be SUBMITTED, PROGRESSING, COMPLETE, CANCELED, or ERROR.
    ///   - logger: Logger use during operation
    @inlinable
    public func listJobs(
        maxResults: Int? = nil,
        nextToken: String? = nil,
        order: Order? = nil,
        queue: String? = nil,
        status: JobStatus? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ListJobsResponse {
        let input = ListJobsRequest(
            maxResults: maxResults, 
            nextToken: nextToken, 
            order: order, 
            queue: queue, 
            status: status
        )
        return try await self.listJobs(input, logger: logger)
    }

    /// Retrieve a JSON array of up to twenty of your presets. This will return the presets themselves, not just a list of them. To retrieve the next twenty presets, use the nextToken string returned with the array.
    @Sendable
    @inlinable
    public func listPresets(_ input: ListPresetsRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> ListPresetsResponse {
        try await self.client.execute(
            operation: "ListPresets", 
            path: "/2017-08-29/presets", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Retrieve a JSON array of up to twenty of your presets. This will return the presets themselves, not just a list of them. To retrieve the next twenty presets, use the nextToken string returned with the array.
    ///
    /// Parameters:
    ///   - category: Optionally, specify a preset category to limit responses to only presets from that category.
    ///   - listBy: Optional. When you request a list of presets, you can choose to list them alphabetically by NAME or chronologically by CREATION_DATE. If you don't specify, the service will list them by name.
    ///   - maxResults: Optional. Number of presets, up to twenty, that will be returned at one time
    ///   - nextToken: Use this string, provided with the response to a previous request, to request the next batch of presets.
    ///   - order: Optional. When you request lists of resources, you can specify whether they are sorted in ASCENDING or DESCENDING order. Default varies by resource.
    ///   - logger: Logger use during operation
    @inlinable
    public func listPresets(
        category: String? = nil,
        listBy: PresetListBy? = nil,
        maxResults: Int? = nil,
        nextToken: String? = nil,
        order: Order? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ListPresetsResponse {
        let input = ListPresetsRequest(
            category: category, 
            listBy: listBy, 
            maxResults: maxResults, 
            nextToken: nextToken, 
            order: order
        )
        return try await self.listPresets(input, logger: logger)
    }

    /// Retrieve a JSON array of up to twenty of your queues. This will return the queues themselves, not just a list of them. To retrieve the next twenty queues, use the nextToken string returned with the array.
    @Sendable
    @inlinable
    public func listQueues(_ input: ListQueuesRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> ListQueuesResponse {
        try await self.client.execute(
            operation: "ListQueues", 
            path: "/2017-08-29/queues", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Retrieve a JSON array of up to twenty of your queues. This will return the queues themselves, not just a list of them. To retrieve the next twenty queues, use the nextToken string returned with the array.
    ///
    /// Parameters:
    ///   - listBy: Optional. When you request a list of queues, you can choose to list them alphabetically by NAME or chronologically by CREATION_DATE. If you don't specify, the service will list them by creation date.
    ///   - maxResults: Optional. Number of queues, up to twenty, that will be returned at one time.
    ///   - nextToken: Use this string, provided with the response to a previous request, to request the next batch of queues.
    ///   - order: Optional. When you request lists of resources, you can specify whether they are sorted in ASCENDING or DESCENDING order. Default varies by resource.
    ///   - logger: Logger use during operation
    @inlinable
    public func listQueues(
        listBy: QueueListBy? = nil,
        maxResults: Int? = nil,
        nextToken: String? = nil,
        order: Order? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ListQueuesResponse {
        let input = ListQueuesRequest(
            listBy: listBy, 
            maxResults: maxResults, 
            nextToken: nextToken, 
            order: order
        )
        return try await self.listQueues(input, logger: logger)
    }

    /// Retrieve the tags for a MediaConvert resource.
    @Sendable
    @inlinable
    public func listTagsForResource(_ input: ListTagsForResourceRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> ListTagsForResourceResponse {
        try await self.client.execute(
            operation: "ListTagsForResource", 
            path: "/2017-08-29/tags/{Arn}", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Retrieve the tags for a MediaConvert resource.
    ///
    /// Parameters:
    ///   - arn: The Amazon Resource Name (ARN) of the resource that you want to list tags for. To get the ARN, send a GET request with the resource name.
    ///   - logger: Logger use during operation
    @inlinable
    public func listTagsForResource(
        arn: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ListTagsForResourceResponse {
        let input = ListTagsForResourceRequest(
            arn: arn
        )
        return try await self.listTagsForResource(input, logger: logger)
    }

    /// Retrieve a JSON array of all available Job engine versions and the date they expire.
    @Sendable
    @inlinable
    public func listVersions(_ input: ListVersionsRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> ListVersionsResponse {
        try await self.client.execute(
            operation: "ListVersions", 
            path: "/2017-08-29/versions", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Retrieve a JSON array of all available Job engine versions and the date they expire.
    ///
    /// Parameters:
    ///   - maxResults: Optional. Number of valid Job engine versions, up to twenty, that will be returned at one time.
    ///   - nextToken: Optional. Use this string, provided with the response to a previous request, to request the next batch of Job engine versions.
    ///   - logger: Logger use during operation
    @inlinable
    public func listVersions(
        maxResults: Int? = nil,
        nextToken: String? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ListVersionsResponse {
        let input = ListVersionsRequest(
            maxResults: maxResults, 
            nextToken: nextToken
        )
        return try await self.listVersions(input, logger: logger)
    }

    /// Create or change your policy. For more information about policies, see the user guide at http://docs.aws.amazon.com/mediaconvert/latest/ug/what-is.html
    @Sendable
    @inlinable
    public func putPolicy(_ input: PutPolicyRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> PutPolicyResponse {
        try await self.client.execute(
            operation: "PutPolicy", 
            path: "/2017-08-29/policy", 
            httpMethod: .PUT, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Create or change your policy. For more information about policies, see the user guide at http://docs.aws.amazon.com/mediaconvert/latest/ug/what-is.html
    ///
    /// Parameters:
    ///   - policy: A policy configures behavior that you allow or disallow for your account. For information about MediaConvert policies, see the user guide at http://docs.aws.amazon.com/mediaconvert/latest/ug/what-is.html
    ///   - logger: Logger use during operation
    @inlinable
    public func putPolicy(
        policy: Policy? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> PutPolicyResponse {
        let input = PutPolicyRequest(
            policy: policy
        )
        return try await self.putPolicy(input, logger: logger)
    }

    /// Retrieve a JSON array that includes job details for up to twenty of your most recent jobs. Optionally filter results further according to input file, queue, or status. To retrieve the twenty next most recent jobs, use the nextToken string returned with the array.
    @Sendable
    @inlinable
    public func searchJobs(_ input: SearchJobsRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> SearchJobsResponse {
        try await self.client.execute(
            operation: "SearchJobs", 
            path: "/2017-08-29/search", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Retrieve a JSON array that includes job details for up to twenty of your most recent jobs. Optionally filter results further according to input file, queue, or status. To retrieve the twenty next most recent jobs, use the nextToken string returned with the array.
    ///
    /// Parameters:
    ///   - inputFile: Optional. Provide your input file URL or your partial input file name. The maximum length for an input file is 300 characters.
    ///   - maxResults: Optional. Number of jobs, up to twenty, that will be returned at one time.
    ///   - nextToken: Optional. Use this string, provided with the response to a previous request, to request the next batch of jobs.
    ///   - order: Optional. When you request lists of resources, you can specify whether they are sorted in ASCENDING or DESCENDING order. Default varies by resource.
    ///   - queue: Optional. Provide a queue name, or a queue ARN, to return only jobs from that queue.
    ///   - status: Optional. A job's status can be SUBMITTED, PROGRESSING, COMPLETE, CANCELED, or ERROR.
    ///   - logger: Logger use during operation
    @inlinable
    public func searchJobs(
        inputFile: String? = nil,
        maxResults: Int? = nil,
        nextToken: String? = nil,
        order: Order? = nil,
        queue: String? = nil,
        status: JobStatus? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> SearchJobsResponse {
        let input = SearchJobsRequest(
            inputFile: inputFile, 
            maxResults: maxResults, 
            nextToken: nextToken, 
            order: order, 
            queue: queue, 
            status: status
        )
        return try await self.searchJobs(input, logger: logger)
    }

    /// Add tags to a MediaConvert queue, preset, or job template. For information about tagging, see the User Guide at https://docs.aws.amazon.com/mediaconvert/latest/ug/tagging-resources.html
    @Sendable
    @inlinable
    public func tagResource(_ input: TagResourceRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> TagResourceResponse {
        try await self.client.execute(
            operation: "TagResource", 
            path: "/2017-08-29/tags", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Add tags to a MediaConvert queue, preset, or job template. For information about tagging, see the User Guide at https://docs.aws.amazon.com/mediaconvert/latest/ug/tagging-resources.html
    ///
    /// Parameters:
    ///   - arn: The Amazon Resource Name (ARN) of the resource that you want to tag. To get the ARN, send a GET request with the resource name.
    ///   - tags: The tags that you want to add to the resource. You can tag resources with a key-value pair or with only a key.
    ///   - logger: Logger use during operation
    @inlinable
    public func tagResource(
        arn: String? = nil,
        tags: [String: String]? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> TagResourceResponse {
        let input = TagResourceRequest(
            arn: arn, 
            tags: tags
        )
        return try await self.tagResource(input, logger: logger)
    }

    /// Remove tags from a MediaConvert queue, preset, or job template. For information about tagging, see the User Guide at https://docs.aws.amazon.com/mediaconvert/latest/ug/tagging-resources.html
    @Sendable
    @inlinable
    public func untagResource(_ input: UntagResourceRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> UntagResourceResponse {
        try await self.client.execute(
            operation: "UntagResource", 
            path: "/2017-08-29/tags/{Arn}", 
            httpMethod: .PUT, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Remove tags from a MediaConvert queue, preset, or job template. For information about tagging, see the User Guide at https://docs.aws.amazon.com/mediaconvert/latest/ug/tagging-resources.html
    ///
    /// Parameters:
    ///   - arn: The Amazon Resource Name (ARN) of the resource that you want to remove tags from. To get the ARN, send a GET request with the resource name.
    ///   - tagKeys: The keys of the tags that you want to remove from the resource.
    ///   - logger: Logger use during operation
    @inlinable
    public func untagResource(
        arn: String,
        tagKeys: [String]? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> UntagResourceResponse {
        let input = UntagResourceRequest(
            arn: arn, 
            tagKeys: tagKeys
        )
        return try await self.untagResource(input, logger: logger)
    }

    /// Modify one of your existing job templates.
    @Sendable
    @inlinable
    public func updateJobTemplate(_ input: UpdateJobTemplateRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> UpdateJobTemplateResponse {
        try await self.client.execute(
            operation: "UpdateJobTemplate", 
            path: "/2017-08-29/jobTemplates/{Name}", 
            httpMethod: .PUT, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Modify one of your existing job templates.
    ///
    /// Parameters:
    ///   - accelerationSettings: Accelerated transcoding can significantly speed up jobs with long, visually complex content. Outputs that use this feature incur pro-tier pricing. For information about feature limitations, see the AWS Elemental MediaConvert User Guide.
    ///   - category: The new category for the job template, if you are changing it.
    ///   - description: The new description for the job template, if you are changing it.
    ///   - hopDestinations: Optional list of hop destinations.
    ///   - name: The name of the job template you are modifying
    ///   - priority: Specify the relative priority for this job. In any given queue, the service begins processing the job with the highest value first. When more than one job has the same priority, the service begins processing the job that you submitted first. If you don't specify a priority, the service uses the default value 0.
    ///   - queue: The new queue for the job template, if you are changing it.
    ///   - settings: JobTemplateSettings contains all the transcode settings saved in the template that will be applied to jobs created from it.
    ///   - statusUpdateInterval: Specify how often MediaConvert sends STATUS_UPDATE events to Amazon CloudWatch Events. Set the interval, in seconds, between status updates. MediaConvert sends an update at this interval from the time the service begins processing your job to the time it completes the transcode or encounters an error.
    ///   - logger: Logger use during operation
    @inlinable
    public func updateJobTemplate(
        accelerationSettings: AccelerationSettings? = nil,
        category: String? = nil,
        description: String? = nil,
        hopDestinations: [HopDestination]? = nil,
        name: String,
        priority: Int? = nil,
        queue: String? = nil,
        settings: JobTemplateSettings? = nil,
        statusUpdateInterval: StatusUpdateInterval? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> UpdateJobTemplateResponse {
        let input = UpdateJobTemplateRequest(
            accelerationSettings: accelerationSettings, 
            category: category, 
            description: description, 
            hopDestinations: hopDestinations, 
            name: name, 
            priority: priority, 
            queue: queue, 
            settings: settings, 
            statusUpdateInterval: statusUpdateInterval
        )
        return try await self.updateJobTemplate(input, logger: logger)
    }

    /// Modify one of your existing presets.
    @Sendable
    @inlinable
    public func updatePreset(_ input: UpdatePresetRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> UpdatePresetResponse {
        try await self.client.execute(
            operation: "UpdatePreset", 
            path: "/2017-08-29/presets/{Name}", 
            httpMethod: .PUT, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Modify one of your existing presets.
    ///
    /// Parameters:
    ///   - category: The new category for the preset, if you are changing it.
    ///   - description: The new description for the preset, if you are changing it.
    ///   - name: The name of the preset you are modifying.
    ///   - settings: Settings for preset
    ///   - logger: Logger use during operation
    @inlinable
    public func updatePreset(
        category: String? = nil,
        description: String? = nil,
        name: String,
        settings: PresetSettings? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> UpdatePresetResponse {
        let input = UpdatePresetRequest(
            category: category, 
            description: description, 
            name: name, 
            settings: settings
        )
        return try await self.updatePreset(input, logger: logger)
    }

    /// Modify one of your existing queues.
    @Sendable
    @inlinable
    public func updateQueue(_ input: UpdateQueueRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> UpdateQueueResponse {
        try await self.client.execute(
            operation: "UpdateQueue", 
            path: "/2017-08-29/queues/{Name}", 
            httpMethod: .PUT, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Modify one of your existing queues.
    ///
    /// Parameters:
    ///   - concurrentJobs: Specify the maximum number of jobs your queue can process concurrently. For on-demand queues, the value you enter is constrained by your service quotas for Maximum concurrent jobs, per on-demand queue and Maximum concurrent jobs, per account. For reserved queues, update your reservation plan instead in order to increase your yearly commitment.
    ///   - description: The new description for the queue, if you are changing it.
    ///   - name: The name of the queue that you are modifying.
    ///   - reservationPlanSettings: The new details of your pricing plan for your reserved queue. When you set up a new pricing plan to replace an expired one, you enter into another 12-month commitment. When you add capacity to your queue by increasing the number of RTS, you extend the term of your commitment to 12 months from when you add capacity. After you make these commitments, you can't cancel them.
    ///   - status: Pause or activate a queue by changing its status between ACTIVE and PAUSED. If you pause a queue, jobs in that queue won't begin. Jobs that are running when you pause the queue continue to run until they finish or result in an error.
    ///   - logger: Logger use during operation
    @inlinable
    public func updateQueue(
        concurrentJobs: Int? = nil,
        description: String? = nil,
        name: String,
        reservationPlanSettings: ReservationPlanSettings? = nil,
        status: QueueStatus? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> UpdateQueueResponse {
        let input = UpdateQueueRequest(
            concurrentJobs: concurrentJobs, 
            description: description, 
            name: name, 
            reservationPlanSettings: reservationPlanSettings, 
            status: status
        )
        return try await self.updateQueue(input, logger: logger)
    }
}

extension MediaConvert {
    /// Initializer required by `AWSService.with(middlewares:timeout:byteBufferAllocator:options)`. You are not able to use this initializer directly as there are not public
    /// initializers for `AWSServiceConfig.Patch`. Please use `AWSService.with(middlewares:timeout:byteBufferAllocator:options)` instead.
    public init(from: MediaConvert, patch: AWSServiceConfig.Patch) {
        self.client = from.client
        self.config = from.config.with(patch: patch)
    }
}

// MARK: Paginators

@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension MediaConvert {
    /// Return PaginatorSequence for operation ``describeEndpoints(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @available(*, deprecated, message: "DescribeEndpoints and account specific endpoints are no longer required. We recommend that you send your requests directly to the regional endpoint instead.")
    @inlinable
    public func describeEndpointsPaginator(
        _ input: DescribeEndpointsRequest,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<DescribeEndpointsRequest, DescribeEndpointsResponse> {
        return .init(
            input: input,
            command: self.describeEndpoints,
            inputKey: \DescribeEndpointsRequest.nextToken,
            outputKey: \DescribeEndpointsResponse.nextToken,
            logger: logger
        )
    }
    /// Return PaginatorSequence for operation ``describeEndpoints(_:logger:)``.
    ///
    /// - Parameters:
    ///   - maxResults: Optional. Max number of endpoints, up to twenty, that will be returned at one time.
    ///   - mode: Optional field, defaults to DEFAULT. Specify DEFAULT for this operation to return your endpoints if any exist, or to create an endpoint for you and return it if one doesn't already exist. Specify GET_ONLY to return your endpoints if any exist, or an empty list if none exist.
    ///   - logger: Logger used for logging
    @available(*, deprecated, message: "DescribeEndpoints and account specific endpoints are no longer required. We recommend that you send your requests directly to the regional endpoint instead.")
    @inlinable
    public func describeEndpointsPaginator(
        maxResults: Int? = nil,
        mode: DescribeEndpointsMode? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) -> AWSClient.PaginatorSequence<DescribeEndpointsRequest, DescribeEndpointsResponse> {
        let input = DescribeEndpointsRequest(
            maxResults: maxResults, 
            mode: mode
        )
        return self.describeEndpointsPaginator(input, logger: logger)
    }

    /// Return PaginatorSequence for operation ``listJobTemplates(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func listJobTemplatesPaginator(
        _ input: ListJobTemplatesRequest,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<ListJobTemplatesRequest, ListJobTemplatesResponse> {
        return .init(
            input: input,
            command: self.listJobTemplates,
            inputKey: \ListJobTemplatesRequest.nextToken,
            outputKey: \ListJobTemplatesResponse.nextToken,
            logger: logger
        )
    }
    /// Return PaginatorSequence for operation ``listJobTemplates(_:logger:)``.
    ///
    /// - Parameters:
    ///   - category: Optionally, specify a job template category to limit responses to only job templates from that category.
    ///   - listBy: Optional. When you request a list of job templates, you can choose to list them alphabetically by NAME or chronologically by CREATION_DATE. If you don't specify, the service will list them by name.
    ///   - maxResults: Optional. Number of job templates, up to twenty, that will be returned at one time.
    ///   - order: Optional. When you request lists of resources, you can specify whether they are sorted in ASCENDING or DESCENDING order. Default varies by resource.
    ///   - logger: Logger used for logging
    @inlinable
    public func listJobTemplatesPaginator(
        category: String? = nil,
        listBy: JobTemplateListBy? = nil,
        maxResults: Int? = nil,
        order: Order? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) -> AWSClient.PaginatorSequence<ListJobTemplatesRequest, ListJobTemplatesResponse> {
        let input = ListJobTemplatesRequest(
            category: category, 
            listBy: listBy, 
            maxResults: maxResults, 
            order: order
        )
        return self.listJobTemplatesPaginator(input, logger: logger)
    }

    /// Return PaginatorSequence for operation ``listJobs(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func listJobsPaginator(
        _ input: ListJobsRequest,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<ListJobsRequest, ListJobsResponse> {
        return .init(
            input: input,
            command: self.listJobs,
            inputKey: \ListJobsRequest.nextToken,
            outputKey: \ListJobsResponse.nextToken,
            logger: logger
        )
    }
    /// Return PaginatorSequence for operation ``listJobs(_:logger:)``.
    ///
    /// - Parameters:
    ///   - maxResults: Optional. Number of jobs, up to twenty, that will be returned at one time.
    ///   - order: Optional. When you request lists of resources, you can specify whether they are sorted in ASCENDING or DESCENDING order. Default varies by resource.
    ///   - queue: Optional. Provide a queue name to get back only jobs from that queue.
    ///   - status: Optional. A job's status can be SUBMITTED, PROGRESSING, COMPLETE, CANCELED, or ERROR.
    ///   - logger: Logger used for logging
    @inlinable
    public func listJobsPaginator(
        maxResults: Int? = nil,
        order: Order? = nil,
        queue: String? = nil,
        status: JobStatus? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) -> AWSClient.PaginatorSequence<ListJobsRequest, ListJobsResponse> {
        let input = ListJobsRequest(
            maxResults: maxResults, 
            order: order, 
            queue: queue, 
            status: status
        )
        return self.listJobsPaginator(input, logger: logger)
    }

    /// Return PaginatorSequence for operation ``listPresets(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func listPresetsPaginator(
        _ input: ListPresetsRequest,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<ListPresetsRequest, ListPresetsResponse> {
        return .init(
            input: input,
            command: self.listPresets,
            inputKey: \ListPresetsRequest.nextToken,
            outputKey: \ListPresetsResponse.nextToken,
            logger: logger
        )
    }
    /// Return PaginatorSequence for operation ``listPresets(_:logger:)``.
    ///
    /// - Parameters:
    ///   - category: Optionally, specify a preset category to limit responses to only presets from that category.
    ///   - listBy: Optional. When you request a list of presets, you can choose to list them alphabetically by NAME or chronologically by CREATION_DATE. If you don't specify, the service will list them by name.
    ///   - maxResults: Optional. Number of presets, up to twenty, that will be returned at one time
    ///   - order: Optional. When you request lists of resources, you can specify whether they are sorted in ASCENDING or DESCENDING order. Default varies by resource.
    ///   - logger: Logger used for logging
    @inlinable
    public func listPresetsPaginator(
        category: String? = nil,
        listBy: PresetListBy? = nil,
        maxResults: Int? = nil,
        order: Order? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) -> AWSClient.PaginatorSequence<ListPresetsRequest, ListPresetsResponse> {
        let input = ListPresetsRequest(
            category: category, 
            listBy: listBy, 
            maxResults: maxResults, 
            order: order
        )
        return self.listPresetsPaginator(input, logger: logger)
    }

    /// Return PaginatorSequence for operation ``listQueues(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func listQueuesPaginator(
        _ input: ListQueuesRequest,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<ListQueuesRequest, ListQueuesResponse> {
        return .init(
            input: input,
            command: self.listQueues,
            inputKey: \ListQueuesRequest.nextToken,
            outputKey: \ListQueuesResponse.nextToken,
            logger: logger
        )
    }
    /// Return PaginatorSequence for operation ``listQueues(_:logger:)``.
    ///
    /// - Parameters:
    ///   - listBy: Optional. When you request a list of queues, you can choose to list them alphabetically by NAME or chronologically by CREATION_DATE. If you don't specify, the service will list them by creation date.
    ///   - maxResults: Optional. Number of queues, up to twenty, that will be returned at one time.
    ///   - order: Optional. When you request lists of resources, you can specify whether they are sorted in ASCENDING or DESCENDING order. Default varies by resource.
    ///   - logger: Logger used for logging
    @inlinable
    public func listQueuesPaginator(
        listBy: QueueListBy? = nil,
        maxResults: Int? = nil,
        order: Order? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) -> AWSClient.PaginatorSequence<ListQueuesRequest, ListQueuesResponse> {
        let input = ListQueuesRequest(
            listBy: listBy, 
            maxResults: maxResults, 
            order: order
        )
        return self.listQueuesPaginator(input, logger: logger)
    }

    /// Return PaginatorSequence for operation ``listVersions(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func listVersionsPaginator(
        _ input: ListVersionsRequest,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<ListVersionsRequest, ListVersionsResponse> {
        return .init(
            input: input,
            command: self.listVersions,
            inputKey: \ListVersionsRequest.nextToken,
            outputKey: \ListVersionsResponse.nextToken,
            logger: logger
        )
    }
    /// Return PaginatorSequence for operation ``listVersions(_:logger:)``.
    ///
    /// - Parameters:
    ///   - maxResults: Optional. Number of valid Job engine versions, up to twenty, that will be returned at one time.
    ///   - logger: Logger used for logging
    @inlinable
    public func listVersionsPaginator(
        maxResults: Int? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) -> AWSClient.PaginatorSequence<ListVersionsRequest, ListVersionsResponse> {
        let input = ListVersionsRequest(
            maxResults: maxResults
        )
        return self.listVersionsPaginator(input, logger: logger)
    }

    /// Return PaginatorSequence for operation ``searchJobs(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func searchJobsPaginator(
        _ input: SearchJobsRequest,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<SearchJobsRequest, SearchJobsResponse> {
        return .init(
            input: input,
            command: self.searchJobs,
            inputKey: \SearchJobsRequest.nextToken,
            outputKey: \SearchJobsResponse.nextToken,
            logger: logger
        )
    }
    /// Return PaginatorSequence for operation ``searchJobs(_:logger:)``.
    ///
    /// - Parameters:
    ///   - inputFile: Optional. Provide your input file URL or your partial input file name. The maximum length for an input file is 300 characters.
    ///   - maxResults: Optional. Number of jobs, up to twenty, that will be returned at one time.
    ///   - order: Optional. When you request lists of resources, you can specify whether they are sorted in ASCENDING or DESCENDING order. Default varies by resource.
    ///   - queue: Optional. Provide a queue name, or a queue ARN, to return only jobs from that queue.
    ///   - status: Optional. A job's status can be SUBMITTED, PROGRESSING, COMPLETE, CANCELED, or ERROR.
    ///   - logger: Logger used for logging
    @inlinable
    public func searchJobsPaginator(
        inputFile: String? = nil,
        maxResults: Int? = nil,
        order: Order? = nil,
        queue: String? = nil,
        status: JobStatus? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) -> AWSClient.PaginatorSequence<SearchJobsRequest, SearchJobsResponse> {
        let input = SearchJobsRequest(
            inputFile: inputFile, 
            maxResults: maxResults, 
            order: order, 
            queue: queue, 
            status: status
        )
        return self.searchJobsPaginator(input, logger: logger)
    }
}

extension MediaConvert.DescribeEndpointsRequest: AWSPaginateToken {
    @inlinable
    public func usingPaginationToken(_ token: String) -> MediaConvert.DescribeEndpointsRequest {
        return .init(
            maxResults: self.maxResults,
            mode: self.mode,
            nextToken: token
        )
    }
}

extension MediaConvert.ListJobTemplatesRequest: AWSPaginateToken {
    @inlinable
    public func usingPaginationToken(_ token: String) -> MediaConvert.ListJobTemplatesRequest {
        return .init(
            category: self.category,
            listBy: self.listBy,
            maxResults: self.maxResults,
            nextToken: token,
            order: self.order
        )
    }
}

extension MediaConvert.ListJobsRequest: AWSPaginateToken {
    @inlinable
    public func usingPaginationToken(_ token: String) -> MediaConvert.ListJobsRequest {
        return .init(
            maxResults: self.maxResults,
            nextToken: token,
            order: self.order,
            queue: self.queue,
            status: self.status
        )
    }
}

extension MediaConvert.ListPresetsRequest: AWSPaginateToken {
    @inlinable
    public func usingPaginationToken(_ token: String) -> MediaConvert.ListPresetsRequest {
        return .init(
            category: self.category,
            listBy: self.listBy,
            maxResults: self.maxResults,
            nextToken: token,
            order: self.order
        )
    }
}

extension MediaConvert.ListQueuesRequest: AWSPaginateToken {
    @inlinable
    public func usingPaginationToken(_ token: String) -> MediaConvert.ListQueuesRequest {
        return .init(
            listBy: self.listBy,
            maxResults: self.maxResults,
            nextToken: token,
            order: self.order
        )
    }
}

extension MediaConvert.ListVersionsRequest: AWSPaginateToken {
    @inlinable
    public func usingPaginationToken(_ token: String) -> MediaConvert.ListVersionsRequest {
        return .init(
            maxResults: self.maxResults,
            nextToken: token
        )
    }
}

extension MediaConvert.SearchJobsRequest: AWSPaginateToken {
    @inlinable
    public func usingPaginationToken(_ token: String) -> MediaConvert.SearchJobsRequest {
        return .init(
            inputFile: self.inputFile,
            maxResults: self.maxResults,
            nextToken: token,
            order: self.order,
            queue: self.queue,
            status: self.status
        )
    }
}
