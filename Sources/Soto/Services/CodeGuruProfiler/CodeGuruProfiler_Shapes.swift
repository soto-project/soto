//===----------------------------------------------------------------------===//
//
// This source file is part of the Soto for AWS open source project
//
// Copyright (c) 2017-2021 the Soto project authors
// Licensed under Apache License v2.0
//
// See LICENSE.txt for license information
// See CONTRIBUTORS.txt for the list of Soto project authors
//
// SPDX-License-Identifier: Apache-2.0
//
//===----------------------------------------------------------------------===//

// THIS FILE IS AUTOMATICALLY GENERATED by https://github.com/soto-project/soto/tree/main/CodeGenerator. DO NOT EDIT.

import Foundation
import SotoCore

extension CodeGuruProfiler {
    // MARK: Enums

    public enum ActionGroup: String, CustomStringConvertible, Codable {
        case agentpermissions = "agentPermissions"
        public var description: String { return self.rawValue }
    }

    public enum AgentParameterField: String, CustomStringConvertible, Codable {
        case maxstackdepth = "MaxStackDepth"
        case memoryusagelimitpercent = "MemoryUsageLimitPercent"
        case minimumtimeforreportinginmilliseconds = "MinimumTimeForReportingInMilliseconds"
        case reportingintervalinmilliseconds = "ReportingIntervalInMilliseconds"
        case samplingintervalinmilliseconds = "SamplingIntervalInMilliseconds"
        public var description: String { return self.rawValue }
    }

    public enum AggregationPeriod: String, CustomStringConvertible, Codable {
        case p1d = "P1D"
        case pt1h = "PT1H"
        case pt5m = "PT5M"
        public var description: String { return self.rawValue }
    }

    public enum ComputePlatform: String, CustomStringConvertible, Codable {
        case awslambda = "AWSLambda"
        case `default` = "Default"
        public var description: String { return self.rawValue }
    }

    public enum EventPublisher: String, CustomStringConvertible, Codable {
        case anomalydetection = "AnomalyDetection"
        public var description: String { return self.rawValue }
    }

    public enum FeedbackType: String, CustomStringConvertible, Codable {
        case negative = "Negative"
        case positive = "Positive"
        public var description: String { return self.rawValue }
    }

    public enum MetadataField: String, CustomStringConvertible, Codable {
        case agentid = "AgentId"
        case awsrequestid = "AwsRequestId"
        case computeplatform = "ComputePlatform"
        case executionenvironment = "ExecutionEnvironment"
        case lambdafunctionarn = "LambdaFunctionArn"
        case lambdamemorylimitinmb = "LambdaMemoryLimitInMB"
        case lambdapreviousexecutiontimeinmilliseconds = "LambdaPreviousExecutionTimeInMilliseconds"
        case lambdaremainingtimeinmilliseconds = "LambdaRemainingTimeInMilliseconds"
        case lambdatimegapbetweeninvokesinmilliseconds = "LambdaTimeGapBetweenInvokesInMilliseconds"
        public var description: String { return self.rawValue }
    }

    public enum MetricType: String, CustomStringConvertible, Codable {
        case aggregatedrelativetotaltime = "AggregatedRelativeTotalTime"
        public var description: String { return self.rawValue }
    }

    public enum OrderBy: String, CustomStringConvertible, Codable {
        case timestampascending = "TimestampAscending"
        case timestampdescending = "TimestampDescending"
        public var description: String { return self.rawValue }
    }

    // MARK: Shapes

    public struct AddNotificationChannelsRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "profilingGroupName", location: .uri(locationName: "profilingGroupName"))
        ]

        /// One or 2 channels to report to when anomalies are detected.
        public let channels: [Channel]
        /// The name of the profiling group that we are setting up notifications for.
        public let profilingGroupName: String

        public init(channels: [Channel], profilingGroupName: String) {
            self.channels = channels
            self.profilingGroupName = profilingGroupName
        }

        public func validate(name: String) throws {
            try self.channels.forEach {
                try $0.validate(name: "\(name).channels[]")
            }
            try self.validate(self.channels, name: "channels", parent: name, max: 2)
            try self.validate(self.channels, name: "channels", parent: name, min: 1)
            try self.validate(self.profilingGroupName, name: "profilingGroupName", parent: name, max: 255)
            try self.validate(self.profilingGroupName, name: "profilingGroupName", parent: name, min: 1)
            try self.validate(self.profilingGroupName, name: "profilingGroupName", parent: name, pattern: "^[\\w-]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case channels
        }
    }

    public struct AddNotificationChannelsResponse: AWSDecodableShape {
        /// The new notification configuration for this profiling group.
        public let notificationConfiguration: NotificationConfiguration?

        public init(notificationConfiguration: NotificationConfiguration? = nil) {
            self.notificationConfiguration = notificationConfiguration
        }

        private enum CodingKeys: String, CodingKey {
            case notificationConfiguration
        }
    }

    public struct AgentConfiguration: AWSDecodableShape {
        ///  Parameters used by the profiler. The valid parameters are:     MaxStackDepth - The maximum depth of the stacks in the code that is represented in the profile. For example, if CodeGuru Profiler finds a method A, which calls method B, which calls method C, which calls method D, then the depth is 4. If the maxDepth is set to 2, then the profiler evaluates A and B.     MemoryUsageLimitPercent - The percentage of memory that is used by the profiler.    MinimumTimeForReportingInMilliseconds - The minimum time in milliseconds between sending reports.     ReportingIntervalInMilliseconds - The reporting interval in milliseconds used to report profiles.     SamplingIntervalInMilliseconds - The sampling interval in milliseconds that is used to profile samples.
        public let agentParameters: [AgentParameterField: String]?
        ///  How long a profiling agent should send profiling data using  ConfigureAgent . For example, if this is set to 300, the profiling agent calls  ConfigureAgent  every 5 minutes to submit the profiled data collected during that period.
        public let periodInSeconds: Int
        ///  A Boolean that specifies whether the profiling agent collects profiling data or not. Set to true to enable profiling.
        public let shouldProfile: Bool

        public init(agentParameters: [AgentParameterField: String]? = nil, periodInSeconds: Int, shouldProfile: Bool) {
            self.agentParameters = agentParameters
            self.periodInSeconds = periodInSeconds
            self.shouldProfile = shouldProfile
        }

        private enum CodingKeys: String, CodingKey {
            case agentParameters
            case periodInSeconds
            case shouldProfile
        }
    }

    public struct AgentOrchestrationConfig: AWSEncodableShape & AWSDecodableShape {
        ///  A Boolean that specifies whether the profiling agent collects profiling data or not. Set to true to enable profiling.
        public let profilingEnabled: Bool

        public init(profilingEnabled: Bool) {
            self.profilingEnabled = profilingEnabled
        }

        private enum CodingKeys: String, CodingKey {
            case profilingEnabled
        }
    }

    public struct AggregatedProfileTime: AWSDecodableShape {
        ///  The aggregation period. This indicates the period during which an aggregation profile collects posted agent profiles for a profiling group. Use one of three valid durations that are specified using the ISO 8601 format.     P1D — 1 day     PT1H — 1 hour     PT5M — 5 minutes
        public let period: AggregationPeriod?
        ///  The time that aggregation of posted agent profiles for a profiling group starts. The aggregation profile contains profiles posted by the agent starting at this time for an aggregation period specified by the period property of the AggregatedProfileTime object.   Specify start using the ISO 8601 format. For example, 2020-06-01T13:15:02.001Z represents 1 millisecond past June 1, 2020 1:15:02 PM UTC.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var start: Date?

        public init(period: AggregationPeriod? = nil, start: Date? = nil) {
            self.period = period
            self.start = start
        }

        private enum CodingKeys: String, CodingKey {
            case period
            case start
        }
    }

    public struct Anomaly: AWSDecodableShape {
        ///  A list of the instances of the detected anomalies during the requested period.
        public let instances: [AnomalyInstance]
        ///  Details about the metric that the analysis used when it detected the anomaly. The metric includes the name of the frame that was analyzed with the type and thread states used to derive the metric value for that frame.
        public let metric: Metric
        /// The reason for which metric was flagged as anomalous.
        public let reason: String

        public init(instances: [AnomalyInstance], metric: Metric, reason: String) {
            self.instances = instances
            self.metric = metric
            self.reason = reason
        }

        private enum CodingKeys: String, CodingKey {
            case instances
            case metric
            case reason
        }
    }

    public struct AnomalyInstance: AWSDecodableShape {
        ///  The end time of the period during which the metric is flagged as anomalous. This is specified using the ISO 8601 format. For example, 2020-06-01T13:15:02.001Z represents 1 millisecond past June 1, 2020 1:15:02 PM UTC.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var endTime: Date?
        ///  The universally unique identifier (UUID) of an instance of an anomaly in a metric.
        public let id: String
        ///  The start time of the period during which the metric is flagged as anomalous. This is specified using the ISO 8601 format. For example, 2020-06-01T13:15:02.001Z represents 1 millisecond past June 1, 2020 1:15:02 PM UTC.
        @CustomCoding<ISO8601DateCoder>
        public var startTime: Date
        /// Feedback type on a specific instance of anomaly submitted by the user.
        public let userFeedback: UserFeedback?

        public init(endTime: Date? = nil, id: String, startTime: Date, userFeedback: UserFeedback? = nil) {
            self.endTime = endTime
            self.id = id
            self.startTime = startTime
            self.userFeedback = userFeedback
        }

        private enum CodingKeys: String, CodingKey {
            case endTime
            case id
            case startTime
            case userFeedback
        }
    }

    public struct BatchGetFrameMetricDataRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "_endTime", location: .querystring(locationName: "endTime")),
            AWSMemberEncoding(label: "period", location: .querystring(locationName: "period")),
            AWSMemberEncoding(label: "profilingGroupName", location: .uri(locationName: "profilingGroupName")),
            AWSMemberEncoding(label: "_startTime", location: .querystring(locationName: "startTime")),
            AWSMemberEncoding(label: "targetResolution", location: .querystring(locationName: "targetResolution"))
        ]

        ///  The end time of the time period for the returned time series values. This is specified using the ISO 8601 format. For example, 2020-06-01T13:15:02.001Z represents 1 millisecond past June 1, 2020 1:15:02 PM UTC.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var endTime: Date?
        ///  The details of the metrics that are used to request a time series of values. The metric includes the name of the frame, the aggregation type to calculate the metric value for the frame, and the thread states to use to get the count for the metric value of the frame.
        public let frameMetrics: [FrameMetric]?
        ///  The duration of the frame metrics used to return the time series values. Specify using the ISO 8601 format. The maximum period duration is one day (PT24H or P1D).
        public let period: String?
        ///  The name of the profiling group associated with the the frame metrics used to return the time series values.
        public let profilingGroupName: String
        ///  The start time of the time period for the frame metrics used to return the time series values. This is specified using the ISO 8601 format. For example, 2020-06-01T13:15:02.001Z represents 1 millisecond past June 1, 2020 1:15:02 PM UTC.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var startTime: Date?
        /// The requested resolution of time steps for the returned time series of values. If the requested target resolution is not available due to data not being retained we provide a best effort result by falling back to the most granular available resolution after the target resolution. There are 3 valid values.     P1D — 1 day     PT1H — 1 hour     PT5M — 5 minutes
        public let targetResolution: AggregationPeriod?

        public init(endTime: Date? = nil, frameMetrics: [FrameMetric]? = nil, period: String? = nil, profilingGroupName: String, startTime: Date? = nil, targetResolution: AggregationPeriod? = nil) {
            self.endTime = endTime
            self.frameMetrics = frameMetrics
            self.period = period
            self.profilingGroupName = profilingGroupName
            self.startTime = startTime
            self.targetResolution = targetResolution
        }

        public func validate(name: String) throws {
            try self.validate(self.period, name: "period", parent: name, max: 64)
            try self.validate(self.period, name: "period", parent: name, min: 1)
            try self.validate(self.profilingGroupName, name: "profilingGroupName", parent: name, max: 255)
            try self.validate(self.profilingGroupName, name: "profilingGroupName", parent: name, min: 1)
            try self.validate(self.profilingGroupName, name: "profilingGroupName", parent: name, pattern: "^[\\w-]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case frameMetrics
        }
    }

    public struct BatchGetFrameMetricDataResponse: AWSDecodableShape {
        ///  The end time of the time period for the returned time series values. This is specified using the ISO 8601 format. For example, 2020-06-01T13:15:02.001Z represents 1 millisecond past June 1, 2020 1:15:02 PM UTC.
        @CustomCoding<ISO8601DateCoder>
        public var endTime: Date
        ///  List of instances, or time steps, in the time series. For example, if the period is one day (PT24H)), and the resolution is five minutes (PT5M), then there are 288 endTimes in the list that are each five minutes appart.
        public let endTimes: [TimestampStructure]
        /// Details of the metrics to request a time series of values. The metric includes the name of the frame, the aggregation type to calculate the metric value for the frame, and the thread states to use to get the count for the metric value of the frame.
        public let frameMetricData: [FrameMetricDatum]
        /// Resolution or granularity of the profile data used to generate the time series. This is the value used to jump through time steps in a time series. There are 3 valid values.     P1D — 1 day     PT1H — 1 hour     PT5M — 5 minutes
        public let resolution: AggregationPeriod
        ///  The start time of the time period for the returned time series values. This is specified using the ISO 8601 format. For example, 2020-06-01T13:15:02.001Z represents 1 millisecond past June 1, 2020 1:15:02 PM UTC.
        @CustomCoding<ISO8601DateCoder>
        public var startTime: Date
        /// List of instances which remained unprocessed. This will create a missing time step in the list of end times.
        public let unprocessedEndTimes: [String: [TimestampStructure]]

        public init(endTime: Date, endTimes: [TimestampStructure], frameMetricData: [FrameMetricDatum], resolution: AggregationPeriod, startTime: Date, unprocessedEndTimes: [String: [TimestampStructure]]) {
            self.endTime = endTime
            self.endTimes = endTimes
            self.frameMetricData = frameMetricData
            self.resolution = resolution
            self.startTime = startTime
            self.unprocessedEndTimes = unprocessedEndTimes
        }

        private enum CodingKeys: String, CodingKey {
            case endTime
            case endTimes
            case frameMetricData
            case resolution
            case startTime
            case unprocessedEndTimes
        }
    }

    public struct Channel: AWSEncodableShape & AWSDecodableShape {
        /// List of publishers for different type of events that may be detected in an application from the profile. Anomaly detection is the only event publisher in Profiler.
        public let eventPublishers: [EventPublisher]
        /// Unique identifier for each Channel in the notification configuration of a Profiling Group. A random UUID for channelId is used when adding a channel to the notification configuration if not specified in the request.
        public let id: String?
        /// Unique arn of the resource to be used for notifications. We support a valid SNS topic arn as a channel uri.
        public let uri: String

        public init(eventPublishers: [EventPublisher], id: String? = nil, uri: String) {
            self.eventPublishers = eventPublishers
            self.id = id
            self.uri = uri
        }

        public func validate(name: String) throws {
            try self.validate(self.eventPublishers, name: "eventPublishers", parent: name, max: 1)
            try self.validate(self.eventPublishers, name: "eventPublishers", parent: name, min: 1)
            try self.validate(self.id, name: "id", parent: name, pattern: "[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}")
        }

        private enum CodingKeys: String, CodingKey {
            case eventPublishers
            case id
            case uri
        }
    }

    public struct ConfigureAgentRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "profilingGroupName", location: .uri(locationName: "profilingGroupName"))
        ]

        ///  A universally unique identifier (UUID) for a profiling instance. For example, if the profiling instance is an Amazon EC2 instance, it is the instance ID. If it is an AWS Fargate container, it is the container's task ID.
        public let fleetInstanceId: String?
        ///  Metadata captured about the compute platform the agent is running on. It includes information about sampling and reporting. The valid fields are:    COMPUTE_PLATFORM - The compute platform on which the agent is running     AGENT_ID - The ID for an agent instance.     AWS_REQUEST_ID - The AWS request ID of a Lambda invocation.     EXECUTION_ENVIRONMENT - The execution environment a Lambda function is running on.     LAMBDA_FUNCTION_ARN - The Amazon Resource Name (ARN) that is used to invoke a Lambda function.     LAMBDA_MEMORY_LIMIT_IN_MB - The memory allocated to a Lambda function.     LAMBDA_REMAINING_TIME_IN_MILLISECONDS - The time in milliseconds before execution of a Lambda function times out.     LAMBDA_TIME_GAP_BETWEEN_INVOKES_IN_MILLISECONDS - The time in milliseconds between two invocations of a Lambda function.     LAMBDA_PREVIOUS_EXECUTION_TIME_IN_MILLISECONDS - The time in milliseconds for the previous Lambda invocation.
        public let metadata: [MetadataField: String]?
        ///  The name of the profiling group for which the configured agent is collecting profiling data.
        public let profilingGroupName: String

        public init(fleetInstanceId: String? = nil, metadata: [MetadataField: String]? = nil, profilingGroupName: String) {
            self.fleetInstanceId = fleetInstanceId
            self.metadata = metadata
            self.profilingGroupName = profilingGroupName
        }

        public func validate(name: String) throws {
            try self.validate(self.fleetInstanceId, name: "fleetInstanceId", parent: name, max: 255)
            try self.validate(self.fleetInstanceId, name: "fleetInstanceId", parent: name, min: 1)
            try self.validate(self.profilingGroupName, name: "profilingGroupName", parent: name, max: 255)
            try self.validate(self.profilingGroupName, name: "profilingGroupName", parent: name, min: 1)
            try self.validate(self.profilingGroupName, name: "profilingGroupName", parent: name, pattern: "^[\\w-]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case fleetInstanceId
            case metadata
        }
    }

    public struct ConfigureAgentResponse: AWSDecodableShape & AWSShapeWithPayload {
        /// The key for the payload
        public static let _payloadPath: String = "configuration"

        ///  An  AgentConfiguration  object that specifies if an agent profiles or not and for how long to return profiling data.
        public let configuration: AgentConfiguration

        public init(configuration: AgentConfiguration) {
            self.configuration = configuration
        }

        private enum CodingKeys: String, CodingKey {
            case configuration
        }
    }

    public struct CreateProfilingGroupRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "clientToken", location: .querystring(locationName: "clientToken"))
        ]

        ///  Specifies whether profiling is enabled or disabled for the created profiling group.
        public let agentOrchestrationConfig: AgentOrchestrationConfig?
        ///  Amazon CodeGuru Profiler uses this universally unique identifier (UUID) to prevent the accidental creation of duplicate profiling groups if there are failures and retries.
        public let clientToken: String
        ///  The compute platform of the profiling group. Use AWSLambda if your application runs on AWS Lambda. Use Default if your application runs on a compute platform that is not AWS Lambda, such an Amazon EC2 instance, an on-premises server, or a different platform. If not specified, Default is used.
        public let computePlatform: ComputePlatform?
        /// The name of the profiling group to create.
        public let profilingGroupName: String
        ///  A list of tags to add to the created profiling group.
        public let tags: [String: String]?

        public init(agentOrchestrationConfig: AgentOrchestrationConfig? = nil, clientToken: String = CreateProfilingGroupRequest.idempotencyToken(), computePlatform: ComputePlatform? = nil, profilingGroupName: String, tags: [String: String]? = nil) {
            self.agentOrchestrationConfig = agentOrchestrationConfig
            self.clientToken = clientToken
            self.computePlatform = computePlatform
            self.profilingGroupName = profilingGroupName
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 64)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "^[\\w-]+$")
            try self.validate(self.profilingGroupName, name: "profilingGroupName", parent: name, max: 255)
            try self.validate(self.profilingGroupName, name: "profilingGroupName", parent: name, min: 1)
            try self.validate(self.profilingGroupName, name: "profilingGroupName", parent: name, pattern: "^[\\w-]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case agentOrchestrationConfig
            case computePlatform
            case profilingGroupName
            case tags
        }
    }

    public struct CreateProfilingGroupResponse: AWSDecodableShape & AWSShapeWithPayload {
        /// The key for the payload
        public static let _payloadPath: String = "profilingGroup"

        ///  The returned  ProfilingGroupDescription  object that contains information about the created profiling group.
        public let profilingGroup: ProfilingGroupDescription

        public init(profilingGroup: ProfilingGroupDescription) {
            self.profilingGroup = profilingGroup
        }

        private enum CodingKeys: String, CodingKey {
            case profilingGroup
        }
    }

    public struct DeleteProfilingGroupRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "profilingGroupName", location: .uri(locationName: "profilingGroupName"))
        ]

        /// The name of the profiling group to delete.
        public let profilingGroupName: String

        public init(profilingGroupName: String) {
            self.profilingGroupName = profilingGroupName
        }

        public func validate(name: String) throws {
            try self.validate(self.profilingGroupName, name: "profilingGroupName", parent: name, max: 255)
            try self.validate(self.profilingGroupName, name: "profilingGroupName", parent: name, min: 1)
            try self.validate(self.profilingGroupName, name: "profilingGroupName", parent: name, pattern: "^[\\w-]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteProfilingGroupResponse: AWSDecodableShape {
        public init() {}
    }

    public struct DescribeProfilingGroupRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "profilingGroupName", location: .uri(locationName: "profilingGroupName"))
        ]

        ///  The name of the profiling group to get information about.
        public let profilingGroupName: String

        public init(profilingGroupName: String) {
            self.profilingGroupName = profilingGroupName
        }

        public func validate(name: String) throws {
            try self.validate(self.profilingGroupName, name: "profilingGroupName", parent: name, max: 255)
            try self.validate(self.profilingGroupName, name: "profilingGroupName", parent: name, min: 1)
            try self.validate(self.profilingGroupName, name: "profilingGroupName", parent: name, pattern: "^[\\w-]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DescribeProfilingGroupResponse: AWSDecodableShape & AWSShapeWithPayload {
        /// The key for the payload
        public static let _payloadPath: String = "profilingGroup"

        ///  The returned  ProfilingGroupDescription  object that contains information about the requested profiling group.
        public let profilingGroup: ProfilingGroupDescription

        public init(profilingGroup: ProfilingGroupDescription) {
            self.profilingGroup = profilingGroup
        }

        private enum CodingKeys: String, CodingKey {
            case profilingGroup
        }
    }

    public struct FindingsReportSummary: AWSDecodableShape {
        /// The universally unique identifier (UUID) of the recommendation report.
        public let id: String?
        ///  The end time of the period during which the metric is flagged as anomalous. This is specified using the ISO 8601 format. For example, 2020-06-01T13:15:02.001Z represents 1 millisecond past June 1, 2020 1:15:02 PM UTC.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var profileEndTime: Date?
        /// The start time of the profile the analysis data is about. This is specified using the ISO 8601 format. For example, 2020-06-01T13:15:02.001Z represents 1 millisecond past June 1, 2020 1:15:02 PM UTC.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var profileStartTime: Date?
        /// The name of the profiling group that is associated with the analysis data.
        public let profilingGroupName: String?
        /// The total number of different recommendations that were found by the analysis.
        public let totalNumberOfFindings: Int?

        public init(id: String? = nil, profileEndTime: Date? = nil, profileStartTime: Date? = nil, profilingGroupName: String? = nil, totalNumberOfFindings: Int? = nil) {
            self.id = id
            self.profileEndTime = profileEndTime
            self.profileStartTime = profileStartTime
            self.profilingGroupName = profilingGroupName
            self.totalNumberOfFindings = totalNumberOfFindings
        }

        private enum CodingKeys: String, CodingKey {
            case id
            case profileEndTime
            case profileStartTime
            case profilingGroupName
            case totalNumberOfFindings
        }
    }

    public struct FrameMetric: AWSEncodableShape & AWSDecodableShape {
        ///  Name of the method common across the multiple occurrences of a frame in an application profile.
        public let frameName: String
        /// List of application runtime thread states used to get the counts for a frame a derive a metric value.
        public let threadStates: [String]
        ///  A type of aggregation that specifies how a metric for a frame is analyzed. The supported value AggregatedRelativeTotalTime is an aggregation of the metric value for one frame that is calculated across the occurrences of all frames in a profile.
        public let type: MetricType

        public init(frameName: String, threadStates: [String], type: MetricType) {
            self.frameName = frameName
            self.threadStates = threadStates
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case frameName
            case threadStates
            case type
        }
    }

    public struct FrameMetricDatum: AWSDecodableShape {
        public let frameMetric: FrameMetric
        ///  A list of values that are associated with a frame metric.
        public let values: [Double]

        public init(frameMetric: FrameMetric, values: [Double]) {
            self.frameMetric = frameMetric
            self.values = values
        }

        private enum CodingKeys: String, CodingKey {
            case frameMetric
            case values
        }
    }

    public struct GetFindingsReportAccountSummaryRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "dailyReportsOnly", location: .querystring(locationName: "dailyReportsOnly")),
            AWSMemberEncoding(label: "maxResults", location: .querystring(locationName: "maxResults")),
            AWSMemberEncoding(label: "nextToken", location: .querystring(locationName: "nextToken"))
        ]

        /// A Boolean value indicating whether to only return reports from daily profiles. If set to True, only analysis data from daily profiles is returned. If set to False, analysis data is returned from smaller time windows (for example, one hour).
        public let dailyReportsOnly: Bool?
        /// The maximum number of results returned by  GetFindingsReportAccountSummary in paginated output. When this parameter is used, GetFindingsReportAccountSummary only returns maxResults results in a single page along with a nextToken response element. The remaining results of the initial request can be seen by sending another GetFindingsReportAccountSummary request with the returned nextToken value.
        public let maxResults: Int?
        /// The nextToken value returned from a previous paginated GetFindingsReportAccountSummary request where maxResults was used and the results exceeded the value of that parameter. Pagination continues from the end of the previous results that returned the nextToken value.   This token should be treated as an opaque identifier that is only used to retrieve the next items in a list and not for other programmatic purposes.
        public let nextToken: String?

        public init(dailyReportsOnly: Bool? = nil, maxResults: Int? = nil, nextToken: String? = nil) {
            self.dailyReportsOnly = dailyReportsOnly
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 1000)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 64)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^[\\w-]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetFindingsReportAccountSummaryResponse: AWSDecodableShape {
        /// The nextToken value to include in a future GetFindingsReportAccountSummary request. When the results of a GetFindingsReportAccountSummary request exceed maxResults, this value can be used to retrieve the next page of results. This value is null when there are no more results to return.
        public let nextToken: String?
        /// The return list of  FindingsReportSummary  objects taht contain summaries of analysis results for all profiling groups in your AWS account.
        public let reportSummaries: [FindingsReportSummary]

        public init(nextToken: String? = nil, reportSummaries: [FindingsReportSummary]) {
            self.nextToken = nextToken
            self.reportSummaries = reportSummaries
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken
            case reportSummaries
        }
    }

    public struct GetNotificationConfigurationRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "profilingGroupName", location: .uri(locationName: "profilingGroupName"))
        ]

        /// The name of the profiling group we want to get the notification configuration for.
        public let profilingGroupName: String

        public init(profilingGroupName: String) {
            self.profilingGroupName = profilingGroupName
        }

        public func validate(name: String) throws {
            try self.validate(self.profilingGroupName, name: "profilingGroupName", parent: name, max: 255)
            try self.validate(self.profilingGroupName, name: "profilingGroupName", parent: name, min: 1)
            try self.validate(self.profilingGroupName, name: "profilingGroupName", parent: name, pattern: "^[\\w-]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetNotificationConfigurationResponse: AWSDecodableShape {
        /// The current notification configuration for this profiling group.
        public let notificationConfiguration: NotificationConfiguration

        public init(notificationConfiguration: NotificationConfiguration) {
            self.notificationConfiguration = notificationConfiguration
        }

        private enum CodingKeys: String, CodingKey {
            case notificationConfiguration
        }
    }

    public struct GetPolicyRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "profilingGroupName", location: .uri(locationName: "profilingGroupName"))
        ]

        /// The name of the profiling group.
        public let profilingGroupName: String

        public init(profilingGroupName: String) {
            self.profilingGroupName = profilingGroupName
        }

        public func validate(name: String) throws {
            try self.validate(self.profilingGroupName, name: "profilingGroupName", parent: name, max: 255)
            try self.validate(self.profilingGroupName, name: "profilingGroupName", parent: name, min: 1)
            try self.validate(self.profilingGroupName, name: "profilingGroupName", parent: name, pattern: "^[\\w-]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetPolicyResponse: AWSDecodableShape {
        /// The JSON-formatted resource-based policy attached to the ProfilingGroup.
        public let policy: String
        /// A unique identifier for the current revision of the returned policy.
        public let revisionId: String

        public init(policy: String, revisionId: String) {
            self.policy = policy
            self.revisionId = revisionId
        }

        private enum CodingKeys: String, CodingKey {
            case policy
            case revisionId
        }
    }

    public struct GetProfileRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "accept", location: .header(locationName: "Accept")),
            AWSMemberEncoding(label: "_endTime", location: .querystring(locationName: "endTime")),
            AWSMemberEncoding(label: "maxDepth", location: .querystring(locationName: "maxDepth")),
            AWSMemberEncoding(label: "period", location: .querystring(locationName: "period")),
            AWSMemberEncoding(label: "profilingGroupName", location: .uri(locationName: "profilingGroupName")),
            AWSMemberEncoding(label: "_startTime", location: .querystring(locationName: "startTime"))
        ]

        ///  The format of the returned profiling data. The format maps to the Accept and Content-Type headers of the HTTP request. You can specify one of the following: or the default .   &lt;ul&gt; &lt;li&gt; &lt;p&gt; &lt;code&gt;application/json&lt;/code&gt; — standard JSON format &lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt; &lt;code&gt;application/x-amzn-ion&lt;/code&gt; — the Amazon Ion data format. For more information, see &lt;a href=&quot;http://amzn.github.io/ion-docs/&quot;&gt;Amazon Ion&lt;/a&gt;. &lt;/p&gt; &lt;/li&gt; &lt;/ul&gt;
        public let accept: String?
        ///  The end time of the requested profile. Specify using the ISO 8601 format. For example, 2020-06-01T13:15:02.001Z represents 1 millisecond past June 1, 2020 1:15:02 PM UTC.   If you specify endTime, then you must also specify period or startTime, but not both.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var endTime: Date?
        ///  The maximum depth of the stacks in the code that is represented in the aggregated profile. For example, if CodeGuru Profiler finds a method A, which calls method B, which calls method C, which calls method D, then the depth is 4. If the maxDepth is set to 2, then the aggregated profile contains representations of methods A and B.
        public let maxDepth: Int?
        ///  Used with startTime or endTime to specify the time range for the returned aggregated profile. Specify using the ISO 8601 format. For example, P1DT1H1M1S.   &lt;p&gt; To get the latest aggregated profile, specify only &lt;code&gt;period&lt;/code&gt;. &lt;/p&gt;
        public let period: String?
        /// The name of the profiling group to get.
        public let profilingGroupName: String
        /// The start time of the profile to get. Specify using the ISO 8601 format. For example, 2020-06-01T13:15:02.001Z represents 1 millisecond past June 1, 2020 1:15:02 PM UTC.  &lt;p&gt; If you specify &lt;code&gt;startTime&lt;/code&gt;, then you must also specify &lt;code&gt;period&lt;/code&gt; or &lt;code&gt;endTime&lt;/code&gt;, but not both. &lt;/p&gt;
        @OptionalCustomCoding<ISO8601DateCoder>
        public var startTime: Date?

        public init(accept: String? = nil, endTime: Date? = nil, maxDepth: Int? = nil, period: String? = nil, profilingGroupName: String, startTime: Date? = nil) {
            self.accept = accept
            self.endTime = endTime
            self.maxDepth = maxDepth
            self.period = period
            self.profilingGroupName = profilingGroupName
            self.startTime = startTime
        }

        public func validate(name: String) throws {
            try self.validate(self.maxDepth, name: "maxDepth", parent: name, max: 10000)
            try self.validate(self.maxDepth, name: "maxDepth", parent: name, min: 1)
            try self.validate(self.period, name: "period", parent: name, max: 64)
            try self.validate(self.period, name: "period", parent: name, min: 1)
            try self.validate(self.profilingGroupName, name: "profilingGroupName", parent: name, max: 255)
            try self.validate(self.profilingGroupName, name: "profilingGroupName", parent: name, min: 1)
            try self.validate(self.profilingGroupName, name: "profilingGroupName", parent: name, pattern: "^[\\w-]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetProfileResponse: AWSDecodableShape & AWSShapeWithPayload {
        /// The key for the payload
        public static let _payloadPath: String = "profile"
        public static let _payloadOptions: AWSShapePayloadOptions = [.raw]
        public static var _encoding = [
            AWSMemberEncoding(label: "contentEncoding", location: .header(locationName: "Content-Encoding")),
            AWSMemberEncoding(label: "contentType", location: .header(locationName: "Content-Type"))
        ]

        /// The content encoding of the profile.
        public let contentEncoding: String?
        /// The content type of the profile in the payload. It is either application/json or the default application/x-amzn-ion.
        public let contentType: String
        /// Information about the profile.
        public let profile: AWSPayload

        public init(contentEncoding: String? = nil, contentType: String, profile: AWSPayload) {
            self.contentEncoding = contentEncoding
            self.contentType = contentType
            self.profile = profile
        }

        private enum CodingKeys: String, CodingKey {
            case contentEncoding = "Content-Encoding"
            case contentType = "Content-Type"
            case profile
        }
    }

    public struct GetRecommendationsRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "_endTime", location: .querystring(locationName: "endTime")),
            AWSMemberEncoding(label: "locale", location: .querystring(locationName: "locale")),
            AWSMemberEncoding(label: "profilingGroupName", location: .uri(locationName: "profilingGroupName")),
            AWSMemberEncoding(label: "_startTime", location: .querystring(locationName: "startTime"))
        ]

        ///  The start time of the profile to get analysis data about. You must specify startTime and endTime. This is specified using the ISO 8601 format. For example, 2020-06-01T13:15:02.001Z represents 1 millisecond past June 1, 2020 1:15:02 PM UTC.
        @CustomCoding<ISO8601DateCoder>
        public var endTime: Date
        ///  The language used to provide analysis. Specify using a string that is one of the following BCP 47 language codes.     de-DE - German, Germany     en-GB - English, United Kingdom     en-US - English, United States     es-ES - Spanish, Spain     fr-FR - French, France     it-IT - Italian, Italy     ja-JP - Japanese, Japan     ko-KR - Korean, Republic of Korea     pt-BR - Portugese, Brazil     zh-CN - Chinese, China     zh-TW - Chinese, Taiwan
        public let locale: String?
        ///  The name of the profiling group to get analysis data about.
        public let profilingGroupName: String
        ///  The end time of the profile to get analysis data about. You must specify startTime and endTime. This is specified using the ISO 8601 format. For example, 2020-06-01T13:15:02.001Z represents 1 millisecond past June 1, 2020 1:15:02 PM UTC.
        @CustomCoding<ISO8601DateCoder>
        public var startTime: Date

        public init(endTime: Date, locale: String? = nil, profilingGroupName: String, startTime: Date) {
            self.endTime = endTime
            self.locale = locale
            self.profilingGroupName = profilingGroupName
            self.startTime = startTime
        }

        public func validate(name: String) throws {
            try self.validate(self.profilingGroupName, name: "profilingGroupName", parent: name, max: 255)
            try self.validate(self.profilingGroupName, name: "profilingGroupName", parent: name, min: 1)
            try self.validate(self.profilingGroupName, name: "profilingGroupName", parent: name, pattern: "^[\\w-]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetRecommendationsResponse: AWSDecodableShape {
        ///  The list of anomalies that the analysis has found for this profile.
        public let anomalies: [Anomaly]
        ///  The end time of the profile the analysis data is about. This is specified using the ISO 8601 format. For example, 2020-06-01T13:15:02.001Z represents 1 millisecond past June 1, 2020 1:15:02 PM UTC.
        @CustomCoding<ISO8601DateCoder>
        public var profileEndTime: Date
        ///  The start time of the profile the analysis data is about. This is specified using the ISO 8601 format. For example, 2020-06-01T13:15:02.001Z represents 1 millisecond past June 1, 2020 1:15:02 PM UTC.
        @CustomCoding<ISO8601DateCoder>
        public var profileStartTime: Date
        /// The name of the profiling group the analysis data is about.
        public let profilingGroupName: String
        /// The list of recommendations that the analysis found for this profile.
        public let recommendations: [Recommendation]

        public init(anomalies: [Anomaly], profileEndTime: Date, profileStartTime: Date, profilingGroupName: String, recommendations: [Recommendation]) {
            self.anomalies = anomalies
            self.profileEndTime = profileEndTime
            self.profileStartTime = profileStartTime
            self.profilingGroupName = profilingGroupName
            self.recommendations = recommendations
        }

        private enum CodingKeys: String, CodingKey {
            case anomalies
            case profileEndTime
            case profileStartTime
            case profilingGroupName
            case recommendations
        }
    }

    public struct ListFindingsReportsRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "dailyReportsOnly", location: .querystring(locationName: "dailyReportsOnly")),
            AWSMemberEncoding(label: "_endTime", location: .querystring(locationName: "endTime")),
            AWSMemberEncoding(label: "maxResults", location: .querystring(locationName: "maxResults")),
            AWSMemberEncoding(label: "nextToken", location: .querystring(locationName: "nextToken")),
            AWSMemberEncoding(label: "profilingGroupName", location: .uri(locationName: "profilingGroupName")),
            AWSMemberEncoding(label: "_startTime", location: .querystring(locationName: "startTime"))
        ]

        /// A Boolean value indicating whether to only return reports from daily profiles. If set to True, only analysis data from daily profiles is returned. If set to False, analysis data is returned from smaller time windows (for example, one hour).
        public let dailyReportsOnly: Bool?
        ///  The end time of the profile to get analysis data about. You must specify startTime and endTime. This is specified using the ISO 8601 format. For example, 2020-06-01T13:15:02.001Z represents 1 millisecond past June 1, 2020 1:15:02 PM UTC.
        @CustomCoding<ISO8601DateCoder>
        public var endTime: Date
        /// The maximum number of report results returned by ListFindingsReports in paginated output. When this parameter is used, ListFindingsReports only returns maxResults results in a single page along with a nextToken response element. The remaining results of the initial request can be seen by sending another ListFindingsReports request with the returned nextToken value.
        public let maxResults: Int?
        /// The nextToken value returned from a previous paginated ListFindingsReportsRequest request where maxResults was used and the results exceeded the value of that parameter. Pagination continues from the end of the previous results that returned the nextToken value.   This token should be treated as an opaque identifier that is only used to retrieve the next items in a list and not for other programmatic purposes.
        public let nextToken: String?
        /// The name of the profiling group from which to search for analysis data.
        public let profilingGroupName: String
        ///  The start time of the profile to get analysis data about. You must specify startTime and endTime. This is specified using the ISO 8601 format. For example, 2020-06-01T13:15:02.001Z represents 1 millisecond past June 1, 2020 1:15:02 PM UTC.
        @CustomCoding<ISO8601DateCoder>
        public var startTime: Date

        public init(dailyReportsOnly: Bool? = nil, endTime: Date, maxResults: Int? = nil, nextToken: String? = nil, profilingGroupName: String, startTime: Date) {
            self.dailyReportsOnly = dailyReportsOnly
            self.endTime = endTime
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.profilingGroupName = profilingGroupName
            self.startTime = startTime
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 1000)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 64)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^[\\w-]+$")
            try self.validate(self.profilingGroupName, name: "profilingGroupName", parent: name, max: 255)
            try self.validate(self.profilingGroupName, name: "profilingGroupName", parent: name, min: 1)
            try self.validate(self.profilingGroupName, name: "profilingGroupName", parent: name, pattern: "^[\\w-]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListFindingsReportsResponse: AWSDecodableShape {
        /// The list of analysis results summaries.
        public let findingsReportSummaries: [FindingsReportSummary]
        /// The nextToken value to include in a future ListFindingsReports request. When the results of a ListFindingsReports request exceed maxResults, this value can be used to retrieve the next page of results. This value is null when there are no more results to return.
        public let nextToken: String?

        public init(findingsReportSummaries: [FindingsReportSummary], nextToken: String? = nil) {
            self.findingsReportSummaries = findingsReportSummaries
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case findingsReportSummaries
            case nextToken
        }
    }

    public struct ListProfileTimesRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "_endTime", location: .querystring(locationName: "endTime")),
            AWSMemberEncoding(label: "maxResults", location: .querystring(locationName: "maxResults")),
            AWSMemberEncoding(label: "nextToken", location: .querystring(locationName: "nextToken")),
            AWSMemberEncoding(label: "orderBy", location: .querystring(locationName: "orderBy")),
            AWSMemberEncoding(label: "period", location: .querystring(locationName: "period")),
            AWSMemberEncoding(label: "profilingGroupName", location: .uri(locationName: "profilingGroupName")),
            AWSMemberEncoding(label: "_startTime", location: .querystring(locationName: "startTime"))
        ]

        /// The end time of the time range from which to list the profiles.
        @CustomCoding<ISO8601DateCoder>
        public var endTime: Date
        /// The maximum number of profile time results returned by ListProfileTimes in paginated output. When this parameter is used, ListProfileTimes only returns maxResults results in a single page with a nextToken response element. The remaining results of the initial request can be seen by sending another ListProfileTimes request with the returned nextToken value.
        public let maxResults: Int?
        /// The nextToken value returned from a previous paginated ListProfileTimes request where maxResults was used and the results exceeded the value of that parameter. Pagination continues from the end of the previous results that returned the nextToken value.   This token should be treated as an opaque identifier that is only used to retrieve the next items in a list and not for other programmatic purposes.
        public let nextToken: String?
        /// The order (ascending or descending by start time of the profile) to use when listing profiles. Defaults to TIMESTAMP_DESCENDING.
        public let orderBy: OrderBy?
        ///  The aggregation period. This specifies the period during which an aggregation profile collects posted agent profiles for a profiling group. There are 3 valid values.     P1D — 1 day     PT1H — 1 hour     PT5M — 5 minutes
        public let period: AggregationPeriod
        /// The name of the profiling group.
        public let profilingGroupName: String
        /// The start time of the time range from which to list the profiles.
        @CustomCoding<ISO8601DateCoder>
        public var startTime: Date

        public init(endTime: Date, maxResults: Int? = nil, nextToken: String? = nil, orderBy: OrderBy? = nil, period: AggregationPeriod, profilingGroupName: String, startTime: Date) {
            self.endTime = endTime
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.orderBy = orderBy
            self.period = period
            self.profilingGroupName = profilingGroupName
            self.startTime = startTime
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 1000)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 64)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^[\\w-]+$")
            try self.validate(self.profilingGroupName, name: "profilingGroupName", parent: name, max: 255)
            try self.validate(self.profilingGroupName, name: "profilingGroupName", parent: name, min: 1)
            try self.validate(self.profilingGroupName, name: "profilingGroupName", parent: name, pattern: "^[\\w-]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListProfileTimesResponse: AWSDecodableShape {
        /// The nextToken value to include in a future ListProfileTimes request. When the results of a ListProfileTimes request exceed maxResults, this value can be used to retrieve the next page of results. This value is null when there are no more results to return.
        public let nextToken: String?
        /// The list of start times of the available profiles for the aggregation period in the specified time range.
        public let profileTimes: [ProfileTime]

        public init(nextToken: String? = nil, profileTimes: [ProfileTime]) {
            self.nextToken = nextToken
            self.profileTimes = profileTimes
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken
            case profileTimes
        }
    }

    public struct ListProfilingGroupsRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "includeDescription", location: .querystring(locationName: "includeDescription")),
            AWSMemberEncoding(label: "maxResults", location: .querystring(locationName: "maxResults")),
            AWSMemberEncoding(label: "nextToken", location: .querystring(locationName: "nextToken"))
        ]

        /// A Boolean value indicating whether to include a description. If true, then a list of  ProfilingGroupDescription  objects that contain detailed information about profiling groups is returned. If false, then a list of profiling group names is returned.
        public let includeDescription: Bool?
        /// The maximum number of profiling groups results returned by ListProfilingGroups in paginated output. When this parameter is used, ListProfilingGroups only returns maxResults results in a single page along with a nextToken response element. The remaining results of the initial request can be seen by sending another ListProfilingGroups request with the returned nextToken value.
        public let maxResults: Int?
        /// The nextToken value returned from a previous paginated ListProfilingGroups request where maxResults was used and the results exceeded the value of that parameter. Pagination continues from the end of the previous results that returned the nextToken value.   This token should be treated as an opaque identifier that is only used to retrieve the next items in a list and not for other programmatic purposes.
        public let nextToken: String?

        public init(includeDescription: Bool? = nil, maxResults: Int? = nil, nextToken: String? = nil) {
            self.includeDescription = includeDescription
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 1000)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 64)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^[\\w-]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListProfilingGroupsResponse: AWSDecodableShape {
        /// The nextToken value to include in a future ListProfilingGroups request. When the results of a ListProfilingGroups request exceed maxResults, this value can be used to retrieve the next page of results. This value is null when there are no more results to return.
        public let nextToken: String?
        ///  A returned list of profiling group names. A list of the names is returned only if includeDescription is false, otherwise a list of  ProfilingGroupDescription  objects is returned.
        public let profilingGroupNames: [String]
        ///  A returned list  ProfilingGroupDescription  objects. A list of  ProfilingGroupDescription  objects is returned only if includeDescription is true, otherwise a list of profiling group names is returned.
        public let profilingGroups: [ProfilingGroupDescription]?

        public init(nextToken: String? = nil, profilingGroupNames: [String], profilingGroups: [ProfilingGroupDescription]? = nil) {
            self.nextToken = nextToken
            self.profilingGroupNames = profilingGroupNames
            self.profilingGroups = profilingGroups
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken
            case profilingGroupNames
            case profilingGroups
        }
    }

    public struct ListTagsForResourceRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "resourceArn", location: .uri(locationName: "resourceArn"))
        ]

        ///  The Amazon Resource Name (ARN) of the resource that contains the tags to return.
        public let resourceArn: String

        public init(resourceArn: String) {
            self.resourceArn = resourceArn
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListTagsForResourceResponse: AWSDecodableShape {
        ///  The list of tags assigned to the specified resource. This is the list of tags returned in the response.
        public let tags: [String: String]?

        public init(tags: [String: String]? = nil) {
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case tags
        }
    }

    public struct Match: AWSDecodableShape {
        /// The location in the profiling graph that contains a recommendation found during analysis.
        public let frameAddress: String?
        /// The target frame that triggered a match.
        public let targetFramesIndex: Int?
        /// The value in the profile data that exceeded the recommendation threshold.
        public let thresholdBreachValue: Double?

        public init(frameAddress: String? = nil, targetFramesIndex: Int? = nil, thresholdBreachValue: Double? = nil) {
            self.frameAddress = frameAddress
            self.targetFramesIndex = targetFramesIndex
            self.thresholdBreachValue = thresholdBreachValue
        }

        private enum CodingKeys: String, CodingKey {
            case frameAddress
            case targetFramesIndex
            case thresholdBreachValue
        }
    }

    public struct Metric: AWSDecodableShape {
        ///  The name of the method that appears as a frame in any stack in a profile.
        public let frameName: String
        ///  The list of application runtime thread states that is used to calculate the metric value for the frame.
        public let threadStates: [String]
        ///  A type that specifies how a metric for a frame is analyzed. The supported value AggregatedRelativeTotalTime is an aggregation of the metric value for one frame that is calculated across the occurences of all frames in a profile.
        public let type: MetricType

        public init(frameName: String, threadStates: [String], type: MetricType) {
            self.frameName = frameName
            self.threadStates = threadStates
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case frameName
            case threadStates
            case type
        }
    }

    public struct NotificationConfiguration: AWSDecodableShape {
        /// List of up to two channels to be used for sending notifications for events detected from the application profile.
        public let channels: [Channel]?

        public init(channels: [Channel]? = nil) {
            self.channels = channels
        }

        private enum CodingKeys: String, CodingKey {
            case channels
        }
    }

    public struct Pattern: AWSDecodableShape {
        ///  A list of the different counters used to determine if there is a match.
        public let countersToAggregate: [String]?
        /// The description of the recommendation. This explains a potential inefficiency in a profiled application.
        public let description: String?
        /// The universally unique identifier (UUID) of this pattern.
        public let id: String?
        /// The name for this pattern.
        public let name: String?
        ///  A string that contains the steps recommended to address the potential inefficiency.
        public let resolutionSteps: String?
        /// A list of frame names that were searched during the analysis that generated a recommendation.
        public let targetFrames: [[String]]?
        ///  The percentage of time an application spends in one method that triggers a recommendation. The percentage of time is the same as the percentage of the total gathered sample counts during analysis.
        public let thresholdPercent: Double?

        public init(countersToAggregate: [String]? = nil, description: String? = nil, id: String? = nil, name: String? = nil, resolutionSteps: String? = nil, targetFrames: [[String]]? = nil, thresholdPercent: Double? = nil) {
            self.countersToAggregate = countersToAggregate
            self.description = description
            self.id = id
            self.name = name
            self.resolutionSteps = resolutionSteps
            self.targetFrames = targetFrames
            self.thresholdPercent = thresholdPercent
        }

        private enum CodingKeys: String, CodingKey {
            case countersToAggregate
            case description
            case id
            case name
            case resolutionSteps
            case targetFrames
            case thresholdPercent
        }
    }

    public struct PostAgentProfileRequest: AWSEncodableShape & AWSShapeWithPayload {
        /// The key for the payload
        public static let _payloadPath: String = "agentProfile"
        public static let _payloadOptions: AWSShapePayloadOptions = [.raw]
        public static var _encoding = [
            AWSMemberEncoding(label: "contentType", location: .header(locationName: "Content-Type")),
            AWSMemberEncoding(label: "profileToken", location: .querystring(locationName: "profileToken")),
            AWSMemberEncoding(label: "profilingGroupName", location: .uri(locationName: "profilingGroupName"))
        ]

        ///  The submitted profiling data.
        public let agentProfile: AWSPayload
        ///  The format of the submitted profiling data. The format maps to the Accept and Content-Type headers of the HTTP request. You can specify one of the following: or the default .   &lt;ul&gt; &lt;li&gt; &lt;p&gt; &lt;code&gt;application/json&lt;/code&gt; — standard JSON format &lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt; &lt;code&gt;application/x-amzn-ion&lt;/code&gt; — the Amazon Ion data format. For more information, see &lt;a href=&quot;http://amzn.github.io/ion-docs/&quot;&gt;Amazon Ion&lt;/a&gt;. &lt;/p&gt; &lt;/li&gt; &lt;/ul&gt;
        public let contentType: String
        ///  Amazon CodeGuru Profiler uses this universally unique identifier (UUID) to prevent the accidental submission of duplicate profiling data if there are failures and retries.
        public let profileToken: String?
        ///  The name of the profiling group with the aggregated profile that receives the submitted profiling data.
        public let profilingGroupName: String

        public init(agentProfile: AWSPayload, contentType: String, profileToken: String? = PostAgentProfileRequest.idempotencyToken(), profilingGroupName: String) {
            self.agentProfile = agentProfile
            self.contentType = contentType
            self.profileToken = profileToken
            self.profilingGroupName = profilingGroupName
        }

        public func validate(name: String) throws {
            try self.validate(self.profileToken, name: "profileToken", parent: name, max: 64)
            try self.validate(self.profileToken, name: "profileToken", parent: name, min: 1)
            try self.validate(self.profileToken, name: "profileToken", parent: name, pattern: "^[\\w-]+$")
            try self.validate(self.profilingGroupName, name: "profilingGroupName", parent: name, max: 255)
            try self.validate(self.profilingGroupName, name: "profilingGroupName", parent: name, min: 1)
            try self.validate(self.profilingGroupName, name: "profilingGroupName", parent: name, pattern: "^[\\w-]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct PostAgentProfileResponse: AWSDecodableShape {
        public init() {}
    }

    public struct ProfileTime: AWSDecodableShape {
        /// The start time of a profile. It is specified using the ISO 8601 format. For example, 2020-06-01T13:15:02.001Z represents 1 millisecond past June 1, 2020 1:15:02 PM UTC.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var start: Date?

        public init(start: Date? = nil) {
            self.start = start
        }

        private enum CodingKeys: String, CodingKey {
            case start
        }
    }

    public struct ProfilingGroupDescription: AWSDecodableShape {
        ///  An  AgentOrchestrationConfig  object that indicates if the profiling group is enabled for profiled or not.
        public let agentOrchestrationConfig: AgentOrchestrationConfig?
        /// The Amazon Resource Name (ARN) identifying the profiling group resource.
        public let arn: String?
        ///  The compute platform of the profiling group. If it is set to AWSLambda, then the profiled application runs on AWS Lambda. If it is set to Default, then the profiled application runs on a compute platform that is not AWS Lambda, such an Amazon EC2 instance, an on-premises server, or a different platform. The default is Default.
        public let computePlatform: ComputePlatform?
        /// The time when the profiling group was created. Specify using the ISO 8601 format. For example, 2020-06-01T13:15:02.001Z represents 1 millisecond past June 1, 2020 1:15:02 PM UTC.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var createdAt: Date?
        /// The name of the profiling group.
        public let name: String?
        ///  A  ProfilingStatus  object that includes information about the last time a profile agent pinged back, the last time a profile was received, and the aggregation period and start time for the most recent aggregated profile.
        public let profilingStatus: ProfilingStatus?
        ///  A list of the tags that belong to this profiling group.
        public let tags: [String: String]?
        ///  The date and time when the profiling group was last updated. Specify using the ISO 8601 format. For example, 2020-06-01T13:15:02.001Z represents 1 millisecond past June 1, 2020 1:15:02 PM UTC.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var updatedAt: Date?

        public init(agentOrchestrationConfig: AgentOrchestrationConfig? = nil, arn: String? = nil, computePlatform: ComputePlatform? = nil, createdAt: Date? = nil, name: String? = nil, profilingStatus: ProfilingStatus? = nil, tags: [String: String]? = nil, updatedAt: Date? = nil) {
            self.agentOrchestrationConfig = agentOrchestrationConfig
            self.arn = arn
            self.computePlatform = computePlatform
            self.createdAt = createdAt
            self.name = name
            self.profilingStatus = profilingStatus
            self.tags = tags
            self.updatedAt = updatedAt
        }

        private enum CodingKeys: String, CodingKey {
            case agentOrchestrationConfig
            case arn
            case computePlatform
            case createdAt
            case name
            case profilingStatus
            case tags
            case updatedAt
        }
    }

    public struct ProfilingStatus: AWSDecodableShape {
        /// The date and time when the profiling agent most recently pinged back. Specify using the ISO 8601 format. For example, 2020-06-01T13:15:02.001Z represents 1 millisecond past June 1, 2020 1:15:02 PM UTC.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var latestAgentOrchestratedAt: Date?
        /// The date and time when the most recent profile was received. Specify using the ISO 8601 format. For example, 2020-06-01T13:15:02.001Z represents 1 millisecond past June 1, 2020 1:15:02 PM UTC.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var latestAgentProfileReportedAt: Date?
        ///  An  AggregatedProfileTime  object that contains the aggregation period and start time for an aggregated profile.
        public let latestAggregatedProfile: AggregatedProfileTime?

        public init(latestAgentOrchestratedAt: Date? = nil, latestAgentProfileReportedAt: Date? = nil, latestAggregatedProfile: AggregatedProfileTime? = nil) {
            self.latestAgentOrchestratedAt = latestAgentOrchestratedAt
            self.latestAgentProfileReportedAt = latestAgentProfileReportedAt
            self.latestAggregatedProfile = latestAggregatedProfile
        }

        private enum CodingKeys: String, CodingKey {
            case latestAgentOrchestratedAt
            case latestAgentProfileReportedAt
            case latestAggregatedProfile
        }
    }

    public struct PutPermissionRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "actionGroup", location: .uri(locationName: "actionGroup")),
            AWSMemberEncoding(label: "profilingGroupName", location: .uri(locationName: "profilingGroupName"))
        ]

        ///  Specifies an action group that contains permissions to add to a profiling group resource. One action group is supported, agentPermissions, which grants permission to perform actions required by the profiling agent, ConfigureAgent and PostAgentProfile permissions.
        public let actionGroup: ActionGroup
        ///  A list ARNs for the roles and users you want to grant access to the profiling group. Wildcards are not are supported in the ARNs.
        public let principals: [String]
        /// The name of the profiling group to grant access to.
        public let profilingGroupName: String
        ///  A universally unique identifier (UUID) for the revision of the policy you are adding to the profiling group. Do not specify this when you add permissions to a profiling group for the first time. If a policy already exists on the profiling group, you must specify the revisionId.
        public let revisionId: String?

        public init(actionGroup: ActionGroup, principals: [String], profilingGroupName: String, revisionId: String? = nil) {
            self.actionGroup = actionGroup
            self.principals = principals
            self.profilingGroupName = profilingGroupName
            self.revisionId = revisionId
        }

        public func validate(name: String) throws {
            try self.validate(self.principals, name: "principals", parent: name, max: 50)
            try self.validate(self.principals, name: "principals", parent: name, min: 1)
            try self.validate(self.profilingGroupName, name: "profilingGroupName", parent: name, max: 255)
            try self.validate(self.profilingGroupName, name: "profilingGroupName", parent: name, min: 1)
            try self.validate(self.profilingGroupName, name: "profilingGroupName", parent: name, pattern: "^[\\w-]+$")
            try self.validate(self.revisionId, name: "revisionId", parent: name, pattern: "[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}")
        }

        private enum CodingKeys: String, CodingKey {
            case principals
            case revisionId
        }
    }

    public struct PutPermissionResponse: AWSDecodableShape {
        ///  The JSON-formatted resource-based policy on the profiling group that includes the added permissions.
        public let policy: String
        ///  A universally unique identifier (UUID) for the revision of the resource-based policy that includes the added permissions. The JSON-formatted policy is in the policy element of the response.
        public let revisionId: String

        public init(policy: String, revisionId: String) {
            self.policy = policy
            self.revisionId = revisionId
        }

        private enum CodingKeys: String, CodingKey {
            case policy
            case revisionId
        }
    }

    public struct Recommendation: AWSDecodableShape {
        /// How many different places in the profile graph triggered a match.
        public let allMatchesCount: Int
        /// How much of the total sample count is potentially affected.
        public let allMatchesSum: Double
        /// End time of the profile that was used by this analysis. This is specified using the ISO 8601 format. For example, 2020-06-01T13:15:02.001Z represents 1 millisecond past June 1, 2020 1:15:02 PM UTC.
        @CustomCoding<ISO8601DateCoder>
        public var endTime: Date
        /// The pattern that analysis recognized in the profile to make this recommendation.
        public let pattern: Pattern
        /// The start time of the profile that was used by this analysis. This is specified using the ISO 8601 format. For example, 2020-06-01T13:15:02.001Z represents 1 millisecond past June 1, 2020 1:15:02 PM UTC.
        @CustomCoding<ISO8601DateCoder>
        public var startTime: Date
        /// List of the matches with most impact.
        public let topMatches: [Match]

        public init(allMatchesCount: Int, allMatchesSum: Double, endTime: Date, pattern: Pattern, startTime: Date, topMatches: [Match]) {
            self.allMatchesCount = allMatchesCount
            self.allMatchesSum = allMatchesSum
            self.endTime = endTime
            self.pattern = pattern
            self.startTime = startTime
            self.topMatches = topMatches
        }

        private enum CodingKeys: String, CodingKey {
            case allMatchesCount
            case allMatchesSum
            case endTime
            case pattern
            case startTime
            case topMatches
        }
    }

    public struct RemoveNotificationChannelRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "channelId", location: .uri(locationName: "channelId")),
            AWSMemberEncoding(label: "profilingGroupName", location: .uri(locationName: "profilingGroupName"))
        ]

        /// The id of the channel that we want to stop receiving notifications.
        public let channelId: String
        /// The name of the profiling group we want to change notification configuration for.
        public let profilingGroupName: String

        public init(channelId: String, profilingGroupName: String) {
            self.channelId = channelId
            self.profilingGroupName = profilingGroupName
        }

        public func validate(name: String) throws {
            try self.validate(self.channelId, name: "channelId", parent: name, pattern: "[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}")
            try self.validate(self.profilingGroupName, name: "profilingGroupName", parent: name, max: 255)
            try self.validate(self.profilingGroupName, name: "profilingGroupName", parent: name, min: 1)
            try self.validate(self.profilingGroupName, name: "profilingGroupName", parent: name, pattern: "^[\\w-]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct RemoveNotificationChannelResponse: AWSDecodableShape {
        /// The new notification configuration for this profiling group.
        public let notificationConfiguration: NotificationConfiguration?

        public init(notificationConfiguration: NotificationConfiguration? = nil) {
            self.notificationConfiguration = notificationConfiguration
        }

        private enum CodingKeys: String, CodingKey {
            case notificationConfiguration
        }
    }

    public struct RemovePermissionRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "actionGroup", location: .uri(locationName: "actionGroup")),
            AWSMemberEncoding(label: "profilingGroupName", location: .uri(locationName: "profilingGroupName")),
            AWSMemberEncoding(label: "revisionId", location: .querystring(locationName: "revisionId"))
        ]

        ///  Specifies an action group that contains the permissions to remove from a profiling group's resource-based policy. One action group is supported, agentPermissions, which grants ConfigureAgent and PostAgentProfile permissions.
        public let actionGroup: ActionGroup
        /// The name of the profiling group.
        public let profilingGroupName: String
        ///  A universally unique identifier (UUID) for the revision of the resource-based policy from which you want to remove permissions.
        public let revisionId: String

        public init(actionGroup: ActionGroup, profilingGroupName: String, revisionId: String) {
            self.actionGroup = actionGroup
            self.profilingGroupName = profilingGroupName
            self.revisionId = revisionId
        }

        public func validate(name: String) throws {
            try self.validate(self.profilingGroupName, name: "profilingGroupName", parent: name, max: 255)
            try self.validate(self.profilingGroupName, name: "profilingGroupName", parent: name, min: 1)
            try self.validate(self.profilingGroupName, name: "profilingGroupName", parent: name, pattern: "^[\\w-]+$")
            try self.validate(self.revisionId, name: "revisionId", parent: name, pattern: "[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct RemovePermissionResponse: AWSDecodableShape {
        ///  The JSON-formatted resource-based policy on the profiling group after the specified permissions were removed.
        public let policy: String
        ///  A universally unique identifier (UUID) for the revision of the resource-based policy after the specified permissions were removed. The updated JSON-formatted policy is in the policy element of the response.
        public let revisionId: String

        public init(policy: String, revisionId: String) {
            self.policy = policy
            self.revisionId = revisionId
        }

        private enum CodingKeys: String, CodingKey {
            case policy
            case revisionId
        }
    }

    public struct SubmitFeedbackRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "anomalyInstanceId", location: .uri(locationName: "anomalyInstanceId")),
            AWSMemberEncoding(label: "profilingGroupName", location: .uri(locationName: "profilingGroupName"))
        ]

        /// The universally unique identifier (UUID) of the  AnomalyInstance  object that is included in the analysis data.
        public let anomalyInstanceId: String
        /// Optional feedback about this anomaly.
        public let comment: String?
        /// The name of the profiling group that is associated with the analysis data.
        public let profilingGroupName: String
        ///  The feedback tpye. Thee are two valid values, Positive and Negative.
        public let type: FeedbackType

        public init(anomalyInstanceId: String, comment: String? = nil, profilingGroupName: String, type: FeedbackType) {
            self.anomalyInstanceId = anomalyInstanceId
            self.comment = comment
            self.profilingGroupName = profilingGroupName
            self.type = type
        }

        public func validate(name: String) throws {
            try self.validate(self.anomalyInstanceId, name: "anomalyInstanceId", parent: name, pattern: "[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}")
            try self.validate(self.profilingGroupName, name: "profilingGroupName", parent: name, max: 255)
            try self.validate(self.profilingGroupName, name: "profilingGroupName", parent: name, min: 1)
            try self.validate(self.profilingGroupName, name: "profilingGroupName", parent: name, pattern: "^[\\w-]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case comment
            case type
        }
    }

    public struct SubmitFeedbackResponse: AWSDecodableShape {
        public init() {}
    }

    public struct TagResourceRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "resourceArn", location: .uri(locationName: "resourceArn"))
        ]

        ///  The Amazon Resource Name (ARN) of the resource that the tags are added to.
        public let resourceArn: String
        ///  The list of tags that are added to the specified resource.
        public let tags: [String: String]

        public init(resourceArn: String, tags: [String: String]) {
            self.resourceArn = resourceArn
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case tags
        }
    }

    public struct TagResourceResponse: AWSDecodableShape {
        public init() {}
    }

    public struct TimestampStructure: AWSDecodableShape {
        ///  A Timestamp. This is specified using the ISO 8601 format. For example, 2020-06-01T13:15:02.001Z represents 1 millisecond past June 1, 2020 1:15:02 PM UTC.
        @CustomCoding<ISO8601DateCoder>
        public var value: Date

        public init(value: Date) {
            self.value = value
        }

        private enum CodingKeys: String, CodingKey {
            case value
        }
    }

    public struct UntagResourceRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "resourceArn", location: .uri(locationName: "resourceArn")),
            AWSMemberEncoding(label: "tagKeys", location: .querystring(locationName: "tagKeys"))
        ]

        ///  The Amazon Resource Name (ARN) of the resource that contains the tags to remove.
        public let resourceArn: String
        ///  A list of tag keys. Existing tags of resources with keys in this list are removed from the specified resource.
        public let tagKeys: [String]

        public init(resourceArn: String, tagKeys: [String]) {
            self.resourceArn = resourceArn
            self.tagKeys = tagKeys
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct UntagResourceResponse: AWSDecodableShape {
        public init() {}
    }

    public struct UpdateProfilingGroupRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "profilingGroupName", location: .uri(locationName: "profilingGroupName"))
        ]

        ///  Specifies whether profiling is enabled or disabled for a profiling group.
        public let agentOrchestrationConfig: AgentOrchestrationConfig
        /// The name of the profiling group to update.
        public let profilingGroupName: String

        public init(agentOrchestrationConfig: AgentOrchestrationConfig, profilingGroupName: String) {
            self.agentOrchestrationConfig = agentOrchestrationConfig
            self.profilingGroupName = profilingGroupName
        }

        public func validate(name: String) throws {
            try self.validate(self.profilingGroupName, name: "profilingGroupName", parent: name, max: 255)
            try self.validate(self.profilingGroupName, name: "profilingGroupName", parent: name, min: 1)
            try self.validate(self.profilingGroupName, name: "profilingGroupName", parent: name, pattern: "^[\\w-]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case agentOrchestrationConfig
        }
    }

    public struct UpdateProfilingGroupResponse: AWSDecodableShape & AWSShapeWithPayload {
        /// The key for the payload
        public static let _payloadPath: String = "profilingGroup"

        ///  A  ProfilingGroupDescription  that contains information about the returned updated profiling group.
        public let profilingGroup: ProfilingGroupDescription

        public init(profilingGroup: ProfilingGroupDescription) {
            self.profilingGroup = profilingGroup
        }

        private enum CodingKeys: String, CodingKey {
            case profilingGroup
        }
    }

    public struct UserFeedback: AWSDecodableShape {
        /// Optional Positive or Negative feedback submitted by the user about whether the recommendation is useful or not.
        public let type: FeedbackType

        public init(type: FeedbackType) {
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case type
        }
    }
}
