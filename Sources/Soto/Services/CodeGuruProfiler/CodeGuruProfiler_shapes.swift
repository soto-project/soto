//===----------------------------------------------------------------------===//
//
// This source file is part of the Soto for AWS open source project
//
// Copyright (c) 2017-2023 the Soto project authors
// Licensed under Apache License v2.0
//
// See LICENSE.txt for license information
// See CONTRIBUTORS.txt for the list of Soto project authors
//
// SPDX-License-Identifier: Apache-2.0
//
//===----------------------------------------------------------------------===//

// THIS FILE IS AUTOMATICALLY GENERATED by https://github.com/soto-project/soto-codegenerator.
// DO NOT EDIT.

#if os(Linux) && compiler(<5.10)
// swift-corelibs-foundation hasn't been updated with Sendable conformances
@preconcurrency import Foundation
#else
import Foundation
#endif
@_spi(SotoInternal) import SotoCore

extension CodeGuruProfiler {
    // MARK: Enums

    public enum ActionGroup: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        /// Permission group type for Agent APIs - ConfigureAgent, PostAgentProfile
        case agentPermissions = "agentPermissions"
        public var description: String { return self.rawValue }
    }

    public enum AgentParameterField: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        /// Maximum stack depth to be captured by the CodeGuru Profiler.
        case maxStackDepth = "MaxStackDepth"
        /// Percentage of memory to be used by CodeGuru profiler. Minimum of 30MB is required for the agent.
        case memoryUsageLimitPercent = "MemoryUsageLimitPercent"
        /// Minimum time in milliseconds between sending reports.
        case minimumTimeForReportingInMilliseconds = "MinimumTimeForReportingInMilliseconds"
        /// Reporting interval in milliseconds used to report profiles.
        case reportingIntervalInMilliseconds = "ReportingIntervalInMilliseconds"
        /// Sampling interval in milliseconds used to sample profiles.
        case samplingIntervalInMilliseconds = "SamplingIntervalInMilliseconds"
        public var description: String { return self.rawValue }
    }

    public enum AggregationPeriod: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        /// Period of one day.
        case p1d = "P1D"
        /// Period of one hour.
        case pt1h = "PT1H"
        /// Period of five minutes.
        case pt5m = "PT5M"
        public var description: String { return self.rawValue }
    }

    public enum ComputePlatform: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        /// Compute platform meant to used for AWS Lambda.
        case awsLambda = "AWSLambda"
        /// Compute platform meant to used for all usecases (like EC2, Fargate, physical servers etc.) but AWS Lambda.
        case `default` = "Default"
        public var description: String { return self.rawValue }
    }

    public enum EventPublisher: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        /// Notifications for Anomaly Detection
        case anomalyDetection = "AnomalyDetection"
        public var description: String { return self.rawValue }
    }

    public enum FeedbackType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        /// Profiler recommendation flagged as not useful.
        case negative = "Negative"
        /// Profiler recommendation flagged as useful.
        case positive = "Positive"
        public var description: String { return self.rawValue }
    }

    public enum MetadataField: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        /// Unique identifier for the agent instance.
        case agentId = "AgentId"
        /// AWS requestId of the Lambda invocation.
        case awsRequestId = "AwsRequestId"
        /// Compute platform on which agent is running.
        case computePlatform = "ComputePlatform"
        /// Execution environment on which Lambda function is running.
        case executionEnvironment = "ExecutionEnvironment"
        /// Function ARN that's used to invoke the Lambda function.
        case lambdaFunctionArn = "LambdaFunctionArn"
        /// Memory allocated for the Lambda function.
        case lambdaMemoryLimitInMB = "LambdaMemoryLimitInMB"
        /// Time in milliseconds for the previous Lambda invocation.
        case lambdaPreviousExecutionTimeInMilliseconds = "LambdaPreviousExecutionTimeInMilliseconds"
        /// Time in milliseconds left before the execution times out.
        case lambdaRemainingTimeInMilliseconds = "LambdaRemainingTimeInMilliseconds"
        /// Time in milliseconds between two invocations of the Lambda function.
        case lambdaTimeGapBetweenInvokesInMilliseconds = "LambdaTimeGapBetweenInvokesInMilliseconds"
        public var description: String { return self.rawValue }
    }

    public enum MetricType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        /// Metric value aggregated for all instances of a frame name in a profile relative to the root frame.
        case aggregatedRelativeTotalTime = "AggregatedRelativeTotalTime"
        public var description: String { return self.rawValue }
    }

    public enum OrderBy: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        /// Order by timestamp in ascending order.
        case timestampAscending = "TimestampAscending"
        /// Order by timestamp in descending order.
        case timestampDescending = "TimestampDescending"
        public var description: String { return self.rawValue }
    }

    // MARK: Shapes

    public struct AddNotificationChannelsRequest: AWSEncodableShape {
        /// One or 2 channels to report to when anomalies are detected.
        public let channels: [Channel]
        /// The name of the profiling group that we are setting up notifications for.
        public let profilingGroupName: String

        public init(channels: [Channel], profilingGroupName: String) {
            self.channels = channels
            self.profilingGroupName = profilingGroupName
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encode(self.channels, forKey: .channels)
            request.encodePath(self.profilingGroupName, key: "profilingGroupName")
        }

        public func validate(name: String) throws {
            try self.channels.forEach {
                try $0.validate(name: "\(name).channels[]")
            }
            try self.validate(self.channels, name: "channels", parent: name, max: 2)
            try self.validate(self.channels, name: "channels", parent: name, min: 1)
            try self.validate(self.profilingGroupName, name: "profilingGroupName", parent: name, max: 255)
            try self.validate(self.profilingGroupName, name: "profilingGroupName", parent: name, min: 1)
            try self.validate(self.profilingGroupName, name: "profilingGroupName", parent: name, pattern: "^[\\w-]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case channels = "channels"
        }
    }

    public struct AddNotificationChannelsResponse: AWSDecodableShape {
        /// The new notification configuration for this profiling group.
        public let notificationConfiguration: NotificationConfiguration?

        public init(notificationConfiguration: NotificationConfiguration? = nil) {
            self.notificationConfiguration = notificationConfiguration
        }

        private enum CodingKeys: String, CodingKey {
            case notificationConfiguration = "notificationConfiguration"
        }
    }

    public struct AgentConfiguration: AWSDecodableShape {
        ///  Parameters used by the profiler. The valid parameters are:      MaxStackDepth - The maximum depth of the stacks in the code that is represented in  the profile. For example, if CodeGuru Profiler finds a method A,  which calls method B, which calls method C, which  calls method D, then the depth is 4. If the maxDepth is  set to 2, then the profiler evaluates A and B.     MemoryUsageLimitPercent - The percentage of memory that is used by the profiler.    MinimumTimeForReportingInMilliseconds - The minimum time in milliseconds between  sending reports.     ReportingIntervalInMilliseconds - The reporting interval in milliseconds used  to report profiles.     SamplingIntervalInMilliseconds - The sampling interval in milliseconds that is used to  profile samples.
        public let agentParameters: [AgentParameterField: String]?
        ///  How long a profiling agent should send profiling data using   ConfigureAgent .  For example, if this is set to 300, the profiling agent calls  ConfigureAgent  every 5 minutes to submit the profiled data collected during that period.
        public let periodInSeconds: Int
        ///  A Boolean that specifies whether the profiling agent collects profiling data or not. Set to true to enable profiling.
        public let shouldProfile: Bool

        public init(agentParameters: [AgentParameterField: String]? = nil, periodInSeconds: Int, shouldProfile: Bool) {
            self.agentParameters = agentParameters
            self.periodInSeconds = periodInSeconds
            self.shouldProfile = shouldProfile
        }

        private enum CodingKeys: String, CodingKey {
            case agentParameters = "agentParameters"
            case periodInSeconds = "periodInSeconds"
            case shouldProfile = "shouldProfile"
        }
    }

    public struct AgentOrchestrationConfig: AWSEncodableShape & AWSDecodableShape {
        ///  A Boolean that specifies whether the profiling agent collects profiling data or not. Set to true to enable profiling.
        public let profilingEnabled: Bool

        public init(profilingEnabled: Bool) {
            self.profilingEnabled = profilingEnabled
        }

        private enum CodingKeys: String, CodingKey {
            case profilingEnabled = "profilingEnabled"
        }
    }

    public struct AggregatedProfileTime: AWSDecodableShape {
        ///  The aggregation period. This indicates the period during which an aggregation profile  collects posted agent profiles for a profiling group. Use one of three valid  durations that are specified using the ISO 8601 format.     P1D — 1 day     PT1H — 1 hour     PT5M — 5 minutes
        public let period: AggregationPeriod?
        ///  The time that aggregation of posted agent profiles for a profiling group starts. The aggregation profile  contains profiles posted by the agent starting at this time for an aggregation period   specified by the period property of the AggregatedProfileTime  object.   Specify start using the ISO 8601 format. For example,  2020-06-01T13:15:02.001Z  represents 1 millisecond past June 1, 2020 1:15:02 PM UTC.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var start: Date?

        public init(period: AggregationPeriod? = nil, start: Date? = nil) {
            self.period = period
            self.start = start
        }

        private enum CodingKeys: String, CodingKey {
            case period = "period"
            case start = "start"
        }
    }

    public struct Anomaly: AWSDecodableShape {
        ///  A list of the instances of the detected anomalies during the requested period.
        public let instances: [AnomalyInstance]
        ///  Details about the metric that the analysis used when it detected the anomaly.  The metric includes the name of the frame that was analyzed with the type and  thread states used to derive the metric value for that frame.
        public let metric: Metric
        /// The reason for which metric was flagged as anomalous.
        public let reason: String

        public init(instances: [AnomalyInstance], metric: Metric, reason: String) {
            self.instances = instances
            self.metric = metric
            self.reason = reason
        }

        private enum CodingKeys: String, CodingKey {
            case instances = "instances"
            case metric = "metric"
            case reason = "reason"
        }
    }

    public struct AnomalyInstance: AWSDecodableShape {
        ///  The end time of the period during which the metric is flagged as anomalous.  This is specified  using the ISO 8601 format. For example, 2020-06-01T13:15:02.001Z represents 1  millisecond past June 1, 2020 1:15:02 PM UTC.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var endTime: Date?
        ///  The universally unique identifier (UUID) of an instance of an anomaly in a metric.
        public let id: String
        ///  The start time of the period during which the metric is flagged as anomalous.  This is specified  using the ISO 8601 format. For example, 2020-06-01T13:15:02.001Z represents 1  millisecond past June 1, 2020 1:15:02 PM UTC.
        @CustomCoding<ISO8601DateCoder>
        public var startTime: Date
        /// Feedback type on a specific instance of anomaly submitted by the user.
        public let userFeedback: UserFeedback?

        public init(endTime: Date? = nil, id: String, startTime: Date, userFeedback: UserFeedback? = nil) {
            self.endTime = endTime
            self.id = id
            self.startTime = startTime
            self.userFeedback = userFeedback
        }

        private enum CodingKeys: String, CodingKey {
            case endTime = "endTime"
            case id = "id"
            case startTime = "startTime"
            case userFeedback = "userFeedback"
        }
    }

    public struct BatchGetFrameMetricDataRequest: AWSEncodableShape {
        ///  The end time of the time period for the returned time series values.  This is specified  using the ISO 8601 format. For example, 2020-06-01T13:15:02.001Z represents 1  millisecond past June 1, 2020 1:15:02 PM UTC.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var endTime: Date?
        ///  The details of the metrics that are used to request a time series of values. The metric includes  the name of the frame, the aggregation type to calculate the metric value for the  frame, and the thread states to use to get the count for the metric value of the frame.
        public let frameMetrics: [FrameMetric]?
        ///  The duration of the frame metrics used to return the time series values.  Specify using the ISO 8601 format. The maximum period duration  is one day (PT24H or P1D).
        public let period: String?
        ///  The name of the profiling group associated with the  the frame metrics used to return the time series values.
        public let profilingGroupName: String
        ///  The start time of the time period for the frame metrics used to return the time series values.  This is specified  using the ISO 8601 format. For example, 2020-06-01T13:15:02.001Z represents 1  millisecond past June 1, 2020 1:15:02 PM UTC.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var startTime: Date?
        /// The requested resolution of time steps for the returned time series of values.  If the requested target resolution is not available due to data not being retained we provide a best effort  result by falling back to the most granular available resolution after the target resolution.  There are 3 valid values.     P1D — 1 day     PT1H — 1 hour     PT5M — 5 minutes
        public let targetResolution: AggregationPeriod?

        public init(endTime: Date? = nil, frameMetrics: [FrameMetric]? = nil, period: String? = nil, profilingGroupName: String, startTime: Date? = nil, targetResolution: AggregationPeriod? = nil) {
            self.endTime = endTime
            self.frameMetrics = frameMetrics
            self.period = period
            self.profilingGroupName = profilingGroupName
            self.startTime = startTime
            self.targetResolution = targetResolution
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self._endTime, key: "endTime")
            try container.encodeIfPresent(self.frameMetrics, forKey: .frameMetrics)
            request.encodeQuery(self.period, key: "period")
            request.encodePath(self.profilingGroupName, key: "profilingGroupName")
            request.encodeQuery(self._startTime, key: "startTime")
            request.encodeQuery(self.targetResolution, key: "targetResolution")
        }

        public func validate(name: String) throws {
            try self.validate(self.period, name: "period", parent: name, max: 64)
            try self.validate(self.period, name: "period", parent: name, min: 1)
            try self.validate(self.profilingGroupName, name: "profilingGroupName", parent: name, max: 255)
            try self.validate(self.profilingGroupName, name: "profilingGroupName", parent: name, min: 1)
            try self.validate(self.profilingGroupName, name: "profilingGroupName", parent: name, pattern: "^[\\w-]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case frameMetrics = "frameMetrics"
        }
    }

    public struct BatchGetFrameMetricDataResponse: AWSDecodableShape {
        ///  The end time of the time period for the returned time series values.  This is specified  using the ISO 8601 format. For example, 2020-06-01T13:15:02.001Z represents 1  millisecond past June 1, 2020 1:15:02 PM UTC.
        @CustomCoding<ISO8601DateCoder>
        public var endTime: Date
        ///  List of instances, or time steps, in the time series. For example, if the  period is one day (PT24H)), and the resolution  is five minutes (PT5M), then there are 288 endTimes in the  list that are each five minutes appart.
        public let endTimes: [TimestampStructure]
        /// Details of the metrics to request a time series of values. The metric includes  the name of the frame, the aggregation type to calculate the metric value for the frame,  and the thread states to use to get the count for the metric value of the frame.
        public let frameMetricData: [FrameMetricDatum]
        /// Resolution or granularity of the profile data used to generate the time series.  This is the value used to jump through time steps in a time series. There are 3 valid values.     P1D — 1 day     PT1H — 1 hour     PT5M — 5 minutes
        public let resolution: AggregationPeriod
        ///  The start time of the time period for the returned time series values.  This is specified  using the ISO 8601 format. For example, 2020-06-01T13:15:02.001Z represents 1  millisecond past June 1, 2020 1:15:02 PM UTC.
        @CustomCoding<ISO8601DateCoder>
        public var startTime: Date
        /// List of instances which remained unprocessed. This will create a missing time step in the list of end times.
        public let unprocessedEndTimes: [String: [TimestampStructure]]

        public init(endTime: Date, endTimes: [TimestampStructure], frameMetricData: [FrameMetricDatum], resolution: AggregationPeriod, startTime: Date, unprocessedEndTimes: [String: [TimestampStructure]]) {
            self.endTime = endTime
            self.endTimes = endTimes
            self.frameMetricData = frameMetricData
            self.resolution = resolution
            self.startTime = startTime
            self.unprocessedEndTimes = unprocessedEndTimes
        }

        private enum CodingKeys: String, CodingKey {
            case endTime = "endTime"
            case endTimes = "endTimes"
            case frameMetricData = "frameMetricData"
            case resolution = "resolution"
            case startTime = "startTime"
            case unprocessedEndTimes = "unprocessedEndTimes"
        }
    }

    public struct Channel: AWSEncodableShape & AWSDecodableShape {
        /// List of publishers for different type of events that may be detected in an application from the profile. Anomaly detection is the only event publisher in Profiler.
        public let eventPublishers: [EventPublisher]
        /// Unique identifier for each Channel in the notification configuration of a Profiling Group. A random UUID for channelId is used when adding a channel to the notification configuration if not specified in the request.
        public let id: String?
        /// Unique arn of the resource to be used for notifications. We support a valid SNS topic arn as a channel uri.
        public let uri: String

        public init(eventPublishers: [EventPublisher], id: String? = nil, uri: String) {
            self.eventPublishers = eventPublishers
            self.id = id
            self.uri = uri
        }

        public func validate(name: String) throws {
            try self.validate(self.eventPublishers, name: "eventPublishers", parent: name, max: 1)
            try self.validate(self.eventPublishers, name: "eventPublishers", parent: name, min: 1)
            try self.validate(self.id, name: "id", parent: name, pattern: "[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}")
        }

        private enum CodingKeys: String, CodingKey {
            case eventPublishers = "eventPublishers"
            case id = "id"
            case uri = "uri"
        }
    }

    public struct ConfigureAgentRequest: AWSEncodableShape {
        ///  A universally unique identifier (UUID) for a profiling instance. For example, if the profiling instance is an Amazon EC2 instance, it is the instance ID. If it is an AWS Fargate container, it is the container's task ID.
        public let fleetInstanceId: String?
        ///  Metadata captured about the compute platform the agent is running on. It includes information about sampling and reporting. The valid fields are:    COMPUTE_PLATFORM - The compute platform on which the agent is running     AGENT_ID - The ID for an agent instance.     AWS_REQUEST_ID - The AWS request ID of a Lambda invocation.     EXECUTION_ENVIRONMENT - The execution environment a Lambda function is running on.     LAMBDA_FUNCTION_ARN - The Amazon Resource Name (ARN) that is used to invoke a Lambda function.     LAMBDA_MEMORY_LIMIT_IN_MB - The memory allocated to a Lambda function.     LAMBDA_REMAINING_TIME_IN_MILLISECONDS - The time in milliseconds before execution of a Lambda function times out.     LAMBDA_TIME_GAP_BETWEEN_INVOKES_IN_MILLISECONDS - The time in milliseconds between two invocations of a Lambda function.     LAMBDA_PREVIOUS_EXECUTION_TIME_IN_MILLISECONDS - The time in milliseconds for the previous Lambda invocation.
        public let metadata: [MetadataField: String]?
        ///  The name of the profiling group for which the configured agent is collecting profiling data.
        public let profilingGroupName: String

        public init(fleetInstanceId: String? = nil, metadata: [MetadataField: String]? = nil, profilingGroupName: String) {
            self.fleetInstanceId = fleetInstanceId
            self.metadata = metadata
            self.profilingGroupName = profilingGroupName
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.fleetInstanceId, forKey: .fleetInstanceId)
            try container.encodeIfPresent(self.metadata, forKey: .metadata)
            request.encodePath(self.profilingGroupName, key: "profilingGroupName")
        }

        public func validate(name: String) throws {
            try self.validate(self.fleetInstanceId, name: "fleetInstanceId", parent: name, max: 255)
            try self.validate(self.fleetInstanceId, name: "fleetInstanceId", parent: name, min: 1)
            try self.validate(self.profilingGroupName, name: "profilingGroupName", parent: name, max: 255)
            try self.validate(self.profilingGroupName, name: "profilingGroupName", parent: name, min: 1)
            try self.validate(self.profilingGroupName, name: "profilingGroupName", parent: name, pattern: "^[\\w-]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case fleetInstanceId = "fleetInstanceId"
            case metadata = "metadata"
        }
    }

    public struct ConfigureAgentResponse: AWSDecodableShape {
        ///  An  AgentConfiguration  object that specifies if an agent profiles or not and for how long to return profiling data.
        public let configuration: AgentConfiguration

        public init(configuration: AgentConfiguration) {
            self.configuration = configuration
        }

        public init(from decoder: Decoder) throws {
            let container = try decoder.singleValueContainer()
            self.configuration = try container.decode(AgentConfiguration.self)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct CreateProfilingGroupRequest: AWSEncodableShape {
        ///  Specifies whether profiling is enabled or disabled for the created profiling group.
        public let agentOrchestrationConfig: AgentOrchestrationConfig?
        ///  Amazon CodeGuru Profiler uses this universally unique identifier (UUID) to prevent the accidental creation of duplicate profiling groups if there are failures and retries.
        public let clientToken: String
        ///  The compute platform of the profiling group. Use AWSLambda if your application  runs on AWS Lambda. Use Default if your application runs on a compute platform that  is not AWS Lambda, such an Amazon EC2 instance, an on-premises server, or a different platform.  If not specified, Default is used.
        public let computePlatform: ComputePlatform?
        /// The name of the profiling group to create.
        public let profilingGroupName: String
        ///  A list of tags to add to the created profiling group.
        public let tags: [String: String]?

        public init(agentOrchestrationConfig: AgentOrchestrationConfig? = nil, clientToken: String = CreateProfilingGroupRequest.idempotencyToken(), computePlatform: ComputePlatform? = nil, profilingGroupName: String, tags: [String: String]? = nil) {
            self.agentOrchestrationConfig = agentOrchestrationConfig
            self.clientToken = clientToken
            self.computePlatform = computePlatform
            self.profilingGroupName = profilingGroupName
            self.tags = tags
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.agentOrchestrationConfig, forKey: .agentOrchestrationConfig)
            request.encodeQuery(self.clientToken, key: "clientToken")
            try container.encodeIfPresent(self.computePlatform, forKey: .computePlatform)
            try container.encode(self.profilingGroupName, forKey: .profilingGroupName)
            try container.encodeIfPresent(self.tags, forKey: .tags)
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 64)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "^[\\w-]+$")
            try self.validate(self.profilingGroupName, name: "profilingGroupName", parent: name, max: 255)
            try self.validate(self.profilingGroupName, name: "profilingGroupName", parent: name, min: 1)
            try self.validate(self.profilingGroupName, name: "profilingGroupName", parent: name, pattern: "^[\\w-]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case agentOrchestrationConfig = "agentOrchestrationConfig"
            case computePlatform = "computePlatform"
            case profilingGroupName = "profilingGroupName"
            case tags = "tags"
        }
    }

    public struct CreateProfilingGroupResponse: AWSDecodableShape {
        ///  The returned  ProfilingGroupDescription object that contains information about the created profiling group.
        public let profilingGroup: ProfilingGroupDescription

        public init(profilingGroup: ProfilingGroupDescription) {
            self.profilingGroup = profilingGroup
        }

        public init(from decoder: Decoder) throws {
            let container = try decoder.singleValueContainer()
            self.profilingGroup = try container.decode(ProfilingGroupDescription.self)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteProfilingGroupRequest: AWSEncodableShape {
        /// The name of the profiling group to delete.
        public let profilingGroupName: String

        public init(profilingGroupName: String) {
            self.profilingGroupName = profilingGroupName
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.profilingGroupName, key: "profilingGroupName")
        }

        public func validate(name: String) throws {
            try self.validate(self.profilingGroupName, name: "profilingGroupName", parent: name, max: 255)
            try self.validate(self.profilingGroupName, name: "profilingGroupName", parent: name, min: 1)
            try self.validate(self.profilingGroupName, name: "profilingGroupName", parent: name, pattern: "^[\\w-]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteProfilingGroupResponse: AWSDecodableShape {
        public init() {}
    }

    public struct DescribeProfilingGroupRequest: AWSEncodableShape {
        ///  The name of the profiling group to get information about.
        public let profilingGroupName: String

        public init(profilingGroupName: String) {
            self.profilingGroupName = profilingGroupName
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.profilingGroupName, key: "profilingGroupName")
        }

        public func validate(name: String) throws {
            try self.validate(self.profilingGroupName, name: "profilingGroupName", parent: name, max: 255)
            try self.validate(self.profilingGroupName, name: "profilingGroupName", parent: name, min: 1)
            try self.validate(self.profilingGroupName, name: "profilingGroupName", parent: name, pattern: "^[\\w-]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DescribeProfilingGroupResponse: AWSDecodableShape {
        ///  The returned  ProfilingGroupDescription  object that contains information about the requested profiling group.
        public let profilingGroup: ProfilingGroupDescription

        public init(profilingGroup: ProfilingGroupDescription) {
            self.profilingGroup = profilingGroup
        }

        public init(from decoder: Decoder) throws {
            let container = try decoder.singleValueContainer()
            self.profilingGroup = try container.decode(ProfilingGroupDescription.self)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct FindingsReportSummary: AWSDecodableShape {
        /// The universally unique identifier (UUID) of the recommendation report.
        public let id: String?
        ///  The end time of the period during which the metric is flagged as anomalous.  This is specified  using the ISO 8601 format. For example, 2020-06-01T13:15:02.001Z represents 1  millisecond past June 1, 2020 1:15:02 PM UTC.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var profileEndTime: Date?
        /// The start time of the profile the analysis data is about.  This is specified  using the ISO 8601 format. For example, 2020-06-01T13:15:02.001Z represents 1  millisecond past June 1, 2020 1:15:02 PM UTC.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var profileStartTime: Date?
        /// The name of the profiling group that is associated with the analysis data.
        public let profilingGroupName: String?
        /// The total number of different recommendations that were found by the analysis.
        public let totalNumberOfFindings: Int?

        public init(id: String? = nil, profileEndTime: Date? = nil, profileStartTime: Date? = nil, profilingGroupName: String? = nil, totalNumberOfFindings: Int? = nil) {
            self.id = id
            self.profileEndTime = profileEndTime
            self.profileStartTime = profileStartTime
            self.profilingGroupName = profilingGroupName
            self.totalNumberOfFindings = totalNumberOfFindings
        }

        private enum CodingKeys: String, CodingKey {
            case id = "id"
            case profileEndTime = "profileEndTime"
            case profileStartTime = "profileStartTime"
            case profilingGroupName = "profilingGroupName"
            case totalNumberOfFindings = "totalNumberOfFindings"
        }
    }

    public struct FrameMetric: AWSEncodableShape & AWSDecodableShape {
        ///  Name of the method common across the multiple occurrences of a frame in an application profile.
        public let frameName: String
        /// List of application runtime thread states used to get the counts for a frame a derive a metric value.
        public let threadStates: [String]
        ///  A type of aggregation that specifies how a metric for a frame is analyzed. The supported value AggregatedRelativeTotalTime is an aggregation of the metric value for one frame that is calculated across the occurrences of all frames in a profile.
        public let type: MetricType

        public init(frameName: String, threadStates: [String], type: MetricType) {
            self.frameName = frameName
            self.threadStates = threadStates
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case frameName = "frameName"
            case threadStates = "threadStates"
            case type = "type"
        }
    }

    public struct FrameMetricDatum: AWSDecodableShape {
        public let frameMetric: FrameMetric
        ///  A list of values that are associated with a frame metric.
        public let values: [Double]

        public init(frameMetric: FrameMetric, values: [Double]) {
            self.frameMetric = frameMetric
            self.values = values
        }

        private enum CodingKeys: String, CodingKey {
            case frameMetric = "frameMetric"
            case values = "values"
        }
    }

    public struct GetFindingsReportAccountSummaryRequest: AWSEncodableShape {
        /// A Boolean value indicating whether to only return reports from daily profiles. If set  to True, only analysis data from daily profiles is returned. If set to False,  analysis data is returned from smaller time windows (for example, one hour).
        public let dailyReportsOnly: Bool?
        /// The maximum number of results returned by  GetFindingsReportAccountSummary in paginated output.  When this parameter is used, GetFindingsReportAccountSummary only returns maxResults  results in a single page along with a nextToken response element. The remaining results of the initial  request can be seen by sending another GetFindingsReportAccountSummary request with the returned  nextToken value.
        public let maxResults: Int?
        /// The nextToken value returned from a previous paginated GetFindingsReportAccountSummary request where maxResults was used and the results exceeded the value of that parameter. Pagination continues from the end of the previous results that returned the nextToken value.   This token should be treated as an opaque identifier that is only used to retrieve the next items in a list and not for other programmatic purposes.
        public let nextToken: String?

        public init(dailyReportsOnly: Bool? = nil, maxResults: Int? = nil, nextToken: String? = nil) {
            self.dailyReportsOnly = dailyReportsOnly
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.dailyReportsOnly, key: "dailyReportsOnly")
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 1000)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 64)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^[\\w-]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetFindingsReportAccountSummaryResponse: AWSDecodableShape {
        /// The nextToken value to include in a future GetFindingsReportAccountSummary request. When the results of a GetFindingsReportAccountSummary request exceed maxResults, this value can be used to retrieve the next page of results. This value is null when there are no more results to return.
        public let nextToken: String?
        /// The return list of   FindingsReportSummary  objects taht contain summaries of analysis results for all profiling groups in your AWS account.
        public let reportSummaries: [FindingsReportSummary]

        public init(nextToken: String? = nil, reportSummaries: [FindingsReportSummary]) {
            self.nextToken = nextToken
            self.reportSummaries = reportSummaries
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "nextToken"
            case reportSummaries = "reportSummaries"
        }
    }

    public struct GetNotificationConfigurationRequest: AWSEncodableShape {
        /// The name of the profiling group we want to get the notification configuration for.
        public let profilingGroupName: String

        public init(profilingGroupName: String) {
            self.profilingGroupName = profilingGroupName
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.profilingGroupName, key: "profilingGroupName")
        }

        public func validate(name: String) throws {
            try self.validate(self.profilingGroupName, name: "profilingGroupName", parent: name, max: 255)
            try self.validate(self.profilingGroupName, name: "profilingGroupName", parent: name, min: 1)
            try self.validate(self.profilingGroupName, name: "profilingGroupName", parent: name, pattern: "^[\\w-]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetNotificationConfigurationResponse: AWSDecodableShape {
        /// The current notification configuration for this profiling group.
        public let notificationConfiguration: NotificationConfiguration

        public init(notificationConfiguration: NotificationConfiguration) {
            self.notificationConfiguration = notificationConfiguration
        }

        private enum CodingKeys: String, CodingKey {
            case notificationConfiguration = "notificationConfiguration"
        }
    }

    public struct GetPolicyRequest: AWSEncodableShape {
        /// The name of the profiling group.
        public let profilingGroupName: String

        public init(profilingGroupName: String) {
            self.profilingGroupName = profilingGroupName
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.profilingGroupName, key: "profilingGroupName")
        }

        public func validate(name: String) throws {
            try self.validate(self.profilingGroupName, name: "profilingGroupName", parent: name, max: 255)
            try self.validate(self.profilingGroupName, name: "profilingGroupName", parent: name, min: 1)
            try self.validate(self.profilingGroupName, name: "profilingGroupName", parent: name, pattern: "^[\\w-]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetPolicyResponse: AWSDecodableShape {
        /// The JSON-formatted resource-based policy attached to the ProfilingGroup.
        public let policy: String
        /// A unique identifier for the current revision of the returned policy.
        public let revisionId: String

        public init(policy: String, revisionId: String) {
            self.policy = policy
            self.revisionId = revisionId
        }

        private enum CodingKeys: String, CodingKey {
            case policy = "policy"
            case revisionId = "revisionId"
        }
    }

    public struct GetProfileRequest: AWSEncodableShape {
        ///  The format of the returned profiling data. The format maps to the  Accept and Content-Type headers of the  HTTP request. You can specify one of the following:  or the default .      application/json — standard JSON format      application/x-amzn-ion — the Amazon Ion data format. For more information,  see Amazon Ion.
        public let accept: String?
        ///  The end time of the requested profile. Specify using  the ISO 8601 format. For example,  2020-06-01T13:15:02.001Z  represents 1 millisecond past June 1, 2020 1:15:02 PM UTC.   If you specify endTime, then you must also specify period  or startTime, but not both.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var endTime: Date?
        ///  The maximum depth of the stacks in the code that is represented in  the aggregated profile. For example, if CodeGuru Profiler finds a method A,  which calls method B, which calls method C, which  calls method D, then the depth is 4. If the maxDepth is  set to 2, then the aggregated profile contains representations of methods A  and B.
        public let maxDepth: Int?
        ///  Used with startTime or endTime to specify  the time range for the returned aggregated profile. Specify using  the ISO 8601 format. For example, P1DT1H1M1S.    To get the latest aggregated profile, specify only period.
        public let period: String?
        /// The name of the profiling group to get.
        public let profilingGroupName: String
        /// The start time of the profile to get. Specify using  the ISO 8601 format. For example,  2020-06-01T13:15:02.001Z  represents 1 millisecond past June 1, 2020 1:15:02 PM UTC.   If you specify startTime, then you must also specify period  or endTime, but not both.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var startTime: Date?

        public init(accept: String? = nil, endTime: Date? = nil, maxDepth: Int? = nil, period: String? = nil, profilingGroupName: String, startTime: Date? = nil) {
            self.accept = accept
            self.endTime = endTime
            self.maxDepth = maxDepth
            self.period = period
            self.profilingGroupName = profilingGroupName
            self.startTime = startTime
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeHeader(self.accept, key: "Accept")
            request.encodeQuery(self._endTime, key: "endTime")
            request.encodeQuery(self.maxDepth, key: "maxDepth")
            request.encodeQuery(self.period, key: "period")
            request.encodePath(self.profilingGroupName, key: "profilingGroupName")
            request.encodeQuery(self._startTime, key: "startTime")
        }

        public func validate(name: String) throws {
            try self.validate(self.maxDepth, name: "maxDepth", parent: name, max: 10000)
            try self.validate(self.maxDepth, name: "maxDepth", parent: name, min: 1)
            try self.validate(self.period, name: "period", parent: name, max: 64)
            try self.validate(self.period, name: "period", parent: name, min: 1)
            try self.validate(self.profilingGroupName, name: "profilingGroupName", parent: name, max: 255)
            try self.validate(self.profilingGroupName, name: "profilingGroupName", parent: name, min: 1)
            try self.validate(self.profilingGroupName, name: "profilingGroupName", parent: name, pattern: "^[\\w-]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetProfileResponse: AWSDecodableShape {
        public static let _options: AWSShapeOptions = [.rawPayload]
        /// The content encoding of the profile.
        public let contentEncoding: String?
        /// The content type of the profile in the payload. It is either application/json or the default  application/x-amzn-ion.
        public let contentType: String
        /// Information about the profile.
        public let profile: AWSHTTPBody

        public init(contentEncoding: String? = nil, contentType: String, profile: AWSHTTPBody) {
            self.contentEncoding = contentEncoding
            self.contentType = contentType
            self.profile = profile
        }

        public init(from decoder: Decoder) throws {
            let response = decoder.userInfo[.awsResponse]! as! ResponseDecodingContainer
            let container = try decoder.singleValueContainer()
            self.contentEncoding = try response.decodeHeaderIfPresent(String.self, key: "Content-Encoding")
            self.contentType = try response.decodeHeader(String.self, key: "Content-Type")
            self.profile = try container.decode(AWSHTTPBody.self)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetRecommendationsRequest: AWSEncodableShape {
        ///  The start time of the profile to get analysis data about. You must specify startTime and endTime.  This is specified  using the ISO 8601 format. For example, 2020-06-01T13:15:02.001Z represents 1  millisecond past June 1, 2020 1:15:02 PM UTC.
        @CustomCoding<ISO8601DateCoder>
        public var endTime: Date
        ///  The language used to provide analysis. Specify using a string that is one  of the following BCP 47 language codes.     de-DE - German, Germany     en-GB - English, United Kingdom     en-US - English, United States     es-ES - Spanish, Spain     fr-FR - French, France     it-IT - Italian, Italy     ja-JP - Japanese, Japan     ko-KR - Korean, Republic of Korea     pt-BR - Portugese, Brazil     zh-CN - Chinese, China     zh-TW - Chinese, Taiwan
        public let locale: String?
        ///  The name of the profiling group to get analysis data about.
        public let profilingGroupName: String
        ///  The end time of the profile to get analysis data about. You must specify startTime and endTime.  This is specified  using the ISO 8601 format. For example, 2020-06-01T13:15:02.001Z represents 1  millisecond past June 1, 2020 1:15:02 PM UTC.
        @CustomCoding<ISO8601DateCoder>
        public var startTime: Date

        public init(endTime: Date, locale: String? = nil, profilingGroupName: String, startTime: Date) {
            self.endTime = endTime
            self.locale = locale
            self.profilingGroupName = profilingGroupName
            self.startTime = startTime
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self._endTime, key: "endTime")
            request.encodeQuery(self.locale, key: "locale")
            request.encodePath(self.profilingGroupName, key: "profilingGroupName")
            request.encodeQuery(self._startTime, key: "startTime")
        }

        public func validate(name: String) throws {
            try self.validate(self.profilingGroupName, name: "profilingGroupName", parent: name, max: 255)
            try self.validate(self.profilingGroupName, name: "profilingGroupName", parent: name, min: 1)
            try self.validate(self.profilingGroupName, name: "profilingGroupName", parent: name, pattern: "^[\\w-]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetRecommendationsResponse: AWSDecodableShape {
        ///  The list of anomalies that the analysis has found for this profile.
        public let anomalies: [Anomaly]
        ///  The end time of the profile the analysis data is about. This is specified  using the ISO 8601 format. For example, 2020-06-01T13:15:02.001Z represents 1  millisecond past June 1, 2020 1:15:02 PM UTC.
        @CustomCoding<ISO8601DateCoder>
        public var profileEndTime: Date
        ///  The start time of the profile the analysis data is about. This is specified  using the ISO 8601 format. For example, 2020-06-01T13:15:02.001Z represents 1  millisecond past June 1, 2020 1:15:02 PM UTC.
        @CustomCoding<ISO8601DateCoder>
        public var profileStartTime: Date
        /// The name of the profiling group the analysis data is about.
        public let profilingGroupName: String
        /// The list of recommendations that the analysis found for this profile.
        public let recommendations: [Recommendation]

        public init(anomalies: [Anomaly], profileEndTime: Date, profileStartTime: Date, profilingGroupName: String, recommendations: [Recommendation]) {
            self.anomalies = anomalies
            self.profileEndTime = profileEndTime
            self.profileStartTime = profileStartTime
            self.profilingGroupName = profilingGroupName
            self.recommendations = recommendations
        }

        private enum CodingKeys: String, CodingKey {
            case anomalies = "anomalies"
            case profileEndTime = "profileEndTime"
            case profileStartTime = "profileStartTime"
            case profilingGroupName = "profilingGroupName"
            case recommendations = "recommendations"
        }
    }

    public struct ListFindingsReportsRequest: AWSEncodableShape {
        /// A Boolean value indicating whether to only return reports from daily profiles. If set  to True, only analysis data from daily profiles is returned. If set to False,  analysis data is returned from smaller time windows (for example, one hour).
        public let dailyReportsOnly: Bool?
        ///  The end time of the profile to get analysis data about. You must specify startTime and endTime.  This is specified  using the ISO 8601 format. For example, 2020-06-01T13:15:02.001Z represents 1  millisecond past June 1, 2020 1:15:02 PM UTC.
        @CustomCoding<ISO8601DateCoder>
        public var endTime: Date
        /// The maximum number of report results returned by ListFindingsReports in paginated output. When this parameter is used, ListFindingsReports only returns maxResults results in a single page along with a nextToken response element. The remaining results of the initial request can be seen by sending another ListFindingsReports request with the returned nextToken value.
        public let maxResults: Int?
        /// The nextToken value returned from a previous paginated ListFindingsReportsRequest request where maxResults was used and the results exceeded the value of that parameter. Pagination continues from the end of the previous results that returned the nextToken value.   This token should be treated as an opaque identifier that is only used to retrieve the next items in a list and not for other programmatic purposes.
        public let nextToken: String?
        /// The name of the profiling group from which to search for analysis data.
        public let profilingGroupName: String
        ///  The start time of the profile to get analysis data about. You must specify startTime and endTime.  This is specified  using the ISO 8601 format. For example, 2020-06-01T13:15:02.001Z represents 1  millisecond past June 1, 2020 1:15:02 PM UTC.
        @CustomCoding<ISO8601DateCoder>
        public var startTime: Date

        public init(dailyReportsOnly: Bool? = nil, endTime: Date, maxResults: Int? = nil, nextToken: String? = nil, profilingGroupName: String, startTime: Date) {
            self.dailyReportsOnly = dailyReportsOnly
            self.endTime = endTime
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.profilingGroupName = profilingGroupName
            self.startTime = startTime
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.dailyReportsOnly, key: "dailyReportsOnly")
            request.encodeQuery(self._endTime, key: "endTime")
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
            request.encodePath(self.profilingGroupName, key: "profilingGroupName")
            request.encodeQuery(self._startTime, key: "startTime")
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 1000)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 64)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^[\\w-]+$")
            try self.validate(self.profilingGroupName, name: "profilingGroupName", parent: name, max: 255)
            try self.validate(self.profilingGroupName, name: "profilingGroupName", parent: name, min: 1)
            try self.validate(self.profilingGroupName, name: "profilingGroupName", parent: name, pattern: "^[\\w-]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListFindingsReportsResponse: AWSDecodableShape {
        /// The list of analysis results summaries.
        public let findingsReportSummaries: [FindingsReportSummary]
        /// The nextToken value to include in a future ListFindingsReports request. When the results of a ListFindingsReports request exceed maxResults, this value can be used to retrieve the next page of results. This value is null when there are no more results to return.
        public let nextToken: String?

        public init(findingsReportSummaries: [FindingsReportSummary], nextToken: String? = nil) {
            self.findingsReportSummaries = findingsReportSummaries
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case findingsReportSummaries = "findingsReportSummaries"
            case nextToken = "nextToken"
        }
    }

    public struct ListProfileTimesRequest: AWSEncodableShape {
        /// The end time of the time range from which to list the profiles.
        @CustomCoding<ISO8601DateCoder>
        public var endTime: Date
        /// The maximum number of profile time results returned by ListProfileTimes  in paginated output. When this parameter is used, ListProfileTimes only returns  maxResults results in a single page with a nextToken response  element. The remaining results of the initial request  can be seen by sending another ListProfileTimes request with the returned  nextToken value.
        public let maxResults: Int?
        /// The nextToken value returned from a previous paginated  ListProfileTimes request where maxResults was used and the results  exceeded the value of that parameter. Pagination continues from the end of the previous results  that returned the nextToken value.    This token should be treated as an opaque identifier that is only used to retrieve  the next items in a list and not for other programmatic purposes.
        public let nextToken: String?
        /// The order (ascending or descending by start time of the profile) to use when listing profiles. Defaults to TIMESTAMP_DESCENDING.
        public let orderBy: OrderBy?
        ///  The aggregation period. This specifies the period during which an aggregation profile  collects posted agent profiles for a profiling group. There are 3 valid values.     P1D — 1 day     PT1H — 1 hour     PT5M — 5 minutes
        public let period: AggregationPeriod
        /// The name of the profiling group.
        public let profilingGroupName: String
        /// The start time of the time range from which to list the profiles.
        @CustomCoding<ISO8601DateCoder>
        public var startTime: Date

        public init(endTime: Date, maxResults: Int? = nil, nextToken: String? = nil, orderBy: OrderBy? = nil, period: AggregationPeriod, profilingGroupName: String, startTime: Date) {
            self.endTime = endTime
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.orderBy = orderBy
            self.period = period
            self.profilingGroupName = profilingGroupName
            self.startTime = startTime
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self._endTime, key: "endTime")
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
            request.encodeQuery(self.orderBy, key: "orderBy")
            request.encodeQuery(self.period, key: "period")
            request.encodePath(self.profilingGroupName, key: "profilingGroupName")
            request.encodeQuery(self._startTime, key: "startTime")
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 1000)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 64)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^[\\w-]+$")
            try self.validate(self.profilingGroupName, name: "profilingGroupName", parent: name, max: 255)
            try self.validate(self.profilingGroupName, name: "profilingGroupName", parent: name, min: 1)
            try self.validate(self.profilingGroupName, name: "profilingGroupName", parent: name, pattern: "^[\\w-]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListProfileTimesResponse: AWSDecodableShape {
        /// The nextToken value to include in a future ListProfileTimes request.  When the results of a ListProfileTimes request exceed maxResults, this  value can be used to retrieve the next page of results. This value is null when there are no more  results to return.
        public let nextToken: String?
        /// The list of start times of the available profiles for the aggregation  period in the specified time range.
        public let profileTimes: [ProfileTime]

        public init(nextToken: String? = nil, profileTimes: [ProfileTime]) {
            self.nextToken = nextToken
            self.profileTimes = profileTimes
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "nextToken"
            case profileTimes = "profileTimes"
        }
    }

    public struct ListProfilingGroupsRequest: AWSEncodableShape {
        /// A Boolean value indicating whether to include a description. If true,  then a list of   ProfilingGroupDescription objects  that contain detailed information about profiling groups is returned. If false, then  a list of profiling group names is returned.
        public let includeDescription: Bool?
        /// The maximum number of profiling groups results returned by ListProfilingGroups  in paginated output. When this parameter is used, ListProfilingGroups only returns  maxResults results in a single page along with a nextToken response  element. The remaining results of the initial request  can be seen by sending another ListProfilingGroups request with the returned  nextToken value.
        public let maxResults: Int?
        /// The nextToken value returned from a previous paginated  ListProfilingGroups request where maxResults was used and the results  exceeded the value of that parameter. Pagination continues from the end of the previous results  that returned the nextToken value.    This token should be treated as an opaque identifier that is only used to retrieve  the next items in a list and not for other programmatic purposes.
        public let nextToken: String?

        public init(includeDescription: Bool? = nil, maxResults: Int? = nil, nextToken: String? = nil) {
            self.includeDescription = includeDescription
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.includeDescription, key: "includeDescription")
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 1000)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 64)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^[\\w-]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListProfilingGroupsResponse: AWSDecodableShape {
        /// The nextToken value to include in a future ListProfilingGroups request.  When the results of a ListProfilingGroups request exceed maxResults, this  value can be used to retrieve the next page of results. This value is null when there are no more  results to return.
        public let nextToken: String?
        ///  A returned list of profiling group names. A list of the names is returned only if  includeDescription is false, otherwise a list of   ProfilingGroupDescription objects  is returned.
        public let profilingGroupNames: [String]
        ///  A returned list   ProfilingGroupDescription  objects. A list of   ProfilingGroupDescription  objects is returned only if includeDescription is true, otherwise a list of profiling group names is returned.
        public let profilingGroups: [ProfilingGroupDescription]?

        public init(nextToken: String? = nil, profilingGroupNames: [String], profilingGroups: [ProfilingGroupDescription]? = nil) {
            self.nextToken = nextToken
            self.profilingGroupNames = profilingGroupNames
            self.profilingGroups = profilingGroups
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "nextToken"
            case profilingGroupNames = "profilingGroupNames"
            case profilingGroups = "profilingGroups"
        }
    }

    public struct ListTagsForResourceRequest: AWSEncodableShape {
        ///  The Amazon Resource Name (ARN) of the resource that contains the tags to return.
        public let resourceArn: String

        public init(resourceArn: String) {
            self.resourceArn = resourceArn
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.resourceArn, key: "resourceArn")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListTagsForResourceResponse: AWSDecodableShape {
        ///  The list of tags assigned to the specified resource. This is the list of tags  returned in the response.
        public let tags: [String: String]?

        public init(tags: [String: String]? = nil) {
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case tags = "tags"
        }
    }

    public struct Match: AWSDecodableShape {
        /// The location in the profiling graph that contains a recommendation found during analysis.
        public let frameAddress: String?
        /// The target frame that triggered a match.
        public let targetFramesIndex: Int?
        /// The value in the profile data that exceeded the recommendation threshold.
        public let thresholdBreachValue: Double?

        public init(frameAddress: String? = nil, targetFramesIndex: Int? = nil, thresholdBreachValue: Double? = nil) {
            self.frameAddress = frameAddress
            self.targetFramesIndex = targetFramesIndex
            self.thresholdBreachValue = thresholdBreachValue
        }

        private enum CodingKeys: String, CodingKey {
            case frameAddress = "frameAddress"
            case targetFramesIndex = "targetFramesIndex"
            case thresholdBreachValue = "thresholdBreachValue"
        }
    }

    public struct Metric: AWSDecodableShape {
        ///  The name of the method that appears as a frame in any stack in a profile.
        public let frameName: String
        ///  The list of application runtime thread states that is used to calculate the  metric value for the frame.
        public let threadStates: [String]
        ///  A type that specifies how a metric for a frame is analyzed.  The supported value AggregatedRelativeTotalTime is an  aggregation of the metric value for one frame that is calculated across the  occurences of all frames in a profile.
        public let type: MetricType

        public init(frameName: String, threadStates: [String], type: MetricType) {
            self.frameName = frameName
            self.threadStates = threadStates
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case frameName = "frameName"
            case threadStates = "threadStates"
            case type = "type"
        }
    }

    public struct NotificationConfiguration: AWSDecodableShape {
        /// List of up to two channels to be used for sending notifications for events detected from the application profile.
        public let channels: [Channel]?

        public init(channels: [Channel]? = nil) {
            self.channels = channels
        }

        private enum CodingKeys: String, CodingKey {
            case channels = "channels"
        }
    }

    public struct Pattern: AWSDecodableShape {
        ///  A list of the different counters used to determine if there is a match.
        public let countersToAggregate: [String]?
        /// The description of the recommendation. This explains a potential  inefficiency in a profiled application.
        public let description: String?
        /// The universally unique identifier (UUID) of this pattern.
        public let id: String?
        /// The name for this pattern.
        public let name: String?
        ///  A string that contains the steps recommended to address the potential inefficiency.
        public let resolutionSteps: String?
        /// A list of frame names that were searched during the analysis that generated  a recommendation.
        public let targetFrames: [[String]]?
        ///  The percentage of time an application spends in one method that triggers  a recommendation. The percentage of time is the same as the percentage of  the total gathered sample counts during analysis.
        public let thresholdPercent: Double?

        public init(countersToAggregate: [String]? = nil, description: String? = nil, id: String? = nil, name: String? = nil, resolutionSteps: String? = nil, targetFrames: [[String]]? = nil, thresholdPercent: Double? = nil) {
            self.countersToAggregate = countersToAggregate
            self.description = description
            self.id = id
            self.name = name
            self.resolutionSteps = resolutionSteps
            self.targetFrames = targetFrames
            self.thresholdPercent = thresholdPercent
        }

        private enum CodingKeys: String, CodingKey {
            case countersToAggregate = "countersToAggregate"
            case description = "description"
            case id = "id"
            case name = "name"
            case resolutionSteps = "resolutionSteps"
            case targetFrames = "targetFrames"
            case thresholdPercent = "thresholdPercent"
        }
    }

    public struct PostAgentProfileRequest: AWSEncodableShape {
        ///  The submitted profiling data.
        public let agentProfile: AWSHTTPBody
        ///  The format of the submitted profiling data. The format maps to the  Accept and Content-Type headers of the  HTTP request. You can specify one of the following:  or the default .      application/json — standard JSON format      application/x-amzn-ion — the Amazon Ion data format. For more information,  see Amazon Ion.
        public let contentType: String
        ///  Amazon CodeGuru Profiler uses this universally unique identifier (UUID) to prevent the accidental submission of duplicate profiling data if there are failures and retries.
        public let profileToken: String?
        ///  The name of the profiling group with the aggregated profile that receives the  submitted profiling data.
        public let profilingGroupName: String

        public init(agentProfile: AWSHTTPBody, contentType: String, profileToken: String? = PostAgentProfileRequest.idempotencyToken(), profilingGroupName: String) {
            self.agentProfile = agentProfile
            self.contentType = contentType
            self.profileToken = profileToken
            self.profilingGroupName = profilingGroupName
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.singleValueContainer()
            try container.encode(self.agentProfile)
            request.encodeHeader(self.contentType, key: "Content-Type")
            request.encodeQuery(self.profileToken, key: "profileToken")
            request.encodePath(self.profilingGroupName, key: "profilingGroupName")
        }

        public func validate(name: String) throws {
            try self.validate(self.profileToken, name: "profileToken", parent: name, max: 64)
            try self.validate(self.profileToken, name: "profileToken", parent: name, min: 1)
            try self.validate(self.profileToken, name: "profileToken", parent: name, pattern: "^[\\w-]+$")
            try self.validate(self.profilingGroupName, name: "profilingGroupName", parent: name, max: 255)
            try self.validate(self.profilingGroupName, name: "profilingGroupName", parent: name, min: 1)
            try self.validate(self.profilingGroupName, name: "profilingGroupName", parent: name, pattern: "^[\\w-]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct PostAgentProfileResponse: AWSDecodableShape {
        public init() {}
    }

    public struct ProfileTime: AWSDecodableShape {
        /// The start time of a profile. It is specified using  the ISO 8601 format. For example,  2020-06-01T13:15:02.001Z  represents 1 millisecond past June 1, 2020 1:15:02 PM UTC.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var start: Date?

        public init(start: Date? = nil) {
            self.start = start
        }

        private enum CodingKeys: String, CodingKey {
            case start = "start"
        }
    }

    public struct ProfilingGroupDescription: AWSDecodableShape {
        ///  An  AgentOrchestrationConfig  object that indicates if the profiling group is enabled for profiled or not.
        public let agentOrchestrationConfig: AgentOrchestrationConfig?
        /// The Amazon Resource Name (ARN) identifying the profiling group resource.
        public let arn: String?
        ///  The compute platform of the profiling group. If it is set to AWSLambda, then  the profiled application runs on AWS Lambda. If it is set to Default, then the  profiled application runs on a compute platform that is not AWS Lambda, such an Amazon EC2 instance,  an on-premises server, or a different platform. The default is Default.
        public let computePlatform: ComputePlatform?
        /// The time when the profiling group was created. Specify using  the ISO 8601 format. For example,  2020-06-01T13:15:02.001Z  represents 1 millisecond past June 1, 2020 1:15:02 PM UTC.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var createdAt: Date?
        /// The name of the profiling group.
        public let name: String?
        ///  A  ProfilingStatus object  that includes information about the last time a profile agent pinged back,  the last time a profile was received, and the aggregation period and start time for the  most recent aggregated profile.
        public let profilingStatus: ProfilingStatus?
        ///  A list of the tags that belong to this profiling group.
        public let tags: [String: String]?
        ///  The date and time when the profiling group was last updated. Specify using  the ISO 8601 format. For example,  2020-06-01T13:15:02.001Z  represents 1 millisecond past June 1, 2020 1:15:02 PM UTC.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var updatedAt: Date?

        public init(agentOrchestrationConfig: AgentOrchestrationConfig? = nil, arn: String? = nil, computePlatform: ComputePlatform? = nil, createdAt: Date? = nil, name: String? = nil, profilingStatus: ProfilingStatus? = nil, tags: [String: String]? = nil, updatedAt: Date? = nil) {
            self.agentOrchestrationConfig = agentOrchestrationConfig
            self.arn = arn
            self.computePlatform = computePlatform
            self.createdAt = createdAt
            self.name = name
            self.profilingStatus = profilingStatus
            self.tags = tags
            self.updatedAt = updatedAt
        }

        private enum CodingKeys: String, CodingKey {
            case agentOrchestrationConfig = "agentOrchestrationConfig"
            case arn = "arn"
            case computePlatform = "computePlatform"
            case createdAt = "createdAt"
            case name = "name"
            case profilingStatus = "profilingStatus"
            case tags = "tags"
            case updatedAt = "updatedAt"
        }
    }

    public struct ProfilingStatus: AWSDecodableShape {
        /// The date and time when the profiling agent most recently pinged back. Specify using  the ISO 8601 format. For example,  2020-06-01T13:15:02.001Z  represents 1 millisecond past June 1, 2020 1:15:02 PM UTC.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var latestAgentOrchestratedAt: Date?
        /// The date and time when the most recent profile was received. Specify using  the ISO 8601 format. For example,  2020-06-01T13:15:02.001Z  represents 1 millisecond past June 1, 2020 1:15:02 PM UTC.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var latestAgentProfileReportedAt: Date?
        ///  An  AggregatedProfileTime  object that contains the aggregation period and start time for an aggregated profile.
        public let latestAggregatedProfile: AggregatedProfileTime?

        public init(latestAgentOrchestratedAt: Date? = nil, latestAgentProfileReportedAt: Date? = nil, latestAggregatedProfile: AggregatedProfileTime? = nil) {
            self.latestAgentOrchestratedAt = latestAgentOrchestratedAt
            self.latestAgentProfileReportedAt = latestAgentProfileReportedAt
            self.latestAggregatedProfile = latestAggregatedProfile
        }

        private enum CodingKeys: String, CodingKey {
            case latestAgentOrchestratedAt = "latestAgentOrchestratedAt"
            case latestAgentProfileReportedAt = "latestAgentProfileReportedAt"
            case latestAggregatedProfile = "latestAggregatedProfile"
        }
    }

    public struct PutPermissionRequest: AWSEncodableShape {
        ///  Specifies an action group that contains permissions to add to  a profiling group resource. One action group is supported, agentPermissions, which  grants permission to perform actions required by the profiling agent, ConfigureAgent  and PostAgentProfile permissions.
        public let actionGroup: ActionGroup
        ///  A list ARNs for the roles and users you want to grant access to the profiling group.  Wildcards are not are supported in the ARNs.
        public let principals: [String]
        /// The name of the profiling group to grant access to.
        public let profilingGroupName: String
        ///  A universally unique identifier (UUID) for the revision of the policy you  are adding to the profiling group. Do not specify  this when you add permissions to a profiling group for the first time. If a policy already exists on the  profiling group, you must specify the revisionId.
        public let revisionId: String?

        public init(actionGroup: ActionGroup, principals: [String], profilingGroupName: String, revisionId: String? = nil) {
            self.actionGroup = actionGroup
            self.principals = principals
            self.profilingGroupName = profilingGroupName
            self.revisionId = revisionId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.actionGroup, key: "actionGroup")
            try container.encode(self.principals, forKey: .principals)
            request.encodePath(self.profilingGroupName, key: "profilingGroupName")
            try container.encodeIfPresent(self.revisionId, forKey: .revisionId)
        }

        public func validate(name: String) throws {
            try self.validate(self.principals, name: "principals", parent: name, max: 50)
            try self.validate(self.principals, name: "principals", parent: name, min: 1)
            try self.validate(self.profilingGroupName, name: "profilingGroupName", parent: name, max: 255)
            try self.validate(self.profilingGroupName, name: "profilingGroupName", parent: name, min: 1)
            try self.validate(self.profilingGroupName, name: "profilingGroupName", parent: name, pattern: "^[\\w-]+$")
            try self.validate(self.revisionId, name: "revisionId", parent: name, pattern: "[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}")
        }

        private enum CodingKeys: String, CodingKey {
            case principals = "principals"
            case revisionId = "revisionId"
        }
    }

    public struct PutPermissionResponse: AWSDecodableShape {
        ///  The JSON-formatted resource-based policy on the profiling group that includes the   added permissions.
        public let policy: String
        ///  A universally unique identifier (UUID) for the revision of the resource-based policy that includes the added permissions. The JSON-formatted policy is in the policy element of the response.
        public let revisionId: String

        public init(policy: String, revisionId: String) {
            self.policy = policy
            self.revisionId = revisionId
        }

        private enum CodingKeys: String, CodingKey {
            case policy = "policy"
            case revisionId = "revisionId"
        }
    }

    public struct Recommendation: AWSDecodableShape {
        /// How many different places in the profile graph triggered a match.
        public let allMatchesCount: Int
        /// How much of the total sample count is potentially affected.
        public let allMatchesSum: Double
        /// End time of the profile that was used by this analysis.  This is specified  using the ISO 8601 format. For example, 2020-06-01T13:15:02.001Z represents 1  millisecond past June 1, 2020 1:15:02 PM UTC.
        @CustomCoding<ISO8601DateCoder>
        public var endTime: Date
        /// The pattern that analysis recognized in the profile to make this recommendation.
        public let pattern: Pattern
        /// The start time of the profile that was used by this analysis.  This is specified  using the ISO 8601 format. For example, 2020-06-01T13:15:02.001Z represents 1  millisecond past June 1, 2020 1:15:02 PM UTC.
        @CustomCoding<ISO8601DateCoder>
        public var startTime: Date
        /// List of the matches with most impact.
        public let topMatches: [Match]

        public init(allMatchesCount: Int, allMatchesSum: Double, endTime: Date, pattern: Pattern, startTime: Date, topMatches: [Match]) {
            self.allMatchesCount = allMatchesCount
            self.allMatchesSum = allMatchesSum
            self.endTime = endTime
            self.pattern = pattern
            self.startTime = startTime
            self.topMatches = topMatches
        }

        private enum CodingKeys: String, CodingKey {
            case allMatchesCount = "allMatchesCount"
            case allMatchesSum = "allMatchesSum"
            case endTime = "endTime"
            case pattern = "pattern"
            case startTime = "startTime"
            case topMatches = "topMatches"
        }
    }

    public struct RemoveNotificationChannelRequest: AWSEncodableShape {
        /// The id of the channel that we want to stop receiving notifications.
        public let channelId: String
        /// The name of the profiling group we want to change notification configuration for.
        public let profilingGroupName: String

        public init(channelId: String, profilingGroupName: String) {
            self.channelId = channelId
            self.profilingGroupName = profilingGroupName
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.channelId, key: "channelId")
            request.encodePath(self.profilingGroupName, key: "profilingGroupName")
        }

        public func validate(name: String) throws {
            try self.validate(self.channelId, name: "channelId", parent: name, pattern: "[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}")
            try self.validate(self.profilingGroupName, name: "profilingGroupName", parent: name, max: 255)
            try self.validate(self.profilingGroupName, name: "profilingGroupName", parent: name, min: 1)
            try self.validate(self.profilingGroupName, name: "profilingGroupName", parent: name, pattern: "^[\\w-]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct RemoveNotificationChannelResponse: AWSDecodableShape {
        /// The new notification configuration for this profiling group.
        public let notificationConfiguration: NotificationConfiguration?

        public init(notificationConfiguration: NotificationConfiguration? = nil) {
            self.notificationConfiguration = notificationConfiguration
        }

        private enum CodingKeys: String, CodingKey {
            case notificationConfiguration = "notificationConfiguration"
        }
    }

    public struct RemovePermissionRequest: AWSEncodableShape {
        ///  Specifies an action group that contains the permissions to remove from  a profiling group's resource-based policy. One action group is supported, agentPermissions, which  grants ConfigureAgent and PostAgentProfile permissions.
        public let actionGroup: ActionGroup
        /// The name of the profiling group.
        public let profilingGroupName: String
        ///  A universally unique identifier (UUID) for the revision of the resource-based policy from which  you want to remove permissions.
        public let revisionId: String

        public init(actionGroup: ActionGroup, profilingGroupName: String, revisionId: String) {
            self.actionGroup = actionGroup
            self.profilingGroupName = profilingGroupName
            self.revisionId = revisionId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.actionGroup, key: "actionGroup")
            request.encodePath(self.profilingGroupName, key: "profilingGroupName")
            request.encodeQuery(self.revisionId, key: "revisionId")
        }

        public func validate(name: String) throws {
            try self.validate(self.profilingGroupName, name: "profilingGroupName", parent: name, max: 255)
            try self.validate(self.profilingGroupName, name: "profilingGroupName", parent: name, min: 1)
            try self.validate(self.profilingGroupName, name: "profilingGroupName", parent: name, pattern: "^[\\w-]+$")
            try self.validate(self.revisionId, name: "revisionId", parent: name, pattern: "[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct RemovePermissionResponse: AWSDecodableShape {
        ///  The JSON-formatted resource-based policy on the profiling group after  the specified permissions were removed.
        public let policy: String
        ///  A universally unique identifier (UUID) for the revision of the resource-based policy after the specified permissions were removed. The updated JSON-formatted policy is in the policy element of the response.
        public let revisionId: String

        public init(policy: String, revisionId: String) {
            self.policy = policy
            self.revisionId = revisionId
        }

        private enum CodingKeys: String, CodingKey {
            case policy = "policy"
            case revisionId = "revisionId"
        }
    }

    public struct SubmitFeedbackRequest: AWSEncodableShape {
        /// The universally unique identifier (UUID) of the   AnomalyInstance object  that is included in the analysis data.
        public let anomalyInstanceId: String
        /// Optional feedback about this anomaly.
        public let comment: String?
        /// The name of the profiling group that is associated with the analysis data.
        public let profilingGroupName: String
        ///  The feedback tpye. Thee are two valid values, Positive and Negative.
        public let type: FeedbackType

        public init(anomalyInstanceId: String, comment: String? = nil, profilingGroupName: String, type: FeedbackType) {
            self.anomalyInstanceId = anomalyInstanceId
            self.comment = comment
            self.profilingGroupName = profilingGroupName
            self.type = type
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.anomalyInstanceId, key: "anomalyInstanceId")
            try container.encodeIfPresent(self.comment, forKey: .comment)
            request.encodePath(self.profilingGroupName, key: "profilingGroupName")
            try container.encode(self.type, forKey: .type)
        }

        public func validate(name: String) throws {
            try self.validate(self.anomalyInstanceId, name: "anomalyInstanceId", parent: name, pattern: "[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}")
            try self.validate(self.profilingGroupName, name: "profilingGroupName", parent: name, max: 255)
            try self.validate(self.profilingGroupName, name: "profilingGroupName", parent: name, min: 1)
            try self.validate(self.profilingGroupName, name: "profilingGroupName", parent: name, pattern: "^[\\w-]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case comment = "comment"
            case type = "type"
        }
    }

    public struct SubmitFeedbackResponse: AWSDecodableShape {
        public init() {}
    }

    public struct TagResourceRequest: AWSEncodableShape {
        ///  The Amazon Resource Name (ARN) of the resource that the tags are added to.
        public let resourceArn: String
        ///  The list of tags that are added to the specified resource.
        public let tags: [String: String]

        public init(resourceArn: String, tags: [String: String]) {
            self.resourceArn = resourceArn
            self.tags = tags
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.resourceArn, key: "resourceArn")
            try container.encode(self.tags, forKey: .tags)
        }

        private enum CodingKeys: String, CodingKey {
            case tags = "tags"
        }
    }

    public struct TagResourceResponse: AWSDecodableShape {
        public init() {}
    }

    public struct TimestampStructure: AWSDecodableShape {
        ///  A Timestamp. This is specified  using the ISO 8601 format. For example, 2020-06-01T13:15:02.001Z represents 1  millisecond past June 1, 2020 1:15:02 PM UTC.
        @CustomCoding<ISO8601DateCoder>
        public var value: Date

        public init(value: Date) {
            self.value = value
        }

        private enum CodingKeys: String, CodingKey {
            case value = "value"
        }
    }

    public struct UntagResourceRequest: AWSEncodableShape {
        ///  The Amazon Resource Name (ARN) of the resource that contains the tags to remove.
        public let resourceArn: String
        ///  A list of tag keys. Existing tags of resources with keys in this list are removed from  the specified resource.
        public let tagKeys: [String]

        public init(resourceArn: String, tagKeys: [String]) {
            self.resourceArn = resourceArn
            self.tagKeys = tagKeys
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.resourceArn, key: "resourceArn")
            request.encodeQuery(self.tagKeys, key: "tagKeys")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct UntagResourceResponse: AWSDecodableShape {
        public init() {}
    }

    public struct UpdateProfilingGroupRequest: AWSEncodableShape {
        ///  Specifies whether profiling is enabled or disabled for a profiling group.
        public let agentOrchestrationConfig: AgentOrchestrationConfig
        /// The name of the profiling group to update.
        public let profilingGroupName: String

        public init(agentOrchestrationConfig: AgentOrchestrationConfig, profilingGroupName: String) {
            self.agentOrchestrationConfig = agentOrchestrationConfig
            self.profilingGroupName = profilingGroupName
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encode(self.agentOrchestrationConfig, forKey: .agentOrchestrationConfig)
            request.encodePath(self.profilingGroupName, key: "profilingGroupName")
        }

        public func validate(name: String) throws {
            try self.validate(self.profilingGroupName, name: "profilingGroupName", parent: name, max: 255)
            try self.validate(self.profilingGroupName, name: "profilingGroupName", parent: name, min: 1)
            try self.validate(self.profilingGroupName, name: "profilingGroupName", parent: name, pattern: "^[\\w-]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case agentOrchestrationConfig = "agentOrchestrationConfig"
        }
    }

    public struct UpdateProfilingGroupResponse: AWSDecodableShape {
        ///  A  ProfilingGroupDescription  that contains information about the returned updated profiling group.
        public let profilingGroup: ProfilingGroupDescription

        public init(profilingGroup: ProfilingGroupDescription) {
            self.profilingGroup = profilingGroup
        }

        public init(from decoder: Decoder) throws {
            let container = try decoder.singleValueContainer()
            self.profilingGroup = try container.decode(ProfilingGroupDescription.self)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct UserFeedback: AWSDecodableShape {
        /// Optional Positive or Negative feedback submitted by  the user about whether the recommendation is useful or not.
        public let type: FeedbackType

        public init(type: FeedbackType) {
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case type = "type"
        }
    }
}

// MARK: - Errors

/// Error enum for CodeGuruProfiler
public struct CodeGuruProfilerErrorType: AWSErrorType {
    enum Code: String {
        case conflictException = "ConflictException"
        case internalServerException = "InternalServerException"
        case resourceNotFoundException = "ResourceNotFoundException"
        case serviceQuotaExceededException = "ServiceQuotaExceededException"
        case throttlingException = "ThrottlingException"
        case validationException = "ValidationException"
    }

    private let error: Code
    public let context: AWSErrorContext?

    /// initialize CodeGuruProfiler
    public init?(errorCode: String, context: AWSErrorContext) {
        guard let error = Code(rawValue: errorCode) else { return nil }
        self.error = error
        self.context = context
    }

    internal init(_ error: Code) {
        self.error = error
        self.context = nil
    }

    /// return error code string
    public var errorCode: String { self.error.rawValue }

    /// The requested operation would cause a conflict with the current state  of a service resource associated with the request. Resolve the conflict  before retrying this request.
    public static var conflictException: Self { .init(.conflictException) }
    /// The server encountered an internal error and is unable to complete the request.
    public static var internalServerException: Self { .init(.internalServerException) }
    /// The resource specified in the request does not exist.
    public static var resourceNotFoundException: Self { .init(.resourceNotFoundException) }
    /// You have exceeded your service quota. To perform the requested action,  remove some of the relevant resources, or use Service Quotas to request a  service quota increase.
    public static var serviceQuotaExceededException: Self { .init(.serviceQuotaExceededException) }
    /// The request was denied due to request throttling.
    public static var throttlingException: Self { .init(.throttlingException) }
    /// The parameter is not valid.
    public static var validationException: Self { .init(.validationException) }
}

extension CodeGuruProfilerErrorType: Equatable {
    public static func == (lhs: CodeGuruProfilerErrorType, rhs: CodeGuruProfilerErrorType) -> Bool {
        lhs.error == rhs.error
    }
}

extension CodeGuruProfilerErrorType: CustomStringConvertible {
    public var description: String {
        return "\(self.error.rawValue): \(self.message ?? "")"
    }
}
