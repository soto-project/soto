//===----------------------------------------------------------------------===//
//
// This source file is part of the Soto for AWS open source project
//
// Copyright (c) 2017-2023 the Soto project authors
// Licensed under Apache License v2.0
//
// See LICENSE.txt for license information
// See CONTRIBUTORS.txt for the list of Soto project authors
//
// SPDX-License-Identifier: Apache-2.0
//
//===----------------------------------------------------------------------===//

// THIS FILE IS AUTOMATICALLY GENERATED by https://github.com/soto-project/soto-codegenerator.
// DO NOT EDIT.

#if os(Linux)
// swift-corelibs-foundation hasn't been updated with Sendable conformances
@preconcurrency import Foundation
#else
import Foundation
#endif
@_spi(SotoInternal) import SotoCore

extension Amp {
    // MARK: Enums

    public enum AlertManagerDefinitionStatusCode: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        /// Definition has been created/updated. Update/Deletion is disallowed until definition is ACTIVE and workspace status is ACTIVE.
        case active = "ACTIVE"
        /// Definition is being created. Update/Deletion is disallowed until definition is ACTIVE and workspace status is ACTIVE.
        case creating = "CREATING"
        /// Definition creation failed.
        case creationFailed = "CREATION_FAILED"
        /// Definition is being deleting. Update/Deletion is disallowed until definition is ACTIVE and workspace status is ACTIVE.
        case deleting = "DELETING"
        /// Definition update failed.
        case updateFailed = "UPDATE_FAILED"
        /// Definition is being updated. Update/Deletion is disallowed until definition is ACTIVE and workspace status is ACTIVE.
        case updating = "UPDATING"
        public var description: String { return self.rawValue }
    }

    public enum LoggingConfigurationStatusCode: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        /// Logging configuration has been created/updated. Update/Deletion is disallowed until logging configuration is ACTIVE and workspace status is ACTIVE.
        case active = "ACTIVE"
        /// Logging configuration is being created. Update/Deletion is disallowed until logging configuration is ACTIVE and workspace status is ACTIVE.
        case creating = "CREATING"
        /// Logging configuration creation failed.
        case creationFailed = "CREATION_FAILED"
        /// Logging configuration is being deleting. Update/Deletion is disallowed until logging configuration is ACTIVE and workspace status is ACTIVE.
        case deleting = "DELETING"
        /// Logging configuration update failed.
        case updateFailed = "UPDATE_FAILED"
        /// Logging configuration is being updated. Update/Deletion is disallowed until logging configuration is ACTIVE and workspace status is ACTIVE.
        case updating = "UPDATING"
        public var description: String { return self.rawValue }
    }

    public enum RuleGroupsNamespaceStatusCode: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        /// Namespace has been created/updated. Update/Deletion is disallowed until namespace is ACTIVE and workspace status is ACTIVE.
        case active = "ACTIVE"
        /// Namespace is being created. Update/Deletion is disallowed until namespace is ACTIVE and workspace status is ACTIVE.
        case creating = "CREATING"
        /// Namespace creation failed.
        case creationFailed = "CREATION_FAILED"
        /// Namespace is being deleting. Update/Deletion is disallowed until namespace is ACTIVE and workspace status is ACTIVE.
        case deleting = "DELETING"
        /// Namespace update failed.
        case updateFailed = "UPDATE_FAILED"
        /// Namespace is being updated. Update/Deletion is disallowed until namespace is ACTIVE and workspace status is ACTIVE.
        case updating = "UPDATING"
        public var description: String { return self.rawValue }
    }

    public enum ScraperStatusCode: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        /// Scraper has been created and is usable.
        case active = "ACTIVE"
        /// Scraper is being created. Deletion is disallowed until status is ACTIVE.
        case creating = "CREATING"
        /// Scraper creation failed.
        case creationFailed = "CREATION_FAILED"
        /// Scraper is being deleted. Deletions are allowed only when status is ACTIVE.
        case deleting = "DELETING"
        /// Scraper deletion failed.
        case deletionFailed = "DELETION_FAILED"
        public var description: String { return self.rawValue }
    }

    public enum WorkspaceStatusCode: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        /// Workspace has been created and is usable.
        case active = "ACTIVE"
        /// Workspace is being created. Deletion is disallowed until status is ACTIVE.
        case creating = "CREATING"
        /// Workspace creation failed. Refer to WorkspaceStatus.failureReason for more details.
        case creationFailed = "CREATION_FAILED"
        /// Workspace is being deleted. Deletions are allowed only when status is ACTIVE.
        case deleting = "DELETING"
        /// Workspace is being updated. Updates are allowed only when status is ACTIVE.
        case updating = "UPDATING"
        public var description: String { return self.rawValue }
    }

    // MARK: Shapes

    public struct AlertManagerDefinitionDescription: AWSDecodableShape {
        /// The time when the alert manager definition was created.
        public let createdAt: Date
        /// The alert manager definition.
        public let data: AWSBase64Data
        /// The time when the alert manager definition was modified.
        public let modifiedAt: Date
        /// The status of alert manager definition.
        public let status: AlertManagerDefinitionStatus

        public init(createdAt: Date, data: AWSBase64Data, modifiedAt: Date, status: AlertManagerDefinitionStatus) {
            self.createdAt = createdAt
            self.data = data
            self.modifiedAt = modifiedAt
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case createdAt = "createdAt"
            case data = "data"
            case modifiedAt = "modifiedAt"
            case status = "status"
        }
    }

    public struct AlertManagerDefinitionStatus: AWSDecodableShape {
        /// Status code of this definition.
        public let statusCode: AlertManagerDefinitionStatusCode
        /// The reason for failure if any.
        public let statusReason: String?

        public init(statusCode: AlertManagerDefinitionStatusCode, statusReason: String? = nil) {
            self.statusCode = statusCode
            self.statusReason = statusReason
        }

        private enum CodingKeys: String, CodingKey {
            case statusCode = "statusCode"
            case statusReason = "statusReason"
        }
    }

    public struct AmpConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The ARN of an AMP workspace.
        public let workspaceArn: String

        public init(workspaceArn: String) {
            self.workspaceArn = workspaceArn
        }

        public func validate(name: String) throws {
            try self.validate(self.workspaceArn, name: "workspaceArn", parent: name, pattern: "^arn:aws[-a-z]*:aps:[-a-z0-9]+:[0-9]{12}:workspace/.+$")
        }

        private enum CodingKeys: String, CodingKey {
            case workspaceArn = "workspaceArn"
        }
    }

    public struct CreateAlertManagerDefinitionRequest: AWSEncodableShape {
        /// Optional, unique, case-sensitive, user-provided identifier to ensure the idempotency of the request.
        public let clientToken: String?
        /// The alert manager definition data.
        public let data: AWSBase64Data
        /// The ID of the workspace in which to create the alert manager definition.
        public let workspaceId: String

        public init(clientToken: String? = CreateAlertManagerDefinitionRequest.idempotencyToken(), data: AWSBase64Data, workspaceId: String) {
            self.clientToken = clientToken
            self.data = data
            self.workspaceId = workspaceId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.clientToken, forKey: .clientToken)
            try container.encode(self.data, forKey: .data)
            request.encodePath(self.workspaceId, key: "workspaceId")
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 64)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "^[!-~]+$")
            try self.validate(self.workspaceId, name: "workspaceId", parent: name, max: 64)
            try self.validate(self.workspaceId, name: "workspaceId", parent: name, min: 1)
            try self.validate(self.workspaceId, name: "workspaceId", parent: name, pattern: "[0-9A-Za-z][-.0-9A-Z_a-z]*")
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "clientToken"
            case data = "data"
        }
    }

    public struct CreateAlertManagerDefinitionResponse: AWSDecodableShape {
        /// The status of alert manager definition.
        public let status: AlertManagerDefinitionStatus

        public init(status: AlertManagerDefinitionStatus) {
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case status = "status"
        }
    }

    public struct CreateLoggingConfigurationRequest: AWSEncodableShape {
        /// Optional, unique, case-sensitive, user-provided identifier to ensure the idempotency of the request.
        public let clientToken: String?
        /// The ARN of the CW log group to which the vended log data will be published.
        public let logGroupArn: String
        /// The ID of the workspace to vend logs to.
        public let workspaceId: String

        public init(clientToken: String? = CreateLoggingConfigurationRequest.idempotencyToken(), logGroupArn: String, workspaceId: String) {
            self.clientToken = clientToken
            self.logGroupArn = logGroupArn
            self.workspaceId = workspaceId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.clientToken, forKey: .clientToken)
            try container.encode(self.logGroupArn, forKey: .logGroupArn)
            request.encodePath(self.workspaceId, key: "workspaceId")
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 64)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "^[!-~]+$")
            try self.validate(self.logGroupArn, name: "logGroupArn", parent: name, pattern: "^arn:aws[a-z0-9-]*:logs:[a-z0-9-]+:\\d{12}:log-group:[A-Za-z0-9\\.\\-\\_\\#/]{1,512}\\:\\*$")
            try self.validate(self.workspaceId, name: "workspaceId", parent: name, max: 64)
            try self.validate(self.workspaceId, name: "workspaceId", parent: name, min: 1)
            try self.validate(self.workspaceId, name: "workspaceId", parent: name, pattern: "[0-9A-Za-z][-.0-9A-Z_a-z]*")
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "clientToken"
            case logGroupArn = "logGroupArn"
        }
    }

    public struct CreateLoggingConfigurationResponse: AWSDecodableShape {
        /// The status of the logging configuration.
        public let status: LoggingConfigurationStatus

        public init(status: LoggingConfigurationStatus) {
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case status = "status"
        }
    }

    public struct CreateRuleGroupsNamespaceRequest: AWSEncodableShape {
        /// Optional, unique, case-sensitive, user-provided identifier to ensure the idempotency of the request.
        public let clientToken: String?
        /// The namespace data that define the rule groups.
        public let data: AWSBase64Data
        /// The rule groups namespace name.
        public let name: String
        /// Optional, user-provided tags for this rule groups namespace.
        public let tags: [String: String]?
        /// The ID of the workspace in which to create the rule group namespace.
        public let workspaceId: String

        public init(clientToken: String? = CreateRuleGroupsNamespaceRequest.idempotencyToken(), data: AWSBase64Data, name: String, tags: [String: String]? = nil, workspaceId: String) {
            self.clientToken = clientToken
            self.data = data
            self.name = name
            self.tags = tags
            self.workspaceId = workspaceId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.clientToken, forKey: .clientToken)
            try container.encode(self.data, forKey: .data)
            try container.encode(self.name, forKey: .name)
            try container.encodeIfPresent(self.tags, forKey: .tags)
            request.encodePath(self.workspaceId, key: "workspaceId")
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 64)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "^[!-~]+$")
            try self.validate(self.name, name: "name", parent: name, max: 64)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "[0-9A-Za-z][-.0-9A-Z_a-z]*")
            try self.tags?.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.key, name: "tags.key", parent: name, pattern: "^([\\p{L}\\p{Z}\\p{N}_.:/=+\\-@]*)$")
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, pattern: "^([\\p{L}\\p{Z}\\p{N}_.:/=+\\-@]*)$")
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 50)
            try self.validate(self.workspaceId, name: "workspaceId", parent: name, max: 64)
            try self.validate(self.workspaceId, name: "workspaceId", parent: name, min: 1)
            try self.validate(self.workspaceId, name: "workspaceId", parent: name, pattern: "[0-9A-Za-z][-.0-9A-Z_a-z]*")
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "clientToken"
            case data = "data"
            case name = "name"
            case tags = "tags"
        }
    }

    public struct CreateRuleGroupsNamespaceResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of this rule groups namespace.
        public let arn: String
        /// The rule groups namespace name.
        public let name: String
        /// The status of rule groups namespace.
        public let status: RuleGroupsNamespaceStatus
        /// The tags of this rule groups namespace.
        public let tags: [String: String]?

        public init(arn: String, name: String, status: RuleGroupsNamespaceStatus, tags: [String: String]? = nil) {
            self.arn = arn
            self.name = name
            self.status = status
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case name = "name"
            case status = "status"
            case tags = "tags"
        }
    }

    public struct CreateScraperRequest: AWSEncodableShape {
        /// An optional user-assigned alias for this scraper. This alias is for user reference and does not need to be unique.
        public let alias: String?
        /// Optional, unique, case-sensitive, user-provided identifier to ensure the idempotency of the request.
        public let clientToken: String?
        /// The destination that the scraper will be producing metrics to.
        public let destination: Destination
        /// The configuration used to create the scraper.
        public let scrapeConfiguration: ScrapeConfiguration
        /// The source that the scraper will be discovering and collecting metrics from.
        public let source: Source
        /// Optional, user-provided tags for this scraper.
        public let tags: [String: String]?

        public init(alias: String? = nil, clientToken: String? = CreateScraperRequest.idempotencyToken(), destination: Destination, scrapeConfiguration: ScrapeConfiguration, source: Source, tags: [String: String]? = nil) {
            self.alias = alias
            self.clientToken = clientToken
            self.destination = destination
            self.scrapeConfiguration = scrapeConfiguration
            self.source = source
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.validate(self.alias, name: "alias", parent: name, max: 100)
            try self.validate(self.alias, name: "alias", parent: name, min: 1)
            try self.validate(self.alias, name: "alias", parent: name, pattern: "^[0-9A-Za-z][-.0-9A-Z_a-z]*$")
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 64)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "^[!-~]+$")
            try self.destination.validate(name: "\(name).destination")
            try self.source.validate(name: "\(name).source")
            try self.tags?.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.key, name: "tags.key", parent: name, pattern: "^([\\p{L}\\p{Z}\\p{N}_.:/=+\\-@]*)$")
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, pattern: "^([\\p{L}\\p{Z}\\p{N}_.:/=+\\-@]*)$")
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 50)
        }

        private enum CodingKeys: String, CodingKey {
            case alias = "alias"
            case clientToken = "clientToken"
            case destination = "destination"
            case scrapeConfiguration = "scrapeConfiguration"
            case source = "source"
            case tags = "tags"
        }
    }

    public struct CreateScraperResponse: AWSDecodableShape {
        /// The ARN of the scraper that was just created.
        public let arn: String
        /// The generated ID of the scraper that was just created.
        public let scraperId: String
        /// The status of the scraper that was just created (usually CREATING).
        public let status: ScraperStatus
        /// The tags of this scraper.
        public let tags: [String: String]?

        public init(arn: String, scraperId: String, status: ScraperStatus, tags: [String: String]? = nil) {
            self.arn = arn
            self.scraperId = scraperId
            self.status = status
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case scraperId = "scraperId"
            case status = "status"
            case tags = "tags"
        }
    }

    public struct CreateWorkspaceRequest: AWSEncodableShape {
        /// An optional user-assigned alias for this workspace. This alias is for user reference and does not need to be unique.
        public let alias: String?
        /// Optional, unique, case-sensitive, user-provided identifier to ensure the idempotency of the request.
        public let clientToken: String?
        /// Optional, user-provided tags for this workspace.
        public let tags: [String: String]?

        public init(alias: String? = nil, clientToken: String? = CreateWorkspaceRequest.idempotencyToken(), tags: [String: String]? = nil) {
            self.alias = alias
            self.clientToken = clientToken
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.validate(self.alias, name: "alias", parent: name, max: 100)
            try self.validate(self.alias, name: "alias", parent: name, min: 1)
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 64)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "^[!-~]+$")
            try self.tags?.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.key, name: "tags.key", parent: name, pattern: "^([\\p{L}\\p{Z}\\p{N}_.:/=+\\-@]*)$")
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, pattern: "^([\\p{L}\\p{Z}\\p{N}_.:/=+\\-@]*)$")
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 50)
        }

        private enum CodingKeys: String, CodingKey {
            case alias = "alias"
            case clientToken = "clientToken"
            case tags = "tags"
        }
    }

    public struct CreateWorkspaceResponse: AWSDecodableShape {
        /// The ARN of the workspace that was just created.
        public let arn: String
        /// The status of the workspace that was just created (usually CREATING).
        public let status: WorkspaceStatus
        /// The tags of this workspace.
        public let tags: [String: String]?
        /// The generated ID of the workspace that was just created.
        public let workspaceId: String

        public init(arn: String, status: WorkspaceStatus, tags: [String: String]? = nil, workspaceId: String) {
            self.arn = arn
            self.status = status
            self.tags = tags
            self.workspaceId = workspaceId
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case status = "status"
            case tags = "tags"
            case workspaceId = "workspaceId"
        }
    }

    public struct DeleteAlertManagerDefinitionRequest: AWSEncodableShape {
        /// Optional, unique, case-sensitive, user-provided identifier to ensure the idempotency of the request.
        public let clientToken: String?
        /// The ID of the workspace in which to delete the alert manager definition.
        public let workspaceId: String

        public init(clientToken: String? = DeleteAlertManagerDefinitionRequest.idempotencyToken(), workspaceId: String) {
            self.clientToken = clientToken
            self.workspaceId = workspaceId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.clientToken, key: "clientToken")
            request.encodePath(self.workspaceId, key: "workspaceId")
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 64)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "^[!-~]+$")
            try self.validate(self.workspaceId, name: "workspaceId", parent: name, max: 64)
            try self.validate(self.workspaceId, name: "workspaceId", parent: name, min: 1)
            try self.validate(self.workspaceId, name: "workspaceId", parent: name, pattern: "[0-9A-Za-z][-.0-9A-Z_a-z]*")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteLoggingConfigurationRequest: AWSEncodableShape {
        /// Optional, unique, case-sensitive, user-provided identifier to ensure the idempotency of the request.
        public let clientToken: String?
        /// The ID of the workspace to vend logs to.
        public let workspaceId: String

        public init(clientToken: String? = DeleteLoggingConfigurationRequest.idempotencyToken(), workspaceId: String) {
            self.clientToken = clientToken
            self.workspaceId = workspaceId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.clientToken, key: "clientToken")
            request.encodePath(self.workspaceId, key: "workspaceId")
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 64)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "^[!-~]+$")
            try self.validate(self.workspaceId, name: "workspaceId", parent: name, max: 64)
            try self.validate(self.workspaceId, name: "workspaceId", parent: name, min: 1)
            try self.validate(self.workspaceId, name: "workspaceId", parent: name, pattern: "[0-9A-Za-z][-.0-9A-Z_a-z]*")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteRuleGroupsNamespaceRequest: AWSEncodableShape {
        /// Optional, unique, case-sensitive, user-provided identifier to ensure the idempotency of the request.
        public let clientToken: String?
        /// The rule groups namespace name.
        public let name: String
        /// The ID of the workspace to delete rule group definition.
        public let workspaceId: String

        public init(clientToken: String? = DeleteRuleGroupsNamespaceRequest.idempotencyToken(), name: String, workspaceId: String) {
            self.clientToken = clientToken
            self.name = name
            self.workspaceId = workspaceId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.clientToken, key: "clientToken")
            request.encodePath(self.name, key: "name")
            request.encodePath(self.workspaceId, key: "workspaceId")
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 64)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "^[!-~]+$")
            try self.validate(self.name, name: "name", parent: name, max: 64)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "[0-9A-Za-z][-.0-9A-Z_a-z]*")
            try self.validate(self.workspaceId, name: "workspaceId", parent: name, max: 64)
            try self.validate(self.workspaceId, name: "workspaceId", parent: name, min: 1)
            try self.validate(self.workspaceId, name: "workspaceId", parent: name, pattern: "[0-9A-Za-z][-.0-9A-Z_a-z]*")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteScraperRequest: AWSEncodableShape {
        /// Optional, unique, case-sensitive, user-provided identifier to ensure the idempotency of the request.
        public let clientToken: String?
        /// The ID of the scraper to delete.
        public let scraperId: String

        public init(clientToken: String? = DeleteScraperRequest.idempotencyToken(), scraperId: String) {
            self.clientToken = clientToken
            self.scraperId = scraperId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.clientToken, key: "clientToken")
            request.encodePath(self.scraperId, key: "scraperId")
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 64)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "^[!-~]+$")
            try self.validate(self.scraperId, name: "scraperId", parent: name, max: 64)
            try self.validate(self.scraperId, name: "scraperId", parent: name, min: 1)
            try self.validate(self.scraperId, name: "scraperId", parent: name, pattern: "^[0-9A-Za-z][-.0-9A-Z_a-z]*$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteScraperResponse: AWSDecodableShape {
        /// The ID of the scraper that was deleted.
        public let scraperId: String
        /// The status of the scraper that is being deleted.
        public let status: ScraperStatus

        public init(scraperId: String, status: ScraperStatus) {
            self.scraperId = scraperId
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case scraperId = "scraperId"
            case status = "status"
        }
    }

    public struct DeleteWorkspaceRequest: AWSEncodableShape {
        /// Optional, unique, case-sensitive, user-provided identifier to ensure the idempotency of the request.
        public let clientToken: String?
        /// The ID of the workspace to delete.
        public let workspaceId: String

        public init(clientToken: String? = DeleteWorkspaceRequest.idempotencyToken(), workspaceId: String) {
            self.clientToken = clientToken
            self.workspaceId = workspaceId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.clientToken, key: "clientToken")
            request.encodePath(self.workspaceId, key: "workspaceId")
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 64)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "^[!-~]+$")
            try self.validate(self.workspaceId, name: "workspaceId", parent: name, max: 64)
            try self.validate(self.workspaceId, name: "workspaceId", parent: name, min: 1)
            try self.validate(self.workspaceId, name: "workspaceId", parent: name, pattern: "[0-9A-Za-z][-.0-9A-Z_a-z]*")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DescribeAlertManagerDefinitionRequest: AWSEncodableShape {
        /// The ID of the workspace to describe.
        public let workspaceId: String

        public init(workspaceId: String) {
            self.workspaceId = workspaceId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.workspaceId, key: "workspaceId")
        }

        public func validate(name: String) throws {
            try self.validate(self.workspaceId, name: "workspaceId", parent: name, max: 64)
            try self.validate(self.workspaceId, name: "workspaceId", parent: name, min: 1)
            try self.validate(self.workspaceId, name: "workspaceId", parent: name, pattern: "[0-9A-Za-z][-.0-9A-Z_a-z]*")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DescribeAlertManagerDefinitionResponse: AWSDecodableShape {
        /// The properties of the selected workspace's alert manager definition.
        public let alertManagerDefinition: AlertManagerDefinitionDescription

        public init(alertManagerDefinition: AlertManagerDefinitionDescription) {
            self.alertManagerDefinition = alertManagerDefinition
        }

        private enum CodingKeys: String, CodingKey {
            case alertManagerDefinition = "alertManagerDefinition"
        }
    }

    public struct DescribeLoggingConfigurationRequest: AWSEncodableShape {
        /// The ID of the workspace to vend logs to.
        public let workspaceId: String

        public init(workspaceId: String) {
            self.workspaceId = workspaceId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.workspaceId, key: "workspaceId")
        }

        public func validate(name: String) throws {
            try self.validate(self.workspaceId, name: "workspaceId", parent: name, max: 64)
            try self.validate(self.workspaceId, name: "workspaceId", parent: name, min: 1)
            try self.validate(self.workspaceId, name: "workspaceId", parent: name, pattern: "[0-9A-Za-z][-.0-9A-Z_a-z]*")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DescribeLoggingConfigurationResponse: AWSDecodableShape {
        /// Metadata object containing information about the logging configuration of a workspace.
        public let loggingConfiguration: LoggingConfigurationMetadata

        public init(loggingConfiguration: LoggingConfigurationMetadata) {
            self.loggingConfiguration = loggingConfiguration
        }

        private enum CodingKeys: String, CodingKey {
            case loggingConfiguration = "loggingConfiguration"
        }
    }

    public struct DescribeRuleGroupsNamespaceRequest: AWSEncodableShape {
        /// The rule groups namespace.
        public let name: String
        /// The ID of the workspace to describe.
        public let workspaceId: String

        public init(name: String, workspaceId: String) {
            self.name = name
            self.workspaceId = workspaceId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.name, key: "name")
            request.encodePath(self.workspaceId, key: "workspaceId")
        }

        public func validate(name: String) throws {
            try self.validate(self.name, name: "name", parent: name, max: 64)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "[0-9A-Za-z][-.0-9A-Z_a-z]*")
            try self.validate(self.workspaceId, name: "workspaceId", parent: name, max: 64)
            try self.validate(self.workspaceId, name: "workspaceId", parent: name, min: 1)
            try self.validate(self.workspaceId, name: "workspaceId", parent: name, pattern: "[0-9A-Za-z][-.0-9A-Z_a-z]*")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DescribeRuleGroupsNamespaceResponse: AWSDecodableShape {
        /// The selected rule groups namespace.
        public let ruleGroupsNamespace: RuleGroupsNamespaceDescription

        public init(ruleGroupsNamespace: RuleGroupsNamespaceDescription) {
            self.ruleGroupsNamespace = ruleGroupsNamespace
        }

        private enum CodingKeys: String, CodingKey {
            case ruleGroupsNamespace = "ruleGroupsNamespace"
        }
    }

    public struct DescribeScraperRequest: AWSEncodableShape {
        /// The IDs of the scraper to describe.
        public let scraperId: String

        public init(scraperId: String) {
            self.scraperId = scraperId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.scraperId, key: "scraperId")
        }

        public func validate(name: String) throws {
            try self.validate(self.scraperId, name: "scraperId", parent: name, max: 64)
            try self.validate(self.scraperId, name: "scraperId", parent: name, min: 1)
            try self.validate(self.scraperId, name: "scraperId", parent: name, pattern: "^[0-9A-Za-z][-.0-9A-Z_a-z]*$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DescribeScraperResponse: AWSDecodableShape {
        /// The properties of the selected scrapers.
        public let scraper: ScraperDescription

        public init(scraper: ScraperDescription) {
            self.scraper = scraper
        }

        private enum CodingKeys: String, CodingKey {
            case scraper = "scraper"
        }
    }

    public struct DescribeWorkspaceRequest: AWSEncodableShape {
        /// The ID of the workspace to describe.
        public let workspaceId: String

        public init(workspaceId: String) {
            self.workspaceId = workspaceId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.workspaceId, key: "workspaceId")
        }

        public func validate(name: String) throws {
            try self.validate(self.workspaceId, name: "workspaceId", parent: name, max: 64)
            try self.validate(self.workspaceId, name: "workspaceId", parent: name, min: 1)
            try self.validate(self.workspaceId, name: "workspaceId", parent: name, pattern: "[0-9A-Za-z][-.0-9A-Z_a-z]*")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DescribeWorkspaceResponse: AWSDecodableShape {
        /// The properties of the selected workspace.
        public let workspace: WorkspaceDescription

        public init(workspace: WorkspaceDescription) {
            self.workspace = workspace
        }

        private enum CodingKeys: String, CodingKey {
            case workspace = "workspace"
        }
    }

    public struct EksConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The ARN of an EKS cluster.
        public let clusterArn: String
        /// A list of security group IDs specified for VPC configuration.
        public let securityGroupIds: [String]?
        /// A list of subnet IDs specified for VPC configuration.
        public let subnetIds: [String]

        public init(clusterArn: String, securityGroupIds: [String]? = nil, subnetIds: [String]) {
            self.clusterArn = clusterArn
            self.securityGroupIds = securityGroupIds
            self.subnetIds = subnetIds
        }

        public func validate(name: String) throws {
            try self.validate(self.clusterArn, name: "clusterArn", parent: name, pattern: "^arn:aws[-a-z]*:eks:[-a-z0-9]+:[0-9]{12}:cluster/.+$")
            try self.securityGroupIds?.forEach {
                try validate($0, name: "securityGroupIds[]", parent: name, max: 255)
                try validate($0, name: "securityGroupIds[]", parent: name, pattern: "^sg-[0-9a-z]+$")
            }
            try self.validate(self.securityGroupIds, name: "securityGroupIds", parent: name, max: 5)
            try self.validate(self.securityGroupIds, name: "securityGroupIds", parent: name, min: 1)
            try self.subnetIds.forEach {
                try validate($0, name: "subnetIds[]", parent: name, max: 255)
                try validate($0, name: "subnetIds[]", parent: name, pattern: "^subnet-[0-9a-z]+$")
            }
            try self.validate(self.subnetIds, name: "subnetIds", parent: name, max: 5)
            try self.validate(self.subnetIds, name: "subnetIds", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case clusterArn = "clusterArn"
            case securityGroupIds = "securityGroupIds"
            case subnetIds = "subnetIds"
        }
    }

    public struct GetDefaultScraperConfigurationRequest: AWSEncodableShape {
        public init() {}
    }

    public struct GetDefaultScraperConfigurationResponse: AWSDecodableShape {
        /// The default configuration.
        public let configuration: AWSBase64Data

        public init(configuration: AWSBase64Data) {
            self.configuration = configuration
        }

        private enum CodingKeys: String, CodingKey {
            case configuration = "configuration"
        }
    }

    public struct ListRuleGroupsNamespacesRequest: AWSEncodableShape {
        /// Maximum results to return in response (default=100, maximum=1000).
        public let maxResults: Int?
        /// Optional filter for rule groups namespace name. Only the rule groups namespace that begin with this value will be returned.
        public let name: String?
        /// Pagination token to request the next page in a paginated list. This token is obtained from the output of the previous ListRuleGroupsNamespaces request.
        public let nextToken: String?
        /// The ID of the workspace.
        public let workspaceId: String

        public init(maxResults: Int? = nil, name: String? = nil, nextToken: String? = nil, workspaceId: String) {
            self.maxResults = maxResults
            self.name = name
            self.nextToken = nextToken
            self.workspaceId = workspaceId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.name, key: "name")
            request.encodeQuery(self.nextToken, key: "nextToken")
            request.encodePath(self.workspaceId, key: "workspaceId")
        }

        public func validate(name: String) throws {
            try self.validate(self.name, name: "name", parent: name, max: 64)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "[0-9A-Za-z][-.0-9A-Z_a-z]*")
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 1000)
            try self.validate(self.workspaceId, name: "workspaceId", parent: name, max: 64)
            try self.validate(self.workspaceId, name: "workspaceId", parent: name, min: 1)
            try self.validate(self.workspaceId, name: "workspaceId", parent: name, pattern: "[0-9A-Za-z][-.0-9A-Z_a-z]*")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListRuleGroupsNamespacesResponse: AWSDecodableShape {
        /// Pagination token to use when requesting the next page in this list.
        public let nextToken: String?
        /// The list of the selected rule groups namespaces.
        public let ruleGroupsNamespaces: [RuleGroupsNamespaceSummary]

        public init(nextToken: String? = nil, ruleGroupsNamespaces: [RuleGroupsNamespaceSummary]) {
            self.nextToken = nextToken
            self.ruleGroupsNamespaces = ruleGroupsNamespaces
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "nextToken"
            case ruleGroupsNamespaces = "ruleGroupsNamespaces"
        }
    }

    public struct ListScrapersRequest: AWSEncodableShape {
        /// A list of scraper filters.
        public let filters: [String: [String]]?
        /// Maximum results to return in response (default=100, maximum=1000).
        public let maxResults: Int?
        /// Pagination token to request the next page in a paginated list. This token is obtained from the output of the previous ListScrapers request.
        public let nextToken: String?

        public init(filters: [String: [String]]? = nil, maxResults: Int? = nil, nextToken: String? = nil) {
            self.filters = filters
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.filters)
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
        }

        public func validate(name: String) throws {
            try self.filters?.forEach {
                try validate($0.key, name: "filters.key", parent: name, max: 256)
                try validate($0.key, name: "filters.key", parent: name, min: 1)
                try validate($0.value, name: "filters[\"\($0.key)\"]", parent: name, max: 20)
                try validate($0.value, name: "filters[\"\($0.key)\"]", parent: name, min: 1)
            }
            try self.validate(self.filters, name: "filters", parent: name, max: 4)
            try self.validate(self.filters, name: "filters", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 1000)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListScrapersResponse: AWSDecodableShape {
        /// Pagination token to use when requesting the next page in this list.
        public let nextToken: String?
        /// The list of scrapers, filtered down if a set of filters was provided in the request.
        public let scrapers: [ScraperSummary]

        public init(nextToken: String? = nil, scrapers: [ScraperSummary]) {
            self.nextToken = nextToken
            self.scrapers = scrapers
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "nextToken"
            case scrapers = "scrapers"
        }
    }

    public struct ListTagsForResourceRequest: AWSEncodableShape {
        /// The ARN of the resource.
        public let resourceArn: String

        public init(resourceArn: String) {
            self.resourceArn = resourceArn
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.resourceArn, key: "resourceArn")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListTagsForResourceResponse: AWSDecodableShape {
        public let tags: [String: String]?

        public init(tags: [String: String]? = nil) {
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case tags = "tags"
        }
    }

    public struct ListWorkspacesRequest: AWSEncodableShape {
        /// Optional filter for workspace alias. Only the workspaces with aliases that begin with this value will be returned.
        public let alias: String?
        /// Maximum results to return in response (default=100, maximum=1000).
        public let maxResults: Int?
        /// Pagination token to request the next page in a paginated list. This token is obtained from the output of the previous ListWorkspaces request.
        public let nextToken: String?

        public init(alias: String? = nil, maxResults: Int? = nil, nextToken: String? = nil) {
            self.alias = alias
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.alias, key: "alias")
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
        }

        public func validate(name: String) throws {
            try self.validate(self.alias, name: "alias", parent: name, max: 100)
            try self.validate(self.alias, name: "alias", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 1000)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListWorkspacesResponse: AWSDecodableShape {
        /// Pagination token to use when requesting the next page in this list.
        public let nextToken: String?
        /// The list of existing workspaces, including those undergoing creation or deletion.
        public let workspaces: [WorkspaceSummary]

        public init(nextToken: String? = nil, workspaces: [WorkspaceSummary]) {
            self.nextToken = nextToken
            self.workspaces = workspaces
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "nextToken"
            case workspaces = "workspaces"
        }
    }

    public struct LoggingConfigurationMetadata: AWSDecodableShape {
        /// The time when the logging configuration was created.
        public let createdAt: Date
        /// The ARN of the CW log group to which the vended log data will be published.
        public let logGroupArn: String
        /// The time when the logging configuration was modified.
        public let modifiedAt: Date
        /// The status of the logging configuration.
        public let status: LoggingConfigurationStatus
        /// The workspace where the logging configuration exists.
        public let workspace: String

        public init(createdAt: Date, logGroupArn: String, modifiedAt: Date, status: LoggingConfigurationStatus, workspace: String) {
            self.createdAt = createdAt
            self.logGroupArn = logGroupArn
            self.modifiedAt = modifiedAt
            self.status = status
            self.workspace = workspace
        }

        private enum CodingKeys: String, CodingKey {
            case createdAt = "createdAt"
            case logGroupArn = "logGroupArn"
            case modifiedAt = "modifiedAt"
            case status = "status"
            case workspace = "workspace"
        }
    }

    public struct LoggingConfigurationStatus: AWSDecodableShape {
        /// Status code of the logging configuration.
        public let statusCode: LoggingConfigurationStatusCode
        /// The reason for failure if any.
        public let statusReason: String?

        public init(statusCode: LoggingConfigurationStatusCode, statusReason: String? = nil) {
            self.statusCode = statusCode
            self.statusReason = statusReason
        }

        private enum CodingKeys: String, CodingKey {
            case statusCode = "statusCode"
            case statusReason = "statusReason"
        }
    }

    public struct PutAlertManagerDefinitionRequest: AWSEncodableShape {
        /// Optional, unique, case-sensitive, user-provided identifier to ensure the idempotency of the request.
        public let clientToken: String?
        /// The alert manager definition data.
        public let data: AWSBase64Data
        /// The ID of the workspace in which to update the alert manager definition.
        public let workspaceId: String

        public init(clientToken: String? = PutAlertManagerDefinitionRequest.idempotencyToken(), data: AWSBase64Data, workspaceId: String) {
            self.clientToken = clientToken
            self.data = data
            self.workspaceId = workspaceId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.clientToken, forKey: .clientToken)
            try container.encode(self.data, forKey: .data)
            request.encodePath(self.workspaceId, key: "workspaceId")
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 64)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "^[!-~]+$")
            try self.validate(self.workspaceId, name: "workspaceId", parent: name, max: 64)
            try self.validate(self.workspaceId, name: "workspaceId", parent: name, min: 1)
            try self.validate(self.workspaceId, name: "workspaceId", parent: name, pattern: "[0-9A-Za-z][-.0-9A-Z_a-z]*")
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "clientToken"
            case data = "data"
        }
    }

    public struct PutAlertManagerDefinitionResponse: AWSDecodableShape {
        /// The status of alert manager definition.
        public let status: AlertManagerDefinitionStatus

        public init(status: AlertManagerDefinitionStatus) {
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case status = "status"
        }
    }

    public struct PutRuleGroupsNamespaceRequest: AWSEncodableShape {
        /// Optional, unique, case-sensitive, user-provided identifier to ensure the idempotency of the request.
        public let clientToken: String?
        /// The namespace data that define the rule groups.
        public let data: AWSBase64Data
        /// The rule groups namespace name.
        public let name: String
        /// The ID of the workspace in which to update the rule group namespace.
        public let workspaceId: String

        public init(clientToken: String? = PutRuleGroupsNamespaceRequest.idempotencyToken(), data: AWSBase64Data, name: String, workspaceId: String) {
            self.clientToken = clientToken
            self.data = data
            self.name = name
            self.workspaceId = workspaceId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.clientToken, forKey: .clientToken)
            try container.encode(self.data, forKey: .data)
            request.encodePath(self.name, key: "name")
            request.encodePath(self.workspaceId, key: "workspaceId")
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 64)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "^[!-~]+$")
            try self.validate(self.name, name: "name", parent: name, max: 64)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "[0-9A-Za-z][-.0-9A-Z_a-z]*")
            try self.validate(self.workspaceId, name: "workspaceId", parent: name, max: 64)
            try self.validate(self.workspaceId, name: "workspaceId", parent: name, min: 1)
            try self.validate(self.workspaceId, name: "workspaceId", parent: name, pattern: "[0-9A-Za-z][-.0-9A-Z_a-z]*")
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "clientToken"
            case data = "data"
        }
    }

    public struct PutRuleGroupsNamespaceResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of this rule groups namespace.
        public let arn: String
        /// The rule groups namespace name.
        public let name: String
        /// The status of rule groups namespace.
        public let status: RuleGroupsNamespaceStatus
        /// The tags of this rule groups namespace.
        public let tags: [String: String]?

        public init(arn: String, name: String, status: RuleGroupsNamespaceStatus, tags: [String: String]? = nil) {
            self.arn = arn
            self.name = name
            self.status = status
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case name = "name"
            case status = "status"
            case tags = "tags"
        }
    }

    public struct RuleGroupsNamespaceDescription: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of this rule groups namespace.
        public let arn: String
        /// The time when the rule groups namespace was created.
        public let createdAt: Date
        /// The rule groups namespace data.
        public let data: AWSBase64Data
        /// The time when the rule groups namespace was modified.
        public let modifiedAt: Date
        /// The rule groups namespace name.
        public let name: String
        /// The status of rule groups namespace.
        public let status: RuleGroupsNamespaceStatus
        /// The tags of this rule groups namespace.
        public let tags: [String: String]?

        public init(arn: String, createdAt: Date, data: AWSBase64Data, modifiedAt: Date, name: String, status: RuleGroupsNamespaceStatus, tags: [String: String]? = nil) {
            self.arn = arn
            self.createdAt = createdAt
            self.data = data
            self.modifiedAt = modifiedAt
            self.name = name
            self.status = status
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case createdAt = "createdAt"
            case data = "data"
            case modifiedAt = "modifiedAt"
            case name = "name"
            case status = "status"
            case tags = "tags"
        }
    }

    public struct RuleGroupsNamespaceStatus: AWSDecodableShape {
        /// Status code of this namespace.
        public let statusCode: RuleGroupsNamespaceStatusCode
        /// The reason for failure if any.
        public let statusReason: String?

        public init(statusCode: RuleGroupsNamespaceStatusCode, statusReason: String? = nil) {
            self.statusCode = statusCode
            self.statusReason = statusReason
        }

        private enum CodingKeys: String, CodingKey {
            case statusCode = "statusCode"
            case statusReason = "statusReason"
        }
    }

    public struct RuleGroupsNamespaceSummary: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of this rule groups namespace.
        public let arn: String
        /// The time when the rule groups namespace was created.
        public let createdAt: Date
        /// The time when the rule groups namespace was modified.
        public let modifiedAt: Date
        /// The rule groups namespace name.
        public let name: String
        /// The status of rule groups namespace.
        public let status: RuleGroupsNamespaceStatus
        /// The tags of this rule groups namespace.
        public let tags: [String: String]?

        public init(arn: String, createdAt: Date, modifiedAt: Date, name: String, status: RuleGroupsNamespaceStatus, tags: [String: String]? = nil) {
            self.arn = arn
            self.createdAt = createdAt
            self.modifiedAt = modifiedAt
            self.name = name
            self.status = status
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case createdAt = "createdAt"
            case modifiedAt = "modifiedAt"
            case name = "name"
            case status = "status"
            case tags = "tags"
        }
    }

    public struct ScraperDescription: AWSDecodableShape {
        /// Alias of this scraper.
        public let alias: String?
        /// The Amazon Resource Name (ARN) of this scraper.
        public let arn: String
        /// The time when the scraper was created.
        public let createdAt: Date
        /// The destination that the scraper is producing metrics to.
        public let destination: Destination
        /// The time when the scraper was last modified.
        public let lastModifiedAt: Date
        /// The Amazon Resource Name (ARN) of the IAM role that provides permissions for the scraper to dsicover, collect, and produce metrics on your behalf.
        public let roleArn: String
        /// The configuration used to create the scraper.
        public let scrapeConfiguration: ScrapeConfiguration
        /// Unique string identifying this scraper.
        public let scraperId: String
        /// The source that the scraper is discovering and collecting metrics from.
        public let source: Source
        /// The status of this scraper.
        public let status: ScraperStatus
        /// The reason for failure if any.
        public let statusReason: String?
        /// The tags of this scraper.
        public let tags: [String: String]?

        public init(alias: String? = nil, arn: String, createdAt: Date, destination: Destination, lastModifiedAt: Date, roleArn: String, scrapeConfiguration: ScrapeConfiguration, scraperId: String, source: Source, status: ScraperStatus, statusReason: String? = nil, tags: [String: String]? = nil) {
            self.alias = alias
            self.arn = arn
            self.createdAt = createdAt
            self.destination = destination
            self.lastModifiedAt = lastModifiedAt
            self.roleArn = roleArn
            self.scrapeConfiguration = scrapeConfiguration
            self.scraperId = scraperId
            self.source = source
            self.status = status
            self.statusReason = statusReason
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case alias = "alias"
            case arn = "arn"
            case createdAt = "createdAt"
            case destination = "destination"
            case lastModifiedAt = "lastModifiedAt"
            case roleArn = "roleArn"
            case scrapeConfiguration = "scrapeConfiguration"
            case scraperId = "scraperId"
            case source = "source"
            case status = "status"
            case statusReason = "statusReason"
            case tags = "tags"
        }
    }

    public struct ScraperStatus: AWSDecodableShape {
        /// Status code of this scraper.
        public let statusCode: ScraperStatusCode

        public init(statusCode: ScraperStatusCode) {
            self.statusCode = statusCode
        }

        private enum CodingKeys: String, CodingKey {
            case statusCode = "statusCode"
        }
    }

    public struct ScraperSummary: AWSDecodableShape {
        /// Alias of this scraper.
        public let alias: String?
        /// The Amazon Resource Name (ARN) of this scraper.
        public let arn: String
        /// The time when the scraper was created.
        public let createdAt: Date
        /// The destination that the scraper is producing metrics to.
        public let destination: Destination
        /// The time when the scraper was last modified.
        public let lastModifiedAt: Date
        /// The Amazon Resource Name (ARN) of the IAM role that provides permissions for the scraper to dsicover, collect, and produce metrics on your behalf.
        public let roleArn: String
        /// Unique string identifying this scraper.
        public let scraperId: String
        /// The source that the scraper is discovering and collecting metrics from.
        public let source: Source
        /// The status of this scraper.
        public let status: ScraperStatus
        /// The reason for failure if any.
        public let statusReason: String?
        /// The tags of this scraper.
        public let tags: [String: String]?

        public init(alias: String? = nil, arn: String, createdAt: Date, destination: Destination, lastModifiedAt: Date, roleArn: String, scraperId: String, source: Source, status: ScraperStatus, statusReason: String? = nil, tags: [String: String]? = nil) {
            self.alias = alias
            self.arn = arn
            self.createdAt = createdAt
            self.destination = destination
            self.lastModifiedAt = lastModifiedAt
            self.roleArn = roleArn
            self.scraperId = scraperId
            self.source = source
            self.status = status
            self.statusReason = statusReason
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case alias = "alias"
            case arn = "arn"
            case createdAt = "createdAt"
            case destination = "destination"
            case lastModifiedAt = "lastModifiedAt"
            case roleArn = "roleArn"
            case scraperId = "scraperId"
            case source = "source"
            case status = "status"
            case statusReason = "statusReason"
            case tags = "tags"
        }
    }

    public struct TagResourceRequest: AWSEncodableShape {
        /// The ARN of the resource.
        public let resourceArn: String
        public let tags: [String: String]

        public init(resourceArn: String, tags: [String: String]) {
            self.resourceArn = resourceArn
            self.tags = tags
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.resourceArn, key: "resourceArn")
            try container.encode(self.tags, forKey: .tags)
        }

        public func validate(name: String) throws {
            try self.tags.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.key, name: "tags.key", parent: name, pattern: "^([\\p{L}\\p{Z}\\p{N}_.:/=+\\-@]*)$")
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, pattern: "^([\\p{L}\\p{Z}\\p{N}_.:/=+\\-@]*)$")
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 50)
        }

        private enum CodingKeys: String, CodingKey {
            case tags = "tags"
        }
    }

    public struct TagResourceResponse: AWSDecodableShape {
        public init() {}
    }

    public struct UntagResourceRequest: AWSEncodableShape {
        /// The ARN of the resource.
        public let resourceArn: String
        /// One or more tag keys
        public let tagKeys: [String]

        public init(resourceArn: String, tagKeys: [String]) {
            self.resourceArn = resourceArn
            self.tagKeys = tagKeys
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.resourceArn, key: "resourceArn")
            request.encodeQuery(self.tagKeys, key: "tagKeys")
        }

        public func validate(name: String) throws {
            try self.tagKeys.forEach {
                try validate($0, name: "tagKeys[]", parent: name, max: 128)
                try validate($0, name: "tagKeys[]", parent: name, min: 1)
                try validate($0, name: "tagKeys[]", parent: name, pattern: "^([\\p{L}\\p{Z}\\p{N}_.:/=+\\-@]*)$")
            }
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct UntagResourceResponse: AWSDecodableShape {
        public init() {}
    }

    public struct UpdateLoggingConfigurationRequest: AWSEncodableShape {
        /// Optional, unique, case-sensitive, user-provided identifier to ensure the idempotency of the request.
        public let clientToken: String?
        /// The ARN of the CW log group to which the vended log data will be published.
        public let logGroupArn: String
        /// The ID of the workspace to vend logs to.
        public let workspaceId: String

        public init(clientToken: String? = UpdateLoggingConfigurationRequest.idempotencyToken(), logGroupArn: String, workspaceId: String) {
            self.clientToken = clientToken
            self.logGroupArn = logGroupArn
            self.workspaceId = workspaceId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.clientToken, forKey: .clientToken)
            try container.encode(self.logGroupArn, forKey: .logGroupArn)
            request.encodePath(self.workspaceId, key: "workspaceId")
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 64)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "^[!-~]+$")
            try self.validate(self.logGroupArn, name: "logGroupArn", parent: name, pattern: "^arn:aws[a-z0-9-]*:logs:[a-z0-9-]+:\\d{12}:log-group:[A-Za-z0-9\\.\\-\\_\\#/]{1,512}\\:\\*$")
            try self.validate(self.workspaceId, name: "workspaceId", parent: name, max: 64)
            try self.validate(self.workspaceId, name: "workspaceId", parent: name, min: 1)
            try self.validate(self.workspaceId, name: "workspaceId", parent: name, pattern: "[0-9A-Za-z][-.0-9A-Z_a-z]*")
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "clientToken"
            case logGroupArn = "logGroupArn"
        }
    }

    public struct UpdateLoggingConfigurationResponse: AWSDecodableShape {
        /// The status of the logging configuration.
        public let status: LoggingConfigurationStatus

        public init(status: LoggingConfigurationStatus) {
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case status = "status"
        }
    }

    public struct UpdateWorkspaceAliasRequest: AWSEncodableShape {
        /// The new alias of the workspace.
        public let alias: String?
        /// Optional, unique, case-sensitive, user-provided identifier to ensure the idempotency of the request.
        public let clientToken: String?
        /// The ID of the workspace being updated.
        public let workspaceId: String

        public init(alias: String? = nil, clientToken: String? = UpdateWorkspaceAliasRequest.idempotencyToken(), workspaceId: String) {
            self.alias = alias
            self.clientToken = clientToken
            self.workspaceId = workspaceId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.alias, forKey: .alias)
            try container.encodeIfPresent(self.clientToken, forKey: .clientToken)
            request.encodePath(self.workspaceId, key: "workspaceId")
        }

        public func validate(name: String) throws {
            try self.validate(self.alias, name: "alias", parent: name, max: 100)
            try self.validate(self.alias, name: "alias", parent: name, min: 1)
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 64)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "^[!-~]+$")
            try self.validate(self.workspaceId, name: "workspaceId", parent: name, max: 64)
            try self.validate(self.workspaceId, name: "workspaceId", parent: name, min: 1)
            try self.validate(self.workspaceId, name: "workspaceId", parent: name, pattern: "[0-9A-Za-z][-.0-9A-Z_a-z]*")
        }

        private enum CodingKeys: String, CodingKey {
            case alias = "alias"
            case clientToken = "clientToken"
        }
    }

    public struct WorkspaceDescription: AWSDecodableShape {
        /// Alias of this workspace.
        public let alias: String?
        /// The Amazon Resource Name (ARN) of this workspace.
        public let arn: String
        /// The time when the workspace was created.
        public let createdAt: Date
        /// Prometheus endpoint URI.
        public let prometheusEndpoint: String?
        /// The status of this workspace.
        public let status: WorkspaceStatus
        /// The tags of this workspace.
        public let tags: [String: String]?
        /// Unique string identifying this workspace.
        public let workspaceId: String

        public init(alias: String? = nil, arn: String, createdAt: Date, prometheusEndpoint: String? = nil, status: WorkspaceStatus, tags: [String: String]? = nil, workspaceId: String) {
            self.alias = alias
            self.arn = arn
            self.createdAt = createdAt
            self.prometheusEndpoint = prometheusEndpoint
            self.status = status
            self.tags = tags
            self.workspaceId = workspaceId
        }

        private enum CodingKeys: String, CodingKey {
            case alias = "alias"
            case arn = "arn"
            case createdAt = "createdAt"
            case prometheusEndpoint = "prometheusEndpoint"
            case status = "status"
            case tags = "tags"
            case workspaceId = "workspaceId"
        }
    }

    public struct WorkspaceStatus: AWSDecodableShape {
        /// Status code of this workspace.
        public let statusCode: WorkspaceStatusCode

        public init(statusCode: WorkspaceStatusCode) {
            self.statusCode = statusCode
        }

        private enum CodingKeys: String, CodingKey {
            case statusCode = "statusCode"
        }
    }

    public struct WorkspaceSummary: AWSDecodableShape {
        /// Alias of this workspace.
        public let alias: String?
        /// The AmazonResourceName of this workspace.
        public let arn: String
        /// The time when the workspace was created.
        public let createdAt: Date
        /// The status of this workspace.
        public let status: WorkspaceStatus
        /// The tags of this workspace.
        public let tags: [String: String]?
        /// Unique string identifying this workspace.
        public let workspaceId: String

        public init(alias: String? = nil, arn: String, createdAt: Date, status: WorkspaceStatus, tags: [String: String]? = nil, workspaceId: String) {
            self.alias = alias
            self.arn = arn
            self.createdAt = createdAt
            self.status = status
            self.tags = tags
            self.workspaceId = workspaceId
        }

        private enum CodingKeys: String, CodingKey {
            case alias = "alias"
            case arn = "arn"
            case createdAt = "createdAt"
            case status = "status"
            case tags = "tags"
            case workspaceId = "workspaceId"
        }
    }

    public struct Destination: AWSEncodableShape & AWSDecodableShape {
        /// A representation of an AMP destination.
        public let ampConfiguration: AmpConfiguration?

        public init(ampConfiguration: AmpConfiguration? = nil) {
            self.ampConfiguration = ampConfiguration
        }

        public func validate(name: String) throws {
            try self.ampConfiguration?.validate(name: "\(name).ampConfiguration")
        }

        private enum CodingKeys: String, CodingKey {
            case ampConfiguration = "ampConfiguration"
        }
    }

    public struct ScrapeConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// Binary data representing a Prometheus configuration file.
        public let configurationBlob: AWSBase64Data?

        public init(configurationBlob: AWSBase64Data? = nil) {
            self.configurationBlob = configurationBlob
        }

        private enum CodingKeys: String, CodingKey {
            case configurationBlob = "configurationBlob"
        }
    }

    public struct Source: AWSEncodableShape & AWSDecodableShape {
        /// A representation of an EKS source.
        public let eksConfiguration: EksConfiguration?

        public init(eksConfiguration: EksConfiguration? = nil) {
            self.eksConfiguration = eksConfiguration
        }

        public func validate(name: String) throws {
            try self.eksConfiguration?.validate(name: "\(name).eksConfiguration")
        }

        private enum CodingKeys: String, CodingKey {
            case eksConfiguration = "eksConfiguration"
        }
    }
}

// MARK: - Errors

/// Error enum for Amp
public struct AmpErrorType: AWSErrorType {
    enum Code: String {
        case accessDeniedException = "AccessDeniedException"
        case conflictException = "ConflictException"
        case internalServerException = "InternalServerException"
        case resourceNotFoundException = "ResourceNotFoundException"
        case serviceQuotaExceededException = "ServiceQuotaExceededException"
        case throttlingException = "ThrottlingException"
        case validationException = "ValidationException"
    }

    private let error: Code
    public let context: AWSErrorContext?

    /// initialize Amp
    public init?(errorCode: String, context: AWSErrorContext) {
        guard let error = Code(rawValue: errorCode) else { return nil }
        self.error = error
        self.context = context
    }

    internal init(_ error: Code) {
        self.error = error
        self.context = nil
    }

    /// return error code string
    public var errorCode: String { self.error.rawValue }

    /// User does not have sufficient access to perform this action.
    public static var accessDeniedException: Self { .init(.accessDeniedException) }
    /// Updating or deleting a resource can cause an inconsistent state.
    public static var conflictException: Self { .init(.conflictException) }
    /// Unexpected error during processing of request.
    public static var internalServerException: Self { .init(.internalServerException) }
    /// Request references a resource which does not exist.
    public static var resourceNotFoundException: Self { .init(.resourceNotFoundException) }
    /// Request would cause a service quota to be exceeded.
    public static var serviceQuotaExceededException: Self { .init(.serviceQuotaExceededException) }
    /// Request was denied due to request throttling.
    public static var throttlingException: Self { .init(.throttlingException) }
    /// The input fails to satisfy the constraints specified by an AWS service.
    public static var validationException: Self { .init(.validationException) }
}

extension AmpErrorType: Equatable {
    public static func == (lhs: AmpErrorType, rhs: AmpErrorType) -> Bool {
        lhs.error == rhs.error
    }
}

extension AmpErrorType: CustomStringConvertible {
    public var description: String {
        return "\(self.error.rawValue): \(self.message ?? "")"
    }
}
