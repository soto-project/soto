//===----------------------------------------------------------------------===//
//
// This source file is part of the Soto for AWS open source project
//
// Copyright (c) 2017-2022 the Soto project authors
// Licensed under Apache License v2.0
//
// See LICENSE.txt for license information
// See CONTRIBUTORS.txt for the list of Soto project authors
//
// SPDX-License-Identifier: Apache-2.0
//
//===----------------------------------------------------------------------===//

// THIS FILE IS AUTOMATICALLY GENERATED by https://github.com/soto-project/soto-codegenerator.
// DO NOT EDIT.

import Foundation
import SotoCore

extension Amp {
    // MARK: Enums

    public enum AlertManagerDefinitionStatusCode: String, CustomStringConvertible, Codable, _SotoSendable {
        /// Definition has been created/updated. Update/Deletion is disallowed until definition is ACTIVE and workspace status is ACTIVE.
        case active = "ACTIVE"
        /// Definition is being created. Update/Deletion is disallowed until definition is ACTIVE and workspace status is ACTIVE.
        case creating = "CREATING"
        /// Definition creation failed.
        case creationFailed = "CREATION_FAILED"
        /// Definition is being deleting. Update/Deletion is disallowed until definition is ACTIVE and workspace status is ACTIVE.
        case deleting = "DELETING"
        /// Definition update failed.
        case updateFailed = "UPDATE_FAILED"
        /// Definition is being updated. Update/Deletion is disallowed until definition is ACTIVE and workspace status is ACTIVE.
        case updating = "UPDATING"
        public var description: String { return self.rawValue }
    }

    public enum LoggingConfigurationStatusCode: String, CustomStringConvertible, Codable, _SotoSendable {
        /// Logging configuration has been created/updated. Update/Deletion is disallowed until logging configuration is ACTIVE and workspace status is ACTIVE.
        case active = "ACTIVE"
        /// Logging configuration is being created. Update/Deletion is disallowed until logging configuration is ACTIVE and workspace status is ACTIVE.
        case creating = "CREATING"
        /// Logging configuration creation failed.
        case creationFailed = "CREATION_FAILED"
        /// Logging configuration is being deleting. Update/Deletion is disallowed until logging configuration is ACTIVE and workspace status is ACTIVE.
        case deleting = "DELETING"
        /// Logging configuration update failed.
        case updateFailed = "UPDATE_FAILED"
        /// Logging configuration is being updated. Update/Deletion is disallowed until logging configuration is ACTIVE and workspace status is ACTIVE.
        case updating = "UPDATING"
        public var description: String { return self.rawValue }
    }

    public enum RuleGroupsNamespaceStatusCode: String, CustomStringConvertible, Codable, _SotoSendable {
        /// Namespace has been created/updated. Update/Deletion is disallowed until namespace is ACTIVE and workspace status is ACTIVE.
        case active = "ACTIVE"
        /// Namespace is being created. Update/Deletion is disallowed until namespace is ACTIVE and workspace status is ACTIVE.
        case creating = "CREATING"
        /// Namespace creation failed.
        case creationFailed = "CREATION_FAILED"
        /// Namespace is being deleting. Update/Deletion is disallowed until namespace is ACTIVE and workspace status is ACTIVE.
        case deleting = "DELETING"
        /// Namespace update failed.
        case updateFailed = "UPDATE_FAILED"
        /// Namespace is being updated. Update/Deletion is disallowed until namespace is ACTIVE and workspace status is ACTIVE.
        case updating = "UPDATING"
        public var description: String { return self.rawValue }
    }

    public enum WorkspaceStatusCode: String, CustomStringConvertible, Codable, _SotoSendable {
        /// Workspace has been created and is usable.
        case active = "ACTIVE"
        /// Workspace is being created. Deletion is disallowed until status is ACTIVE.
        case creating = "CREATING"
        /// Workspace creation failed. Refer to WorkspaceStatus.failureReason for more details.
        case creationFailed = "CREATION_FAILED"
        /// Workspace is being deleted. Deletions are allowed only when status is ACTIVE.
        case deleting = "DELETING"
        /// Workspace is being updated. Updates are allowed only when status is ACTIVE.
        case updating = "UPDATING"
        public var description: String { return self.rawValue }
    }

    // MARK: Shapes

    public struct AlertManagerDefinitionDescription: AWSDecodableShape {
        /// The time when the alert manager definition was created.
        public let createdAt: Date
        /// The alert manager definition.
        public let data: AWSBase64Data
        /// The time when the alert manager definition was modified.
        public let modifiedAt: Date
        /// The status of alert manager definition.
        public let status: AlertManagerDefinitionStatus

        public init(createdAt: Date, data: AWSBase64Data, modifiedAt: Date, status: AlertManagerDefinitionStatus) {
            self.createdAt = createdAt
            self.data = data
            self.modifiedAt = modifiedAt
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case createdAt
            case data
            case modifiedAt
            case status
        }
    }

    public struct AlertManagerDefinitionStatus: AWSDecodableShape {
        /// Status code of this definition.
        public let statusCode: AlertManagerDefinitionStatusCode
        /// The reason for failure if any.
        public let statusReason: String?

        public init(statusCode: AlertManagerDefinitionStatusCode, statusReason: String? = nil) {
            self.statusCode = statusCode
            self.statusReason = statusReason
        }

        private enum CodingKeys: String, CodingKey {
            case statusCode
            case statusReason
        }
    }

    public struct CreateAlertManagerDefinitionRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "workspaceId", location: .uri("workspaceId"))
        ]

        /// Optional, unique, case-sensitive, user-provided identifier to ensure the idempotency of the request.
        public let clientToken: String?
        /// The alert manager definition data.
        public let data: AWSBase64Data
        /// The ID of the workspace in which to create the alert manager definition.
        public let workspaceId: String

        public init(clientToken: String? = CreateAlertManagerDefinitionRequest.idempotencyToken(), data: AWSBase64Data, workspaceId: String) {
            self.clientToken = clientToken
            self.data = data
            self.workspaceId = workspaceId
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 64)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "[!-~]+")
            try self.validate(self.workspaceId, name: "workspaceId", parent: name, max: 64)
            try self.validate(self.workspaceId, name: "workspaceId", parent: name, min: 1)
            try self.validate(self.workspaceId, name: "workspaceId", parent: name, pattern: "[0-9A-Za-z][-.0-9A-Z_a-z]*")
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken
            case data
        }
    }

    public struct CreateAlertManagerDefinitionResponse: AWSDecodableShape {
        /// The status of alert manager definition.
        public let status: AlertManagerDefinitionStatus

        public init(status: AlertManagerDefinitionStatus) {
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case status
        }
    }

    public struct CreateLoggingConfigurationRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "workspaceId", location: .uri("workspaceId"))
        ]

        /// Optional, unique, case-sensitive, user-provided identifier to ensure the idempotency of the request.
        public let clientToken: String?
        /// The ARN of the CW log group to which the vended log data will be published.
        public let logGroupArn: String
        /// The ID of the workspace to vend logs to.
        public let workspaceId: String

        public init(clientToken: String? = CreateLoggingConfigurationRequest.idempotencyToken(), logGroupArn: String, workspaceId: String) {
            self.clientToken = clientToken
            self.logGroupArn = logGroupArn
            self.workspaceId = workspaceId
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 64)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "[!-~]+")
            try self.validate(self.logGroupArn, name: "logGroupArn", parent: name, pattern: "^arn:aws[a-z0-9-]*:logs:[a-z0-9-]+:\\d{12}:log-group:[A-Za-z0-9\\.\\-\\_\\#/]{1,512}\\:\\*$")
            try self.validate(self.workspaceId, name: "workspaceId", parent: name, max: 64)
            try self.validate(self.workspaceId, name: "workspaceId", parent: name, min: 1)
            try self.validate(self.workspaceId, name: "workspaceId", parent: name, pattern: "[0-9A-Za-z][-.0-9A-Z_a-z]*")
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken
            case logGroupArn
        }
    }

    public struct CreateLoggingConfigurationResponse: AWSDecodableShape {
        /// The status of the logging configuration.
        public let status: LoggingConfigurationStatus

        public init(status: LoggingConfigurationStatus) {
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case status
        }
    }

    public struct CreateRuleGroupsNamespaceRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "workspaceId", location: .uri("workspaceId"))
        ]

        /// Optional, unique, case-sensitive, user-provided identifier to ensure the idempotency of the request.
        public let clientToken: String?
        /// The namespace data that define the rule groups.
        public let data: AWSBase64Data
        /// The rule groups namespace name.
        public let name: String
        /// Optional, user-provided tags for this rule groups namespace.
        public let tags: [String: String]?
        /// The ID of the workspace in which to create the rule group namespace.
        public let workspaceId: String

        public init(clientToken: String? = CreateRuleGroupsNamespaceRequest.idempotencyToken(), data: AWSBase64Data, name: String, tags: [String: String]? = nil, workspaceId: String) {
            self.clientToken = clientToken
            self.data = data
            self.name = name
            self.tags = tags
            self.workspaceId = workspaceId
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 64)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "[!-~]+")
            try self.validate(self.name, name: "name", parent: name, max: 64)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "[0-9A-Za-z][-.0-9A-Z_a-z]*")
            try self.tags?.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.key, name: "tags.key", parent: name, pattern: "^([\\p{L}\\p{Z}\\p{N}_.:/=+\\-@]*)$")
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, pattern: "^([\\p{L}\\p{Z}\\p{N}_.:/=+\\-@]*)$")
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 50)
            try self.validate(self.workspaceId, name: "workspaceId", parent: name, max: 64)
            try self.validate(self.workspaceId, name: "workspaceId", parent: name, min: 1)
            try self.validate(self.workspaceId, name: "workspaceId", parent: name, pattern: "[0-9A-Za-z][-.0-9A-Z_a-z]*")
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken
            case data
            case name
            case tags
        }
    }

    public struct CreateRuleGroupsNamespaceResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of this rule groups namespace.
        public let arn: String
        /// The rule groups namespace name.
        public let name: String
        /// The status of rule groups namespace.
        public let status: RuleGroupsNamespaceStatus
        /// The tags of this rule groups namespace.
        public let tags: [String: String]?

        public init(arn: String, name: String, status: RuleGroupsNamespaceStatus, tags: [String: String]? = nil) {
            self.arn = arn
            self.name = name
            self.status = status
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case arn
            case name
            case status
            case tags
        }
    }

    public struct CreateWorkspaceRequest: AWSEncodableShape {
        /// An optional user-assigned alias for this workspace. This alias is for user reference and does not need to be unique.
        public let alias: String?
        /// Optional, unique, case-sensitive, user-provided identifier to ensure the idempotency of the request.
        public let clientToken: String?
        /// Optional, user-provided tags for this workspace.
        public let tags: [String: String]?

        public init(alias: String? = nil, clientToken: String? = CreateWorkspaceRequest.idempotencyToken(), tags: [String: String]? = nil) {
            self.alias = alias
            self.clientToken = clientToken
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.validate(self.alias, name: "alias", parent: name, max: 100)
            try self.validate(self.alias, name: "alias", parent: name, min: 1)
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 64)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "[!-~]+")
            try self.tags?.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.key, name: "tags.key", parent: name, pattern: "^([\\p{L}\\p{Z}\\p{N}_.:/=+\\-@]*)$")
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, pattern: "^([\\p{L}\\p{Z}\\p{N}_.:/=+\\-@]*)$")
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 50)
        }

        private enum CodingKeys: String, CodingKey {
            case alias
            case clientToken
            case tags
        }
    }

    public struct CreateWorkspaceResponse: AWSDecodableShape {
        /// The ARN of the workspace that was just created.
        public let arn: String
        /// The status of the workspace that was just created (usually CREATING).
        public let status: WorkspaceStatus
        /// The tags of this workspace.
        public let tags: [String: String]?
        /// The generated ID of the workspace that was just created.
        public let workspaceId: String

        public init(arn: String, status: WorkspaceStatus, tags: [String: String]? = nil, workspaceId: String) {
            self.arn = arn
            self.status = status
            self.tags = tags
            self.workspaceId = workspaceId
        }

        private enum CodingKeys: String, CodingKey {
            case arn
            case status
            case tags
            case workspaceId
        }
    }

    public struct DeleteAlertManagerDefinitionRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "clientToken", location: .querystring("clientToken")),
            AWSMemberEncoding(label: "workspaceId", location: .uri("workspaceId"))
        ]

        /// Optional, unique, case-sensitive, user-provided identifier to ensure the idempotency of the request.
        public let clientToken: String?
        /// The ID of the workspace in which to delete the alert manager definition.
        public let workspaceId: String

        public init(clientToken: String? = DeleteAlertManagerDefinitionRequest.idempotencyToken(), workspaceId: String) {
            self.clientToken = clientToken
            self.workspaceId = workspaceId
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 64)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "[!-~]+")
            try self.validate(self.workspaceId, name: "workspaceId", parent: name, max: 64)
            try self.validate(self.workspaceId, name: "workspaceId", parent: name, min: 1)
            try self.validate(self.workspaceId, name: "workspaceId", parent: name, pattern: "[0-9A-Za-z][-.0-9A-Z_a-z]*")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteLoggingConfigurationRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "clientToken", location: .querystring("clientToken")),
            AWSMemberEncoding(label: "workspaceId", location: .uri("workspaceId"))
        ]

        /// Optional, unique, case-sensitive, user-provided identifier to ensure the idempotency of the request.
        public let clientToken: String?
        /// The ID of the workspace to vend logs to.
        public let workspaceId: String

        public init(clientToken: String? = DeleteLoggingConfigurationRequest.idempotencyToken(), workspaceId: String) {
            self.clientToken = clientToken
            self.workspaceId = workspaceId
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 64)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "[!-~]+")
            try self.validate(self.workspaceId, name: "workspaceId", parent: name, max: 64)
            try self.validate(self.workspaceId, name: "workspaceId", parent: name, min: 1)
            try self.validate(self.workspaceId, name: "workspaceId", parent: name, pattern: "[0-9A-Za-z][-.0-9A-Z_a-z]*")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteRuleGroupsNamespaceRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "clientToken", location: .querystring("clientToken")),
            AWSMemberEncoding(label: "name", location: .uri("name")),
            AWSMemberEncoding(label: "workspaceId", location: .uri("workspaceId"))
        ]

        /// Optional, unique, case-sensitive, user-provided identifier to ensure the idempotency of the request.
        public let clientToken: String?
        /// The rule groups namespace name.
        public let name: String
        /// The ID of the workspace to delete rule group definition.
        public let workspaceId: String

        public init(clientToken: String? = DeleteRuleGroupsNamespaceRequest.idempotencyToken(), name: String, workspaceId: String) {
            self.clientToken = clientToken
            self.name = name
            self.workspaceId = workspaceId
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 64)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "[!-~]+")
            try self.validate(self.name, name: "name", parent: name, max: 64)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "[0-9A-Za-z][-.0-9A-Z_a-z]*")
            try self.validate(self.workspaceId, name: "workspaceId", parent: name, max: 64)
            try self.validate(self.workspaceId, name: "workspaceId", parent: name, min: 1)
            try self.validate(self.workspaceId, name: "workspaceId", parent: name, pattern: "[0-9A-Za-z][-.0-9A-Z_a-z]*")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteWorkspaceRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "clientToken", location: .querystring("clientToken")),
            AWSMemberEncoding(label: "workspaceId", location: .uri("workspaceId"))
        ]

        /// Optional, unique, case-sensitive, user-provided identifier to ensure the idempotency of the request.
        public let clientToken: String?
        /// The ID of the workspace to delete.
        public let workspaceId: String

        public init(clientToken: String? = DeleteWorkspaceRequest.idempotencyToken(), workspaceId: String) {
            self.clientToken = clientToken
            self.workspaceId = workspaceId
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 64)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "[!-~]+")
            try self.validate(self.workspaceId, name: "workspaceId", parent: name, max: 64)
            try self.validate(self.workspaceId, name: "workspaceId", parent: name, min: 1)
            try self.validate(self.workspaceId, name: "workspaceId", parent: name, pattern: "[0-9A-Za-z][-.0-9A-Z_a-z]*")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DescribeAlertManagerDefinitionRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "workspaceId", location: .uri("workspaceId"))
        ]

        /// The ID of the workspace to describe.
        public let workspaceId: String

        public init(workspaceId: String) {
            self.workspaceId = workspaceId
        }

        public func validate(name: String) throws {
            try self.validate(self.workspaceId, name: "workspaceId", parent: name, max: 64)
            try self.validate(self.workspaceId, name: "workspaceId", parent: name, min: 1)
            try self.validate(self.workspaceId, name: "workspaceId", parent: name, pattern: "[0-9A-Za-z][-.0-9A-Z_a-z]*")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DescribeAlertManagerDefinitionResponse: AWSDecodableShape {
        /// The properties of the selected workspace's alert manager definition.
        public let alertManagerDefinition: AlertManagerDefinitionDescription

        public init(alertManagerDefinition: AlertManagerDefinitionDescription) {
            self.alertManagerDefinition = alertManagerDefinition
        }

        private enum CodingKeys: String, CodingKey {
            case alertManagerDefinition
        }
    }

    public struct DescribeLoggingConfigurationRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "workspaceId", location: .uri("workspaceId"))
        ]

        /// The ID of the workspace to vend logs to.
        public let workspaceId: String

        public init(workspaceId: String) {
            self.workspaceId = workspaceId
        }

        public func validate(name: String) throws {
            try self.validate(self.workspaceId, name: "workspaceId", parent: name, max: 64)
            try self.validate(self.workspaceId, name: "workspaceId", parent: name, min: 1)
            try self.validate(self.workspaceId, name: "workspaceId", parent: name, pattern: "[0-9A-Za-z][-.0-9A-Z_a-z]*")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DescribeLoggingConfigurationResponse: AWSDecodableShape {
        /// Metadata object containing information about the logging configuration of a workspace.
        public let loggingConfiguration: LoggingConfigurationMetadata

        public init(loggingConfiguration: LoggingConfigurationMetadata) {
            self.loggingConfiguration = loggingConfiguration
        }

        private enum CodingKeys: String, CodingKey {
            case loggingConfiguration
        }
    }

    public struct DescribeRuleGroupsNamespaceRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "name", location: .uri("name")),
            AWSMemberEncoding(label: "workspaceId", location: .uri("workspaceId"))
        ]

        /// The rule groups namespace.
        public let name: String
        /// The ID of the workspace to describe.
        public let workspaceId: String

        public init(name: String, workspaceId: String) {
            self.name = name
            self.workspaceId = workspaceId
        }

        public func validate(name: String) throws {
            try self.validate(self.name, name: "name", parent: name, max: 64)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "[0-9A-Za-z][-.0-9A-Z_a-z]*")
            try self.validate(self.workspaceId, name: "workspaceId", parent: name, max: 64)
            try self.validate(self.workspaceId, name: "workspaceId", parent: name, min: 1)
            try self.validate(self.workspaceId, name: "workspaceId", parent: name, pattern: "[0-9A-Za-z][-.0-9A-Z_a-z]*")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DescribeRuleGroupsNamespaceResponse: AWSDecodableShape {
        /// The selected rule groups namespace.
        public let ruleGroupsNamespace: RuleGroupsNamespaceDescription

        public init(ruleGroupsNamespace: RuleGroupsNamespaceDescription) {
            self.ruleGroupsNamespace = ruleGroupsNamespace
        }

        private enum CodingKeys: String, CodingKey {
            case ruleGroupsNamespace
        }
    }

    public struct DescribeWorkspaceRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "workspaceId", location: .uri("workspaceId"))
        ]

        /// The ID of the workspace to describe.
        public let workspaceId: String

        public init(workspaceId: String) {
            self.workspaceId = workspaceId
        }

        public func validate(name: String) throws {
            try self.validate(self.workspaceId, name: "workspaceId", parent: name, max: 64)
            try self.validate(self.workspaceId, name: "workspaceId", parent: name, min: 1)
            try self.validate(self.workspaceId, name: "workspaceId", parent: name, pattern: "[0-9A-Za-z][-.0-9A-Z_a-z]*")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DescribeWorkspaceResponse: AWSDecodableShape {
        /// The properties of the selected workspace.
        public let workspace: WorkspaceDescription

        public init(workspace: WorkspaceDescription) {
            self.workspace = workspace
        }

        private enum CodingKeys: String, CodingKey {
            case workspace
        }
    }

    public struct ListRuleGroupsNamespacesRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "maxResults", location: .querystring("maxResults")),
            AWSMemberEncoding(label: "name", location: .querystring("name")),
            AWSMemberEncoding(label: "nextToken", location: .querystring("nextToken")),
            AWSMemberEncoding(label: "workspaceId", location: .uri("workspaceId"))
        ]

        /// Maximum results to return in response (default=100, maximum=1000).
        public let maxResults: Int?
        /// Optional filter for rule groups namespace name. Only the rule groups namespace that begin with this value will be returned.
        public let name: String?
        /// Pagination token to request the next page in a paginated list. This token is obtained from the output of the previous ListRuleGroupsNamespaces request.
        public let nextToken: String?
        /// The ID of the workspace.
        public let workspaceId: String

        public init(maxResults: Int? = nil, name: String? = nil, nextToken: String? = nil, workspaceId: String) {
            self.maxResults = maxResults
            self.name = name
            self.nextToken = nextToken
            self.workspaceId = workspaceId
        }

        public func validate(name: String) throws {
            try self.validate(self.name, name: "name", parent: name, max: 64)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "[0-9A-Za-z][-.0-9A-Z_a-z]*")
            try self.validate(self.workspaceId, name: "workspaceId", parent: name, max: 64)
            try self.validate(self.workspaceId, name: "workspaceId", parent: name, min: 1)
            try self.validate(self.workspaceId, name: "workspaceId", parent: name, pattern: "[0-9A-Za-z][-.0-9A-Z_a-z]*")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListRuleGroupsNamespacesResponse: AWSDecodableShape {
        /// Pagination token to use when requesting the next page in this list.
        public let nextToken: String?
        /// The list of the selected rule groups namespaces.
        public let ruleGroupsNamespaces: [RuleGroupsNamespaceSummary]

        public init(nextToken: String? = nil, ruleGroupsNamespaces: [RuleGroupsNamespaceSummary]) {
            self.nextToken = nextToken
            self.ruleGroupsNamespaces = ruleGroupsNamespaces
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken
            case ruleGroupsNamespaces
        }
    }

    public struct ListTagsForResourceRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "resourceArn", location: .uri("resourceArn"))
        ]

        /// The ARN of the resource.
        public let resourceArn: String

        public init(resourceArn: String) {
            self.resourceArn = resourceArn
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListTagsForResourceResponse: AWSDecodableShape {
        public let tags: [String: String]?

        public init(tags: [String: String]? = nil) {
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case tags
        }
    }

    public struct ListWorkspacesRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "alias", location: .querystring("alias")),
            AWSMemberEncoding(label: "maxResults", location: .querystring("maxResults")),
            AWSMemberEncoding(label: "nextToken", location: .querystring("nextToken"))
        ]

        /// Optional filter for workspace alias. Only the workspaces with aliases that begin with this value will be returned.
        public let alias: String?
        /// Maximum results to return in response (default=100, maximum=1000).
        public let maxResults: Int?
        /// Pagination token to request the next page in a paginated list. This token is obtained from the output of the previous ListWorkspaces request.
        public let nextToken: String?

        public init(alias: String? = nil, maxResults: Int? = nil, nextToken: String? = nil) {
            self.alias = alias
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.validate(self.alias, name: "alias", parent: name, max: 100)
            try self.validate(self.alias, name: "alias", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListWorkspacesResponse: AWSDecodableShape {
        /// Pagination token to use when requesting the next page in this list.
        public let nextToken: String?
        /// The list of existing workspaces, including those undergoing creation or deletion.
        public let workspaces: [WorkspaceSummary]

        public init(nextToken: String? = nil, workspaces: [WorkspaceSummary]) {
            self.nextToken = nextToken
            self.workspaces = workspaces
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken
            case workspaces
        }
    }

    public struct LoggingConfigurationMetadata: AWSDecodableShape {
        /// The time when the logging configuration was created.
        public let createdAt: Date
        /// The ARN of the CW log group to which the vended log data will be published.
        public let logGroupArn: String
        /// The time when the logging configuration was modified.
        public let modifiedAt: Date
        /// The status of the logging configuration.
        public let status: LoggingConfigurationStatus
        /// The workspace where the logging configuration exists.
        public let workspace: String

        public init(createdAt: Date, logGroupArn: String, modifiedAt: Date, status: LoggingConfigurationStatus, workspace: String) {
            self.createdAt = createdAt
            self.logGroupArn = logGroupArn
            self.modifiedAt = modifiedAt
            self.status = status
            self.workspace = workspace
        }

        private enum CodingKeys: String, CodingKey {
            case createdAt
            case logGroupArn
            case modifiedAt
            case status
            case workspace
        }
    }

    public struct LoggingConfigurationStatus: AWSDecodableShape {
        /// Status code of the logging configuration.
        public let statusCode: LoggingConfigurationStatusCode
        /// The reason for failure if any.
        public let statusReason: String?

        public init(statusCode: LoggingConfigurationStatusCode, statusReason: String? = nil) {
            self.statusCode = statusCode
            self.statusReason = statusReason
        }

        private enum CodingKeys: String, CodingKey {
            case statusCode
            case statusReason
        }
    }

    public struct PutAlertManagerDefinitionRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "workspaceId", location: .uri("workspaceId"))
        ]

        /// Optional, unique, case-sensitive, user-provided identifier to ensure the idempotency of the request.
        public let clientToken: String?
        /// The alert manager definition data.
        public let data: AWSBase64Data
        /// The ID of the workspace in which to update the alert manager definition.
        public let workspaceId: String

        public init(clientToken: String? = PutAlertManagerDefinitionRequest.idempotencyToken(), data: AWSBase64Data, workspaceId: String) {
            self.clientToken = clientToken
            self.data = data
            self.workspaceId = workspaceId
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 64)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "[!-~]+")
            try self.validate(self.workspaceId, name: "workspaceId", parent: name, max: 64)
            try self.validate(self.workspaceId, name: "workspaceId", parent: name, min: 1)
            try self.validate(self.workspaceId, name: "workspaceId", parent: name, pattern: "[0-9A-Za-z][-.0-9A-Z_a-z]*")
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken
            case data
        }
    }

    public struct PutAlertManagerDefinitionResponse: AWSDecodableShape {
        /// The status of alert manager definition.
        public let status: AlertManagerDefinitionStatus

        public init(status: AlertManagerDefinitionStatus) {
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case status
        }
    }

    public struct PutRuleGroupsNamespaceRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "name", location: .uri("name")),
            AWSMemberEncoding(label: "workspaceId", location: .uri("workspaceId"))
        ]

        /// Optional, unique, case-sensitive, user-provided identifier to ensure the idempotency of the request.
        public let clientToken: String?
        /// The namespace data that define the rule groups.
        public let data: AWSBase64Data
        /// The rule groups namespace name.
        public let name: String
        /// The ID of the workspace in which to update the rule group namespace.
        public let workspaceId: String

        public init(clientToken: String? = PutRuleGroupsNamespaceRequest.idempotencyToken(), data: AWSBase64Data, name: String, workspaceId: String) {
            self.clientToken = clientToken
            self.data = data
            self.name = name
            self.workspaceId = workspaceId
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 64)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "[!-~]+")
            try self.validate(self.name, name: "name", parent: name, max: 64)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "[0-9A-Za-z][-.0-9A-Z_a-z]*")
            try self.validate(self.workspaceId, name: "workspaceId", parent: name, max: 64)
            try self.validate(self.workspaceId, name: "workspaceId", parent: name, min: 1)
            try self.validate(self.workspaceId, name: "workspaceId", parent: name, pattern: "[0-9A-Za-z][-.0-9A-Z_a-z]*")
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken
            case data
        }
    }

    public struct PutRuleGroupsNamespaceResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of this rule groups namespace.
        public let arn: String
        /// The rule groups namespace name.
        public let name: String
        /// The status of rule groups namespace.
        public let status: RuleGroupsNamespaceStatus
        /// The tags of this rule groups namespace.
        public let tags: [String: String]?

        public init(arn: String, name: String, status: RuleGroupsNamespaceStatus, tags: [String: String]? = nil) {
            self.arn = arn
            self.name = name
            self.status = status
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case arn
            case name
            case status
            case tags
        }
    }

    public struct RuleGroupsNamespaceDescription: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of this rule groups namespace.
        public let arn: String
        /// The time when the rule groups namespace was created.
        public let createdAt: Date
        /// The rule groups namespace data.
        public let data: AWSBase64Data
        /// The time when the rule groups namespace was modified.
        public let modifiedAt: Date
        /// The rule groups namespace name.
        public let name: String
        /// The status of rule groups namespace.
        public let status: RuleGroupsNamespaceStatus
        /// The tags of this rule groups namespace.
        public let tags: [String: String]?

        public init(arn: String, createdAt: Date, data: AWSBase64Data, modifiedAt: Date, name: String, status: RuleGroupsNamespaceStatus, tags: [String: String]? = nil) {
            self.arn = arn
            self.createdAt = createdAt
            self.data = data
            self.modifiedAt = modifiedAt
            self.name = name
            self.status = status
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case arn
            case createdAt
            case data
            case modifiedAt
            case name
            case status
            case tags
        }
    }

    public struct RuleGroupsNamespaceStatus: AWSDecodableShape {
        /// Status code of this namespace.
        public let statusCode: RuleGroupsNamespaceStatusCode
        /// The reason for failure if any.
        public let statusReason: String?

        public init(statusCode: RuleGroupsNamespaceStatusCode, statusReason: String? = nil) {
            self.statusCode = statusCode
            self.statusReason = statusReason
        }

        private enum CodingKeys: String, CodingKey {
            case statusCode
            case statusReason
        }
    }

    public struct RuleGroupsNamespaceSummary: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of this rule groups namespace.
        public let arn: String
        /// The time when the rule groups namespace was created.
        public let createdAt: Date
        /// The time when the rule groups namespace was modified.
        public let modifiedAt: Date
        /// The rule groups namespace name.
        public let name: String
        /// The status of rule groups namespace.
        public let status: RuleGroupsNamespaceStatus
        /// The tags of this rule groups namespace.
        public let tags: [String: String]?

        public init(arn: String, createdAt: Date, modifiedAt: Date, name: String, status: RuleGroupsNamespaceStatus, tags: [String: String]? = nil) {
            self.arn = arn
            self.createdAt = createdAt
            self.modifiedAt = modifiedAt
            self.name = name
            self.status = status
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case arn
            case createdAt
            case modifiedAt
            case name
            case status
            case tags
        }
    }

    public struct TagResourceRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "resourceArn", location: .uri("resourceArn"))
        ]

        /// The ARN of the resource.
        public let resourceArn: String
        public let tags: [String: String]

        public init(resourceArn: String, tags: [String: String]) {
            self.resourceArn = resourceArn
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.tags.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.key, name: "tags.key", parent: name, pattern: "^([\\p{L}\\p{Z}\\p{N}_.:/=+\\-@]*)$")
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, pattern: "^([\\p{L}\\p{Z}\\p{N}_.:/=+\\-@]*)$")
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 50)
        }

        private enum CodingKeys: String, CodingKey {
            case tags
        }
    }

    public struct TagResourceResponse: AWSDecodableShape {
        public init() {}
    }

    public struct UntagResourceRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "resourceArn", location: .uri("resourceArn")),
            AWSMemberEncoding(label: "tagKeys", location: .querystring("tagKeys"))
        ]

        /// The ARN of the resource.
        public let resourceArn: String
        /// One or more tag keys
        public let tagKeys: [String]

        public init(resourceArn: String, tagKeys: [String]) {
            self.resourceArn = resourceArn
            self.tagKeys = tagKeys
        }

        public func validate(name: String) throws {
            try self.tagKeys.forEach {
                try validate($0, name: "tagKeys[]", parent: name, max: 128)
                try validate($0, name: "tagKeys[]", parent: name, min: 1)
                try validate($0, name: "tagKeys[]", parent: name, pattern: "^([\\p{L}\\p{Z}\\p{N}_.:/=+\\-@]*)$")
            }
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct UntagResourceResponse: AWSDecodableShape {
        public init() {}
    }

    public struct UpdateLoggingConfigurationRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "workspaceId", location: .uri("workspaceId"))
        ]

        /// Optional, unique, case-sensitive, user-provided identifier to ensure the idempotency of the request.
        public let clientToken: String?
        /// The ARN of the CW log group to which the vended log data will be published.
        public let logGroupArn: String
        /// The ID of the workspace to vend logs to.
        public let workspaceId: String

        public init(clientToken: String? = UpdateLoggingConfigurationRequest.idempotencyToken(), logGroupArn: String, workspaceId: String) {
            self.clientToken = clientToken
            self.logGroupArn = logGroupArn
            self.workspaceId = workspaceId
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 64)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "[!-~]+")
            try self.validate(self.logGroupArn, name: "logGroupArn", parent: name, pattern: "^arn:aws[a-z0-9-]*:logs:[a-z0-9-]+:\\d{12}:log-group:[A-Za-z0-9\\.\\-\\_\\#/]{1,512}\\:\\*$")
            try self.validate(self.workspaceId, name: "workspaceId", parent: name, max: 64)
            try self.validate(self.workspaceId, name: "workspaceId", parent: name, min: 1)
            try self.validate(self.workspaceId, name: "workspaceId", parent: name, pattern: "[0-9A-Za-z][-.0-9A-Z_a-z]*")
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken
            case logGroupArn
        }
    }

    public struct UpdateLoggingConfigurationResponse: AWSDecodableShape {
        /// The status of the logging configuration.
        public let status: LoggingConfigurationStatus

        public init(status: LoggingConfigurationStatus) {
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case status
        }
    }

    public struct UpdateWorkspaceAliasRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "workspaceId", location: .uri("workspaceId"))
        ]

        /// The new alias of the workspace.
        public let alias: String?
        /// Optional, unique, case-sensitive, user-provided identifier to ensure the idempotency of the request.
        public let clientToken: String?
        /// The ID of the workspace being updated.
        public let workspaceId: String

        public init(alias: String? = nil, clientToken: String? = UpdateWorkspaceAliasRequest.idempotencyToken(), workspaceId: String) {
            self.alias = alias
            self.clientToken = clientToken
            self.workspaceId = workspaceId
        }

        public func validate(name: String) throws {
            try self.validate(self.alias, name: "alias", parent: name, max: 100)
            try self.validate(self.alias, name: "alias", parent: name, min: 1)
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 64)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "[!-~]+")
            try self.validate(self.workspaceId, name: "workspaceId", parent: name, max: 64)
            try self.validate(self.workspaceId, name: "workspaceId", parent: name, min: 1)
            try self.validate(self.workspaceId, name: "workspaceId", parent: name, pattern: "[0-9A-Za-z][-.0-9A-Z_a-z]*")
        }

        private enum CodingKeys: String, CodingKey {
            case alias
            case clientToken
        }
    }

    public struct WorkspaceDescription: AWSDecodableShape {
        /// Alias of this workspace.
        public let alias: String?
        /// The Amazon Resource Name (ARN) of this workspace.
        public let arn: String
        /// The time when the workspace was created.
        public let createdAt: Date
        /// Prometheus endpoint URI.
        public let prometheusEndpoint: String?
        /// The status of this workspace.
        public let status: WorkspaceStatus
        /// The tags of this workspace.
        public let tags: [String: String]?
        /// Unique string identifying this workspace.
        public let workspaceId: String

        public init(alias: String? = nil, arn: String, createdAt: Date, prometheusEndpoint: String? = nil, status: WorkspaceStatus, tags: [String: String]? = nil, workspaceId: String) {
            self.alias = alias
            self.arn = arn
            self.createdAt = createdAt
            self.prometheusEndpoint = prometheusEndpoint
            self.status = status
            self.tags = tags
            self.workspaceId = workspaceId
        }

        private enum CodingKeys: String, CodingKey {
            case alias
            case arn
            case createdAt
            case prometheusEndpoint
            case status
            case tags
            case workspaceId
        }
    }

    public struct WorkspaceStatus: AWSDecodableShape {
        /// Status code of this workspace.
        public let statusCode: WorkspaceStatusCode

        public init(statusCode: WorkspaceStatusCode) {
            self.statusCode = statusCode
        }

        private enum CodingKeys: String, CodingKey {
            case statusCode
        }
    }

    public struct WorkspaceSummary: AWSDecodableShape {
        /// Alias of this workspace.
        public let alias: String?
        /// The AmazonResourceName of this workspace.
        public let arn: String
        /// The time when the workspace was created.
        public let createdAt: Date
        /// The status of this workspace.
        public let status: WorkspaceStatus
        /// The tags of this workspace.
        public let tags: [String: String]?
        /// Unique string identifying this workspace.
        public let workspaceId: String

        public init(alias: String? = nil, arn: String, createdAt: Date, status: WorkspaceStatus, tags: [String: String]? = nil, workspaceId: String) {
            self.alias = alias
            self.arn = arn
            self.createdAt = createdAt
            self.status = status
            self.tags = tags
            self.workspaceId = workspaceId
        }

        private enum CodingKeys: String, CodingKey {
            case alias
            case arn
            case createdAt
            case status
            case tags
            case workspaceId
        }
    }
}

// MARK: - Errors

/// Error enum for Amp
public struct AmpErrorType: AWSErrorType {
    enum Code: String {
        case accessDeniedException = "AccessDeniedException"
        case conflictException = "ConflictException"
        case internalServerException = "InternalServerException"
        case resourceNotFoundException = "ResourceNotFoundException"
        case serviceQuotaExceededException = "ServiceQuotaExceededException"
        case throttlingException = "ThrottlingException"
        case validationException = "ValidationException"
    }

    private let error: Code
    public let context: AWSErrorContext?

    /// initialize Amp
    public init?(errorCode: String, context: AWSErrorContext) {
        guard let error = Code(rawValue: errorCode) else { return nil }
        self.error = error
        self.context = context
    }

    internal init(_ error: Code) {
        self.error = error
        self.context = nil
    }

    /// return error code string
    public var errorCode: String { self.error.rawValue }

    /// User does not have sufficient access to perform this action.
    public static var accessDeniedException: Self { .init(.accessDeniedException) }
    /// Updating or deleting a resource can cause an inconsistent state.
    public static var conflictException: Self { .init(.conflictException) }
    /// Unexpected error during processing of request.
    public static var internalServerException: Self { .init(.internalServerException) }
    /// Request references a resource which does not exist.
    public static var resourceNotFoundException: Self { .init(.resourceNotFoundException) }
    /// Request would cause a service quota to be exceeded.
    public static var serviceQuotaExceededException: Self { .init(.serviceQuotaExceededException) }
    /// Request was denied due to request throttling.
    public static var throttlingException: Self { .init(.throttlingException) }
    /// The input fails to satisfy the constraints specified by an AWS service.
    public static var validationException: Self { .init(.validationException) }
}

extension AmpErrorType: Equatable {
    public static func == (lhs: AmpErrorType, rhs: AmpErrorType) -> Bool {
        lhs.error == rhs.error
    }
}

extension AmpErrorType: CustomStringConvertible {
    public var description: String {
        return "\(self.error.rawValue): \(self.message ?? "")"
    }
}
