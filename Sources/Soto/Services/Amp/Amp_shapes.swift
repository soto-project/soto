//===----------------------------------------------------------------------===//
//
// This source file is part of the Soto for AWS open source project
//
// Copyright (c) 2017-2024 the Soto project authors
// Licensed under Apache License v2.0
//
// See LICENSE.txt for license information
// See CONTRIBUTORS.txt for the list of Soto project authors
//
// SPDX-License-Identifier: Apache-2.0
//
//===----------------------------------------------------------------------===//

// THIS FILE IS AUTOMATICALLY GENERATED by https://github.com/soto-project/soto-codegenerator.
// DO NOT EDIT.

#if canImport(FoundationEssentials)
import FoundationEssentials
#else
import Foundation
#endif
@_spi(SotoInternal) import SotoCore

extension Amp {
    // MARK: Enums

    public enum AlertManagerDefinitionStatusCode: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        /// Definition has been created/updated. Update/Deletion is disallowed until definition is ACTIVE and workspace status is ACTIVE.
        case active = "ACTIVE"
        /// Definition is being created. Update/Deletion is disallowed until definition is ACTIVE and workspace status is ACTIVE.
        case creating = "CREATING"
        /// Definition creation failed.
        case creationFailed = "CREATION_FAILED"
        /// Definition is being deleting. Update/Deletion is disallowed until definition is ACTIVE and workspace status is ACTIVE.
        case deleting = "DELETING"
        /// Definition update failed.
        case updateFailed = "UPDATE_FAILED"
        /// Definition is being updated. Update/Deletion is disallowed until definition is ACTIVE and workspace status is ACTIVE.
        case updating = "UPDATING"
        public var description: String { return self.rawValue }
    }

    public enum LoggingConfigurationStatusCode: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        /// Logging configuration has been created/updated. Update/Deletion is disallowed until logging configuration is ACTIVE and workspace status is ACTIVE.
        case active = "ACTIVE"
        /// Logging configuration is being created. Update/Deletion is disallowed until logging configuration is ACTIVE and workspace status is ACTIVE.
        case creating = "CREATING"
        /// Logging configuration creation failed.
        case creationFailed = "CREATION_FAILED"
        /// Logging configuration is being deleting. Update/Deletion is disallowed until logging configuration is ACTIVE and workspace status is ACTIVE.
        case deleting = "DELETING"
        /// Logging configuration update failed.
        case updateFailed = "UPDATE_FAILED"
        /// Logging configuration is being updated. Update/Deletion is disallowed until logging configuration is ACTIVE and workspace status is ACTIVE.
        case updating = "UPDATING"
        public var description: String { return self.rawValue }
    }

    public enum RuleGroupsNamespaceStatusCode: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        /// Namespace has been created/updated. Update/Deletion is disallowed until namespace is ACTIVE and workspace status is ACTIVE.
        case active = "ACTIVE"
        /// Namespace is being created. Update/Deletion is disallowed until namespace is ACTIVE and workspace status is ACTIVE.
        case creating = "CREATING"
        /// Namespace creation failed.
        case creationFailed = "CREATION_FAILED"
        /// Namespace is being deleting. Update/Deletion is disallowed until namespace is ACTIVE and workspace status is ACTIVE.
        case deleting = "DELETING"
        /// Namespace update failed.
        case updateFailed = "UPDATE_FAILED"
        /// Namespace is being updated. Update/Deletion is disallowed until namespace is ACTIVE and workspace status is ACTIVE.
        case updating = "UPDATING"
        public var description: String { return self.rawValue }
    }

    public enum ScraperStatusCode: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        /// Scraper has been created and is usable.
        case active = "ACTIVE"
        /// Scraper is being created. Deletion is disallowed until status is ACTIVE.
        case creating = "CREATING"
        /// Scraper creation failed.
        case creationFailed = "CREATION_FAILED"
        /// Scraper is being deleted. Deletions are allowed only when status is ACTIVE.
        case deleting = "DELETING"
        /// Scraper deletion failed.
        case deletionFailed = "DELETION_FAILED"
        /// Scraper update failed.
        case updateFailed = "UPDATE_FAILED"
        /// Scraper is being updated. Deletion is disallowed until status is ACTIVE.
        case updating = "UPDATING"
        public var description: String { return self.rawValue }
    }

    public enum ValidationExceptionReason: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case cannotParse = "CANNOT_PARSE"
        case fieldValidationFailed = "FIELD_VALIDATION_FAILED"
        case other = "OTHER"
        case unknownOperation = "UNKNOWN_OPERATION"
        public var description: String { return self.rawValue }
    }

    public enum WorkspaceStatusCode: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        /// Workspace has been created and is usable.
        case active = "ACTIVE"
        /// Workspace is being created. Deletion is disallowed until status is ACTIVE.
        case creating = "CREATING"
        /// Workspace creation failed. Refer to WorkspaceStatus.failureReason for more details.
        case creationFailed = "CREATION_FAILED"
        /// Workspace is being deleted. Deletions are allowed only when status is ACTIVE.
        case deleting = "DELETING"
        /// Workspace is being updated. Updates are allowed only when status is ACTIVE.
        case updating = "UPDATING"
        public var description: String { return self.rawValue }
    }

    // MARK: Shapes

    public struct AlertManagerDefinitionDescription: AWSDecodableShape {
        /// The date and time that the alert manager definition was created.
        public let createdAt: Date
        /// The actual alert manager definition. For details about the alert manager definition, see AlertManagedDefinitionData.
        public let data: AWSBase64Data
        /// The date and time that the alert manager definition was most recently changed.
        public let modifiedAt: Date
        /// A structure that displays the current status of the alert manager definition..
        public let status: AlertManagerDefinitionStatus

        @inlinable
        public init(createdAt: Date, data: AWSBase64Data, modifiedAt: Date, status: AlertManagerDefinitionStatus) {
            self.createdAt = createdAt
            self.data = data
            self.modifiedAt = modifiedAt
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case createdAt = "createdAt"
            case data = "data"
            case modifiedAt = "modifiedAt"
            case status = "status"
        }
    }

    public struct AlertManagerDefinitionStatus: AWSDecodableShape {
        /// The current status of the alert manager.
        public let statusCode: AlertManagerDefinitionStatusCode
        /// If there is a failure, the reason for the failure.
        public let statusReason: String?

        @inlinable
        public init(statusCode: AlertManagerDefinitionStatusCode, statusReason: String? = nil) {
            self.statusCode = statusCode
            self.statusReason = statusReason
        }

        private enum CodingKeys: String, CodingKey {
            case statusCode = "statusCode"
            case statusReason = "statusReason"
        }
    }

    public struct AmpConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// ARN of the Amazon Managed Service for Prometheus workspace.
        public let workspaceArn: String

        @inlinable
        public init(workspaceArn: String) {
            self.workspaceArn = workspaceArn
        }

        public func validate(name: String) throws {
            try self.validate(self.workspaceArn, name: "workspaceArn", parent: name, pattern: "^arn:aws[-a-z]*:aps:[-a-z0-9]+:[0-9]{12}:workspace/.+$")
        }

        private enum CodingKeys: String, CodingKey {
            case workspaceArn = "workspaceArn"
        }
    }

    public struct ConflictException: AWSErrorShape {
        /// Description of the error.
        public let message: String
        /// Identifier of the resource affected.
        public let resourceId: String
        /// Type of the resource affected.
        public let resourceType: String

        @inlinable
        public init(message: String, resourceId: String, resourceType: String) {
            self.message = message
            self.resourceId = resourceId
            self.resourceType = resourceType
        }

        private enum CodingKeys: String, CodingKey {
            case message = "message"
            case resourceId = "resourceId"
            case resourceType = "resourceType"
        }
    }

    public struct CreateAlertManagerDefinitionRequest: AWSEncodableShape {
        /// A unique identifier that you can provide to ensure the idempotency of the request. Case-sensitive.
        public let clientToken: String?
        /// The alert manager definition to add. A base64-encoded version of the YAML alert manager definition file. For details about the alert manager definition, see AlertManagedDefinitionData.
        public let data: AWSBase64Data
        /// The ID of the workspace to add the alert manager definition to.
        public let workspaceId: String

        @inlinable
        public init(clientToken: String? = CreateAlertManagerDefinitionRequest.idempotencyToken(), data: AWSBase64Data, workspaceId: String) {
            self.clientToken = clientToken
            self.data = data
            self.workspaceId = workspaceId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.clientToken, forKey: .clientToken)
            try container.encode(self.data, forKey: .data)
            request.encodePath(self.workspaceId, key: "workspaceId")
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 64)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "^[!-~]+$")
            try self.validate(self.workspaceId, name: "workspaceId", parent: name, max: 64)
            try self.validate(self.workspaceId, name: "workspaceId", parent: name, min: 1)
            try self.validate(self.workspaceId, name: "workspaceId", parent: name, pattern: "[0-9A-Za-z][-.0-9A-Z_a-z]*")
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "clientToken"
            case data = "data"
        }
    }

    public struct CreateAlertManagerDefinitionResponse: AWSDecodableShape {
        /// A structure that displays the current status of the alert manager definition.
        public let status: AlertManagerDefinitionStatus

        @inlinable
        public init(status: AlertManagerDefinitionStatus) {
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case status = "status"
        }
    }

    public struct CreateLoggingConfigurationRequest: AWSEncodableShape {
        /// A unique identifier that you can provide to ensure the idempotency of the request. Case-sensitive.
        public let clientToken: String?
        /// The ARN of the CloudWatch log group to which the vended log data will be published. This log group must exist prior to calling this operation.
        public let logGroupArn: String
        /// The ID of the workspace to create the logging configuration for.
        public let workspaceId: String

        @inlinable
        public init(clientToken: String? = CreateLoggingConfigurationRequest.idempotencyToken(), logGroupArn: String, workspaceId: String) {
            self.clientToken = clientToken
            self.logGroupArn = logGroupArn
            self.workspaceId = workspaceId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.clientToken, forKey: .clientToken)
            try container.encode(self.logGroupArn, forKey: .logGroupArn)
            request.encodePath(self.workspaceId, key: "workspaceId")
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 64)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "^[!-~]+$")
            try self.validate(self.logGroupArn, name: "logGroupArn", parent: name, pattern: "^arn:aws[-a-z]*:logs:[-a-z0-9]+:[0-9]{12}:log-group:[A-Za-z0-9\\.\\-\\_\\#/]{1,512}\\:\\*$")
            try self.validate(self.workspaceId, name: "workspaceId", parent: name, max: 64)
            try self.validate(self.workspaceId, name: "workspaceId", parent: name, min: 1)
            try self.validate(self.workspaceId, name: "workspaceId", parent: name, pattern: "[0-9A-Za-z][-.0-9A-Z_a-z]*")
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "clientToken"
            case logGroupArn = "logGroupArn"
        }
    }

    public struct CreateLoggingConfigurationResponse: AWSDecodableShape {
        /// A structure that displays the current status of the logging configuration.
        public let status: LoggingConfigurationStatus

        @inlinable
        public init(status: LoggingConfigurationStatus) {
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case status = "status"
        }
    }

    public struct CreateRuleGroupsNamespaceRequest: AWSEncodableShape {
        /// A unique identifier that you can provide to ensure the idempotency of the request. Case-sensitive.
        public let clientToken: String?
        /// The rules file to use in the new namespace. Contains the base64-encoded version of the YAML rules file. For details about the rule groups namespace structure, see RuleGroupsNamespaceData.
        public let data: AWSBase64Data
        /// The name for the new rule groups namespace.
        public let name: String
        /// The list of tag keys and values to associate with the rule groups namespace.
        public let tags: [String: String]?
        /// The ID of the workspace to add the rule groups namespace.
        public let workspaceId: String

        @inlinable
        public init(clientToken: String? = CreateRuleGroupsNamespaceRequest.idempotencyToken(), data: AWSBase64Data, name: String, tags: [String: String]? = nil, workspaceId: String) {
            self.clientToken = clientToken
            self.data = data
            self.name = name
            self.tags = tags
            self.workspaceId = workspaceId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.clientToken, forKey: .clientToken)
            try container.encode(self.data, forKey: .data)
            try container.encode(self.name, forKey: .name)
            try container.encodeIfPresent(self.tags, forKey: .tags)
            request.encodePath(self.workspaceId, key: "workspaceId")
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 64)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "^[!-~]+$")
            try self.validate(self.name, name: "name", parent: name, max: 64)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "[0-9A-Za-z][-.0-9A-Z_a-z]*")
            try self.tags?.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.key, name: "tags.key", parent: name, pattern: "^([\\p{L}\\p{Z}\\p{N}_.:/=+\\-@]*)$")
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, pattern: "^([\\p{L}\\p{Z}\\p{N}_.:/=+\\-@]*)$")
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 50)
            try self.validate(self.workspaceId, name: "workspaceId", parent: name, max: 64)
            try self.validate(self.workspaceId, name: "workspaceId", parent: name, min: 1)
            try self.validate(self.workspaceId, name: "workspaceId", parent: name, pattern: "[0-9A-Za-z][-.0-9A-Z_a-z]*")
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "clientToken"
            case data = "data"
            case name = "name"
            case tags = "tags"
        }
    }

    public struct CreateRuleGroupsNamespaceResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the new rule groups namespace.
        public let arn: String
        /// The name of the new rule groups namespace.
        public let name: String
        /// A structure that returns the current status of the rule groups namespace.
        public let status: RuleGroupsNamespaceStatus
        /// The list of tag keys and values that are associated with the namespace.
        public let tags: [String: String]?

        @inlinable
        public init(arn: String, name: String, status: RuleGroupsNamespaceStatus, tags: [String: String]? = nil) {
            self.arn = arn
            self.name = name
            self.status = status
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case name = "name"
            case status = "status"
            case tags = "tags"
        }
    }

    public struct CreateScraperRequest: AWSEncodableShape {
        /// (optional) An alias to associate with the scraper. This is for your use, and does not need to be unique.
        public let alias: String?
        /// (Optional) A unique, case-sensitive identifier that you can provide to ensure the idempotency of the request.
        public let clientToken: String?
        /// The Amazon Managed Service for Prometheus workspace to send metrics to.
        public let destination: Destination
        /// The scraper role configuration for the workspace.
        public let roleConfiguration: RoleConfiguration?
        /// The configuration file to use in the new scraper. For more information, see Scraper configuration in the Amazon Managed Service for Prometheus User  Guide.
        public let scrapeConfiguration: ScrapeConfiguration
        /// The Amazon EKS cluster from which the scraper will collect metrics.
        public let source: Source
        /// (Optional) The list of tag keys and values to associate with the scraper.
        public let tags: [String: String]?

        @inlinable
        public init(alias: String? = nil, clientToken: String? = CreateScraperRequest.idempotencyToken(), destination: Destination, roleConfiguration: RoleConfiguration? = nil, scrapeConfiguration: ScrapeConfiguration, source: Source, tags: [String: String]? = nil) {
            self.alias = alias
            self.clientToken = clientToken
            self.destination = destination
            self.roleConfiguration = roleConfiguration
            self.scrapeConfiguration = scrapeConfiguration
            self.source = source
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.validate(self.alias, name: "alias", parent: name, max: 100)
            try self.validate(self.alias, name: "alias", parent: name, min: 1)
            try self.validate(self.alias, name: "alias", parent: name, pattern: "^[0-9A-Za-z][-.0-9A-Z_a-z]*$")
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 64)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "^[!-~]+$")
            try self.destination.validate(name: "\(name).destination")
            try self.roleConfiguration?.validate(name: "\(name).roleConfiguration")
            try self.source.validate(name: "\(name).source")
            try self.tags?.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.key, name: "tags.key", parent: name, pattern: "^([\\p{L}\\p{Z}\\p{N}_.:/=+\\-@]*)$")
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, pattern: "^([\\p{L}\\p{Z}\\p{N}_.:/=+\\-@]*)$")
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 50)
        }

        private enum CodingKeys: String, CodingKey {
            case alias = "alias"
            case clientToken = "clientToken"
            case destination = "destination"
            case roleConfiguration = "roleConfiguration"
            case scrapeConfiguration = "scrapeConfiguration"
            case source = "source"
            case tags = "tags"
        }
    }

    public struct CreateScraperResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the new scraper.
        public let arn: String
        /// The ID of the new scraper.
        public let scraperId: String
        /// A structure that displays the current status of the scraper.
        public let status: ScraperStatus
        /// The list of tag keys and values that are associated with the scraper.
        public let tags: [String: String]?

        @inlinable
        public init(arn: String, scraperId: String, status: ScraperStatus, tags: [String: String]? = nil) {
            self.arn = arn
            self.scraperId = scraperId
            self.status = status
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case scraperId = "scraperId"
            case status = "status"
            case tags = "tags"
        }
    }

    public struct CreateWorkspaceRequest: AWSEncodableShape {
        /// An alias that you assign to this workspace to help you identify it. It does not need to be unique. Blank spaces at the beginning or end of the alias that you specify will be trimmed from the value used.
        public let alias: String?
        /// A unique identifier that you can provide to ensure the idempotency of the request. Case-sensitive.
        public let clientToken: String?
        /// (optional) The ARN for a customer managed KMS key to use for  encrypting data within your workspace. For more information about using your own key in your workspace, see Encryption at rest in the Amazon Managed Service for Prometheus User  Guide.
        public let kmsKeyArn: String?
        /// The list of tag keys and values to associate with the workspace.
        public let tags: [String: String]?

        @inlinable
        public init(alias: String? = nil, clientToken: String? = CreateWorkspaceRequest.idempotencyToken(), kmsKeyArn: String? = nil, tags: [String: String]? = nil) {
            self.alias = alias
            self.clientToken = clientToken
            self.kmsKeyArn = kmsKeyArn
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.validate(self.alias, name: "alias", parent: name, max: 100)
            try self.validate(self.alias, name: "alias", parent: name, min: 1)
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 64)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "^[!-~]+$")
            try self.validate(self.kmsKeyArn, name: "kmsKeyArn", parent: name, max: 2048)
            try self.validate(self.kmsKeyArn, name: "kmsKeyArn", parent: name, min: 20)
            try self.validate(self.kmsKeyArn, name: "kmsKeyArn", parent: name, pattern: "^arn:aws[-a-z]*:kms:[-a-z0-9]+:[0-9]{12}:key/[-a-f0-9]+$")
            try self.tags?.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.key, name: "tags.key", parent: name, pattern: "^([\\p{L}\\p{Z}\\p{N}_.:/=+\\-@]*)$")
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, pattern: "^([\\p{L}\\p{Z}\\p{N}_.:/=+\\-@]*)$")
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 50)
        }

        private enum CodingKeys: String, CodingKey {
            case alias = "alias"
            case clientToken = "clientToken"
            case kmsKeyArn = "kmsKeyArn"
            case tags = "tags"
        }
    }

    public struct CreateWorkspaceResponse: AWSDecodableShape {
        /// The ARN for the new workspace.
        public let arn: String
        /// (optional) If the workspace was created with a customer managed KMS  key, the ARN for the key used.
        public let kmsKeyArn: String?
        /// The current status of the new workspace. Immediately after you create the workspace, the status is usually CREATING.
        public let status: WorkspaceStatus
        /// The list of tag keys and values that are associated with the workspace.
        public let tags: [String: String]?
        /// The unique ID for the new workspace.
        public let workspaceId: String

        @inlinable
        public init(arn: String, kmsKeyArn: String? = nil, status: WorkspaceStatus, tags: [String: String]? = nil, workspaceId: String) {
            self.arn = arn
            self.kmsKeyArn = kmsKeyArn
            self.status = status
            self.tags = tags
            self.workspaceId = workspaceId
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case kmsKeyArn = "kmsKeyArn"
            case status = "status"
            case tags = "tags"
            case workspaceId = "workspaceId"
        }
    }

    public struct DeleteAlertManagerDefinitionRequest: AWSEncodableShape {
        /// A unique identifier that you can provide to ensure the idempotency of the request. Case-sensitive.
        public let clientToken: String?
        /// The ID of the workspace to delete the alert manager definition from.
        public let workspaceId: String

        @inlinable
        public init(clientToken: String? = DeleteAlertManagerDefinitionRequest.idempotencyToken(), workspaceId: String) {
            self.clientToken = clientToken
            self.workspaceId = workspaceId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.clientToken, key: "clientToken")
            request.encodePath(self.workspaceId, key: "workspaceId")
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 64)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "^[!-~]+$")
            try self.validate(self.workspaceId, name: "workspaceId", parent: name, max: 64)
            try self.validate(self.workspaceId, name: "workspaceId", parent: name, min: 1)
            try self.validate(self.workspaceId, name: "workspaceId", parent: name, pattern: "[0-9A-Za-z][-.0-9A-Z_a-z]*")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteLoggingConfigurationRequest: AWSEncodableShape {
        /// A unique identifier that you can provide to ensure the idempotency of the request. Case-sensitive.
        public let clientToken: String?
        /// The ID of the workspace containing the logging configuration to delete.
        public let workspaceId: String

        @inlinable
        public init(clientToken: String? = DeleteLoggingConfigurationRequest.idempotencyToken(), workspaceId: String) {
            self.clientToken = clientToken
            self.workspaceId = workspaceId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.clientToken, key: "clientToken")
            request.encodePath(self.workspaceId, key: "workspaceId")
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 64)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "^[!-~]+$")
            try self.validate(self.workspaceId, name: "workspaceId", parent: name, max: 64)
            try self.validate(self.workspaceId, name: "workspaceId", parent: name, min: 1)
            try self.validate(self.workspaceId, name: "workspaceId", parent: name, pattern: "[0-9A-Za-z][-.0-9A-Z_a-z]*")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteRuleGroupsNamespaceRequest: AWSEncodableShape {
        /// A unique identifier that you can provide to ensure the idempotency of the request. Case-sensitive.
        public let clientToken: String?
        /// The name of the rule groups namespace to delete.
        public let name: String
        /// The ID of the workspace containing the rule groups namespace and definition to delete.
        public let workspaceId: String

        @inlinable
        public init(clientToken: String? = DeleteRuleGroupsNamespaceRequest.idempotencyToken(), name: String, workspaceId: String) {
            self.clientToken = clientToken
            self.name = name
            self.workspaceId = workspaceId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.clientToken, key: "clientToken")
            request.encodePath(self.name, key: "name")
            request.encodePath(self.workspaceId, key: "workspaceId")
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 64)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "^[!-~]+$")
            try self.validate(self.name, name: "name", parent: name, max: 64)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "[0-9A-Za-z][-.0-9A-Z_a-z]*")
            try self.validate(self.workspaceId, name: "workspaceId", parent: name, max: 64)
            try self.validate(self.workspaceId, name: "workspaceId", parent: name, min: 1)
            try self.validate(self.workspaceId, name: "workspaceId", parent: name, pattern: "[0-9A-Za-z][-.0-9A-Z_a-z]*")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteScraperRequest: AWSEncodableShape {
        /// (Optional) A unique, case-sensitive identifier that you can provide to ensure the  idempotency of the request.
        public let clientToken: String?
        /// The ID of the scraper to delete.
        public let scraperId: String

        @inlinable
        public init(clientToken: String? = DeleteScraperRequest.idempotencyToken(), scraperId: String) {
            self.clientToken = clientToken
            self.scraperId = scraperId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.clientToken, key: "clientToken")
            request.encodePath(self.scraperId, key: "scraperId")
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 64)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "^[!-~]+$")
            try self.validate(self.scraperId, name: "scraperId", parent: name, max: 64)
            try self.validate(self.scraperId, name: "scraperId", parent: name, min: 1)
            try self.validate(self.scraperId, name: "scraperId", parent: name, pattern: "^[0-9A-Za-z][-.0-9A-Z_a-z]*$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteScraperResponse: AWSDecodableShape {
        /// The ID of the scraper to delete.
        public let scraperId: String
        /// The current status of the scraper.
        public let status: ScraperStatus

        @inlinable
        public init(scraperId: String, status: ScraperStatus) {
            self.scraperId = scraperId
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case scraperId = "scraperId"
            case status = "status"
        }
    }

    public struct DeleteWorkspaceRequest: AWSEncodableShape {
        /// A unique identifier that you can provide to ensure the idempotency of the request. Case-sensitive.
        public let clientToken: String?
        /// The ID of the workspace to delete.
        public let workspaceId: String

        @inlinable
        public init(clientToken: String? = DeleteWorkspaceRequest.idempotencyToken(), workspaceId: String) {
            self.clientToken = clientToken
            self.workspaceId = workspaceId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.clientToken, key: "clientToken")
            request.encodePath(self.workspaceId, key: "workspaceId")
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 64)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "^[!-~]+$")
            try self.validate(self.workspaceId, name: "workspaceId", parent: name, max: 64)
            try self.validate(self.workspaceId, name: "workspaceId", parent: name, min: 1)
            try self.validate(self.workspaceId, name: "workspaceId", parent: name, pattern: "[0-9A-Za-z][-.0-9A-Z_a-z]*")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DescribeAlertManagerDefinitionRequest: AWSEncodableShape {
        /// The ID of the workspace to retrieve the alert manager definition from.
        public let workspaceId: String

        @inlinable
        public init(workspaceId: String) {
            self.workspaceId = workspaceId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.workspaceId, key: "workspaceId")
        }

        public func validate(name: String) throws {
            try self.validate(self.workspaceId, name: "workspaceId", parent: name, max: 64)
            try self.validate(self.workspaceId, name: "workspaceId", parent: name, min: 1)
            try self.validate(self.workspaceId, name: "workspaceId", parent: name, pattern: "[0-9A-Za-z][-.0-9A-Z_a-z]*")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DescribeAlertManagerDefinitionResponse: AWSDecodableShape {
        /// The alert manager definition.
        public let alertManagerDefinition: AlertManagerDefinitionDescription

        @inlinable
        public init(alertManagerDefinition: AlertManagerDefinitionDescription) {
            self.alertManagerDefinition = alertManagerDefinition
        }

        private enum CodingKeys: String, CodingKey {
            case alertManagerDefinition = "alertManagerDefinition"
        }
    }

    public struct DescribeLoggingConfigurationRequest: AWSEncodableShape {
        /// The ID of the workspace to describe the logging configuration for.
        public let workspaceId: String

        @inlinable
        public init(workspaceId: String) {
            self.workspaceId = workspaceId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.workspaceId, key: "workspaceId")
        }

        public func validate(name: String) throws {
            try self.validate(self.workspaceId, name: "workspaceId", parent: name, max: 64)
            try self.validate(self.workspaceId, name: "workspaceId", parent: name, min: 1)
            try self.validate(self.workspaceId, name: "workspaceId", parent: name, pattern: "[0-9A-Za-z][-.0-9A-Z_a-z]*")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DescribeLoggingConfigurationResponse: AWSDecodableShape {
        /// A structure that displays the information about the logging configuration.
        public let loggingConfiguration: LoggingConfigurationMetadata

        @inlinable
        public init(loggingConfiguration: LoggingConfigurationMetadata) {
            self.loggingConfiguration = loggingConfiguration
        }

        private enum CodingKeys: String, CodingKey {
            case loggingConfiguration = "loggingConfiguration"
        }
    }

    public struct DescribeRuleGroupsNamespaceRequest: AWSEncodableShape {
        /// The name of the rule groups namespace that you want information for.
        public let name: String
        /// The ID of the workspace containing the rule groups namespace.
        public let workspaceId: String

        @inlinable
        public init(name: String, workspaceId: String) {
            self.name = name
            self.workspaceId = workspaceId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.name, key: "name")
            request.encodePath(self.workspaceId, key: "workspaceId")
        }

        public func validate(name: String) throws {
            try self.validate(self.name, name: "name", parent: name, max: 64)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "[0-9A-Za-z][-.0-9A-Z_a-z]*")
            try self.validate(self.workspaceId, name: "workspaceId", parent: name, max: 64)
            try self.validate(self.workspaceId, name: "workspaceId", parent: name, min: 1)
            try self.validate(self.workspaceId, name: "workspaceId", parent: name, pattern: "[0-9A-Za-z][-.0-9A-Z_a-z]*")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DescribeRuleGroupsNamespaceResponse: AWSDecodableShape {
        /// The information about the rule groups namespace.
        public let ruleGroupsNamespace: RuleGroupsNamespaceDescription

        @inlinable
        public init(ruleGroupsNamespace: RuleGroupsNamespaceDescription) {
            self.ruleGroupsNamespace = ruleGroupsNamespace
        }

        private enum CodingKeys: String, CodingKey {
            case ruleGroupsNamespace = "ruleGroupsNamespace"
        }
    }

    public struct DescribeScraperRequest: AWSEncodableShape {
        /// The ID of the scraper to describe.
        public let scraperId: String

        @inlinable
        public init(scraperId: String) {
            self.scraperId = scraperId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.scraperId, key: "scraperId")
        }

        public func validate(name: String) throws {
            try self.validate(self.scraperId, name: "scraperId", parent: name, max: 64)
            try self.validate(self.scraperId, name: "scraperId", parent: name, min: 1)
            try self.validate(self.scraperId, name: "scraperId", parent: name, pattern: "^[0-9A-Za-z][-.0-9A-Z_a-z]*$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DescribeScraperResponse: AWSDecodableShape {
        /// Contains details about the scraper.
        public let scraper: ScraperDescription

        @inlinable
        public init(scraper: ScraperDescription) {
            self.scraper = scraper
        }

        private enum CodingKeys: String, CodingKey {
            case scraper = "scraper"
        }
    }

    public struct DescribeWorkspaceRequest: AWSEncodableShape {
        /// The ID of the workspace to describe.
        public let workspaceId: String

        @inlinable
        public init(workspaceId: String) {
            self.workspaceId = workspaceId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.workspaceId, key: "workspaceId")
        }

        public func validate(name: String) throws {
            try self.validate(self.workspaceId, name: "workspaceId", parent: name, max: 64)
            try self.validate(self.workspaceId, name: "workspaceId", parent: name, min: 1)
            try self.validate(self.workspaceId, name: "workspaceId", parent: name, pattern: "[0-9A-Za-z][-.0-9A-Z_a-z]*")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DescribeWorkspaceResponse: AWSDecodableShape {
        /// A structure that contains details about the workspace.
        public let workspace: WorkspaceDescription

        @inlinable
        public init(workspace: WorkspaceDescription) {
            self.workspace = workspace
        }

        private enum CodingKeys: String, CodingKey {
            case workspace = "workspace"
        }
    }

    public struct EksConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// ARN of the Amazon EKS cluster.
        public let clusterArn: String
        /// A list of the security group IDs for the Amazon EKS cluster VPC configuration.
        public let securityGroupIds: [String]?
        /// A list of subnet IDs for the Amazon EKS cluster VPC configuration.
        public let subnetIds: [String]

        @inlinable
        public init(clusterArn: String, securityGroupIds: [String]? = nil, subnetIds: [String]) {
            self.clusterArn = clusterArn
            self.securityGroupIds = securityGroupIds
            self.subnetIds = subnetIds
        }

        public func validate(name: String) throws {
            try self.validate(self.clusterArn, name: "clusterArn", parent: name, pattern: "^arn:aws[-a-z]*:eks:[-a-z0-9]+:[0-9]{12}:cluster/.+$")
            try self.securityGroupIds?.forEach {
                try validate($0, name: "securityGroupIds[]", parent: name, max: 255)
                try validate($0, name: "securityGroupIds[]", parent: name, pattern: "^sg-[0-9a-z]+$")
            }
            try self.validate(self.securityGroupIds, name: "securityGroupIds", parent: name, max: 5)
            try self.validate(self.securityGroupIds, name: "securityGroupIds", parent: name, min: 1)
            try self.subnetIds.forEach {
                try validate($0, name: "subnetIds[]", parent: name, max: 255)
                try validate($0, name: "subnetIds[]", parent: name, pattern: "^subnet-[0-9a-z]+$")
            }
            try self.validate(self.subnetIds, name: "subnetIds", parent: name, max: 5)
            try self.validate(self.subnetIds, name: "subnetIds", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case clusterArn = "clusterArn"
            case securityGroupIds = "securityGroupIds"
            case subnetIds = "subnetIds"
        }
    }

    public struct GetDefaultScraperConfigurationRequest: AWSEncodableShape {
        public init() {}
    }

    public struct GetDefaultScraperConfigurationResponse: AWSDecodableShape {
        /// The configuration file. Base 64 encoded.  For more information, see Scraper configurationin the Amazon Managed Service for Prometheus User  Guide.
        public let configuration: AWSBase64Data

        @inlinable
        public init(configuration: AWSBase64Data) {
            self.configuration = configuration
        }

        private enum CodingKeys: String, CodingKey {
            case configuration = "configuration"
        }
    }

    public struct InternalServerException: AWSErrorShape {
        /// Description of the error.
        public let message: String
        /// Advice to clients on when the call can be safely retried.
        public let retryAfterSeconds: Int?

        @inlinable
        public init(message: String, retryAfterSeconds: Int? = nil) {
            self.message = message
            self.retryAfterSeconds = retryAfterSeconds
        }

        public init(from decoder: Decoder) throws {
            let response = decoder.userInfo[.awsResponse]! as! ResponseDecodingContainer
            let container = try decoder.container(keyedBy: CodingKeys.self)
            self.message = try container.decode(String.self, forKey: .message)
            self.retryAfterSeconds = try response.decodeHeaderIfPresent(Int.self, key: "Retry-After")
        }

        private enum CodingKeys: String, CodingKey {
            case message = "message"
        }
    }

    public struct ListRuleGroupsNamespacesRequest: AWSEncodableShape {
        /// The maximum number of results to return. The default is 100.
        public let maxResults: Int?
        /// Use this parameter to filter the rule groups namespaces that are returned. Only the namespaces with names that begin with the value that you specify are returned.
        public let name: String?
        /// The token for the next set of items to return. You receive this token from a previous call, and use it to get the next page of results. The other parameters must be the same as the initial call. For example, if your initial request has maxResults of 10, and there are 12 rule groups namespaces to return, then your initial request will return 10 and a nextToken. Using the next token in a subsequent call will return the remaining 2 namespaces.
        public let nextToken: String?
        /// The ID of the workspace containing the rule groups namespaces.
        public let workspaceId: String

        @inlinable
        public init(maxResults: Int? = nil, name: String? = nil, nextToken: String? = nil, workspaceId: String) {
            self.maxResults = maxResults
            self.name = name
            self.nextToken = nextToken
            self.workspaceId = workspaceId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.name, key: "name")
            request.encodeQuery(self.nextToken, key: "nextToken")
            request.encodePath(self.workspaceId, key: "workspaceId")
        }

        public func validate(name: String) throws {
            try self.validate(self.name, name: "name", parent: name, max: 64)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "[0-9A-Za-z][-.0-9A-Z_a-z]*")
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 1000)
            try self.validate(self.workspaceId, name: "workspaceId", parent: name, max: 64)
            try self.validate(self.workspaceId, name: "workspaceId", parent: name, min: 1)
            try self.validate(self.workspaceId, name: "workspaceId", parent: name, pattern: "[0-9A-Za-z][-.0-9A-Z_a-z]*")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListRuleGroupsNamespacesResponse: AWSDecodableShape {
        /// A token indicating that there are more results to retrieve. You can use this token as part of your next ListRuleGroupsNamespaces request to retrieve those results.
        public let nextToken: String?
        /// The returned list of rule groups namespaces.
        public let ruleGroupsNamespaces: [RuleGroupsNamespaceSummary]

        @inlinable
        public init(nextToken: String? = nil, ruleGroupsNamespaces: [RuleGroupsNamespaceSummary]) {
            self.nextToken = nextToken
            self.ruleGroupsNamespaces = ruleGroupsNamespaces
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "nextToken"
            case ruleGroupsNamespaces = "ruleGroupsNamespaces"
        }
    }

    public struct ListScrapersRequest: AWSEncodableShape {
        /// (Optional) A list of key-value pairs to filter the list of scrapers returned. Keys include status, sourceArn,  destinationArn, and alias. Filters on the same key are OR'd together, and filters on different keys are AND'd together. For example,  status=ACTIVE&amp;status=CREATING&amp;alias=Test, will return all scrapers that have the alias Test, and are either in status ACTIVE or CREATING. To find all active scrapers that are sending metrics to a specific Amazon Managed Service for Prometheus workspace, you would use the ARN of the workspace in a query:  status=ACTIVE&amp;destinationArn=arn:aws:aps:us-east-1:123456789012:workspace/ws-example1-1234-abcd-56ef-123456789012  If this is included, it filters the results to only the scrapers that match  the filter.
        public let filters: [String: [String]]?
        /// Optional) The maximum number of scrapers to return in one ListScrapers operation. The range is 1-1000. If you omit this parameter, the default of 100 is used.
        public let maxResults: Int?
        /// (Optional) The token for the next set of items to return. (You received this token from a previous call.)
        public let nextToken: String?

        @inlinable
        public init(filters: [String: [String]]? = nil, maxResults: Int? = nil, nextToken: String? = nil) {
            self.filters = filters
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.filters)
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
        }

        public func validate(name: String) throws {
            try self.filters?.forEach {
                try validate($0.key, name: "filters.key", parent: name, max: 256)
                try validate($0.key, name: "filters.key", parent: name, min: 1)
                try validate($0.value, name: "filters[\"\($0.key)\"]", parent: name, max: 20)
                try validate($0.value, name: "filters[\"\($0.key)\"]", parent: name, min: 1)
            }
            try self.validate(self.filters, name: "filters", parent: name, max: 4)
            try self.validate(self.filters, name: "filters", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 1000)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListScrapersResponse: AWSDecodableShape {
        /// A token indicating that there are more results to retrieve. You can use this token as part of your next ListScrapers operation to retrieve those results.
        public let nextToken: String?
        /// A list of ScraperSummary structures giving information about scrapers in the account that match the filters provided.
        public let scrapers: [ScraperSummary]

        @inlinable
        public init(nextToken: String? = nil, scrapers: [ScraperSummary]) {
            self.nextToken = nextToken
            self.scrapers = scrapers
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "nextToken"
            case scrapers = "scrapers"
        }
    }

    public struct ListTagsForResourceRequest: AWSEncodableShape {
        /// The ARN of the resource to list tages for. Must be a workspace, scraper, or rule groups namespace resource.
        public let resourceArn: String

        @inlinable
        public init(resourceArn: String) {
            self.resourceArn = resourceArn
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.resourceArn, key: "resourceArn")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListTagsForResourceResponse: AWSDecodableShape {
        /// The list of tag keys and values associated with the resource.
        public let tags: [String: String]?

        @inlinable
        public init(tags: [String: String]? = nil) {
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case tags = "tags"
        }
    }

    public struct ListWorkspacesRequest: AWSEncodableShape {
        /// If this is included, it filters the results to only the workspaces with names that start with the value that you specify here. Amazon Managed Service for Prometheus will automatically strip any blank spaces from the beginning and end of the alias that you specify.
        public let alias: String?
        /// The maximum number of workspaces to return per request. The default is 100.
        public let maxResults: Int?
        /// The token for the next set of items to return. You receive this token from a previous call, and use it to get the next page of results. The other parameters must be the same as the initial call. For example, if your initial request has maxResults of 10, and there are 12 workspaces to return, then your initial request will return 10 and a nextToken. Using the next token in a subsequent call will return the remaining 2 workspaces.
        public let nextToken: String?

        @inlinable
        public init(alias: String? = nil, maxResults: Int? = nil, nextToken: String? = nil) {
            self.alias = alias
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.alias, key: "alias")
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
        }

        public func validate(name: String) throws {
            try self.validate(self.alias, name: "alias", parent: name, max: 100)
            try self.validate(self.alias, name: "alias", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 1000)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListWorkspacesResponse: AWSDecodableShape {
        /// A token indicating that there are more results to retrieve. You can use this token as part of your next ListWorkspaces request to retrieve those results.
        public let nextToken: String?
        /// An array of WorkspaceSummary structures containing information about the workspaces requested.
        public let workspaces: [WorkspaceSummary]

        @inlinable
        public init(nextToken: String? = nil, workspaces: [WorkspaceSummary]) {
            self.nextToken = nextToken
            self.workspaces = workspaces
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "nextToken"
            case workspaces = "workspaces"
        }
    }

    public struct LoggingConfigurationMetadata: AWSDecodableShape {
        /// The date and time that the logging configuration was created.
        public let createdAt: Date
        /// The ARN of the CloudWatch log group to which the vended log data will be published.
        public let logGroupArn: String
        /// The date and time that the logging configuration was most recently changed.
        public let modifiedAt: Date
        /// The current status of the logging configuration.
        public let status: LoggingConfigurationStatus
        /// The ID of the workspace the logging configuration is for.
        public let workspace: String

        @inlinable
        public init(createdAt: Date, logGroupArn: String, modifiedAt: Date, status: LoggingConfigurationStatus, workspace: String) {
            self.createdAt = createdAt
            self.logGroupArn = logGroupArn
            self.modifiedAt = modifiedAt
            self.status = status
            self.workspace = workspace
        }

        private enum CodingKeys: String, CodingKey {
            case createdAt = "createdAt"
            case logGroupArn = "logGroupArn"
            case modifiedAt = "modifiedAt"
            case status = "status"
            case workspace = "workspace"
        }
    }

    public struct LoggingConfigurationStatus: AWSDecodableShape {
        /// The current status of the logging configuration.
        public let statusCode: LoggingConfigurationStatusCode
        /// If failed, the reason for the failure.
        public let statusReason: String?

        @inlinable
        public init(statusCode: LoggingConfigurationStatusCode, statusReason: String? = nil) {
            self.statusCode = statusCode
            self.statusReason = statusReason
        }

        private enum CodingKeys: String, CodingKey {
            case statusCode = "statusCode"
            case statusReason = "statusReason"
        }
    }

    public struct PutAlertManagerDefinitionRequest: AWSEncodableShape {
        /// A unique identifier that you can provide to ensure the idempotency of the request. Case-sensitive.
        public let clientToken: String?
        /// The alert manager definition to use. A base64-encoded version of the YAML alert manager definition file. For details about the alert manager definition, see AlertManagedDefinitionData.
        public let data: AWSBase64Data
        /// The ID of the workspace to update the alert manager definition in.
        public let workspaceId: String

        @inlinable
        public init(clientToken: String? = PutAlertManagerDefinitionRequest.idempotencyToken(), data: AWSBase64Data, workspaceId: String) {
            self.clientToken = clientToken
            self.data = data
            self.workspaceId = workspaceId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.clientToken, forKey: .clientToken)
            try container.encode(self.data, forKey: .data)
            request.encodePath(self.workspaceId, key: "workspaceId")
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 64)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "^[!-~]+$")
            try self.validate(self.workspaceId, name: "workspaceId", parent: name, max: 64)
            try self.validate(self.workspaceId, name: "workspaceId", parent: name, min: 1)
            try self.validate(self.workspaceId, name: "workspaceId", parent: name, pattern: "[0-9A-Za-z][-.0-9A-Z_a-z]*")
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "clientToken"
            case data = "data"
        }
    }

    public struct PutAlertManagerDefinitionResponse: AWSDecodableShape {
        /// A structure that returns the current status of the alert manager definition.
        public let status: AlertManagerDefinitionStatus

        @inlinable
        public init(status: AlertManagerDefinitionStatus) {
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case status = "status"
        }
    }

    public struct PutRuleGroupsNamespaceRequest: AWSEncodableShape {
        /// A unique identifier that you can provide to ensure the idempotency of the request. Case-sensitive.
        public let clientToken: String?
        /// The new rules file to use in the namespace. A base64-encoded version of the YAML rule groups file. For details about the rule groups namespace structure, see RuleGroupsNamespaceData.
        public let data: AWSBase64Data
        /// The name of the rule groups namespace that you are updating.
        public let name: String
        /// The ID of the workspace where you are updating the rule groups namespace.
        public let workspaceId: String

        @inlinable
        public init(clientToken: String? = PutRuleGroupsNamespaceRequest.idempotencyToken(), data: AWSBase64Data, name: String, workspaceId: String) {
            self.clientToken = clientToken
            self.data = data
            self.name = name
            self.workspaceId = workspaceId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.clientToken, forKey: .clientToken)
            try container.encode(self.data, forKey: .data)
            request.encodePath(self.name, key: "name")
            request.encodePath(self.workspaceId, key: "workspaceId")
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 64)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "^[!-~]+$")
            try self.validate(self.name, name: "name", parent: name, max: 64)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "[0-9A-Za-z][-.0-9A-Z_a-z]*")
            try self.validate(self.workspaceId, name: "workspaceId", parent: name, max: 64)
            try self.validate(self.workspaceId, name: "workspaceId", parent: name, min: 1)
            try self.validate(self.workspaceId, name: "workspaceId", parent: name, pattern: "[0-9A-Za-z][-.0-9A-Z_a-z]*")
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "clientToken"
            case data = "data"
        }
    }

    public struct PutRuleGroupsNamespaceResponse: AWSDecodableShape {
        /// The ARN of the rule groups namespace.
        public let arn: String
        /// The name of the rule groups namespace that was updated.
        public let name: String
        /// A structure that includes the current status of the rule groups namespace.
        public let status: RuleGroupsNamespaceStatus
        /// The list of tag keys and values that are associated with the namespace.
        public let tags: [String: String]?

        @inlinable
        public init(arn: String, name: String, status: RuleGroupsNamespaceStatus, tags: [String: String]? = nil) {
            self.arn = arn
            self.name = name
            self.status = status
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case name = "name"
            case status = "status"
            case tags = "tags"
        }
    }

    public struct ResourceNotFoundException: AWSErrorShape {
        /// Description of the error.
        public let message: String
        /// Identifier of the resource affected.
        public let resourceId: String
        /// Type of the resource affected.
        public let resourceType: String

        @inlinable
        public init(message: String, resourceId: String, resourceType: String) {
            self.message = message
            self.resourceId = resourceId
            self.resourceType = resourceType
        }

        private enum CodingKeys: String, CodingKey {
            case message = "message"
            case resourceId = "resourceId"
            case resourceType = "resourceType"
        }
    }

    public struct RoleConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// A ARN identifying the source role configuration.
        public let sourceRoleArn: String?
        /// A ARN identifying the target role configuration.
        public let targetRoleArn: String?

        @inlinable
        public init(sourceRoleArn: String? = nil, targetRoleArn: String? = nil) {
            self.sourceRoleArn = sourceRoleArn
            self.targetRoleArn = targetRoleArn
        }

        public func validate(name: String) throws {
            try self.validate(self.sourceRoleArn, name: "sourceRoleArn", parent: name, pattern: "^arn:aws[-a-z]*:iam::[0-9]{12}:role/.+$")
            try self.validate(self.targetRoleArn, name: "targetRoleArn", parent: name, pattern: "^arn:aws[-a-z]*:iam::[0-9]{12}:role/.+$")
        }

        private enum CodingKeys: String, CodingKey {
            case sourceRoleArn = "sourceRoleArn"
            case targetRoleArn = "targetRoleArn"
        }
    }

    public struct RuleGroupsNamespaceDescription: AWSDecodableShape {
        /// The ARN of the rule groups namespace. For example,  arn:aws:aps:&lt;region&gt;:123456789012:rulegroupsnamespace/ws-example1-1234-abcd-5678-ef90abcd1234/rulesfile1.
        public let arn: String
        /// The date and time that the rule groups namespace was created.
        public let createdAt: Date
        /// The rule groups file used in the namespace. For details about the rule groups namespace structure, see RuleGroupsNamespaceData.
        public let data: AWSBase64Data
        /// The date and time that the rule groups namespace was most recently changed.
        public let modifiedAt: Date
        /// The name of the rule groups namespace.
        public let name: String
        /// The current status of the rule groups namespace.
        public let status: RuleGroupsNamespaceStatus
        /// The list of tag keys and values that are associated with the rule groups namespace.
        public let tags: [String: String]?

        @inlinable
        public init(arn: String, createdAt: Date, data: AWSBase64Data, modifiedAt: Date, name: String, status: RuleGroupsNamespaceStatus, tags: [String: String]? = nil) {
            self.arn = arn
            self.createdAt = createdAt
            self.data = data
            self.modifiedAt = modifiedAt
            self.name = name
            self.status = status
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case createdAt = "createdAt"
            case data = "data"
            case modifiedAt = "modifiedAt"
            case name = "name"
            case status = "status"
            case tags = "tags"
        }
    }

    public struct RuleGroupsNamespaceStatus: AWSDecodableShape {
        /// The current status of the namespace.
        public let statusCode: RuleGroupsNamespaceStatusCode
        /// The reason for the failure, if any.
        public let statusReason: String?

        @inlinable
        public init(statusCode: RuleGroupsNamespaceStatusCode, statusReason: String? = nil) {
            self.statusCode = statusCode
            self.statusReason = statusReason
        }

        private enum CodingKeys: String, CodingKey {
            case statusCode = "statusCode"
            case statusReason = "statusReason"
        }
    }

    public struct RuleGroupsNamespaceSummary: AWSDecodableShape {
        /// The ARN of the rule groups namespace.
        public let arn: String
        /// The date and time that the rule groups namespace was created.
        public let createdAt: Date
        /// The date and time that the rule groups namespace was most recently changed.
        public let modifiedAt: Date
        /// The name of the rule groups namespace.
        public let name: String
        /// A structure that displays the current status of the rule groups namespace.
        public let status: RuleGroupsNamespaceStatus
        /// The list of tag keys and values that are associated with the rule groups namespace.
        public let tags: [String: String]?

        @inlinable
        public init(arn: String, createdAt: Date, modifiedAt: Date, name: String, status: RuleGroupsNamespaceStatus, tags: [String: String]? = nil) {
            self.arn = arn
            self.createdAt = createdAt
            self.modifiedAt = modifiedAt
            self.name = name
            self.status = status
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case createdAt = "createdAt"
            case modifiedAt = "modifiedAt"
            case name = "name"
            case status = "status"
            case tags = "tags"
        }
    }

    public struct ScraperDescription: AWSDecodableShape {
        /// (Optional) A name associated with the scraper.
        public let alias: String?
        /// The Amazon Resource Name (ARN) of the scraper. For example,  arn:aws:aps:&lt;region&gt;:123456798012:scraper/s-example1-1234-abcd-5678-ef9012abcd34.
        public let arn: String
        /// The date and time that the scraper was created.
        public let createdAt: Date
        /// The Amazon Managed Service for Prometheus workspace the scraper sends metrics to.
        public let destination: Destination
        /// The date and time that the scraper was last modified.
        public let lastModifiedAt: Date
        /// The Amazon Resource Name (ARN) of the IAM role that provides  permissions for the scraper to discover and collect metrics on your behalf. For example, arn:aws:iam::123456789012:role/service-role/AmazonGrafanaServiceRole-12example.
        public let roleArn: String
        public let roleConfiguration: RoleConfiguration?
        /// The configuration in use by the scraper.
        public let scrapeConfiguration: ScrapeConfiguration
        /// The ID of the scraper. For example, s-example1-1234-abcd-5678-ef9012abcd34.
        public let scraperId: String
        /// The Amazon EKS cluster from which the scraper collects metrics.
        public let source: Source
        /// A structure that contains the current status of the scraper.
        public let status: ScraperStatus
        /// If there is a failure, the reason for the failure.
        public let statusReason: String?
        /// (Optional) The list of tag keys and values associated with the scraper.
        public let tags: [String: String]?

        @inlinable
        public init(alias: String? = nil, arn: String, createdAt: Date, destination: Destination, lastModifiedAt: Date, roleArn: String, roleConfiguration: RoleConfiguration? = nil, scrapeConfiguration: ScrapeConfiguration, scraperId: String, source: Source, status: ScraperStatus, statusReason: String? = nil, tags: [String: String]? = nil) {
            self.alias = alias
            self.arn = arn
            self.createdAt = createdAt
            self.destination = destination
            self.lastModifiedAt = lastModifiedAt
            self.roleArn = roleArn
            self.roleConfiguration = roleConfiguration
            self.scrapeConfiguration = scrapeConfiguration
            self.scraperId = scraperId
            self.source = source
            self.status = status
            self.statusReason = statusReason
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case alias = "alias"
            case arn = "arn"
            case createdAt = "createdAt"
            case destination = "destination"
            case lastModifiedAt = "lastModifiedAt"
            case roleArn = "roleArn"
            case roleConfiguration = "roleConfiguration"
            case scrapeConfiguration = "scrapeConfiguration"
            case scraperId = "scraperId"
            case source = "source"
            case status = "status"
            case statusReason = "statusReason"
            case tags = "tags"
        }
    }

    public struct ScraperStatus: AWSDecodableShape {
        /// The current status of the scraper.
        public let statusCode: ScraperStatusCode

        @inlinable
        public init(statusCode: ScraperStatusCode) {
            self.statusCode = statusCode
        }

        private enum CodingKeys: String, CodingKey {
            case statusCode = "statusCode"
        }
    }

    public struct ScraperSummary: AWSDecodableShape {
        /// (Optional) A name associated with the scraper.
        public let alias: String?
        /// The Amazon Resource Name (ARN) of the scraper.
        public let arn: String
        /// The date and time that the scraper was created.
        public let createdAt: Date
        /// The Amazon Managed Service for Prometheus workspace the scraper sends metrics to.
        public let destination: Destination
        /// The date and time that the scraper was last modified.
        public let lastModifiedAt: Date
        /// The Amazon Resource Name (ARN) of the IAM role that provides  permissions for the scraper to discover and collect metrics on your behalf.
        public let roleArn: String
        public let roleConfiguration: RoleConfiguration?
        /// The ID of the scraper.
        public let scraperId: String
        /// The Amazon EKS cluster from which the scraper collects metrics.
        public let source: Source
        /// A structure that contains the current status of the scraper.
        public let status: ScraperStatus
        /// If there is a failure, the reason for the failure.
        public let statusReason: String?
        /// (Optional) The list of tag keys and values associated with the scraper.
        public let tags: [String: String]?

        @inlinable
        public init(alias: String? = nil, arn: String, createdAt: Date, destination: Destination, lastModifiedAt: Date, roleArn: String, roleConfiguration: RoleConfiguration? = nil, scraperId: String, source: Source, status: ScraperStatus, statusReason: String? = nil, tags: [String: String]? = nil) {
            self.alias = alias
            self.arn = arn
            self.createdAt = createdAt
            self.destination = destination
            self.lastModifiedAt = lastModifiedAt
            self.roleArn = roleArn
            self.roleConfiguration = roleConfiguration
            self.scraperId = scraperId
            self.source = source
            self.status = status
            self.statusReason = statusReason
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case alias = "alias"
            case arn = "arn"
            case createdAt = "createdAt"
            case destination = "destination"
            case lastModifiedAt = "lastModifiedAt"
            case roleArn = "roleArn"
            case roleConfiguration = "roleConfiguration"
            case scraperId = "scraperId"
            case source = "source"
            case status = "status"
            case statusReason = "statusReason"
            case tags = "tags"
        }
    }

    public struct ServiceQuotaExceededException: AWSErrorShape {
        /// Description of the error.
        public let message: String
        /// Service quotas code of the originating quota.
        public let quotaCode: String
        /// Identifier of the resource affected.
        public let resourceId: String
        /// Type of the resource affected.
        public let resourceType: String
        /// Service quotas code for the originating service.
        public let serviceCode: String

        @inlinable
        public init(message: String, quotaCode: String, resourceId: String, resourceType: String, serviceCode: String) {
            self.message = message
            self.quotaCode = quotaCode
            self.resourceId = resourceId
            self.resourceType = resourceType
            self.serviceCode = serviceCode
        }

        private enum CodingKeys: String, CodingKey {
            case message = "message"
            case quotaCode = "quotaCode"
            case resourceId = "resourceId"
            case resourceType = "resourceType"
            case serviceCode = "serviceCode"
        }
    }

    public struct TagResourceRequest: AWSEncodableShape {
        /// The ARN of the resource to apply tags to.
        public let resourceArn: String
        /// The list of tag keys and values to associate with the resource. Keys must not begin with aws:.
        public let tags: [String: String]

        @inlinable
        public init(resourceArn: String, tags: [String: String]) {
            self.resourceArn = resourceArn
            self.tags = tags
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.resourceArn, key: "resourceArn")
            try container.encode(self.tags, forKey: .tags)
        }

        public func validate(name: String) throws {
            try self.tags.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.key, name: "tags.key", parent: name, pattern: "^([\\p{L}\\p{Z}\\p{N}_.:/=+\\-@]*)$")
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, pattern: "^([\\p{L}\\p{Z}\\p{N}_.:/=+\\-@]*)$")
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 50)
        }

        private enum CodingKeys: String, CodingKey {
            case tags = "tags"
        }
    }

    public struct TagResourceResponse: AWSDecodableShape {
        public init() {}
    }

    public struct ThrottlingException: AWSErrorShape {
        /// Description of the error.
        public let message: String
        /// Service quotas code for the originating quota.
        public let quotaCode: String?
        /// Advice to clients on when the call can be safely retried.
        public let retryAfterSeconds: Int?
        /// Service quotas code for the originating service.
        public let serviceCode: String?

        @inlinable
        public init(message: String, quotaCode: String? = nil, retryAfterSeconds: Int? = nil, serviceCode: String? = nil) {
            self.message = message
            self.quotaCode = quotaCode
            self.retryAfterSeconds = retryAfterSeconds
            self.serviceCode = serviceCode
        }

        public init(from decoder: Decoder) throws {
            let response = decoder.userInfo[.awsResponse]! as! ResponseDecodingContainer
            let container = try decoder.container(keyedBy: CodingKeys.self)
            self.message = try container.decode(String.self, forKey: .message)
            self.quotaCode = try container.decodeIfPresent(String.self, forKey: .quotaCode)
            self.retryAfterSeconds = try response.decodeHeaderIfPresent(Int.self, key: "Retry-After")
            self.serviceCode = try container.decodeIfPresent(String.self, forKey: .serviceCode)
        }

        private enum CodingKeys: String, CodingKey {
            case message = "message"
            case quotaCode = "quotaCode"
            case serviceCode = "serviceCode"
        }
    }

    public struct UntagResourceRequest: AWSEncodableShape {
        /// The ARN of the resource from which to remove a tag.
        public let resourceArn: String
        /// The keys of the tags to remove.
        public let tagKeys: [String]

        @inlinable
        public init(resourceArn: String, tagKeys: [String]) {
            self.resourceArn = resourceArn
            self.tagKeys = tagKeys
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.resourceArn, key: "resourceArn")
            request.encodeQuery(self.tagKeys, key: "tagKeys")
        }

        public func validate(name: String) throws {
            try self.tagKeys.forEach {
                try validate($0, name: "tagKeys[]", parent: name, max: 128)
                try validate($0, name: "tagKeys[]", parent: name, min: 1)
                try validate($0, name: "tagKeys[]", parent: name, pattern: "^([\\p{L}\\p{Z}\\p{N}_.:/=+\\-@]*)$")
            }
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct UntagResourceResponse: AWSDecodableShape {
        public init() {}
    }

    public struct UpdateLoggingConfigurationRequest: AWSEncodableShape {
        /// A unique identifier that you can provide to ensure the idempotency of the request. Case-sensitive.
        public let clientToken: String?
        /// The ARN of the CloudWatch log group to which the vended log data will be published.
        public let logGroupArn: String
        /// The ID of the workspace to update the logging configuration for.
        public let workspaceId: String

        @inlinable
        public init(clientToken: String? = UpdateLoggingConfigurationRequest.idempotencyToken(), logGroupArn: String, workspaceId: String) {
            self.clientToken = clientToken
            self.logGroupArn = logGroupArn
            self.workspaceId = workspaceId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.clientToken, forKey: .clientToken)
            try container.encode(self.logGroupArn, forKey: .logGroupArn)
            request.encodePath(self.workspaceId, key: "workspaceId")
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 64)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "^[!-~]+$")
            try self.validate(self.logGroupArn, name: "logGroupArn", parent: name, pattern: "^arn:aws[-a-z]*:logs:[-a-z0-9]+:[0-9]{12}:log-group:[A-Za-z0-9\\.\\-\\_\\#/]{1,512}\\:\\*$")
            try self.validate(self.workspaceId, name: "workspaceId", parent: name, max: 64)
            try self.validate(self.workspaceId, name: "workspaceId", parent: name, min: 1)
            try self.validate(self.workspaceId, name: "workspaceId", parent: name, pattern: "[0-9A-Za-z][-.0-9A-Z_a-z]*")
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "clientToken"
            case logGroupArn = "logGroupArn"
        }
    }

    public struct UpdateLoggingConfigurationResponse: AWSDecodableShape {
        /// A structure that contains the current status of the logging configuration.
        public let status: LoggingConfigurationStatus

        @inlinable
        public init(status: LoggingConfigurationStatus) {
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case status = "status"
        }
    }

    public struct UpdateScraperRequest: AWSEncodableShape {
        /// The new alias of the scraper.
        public let alias: String?
        /// A unique identifier that you can provide to ensure the idempotency of the request. Case-sensitive.
        public let clientToken: String?
        /// The new Amazon Managed Service for Prometheus workspace to send metrics to.
        public let destination: Destination?
        /// The scraper role configuration for the workspace.
        public let roleConfiguration: RoleConfiguration?
        /// Contains the base-64 encoded YAML configuration for the scraper.  For more information about configuring a scraper, see Using an  Amazon Web Services managed collector in the Amazon Managed Service for Prometheus  User Guide.
        public let scrapeConfiguration: ScrapeConfiguration?
        /// The ID of the scraper to update.
        public let scraperId: String

        @inlinable
        public init(alias: String? = nil, clientToken: String? = UpdateScraperRequest.idempotencyToken(), destination: Destination? = nil, roleConfiguration: RoleConfiguration? = nil, scrapeConfiguration: ScrapeConfiguration? = nil, scraperId: String) {
            self.alias = alias
            self.clientToken = clientToken
            self.destination = destination
            self.roleConfiguration = roleConfiguration
            self.scrapeConfiguration = scrapeConfiguration
            self.scraperId = scraperId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.alias, forKey: .alias)
            try container.encodeIfPresent(self.clientToken, forKey: .clientToken)
            try container.encodeIfPresent(self.destination, forKey: .destination)
            try container.encodeIfPresent(self.roleConfiguration, forKey: .roleConfiguration)
            try container.encodeIfPresent(self.scrapeConfiguration, forKey: .scrapeConfiguration)
            request.encodePath(self.scraperId, key: "scraperId")
        }

        public func validate(name: String) throws {
            try self.validate(self.alias, name: "alias", parent: name, max: 100)
            try self.validate(self.alias, name: "alias", parent: name, min: 1)
            try self.validate(self.alias, name: "alias", parent: name, pattern: "^[0-9A-Za-z][-.0-9A-Z_a-z]*$")
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 64)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "^[!-~]+$")
            try self.destination?.validate(name: "\(name).destination")
            try self.roleConfiguration?.validate(name: "\(name).roleConfiguration")
            try self.validate(self.scraperId, name: "scraperId", parent: name, max: 64)
            try self.validate(self.scraperId, name: "scraperId", parent: name, min: 1)
            try self.validate(self.scraperId, name: "scraperId", parent: name, pattern: "^[0-9A-Za-z][-.0-9A-Z_a-z]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case alias = "alias"
            case clientToken = "clientToken"
            case destination = "destination"
            case roleConfiguration = "roleConfiguration"
            case scrapeConfiguration = "scrapeConfiguration"
        }
    }

    public struct UpdateScraperResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the updated scraper.
        public let arn: String
        /// The ID of the updated scraper.
        public let scraperId: String
        /// A structure that displays the current status of the scraper.
        public let status: ScraperStatus
        /// The list of tag keys and values that are associated with the scraper.
        public let tags: [String: String]?

        @inlinable
        public init(arn: String, scraperId: String, status: ScraperStatus, tags: [String: String]? = nil) {
            self.arn = arn
            self.scraperId = scraperId
            self.status = status
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case scraperId = "scraperId"
            case status = "status"
            case tags = "tags"
        }
    }

    public struct UpdateWorkspaceAliasRequest: AWSEncodableShape {
        /// The new alias for the workspace. It does not need to be unique. Amazon Managed Service for Prometheus will automatically strip any blank spaces from the beginning and end of the alias that you specify.
        public let alias: String?
        /// A unique identifier that you can provide to ensure the idempotency of the request. Case-sensitive.
        public let clientToken: String?
        /// The ID of the workspace to update.
        public let workspaceId: String

        @inlinable
        public init(alias: String? = nil, clientToken: String? = UpdateWorkspaceAliasRequest.idempotencyToken(), workspaceId: String) {
            self.alias = alias
            self.clientToken = clientToken
            self.workspaceId = workspaceId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.alias, forKey: .alias)
            try container.encodeIfPresent(self.clientToken, forKey: .clientToken)
            request.encodePath(self.workspaceId, key: "workspaceId")
        }

        public func validate(name: String) throws {
            try self.validate(self.alias, name: "alias", parent: name, max: 100)
            try self.validate(self.alias, name: "alias", parent: name, min: 1)
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 64)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "^[!-~]+$")
            try self.validate(self.workspaceId, name: "workspaceId", parent: name, max: 64)
            try self.validate(self.workspaceId, name: "workspaceId", parent: name, min: 1)
            try self.validate(self.workspaceId, name: "workspaceId", parent: name, pattern: "[0-9A-Za-z][-.0-9A-Z_a-z]*")
        }

        private enum CodingKeys: String, CodingKey {
            case alias = "alias"
            case clientToken = "clientToken"
        }
    }

    public struct ValidationException: AWSErrorShape {
        /// The field that caused the error, if applicable.
        public let fieldList: [ValidationExceptionField]?
        /// Description of the error.
        public let message: String
        /// Reason the request failed validation.
        public let reason: ValidationExceptionReason

        @inlinable
        public init(fieldList: [ValidationExceptionField]? = nil, message: String, reason: ValidationExceptionReason) {
            self.fieldList = fieldList
            self.message = message
            self.reason = reason
        }

        private enum CodingKeys: String, CodingKey {
            case fieldList = "fieldList"
            case message = "message"
            case reason = "reason"
        }
    }

    public struct ValidationExceptionField: AWSDecodableShape {
        /// A message describing why the field caused an exception.
        public let message: String
        /// The name of the field that caused an exception.
        public let name: String

        @inlinable
        public init(message: String, name: String) {
            self.message = message
            self.name = name
        }

        private enum CodingKeys: String, CodingKey {
            case message = "message"
            case name = "name"
        }
    }

    public struct WorkspaceDescription: AWSDecodableShape {
        /// The alias that is assigned to this workspace to help identify it. It does not need to be unique.
        public let alias: String?
        /// The ARN of the workspace. For example,  arn:aws:aps:&lt;region&gt;:123456789012:workspace/ws-example1-1234-abcd-5678-ef90abcd1234.
        public let arn: String
        /// The date and time that the workspace was created.
        public let createdAt: Date
        /// (optional) If the workspace was created with a customer managed KMS  key, the ARN for the key used.
        public let kmsKeyArn: String?
        /// The Prometheus endpoint available for this workspace. For example, https://aps-workspaces.&lt;region&gt;.amazonaws.com/workspaces/ws-example1-1234-abcd-5678-ef90abcd1234/api/v1/.
        public let prometheusEndpoint: String?
        /// The current status of the workspace.
        public let status: WorkspaceStatus
        /// The list of tag keys and values that are associated with the workspace.
        public let tags: [String: String]?
        /// The unique ID for the workspace. For example,  ws-example1-1234-abcd-5678-ef90abcd1234.
        public let workspaceId: String

        @inlinable
        public init(alias: String? = nil, arn: String, createdAt: Date, kmsKeyArn: String? = nil, prometheusEndpoint: String? = nil, status: WorkspaceStatus, tags: [String: String]? = nil, workspaceId: String) {
            self.alias = alias
            self.arn = arn
            self.createdAt = createdAt
            self.kmsKeyArn = kmsKeyArn
            self.prometheusEndpoint = prometheusEndpoint
            self.status = status
            self.tags = tags
            self.workspaceId = workspaceId
        }

        private enum CodingKeys: String, CodingKey {
            case alias = "alias"
            case arn = "arn"
            case createdAt = "createdAt"
            case kmsKeyArn = "kmsKeyArn"
            case prometheusEndpoint = "prometheusEndpoint"
            case status = "status"
            case tags = "tags"
            case workspaceId = "workspaceId"
        }
    }

    public struct WorkspaceStatus: AWSDecodableShape {
        /// The current status of the workspace.
        public let statusCode: WorkspaceStatusCode

        @inlinable
        public init(statusCode: WorkspaceStatusCode) {
            self.statusCode = statusCode
        }

        private enum CodingKeys: String, CodingKey {
            case statusCode = "statusCode"
        }
    }

    public struct WorkspaceSummary: AWSDecodableShape {
        /// The alias that is assigned to this workspace to help identify it. It does not  need to be unique.
        public let alias: String?
        /// The ARN of the workspace.
        public let arn: String
        /// The date and time that the workspace was created.
        public let createdAt: Date
        /// (optional) If the workspace was created with a customer managed KMS  key, the ARN for the key used.
        public let kmsKeyArn: String?
        /// The current status of the workspace.
        public let status: WorkspaceStatus
        /// The list of tag keys and values that are associated with the workspace.
        public let tags: [String: String]?
        /// The unique ID for the workspace.
        public let workspaceId: String

        @inlinable
        public init(alias: String? = nil, arn: String, createdAt: Date, kmsKeyArn: String? = nil, status: WorkspaceStatus, tags: [String: String]? = nil, workspaceId: String) {
            self.alias = alias
            self.arn = arn
            self.createdAt = createdAt
            self.kmsKeyArn = kmsKeyArn
            self.status = status
            self.tags = tags
            self.workspaceId = workspaceId
        }

        private enum CodingKeys: String, CodingKey {
            case alias = "alias"
            case arn = "arn"
            case createdAt = "createdAt"
            case kmsKeyArn = "kmsKeyArn"
            case status = "status"
            case tags = "tags"
            case workspaceId = "workspaceId"
        }
    }

    public struct Destination: AWSEncodableShape & AWSDecodableShape {
        /// The Amazon Managed Service for Prometheus workspace to send metrics to.
        public let ampConfiguration: AmpConfiguration?

        @inlinable
        public init(ampConfiguration: AmpConfiguration? = nil) {
            self.ampConfiguration = ampConfiguration
        }

        public func validate(name: String) throws {
            try self.ampConfiguration?.validate(name: "\(name).ampConfiguration")
        }

        private enum CodingKeys: String, CodingKey {
            case ampConfiguration = "ampConfiguration"
        }
    }

    public struct ScrapeConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The base 64 encoded scrape configuration file.
        public let configurationBlob: AWSBase64Data?

        @inlinable
        public init(configurationBlob: AWSBase64Data? = nil) {
            self.configurationBlob = configurationBlob
        }

        private enum CodingKeys: String, CodingKey {
            case configurationBlob = "configurationBlob"
        }
    }

    public struct Source: AWSEncodableShape & AWSDecodableShape {
        /// The Amazon EKS cluster from which a scraper collects metrics.
        public let eksConfiguration: EksConfiguration?

        @inlinable
        public init(eksConfiguration: EksConfiguration? = nil) {
            self.eksConfiguration = eksConfiguration
        }

        public func validate(name: String) throws {
            try self.eksConfiguration?.validate(name: "\(name).eksConfiguration")
        }

        private enum CodingKeys: String, CodingKey {
            case eksConfiguration = "eksConfiguration"
        }
    }
}

// MARK: - Errors

/// Error enum for Amp
public struct AmpErrorType: AWSErrorType {
    enum Code: String {
        case accessDeniedException = "AccessDeniedException"
        case conflictException = "ConflictException"
        case internalServerException = "InternalServerException"
        case resourceNotFoundException = "ResourceNotFoundException"
        case serviceQuotaExceededException = "ServiceQuotaExceededException"
        case throttlingException = "ThrottlingException"
        case validationException = "ValidationException"
    }

    private let error: Code
    public let context: AWSErrorContext?

    /// initialize Amp
    public init?(errorCode: String, context: AWSErrorContext) {
        guard let error = Code(rawValue: errorCode) else { return nil }
        self.error = error
        self.context = context
    }

    internal init(_ error: Code) {
        self.error = error
        self.context = nil
    }

    /// return error code string
    public var errorCode: String { self.error.rawValue }

    /// You do not have sufficient access to perform this action.
    public static var accessDeniedException: Self { .init(.accessDeniedException) }
    /// The request would cause an inconsistent state.
    public static var conflictException: Self { .init(.conflictException) }
    /// An unexpected error occurred during the processing of the request.
    public static var internalServerException: Self { .init(.internalServerException) }
    /// The request references a resources that doesn't exist.
    public static var resourceNotFoundException: Self { .init(.resourceNotFoundException) }
    /// Completing the request would cause a service quota to be exceeded.
    public static var serviceQuotaExceededException: Self { .init(.serviceQuotaExceededException) }
    /// The request was denied due to request throttling.
    public static var throttlingException: Self { .init(.throttlingException) }
    /// The input fails to satisfy the constraints specified by an Amazon Web Services service.
    public static var validationException: Self { .init(.validationException) }
}

extension AmpErrorType: AWSServiceErrorType {
    public static let errorCodeMap: [String: AWSErrorShape.Type] = [
        "ConflictException": Amp.ConflictException.self,
        "InternalServerException": Amp.InternalServerException.self,
        "ResourceNotFoundException": Amp.ResourceNotFoundException.self,
        "ServiceQuotaExceededException": Amp.ServiceQuotaExceededException.self,
        "ThrottlingException": Amp.ThrottlingException.self,
        "ValidationException": Amp.ValidationException.self
    ]
}

extension AmpErrorType: Equatable {
    public static func == (lhs: AmpErrorType, rhs: AmpErrorType) -> Bool {
        lhs.error == rhs.error
    }
}

extension AmpErrorType: CustomStringConvertible {
    public var description: String {
        return "\(self.error.rawValue): \(self.message ?? "")"
    }
}
