//===----------------------------------------------------------------------===//
//
// This source file is part of the Soto for AWS open source project
//
// Copyright (c) 2017-2024 the Soto project authors
// Licensed under Apache License v2.0
//
// See LICENSE.txt for license information
// See CONTRIBUTORS.txt for the list of Soto project authors
//
// SPDX-License-Identifier: Apache-2.0
//
//===----------------------------------------------------------------------===//

// THIS FILE IS AUTOMATICALLY GENERATED by https://github.com/soto-project/soto-codegenerator.
// DO NOT EDIT.

#if canImport(FoundationEssentials)
import FoundationEssentials
#else
import Foundation
#endif
@_exported import SotoCore

/// Service object for interacting with AWS Amp service.
///
/// Amazon Managed Service for Prometheus is a serverless, Prometheus-compatible monitoring service for container metrics that makes it easier to securely monitor container environments at scale. With Amazon Managed Service for Prometheus, you can use the same open-source Prometheus data model and query language that you use today to monitor the performance of your containerized workloads, and also enjoy improved scalability, availability, and security without having to manage the underlying infrastructure. For more information about Amazon Managed Service for Prometheus, see the Amazon Managed Service for Prometheus User Guide. Amazon Managed Service for Prometheus includes two APIs.   Use the Amazon Web Services API described in this guide to manage Amazon Managed Service for Prometheus resources, such as workspaces, rule groups, and alert managers.   Use the Prometheus-compatible API to work within your Prometheus workspace.
public struct Amp: AWSService {
    // MARK: Member variables

    /// Client used for communication with AWS
    public let client: AWSClient
    /// Service configuration
    public let config: AWSServiceConfig

    // MARK: Initialization

    /// Initialize the Amp client
    /// - parameters:
    ///     - client: AWSClient used to process requests
    ///     - region: Region of server you want to communicate with. This will override the partition parameter.
    ///     - partition: AWS partition where service resides, standard (.aws), china (.awscn), government (.awsusgov).
    ///     - endpoint: Custom endpoint URL to use instead of standard AWS servers
    ///     - middleware: Middleware chain used to edit requests before they are sent and responses before they are decoded 
    ///     - timeout: Timeout value for HTTP requests
    ///     - byteBufferAllocator: Allocator for ByteBuffers
    ///     - options: Service options
    public init(
        client: AWSClient,
        region: SotoCore.Region? = nil,
        partition: AWSPartition = .aws,
        endpoint: String? = nil,
        middleware: AWSMiddlewareProtocol? = nil,
        timeout: TimeAmount? = nil,
        byteBufferAllocator: ByteBufferAllocator = ByteBufferAllocator(),
        options: AWSServiceConfig.Options = []
    ) {
        self.client = client
        self.config = AWSServiceConfig(
            region: region,
            partition: region?.partition ?? partition,
            serviceName: "Amp",
            serviceIdentifier: "aps",
            serviceProtocol: .restjson,
            apiVersion: "2020-08-01",
            endpoint: endpoint,
            variantEndpoints: Self.variantEndpoints,
            errorType: AmpErrorType.self,
            middleware: middleware,
            timeout: timeout,
            byteBufferAllocator: byteBufferAllocator,
            options: options
        )
    }




    /// FIPS and dualstack endpoints
    static var variantEndpoints: [EndpointVariantType: AWSServiceConfig.EndpointVariant] {[
        [.dualstack]: .init(endpoints: [
            "ap-northeast-1": "aps.ap-northeast-1.api.aws",
            "ap-northeast-2": "aps.ap-northeast-2.api.aws",
            "ap-south-1": "aps.ap-south-1.api.aws",
            "ap-southeast-1": "aps.ap-southeast-1.api.aws",
            "ap-southeast-2": "aps.ap-southeast-2.api.aws",
            "eu-central-1": "aps.eu-central-1.api.aws",
            "eu-north-1": "aps.eu-north-1.api.aws",
            "eu-west-1": "aps.eu-west-1.api.aws",
            "eu-west-2": "aps.eu-west-2.api.aws",
            "eu-west-3": "aps.eu-west-3.api.aws",
            "sa-east-1": "aps.sa-east-1.api.aws",
            "us-east-1": "aps.us-east-1.api.aws",
            "us-east-2": "aps.us-east-2.api.aws",
            "us-west-2": "aps.us-west-2.api.aws"
        ]),
        [.dualstack, .fips]: .init(endpoints: [
            "us-east-1": "aps-fips.us-east-1.api.aws",
            "us-east-2": "aps-fips.us-east-2.api.aws",
            "us-west-2": "aps-fips.us-west-2.api.aws"
        ]),
        [.fips]: .init(endpoints: [
            "us-east-1": "aps-fips.us-east-1.amazonaws.com",
            "us-east-2": "aps-fips.us-east-2.amazonaws.com",
            "us-west-2": "aps-fips.us-west-2.amazonaws.com"
        ])
    ]}

    // MARK: API Calls

    /// The CreateAlertManagerDefinition operation creates the alert manager definition in a workspace. If a workspace already has an alert manager definition, don't use this operation to update it. Instead, use PutAlertManagerDefinition.
    @Sendable
    @inlinable
    public func createAlertManagerDefinition(_ input: CreateAlertManagerDefinitionRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> CreateAlertManagerDefinitionResponse {
        try await self.client.execute(
            operation: "CreateAlertManagerDefinition", 
            path: "/workspaces/{workspaceId}/alertmanager/definition", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// The CreateAlertManagerDefinition operation creates the alert manager definition in a workspace. If a workspace already has an alert manager definition, don't use this operation to update it. Instead, use PutAlertManagerDefinition.
    ///
    /// Parameters:
    ///   - clientToken: A unique identifier that you can provide to ensure the idempotency of the request. Case-sensitive.
    ///   - data: The alert manager definition to add. A base64-encoded version of the YAML alert manager definition file. For details about the alert manager definition, see AlertManagedDefinitionData.
    ///   - workspaceId: The ID of the workspace to add the alert manager definition to.
    ///   - logger: Logger use during operation
    @inlinable
    public func createAlertManagerDefinition(
        clientToken: String? = CreateAlertManagerDefinitionRequest.idempotencyToken(),
        data: AWSBase64Data,
        workspaceId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> CreateAlertManagerDefinitionResponse {
        let input = CreateAlertManagerDefinitionRequest(
            clientToken: clientToken, 
            data: data, 
            workspaceId: workspaceId
        )
        return try await self.createAlertManagerDefinition(input, logger: logger)
    }

    /// The CreateLoggingConfiguration operation creates a logging configuration for the workspace. Use this operation to set the CloudWatch log group to which the logs will be published to.
    @Sendable
    @inlinable
    public func createLoggingConfiguration(_ input: CreateLoggingConfigurationRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> CreateLoggingConfigurationResponse {
        try await self.client.execute(
            operation: "CreateLoggingConfiguration", 
            path: "/workspaces/{workspaceId}/logging", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// The CreateLoggingConfiguration operation creates a logging configuration for the workspace. Use this operation to set the CloudWatch log group to which the logs will be published to.
    ///
    /// Parameters:
    ///   - clientToken: A unique identifier that you can provide to ensure the idempotency of the request. Case-sensitive.
    ///   - logGroupArn: The ARN of the CloudWatch log group to which the vended log data will be published. This log group must exist prior to calling this operation.
    ///   - workspaceId: The ID of the workspace to create the logging configuration for.
    ///   - logger: Logger use during operation
    @inlinable
    public func createLoggingConfiguration(
        clientToken: String? = CreateLoggingConfigurationRequest.idempotencyToken(),
        logGroupArn: String,
        workspaceId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> CreateLoggingConfigurationResponse {
        let input = CreateLoggingConfigurationRequest(
            clientToken: clientToken, 
            logGroupArn: logGroupArn, 
            workspaceId: workspaceId
        )
        return try await self.createLoggingConfiguration(input, logger: logger)
    }

    /// The CreateRuleGroupsNamespace operation creates a rule groups namespace within a workspace. A rule groups namespace is associated with exactly one rules file. A workspace can have multiple rule groups namespaces. Use this operation only to create new rule groups namespaces. To update an existing rule groups namespace, use PutRuleGroupsNamespace.
    @Sendable
    @inlinable
    public func createRuleGroupsNamespace(_ input: CreateRuleGroupsNamespaceRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> CreateRuleGroupsNamespaceResponse {
        try await self.client.execute(
            operation: "CreateRuleGroupsNamespace", 
            path: "/workspaces/{workspaceId}/rulegroupsnamespaces", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// The CreateRuleGroupsNamespace operation creates a rule groups namespace within a workspace. A rule groups namespace is associated with exactly one rules file. A workspace can have multiple rule groups namespaces. Use this operation only to create new rule groups namespaces. To update an existing rule groups namespace, use PutRuleGroupsNamespace.
    ///
    /// Parameters:
    ///   - clientToken: A unique identifier that you can provide to ensure the idempotency of the request. Case-sensitive.
    ///   - data: The rules file to use in the new namespace. Contains the base64-encoded version of the YAML rules file. For details about the rule groups namespace structure, see RuleGroupsNamespaceData.
    ///   - name: The name for the new rule groups namespace.
    ///   - tags: The list of tag keys and values to associate with the rule groups namespace.
    ///   - workspaceId: The ID of the workspace to add the rule groups namespace.
    ///   - logger: Logger use during operation
    @inlinable
    public func createRuleGroupsNamespace(
        clientToken: String? = CreateRuleGroupsNamespaceRequest.idempotencyToken(),
        data: AWSBase64Data,
        name: String,
        tags: [String: String]? = nil,
        workspaceId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> CreateRuleGroupsNamespaceResponse {
        let input = CreateRuleGroupsNamespaceRequest(
            clientToken: clientToken, 
            data: data, 
            name: name, 
            tags: tags, 
            workspaceId: workspaceId
        )
        return try await self.createRuleGroupsNamespace(input, logger: logger)
    }

    /// The CreateScraper operation creates a scraper to collect metrics. A scraper pulls metrics from Prometheus-compatible sources within an Amazon EKS cluster, and sends them to your Amazon Managed Service for Prometheus workspace. Scrapers are  flexible, and can be configured to control what metrics are collected, the  frequency of collection, what transformations are applied to the metrics, and more. An IAM role will be created for you that Amazon Managed Service for Prometheus uses  to access the metrics in your cluster. You must configure this role with a policy that allows it to scrape metrics from your cluster. For more information, see  Configuring your Amazon EKS cluster in the Amazon Managed Service for Prometheus User Guide. The scrapeConfiguration parameter contains the base-64 encoded YAML  configuration for the scraper.  For more information about collectors, including what metrics are collected, and how to configure the scraper, see Using an  Amazon Web Services managed collector in the Amazon Managed Service for Prometheus User  Guide.
    @Sendable
    @inlinable
    public func createScraper(_ input: CreateScraperRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> CreateScraperResponse {
        try await self.client.execute(
            operation: "CreateScraper", 
            path: "/scrapers", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// The CreateScraper operation creates a scraper to collect metrics. A scraper pulls metrics from Prometheus-compatible sources within an Amazon EKS cluster, and sends them to your Amazon Managed Service for Prometheus workspace. Scrapers are  flexible, and can be configured to control what metrics are collected, the  frequency of collection, what transformations are applied to the metrics, and more. An IAM role will be created for you that Amazon Managed Service for Prometheus uses  to access the metrics in your cluster. You must configure this role with a policy that allows it to scrape metrics from your cluster. For more information, see  Configuring your Amazon EKS cluster in the Amazon Managed Service for Prometheus User Guide. The scrapeConfiguration parameter contains the base-64 encoded YAML  configuration for the scraper.  For more information about collectors, including what metrics are collected, and how to configure the scraper, see Using an  Amazon Web Services managed collector in the Amazon Managed Service for Prometheus User  Guide.
    ///
    /// Parameters:
    ///   - alias: (optional) An alias to associate with the scraper. This is for your use, and does not need to be unique.
    ///   - clientToken: (Optional) A unique, case-sensitive identifier that you can provide to ensure the idempotency of the request.
    ///   - destination: The Amazon Managed Service for Prometheus workspace to send metrics to.
    ///   - roleConfiguration: The scraper role configuration for the workspace.
    ///   - scrapeConfiguration: The configuration file to use in the new scraper. For more information, see Scraper configuration in the Amazon Managed Service for Prometheus User  Guide.
    ///   - source: The Amazon EKS cluster from which the scraper will collect metrics.
    ///   - tags: (Optional) The list of tag keys and values to associate with the scraper.
    ///   - logger: Logger use during operation
    @inlinable
    public func createScraper(
        alias: String? = nil,
        clientToken: String? = CreateScraperRequest.idempotencyToken(),
        destination: Destination,
        roleConfiguration: RoleConfiguration? = nil,
        scrapeConfiguration: ScrapeConfiguration,
        source: Source,
        tags: [String: String]? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> CreateScraperResponse {
        let input = CreateScraperRequest(
            alias: alias, 
            clientToken: clientToken, 
            destination: destination, 
            roleConfiguration: roleConfiguration, 
            scrapeConfiguration: scrapeConfiguration, 
            source: source, 
            tags: tags
        )
        return try await self.createScraper(input, logger: logger)
    }

    /// Creates a Prometheus workspace. A workspace is a logical space dedicated to the storage and querying of Prometheus metrics. You can have one or more workspaces in each Region in your account.
    @Sendable
    @inlinable
    public func createWorkspace(_ input: CreateWorkspaceRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> CreateWorkspaceResponse {
        try await self.client.execute(
            operation: "CreateWorkspace", 
            path: "/workspaces", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Creates a Prometheus workspace. A workspace is a logical space dedicated to the storage and querying of Prometheus metrics. You can have one or more workspaces in each Region in your account.
    ///
    /// Parameters:
    ///   - alias: An alias that you assign to this workspace to help you identify it. It does not need to be unique. Blank spaces at the beginning or end of the alias that you specify will be trimmed from the value used.
    ///   - clientToken: A unique identifier that you can provide to ensure the idempotency of the request. Case-sensitive.
    ///   - kmsKeyArn: (optional) The ARN for a customer managed KMS key to use for  encrypting data within your workspace. For more information about using your own key in your workspace, see Encryption at rest in the Amazon Managed Service for Prometheus User  Guide.
    ///   - tags: The list of tag keys and values to associate with the workspace.
    ///   - logger: Logger use during operation
    @inlinable
    public func createWorkspace(
        alias: String? = nil,
        clientToken: String? = CreateWorkspaceRequest.idempotencyToken(),
        kmsKeyArn: String? = nil,
        tags: [String: String]? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> CreateWorkspaceResponse {
        let input = CreateWorkspaceRequest(
            alias: alias, 
            clientToken: clientToken, 
            kmsKeyArn: kmsKeyArn, 
            tags: tags
        )
        return try await self.createWorkspace(input, logger: logger)
    }

    /// Deletes the alert manager definition from a workspace.
    @Sendable
    @inlinable
    public func deleteAlertManagerDefinition(_ input: DeleteAlertManagerDefinitionRequest, logger: Logger = AWSClient.loggingDisabled) async throws {
        try await self.client.execute(
            operation: "DeleteAlertManagerDefinition", 
            path: "/workspaces/{workspaceId}/alertmanager/definition", 
            httpMethod: .DELETE, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Deletes the alert manager definition from a workspace.
    ///
    /// Parameters:
    ///   - clientToken: A unique identifier that you can provide to ensure the idempotency of the request. Case-sensitive.
    ///   - workspaceId: The ID of the workspace to delete the alert manager definition from.
    ///   - logger: Logger use during operation
    @inlinable
    public func deleteAlertManagerDefinition(
        clientToken: String? = DeleteAlertManagerDefinitionRequest.idempotencyToken(),
        workspaceId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws {
        let input = DeleteAlertManagerDefinitionRequest(
            clientToken: clientToken, 
            workspaceId: workspaceId
        )
        return try await self.deleteAlertManagerDefinition(input, logger: logger)
    }

    /// Deletes the logging configuration for a workspace.
    @Sendable
    @inlinable
    public func deleteLoggingConfiguration(_ input: DeleteLoggingConfigurationRequest, logger: Logger = AWSClient.loggingDisabled) async throws {
        try await self.client.execute(
            operation: "DeleteLoggingConfiguration", 
            path: "/workspaces/{workspaceId}/logging", 
            httpMethod: .DELETE, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Deletes the logging configuration for a workspace.
    ///
    /// Parameters:
    ///   - clientToken: A unique identifier that you can provide to ensure the idempotency of the request. Case-sensitive.
    ///   - workspaceId: The ID of the workspace containing the logging configuration to delete.
    ///   - logger: Logger use during operation
    @inlinable
    public func deleteLoggingConfiguration(
        clientToken: String? = DeleteLoggingConfigurationRequest.idempotencyToken(),
        workspaceId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws {
        let input = DeleteLoggingConfigurationRequest(
            clientToken: clientToken, 
            workspaceId: workspaceId
        )
        return try await self.deleteLoggingConfiguration(input, logger: logger)
    }

    /// Deletes one rule groups namespace and its associated rule groups definition.
    @Sendable
    @inlinable
    public func deleteRuleGroupsNamespace(_ input: DeleteRuleGroupsNamespaceRequest, logger: Logger = AWSClient.loggingDisabled) async throws {
        try await self.client.execute(
            operation: "DeleteRuleGroupsNamespace", 
            path: "/workspaces/{workspaceId}/rulegroupsnamespaces/{name}", 
            httpMethod: .DELETE, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Deletes one rule groups namespace and its associated rule groups definition.
    ///
    /// Parameters:
    ///   - clientToken: A unique identifier that you can provide to ensure the idempotency of the request. Case-sensitive.
    ///   - name: The name of the rule groups namespace to delete.
    ///   - workspaceId: The ID of the workspace containing the rule groups namespace and definition to delete.
    ///   - logger: Logger use during operation
    @inlinable
    public func deleteRuleGroupsNamespace(
        clientToken: String? = DeleteRuleGroupsNamespaceRequest.idempotencyToken(),
        name: String,
        workspaceId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws {
        let input = DeleteRuleGroupsNamespaceRequest(
            clientToken: clientToken, 
            name: name, 
            workspaceId: workspaceId
        )
        return try await self.deleteRuleGroupsNamespace(input, logger: logger)
    }

    /// The DeleteScraper operation deletes one scraper, and stops any metrics collection that the scraper performs.
    @Sendable
    @inlinable
    public func deleteScraper(_ input: DeleteScraperRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> DeleteScraperResponse {
        try await self.client.execute(
            operation: "DeleteScraper", 
            path: "/scrapers/{scraperId}", 
            httpMethod: .DELETE, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// The DeleteScraper operation deletes one scraper, and stops any metrics collection that the scraper performs.
    ///
    /// Parameters:
    ///   - clientToken: (Optional) A unique, case-sensitive identifier that you can provide to ensure the  idempotency of the request.
    ///   - scraperId: The ID of the scraper to delete.
    ///   - logger: Logger use during operation
    @inlinable
    public func deleteScraper(
        clientToken: String? = DeleteScraperRequest.idempotencyToken(),
        scraperId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> DeleteScraperResponse {
        let input = DeleteScraperRequest(
            clientToken: clientToken, 
            scraperId: scraperId
        )
        return try await self.deleteScraper(input, logger: logger)
    }

    /// Deletes an existing workspace.   When you delete a workspace, the data that has been ingested into it is not immediately deleted. It will be permanently deleted within one month.
    @Sendable
    @inlinable
    public func deleteWorkspace(_ input: DeleteWorkspaceRequest, logger: Logger = AWSClient.loggingDisabled) async throws {
        try await self.client.execute(
            operation: "DeleteWorkspace", 
            path: "/workspaces/{workspaceId}", 
            httpMethod: .DELETE, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Deletes an existing workspace.   When you delete a workspace, the data that has been ingested into it is not immediately deleted. It will be permanently deleted within one month.
    ///
    /// Parameters:
    ///   - clientToken: A unique identifier that you can provide to ensure the idempotency of the request. Case-sensitive.
    ///   - workspaceId: The ID of the workspace to delete.
    ///   - logger: Logger use during operation
    @inlinable
    public func deleteWorkspace(
        clientToken: String? = DeleteWorkspaceRequest.idempotencyToken(),
        workspaceId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws {
        let input = DeleteWorkspaceRequest(
            clientToken: clientToken, 
            workspaceId: workspaceId
        )
        return try await self.deleteWorkspace(input, logger: logger)
    }

    /// Retrieves the full information about the alert manager definition for a workspace.
    @Sendable
    @inlinable
    public func describeAlertManagerDefinition(_ input: DescribeAlertManagerDefinitionRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> DescribeAlertManagerDefinitionResponse {
        try await self.client.execute(
            operation: "DescribeAlertManagerDefinition", 
            path: "/workspaces/{workspaceId}/alertmanager/definition", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Retrieves the full information about the alert manager definition for a workspace.
    ///
    /// Parameters:
    ///   - workspaceId: The ID of the workspace to retrieve the alert manager definition from.
    ///   - logger: Logger use during operation
    @inlinable
    public func describeAlertManagerDefinition(
        workspaceId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> DescribeAlertManagerDefinitionResponse {
        let input = DescribeAlertManagerDefinitionRequest(
            workspaceId: workspaceId
        )
        return try await self.describeAlertManagerDefinition(input, logger: logger)
    }

    /// Returns complete information about the current logging configuration of the workspace.
    @Sendable
    @inlinable
    public func describeLoggingConfiguration(_ input: DescribeLoggingConfigurationRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> DescribeLoggingConfigurationResponse {
        try await self.client.execute(
            operation: "DescribeLoggingConfiguration", 
            path: "/workspaces/{workspaceId}/logging", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Returns complete information about the current logging configuration of the workspace.
    ///
    /// Parameters:
    ///   - workspaceId: The ID of the workspace to describe the logging configuration for.
    ///   - logger: Logger use during operation
    @inlinable
    public func describeLoggingConfiguration(
        workspaceId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> DescribeLoggingConfigurationResponse {
        let input = DescribeLoggingConfigurationRequest(
            workspaceId: workspaceId
        )
        return try await self.describeLoggingConfiguration(input, logger: logger)
    }

    /// Returns complete information about one rule groups namespace. To retrieve a list of rule groups namespaces, use ListRuleGroupsNamespaces.
    @Sendable
    @inlinable
    public func describeRuleGroupsNamespace(_ input: DescribeRuleGroupsNamespaceRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> DescribeRuleGroupsNamespaceResponse {
        try await self.client.execute(
            operation: "DescribeRuleGroupsNamespace", 
            path: "/workspaces/{workspaceId}/rulegroupsnamespaces/{name}", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Returns complete information about one rule groups namespace. To retrieve a list of rule groups namespaces, use ListRuleGroupsNamespaces.
    ///
    /// Parameters:
    ///   - name: The name of the rule groups namespace that you want information for.
    ///   - workspaceId: The ID of the workspace containing the rule groups namespace.
    ///   - logger: Logger use during operation
    @inlinable
    public func describeRuleGroupsNamespace(
        name: String,
        workspaceId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> DescribeRuleGroupsNamespaceResponse {
        let input = DescribeRuleGroupsNamespaceRequest(
            name: name, 
            workspaceId: workspaceId
        )
        return try await self.describeRuleGroupsNamespace(input, logger: logger)
    }

    /// The DescribeScraper operation displays information about an existing scraper.
    @Sendable
    @inlinable
    public func describeScraper(_ input: DescribeScraperRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> DescribeScraperResponse {
        try await self.client.execute(
            operation: "DescribeScraper", 
            path: "/scrapers/{scraperId}", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// The DescribeScraper operation displays information about an existing scraper.
    ///
    /// Parameters:
    ///   - scraperId: The ID of the scraper to describe.
    ///   - logger: Logger use during operation
    @inlinable
    public func describeScraper(
        scraperId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> DescribeScraperResponse {
        let input = DescribeScraperRequest(
            scraperId: scraperId
        )
        return try await self.describeScraper(input, logger: logger)
    }

    /// Returns information about an existing workspace.
    @Sendable
    @inlinable
    public func describeWorkspace(_ input: DescribeWorkspaceRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> DescribeWorkspaceResponse {
        try await self.client.execute(
            operation: "DescribeWorkspace", 
            path: "/workspaces/{workspaceId}", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Returns information about an existing workspace.
    ///
    /// Parameters:
    ///   - workspaceId: The ID of the workspace to describe.
    ///   - logger: Logger use during operation
    @inlinable
    public func describeWorkspace(
        workspaceId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> DescribeWorkspaceResponse {
        let input = DescribeWorkspaceRequest(
            workspaceId: workspaceId
        )
        return try await self.describeWorkspace(input, logger: logger)
    }

    /// The GetDefaultScraperConfiguration operation returns the default  scraper configuration used when Amazon EKS creates a scraper for you.
    @Sendable
    @inlinable
    public func getDefaultScraperConfiguration(_ input: GetDefaultScraperConfigurationRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> GetDefaultScraperConfigurationResponse {
        try await self.client.execute(
            operation: "GetDefaultScraperConfiguration", 
            path: "/scraperconfiguration", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// The GetDefaultScraperConfiguration operation returns the default  scraper configuration used when Amazon EKS creates a scraper for you.
    ///
    /// Parameters:
    ///   - logger: Logger use during operation
    @inlinable
    public func getDefaultScraperConfiguration(
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> GetDefaultScraperConfigurationResponse {
        let input = GetDefaultScraperConfigurationRequest(
        )
        return try await self.getDefaultScraperConfiguration(input, logger: logger)
    }

    /// Returns a list of rule groups namespaces in a workspace.
    @Sendable
    @inlinable
    public func listRuleGroupsNamespaces(_ input: ListRuleGroupsNamespacesRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> ListRuleGroupsNamespacesResponse {
        try await self.client.execute(
            operation: "ListRuleGroupsNamespaces", 
            path: "/workspaces/{workspaceId}/rulegroupsnamespaces", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Returns a list of rule groups namespaces in a workspace.
    ///
    /// Parameters:
    ///   - maxResults: The maximum number of results to return. The default is 100.
    ///   - name: Use this parameter to filter the rule groups namespaces that are returned. Only the namespaces with names that begin with the value that you specify are returned.
    ///   - nextToken: The token for the next set of items to return. You receive this token from a previous call, and use it to get the next page of results. The other parameters must be the same as the initial call. For example, if your initial request has maxResults of 10, and there are 12 rule groups namespaces to return, then your initial request will return 10 and a nextToken. Using the next token in a subsequent call will return the remaining 2 namespaces.
    ///   - workspaceId: The ID of the workspace containing the rule groups namespaces.
    ///   - logger: Logger use during operation
    @inlinable
    public func listRuleGroupsNamespaces(
        maxResults: Int? = nil,
        name: String? = nil,
        nextToken: String? = nil,
        workspaceId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ListRuleGroupsNamespacesResponse {
        let input = ListRuleGroupsNamespacesRequest(
            maxResults: maxResults, 
            name: name, 
            nextToken: nextToken, 
            workspaceId: workspaceId
        )
        return try await self.listRuleGroupsNamespaces(input, logger: logger)
    }

    /// The ListScrapers operation lists all of the scrapers in your account. This includes scrapers being created or deleted. You can optionally filter the returned list.
    @Sendable
    @inlinable
    public func listScrapers(_ input: ListScrapersRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> ListScrapersResponse {
        try await self.client.execute(
            operation: "ListScrapers", 
            path: "/scrapers", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// The ListScrapers operation lists all of the scrapers in your account. This includes scrapers being created or deleted. You can optionally filter the returned list.
    ///
    /// Parameters:
    ///   - filters: (Optional) A list of key-value pairs to filter the list of scrapers returned. Keys include status, sourceArn,  destinationArn, and alias. Filters on the same key are OR'd together, and filters on different keys are AND'd together. For example,  status=ACTIVE&amp;status=CREATING&amp;alias=Test, will return all scrapers that have the alias Test, and are either in status ACTIVE or CREATING. To find all active scrapers that are sending metrics to a specific Amazon Managed Service for Prometheus workspace, you would use the ARN of the workspace in a query:  status=ACTIVE&amp;destinationArn=arn:aws:aps:us-east-1:123456789012:workspace/ws-example1-1234-abcd-56ef-123456789012  If this is included, it filters the results to only the scrapers that match  the filter.
    ///   - maxResults: Optional) The maximum number of scrapers to return in one ListScrapers operation. The range is 1-1000. If you omit this parameter, the default of 100 is used.
    ///   - nextToken: (Optional) The token for the next set of items to return. (You received this token from a previous call.)
    ///   - logger: Logger use during operation
    @inlinable
    public func listScrapers(
        filters: [String: [String]]? = nil,
        maxResults: Int? = nil,
        nextToken: String? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ListScrapersResponse {
        let input = ListScrapersRequest(
            filters: filters, 
            maxResults: maxResults, 
            nextToken: nextToken
        )
        return try await self.listScrapers(input, logger: logger)
    }

    /// The ListTagsForResource operation returns the tags that are associated with an Amazon Managed Service for Prometheus resource. Currently, the only resources that can be tagged are scrapers, workspaces, and rule groups namespaces.
    @Sendable
    @inlinable
    public func listTagsForResource(_ input: ListTagsForResourceRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> ListTagsForResourceResponse {
        try await self.client.execute(
            operation: "ListTagsForResource", 
            path: "/tags/{resourceArn}", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// The ListTagsForResource operation returns the tags that are associated with an Amazon Managed Service for Prometheus resource. Currently, the only resources that can be tagged are scrapers, workspaces, and rule groups namespaces.
    ///
    /// Parameters:
    ///   - resourceArn: The ARN of the resource to list tages for. Must be a workspace, scraper, or rule groups namespace resource.
    ///   - logger: Logger use during operation
    @inlinable
    public func listTagsForResource(
        resourceArn: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ListTagsForResourceResponse {
        let input = ListTagsForResourceRequest(
            resourceArn: resourceArn
        )
        return try await self.listTagsForResource(input, logger: logger)
    }

    /// Lists all of the Amazon Managed Service for Prometheus workspaces in your account. This includes workspaces being created or deleted.
    @Sendable
    @inlinable
    public func listWorkspaces(_ input: ListWorkspacesRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> ListWorkspacesResponse {
        try await self.client.execute(
            operation: "ListWorkspaces", 
            path: "/workspaces", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Lists all of the Amazon Managed Service for Prometheus workspaces in your account. This includes workspaces being created or deleted.
    ///
    /// Parameters:
    ///   - alias: If this is included, it filters the results to only the workspaces with names that start with the value that you specify here. Amazon Managed Service for Prometheus will automatically strip any blank spaces from the beginning and end of the alias that you specify.
    ///   - maxResults: The maximum number of workspaces to return per request. The default is 100.
    ///   - nextToken: The token for the next set of items to return. You receive this token from a previous call, and use it to get the next page of results. The other parameters must be the same as the initial call. For example, if your initial request has maxResults of 10, and there are 12 workspaces to return, then your initial request will return 10 and a nextToken. Using the next token in a subsequent call will return the remaining 2 workspaces.
    ///   - logger: Logger use during operation
    @inlinable
    public func listWorkspaces(
        alias: String? = nil,
        maxResults: Int? = nil,
        nextToken: String? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ListWorkspacesResponse {
        let input = ListWorkspacesRequest(
            alias: alias, 
            maxResults: maxResults, 
            nextToken: nextToken
        )
        return try await self.listWorkspaces(input, logger: logger)
    }

    /// Updates an existing alert manager definition in a workspace. If the workspace does not already have an alert manager definition, don't use this operation to create it. Instead, use CreateAlertManagerDefinition.
    @Sendable
    @inlinable
    public func putAlertManagerDefinition(_ input: PutAlertManagerDefinitionRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> PutAlertManagerDefinitionResponse {
        try await self.client.execute(
            operation: "PutAlertManagerDefinition", 
            path: "/workspaces/{workspaceId}/alertmanager/definition", 
            httpMethod: .PUT, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Updates an existing alert manager definition in a workspace. If the workspace does not already have an alert manager definition, don't use this operation to create it. Instead, use CreateAlertManagerDefinition.
    ///
    /// Parameters:
    ///   - clientToken: A unique identifier that you can provide to ensure the idempotency of the request. Case-sensitive.
    ///   - data: The alert manager definition to use. A base64-encoded version of the YAML alert manager definition file. For details about the alert manager definition, see AlertManagedDefinitionData.
    ///   - workspaceId: The ID of the workspace to update the alert manager definition in.
    ///   - logger: Logger use during operation
    @inlinable
    public func putAlertManagerDefinition(
        clientToken: String? = PutAlertManagerDefinitionRequest.idempotencyToken(),
        data: AWSBase64Data,
        workspaceId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> PutAlertManagerDefinitionResponse {
        let input = PutAlertManagerDefinitionRequest(
            clientToken: clientToken, 
            data: data, 
            workspaceId: workspaceId
        )
        return try await self.putAlertManagerDefinition(input, logger: logger)
    }

    /// Updates an existing rule groups namespace within a workspace. A rule groups namespace is associated with exactly one rules file. A workspace can have multiple rule groups namespaces. Use this operation only to update existing rule groups namespaces. To create a new rule groups namespace, use CreateRuleGroupsNamespace. You can't use this operation to add tags to an existing rule groups namespace. Instead, use TagResource.
    @Sendable
    @inlinable
    public func putRuleGroupsNamespace(_ input: PutRuleGroupsNamespaceRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> PutRuleGroupsNamespaceResponse {
        try await self.client.execute(
            operation: "PutRuleGroupsNamespace", 
            path: "/workspaces/{workspaceId}/rulegroupsnamespaces/{name}", 
            httpMethod: .PUT, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Updates an existing rule groups namespace within a workspace. A rule groups namespace is associated with exactly one rules file. A workspace can have multiple rule groups namespaces. Use this operation only to update existing rule groups namespaces. To create a new rule groups namespace, use CreateRuleGroupsNamespace. You can't use this operation to add tags to an existing rule groups namespace. Instead, use TagResource.
    ///
    /// Parameters:
    ///   - clientToken: A unique identifier that you can provide to ensure the idempotency of the request. Case-sensitive.
    ///   - data: The new rules file to use in the namespace. A base64-encoded version of the YAML rule groups file. For details about the rule groups namespace structure, see RuleGroupsNamespaceData.
    ///   - name: The name of the rule groups namespace that you are updating.
    ///   - workspaceId: The ID of the workspace where you are updating the rule groups namespace.
    ///   - logger: Logger use during operation
    @inlinable
    public func putRuleGroupsNamespace(
        clientToken: String? = PutRuleGroupsNamespaceRequest.idempotencyToken(),
        data: AWSBase64Data,
        name: String,
        workspaceId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> PutRuleGroupsNamespaceResponse {
        let input = PutRuleGroupsNamespaceRequest(
            clientToken: clientToken, 
            data: data, 
            name: name, 
            workspaceId: workspaceId
        )
        return try await self.putRuleGroupsNamespace(input, logger: logger)
    }

    /// The TagResource operation associates tags with an Amazon Managed Service for Prometheus resource. The only resources that can be tagged are rule groups namespaces, scrapers,  and workspaces. If you specify a new tag key for the resource, this tag is appended to the list of tags associated with the resource. If you specify a tag key that is already associated with the resource, the new tag value that you specify replaces the previous value for that tag. To remove a tag, use UntagResource.
    @Sendable
    @inlinable
    public func tagResource(_ input: TagResourceRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> TagResourceResponse {
        try await self.client.execute(
            operation: "TagResource", 
            path: "/tags/{resourceArn}", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// The TagResource operation associates tags with an Amazon Managed Service for Prometheus resource. The only resources that can be tagged are rule groups namespaces, scrapers,  and workspaces. If you specify a new tag key for the resource, this tag is appended to the list of tags associated with the resource. If you specify a tag key that is already associated with the resource, the new tag value that you specify replaces the previous value for that tag. To remove a tag, use UntagResource.
    ///
    /// Parameters:
    ///   - resourceArn: The ARN of the resource to apply tags to.
    ///   - tags: The list of tag keys and values to associate with the resource. Keys must not begin with aws:.
    ///   - logger: Logger use during operation
    @inlinable
    public func tagResource(
        resourceArn: String,
        tags: [String: String],
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> TagResourceResponse {
        let input = TagResourceRequest(
            resourceArn: resourceArn, 
            tags: tags
        )
        return try await self.tagResource(input, logger: logger)
    }

    /// Removes the specified tags from an Amazon Managed Service for Prometheus resource. The only resources that can be tagged are rule groups namespaces, scrapers, and workspaces.
    @Sendable
    @inlinable
    public func untagResource(_ input: UntagResourceRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> UntagResourceResponse {
        try await self.client.execute(
            operation: "UntagResource", 
            path: "/tags/{resourceArn}", 
            httpMethod: .DELETE, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Removes the specified tags from an Amazon Managed Service for Prometheus resource. The only resources that can be tagged are rule groups namespaces, scrapers, and workspaces.
    ///
    /// Parameters:
    ///   - resourceArn: The ARN of the resource from which to remove a tag.
    ///   - tagKeys: The keys of the tags to remove.
    ///   - logger: Logger use during operation
    @inlinable
    public func untagResource(
        resourceArn: String,
        tagKeys: [String],
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> UntagResourceResponse {
        let input = UntagResourceRequest(
            resourceArn: resourceArn, 
            tagKeys: tagKeys
        )
        return try await self.untagResource(input, logger: logger)
    }

    /// Updates the log group ARN or the workspace ID of the current logging configuration.
    @Sendable
    @inlinable
    public func updateLoggingConfiguration(_ input: UpdateLoggingConfigurationRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> UpdateLoggingConfigurationResponse {
        try await self.client.execute(
            operation: "UpdateLoggingConfiguration", 
            path: "/workspaces/{workspaceId}/logging", 
            httpMethod: .PUT, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Updates the log group ARN or the workspace ID of the current logging configuration.
    ///
    /// Parameters:
    ///   - clientToken: A unique identifier that you can provide to ensure the idempotency of the request. Case-sensitive.
    ///   - logGroupArn: The ARN of the CloudWatch log group to which the vended log data will be published.
    ///   - workspaceId: The ID of the workspace to update the logging configuration for.
    ///   - logger: Logger use during operation
    @inlinable
    public func updateLoggingConfiguration(
        clientToken: String? = UpdateLoggingConfigurationRequest.idempotencyToken(),
        logGroupArn: String,
        workspaceId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> UpdateLoggingConfigurationResponse {
        let input = UpdateLoggingConfigurationRequest(
            clientToken: clientToken, 
            logGroupArn: logGroupArn, 
            workspaceId: workspaceId
        )
        return try await self.updateLoggingConfiguration(input, logger: logger)
    }

    /// Updates an existing scraper. You can't use this function to update the source from which the scraper is  collecting metrics. To change the source, delete the scraper and create a new one.
    @Sendable
    @inlinable
    public func updateScraper(_ input: UpdateScraperRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> UpdateScraperResponse {
        try await self.client.execute(
            operation: "UpdateScraper", 
            path: "/scrapers/{scraperId}", 
            httpMethod: .PUT, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Updates an existing scraper. You can't use this function to update the source from which the scraper is  collecting metrics. To change the source, delete the scraper and create a new one.
    ///
    /// Parameters:
    ///   - alias: The new alias of the scraper.
    ///   - clientToken: A unique identifier that you can provide to ensure the idempotency of the request. Case-sensitive.
    ///   - destination: The new Amazon Managed Service for Prometheus workspace to send metrics to.
    ///   - roleConfiguration: The scraper role configuration for the workspace.
    ///   - scrapeConfiguration: Contains the base-64 encoded YAML configuration for the scraper.  For more information about configuring a scraper, see Using an  Amazon Web Services managed collector in the Amazon Managed Service for Prometheus  User Guide.
    ///   - scraperId: The ID of the scraper to update.
    ///   - logger: Logger use during operation
    @inlinable
    public func updateScraper(
        alias: String? = nil,
        clientToken: String? = UpdateScraperRequest.idempotencyToken(),
        destination: Destination? = nil,
        roleConfiguration: RoleConfiguration? = nil,
        scrapeConfiguration: ScrapeConfiguration? = nil,
        scraperId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> UpdateScraperResponse {
        let input = UpdateScraperRequest(
            alias: alias, 
            clientToken: clientToken, 
            destination: destination, 
            roleConfiguration: roleConfiguration, 
            scrapeConfiguration: scrapeConfiguration, 
            scraperId: scraperId
        )
        return try await self.updateScraper(input, logger: logger)
    }

    /// Updates the alias of an existing workspace.
    @Sendable
    @inlinable
    public func updateWorkspaceAlias(_ input: UpdateWorkspaceAliasRequest, logger: Logger = AWSClient.loggingDisabled) async throws {
        try await self.client.execute(
            operation: "UpdateWorkspaceAlias", 
            path: "/workspaces/{workspaceId}/alias", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Updates the alias of an existing workspace.
    ///
    /// Parameters:
    ///   - alias: The new alias for the workspace. It does not need to be unique. Amazon Managed Service for Prometheus will automatically strip any blank spaces from the beginning and end of the alias that you specify.
    ///   - clientToken: A unique identifier that you can provide to ensure the idempotency of the request. Case-sensitive.
    ///   - workspaceId: The ID of the workspace to update.
    ///   - logger: Logger use during operation
    @inlinable
    public func updateWorkspaceAlias(
        alias: String? = nil,
        clientToken: String? = UpdateWorkspaceAliasRequest.idempotencyToken(),
        workspaceId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws {
        let input = UpdateWorkspaceAliasRequest(
            alias: alias, 
            clientToken: clientToken, 
            workspaceId: workspaceId
        )
        return try await self.updateWorkspaceAlias(input, logger: logger)
    }
}

extension Amp {
    /// Initializer required by `AWSService.with(middlewares:timeout:byteBufferAllocator:options)`. You are not able to use this initializer directly as there are not public
    /// initializers for `AWSServiceConfig.Patch`. Please use `AWSService.with(middlewares:timeout:byteBufferAllocator:options)` instead.
    public init(from: Amp, patch: AWSServiceConfig.Patch) {
        self.client = from.client
        self.config = from.config.with(patch: patch)
    }
}

// MARK: Paginators

@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension Amp {
    /// Return PaginatorSequence for operation ``listRuleGroupsNamespaces(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func listRuleGroupsNamespacesPaginator(
        _ input: ListRuleGroupsNamespacesRequest,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<ListRuleGroupsNamespacesRequest, ListRuleGroupsNamespacesResponse> {
        return .init(
            input: input,
            command: self.listRuleGroupsNamespaces,
            inputKey: \ListRuleGroupsNamespacesRequest.nextToken,
            outputKey: \ListRuleGroupsNamespacesResponse.nextToken,
            logger: logger
        )
    }
    /// Return PaginatorSequence for operation ``listRuleGroupsNamespaces(_:logger:)``.
    ///
    /// - Parameters:
    ///   - maxResults: The maximum number of results to return. The default is 100.
    ///   - name: Use this parameter to filter the rule groups namespaces that are returned. Only the namespaces with names that begin with the value that you specify are returned.
    ///   - workspaceId: The ID of the workspace containing the rule groups namespaces.
    ///   - logger: Logger used for logging
    @inlinable
    public func listRuleGroupsNamespacesPaginator(
        maxResults: Int? = nil,
        name: String? = nil,
        workspaceId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) -> AWSClient.PaginatorSequence<ListRuleGroupsNamespacesRequest, ListRuleGroupsNamespacesResponse> {
        let input = ListRuleGroupsNamespacesRequest(
            maxResults: maxResults, 
            name: name, 
            workspaceId: workspaceId
        )
        return self.listRuleGroupsNamespacesPaginator(input, logger: logger)
    }

    /// Return PaginatorSequence for operation ``listScrapers(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func listScrapersPaginator(
        _ input: ListScrapersRequest,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<ListScrapersRequest, ListScrapersResponse> {
        return .init(
            input: input,
            command: self.listScrapers,
            inputKey: \ListScrapersRequest.nextToken,
            outputKey: \ListScrapersResponse.nextToken,
            logger: logger
        )
    }
    /// Return PaginatorSequence for operation ``listScrapers(_:logger:)``.
    ///
    /// - Parameters:
    ///   - filters: (Optional) A list of key-value pairs to filter the list of scrapers returned. Keys include status, sourceArn,  destinationArn, and alias. Filters on the same key are OR'd together, and filters on different keys are AND'd together. For example,  status=ACTIVE&amp;status=CREATING&amp;alias=Test, will return all scrapers that have the alias Test, and are either in status ACTIVE or CREATING. To find all active scrapers that are sending metrics to a specific Amazon Managed Service for Prometheus workspace, you would use the ARN of the workspace in a query:  status=ACTIVE&amp;destinationArn=arn:aws:aps:us-east-1:123456789012:workspace/ws-example1-1234-abcd-56ef-123456789012  If this is included, it filters the results to only the scrapers that match  the filter.
    ///   - maxResults: Optional) The maximum number of scrapers to return in one ListScrapers operation. The range is 1-1000. If you omit this parameter, the default of 100 is used.
    ///   - logger: Logger used for logging
    @inlinable
    public func listScrapersPaginator(
        filters: [String: [String]]? = nil,
        maxResults: Int? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) -> AWSClient.PaginatorSequence<ListScrapersRequest, ListScrapersResponse> {
        let input = ListScrapersRequest(
            filters: filters, 
            maxResults: maxResults
        )
        return self.listScrapersPaginator(input, logger: logger)
    }

    /// Return PaginatorSequence for operation ``listWorkspaces(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func listWorkspacesPaginator(
        _ input: ListWorkspacesRequest,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<ListWorkspacesRequest, ListWorkspacesResponse> {
        return .init(
            input: input,
            command: self.listWorkspaces,
            inputKey: \ListWorkspacesRequest.nextToken,
            outputKey: \ListWorkspacesResponse.nextToken,
            logger: logger
        )
    }
    /// Return PaginatorSequence for operation ``listWorkspaces(_:logger:)``.
    ///
    /// - Parameters:
    ///   - alias: If this is included, it filters the results to only the workspaces with names that start with the value that you specify here. Amazon Managed Service for Prometheus will automatically strip any blank spaces from the beginning and end of the alias that you specify.
    ///   - maxResults: The maximum number of workspaces to return per request. The default is 100.
    ///   - logger: Logger used for logging
    @inlinable
    public func listWorkspacesPaginator(
        alias: String? = nil,
        maxResults: Int? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) -> AWSClient.PaginatorSequence<ListWorkspacesRequest, ListWorkspacesResponse> {
        let input = ListWorkspacesRequest(
            alias: alias, 
            maxResults: maxResults
        )
        return self.listWorkspacesPaginator(input, logger: logger)
    }
}

extension Amp.ListRuleGroupsNamespacesRequest: AWSPaginateToken {
    @inlinable
    public func usingPaginationToken(_ token: String) -> Amp.ListRuleGroupsNamespacesRequest {
        return .init(
            maxResults: self.maxResults,
            name: self.name,
            nextToken: token,
            workspaceId: self.workspaceId
        )
    }
}

extension Amp.ListScrapersRequest: AWSPaginateToken {
    @inlinable
    public func usingPaginationToken(_ token: String) -> Amp.ListScrapersRequest {
        return .init(
            filters: self.filters,
            maxResults: self.maxResults,
            nextToken: token
        )
    }
}

extension Amp.ListWorkspacesRequest: AWSPaginateToken {
    @inlinable
    public func usingPaginationToken(_ token: String) -> Amp.ListWorkspacesRequest {
        return .init(
            alias: self.alias,
            maxResults: self.maxResults,
            nextToken: token
        )
    }
}

// MARK: Waiters

@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension Amp {
    /// Waiter for operation ``describeScraper(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func waitUntilScraperActive(
        _ input: DescribeScraperRequest,
        maxWaitTime: TimeAmount? = nil,
        logger: Logger = AWSClient.loggingDisabled
    ) async throws {
        let waiter = AWSClient.Waiter<DescribeScraperRequest, _>(
            acceptors: [
                .init(state: .success, matcher: try! JMESPathMatcher("scraper.status.statusCode", expected: "ACTIVE")),
                .init(state: .failure, matcher: try! JMESPathMatcher("scraper.status.statusCode", expected: "CREATION_FAILED")),
            ],
            command: self.describeScraper
        )
        return try await self.client.waitUntil(input, waiter: waiter, maxWaitTime: maxWaitTime, logger: logger)
    }
    /// Waiter for operation ``describeScraper(_:logger:)``.
    ///
    /// - Parameters:
    ///   - scraperId: The ID of the scraper to describe.
    ///   - logger: Logger used for logging
    @inlinable
    public func waitUntilScraperActive(
        scraperId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws {
        let input = DescribeScraperRequest(
            scraperId: scraperId
        )
        try await self.waitUntilScraperActive(input, logger: logger)
    }

    /// Waiter for operation ``describeScraper(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func waitUntilScraperDeleted(
        _ input: DescribeScraperRequest,
        maxWaitTime: TimeAmount? = nil,
        logger: Logger = AWSClient.loggingDisabled
    ) async throws {
        let waiter = AWSClient.Waiter<DescribeScraperRequest, _>(
            acceptors: [
                .init(state: .success, matcher: AWSErrorCodeMatcher("ResourceNotFoundException")),
                .init(state: .failure, matcher: try! JMESPathMatcher("scraper.status.statusCode", expected: "DELETION_FAILED")),
            ],
            command: self.describeScraper
        )
        return try await self.client.waitUntil(input, waiter: waiter, maxWaitTime: maxWaitTime, logger: logger)
    }
    /// Waiter for operation ``describeScraper(_:logger:)``.
    ///
    /// - Parameters:
    ///   - scraperId: The ID of the scraper to describe.
    ///   - logger: Logger used for logging
    @inlinable
    public func waitUntilScraperDeleted(
        scraperId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws {
        let input = DescribeScraperRequest(
            scraperId: scraperId
        )
        try await self.waitUntilScraperDeleted(input, logger: logger)
    }

    /// Waiter for operation ``describeWorkspace(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func waitUntilWorkspaceActive(
        _ input: DescribeWorkspaceRequest,
        maxWaitTime: TimeAmount? = nil,
        logger: Logger = AWSClient.loggingDisabled
    ) async throws {
        let waiter = AWSClient.Waiter<DescribeWorkspaceRequest, _>(
            acceptors: [
                .init(state: .success, matcher: try! JMESPathMatcher("workspace.status.statusCode", expected: "ACTIVE")),
                .init(state: .retry, matcher: try! JMESPathMatcher("workspace.status.statusCode", expected: "UPDATING")),
                .init(state: .retry, matcher: try! JMESPathMatcher("workspace.status.statusCode", expected: "CREATING")),
            ],
            command: self.describeWorkspace
        )
        return try await self.client.waitUntil(input, waiter: waiter, maxWaitTime: maxWaitTime, logger: logger)
    }
    /// Waiter for operation ``describeWorkspace(_:logger:)``.
    ///
    /// - Parameters:
    ///   - workspaceId: The ID of the workspace to describe.
    ///   - logger: Logger used for logging
    @inlinable
    public func waitUntilWorkspaceActive(
        workspaceId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws {
        let input = DescribeWorkspaceRequest(
            workspaceId: workspaceId
        )
        try await self.waitUntilWorkspaceActive(input, logger: logger)
    }

    /// Waiter for operation ``describeWorkspace(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func waitUntilWorkspaceDeleted(
        _ input: DescribeWorkspaceRequest,
        maxWaitTime: TimeAmount? = nil,
        logger: Logger = AWSClient.loggingDisabled
    ) async throws {
        let waiter = AWSClient.Waiter<DescribeWorkspaceRequest, _>(
            acceptors: [
                .init(state: .success, matcher: AWSErrorCodeMatcher("ResourceNotFoundException")),
                .init(state: .retry, matcher: try! JMESPathMatcher("workspace.status.statusCode", expected: "DELETING")),
            ],
            command: self.describeWorkspace
        )
        return try await self.client.waitUntil(input, waiter: waiter, maxWaitTime: maxWaitTime, logger: logger)
    }
    /// Waiter for operation ``describeWorkspace(_:logger:)``.
    ///
    /// - Parameters:
    ///   - workspaceId: The ID of the workspace to describe.
    ///   - logger: Logger used for logging
    @inlinable
    public func waitUntilWorkspaceDeleted(
        workspaceId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws {
        let input = DescribeWorkspaceRequest(
            workspaceId: workspaceId
        )
        try await self.waitUntilWorkspaceDeleted(input, logger: logger)
    }
}
