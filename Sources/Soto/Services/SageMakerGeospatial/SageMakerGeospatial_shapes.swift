//===----------------------------------------------------------------------===//
//
// This source file is part of the Soto for AWS open source project
//
// Copyright (c) 2017-2024 the Soto project authors
// Licensed under Apache License v2.0
//
// See LICENSE.txt for license information
// See CONTRIBUTORS.txt for the list of Soto project authors
//
// SPDX-License-Identifier: Apache-2.0
//
//===----------------------------------------------------------------------===//

// THIS FILE IS AUTOMATICALLY GENERATED by https://github.com/soto-project/soto-codegenerator.
// DO NOT EDIT.

#if canImport(FoundationEssentials)
import FoundationEssentials
#else
import Foundation
#endif
@_spi(SotoInternal) import SotoCore

extension SageMakerGeospatial {
    // MARK: Enums

    public enum AlgorithmNameCloudRemoval: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        /// INTERPOLATION
        case interpolation = "INTERPOLATION"
        public var description: String { return self.rawValue }
    }

    public enum AlgorithmNameGeoMosaic: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        /// AVERAGE
        case average = "AVERAGE"
        /// BILINEAR
        case bilinear = "BILINEAR"
        /// CUBIC
        case cubic = "CUBIC"
        /// CUBICSPLINE
        case cubicspline = "CUBICSPLINE"
        /// LANCZOS
        case lanczos = "LANCZOS"
        /// MAX
        case max = "MAX"
        /// MED
        case med = "MED"
        /// MIN
        case min = "MIN"
        /// MODE
        case mode = "MODE"
        /// NEAR
        case near = "NEAR"
        /// Q1
        case q1 = "Q1"
        /// Q3
        case q3 = "Q3"
        /// RMS
        case rms = "RMS"
        /// SUM
        case sum = "SUM"
        public var description: String { return self.rawValue }
    }

    public enum AlgorithmNameResampling: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        /// AVERAGE
        case average = "AVERAGE"
        /// BILINEAR
        case bilinear = "BILINEAR"
        /// CUBIC
        case cubic = "CUBIC"
        /// CUBICSPLINE
        case cubicspline = "CUBICSPLINE"
        /// LANCZOS
        case lanczos = "LANCZOS"
        /// MAX
        case max = "MAX"
        /// MED
        case med = "MED"
        /// MIN
        case min = "MIN"
        /// MODE
        case mode = "MODE"
        /// NEAR
        case near = "NEAR"
        /// Q1
        case q1 = "Q1"
        /// Q3
        case q3 = "Q3"
        /// RMS
        case rms = "RMS"
        /// SUM
        case sum = "SUM"
        public var description: String { return self.rawValue }
    }

    public enum ComparisonOperator: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        /// EQUALS
        case equals = "EQUALS"
        /// NOT_EQUALS
        case notEquals = "NOT_EQUALS"
        /// STARTS_WITH
        case startsWith = "STARTS_WITH"
        public var description: String { return self.rawValue }
    }

    public enum DataCollectionType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        /// PREMIUM
        case premium = "PREMIUM"
        /// PUBLIC
        case `public` = "PUBLIC"
        /// USER
        case user = "USER"
        public var description: String { return self.rawValue }
    }

    public enum EarthObservationJobErrorType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        /// CLIENT_ERROR
        case clientError = "CLIENT_ERROR"
        /// SERVER_ERROR
        case serverError = "SERVER_ERROR"
        public var description: String { return self.rawValue }
    }

    public enum EarthObservationJobExportStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        /// FAILED
        case failed = "FAILED"
        /// IN_PROGRESS
        case inProgress = "IN_PROGRESS"
        /// SUCCEEDED
        case succeeded = "SUCCEEDED"
        public var description: String { return self.rawValue }
    }

    public enum EarthObservationJobStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        /// COMPLETED
        case completed = "COMPLETED"
        /// DELETED
        case deleted = "DELETED"
        /// DELETING
        case deleting = "DELETING"
        /// FAILED
        case failed = "FAILED"
        /// INITIALIZING
        case initializing = "INITIALIZING"
        /// IN_PROGRESS
        case inProgress = "IN_PROGRESS"
        /// STOPPED
        case stopped = "STOPPED"
        /// STOPPING
        case stopping = "STOPPING"
        public var description: String { return self.rawValue }
    }

    public enum ExportErrorType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        /// CLIENT_ERROR
        case clientError = "CLIENT_ERROR"
        /// SERVER_ERROR
        case serverError = "SERVER_ERROR"
        public var description: String { return self.rawValue }
    }

    public enum GroupBy: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        /// ALL
        case all = "ALL"
        /// YEARLY
        case yearly = "YEARLY"
        public var description: String { return self.rawValue }
    }

    public enum LogicalOperator: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        /// AND
        case and = "AND"
        public var description: String { return self.rawValue }
    }

    public enum OutputType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        /// FLOAT32
        case float32 = "FLOAT32"
        /// FLOAT64
        case float64 = "FLOAT64"
        /// INT16
        case int16 = "INT16"
        /// INT32
        case int32 = "INT32"
        /// UINT16
        case uint16 = "UINT16"
        public var description: String { return self.rawValue }
    }

    public enum PredefinedResolution: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        /// AVERAGE
        case average = "AVERAGE"
        /// HIGHEST
        case highest = "HIGHEST"
        /// LOWEST
        case lowest = "LOWEST"
        public var description: String { return self.rawValue }
    }

    public enum SortOrder: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        /// ASCENDING
        case ascending = "ASCENDING"
        /// DESCENDING
        case descending = "DESCENDING"
        public var description: String { return self.rawValue }
    }

    public enum TargetOptions: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        /// INPUT
        case input = "INPUT"
        /// OUTPUT
        case output = "OUTPUT"
        public var description: String { return self.rawValue }
    }

    public enum TemporalStatistics: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        /// MEAN
        case mean = "MEAN"
        /// MEDIAN
        case median = "MEDIAN"
        /// STANDARD_DEVIATION
        case standardDeviation = "STANDARD_DEVIATION"
        public var description: String { return self.rawValue }
    }

    public enum Unit: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        /// METERS
        case meters = "METERS"
        public var description: String { return self.rawValue }
    }

    public enum VectorEnrichmentJobDocumentType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case csv = "CSV"
        public var description: String { return self.rawValue }
    }

    public enum VectorEnrichmentJobErrorType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        /// CLIENT_ERROR
        case clientError = "CLIENT_ERROR"
        /// SERVER_ERROR
        case serverError = "SERVER_ERROR"
        public var description: String { return self.rawValue }
    }

    public enum VectorEnrichmentJobExportErrorType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case clientError = "CLIENT_ERROR"
        case serverError = "SERVER_ERROR"
        public var description: String { return self.rawValue }
    }

    public enum VectorEnrichmentJobExportStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case failed = "FAILED"
        case inProgress = "IN_PROGRESS"
        case succeeded = "SUCCEEDED"
        public var description: String { return self.rawValue }
    }

    public enum VectorEnrichmentJobStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case completed = "COMPLETED"
        case deleted = "DELETED"
        case deleting = "DELETING"
        case failed = "FAILED"
        case initializing = "INITIALIZING"
        case inProgress = "IN_PROGRESS"
        case stopped = "STOPPED"
        case stopping = "STOPPING"
        public var description: String { return self.rawValue }
    }

    public enum VectorEnrichmentJobType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case mapMatching = "MAP_MATCHING"
        case reverseGeocoding = "REVERSE_GEOCODING"
        public var description: String { return self.rawValue }
    }

    public enum ZonalStatistics: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        /// MAX
        case max = "MAX"
        /// MEAN
        case mean = "MEAN"
        /// MEDIAN
        case median = "MEDIAN"
        /// MIN
        case min = "MIN"
        /// STANDARD_DEVIATION
        case standardDeviation = "STANDARD_DEVIATION"
        /// SUM
        case sum = "SUM"
        public var description: String { return self.rawValue }
    }

    public enum AreaOfInterestGeometry: AWSEncodableShape & AWSDecodableShape, Sendable {
        /// The structure representing the MultiPolygon Geometry.
        case multiPolygonGeometry(MultiPolygonGeometryInput)
        /// The structure representing Polygon Geometry.
        case polygonGeometry(PolygonGeometryInput)

        public init(from decoder: Decoder) throws {
            let container = try decoder.container(keyedBy: CodingKeys.self)
            guard container.allKeys.count == 1, let key = container.allKeys.first else {
                let context = DecodingError.Context(
                    codingPath: container.codingPath,
                    debugDescription: "Expected exactly one key, but got \(container.allKeys.count)"
                )
                throw DecodingError.dataCorrupted(context)
            }
            switch key {
            case .multiPolygonGeometry:
                let value = try container.decode(MultiPolygonGeometryInput.self, forKey: .multiPolygonGeometry)
                self = .multiPolygonGeometry(value)
            case .polygonGeometry:
                let value = try container.decode(PolygonGeometryInput.self, forKey: .polygonGeometry)
                self = .polygonGeometry(value)
            }
        }

        public func encode(to encoder: Encoder) throws {
            var container = encoder.container(keyedBy: CodingKeys.self)
            switch self {
            case .multiPolygonGeometry(let value):
                try container.encode(value, forKey: .multiPolygonGeometry)
            case .polygonGeometry(let value):
                try container.encode(value, forKey: .polygonGeometry)
            }
        }

        public func validate(name: String) throws {
            switch self {
            case .multiPolygonGeometry(let value):
                try value.validate(name: "\(name).multiPolygonGeometry")
            case .polygonGeometry(let value):
                try value.validate(name: "\(name).polygonGeometry")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case multiPolygonGeometry = "MultiPolygonGeometry"
            case polygonGeometry = "PolygonGeometry"
        }
    }

    public enum JobConfigInput: AWSEncodableShape & AWSDecodableShape, Sendable {
        /// An object containing information about the job configuration for BandMath.
        case bandMathConfig(BandMathConfigInput)
        /// An object containing information about the job configuration for cloud masking.
        case cloudMaskingConfig(CloudMaskingConfigInput)
        /// An object containing information about the job configuration for cloud removal.
        case cloudRemovalConfig(CloudRemovalConfigInput)
        /// An object containing information about the job configuration for geomosaic.
        case geoMosaicConfig(GeoMosaicConfigInput)
        /// An object containing information about the job configuration for land cover segmentation.
        case landCoverSegmentationConfig(LandCoverSegmentationConfigInput)
        /// An object containing information about the job configuration for resampling.
        case resamplingConfig(ResamplingConfigInput)
        /// An object containing information about the job configuration for a Stacking Earth Observation job.
        case stackConfig(StackConfigInput)
        /// An object containing information about the job configuration for temporal statistics.
        case temporalStatisticsConfig(TemporalStatisticsConfigInput)
        /// An object containing information about the job configuration for zonal statistics.
        case zonalStatisticsConfig(ZonalStatisticsConfigInput)

        public init(from decoder: Decoder) throws {
            let container = try decoder.container(keyedBy: CodingKeys.self)
            guard container.allKeys.count == 1, let key = container.allKeys.first else {
                let context = DecodingError.Context(
                    codingPath: container.codingPath,
                    debugDescription: "Expected exactly one key, but got \(container.allKeys.count)"
                )
                throw DecodingError.dataCorrupted(context)
            }
            switch key {
            case .bandMathConfig:
                let value = try container.decode(BandMathConfigInput.self, forKey: .bandMathConfig)
                self = .bandMathConfig(value)
            case .cloudMaskingConfig:
                let value = try container.decode(CloudMaskingConfigInput.self, forKey: .cloudMaskingConfig)
                self = .cloudMaskingConfig(value)
            case .cloudRemovalConfig:
                let value = try container.decode(CloudRemovalConfigInput.self, forKey: .cloudRemovalConfig)
                self = .cloudRemovalConfig(value)
            case .geoMosaicConfig:
                let value = try container.decode(GeoMosaicConfigInput.self, forKey: .geoMosaicConfig)
                self = .geoMosaicConfig(value)
            case .landCoverSegmentationConfig:
                let value = try container.decode(LandCoverSegmentationConfigInput.self, forKey: .landCoverSegmentationConfig)
                self = .landCoverSegmentationConfig(value)
            case .resamplingConfig:
                let value = try container.decode(ResamplingConfigInput.self, forKey: .resamplingConfig)
                self = .resamplingConfig(value)
            case .stackConfig:
                let value = try container.decode(StackConfigInput.self, forKey: .stackConfig)
                self = .stackConfig(value)
            case .temporalStatisticsConfig:
                let value = try container.decode(TemporalStatisticsConfigInput.self, forKey: .temporalStatisticsConfig)
                self = .temporalStatisticsConfig(value)
            case .zonalStatisticsConfig:
                let value = try container.decode(ZonalStatisticsConfigInput.self, forKey: .zonalStatisticsConfig)
                self = .zonalStatisticsConfig(value)
            }
        }

        public func encode(to encoder: Encoder) throws {
            var container = encoder.container(keyedBy: CodingKeys.self)
            switch self {
            case .bandMathConfig(let value):
                try container.encode(value, forKey: .bandMathConfig)
            case .cloudMaskingConfig(let value):
                try container.encode(value, forKey: .cloudMaskingConfig)
            case .cloudRemovalConfig(let value):
                try container.encode(value, forKey: .cloudRemovalConfig)
            case .geoMosaicConfig(let value):
                try container.encode(value, forKey: .geoMosaicConfig)
            case .landCoverSegmentationConfig(let value):
                try container.encode(value, forKey: .landCoverSegmentationConfig)
            case .resamplingConfig(let value):
                try container.encode(value, forKey: .resamplingConfig)
            case .stackConfig(let value):
                try container.encode(value, forKey: .stackConfig)
            case .temporalStatisticsConfig(let value):
                try container.encode(value, forKey: .temporalStatisticsConfig)
            case .zonalStatisticsConfig(let value):
                try container.encode(value, forKey: .zonalStatisticsConfig)
            }
        }

        public func validate(name: String) throws {
            switch self {
            case .bandMathConfig(let value):
                try value.validate(name: "\(name).bandMathConfig")
            case .cloudRemovalConfig(let value):
                try value.validate(name: "\(name).cloudRemovalConfig")
            case .geoMosaicConfig(let value):
                try value.validate(name: "\(name).geoMosaicConfig")
            case .resamplingConfig(let value):
                try value.validate(name: "\(name).resamplingConfig")
            case .stackConfig(let value):
                try value.validate(name: "\(name).stackConfig")
            case .temporalStatisticsConfig(let value):
                try value.validate(name: "\(name).temporalStatisticsConfig")
            case .zonalStatisticsConfig(let value):
                try value.validate(name: "\(name).zonalStatisticsConfig")
            default:
                break
            }
        }

        private enum CodingKeys: String, CodingKey {
            case bandMathConfig = "BandMathConfig"
            case cloudMaskingConfig = "CloudMaskingConfig"
            case cloudRemovalConfig = "CloudRemovalConfig"
            case geoMosaicConfig = "GeoMosaicConfig"
            case landCoverSegmentationConfig = "LandCoverSegmentationConfig"
            case resamplingConfig = "ResamplingConfig"
            case stackConfig = "StackConfig"
            case temporalStatisticsConfig = "TemporalStatisticsConfig"
            case zonalStatisticsConfig = "ZonalStatisticsConfig"
        }
    }

    public enum Property: AWSEncodableShape & AWSDecodableShape, Sendable {
        /// The structure representing EoCloudCover property filter containing a lower bound and upper bound.
        case eoCloudCover(EoCloudCoverInput)
        /// The structure representing Land Cloud Cover property filter  for Landsat collection containing a lower bound and upper bound.
        case landsatCloudCoverLand(LandsatCloudCoverLandInput)
        /// The structure representing Platform property filter consisting of value and comparison operator.
        case platform(PlatformInput)
        /// The structure representing ViewOffNadir property filter containing a lower bound and upper bound.
        case viewOffNadir(ViewOffNadirInput)
        /// The structure representing ViewSunAzimuth property filter containing a lower bound and upper bound.
        case viewSunAzimuth(ViewSunAzimuthInput)
        /// The structure representing ViewSunElevation property filter containing a lower bound and upper bound.
        case viewSunElevation(ViewSunElevationInput)

        public init(from decoder: Decoder) throws {
            let container = try decoder.container(keyedBy: CodingKeys.self)
            guard container.allKeys.count == 1, let key = container.allKeys.first else {
                let context = DecodingError.Context(
                    codingPath: container.codingPath,
                    debugDescription: "Expected exactly one key, but got \(container.allKeys.count)"
                )
                throw DecodingError.dataCorrupted(context)
            }
            switch key {
            case .eoCloudCover:
                let value = try container.decode(EoCloudCoverInput.self, forKey: .eoCloudCover)
                self = .eoCloudCover(value)
            case .landsatCloudCoverLand:
                let value = try container.decode(LandsatCloudCoverLandInput.self, forKey: .landsatCloudCoverLand)
                self = .landsatCloudCoverLand(value)
            case .platform:
                let value = try container.decode(PlatformInput.self, forKey: .platform)
                self = .platform(value)
            case .viewOffNadir:
                let value = try container.decode(ViewOffNadirInput.self, forKey: .viewOffNadir)
                self = .viewOffNadir(value)
            case .viewSunAzimuth:
                let value = try container.decode(ViewSunAzimuthInput.self, forKey: .viewSunAzimuth)
                self = .viewSunAzimuth(value)
            case .viewSunElevation:
                let value = try container.decode(ViewSunElevationInput.self, forKey: .viewSunElevation)
                self = .viewSunElevation(value)
            }
        }

        public func encode(to encoder: Encoder) throws {
            var container = encoder.container(keyedBy: CodingKeys.self)
            switch self {
            case .eoCloudCover(let value):
                try container.encode(value, forKey: .eoCloudCover)
            case .landsatCloudCoverLand(let value):
                try container.encode(value, forKey: .landsatCloudCoverLand)
            case .platform(let value):
                try container.encode(value, forKey: .platform)
            case .viewOffNadir(let value):
                try container.encode(value, forKey: .viewOffNadir)
            case .viewSunAzimuth(let value):
                try container.encode(value, forKey: .viewSunAzimuth)
            case .viewSunElevation(let value):
                try container.encode(value, forKey: .viewSunElevation)
            }
        }

        private enum CodingKeys: String, CodingKey {
            case eoCloudCover = "EoCloudCover"
            case landsatCloudCoverLand = "LandsatCloudCoverLand"
            case platform = "Platform"
            case viewOffNadir = "ViewOffNadir"
            case viewSunAzimuth = "ViewSunAzimuth"
            case viewSunElevation = "ViewSunElevation"
        }
    }

    public enum VectorEnrichmentJobConfig: AWSEncodableShape & AWSDecodableShape, Sendable {
        /// The input structure for Map Matching operation type.
        case mapMatchingConfig(MapMatchingConfig)
        /// The input structure for Reverse Geocoding operation type.
        case reverseGeocodingConfig(ReverseGeocodingConfig)

        public init(from decoder: Decoder) throws {
            let container = try decoder.container(keyedBy: CodingKeys.self)
            guard container.allKeys.count == 1, let key = container.allKeys.first else {
                let context = DecodingError.Context(
                    codingPath: container.codingPath,
                    debugDescription: "Expected exactly one key, but got \(container.allKeys.count)"
                )
                throw DecodingError.dataCorrupted(context)
            }
            switch key {
            case .mapMatchingConfig:
                let value = try container.decode(MapMatchingConfig.self, forKey: .mapMatchingConfig)
                self = .mapMatchingConfig(value)
            case .reverseGeocodingConfig:
                let value = try container.decode(ReverseGeocodingConfig.self, forKey: .reverseGeocodingConfig)
                self = .reverseGeocodingConfig(value)
            }
        }

        public func encode(to encoder: Encoder) throws {
            var container = encoder.container(keyedBy: CodingKeys.self)
            switch self {
            case .mapMatchingConfig(let value):
                try container.encode(value, forKey: .mapMatchingConfig)
            case .reverseGeocodingConfig(let value):
                try container.encode(value, forKey: .reverseGeocodingConfig)
            }
        }

        private enum CodingKeys: String, CodingKey {
            case mapMatchingConfig = "MapMatchingConfig"
            case reverseGeocodingConfig = "ReverseGeocodingConfig"
        }
    }

    // MARK: Shapes

    public struct AssetValue: AWSDecodableShape {
        /// Link to the asset object.
        public let href: String?

        @inlinable
        public init(href: String? = nil) {
            self.href = href
        }

        private enum CodingKeys: String, CodingKey {
            case href = "Href"
        }
    }

    public struct BandMathConfigInput: AWSEncodableShape & AWSDecodableShape {
        /// CustomIndices that are computed.
        public let customIndices: CustomIndicesInput?
        /// One or many of the supported predefined indices to compute.  Allowed values: NDVI, EVI2, MSAVI,  NDWI, NDMI, NDSI, and WDRVI.
        public let predefinedIndices: [String]?

        @inlinable
        public init(customIndices: CustomIndicesInput? = nil, predefinedIndices: [String]? = nil) {
            self.customIndices = customIndices
            self.predefinedIndices = predefinedIndices
        }

        public func validate(name: String) throws {
            try self.customIndices?.validate(name: "\(name).customIndices")
            try self.validate(self.predefinedIndices, name: "predefinedIndices", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case customIndices = "CustomIndices"
            case predefinedIndices = "PredefinedIndices"
        }
    }

    public struct CloudMaskingConfigInput: AWSEncodableShape & AWSDecodableShape {
        public init() {}
    }

    public struct CloudRemovalConfigInput: AWSEncodableShape & AWSDecodableShape {
        /// The name of the algorithm used for cloud removal.
        public let algorithmName: AlgorithmNameCloudRemoval?
        /// The interpolation value you provide for cloud removal.
        public let interpolationValue: String?
        /// TargetBands to be returned in the output of CloudRemoval operation.
        public let targetBands: [String]?

        @inlinable
        public init(algorithmName: AlgorithmNameCloudRemoval? = nil, interpolationValue: String? = nil, targetBands: [String]? = nil) {
            self.algorithmName = algorithmName
            self.interpolationValue = interpolationValue
            self.targetBands = targetBands
        }

        public func validate(name: String) throws {
            try self.validate(self.targetBands, name: "targetBands", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case algorithmName = "AlgorithmName"
            case interpolationValue = "InterpolationValue"
            case targetBands = "TargetBands"
        }
    }

    public struct ConflictException: AWSErrorShape {
        public let message: String
        /// Identifier of the resource affected.
        public let resourceId: String?

        @inlinable
        public init(message: String, resourceId: String? = nil) {
            self.message = message
            self.resourceId = resourceId
        }

        private enum CodingKeys: String, CodingKey {
            case message = "Message"
            case resourceId = "ResourceId"
        }
    }

    public struct CustomIndicesInput: AWSEncodableShape & AWSDecodableShape {
        /// A list of BandMath indices to compute.
        public let operations: [Operation]?

        @inlinable
        public init(operations: [Operation]? = nil) {
            self.operations = operations
        }

        public func validate(name: String) throws {
            try self.validate(self.operations, name: "operations", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case operations = "Operations"
        }
    }

    public struct DeleteEarthObservationJobInput: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the Earth Observation job being deleted.
        public let arn: String

        @inlinable
        public init(arn: String) {
            self.arn = arn
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.arn, key: "Arn")
        }

        public func validate(name: String) throws {
            try self.validate(self.arn, name: "arn", parent: name, pattern: "^arn:aws[a-z-]{0,12}:sagemaker-geospatial:[a-z0-9-]{1,25}:[0-9]{12}:earth-observation-job/[a-z0-9]{12,}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteEarthObservationJobOutput: AWSDecodableShape {
        public init() {}
    }

    public struct DeleteVectorEnrichmentJobInput: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the Vector Enrichment job being deleted.
        public let arn: String

        @inlinable
        public init(arn: String) {
            self.arn = arn
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.arn, key: "Arn")
        }

        public func validate(name: String) throws {
            try self.validate(self.arn, name: "arn", parent: name, pattern: "^arn:aws[a-z-]{0,12}:sagemaker-geospatial:[a-z0-9-]{1,25}:[0-9]{12}:vector-enrichment-job/[a-z0-9]{12,}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteVectorEnrichmentJobOutput: AWSDecodableShape {
        public init() {}
    }

    public struct EarthObservationJobErrorDetails: AWSDecodableShape {
        /// A detailed message describing the error in an Earth Observation job.
        public let message: String?
        /// The type of error in an Earth Observation job.
        public let type: EarthObservationJobErrorType?

        @inlinable
        public init(message: String? = nil, type: EarthObservationJobErrorType? = nil) {
            self.message = message
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case message = "Message"
            case type = "Type"
        }
    }

    public struct EoCloudCoverInput: AWSEncodableShape & AWSDecodableShape {
        /// Lower bound for EoCloudCover.
        public let lowerBound: Float
        /// Upper bound for EoCloudCover.
        public let upperBound: Float

        @inlinable
        public init(lowerBound: Float, upperBound: Float) {
            self.lowerBound = lowerBound
            self.upperBound = upperBound
        }

        private enum CodingKeys: String, CodingKey {
            case lowerBound = "LowerBound"
            case upperBound = "UpperBound"
        }
    }

    public struct ExportEarthObservationJobInput: AWSEncodableShape {
        /// The input Amazon Resource Name (ARN) of the Earth Observation job being exported.
        public let arn: String
        /// A unique token that guarantees that the call to this API is idempotent.
        public let clientToken: String?
        /// The Amazon Resource Name (ARN) of the IAM role that you specified for the job.
        public let executionRoleArn: String
        /// The source images provided to the Earth Observation job being exported.
        public let exportSourceImages: Bool?
        /// An object containing information about the output file.
        public let outputConfig: OutputConfigInput

        @inlinable
        public init(arn: String, clientToken: String? = ExportEarthObservationJobInput.idempotencyToken(), executionRoleArn: String, exportSourceImages: Bool? = nil, outputConfig: OutputConfigInput) {
            self.arn = arn
            self.clientToken = clientToken
            self.executionRoleArn = executionRoleArn
            self.exportSourceImages = exportSourceImages
            self.outputConfig = outputConfig
        }

        public func validate(name: String) throws {
            try self.validate(self.arn, name: "arn", parent: name, pattern: "^arn:aws[a-z-]{0,12}:sagemaker-geospatial:[a-z0-9-]{1,25}:[0-9]{12}:earth-observation-job/[a-z0-9]{12,}$")
            try self.validate(self.executionRoleArn, name: "executionRoleArn", parent: name, max: 2048)
            try self.validate(self.executionRoleArn, name: "executionRoleArn", parent: name, min: 20)
            try self.validate(self.executionRoleArn, name: "executionRoleArn", parent: name, pattern: "^arn:(aws[a-z-]*):iam::([0-9]{12}):role/[a-zA-Z0-9+=,.@_/-]+$")
            try self.outputConfig.validate(name: "\(name).outputConfig")
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case clientToken = "ClientToken"
            case executionRoleArn = "ExecutionRoleArn"
            case exportSourceImages = "ExportSourceImages"
            case outputConfig = "OutputConfig"
        }
    }

    public struct ExportEarthObservationJobOutput: AWSDecodableShape {
        /// The output Amazon Resource Name (ARN) of the Earth Observation job being exported.
        public let arn: String
        /// The creation time.
        public let creationTime: Date
        /// The Amazon Resource Name (ARN) of the IAM role that you specified for the job.
        public let executionRoleArn: String
        /// The source images provided to the Earth Observation job being exported.
        public let exportSourceImages: Bool?
        /// The status of the results of the Earth Observation job being exported.
        public let exportStatus: EarthObservationJobExportStatus
        /// An object containing information about the output file.
        public let outputConfig: OutputConfigInput

        @inlinable
        public init(arn: String, creationTime: Date, executionRoleArn: String, exportSourceImages: Bool? = nil, exportStatus: EarthObservationJobExportStatus, outputConfig: OutputConfigInput) {
            self.arn = arn
            self.creationTime = creationTime
            self.executionRoleArn = executionRoleArn
            self.exportSourceImages = exportSourceImages
            self.exportStatus = exportStatus
            self.outputConfig = outputConfig
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case creationTime = "CreationTime"
            case executionRoleArn = "ExecutionRoleArn"
            case exportSourceImages = "ExportSourceImages"
            case exportStatus = "ExportStatus"
            case outputConfig = "OutputConfig"
        }
    }

    public struct ExportErrorDetails: AWSDecodableShape {
        /// The structure for returning the export error details while exporting results of an Earth Observation job.
        public let exportResults: ExportErrorDetailsOutput?
        /// The structure for returning the export error details  while exporting the source images of an Earth Observation job.
        public let exportSourceImages: ExportErrorDetailsOutput?

        @inlinable
        public init(exportResults: ExportErrorDetailsOutput? = nil, exportSourceImages: ExportErrorDetailsOutput? = nil) {
            self.exportResults = exportResults
            self.exportSourceImages = exportSourceImages
        }

        private enum CodingKeys: String, CodingKey {
            case exportResults = "ExportResults"
            case exportSourceImages = "ExportSourceImages"
        }
    }

    public struct ExportErrorDetailsOutput: AWSDecodableShape {
        /// A detailed message describing the error in an export EarthObservationJob operation.
        public let message: String?
        /// The type of error in an export EarthObservationJob operation.
        public let type: ExportErrorType?

        @inlinable
        public init(message: String? = nil, type: ExportErrorType? = nil) {
            self.message = message
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case message = "Message"
            case type = "Type"
        }
    }

    public struct ExportS3DataInput: AWSEncodableShape & AWSDecodableShape {
        /// The Key Management Service key ID for server-side encryption.
        public let kmsKeyId: String?
        /// The URL to the Amazon S3 data input.
        public let s3Uri: String

        @inlinable
        public init(kmsKeyId: String? = nil, s3Uri: String) {
            self.kmsKeyId = kmsKeyId
            self.s3Uri = s3Uri
        }

        public func validate(name: String) throws {
            try self.validate(self.kmsKeyId, name: "kmsKeyId", parent: name, max: 2048)
            try self.validate(self.s3Uri, name: "s3Uri", parent: name, pattern: "^s3://([^/]+)/?(.*)$")
        }

        private enum CodingKeys: String, CodingKey {
            case kmsKeyId = "KmsKeyId"
            case s3Uri = "S3Uri"
        }
    }

    public struct ExportVectorEnrichmentJobInput: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the Vector Enrichment job.
        public let arn: String
        /// A unique token that guarantees that the call to this API is idempotent.
        public let clientToken: String?
        /// The Amazon Resource Name (ARN) of the IAM rolewith permission to upload to the location in OutputConfig.
        public let executionRoleArn: String
        /// Output location information for exporting Vector Enrichment Job results.
        public let outputConfig: ExportVectorEnrichmentJobOutputConfig

        @inlinable
        public init(arn: String, clientToken: String? = ExportVectorEnrichmentJobInput.idempotencyToken(), executionRoleArn: String, outputConfig: ExportVectorEnrichmentJobOutputConfig) {
            self.arn = arn
            self.clientToken = clientToken
            self.executionRoleArn = executionRoleArn
            self.outputConfig = outputConfig
        }

        public func validate(name: String) throws {
            try self.validate(self.arn, name: "arn", parent: name, pattern: "^arn:aws[a-z-]{0,12}:sagemaker-geospatial:[a-z0-9-]{1,25}:[0-9]{12}:vector-enrichment-job/[a-z0-9]{12,}$")
            try self.validate(self.executionRoleArn, name: "executionRoleArn", parent: name, max: 2048)
            try self.validate(self.executionRoleArn, name: "executionRoleArn", parent: name, min: 20)
            try self.validate(self.executionRoleArn, name: "executionRoleArn", parent: name, pattern: "^arn:(aws[a-z-]*):iam::([0-9]{12}):role/[a-zA-Z0-9+=,.@_/-]+$")
            try self.outputConfig.validate(name: "\(name).outputConfig")
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case clientToken = "ClientToken"
            case executionRoleArn = "ExecutionRoleArn"
            case outputConfig = "OutputConfig"
        }
    }

    public struct ExportVectorEnrichmentJobOutput: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the Vector Enrichment job being exported.
        public let arn: String
        /// The creation time.
        public let creationTime: Date
        /// The Amazon Resource Name (ARN) of the IAM role with permission to upload to the location in OutputConfig.
        public let executionRoleArn: String
        /// The status of the results the Vector Enrichment job being exported.
        public let exportStatus: VectorEnrichmentJobExportStatus
        /// Output location information for exporting Vector Enrichment Job results.
        public let outputConfig: ExportVectorEnrichmentJobOutputConfig

        @inlinable
        public init(arn: String, creationTime: Date, executionRoleArn: String, exportStatus: VectorEnrichmentJobExportStatus, outputConfig: ExportVectorEnrichmentJobOutputConfig) {
            self.arn = arn
            self.creationTime = creationTime
            self.executionRoleArn = executionRoleArn
            self.exportStatus = exportStatus
            self.outputConfig = outputConfig
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case creationTime = "CreationTime"
            case executionRoleArn = "ExecutionRoleArn"
            case exportStatus = "ExportStatus"
            case outputConfig = "OutputConfig"
        }
    }

    public struct ExportVectorEnrichmentJobOutputConfig: AWSEncodableShape & AWSDecodableShape {
        /// The input structure for Amazon S3 data; representing the Amazon S3 location of the input data objects.
        public let s3Data: VectorEnrichmentJobS3Data

        @inlinable
        public init(s3Data: VectorEnrichmentJobS3Data) {
            self.s3Data = s3Data
        }

        public func validate(name: String) throws {
            try self.s3Data.validate(name: "\(name).s3Data")
        }

        private enum CodingKeys: String, CodingKey {
            case s3Data = "S3Data"
        }
    }

    public struct Filter: AWSDecodableShape {
        /// The maximum value of the filter.
        public let maximum: Float?
        /// The minimum value of the filter.
        public let minimum: Float?
        /// The name of the filter.
        public let name: String
        /// The type of the filter being used.
        public let type: String

        @inlinable
        public init(maximum: Float? = nil, minimum: Float? = nil, name: String, type: String) {
            self.maximum = maximum
            self.minimum = minimum
            self.name = name
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case maximum = "Maximum"
            case minimum = "Minimum"
            case name = "Name"
            case type = "Type"
        }
    }

    public struct GeoMosaicConfigInput: AWSEncodableShape & AWSDecodableShape {
        /// The name of the algorithm being used for geomosaic.
        public let algorithmName: AlgorithmNameGeoMosaic?
        /// The target bands for geomosaic.
        public let targetBands: [String]?

        @inlinable
        public init(algorithmName: AlgorithmNameGeoMosaic? = nil, targetBands: [String]? = nil) {
            self.algorithmName = algorithmName
            self.targetBands = targetBands
        }

        public func validate(name: String) throws {
            try self.validate(self.targetBands, name: "targetBands", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case algorithmName = "AlgorithmName"
            case targetBands = "TargetBands"
        }
    }

    public struct Geometry: AWSDecodableShape {
        /// The coordinates of the GeoJson Geometry.
        public let coordinates: [[[Double]]]
        /// GeoJson Geometry types like Polygon and MultiPolygon.
        public let type: String

        @inlinable
        public init(coordinates: [[[Double]]], type: String) {
            self.coordinates = coordinates
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case coordinates = "Coordinates"
            case type = "Type"
        }
    }

    public struct GetEarthObservationJobInput: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the Earth Observation job.
        public let arn: String

        @inlinable
        public init(arn: String) {
            self.arn = arn
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.arn, key: "Arn")
        }

        public func validate(name: String) throws {
            try self.validate(self.arn, name: "arn", parent: name, pattern: "^arn:aws[a-z-]{0,12}:sagemaker-geospatial:[a-z0-9-]{1,25}:[0-9]{12}:earth-observation-job/[a-z0-9]{12,}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetEarthObservationJobOutput: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the Earth Observation job.
        public let arn: String
        /// The creation time of the initiated Earth Observation job.
        public let creationTime: Date
        /// The duration of Earth Observation job, in seconds.
        public let durationInSeconds: Int
        /// Details about the errors generated during the Earth Observation job.
        public let errorDetails: EarthObservationJobErrorDetails?
        /// The Amazon Resource Name (ARN) of the IAM role that you specified for the job.
        public let executionRoleArn: String?
        /// Details about the errors generated during ExportEarthObservationJob.
        public let exportErrorDetails: ExportErrorDetails?
        /// The status of the Earth Observation job.
        public let exportStatus: EarthObservationJobExportStatus?
        /// Input data for the Earth Observation job.
        public let inputConfig: InputConfigOutput
        /// An object containing information about the job configuration.
        public let jobConfig: JobConfigInput
        /// The Key Management Service key ID for server-side encryption.
        public let kmsKeyId: String?
        /// The name of the Earth Observation job.
        public let name: String
        /// Bands available in the output of an operation.
        public let outputBands: [OutputBand]?
        /// The status of a previously initiated Earth Observation job.
        public let status: EarthObservationJobStatus
        /// Each tag consists of a key and a value.
        public let tags: [String: String]?

        @inlinable
        public init(arn: String, creationTime: Date, durationInSeconds: Int, errorDetails: EarthObservationJobErrorDetails? = nil, executionRoleArn: String? = nil, exportErrorDetails: ExportErrorDetails? = nil, exportStatus: EarthObservationJobExportStatus? = nil, inputConfig: InputConfigOutput, jobConfig: JobConfigInput, kmsKeyId: String? = nil, name: String, outputBands: [OutputBand]? = nil, status: EarthObservationJobStatus, tags: [String: String]? = nil) {
            self.arn = arn
            self.creationTime = creationTime
            self.durationInSeconds = durationInSeconds
            self.errorDetails = errorDetails
            self.executionRoleArn = executionRoleArn
            self.exportErrorDetails = exportErrorDetails
            self.exportStatus = exportStatus
            self.inputConfig = inputConfig
            self.jobConfig = jobConfig
            self.kmsKeyId = kmsKeyId
            self.name = name
            self.outputBands = outputBands
            self.status = status
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case creationTime = "CreationTime"
            case durationInSeconds = "DurationInSeconds"
            case errorDetails = "ErrorDetails"
            case executionRoleArn = "ExecutionRoleArn"
            case exportErrorDetails = "ExportErrorDetails"
            case exportStatus = "ExportStatus"
            case inputConfig = "InputConfig"
            case jobConfig = "JobConfig"
            case kmsKeyId = "KmsKeyId"
            case name = "Name"
            case outputBands = "OutputBands"
            case status = "Status"
            case tags = "Tags"
        }
    }

    public struct GetRasterDataCollectionInput: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the raster data collection.
        public let arn: String

        @inlinable
        public init(arn: String) {
            self.arn = arn
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.arn, key: "Arn")
        }

        public func validate(name: String) throws {
            try self.validate(self.arn, name: "arn", parent: name, pattern: "^arn:aws[a-z-]{0,12}:sagemaker-geospatial:[a-z0-9-]{1,25}:[0-9]{12}:raster-data-collection/(public|premium|user)/[a-z0-9]{12,}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetRasterDataCollectionOutput: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the raster data collection.
        public let arn: String
        /// A description of the raster data collection.
        public let description: String
        /// The URL of the description page.
        public let descriptionPageUrl: String
        /// The list of image source bands in the raster data collection.
        public let imageSourceBands: [String]
        /// The name of the raster data collection.
        public let name: String
        /// The filters supported by the raster data collection.
        public let supportedFilters: [Filter]
        /// Each tag consists of a key and a value.
        public let tags: [String: String]?
        /// The raster data collection type.
        public let type: DataCollectionType

        @inlinable
        public init(arn: String, description: String, descriptionPageUrl: String, imageSourceBands: [String], name: String, supportedFilters: [Filter], tags: [String: String]? = nil, type: DataCollectionType) {
            self.arn = arn
            self.description = description
            self.descriptionPageUrl = descriptionPageUrl
            self.imageSourceBands = imageSourceBands
            self.name = name
            self.supportedFilters = supportedFilters
            self.tags = tags
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case description = "Description"
            case descriptionPageUrl = "DescriptionPageUrl"
            case imageSourceBands = "ImageSourceBands"
            case name = "Name"
            case supportedFilters = "SupportedFilters"
            case tags = "Tags"
            case type = "Type"
        }
    }

    public struct GetTileInput: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the tile operation.
        public let arn: String
        /// The Amazon Resource Name (ARN) of the IAM role that you specify.
        public let executionRoleArn: String?
        /// The particular assets or bands to tile.
        public let imageAssets: [String]
        /// Determines whether or not to return a valid data mask.
        public let imageMask: Bool?
        /// The output data type of the tile operation.
        public let outputDataType: OutputType?
        /// The data format of the output tile. The formats include .npy, .png and .jpg.
        public let outputFormat: String?
        /// Property filters for the imagery to tile.
        public let propertyFilters: String?
        /// Determines what part of the Earth Observation job to tile. 'INPUT' or 'OUTPUT' are the valid options.
        public let target: TargetOptions
        /// Time range filter applied to imagery to find the images to tile.
        public let timeRangeFilter: String?
        /// The x coordinate of the tile input.
        public let x: Int
        /// The y coordinate of the tile input.
        public let y: Int
        /// The z coordinate of the tile input.
        public let z: Int

        @inlinable
        public init(arn: String, executionRoleArn: String? = nil, imageAssets: [String], imageMask: Bool? = nil, outputDataType: OutputType? = nil, outputFormat: String? = nil, propertyFilters: String? = nil, target: TargetOptions, timeRangeFilter: String? = nil, x: Int, y: Int, z: Int) {
            self.arn = arn
            self.executionRoleArn = executionRoleArn
            self.imageAssets = imageAssets
            self.imageMask = imageMask
            self.outputDataType = outputDataType
            self.outputFormat = outputFormat
            self.propertyFilters = propertyFilters
            self.target = target
            self.timeRangeFilter = timeRangeFilter
            self.x = x
            self.y = y
            self.z = z
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.arn, key: "Arn")
            request.encodeQuery(self.executionRoleArn, key: "ExecutionRoleArn")
            request.encodeQuery(self.imageAssets, key: "ImageAssets")
            request.encodeQuery(self.imageMask, key: "ImageMask")
            request.encodeQuery(self.outputDataType, key: "OutputDataType")
            request.encodeQuery(self.outputFormat, key: "OutputFormat")
            request.encodeQuery(self.propertyFilters, key: "PropertyFilters")
            request.encodeQuery(self.target, key: "Target")
            request.encodeQuery(self.timeRangeFilter, key: "TimeRangeFilter")
            request.encodePath(self.x, key: "x")
            request.encodePath(self.y, key: "y")
            request.encodePath(self.z, key: "z")
        }

        public func validate(name: String) throws {
            try self.validate(self.arn, name: "arn", parent: name, pattern: "^arn:aws[a-z-]{0,12}:sagemaker-geospatial:[a-z0-9-]{1,25}:[0-9]{12}:earth-observation-job/[a-z0-9]{12,}$")
            try self.validate(self.executionRoleArn, name: "executionRoleArn", parent: name, max: 2048)
            try self.validate(self.executionRoleArn, name: "executionRoleArn", parent: name, min: 20)
            try self.validate(self.executionRoleArn, name: "executionRoleArn", parent: name, pattern: "^arn:(aws[a-z-]*):iam::([0-9]{12}):role/[a-zA-Z0-9+=,.@_/-]+$")
            try self.validate(self.imageAssets, name: "imageAssets", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetTileOutput: AWSDecodableShape {
        public static let _options: AWSShapeOptions = [.rawPayload]
        /// The output binary file.
        public let binaryFile: AWSHTTPBody

        @inlinable
        public init(binaryFile: AWSHTTPBody) {
            self.binaryFile = binaryFile
        }

        public init(from decoder: Decoder) throws {
            let container = try decoder.singleValueContainer()
            self.binaryFile = try container.decode(AWSHTTPBody.self)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetVectorEnrichmentJobInput: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the Vector Enrichment job.
        public let arn: String

        @inlinable
        public init(arn: String) {
            self.arn = arn
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.arn, key: "Arn")
        }

        public func validate(name: String) throws {
            try self.validate(self.arn, name: "arn", parent: name, pattern: "^arn:aws[a-z-]{0,12}:sagemaker-geospatial:[a-z0-9-]{1,25}:[0-9]{12}:vector-enrichment-job/[a-z0-9]{12,}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetVectorEnrichmentJobOutput: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the Vector Enrichment job.
        public let arn: String
        /// The creation time.
        public let creationTime: Date
        /// The duration of the Vector Enrichment job, in seconds.
        public let durationInSeconds: Int
        /// Details about the errors generated during the Vector Enrichment job.
        public let errorDetails: VectorEnrichmentJobErrorDetails?
        /// The Amazon Resource Name (ARN) of the IAM role that you specified for the job.
        public let executionRoleArn: String
        /// Details about the errors generated during the ExportVectorEnrichmentJob.
        public let exportErrorDetails: VectorEnrichmentJobExportErrorDetails?
        /// The export status of the Vector Enrichment job being initiated.
        public let exportStatus: VectorEnrichmentJobExportStatus?
        /// Input configuration information for the Vector Enrichment job.
        public let inputConfig: VectorEnrichmentJobInputConfig
        /// An object containing information about the job configuration.
        public let jobConfig: VectorEnrichmentJobConfig
        /// The Key Management Service key ID for server-side encryption.
        public let kmsKeyId: String?
        /// The name of the Vector Enrichment job.
        public let name: String
        /// The status of the initiated Vector Enrichment job.
        public let status: VectorEnrichmentJobStatus
        /// Each tag consists of a key and a value.
        public let tags: [String: String]?
        /// The type of the Vector Enrichment job being initiated.
        public let type: VectorEnrichmentJobType

        @inlinable
        public init(arn: String, creationTime: Date, durationInSeconds: Int, errorDetails: VectorEnrichmentJobErrorDetails? = nil, executionRoleArn: String, exportErrorDetails: VectorEnrichmentJobExportErrorDetails? = nil, exportStatus: VectorEnrichmentJobExportStatus? = nil, inputConfig: VectorEnrichmentJobInputConfig, jobConfig: VectorEnrichmentJobConfig, kmsKeyId: String? = nil, name: String, status: VectorEnrichmentJobStatus, tags: [String: String]? = nil, type: VectorEnrichmentJobType) {
            self.arn = arn
            self.creationTime = creationTime
            self.durationInSeconds = durationInSeconds
            self.errorDetails = errorDetails
            self.executionRoleArn = executionRoleArn
            self.exportErrorDetails = exportErrorDetails
            self.exportStatus = exportStatus
            self.inputConfig = inputConfig
            self.jobConfig = jobConfig
            self.kmsKeyId = kmsKeyId
            self.name = name
            self.status = status
            self.tags = tags
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case creationTime = "CreationTime"
            case durationInSeconds = "DurationInSeconds"
            case errorDetails = "ErrorDetails"
            case executionRoleArn = "ExecutionRoleArn"
            case exportErrorDetails = "ExportErrorDetails"
            case exportStatus = "ExportStatus"
            case inputConfig = "InputConfig"
            case jobConfig = "JobConfig"
            case kmsKeyId = "KmsKeyId"
            case name = "Name"
            case status = "Status"
            case tags = "Tags"
            case type = "Type"
        }
    }

    public struct InputConfigInput: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the previous Earth Observation job.
        public let previousEarthObservationJobArn: String?
        /// The structure representing the RasterDataCollection Query consisting of  the Area of Interest, RasterDataCollectionArn,TimeRange and Property Filters.
        public let rasterDataCollectionQuery: RasterDataCollectionQueryInput?

        @inlinable
        public init(previousEarthObservationJobArn: String? = nil, rasterDataCollectionQuery: RasterDataCollectionQueryInput? = nil) {
            self.previousEarthObservationJobArn = previousEarthObservationJobArn
            self.rasterDataCollectionQuery = rasterDataCollectionQuery
        }

        public func validate(name: String) throws {
            try self.validate(self.previousEarthObservationJobArn, name: "previousEarthObservationJobArn", parent: name, pattern: "^arn:aws[a-z-]{0,12}:sagemaker-geospatial:[a-z0-9-]{1,25}:[0-9]{12}:earth-observation-job/[a-z0-9]{12,}$")
            try self.rasterDataCollectionQuery?.validate(name: "\(name).rasterDataCollectionQuery")
        }

        private enum CodingKeys: String, CodingKey {
            case previousEarthObservationJobArn = "PreviousEarthObservationJobArn"
            case rasterDataCollectionQuery = "RasterDataCollectionQuery"
        }
    }

    public struct InputConfigOutput: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the previous Earth Observation job.
        public let previousEarthObservationJobArn: String?
        /// The structure representing the RasterDataCollection Query consisting of the Area of Interest,  RasterDataCollectionArn, RasterDataCollectionName, TimeRange, and Property Filters.
        public let rasterDataCollectionQuery: RasterDataCollectionQueryOutput?

        @inlinable
        public init(previousEarthObservationJobArn: String? = nil, rasterDataCollectionQuery: RasterDataCollectionQueryOutput? = nil) {
            self.previousEarthObservationJobArn = previousEarthObservationJobArn
            self.rasterDataCollectionQuery = rasterDataCollectionQuery
        }

        private enum CodingKeys: String, CodingKey {
            case previousEarthObservationJobArn = "PreviousEarthObservationJobArn"
            case rasterDataCollectionQuery = "RasterDataCollectionQuery"
        }
    }

    public struct InternalServerException: AWSErrorShape {
        public let message: String
        public let resourceId: String?

        @inlinable
        public init(message: String, resourceId: String? = nil) {
            self.message = message
            self.resourceId = resourceId
        }

        private enum CodingKeys: String, CodingKey {
            case message = "Message"
            case resourceId = "ResourceId"
        }
    }

    public struct ItemSource: AWSDecodableShape {
        /// This is a dictionary of Asset Objects data associated with the Item that  can be downloaded or streamed, each with a unique key.
        public let assets: [String: AssetValue]?
        /// The searchable date and time of the item, in UTC.
        public let dateTime: Date
        /// The item Geometry in GeoJson format.
        public let geometry: Geometry
        /// A unique Id for the source item.
        public let id: String
        /// This field contains additional properties of the item.
        public let properties: Properties?

        @inlinable
        public init(assets: [String: AssetValue]? = nil, dateTime: Date, geometry: Geometry, id: String, properties: Properties? = nil) {
            self.assets = assets
            self.dateTime = dateTime
            self.geometry = geometry
            self.id = id
            self.properties = properties
        }

        private enum CodingKeys: String, CodingKey {
            case assets = "Assets"
            case dateTime = "DateTime"
            case geometry = "Geometry"
            case id = "Id"
            case properties = "Properties"
        }
    }

    public struct LandCoverSegmentationConfigInput: AWSEncodableShape & AWSDecodableShape {
        public init() {}
    }

    public struct LandsatCloudCoverLandInput: AWSEncodableShape & AWSDecodableShape {
        /// The minimum value for Land Cloud Cover property filter. This will filter items  having Land Cloud Cover greater than or equal to this value.
        public let lowerBound: Float
        /// The maximum value for Land Cloud Cover property filter.  This will filter items having Land Cloud Cover less than or equal to this value.
        public let upperBound: Float

        @inlinable
        public init(lowerBound: Float, upperBound: Float) {
            self.lowerBound = lowerBound
            self.upperBound = upperBound
        }

        private enum CodingKeys: String, CodingKey {
            case lowerBound = "LowerBound"
            case upperBound = "UpperBound"
        }
    }

    public struct ListEarthObservationJobInput: AWSEncodableShape {
        /// The total number of items to return.
        public let maxResults: Int?
        /// If the previous response was truncated, you receive this token. Use it in your next request to receive the next set of results.
        public let nextToken: String?
        /// The parameter by which to sort the results.
        public let sortBy: String?
        /// An optional value that specifies whether you want the results sorted in Ascending or Descending order.
        public let sortOrder: SortOrder?
        /// A filter that retrieves only jobs with a specific status.
        public let statusEquals: EarthObservationJobStatus?

        @inlinable
        public init(maxResults: Int? = nil, nextToken: String? = nil, sortBy: String? = nil, sortOrder: SortOrder? = nil, statusEquals: EarthObservationJobStatus? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.sortBy = sortBy
            self.sortOrder = sortOrder
            self.statusEquals = statusEquals
        }

        public func validate(name: String) throws {
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 8192)
        }

        private enum CodingKeys: String, CodingKey {
            case maxResults = "MaxResults"
            case nextToken = "NextToken"
            case sortBy = "SortBy"
            case sortOrder = "SortOrder"
            case statusEquals = "StatusEquals"
        }
    }

    public struct ListEarthObservationJobOutput: AWSDecodableShape {
        /// Contains summary information about the Earth Observation jobs.
        public let earthObservationJobSummaries: [ListEarthObservationJobOutputConfig]
        /// If the previous response was truncated, you receive this token. Use it in your next request to receive the next set of results.
        public let nextToken: String?

        @inlinable
        public init(earthObservationJobSummaries: [ListEarthObservationJobOutputConfig], nextToken: String? = nil) {
            self.earthObservationJobSummaries = earthObservationJobSummaries
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case earthObservationJobSummaries = "EarthObservationJobSummaries"
            case nextToken = "NextToken"
        }
    }

    public struct ListEarthObservationJobOutputConfig: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the list of the Earth Observation jobs.
        public let arn: String
        /// The creation time.
        public let creationTime: Date
        /// The duration of the session, in seconds.
        public let durationInSeconds: Int
        /// The names of the Earth Observation jobs in the list.
        public let name: String
        /// The operation type for an Earth Observation job.
        public let operationType: String
        /// The status of the list of the Earth Observation jobs.
        public let status: EarthObservationJobStatus
        /// Each tag consists of a key and a value.
        public let tags: [String: String]?

        @inlinable
        public init(arn: String, creationTime: Date, durationInSeconds: Int, name: String, operationType: String, status: EarthObservationJobStatus, tags: [String: String]? = nil) {
            self.arn = arn
            self.creationTime = creationTime
            self.durationInSeconds = durationInSeconds
            self.name = name
            self.operationType = operationType
            self.status = status
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case creationTime = "CreationTime"
            case durationInSeconds = "DurationInSeconds"
            case name = "Name"
            case operationType = "OperationType"
            case status = "Status"
            case tags = "Tags"
        }
    }

    public struct ListRasterDataCollectionsInput: AWSEncodableShape {
        /// The total number of items to return.
        public let maxResults: Int?
        /// If the previous response was truncated, you receive this token. Use it in your next request to receive the next set of results.
        public let nextToken: String?

        @inlinable
        public init(maxResults: Int? = nil, nextToken: String? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.maxResults, key: "MaxResults")
            request.encodeQuery(self.nextToken, key: "NextToken")
        }

        public func validate(name: String) throws {
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 8192)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListRasterDataCollectionsOutput: AWSDecodableShape {
        /// If the previous response was truncated, you receive this token. Use it in your next request to receive the next set of results.
        public let nextToken: String?
        /// Contains summary information about the raster data collection.
        public let rasterDataCollectionSummaries: [RasterDataCollectionMetadata]

        @inlinable
        public init(nextToken: String? = nil, rasterDataCollectionSummaries: [RasterDataCollectionMetadata]) {
            self.nextToken = nextToken
            self.rasterDataCollectionSummaries = rasterDataCollectionSummaries
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "NextToken"
            case rasterDataCollectionSummaries = "RasterDataCollectionSummaries"
        }
    }

    public struct ListTagsForResourceRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the resource you want to tag.
        public let resourceArn: String

        @inlinable
        public init(resourceArn: String) {
            self.resourceArn = resourceArn
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.resourceArn, key: "ResourceArn")
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, max: 2048)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListTagsForResourceResponse: AWSDecodableShape {
        /// Each tag consists of a key and a value.
        public let tags: [String: String]?

        @inlinable
        public init(tags: [String: String]? = nil) {
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case tags = "Tags"
        }
    }

    public struct ListVectorEnrichmentJobInput: AWSEncodableShape {
        /// The maximum number of items to return.
        public let maxResults: Int?
        /// If the previous response was truncated, you receive this token. Use it in your next request to receive the next set of results.
        public let nextToken: String?
        /// The parameter by which to sort the results.
        public let sortBy: String?
        /// An optional value that specifies whether you want the results sorted in Ascending or Descending order.
        public let sortOrder: SortOrder?
        /// A filter that retrieves only jobs with a specific status.
        public let statusEquals: String?

        @inlinable
        public init(maxResults: Int? = nil, nextToken: String? = nil, sortBy: String? = nil, sortOrder: SortOrder? = nil, statusEquals: String? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.sortBy = sortBy
            self.sortOrder = sortOrder
            self.statusEquals = statusEquals
        }

        public func validate(name: String) throws {
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 8192)
        }

        private enum CodingKeys: String, CodingKey {
            case maxResults = "MaxResults"
            case nextToken = "NextToken"
            case sortBy = "SortBy"
            case sortOrder = "SortOrder"
            case statusEquals = "StatusEquals"
        }
    }

    public struct ListVectorEnrichmentJobOutput: AWSDecodableShape {
        /// If the previous response was truncated, you receive this token. Use it in your next request to receive the next set of results.
        public let nextToken: String?
        /// Contains summary information about the Vector Enrichment jobs.
        public let vectorEnrichmentJobSummaries: [ListVectorEnrichmentJobOutputConfig]

        @inlinable
        public init(nextToken: String? = nil, vectorEnrichmentJobSummaries: [ListVectorEnrichmentJobOutputConfig]) {
            self.nextToken = nextToken
            self.vectorEnrichmentJobSummaries = vectorEnrichmentJobSummaries
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "NextToken"
            case vectorEnrichmentJobSummaries = "VectorEnrichmentJobSummaries"
        }
    }

    public struct ListVectorEnrichmentJobOutputConfig: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the list of the Vector Enrichment jobs.
        public let arn: String
        /// The creation time.
        public let creationTime: Date
        /// The duration of the session, in seconds.
        public let durationInSeconds: Int
        /// The names of the Vector Enrichment jobs in the list.
        public let name: String
        /// The status of the Vector Enrichment jobs list.
        public let status: VectorEnrichmentJobStatus
        /// Each tag consists of a key and a value.
        public let tags: [String: String]?
        /// The type of the list of Vector Enrichment jobs.
        public let type: VectorEnrichmentJobType

        @inlinable
        public init(arn: String, creationTime: Date, durationInSeconds: Int, name: String, status: VectorEnrichmentJobStatus, tags: [String: String]? = nil, type: VectorEnrichmentJobType) {
            self.arn = arn
            self.creationTime = creationTime
            self.durationInSeconds = durationInSeconds
            self.name = name
            self.status = status
            self.tags = tags
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case creationTime = "CreationTime"
            case durationInSeconds = "DurationInSeconds"
            case name = "Name"
            case status = "Status"
            case tags = "Tags"
            case type = "Type"
        }
    }

    public struct MapMatchingConfig: AWSEncodableShape & AWSDecodableShape {
        /// The field name for the data that describes the identifier representing a collection of GPS points belonging to an individual trace.
        public let idAttributeName: String
        /// The name of the timestamp attribute.
        public let timestampAttributeName: String
        /// The name of the X-attribute
        public let xAttributeName: String
        /// The name of the Y-attribute
        public let yAttributeName: String

        @inlinable
        public init(idAttributeName: String, timestampAttributeName: String, xAttributeName: String, yAttributeName: String) {
            self.idAttributeName = idAttributeName
            self.timestampAttributeName = timestampAttributeName
            self.xAttributeName = xAttributeName
            self.yAttributeName = yAttributeName
        }

        private enum CodingKeys: String, CodingKey {
            case idAttributeName = "IdAttributeName"
            case timestampAttributeName = "TimestampAttributeName"
            case xAttributeName = "XAttributeName"
            case yAttributeName = "YAttributeName"
        }
    }

    public struct MultiPolygonGeometryInput: AWSEncodableShape & AWSDecodableShape {
        /// The coordinates of the multipolygon geometry.
        public let coordinates: [[[[Double]]]]

        @inlinable
        public init(coordinates: [[[[Double]]]]) {
            self.coordinates = coordinates
        }

        public func validate(name: String) throws {
            try self.coordinates.forEach {
                try validate($0, name: "coordinates[]", parent: name, min: 1)
            }
        }

        private enum CodingKeys: String, CodingKey {
            case coordinates = "Coordinates"
        }
    }

    public struct Operation: AWSEncodableShape & AWSDecodableShape {
        /// Textual representation of the math operation; Equation used to compute the spectral index.
        public let equation: String
        /// The name of the operation.
        public let name: String
        /// The type of the operation.
        public let outputType: OutputType?

        @inlinable
        public init(equation: String, name: String, outputType: OutputType? = nil) {
            self.equation = equation
            self.name = name
            self.outputType = outputType
        }

        private enum CodingKeys: String, CodingKey {
            case equation = "Equation"
            case name = "Name"
            case outputType = "OutputType"
        }
    }

    public struct OutputBand: AWSDecodableShape {
        /// The name of the band.
        public let bandName: String
        /// The datatype of the output band.
        public let outputDataType: OutputType

        @inlinable
        public init(bandName: String, outputDataType: OutputType) {
            self.bandName = bandName
            self.outputDataType = outputDataType
        }

        private enum CodingKeys: String, CodingKey {
            case bandName = "BandName"
            case outputDataType = "OutputDataType"
        }
    }

    public struct OutputConfigInput: AWSEncodableShape & AWSDecodableShape {
        /// Path to Amazon S3 storage location for the output configuration file.
        public let s3Data: ExportS3DataInput

        @inlinable
        public init(s3Data: ExportS3DataInput) {
            self.s3Data = s3Data
        }

        public func validate(name: String) throws {
            try self.s3Data.validate(name: "\(name).s3Data")
        }

        private enum CodingKeys: String, CodingKey {
            case s3Data = "S3Data"
        }
    }

    public struct OutputResolutionResamplingInput: AWSEncodableShape & AWSDecodableShape {
        /// User Defined Resolution for the output  of Resampling operation defined by value and unit.
        public let userDefined: UserDefined

        @inlinable
        public init(userDefined: UserDefined) {
            self.userDefined = userDefined
        }

        private enum CodingKeys: String, CodingKey {
            case userDefined = "UserDefined"
        }
    }

    public struct OutputResolutionStackInput: AWSEncodableShape & AWSDecodableShape {
        /// A string value representing Predefined Output Resolution for a stacking operation. Allowed values are HIGHEST, LOWEST, and AVERAGE.
        public let predefined: PredefinedResolution?
        /// The structure representing User Output Resolution for a Stacking operation defined as a value and unit.
        public let userDefined: UserDefined?

        @inlinable
        public init(predefined: PredefinedResolution? = nil, userDefined: UserDefined? = nil) {
            self.predefined = predefined
            self.userDefined = userDefined
        }

        private enum CodingKeys: String, CodingKey {
            case predefined = "Predefined"
            case userDefined = "UserDefined"
        }
    }

    public struct PlatformInput: AWSEncodableShape & AWSDecodableShape {
        /// The ComparisonOperator to use with PlatformInput.
        public let comparisonOperator: ComparisonOperator?
        /// The value of the platform.
        public let value: String

        @inlinable
        public init(comparisonOperator: ComparisonOperator? = nil, value: String) {
            self.comparisonOperator = comparisonOperator
            self.value = value
        }

        private enum CodingKeys: String, CodingKey {
            case comparisonOperator = "ComparisonOperator"
            case value = "Value"
        }
    }

    public struct PolygonGeometryInput: AWSEncodableShape & AWSDecodableShape {
        /// Coordinates representing a Polygon based on the GeoJson spec.
        public let coordinates: [[[Double]]]

        @inlinable
        public init(coordinates: [[[Double]]]) {
            self.coordinates = coordinates
        }

        public func validate(name: String) throws {
            try self.coordinates.forEach {
                try validate($0, name: "coordinates[]", parent: name, min: 4)
            }
            try self.validate(self.coordinates, name: "coordinates", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case coordinates = "Coordinates"
        }
    }

    public struct Properties: AWSDecodableShape {
        /// Estimate of cloud cover.
        public let eoCloudCover: Float?
        /// Land cloud cover for Landsat Data Collection.
        public let landsatCloudCoverLand: Float?
        /// Platform property. Platform refers to the unique name  of the specific platform the instrument is attached to.  For satellites it is the name of  the satellite, eg. landsat-8 (Landsat-8), sentinel-2a.
        public let platform: String?
        /// The angle from the sensor between nadir (straight down) and the scene center. Measured in degrees (0-90).
        public let viewOffNadir: Float?
        /// The sun azimuth angle. From the scene center point on the ground, this is the angle between truth north and the sun.  Measured clockwise in degrees (0-360).
        public let viewSunAzimuth: Float?
        /// The sun elevation angle. The angle from the tangent of the scene center point to the sun. Measured from the horizon in degrees (-90-90). Negative values indicate the sun is below the horizon, e.g. sun elevation of -10 means the data was captured during nautical twilight.
        public let viewSunElevation: Float?

        @inlinable
        public init(eoCloudCover: Float? = nil, landsatCloudCoverLand: Float? = nil, platform: String? = nil, viewOffNadir: Float? = nil, viewSunAzimuth: Float? = nil, viewSunElevation: Float? = nil) {
            self.eoCloudCover = eoCloudCover
            self.landsatCloudCoverLand = landsatCloudCoverLand
            self.platform = platform
            self.viewOffNadir = viewOffNadir
            self.viewSunAzimuth = viewSunAzimuth
            self.viewSunElevation = viewSunElevation
        }

        private enum CodingKeys: String, CodingKey {
            case eoCloudCover = "EoCloudCover"
            case landsatCloudCoverLand = "LandsatCloudCoverLand"
            case platform = "Platform"
            case viewOffNadir = "ViewOffNadir"
            case viewSunAzimuth = "ViewSunAzimuth"
            case viewSunElevation = "ViewSunElevation"
        }
    }

    public struct PropertyFilter: AWSEncodableShape & AWSDecodableShape {
        /// Represents a single property to match with when searching a raster data collection.
        public let property: Property

        @inlinable
        public init(property: Property) {
            self.property = property
        }

        private enum CodingKeys: String, CodingKey {
            case property = "Property"
        }
    }

    public struct PropertyFilters: AWSEncodableShape & AWSDecodableShape {
        /// The Logical Operator used to combine the Property Filters.
        public let logicalOperator: LogicalOperator?
        /// A list of Property Filters.
        public let properties: [PropertyFilter]?

        @inlinable
        public init(logicalOperator: LogicalOperator? = nil, properties: [PropertyFilter]? = nil) {
            self.logicalOperator = logicalOperator
            self.properties = properties
        }

        private enum CodingKeys: String, CodingKey {
            case logicalOperator = "LogicalOperator"
            case properties = "Properties"
        }
    }

    public struct RasterDataCollectionMetadata: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the raster data collection.
        public let arn: String
        /// A description of the raster data collection.
        public let description: String
        /// The description URL of the raster data collection.
        public let descriptionPageUrl: String?
        /// The name of the raster data collection.
        public let name: String
        /// The list of filters supported by the raster data collection.
        public let supportedFilters: [Filter]
        /// Each tag consists of a key and a value.
        public let tags: [String: String]?
        /// The type of raster data collection.
        public let type: DataCollectionType

        @inlinable
        public init(arn: String, description: String, descriptionPageUrl: String? = nil, name: String, supportedFilters: [Filter], tags: [String: String]? = nil, type: DataCollectionType) {
            self.arn = arn
            self.description = description
            self.descriptionPageUrl = descriptionPageUrl
            self.name = name
            self.supportedFilters = supportedFilters
            self.tags = tags
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case description = "Description"
            case descriptionPageUrl = "DescriptionPageUrl"
            case name = "Name"
            case supportedFilters = "SupportedFilters"
            case tags = "Tags"
            case type = "Type"
        }
    }

    public struct RasterDataCollectionQueryInput: AWSEncodableShape {
        /// The area of interest being queried for the raster data collection.
        public let areaOfInterest: AreaOfInterest?
        /// The list of Property filters used in the Raster Data Collection Query.
        public let propertyFilters: PropertyFilters?
        /// The Amazon Resource Name (ARN) of the raster data collection.
        public let rasterDataCollectionArn: String
        /// The TimeRange Filter used in the RasterDataCollection Query.
        public let timeRangeFilter: TimeRangeFilterInput

        @inlinable
        public init(areaOfInterest: AreaOfInterest? = nil, propertyFilters: PropertyFilters? = nil, rasterDataCollectionArn: String, timeRangeFilter: TimeRangeFilterInput) {
            self.areaOfInterest = areaOfInterest
            self.propertyFilters = propertyFilters
            self.rasterDataCollectionArn = rasterDataCollectionArn
            self.timeRangeFilter = timeRangeFilter
        }

        public func validate(name: String) throws {
            try self.areaOfInterest?.validate(name: "\(name).areaOfInterest")
            try self.validate(self.rasterDataCollectionArn, name: "rasterDataCollectionArn", parent: name, pattern: "^arn:aws[a-z-]{0,12}:sagemaker-geospatial:[a-z0-9-]{1,25}:[0-9]{12}:raster-data-collection/(public|premium|user)/[a-z0-9]{12,}$")
        }

        private enum CodingKeys: String, CodingKey {
            case areaOfInterest = "AreaOfInterest"
            case propertyFilters = "PropertyFilters"
            case rasterDataCollectionArn = "RasterDataCollectionArn"
            case timeRangeFilter = "TimeRangeFilter"
        }
    }

    public struct RasterDataCollectionQueryOutput: AWSDecodableShape {
        /// The Area of Interest used in the search.
        public let areaOfInterest: AreaOfInterest?
        /// Property filters used in the search.
        public let propertyFilters: PropertyFilters?
        /// The ARN of the Raster Data Collection against which the search is done.
        public let rasterDataCollectionArn: String
        /// The name of the raster data collection.
        public let rasterDataCollectionName: String
        /// The TimeRange filter used in the search.
        public let timeRangeFilter: TimeRangeFilterOutput

        @inlinable
        public init(areaOfInterest: AreaOfInterest? = nil, propertyFilters: PropertyFilters? = nil, rasterDataCollectionArn: String, rasterDataCollectionName: String, timeRangeFilter: TimeRangeFilterOutput) {
            self.areaOfInterest = areaOfInterest
            self.propertyFilters = propertyFilters
            self.rasterDataCollectionArn = rasterDataCollectionArn
            self.rasterDataCollectionName = rasterDataCollectionName
            self.timeRangeFilter = timeRangeFilter
        }

        private enum CodingKeys: String, CodingKey {
            case areaOfInterest = "AreaOfInterest"
            case propertyFilters = "PropertyFilters"
            case rasterDataCollectionArn = "RasterDataCollectionArn"
            case rasterDataCollectionName = "RasterDataCollectionName"
            case timeRangeFilter = "TimeRangeFilter"
        }
    }

    public struct RasterDataCollectionQueryWithBandFilterInput: AWSEncodableShape {
        /// The Area of interest to be used in the search query.
        public let areaOfInterest: AreaOfInterest?
        /// The list of Bands to be displayed in the result for each item.
        public let bandFilter: [String]?
        /// The Property Filters used in the search query.
        public let propertyFilters: PropertyFilters?
        /// The TimeRange Filter used in the search query.
        public let timeRangeFilter: TimeRangeFilterInput

        @inlinable
        public init(areaOfInterest: AreaOfInterest? = nil, bandFilter: [String]? = nil, propertyFilters: PropertyFilters? = nil, timeRangeFilter: TimeRangeFilterInput) {
            self.areaOfInterest = areaOfInterest
            self.bandFilter = bandFilter
            self.propertyFilters = propertyFilters
            self.timeRangeFilter = timeRangeFilter
        }

        public func validate(name: String) throws {
            try self.areaOfInterest?.validate(name: "\(name).areaOfInterest")
            try self.validate(self.bandFilter, name: "bandFilter", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case areaOfInterest = "AreaOfInterest"
            case bandFilter = "BandFilter"
            case propertyFilters = "PropertyFilters"
            case timeRangeFilter = "TimeRangeFilter"
        }
    }

    public struct ResamplingConfigInput: AWSEncodableShape & AWSDecodableShape {
        /// The name of the algorithm used for resampling.
        public let algorithmName: AlgorithmNameResampling?
        /// The structure representing output  resolution (in target georeferenced units) of the result of resampling operation.
        public let outputResolution: OutputResolutionResamplingInput
        /// Bands used in the operation. If no target bands are specified, it uses all bands available in the input.
        public let targetBands: [String]?

        @inlinable
        public init(algorithmName: AlgorithmNameResampling? = nil, outputResolution: OutputResolutionResamplingInput, targetBands: [String]? = nil) {
            self.algorithmName = algorithmName
            self.outputResolution = outputResolution
            self.targetBands = targetBands
        }

        public func validate(name: String) throws {
            try self.validate(self.targetBands, name: "targetBands", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case algorithmName = "AlgorithmName"
            case outputResolution = "OutputResolution"
            case targetBands = "TargetBands"
        }
    }

    public struct ResourceNotFoundException: AWSErrorShape {
        public let message: String
        /// Identifier of the resource that was not found.
        public let resourceId: String?

        @inlinable
        public init(message: String, resourceId: String? = nil) {
            self.message = message
            self.resourceId = resourceId
        }

        private enum CodingKeys: String, CodingKey {
            case message = "Message"
            case resourceId = "ResourceId"
        }
    }

    public struct ReverseGeocodingConfig: AWSEncodableShape & AWSDecodableShape {
        /// The field name for the data that describes x-axis coordinate, eg. longitude of a point.
        public let xAttributeName: String
        /// The field name for the data that describes y-axis coordinate, eg. latitude of a point.
        public let yAttributeName: String

        @inlinable
        public init(xAttributeName: String, yAttributeName: String) {
            self.xAttributeName = xAttributeName
            self.yAttributeName = yAttributeName
        }

        private enum CodingKeys: String, CodingKey {
            case xAttributeName = "XAttributeName"
            case yAttributeName = "YAttributeName"
        }
    }

    public struct SearchRasterDataCollectionInput: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the raster data collection.
        public let arn: String
        /// If the previous response was truncated, you receive this token. Use it in your next request to receive the next set of results.
        public let nextToken: String?
        /// RasterDataCollectionQuery consisting of AreaOfInterest(AOI), PropertyFilters and  TimeRangeFilterInput used in SearchRasterDataCollection.
        public let rasterDataCollectionQuery: RasterDataCollectionQueryWithBandFilterInput

        @inlinable
        public init(arn: String, nextToken: String? = nil, rasterDataCollectionQuery: RasterDataCollectionQueryWithBandFilterInput) {
            self.arn = arn
            self.nextToken = nextToken
            self.rasterDataCollectionQuery = rasterDataCollectionQuery
        }

        public func validate(name: String) throws {
            try self.validate(self.arn, name: "arn", parent: name, pattern: "^arn:aws[a-z-]{0,12}:sagemaker-geospatial:[a-z0-9-]{1,25}:[0-9]{12}:raster-data-collection/(public|premium|user)/[a-z0-9]{12,}$")
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 8192)
            try self.rasterDataCollectionQuery.validate(name: "\(name).rasterDataCollectionQuery")
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case nextToken = "NextToken"
            case rasterDataCollectionQuery = "RasterDataCollectionQuery"
        }
    }

    public struct SearchRasterDataCollectionOutput: AWSDecodableShape {
        /// Approximate number of results in the response.
        public let approximateResultCount: Int
        /// List of items matching the Raster DataCollectionQuery.
        public let items: [ItemSource]?
        /// If the previous response was truncated, you receive this token. Use it in your next request to receive the next set of results.
        public let nextToken: String?

        @inlinable
        public init(approximateResultCount: Int, items: [ItemSource]? = nil, nextToken: String? = nil) {
            self.approximateResultCount = approximateResultCount
            self.items = items
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case approximateResultCount = "ApproximateResultCount"
            case items = "Items"
            case nextToken = "NextToken"
        }
    }

    public struct ServiceQuotaExceededException: AWSErrorShape {
        public let message: String
        /// Identifier of the resource affected.
        public let resourceId: String?

        @inlinable
        public init(message: String, resourceId: String? = nil) {
            self.message = message
            self.resourceId = resourceId
        }

        private enum CodingKeys: String, CodingKey {
            case message = "Message"
            case resourceId = "ResourceId"
        }
    }

    public struct StackConfigInput: AWSEncodableShape & AWSDecodableShape {
        /// The structure representing output  resolution (in target georeferenced units) of the  result of stacking operation.
        public let outputResolution: OutputResolutionStackInput?
        /// A list of bands to be stacked in the specified order. When the parameter is not provided, all the available bands in the data collection are stacked in the alphabetical order of their asset names.
        public let targetBands: [String]?

        @inlinable
        public init(outputResolution: OutputResolutionStackInput? = nil, targetBands: [String]? = nil) {
            self.outputResolution = outputResolution
            self.targetBands = targetBands
        }

        public func validate(name: String) throws {
            try self.validate(self.targetBands, name: "targetBands", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case outputResolution = "OutputResolution"
            case targetBands = "TargetBands"
        }
    }

    public struct StartEarthObservationJobInput: AWSEncodableShape {
        /// A unique token that guarantees that the call to this API is idempotent.
        public let clientToken: String?
        /// The Amazon Resource Name (ARN) of the IAM role that you specified for the job.
        public let executionRoleArn: String
        /// Input configuration information for the Earth Observation job.
        public let inputConfig: InputConfigInput
        /// An object containing information about the job configuration.
        public let jobConfig: JobConfigInput
        /// The Key Management Service key ID for server-side encryption.
        public let kmsKeyId: String?
        /// The name of the Earth Observation job.
        public let name: String
        /// Each tag consists of a key and a value.
        public let tags: [String: String]?

        @inlinable
        public init(clientToken: String? = StartEarthObservationJobInput.idempotencyToken(), executionRoleArn: String, inputConfig: InputConfigInput, jobConfig: JobConfigInput, kmsKeyId: String? = nil, name: String, tags: [String: String]? = nil) {
            self.clientToken = clientToken
            self.executionRoleArn = executionRoleArn
            self.inputConfig = inputConfig
            self.jobConfig = jobConfig
            self.kmsKeyId = kmsKeyId
            self.name = name
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.validate(self.executionRoleArn, name: "executionRoleArn", parent: name, max: 2048)
            try self.validate(self.executionRoleArn, name: "executionRoleArn", parent: name, min: 20)
            try self.validate(self.executionRoleArn, name: "executionRoleArn", parent: name, pattern: "^arn:(aws[a-z-]*):iam::([0-9]{12}):role/[a-zA-Z0-9+=,.@_/-]+$")
            try self.inputConfig.validate(name: "\(name).inputConfig")
            try self.jobConfig.validate(name: "\(name).jobConfig")
            try self.validate(self.kmsKeyId, name: "kmsKeyId", parent: name, max: 2048)
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "ClientToken"
            case executionRoleArn = "ExecutionRoleArn"
            case inputConfig = "InputConfig"
            case jobConfig = "JobConfig"
            case kmsKeyId = "KmsKeyId"
            case name = "Name"
            case tags = "Tags"
        }
    }

    public struct StartEarthObservationJobOutput: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the Earth Observation job.
        public let arn: String
        /// The creation time.
        public let creationTime: Date
        /// The duration of the session, in seconds.
        public let durationInSeconds: Int
        /// The Amazon Resource Name (ARN) of the IAM role that you specified for the job.
        public let executionRoleArn: String
        /// Input configuration information for the Earth Observation job.
        public let inputConfig: InputConfigOutput?
        /// An object containing information about the job configuration.
        public let jobConfig: JobConfigInput
        /// The Key Management Service key ID for server-side encryption.
        public let kmsKeyId: String?
        /// The name of the Earth Observation job.
        public let name: String
        /// The status of the Earth Observation job.
        public let status: EarthObservationJobStatus
        /// Each tag consists of a key and a value.
        public let tags: [String: String]?

        @inlinable
        public init(arn: String, creationTime: Date, durationInSeconds: Int, executionRoleArn: String, inputConfig: InputConfigOutput? = nil, jobConfig: JobConfigInput, kmsKeyId: String? = nil, name: String, status: EarthObservationJobStatus, tags: [String: String]? = nil) {
            self.arn = arn
            self.creationTime = creationTime
            self.durationInSeconds = durationInSeconds
            self.executionRoleArn = executionRoleArn
            self.inputConfig = inputConfig
            self.jobConfig = jobConfig
            self.kmsKeyId = kmsKeyId
            self.name = name
            self.status = status
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case creationTime = "CreationTime"
            case durationInSeconds = "DurationInSeconds"
            case executionRoleArn = "ExecutionRoleArn"
            case inputConfig = "InputConfig"
            case jobConfig = "JobConfig"
            case kmsKeyId = "KmsKeyId"
            case name = "Name"
            case status = "Status"
            case tags = "Tags"
        }
    }

    public struct StartVectorEnrichmentJobInput: AWSEncodableShape {
        /// A unique token that guarantees that the call to this API is idempotent.
        public let clientToken: String?
        /// The Amazon Resource Name (ARN) of the IAM role that you specified for the job.
        public let executionRoleArn: String
        /// Input configuration information for the Vector Enrichment job.
        public let inputConfig: VectorEnrichmentJobInputConfig
        /// An object containing information about the job configuration.
        public let jobConfig: VectorEnrichmentJobConfig
        /// The Key Management Service key ID for server-side encryption.
        public let kmsKeyId: String?
        /// The name of the Vector Enrichment job.
        public let name: String
        /// Each tag consists of a key and a value.
        public let tags: [String: String]?

        @inlinable
        public init(clientToken: String? = StartVectorEnrichmentJobInput.idempotencyToken(), executionRoleArn: String, inputConfig: VectorEnrichmentJobInputConfig, jobConfig: VectorEnrichmentJobConfig, kmsKeyId: String? = nil, name: String, tags: [String: String]? = nil) {
            self.clientToken = clientToken
            self.executionRoleArn = executionRoleArn
            self.inputConfig = inputConfig
            self.jobConfig = jobConfig
            self.kmsKeyId = kmsKeyId
            self.name = name
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.validate(self.executionRoleArn, name: "executionRoleArn", parent: name, max: 2048)
            try self.validate(self.executionRoleArn, name: "executionRoleArn", parent: name, min: 20)
            try self.validate(self.executionRoleArn, name: "executionRoleArn", parent: name, pattern: "^arn:(aws[a-z-]*):iam::([0-9]{12}):role/[a-zA-Z0-9+=,.@_/-]+$")
            try self.inputConfig.validate(name: "\(name).inputConfig")
            try self.validate(self.kmsKeyId, name: "kmsKeyId", parent: name, max: 2048)
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "ClientToken"
            case executionRoleArn = "ExecutionRoleArn"
            case inputConfig = "InputConfig"
            case jobConfig = "JobConfig"
            case kmsKeyId = "KmsKeyId"
            case name = "Name"
            case tags = "Tags"
        }
    }

    public struct StartVectorEnrichmentJobOutput: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the Vector Enrichment job.
        public let arn: String
        /// The creation time.
        public let creationTime: Date
        /// The duration of the Vector Enrichment job, in seconds.
        public let durationInSeconds: Int
        /// The Amazon Resource Name (ARN) of the IAM role that you specified for the job.
        public let executionRoleArn: String
        /// Input configuration information for starting the Vector Enrichment job.
        public let inputConfig: VectorEnrichmentJobInputConfig
        /// An object containing information about the job configuration.
        public let jobConfig: VectorEnrichmentJobConfig
        /// The Key Management Service key ID for server-side encryption.
        public let kmsKeyId: String?
        /// The name of the Vector Enrichment job.
        public let name: String
        /// The status of the Vector Enrichment job being started.
        public let status: VectorEnrichmentJobStatus
        /// Each tag consists of a key and a value.
        public let tags: [String: String]?
        /// The type of the Vector Enrichment job.
        public let type: VectorEnrichmentJobType

        @inlinable
        public init(arn: String, creationTime: Date, durationInSeconds: Int, executionRoleArn: String, inputConfig: VectorEnrichmentJobInputConfig, jobConfig: VectorEnrichmentJobConfig, kmsKeyId: String? = nil, name: String, status: VectorEnrichmentJobStatus, tags: [String: String]? = nil, type: VectorEnrichmentJobType) {
            self.arn = arn
            self.creationTime = creationTime
            self.durationInSeconds = durationInSeconds
            self.executionRoleArn = executionRoleArn
            self.inputConfig = inputConfig
            self.jobConfig = jobConfig
            self.kmsKeyId = kmsKeyId
            self.name = name
            self.status = status
            self.tags = tags
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case creationTime = "CreationTime"
            case durationInSeconds = "DurationInSeconds"
            case executionRoleArn = "ExecutionRoleArn"
            case inputConfig = "InputConfig"
            case jobConfig = "JobConfig"
            case kmsKeyId = "KmsKeyId"
            case name = "Name"
            case status = "Status"
            case tags = "Tags"
            case type = "Type"
        }
    }

    public struct StopEarthObservationJobInput: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the Earth Observation job being stopped.
        public let arn: String

        @inlinable
        public init(arn: String) {
            self.arn = arn
        }

        public func validate(name: String) throws {
            try self.validate(self.arn, name: "arn", parent: name, pattern: "^arn:aws[a-z-]{0,12}:sagemaker-geospatial:[a-z0-9-]{1,25}:[0-9]{12}:earth-observation-job/[a-z0-9]{12,}$")
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
        }
    }

    public struct StopEarthObservationJobOutput: AWSDecodableShape {
        public init() {}
    }

    public struct StopVectorEnrichmentJobInput: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the Vector Enrichment job.
        public let arn: String

        @inlinable
        public init(arn: String) {
            self.arn = arn
        }

        public func validate(name: String) throws {
            try self.validate(self.arn, name: "arn", parent: name, pattern: "^arn:aws[a-z-]{0,12}:sagemaker-geospatial:[a-z0-9-]{1,25}:[0-9]{12}:vector-enrichment-job/[a-z0-9]{12,}$")
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
        }
    }

    public struct StopVectorEnrichmentJobOutput: AWSDecodableShape {
        public init() {}
    }

    public struct TagResourceRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the resource you want to tag.
        public let resourceArn: String
        /// Each tag consists of a key and a value.
        public let tags: [String: String]

        @inlinable
        public init(resourceArn: String, tags: [String: String]) {
            self.resourceArn = resourceArn
            self.tags = tags
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.resourceArn, key: "ResourceArn")
            try container.encode(self.tags, forKey: .tags)
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, max: 2048)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case tags = "Tags"
        }
    }

    public struct TagResourceResponse: AWSDecodableShape {
        public init() {}
    }

    public struct TemporalStatisticsConfigInput: AWSEncodableShape & AWSDecodableShape {
        /// The input for the temporal statistics grouping by time frequency option.
        public let groupBy: GroupBy?
        /// The list of the statistics method options.
        public let statistics: [TemporalStatistics]
        /// The list of target band names for the temporal statistic to calculate.
        public let targetBands: [String]?

        @inlinable
        public init(groupBy: GroupBy? = nil, statistics: [TemporalStatistics], targetBands: [String]? = nil) {
            self.groupBy = groupBy
            self.statistics = statistics
            self.targetBands = targetBands
        }

        public func validate(name: String) throws {
            try self.validate(self.statistics, name: "statistics", parent: name, min: 1)
            try self.validate(self.targetBands, name: "targetBands", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case groupBy = "GroupBy"
            case statistics = "Statistics"
            case targetBands = "TargetBands"
        }
    }

    public struct ThrottlingException: AWSErrorShape {
        public let message: String
        public let resourceId: String?

        @inlinable
        public init(message: String, resourceId: String? = nil) {
            self.message = message
            self.resourceId = resourceId
        }

        private enum CodingKeys: String, CodingKey {
            case message = "Message"
            case resourceId = "ResourceId"
        }
    }

    public struct TimeRangeFilterInput: AWSEncodableShape {
        /// The end time for the time-range filter.
        public let endTime: Date
        /// The start time for the time-range filter.
        public let startTime: Date

        @inlinable
        public init(endTime: Date, startTime: Date) {
            self.endTime = endTime
            self.startTime = startTime
        }

        private enum CodingKeys: String, CodingKey {
            case endTime = "EndTime"
            case startTime = "StartTime"
        }
    }

    public struct TimeRangeFilterOutput: AWSDecodableShape {
        /// The ending time for the time range filter.
        public let endTime: Date
        /// The starting time for the time range filter.
        public let startTime: Date

        @inlinable
        public init(endTime: Date, startTime: Date) {
            self.endTime = endTime
            self.startTime = startTime
        }

        private enum CodingKeys: String, CodingKey {
            case endTime = "EndTime"
            case startTime = "StartTime"
        }
    }

    public struct UntagResourceRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the resource you want to untag.
        public let resourceArn: String
        /// Keys of the tags you want to remove.
        public let tagKeys: [String]

        @inlinable
        public init(resourceArn: String, tagKeys: [String]) {
            self.resourceArn = resourceArn
            self.tagKeys = tagKeys
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.resourceArn, key: "ResourceArn")
            request.encodeQuery(self.tagKeys, key: "tagKeys")
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, max: 2048)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, min: 1)
            try self.validate(self.tagKeys, name: "tagKeys", parent: name, max: 50)
            try self.validate(self.tagKeys, name: "tagKeys", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct UntagResourceResponse: AWSDecodableShape {
        public init() {}
    }

    public struct UserDefined: AWSEncodableShape & AWSDecodableShape {
        /// The units for output resolution of the result.
        public let unit: Unit
        /// The value for output resolution of the result.
        public let value: Float

        @inlinable
        public init(unit: Unit, value: Float) {
            self.unit = unit
            self.value = value
        }

        private enum CodingKeys: String, CodingKey {
            case unit = "Unit"
            case value = "Value"
        }
    }

    public struct ValidationException: AWSErrorShape {
        public let message: String
        public let resourceId: String?

        @inlinable
        public init(message: String, resourceId: String? = nil) {
            self.message = message
            self.resourceId = resourceId
        }

        private enum CodingKeys: String, CodingKey {
            case message = "Message"
            case resourceId = "ResourceId"
        }
    }

    public struct VectorEnrichmentJobErrorDetails: AWSDecodableShape {
        /// A message that you define and then is processed and rendered by  the Vector Enrichment job when the error occurs.
        public let errorMessage: String?
        /// The type of error generated during the Vector Enrichment job.
        public let errorType: VectorEnrichmentJobErrorType?

        @inlinable
        public init(errorMessage: String? = nil, errorType: VectorEnrichmentJobErrorType? = nil) {
            self.errorMessage = errorMessage
            self.errorType = errorType
        }

        private enum CodingKeys: String, CodingKey {
            case errorMessage = "ErrorMessage"
            case errorType = "ErrorType"
        }
    }

    public struct VectorEnrichmentJobExportErrorDetails: AWSDecodableShape {
        /// The message providing details about the errors generated during the Vector Enrichment job.
        public let message: String?
        /// The output error details for an Export operation on a Vector Enrichment job.
        public let type: VectorEnrichmentJobExportErrorType?

        @inlinable
        public init(message: String? = nil, type: VectorEnrichmentJobExportErrorType? = nil) {
            self.message = message
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case message = "Message"
            case type = "Type"
        }
    }

    public struct VectorEnrichmentJobInputConfig: AWSEncodableShape & AWSDecodableShape {
        /// The input structure for the data source that represents the storage type of the input data objects.
        public let dataSourceConfig: VectorEnrichmentJobDataSourceConfigInput
        /// The input structure that defines the data source file type.
        public let documentType: VectorEnrichmentJobDocumentType

        @inlinable
        public init(dataSourceConfig: VectorEnrichmentJobDataSourceConfigInput, documentType: VectorEnrichmentJobDocumentType) {
            self.dataSourceConfig = dataSourceConfig
            self.documentType = documentType
        }

        public func validate(name: String) throws {
            try self.dataSourceConfig.validate(name: "\(name).dataSourceConfig")
        }

        private enum CodingKeys: String, CodingKey {
            case dataSourceConfig = "DataSourceConfig"
            case documentType = "DocumentType"
        }
    }

    public struct VectorEnrichmentJobS3Data: AWSEncodableShape & AWSDecodableShape {
        /// The Key Management Service key ID for server-side encryption.
        public let kmsKeyId: String?
        /// The URL to the Amazon S3 data for the Vector Enrichment job.
        public let s3Uri: String

        @inlinable
        public init(kmsKeyId: String? = nil, s3Uri: String) {
            self.kmsKeyId = kmsKeyId
            self.s3Uri = s3Uri
        }

        public func validate(name: String) throws {
            try self.validate(self.kmsKeyId, name: "kmsKeyId", parent: name, max: 2048)
            try self.validate(self.s3Uri, name: "s3Uri", parent: name, pattern: "^s3://([^/]+)/?(.*)$")
        }

        private enum CodingKeys: String, CodingKey {
            case kmsKeyId = "KmsKeyId"
            case s3Uri = "S3Uri"
        }
    }

    public struct ViewOffNadirInput: AWSEncodableShape & AWSDecodableShape {
        /// The minimum value for ViewOffNadir property filter.  This filters items having ViewOffNadir greater than or equal to this value.
        public let lowerBound: Float
        /// The maximum value for ViewOffNadir property filter.  This filters items having ViewOffNadir lesser than or equal to this value.
        public let upperBound: Float

        @inlinable
        public init(lowerBound: Float, upperBound: Float) {
            self.lowerBound = lowerBound
            self.upperBound = upperBound
        }

        private enum CodingKeys: String, CodingKey {
            case lowerBound = "LowerBound"
            case upperBound = "UpperBound"
        }
    }

    public struct ViewSunAzimuthInput: AWSEncodableShape & AWSDecodableShape {
        /// The minimum value for ViewSunAzimuth property filter.  This filters items having ViewSunAzimuth greater than or equal to this value.
        public let lowerBound: Float
        /// The maximum value for ViewSunAzimuth property filter.  This filters items having ViewSunAzimuth lesser than or equal to this value.
        public let upperBound: Float

        @inlinable
        public init(lowerBound: Float, upperBound: Float) {
            self.lowerBound = lowerBound
            self.upperBound = upperBound
        }

        private enum CodingKeys: String, CodingKey {
            case lowerBound = "LowerBound"
            case upperBound = "UpperBound"
        }
    }

    public struct ViewSunElevationInput: AWSEncodableShape & AWSDecodableShape {
        /// The lower bound to view the sun elevation.
        public let lowerBound: Float
        /// The upper bound to view the sun elevation.
        public let upperBound: Float

        @inlinable
        public init(lowerBound: Float, upperBound: Float) {
            self.lowerBound = lowerBound
            self.upperBound = upperBound
        }

        private enum CodingKeys: String, CodingKey {
            case lowerBound = "LowerBound"
            case upperBound = "UpperBound"
        }
    }

    public struct ZonalStatisticsConfigInput: AWSEncodableShape & AWSDecodableShape {
        /// List of zonal statistics to compute.
        public let statistics: [ZonalStatistics]
        /// Bands used in the operation.  If no target bands are specified, it uses all bands available input.
        public let targetBands: [String]?
        /// The Amazon S3 path pointing to the GeoJSON containing the polygonal zones.
        public let zoneS3Path: String
        /// The Amazon Resource Name (ARN) or an ID of a Amazon Web Services Key Management Service (Amazon Web Services KMS) key that Amazon SageMaker uses to decrypt your output artifacts with Amazon S3 server-side encryption.
        /// The SageMaker execution role must have kms:GenerateDataKey permission. The KmsKeyId can be any of the following formats:   // KMS Key ID  "1234abcd-12ab-34cd-56ef-1234567890ab"    // Amazon Resource Name (ARN) of a KMS Key  "arn:aws:kms:&lt;region&gt;:&lt;account&gt;:key/&lt;key-id-12ab-34cd-56ef-1234567890ab&gt;"    For more information about key identifiers, see
        /// Key identifiers (KeyID) in the
        /// Amazon Web Services Key Management Service (Amazon Web Services KMS) documentation.
        public let zoneS3PathKmsKeyId: String?

        @inlinable
        public init(statistics: [ZonalStatistics], targetBands: [String]? = nil, zoneS3Path: String, zoneS3PathKmsKeyId: String? = nil) {
            self.statistics = statistics
            self.targetBands = targetBands
            self.zoneS3Path = zoneS3Path
            self.zoneS3PathKmsKeyId = zoneS3PathKmsKeyId
        }

        public func validate(name: String) throws {
            try self.validate(self.statistics, name: "statistics", parent: name, min: 1)
            try self.validate(self.targetBands, name: "targetBands", parent: name, min: 1)
            try self.validate(self.zoneS3Path, name: "zoneS3Path", parent: name, pattern: "^s3://([^/]+)/?(.*)$")
            try self.validate(self.zoneS3PathKmsKeyId, name: "zoneS3PathKmsKeyId", parent: name, max: 2048)
        }

        private enum CodingKeys: String, CodingKey {
            case statistics = "Statistics"
            case targetBands = "TargetBands"
            case zoneS3Path = "ZoneS3Path"
            case zoneS3PathKmsKeyId = "ZoneS3PathKmsKeyId"
        }
    }

    public struct AreaOfInterest: AWSEncodableShape & AWSDecodableShape {
        /// A GeoJSON object representing the geographic extent in the coordinate space.
        public let areaOfInterestGeometry: AreaOfInterestGeometry?

        @inlinable
        public init(areaOfInterestGeometry: AreaOfInterestGeometry? = nil) {
            self.areaOfInterestGeometry = areaOfInterestGeometry
        }

        public func validate(name: String) throws {
            try self.areaOfInterestGeometry?.validate(name: "\(name).areaOfInterestGeometry")
        }

        private enum CodingKeys: String, CodingKey {
            case areaOfInterestGeometry = "AreaOfInterestGeometry"
        }
    }

    public struct VectorEnrichmentJobDataSourceConfigInput: AWSEncodableShape & AWSDecodableShape {
        /// The input structure for the Amazon S3 data that represents the Amazon S3 location of the input data objects.
        public let s3Data: VectorEnrichmentJobS3Data?

        @inlinable
        public init(s3Data: VectorEnrichmentJobS3Data? = nil) {
            self.s3Data = s3Data
        }

        public func validate(name: String) throws {
            try self.s3Data?.validate(name: "\(name).s3Data")
        }

        private enum CodingKeys: String, CodingKey {
            case s3Data = "S3Data"
        }
    }
}

// MARK: - Errors

/// Error enum for SageMakerGeospatial
public struct SageMakerGeospatialErrorType: AWSErrorType {
    enum Code: String {
        case accessDeniedException = "AccessDeniedException"
        case conflictException = "ConflictException"
        case internalServerException = "InternalServerException"
        case resourceNotFoundException = "ResourceNotFoundException"
        case serviceQuotaExceededException = "ServiceQuotaExceededException"
        case throttlingException = "ThrottlingException"
        case validationException = "ValidationException"
    }

    private let error: Code
    public let context: AWSErrorContext?

    /// initialize SageMakerGeospatial
    public init?(errorCode: String, context: AWSErrorContext) {
        guard let error = Code(rawValue: errorCode) else { return nil }
        self.error = error
        self.context = context
    }

    internal init(_ error: Code) {
        self.error = error
        self.context = nil
    }

    /// return error code string
    public var errorCode: String { self.error.rawValue }

    /// You do not have sufficient access to perform this action.
    public static var accessDeniedException: Self { .init(.accessDeniedException) }
    /// Updating or deleting a resource can cause an inconsistent state.
    public static var conflictException: Self { .init(.conflictException) }
    /// The request processing has failed because of an unknown error, exception, or failure.
    public static var internalServerException: Self { .init(.internalServerException) }
    /// The request references a resource which does not exist.
    public static var resourceNotFoundException: Self { .init(.resourceNotFoundException) }
    /// You have exceeded the service quota.
    public static var serviceQuotaExceededException: Self { .init(.serviceQuotaExceededException) }
    /// The request was denied due to request throttling.
    public static var throttlingException: Self { .init(.throttlingException) }
    /// The input fails to satisfy the constraints specified by an Amazon Web Services service.
    public static var validationException: Self { .init(.validationException) }
}

extension SageMakerGeospatialErrorType: AWSServiceErrorType {
    public static let errorCodeMap: [String: AWSErrorShape.Type] = [
        "ConflictException": SageMakerGeospatial.ConflictException.self,
        "InternalServerException": SageMakerGeospatial.InternalServerException.self,
        "ResourceNotFoundException": SageMakerGeospatial.ResourceNotFoundException.self,
        "ServiceQuotaExceededException": SageMakerGeospatial.ServiceQuotaExceededException.self,
        "ThrottlingException": SageMakerGeospatial.ThrottlingException.self,
        "ValidationException": SageMakerGeospatial.ValidationException.self
    ]
}

extension SageMakerGeospatialErrorType: Equatable {
    public static func == (lhs: SageMakerGeospatialErrorType, rhs: SageMakerGeospatialErrorType) -> Bool {
        lhs.error == rhs.error
    }
}

extension SageMakerGeospatialErrorType: CustomStringConvertible {
    public var description: String {
        return "\(self.error.rawValue): \(self.message ?? "")"
    }
}
