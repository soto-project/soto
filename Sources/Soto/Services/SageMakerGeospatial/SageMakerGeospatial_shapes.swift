//===----------------------------------------------------------------------===//
//
// This source file is part of the Soto for AWS open source project
//
// Copyright (c) 2017-2022 the Soto project authors
// Licensed under Apache License v2.0
//
// See LICENSE.txt for license information
// See CONTRIBUTORS.txt for the list of Soto project authors
//
// SPDX-License-Identifier: Apache-2.0
//
//===----------------------------------------------------------------------===//

// THIS FILE IS AUTOMATICALLY GENERATED by https://github.com/soto-project/soto-codegenerator.
// DO NOT EDIT.

import Foundation
import SotoCore

extension SageMakerGeospatial {
    // MARK: Enums

    public enum AlgorithmNameCloudRemoval: String, CustomStringConvertible, Codable, _SotoSendable {
        /// INTERPOLATION
        case interpolation = "INTERPOLATION"
        public var description: String { return self.rawValue }
    }

    public enum AlgorithmNameGeoMosaic: String, CustomStringConvertible, Codable, _SotoSendable {
        /// AVERAGE
        case average = "AVERAGE"
        /// BILINEAR
        case bilinear = "BILINEAR"
        /// CUBIC
        case cubic = "CUBIC"
        /// CUBICSPLINE
        case cubicspline = "CUBICSPLINE"
        /// LANCZOS
        case lanczos = "LANCZOS"
        /// MAX
        case max = "MAX"
        /// MED
        case med = "MED"
        /// MIN
        case min = "MIN"
        /// MODE
        case mode = "MODE"
        /// NEAR
        case near = "NEAR"
        /// Q1
        case q1 = "Q1"
        /// Q3
        case q3 = "Q3"
        /// RMS
        case rms = "RMS"
        /// SUM
        case sum = "SUM"
        public var description: String { return self.rawValue }
    }

    public enum AlgorithmNameResampling: String, CustomStringConvertible, Codable, _SotoSendable {
        /// AVERAGE
        case average = "AVERAGE"
        /// BILINEAR
        case bilinear = "BILINEAR"
        /// CUBIC
        case cubic = "CUBIC"
        /// CUBICSPLINE
        case cubicspline = "CUBICSPLINE"
        /// LANCZOS
        case lanczos = "LANCZOS"
        /// MAX
        case max = "MAX"
        /// MED
        case med = "MED"
        /// MIN
        case min = "MIN"
        /// MODE
        case mode = "MODE"
        /// NEAR
        case near = "NEAR"
        /// Q1
        case q1 = "Q1"
        /// Q3
        case q3 = "Q3"
        /// RMS
        case rms = "RMS"
        /// SUM
        case sum = "SUM"
        public var description: String { return self.rawValue }
    }

    public enum ComparisonOperator: String, CustomStringConvertible, Codable, _SotoSendable {
        /// EQUALS
        case equals = "EQUALS"
        /// NOT_EQUALS
        case notEquals = "NOT_EQUALS"
        /// STARTS_WITH
        case startsWith = "STARTS_WITH"
        public var description: String { return self.rawValue }
    }

    public enum DataCollectionType: String, CustomStringConvertible, Codable, _SotoSendable {
        /// PREMIUM
        case premium = "PREMIUM"
        /// PUBLIC
        case `public` = "PUBLIC"
        /// USER
        case user = "USER"
        public var description: String { return self.rawValue }
    }

    public enum EarthObservationJobErrorType: String, CustomStringConvertible, Codable, _SotoSendable {
        /// CLIENT_ERROR
        case clientError = "CLIENT_ERROR"
        /// SERVER_ERROR
        case serverError = "SERVER_ERROR"
        public var description: String { return self.rawValue }
    }

    public enum EarthObservationJobExportStatus: String, CustomStringConvertible, Codable, _SotoSendable {
        /// FAILED
        case failed = "FAILED"
        /// IN_PROGRESS
        case inProgress = "IN_PROGRESS"
        /// SUCCEEDED
        case succeeded = "SUCCEEDED"
        public var description: String { return self.rawValue }
    }

    public enum EarthObservationJobStatus: String, CustomStringConvertible, Codable, _SotoSendable {
        /// COMPLETED
        case completed = "COMPLETED"
        /// DELETED
        case deleted = "DELETED"
        /// DELETING
        case deleting = "DELETING"
        /// FAILED
        case failed = "FAILED"
        /// INITIALIZING
        case initializing = "INITIALIZING"
        /// IN_PROGRESS
        case inProgress = "IN_PROGRESS"
        /// STOPPED
        case stopped = "STOPPED"
        /// STOPPING
        case stopping = "STOPPING"
        public var description: String { return self.rawValue }
    }

    public enum ExportErrorType: String, CustomStringConvertible, Codable, _SotoSendable {
        /// CLIENT_ERROR
        case clientError = "CLIENT_ERROR"
        /// SERVER_ERROR
        case serverError = "SERVER_ERROR"
        public var description: String { return self.rawValue }
    }

    public enum GroupBy: String, CustomStringConvertible, Codable, _SotoSendable {
        /// ALL
        case all = "ALL"
        /// YEARLY
        case yearly = "YEARLY"
        public var description: String { return self.rawValue }
    }

    public enum LogicalOperator: String, CustomStringConvertible, Codable, _SotoSendable {
        /// AND
        case and = "AND"
        public var description: String { return self.rawValue }
    }

    public enum MetadataProvider: String, CustomStringConvertible, Codable, _SotoSendable {
        /// PLANET_ORDER
        case planetOrder = "PLANET_ORDER"
        public var description: String { return self.rawValue }
    }

    public enum OutputType: String, CustomStringConvertible, Codable, _SotoSendable {
        /// FLOAT32
        case float32 = "FLOAT32"
        /// FLOAT64
        case float64 = "FLOAT64"
        /// INT16
        case int16 = "INT16"
        /// INT32
        case int32 = "INT32"
        /// UINT16
        case uint16 = "UINT16"
        public var description: String { return self.rawValue }
    }

    public enum PredefinedResolution: String, CustomStringConvertible, Codable, _SotoSendable {
        /// AVERAGE
        case average = "AVERAGE"
        /// HIGHEST
        case highest = "HIGHEST"
        /// LOWEST
        case lowest = "LOWEST"
        public var description: String { return self.rawValue }
    }

    public enum SortOrder: String, CustomStringConvertible, Codable, _SotoSendable {
        /// ASCENDING
        case ascending = "ASCENDING"
        /// DESCENDING
        case descending = "DESCENDING"
        public var description: String { return self.rawValue }
    }

    public enum TargetOptions: String, CustomStringConvertible, Codable, _SotoSendable {
        /// INPUT
        case input = "INPUT"
        /// OUTPUT
        case output = "OUTPUT"
        public var description: String { return self.rawValue }
    }

    public enum TemporalStatistics: String, CustomStringConvertible, Codable, _SotoSendable {
        /// MEAN
        case mean = "MEAN"
        /// MEDIAN
        case median = "MEDIAN"
        /// STANDARD_DEVIATION
        case standardDeviation = "STANDARD_DEVIATION"
        public var description: String { return self.rawValue }
    }

    public enum Unit: String, CustomStringConvertible, Codable, _SotoSendable {
        /// METERS
        case meters = "METERS"
        public var description: String { return self.rawValue }
    }

    public enum VectorEnrichmentJobDocumentType: String, CustomStringConvertible, Codable, _SotoSendable {
        case csv = "CSV"
        public var description: String { return self.rawValue }
    }

    public enum VectorEnrichmentJobErrorType: String, CustomStringConvertible, Codable, _SotoSendable {
        /// CLIENT_ERROR
        case clientError = "CLIENT_ERROR"
        /// SERVER_ERROR
        case serverError = "SERVER_ERROR"
        public var description: String { return self.rawValue }
    }

    public enum VectorEnrichmentJobExportErrorType: String, CustomStringConvertible, Codable, _SotoSendable {
        case clientError = "CLIENT_ERROR"
        case serverError = "SERVER_ERROR"
        public var description: String { return self.rawValue }
    }

    public enum VectorEnrichmentJobExportStatus: String, CustomStringConvertible, Codable, _SotoSendable {
        case failed = "FAILED"
        case inProgress = "IN_PROGRESS"
        case succeeded = "SUCCEEDED"
        public var description: String { return self.rawValue }
    }

    public enum VectorEnrichmentJobStatus: String, CustomStringConvertible, Codable, _SotoSendable {
        case completed = "COMPLETED"
        case deleted = "DELETED"
        case deleting = "DELETING"
        case failed = "FAILED"
        case initializing = "INITIALIZING"
        case inProgress = "IN_PROGRESS"
        case stopped = "STOPPED"
        case stopping = "STOPPING"
        public var description: String { return self.rawValue }
    }

    public enum VectorEnrichmentJobType: String, CustomStringConvertible, Codable, _SotoSendable {
        case mapMatching = "MAP_MATCHING"
        case reverseGeocoding = "REVERSE_GEOCODING"
        public var description: String { return self.rawValue }
    }

    public enum ZonalStatistics: String, CustomStringConvertible, Codable, _SotoSendable {
        /// MAX
        case max = "MAX"
        /// MEAN
        case mean = "MEAN"
        /// MEDIAN
        case median = "MEDIAN"
        /// MIN
        case min = "MIN"
        /// STANDARD_DEVIATION
        case standardDeviation = "STANDARD_DEVIATION"
        /// SUM
        case sum = "SUM"
        public var description: String { return self.rawValue }
    }

    public enum AreaOfInterestGeometry: AWSEncodableShape & AWSDecodableShape, _SotoSendable {
        case multiPolygonGeometry(MultiPolygonGeometryInput)
        case polygonGeometry(PolygonGeometryInput)

        public init(from decoder: Decoder) throws {
            let container = try decoder.container(keyedBy: CodingKeys.self)
            guard container.allKeys.count == 1, let key = container.allKeys.first else {
                let context = DecodingError.Context(
                    codingPath: container.codingPath,
                    debugDescription: "Expected exactly one key, but got \(container.allKeys.count)"
                )
                throw DecodingError.dataCorrupted(context)
            }
            switch key {
            case .multiPolygonGeometry:
                let value = try container.decode(MultiPolygonGeometryInput.self, forKey: .multiPolygonGeometry)
                self = .multiPolygonGeometry(value)
            case .polygonGeometry:
                let value = try container.decode(PolygonGeometryInput.self, forKey: .polygonGeometry)
                self = .polygonGeometry(value)
            }
        }

        public func encode(to encoder: Encoder) throws {
            var container = encoder.container(keyedBy: CodingKeys.self)
            switch self {
            case .multiPolygonGeometry(let value):
                try container.encode(value, forKey: .multiPolygonGeometry)
            case .polygonGeometry(let value):
                try container.encode(value, forKey: .polygonGeometry)
            }
        }

        public func validate(name: String) throws {
            switch self {
            case .multiPolygonGeometry(let value):
                try value.validate(name: "\(name).multiPolygonGeometry")
            case .polygonGeometry(let value):
                try value.validate(name: "\(name).polygonGeometry")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case multiPolygonGeometry = "MultiPolygonGeometry"
            case polygonGeometry = "PolygonGeometry"
        }
    }

    public enum JobConfigInput: AWSEncodableShape & AWSDecodableShape, _SotoSendable {
        case bandMathConfig(BandMathConfigInput)
        /// An object containing information about the job configuration for cloud masking.
        case cloudMaskingConfig(CloudMaskingConfigInput)
        /// An object containing information about the job configuration for cloud removal.
        case cloudRemovalConfig(CloudRemovalConfigInput)
        /// An object containing information about the job configuration for geomosaic.
        case geoMosaicConfig(GeoMosaicConfigInput)
        /// An object containing information about the job configuration for land cover segmentation.
        case landCoverSegmentationConfig(LandCoverSegmentationConfigInput)
        /// An object containing information about the job configuration for resampling.
        case resamplingConfig(ResamplingConfigInput)
        case stackConfig(StackConfigInput)
        /// An object containing information about the job configuration for temporal statistics.
        case temporalStatisticsConfig(TemporalStatisticsConfigInput)
        /// An object containing information about the job configuration for zonal statistics.
        case zonalStatisticsConfig(ZonalStatisticsConfigInput)

        public init(from decoder: Decoder) throws {
            let container = try decoder.container(keyedBy: CodingKeys.self)
            guard container.allKeys.count == 1, let key = container.allKeys.first else {
                let context = DecodingError.Context(
                    codingPath: container.codingPath,
                    debugDescription: "Expected exactly one key, but got \(container.allKeys.count)"
                )
                throw DecodingError.dataCorrupted(context)
            }
            switch key {
            case .bandMathConfig:
                let value = try container.decode(BandMathConfigInput.self, forKey: .bandMathConfig)
                self = .bandMathConfig(value)
            case .cloudMaskingConfig:
                let value = try container.decode(CloudMaskingConfigInput.self, forKey: .cloudMaskingConfig)
                self = .cloudMaskingConfig(value)
            case .cloudRemovalConfig:
                let value = try container.decode(CloudRemovalConfigInput.self, forKey: .cloudRemovalConfig)
                self = .cloudRemovalConfig(value)
            case .geoMosaicConfig:
                let value = try container.decode(GeoMosaicConfigInput.self, forKey: .geoMosaicConfig)
                self = .geoMosaicConfig(value)
            case .landCoverSegmentationConfig:
                let value = try container.decode(LandCoverSegmentationConfigInput.self, forKey: .landCoverSegmentationConfig)
                self = .landCoverSegmentationConfig(value)
            case .resamplingConfig:
                let value = try container.decode(ResamplingConfigInput.self, forKey: .resamplingConfig)
                self = .resamplingConfig(value)
            case .stackConfig:
                let value = try container.decode(StackConfigInput.self, forKey: .stackConfig)
                self = .stackConfig(value)
            case .temporalStatisticsConfig:
                let value = try container.decode(TemporalStatisticsConfigInput.self, forKey: .temporalStatisticsConfig)
                self = .temporalStatisticsConfig(value)
            case .zonalStatisticsConfig:
                let value = try container.decode(ZonalStatisticsConfigInput.self, forKey: .zonalStatisticsConfig)
                self = .zonalStatisticsConfig(value)
            }
        }

        public func encode(to encoder: Encoder) throws {
            var container = encoder.container(keyedBy: CodingKeys.self)
            switch self {
            case .bandMathConfig(let value):
                try container.encode(value, forKey: .bandMathConfig)
            case .cloudMaskingConfig(let value):
                try container.encode(value, forKey: .cloudMaskingConfig)
            case .cloudRemovalConfig(let value):
                try container.encode(value, forKey: .cloudRemovalConfig)
            case .geoMosaicConfig(let value):
                try container.encode(value, forKey: .geoMosaicConfig)
            case .landCoverSegmentationConfig(let value):
                try container.encode(value, forKey: .landCoverSegmentationConfig)
            case .resamplingConfig(let value):
                try container.encode(value, forKey: .resamplingConfig)
            case .stackConfig(let value):
                try container.encode(value, forKey: .stackConfig)
            case .temporalStatisticsConfig(let value):
                try container.encode(value, forKey: .temporalStatisticsConfig)
            case .zonalStatisticsConfig(let value):
                try container.encode(value, forKey: .zonalStatisticsConfig)
            }
        }

        public func validate(name: String) throws {
            switch self {
            case .bandMathConfig(let value):
                try value.validate(name: "\(name).bandMathConfig")
            case .cloudRemovalConfig(let value):
                try value.validate(name: "\(name).cloudRemovalConfig")
            case .geoMosaicConfig(let value):
                try value.validate(name: "\(name).geoMosaicConfig")
            case .resamplingConfig(let value):
                try value.validate(name: "\(name).resamplingConfig")
            case .stackConfig(let value):
                try value.validate(name: "\(name).stackConfig")
            case .temporalStatisticsConfig(let value):
                try value.validate(name: "\(name).temporalStatisticsConfig")
            case .zonalStatisticsConfig(let value):
                try value.validate(name: "\(name).zonalStatisticsConfig")
            default:
                break
            }
        }

        private enum CodingKeys: String, CodingKey {
            case bandMathConfig = "BandMathConfig"
            case cloudMaskingConfig = "CloudMaskingConfig"
            case cloudRemovalConfig = "CloudRemovalConfig"
            case geoMosaicConfig = "GeoMosaicConfig"
            case landCoverSegmentationConfig = "LandCoverSegmentationConfig"
            case resamplingConfig = "ResamplingConfig"
            case stackConfig = "StackConfig"
            case temporalStatisticsConfig = "TemporalStatisticsConfig"
            case zonalStatisticsConfig = "ZonalStatisticsConfig"
        }
    }

    public enum Property: AWSEncodableShape & AWSDecodableShape, _SotoSendable {
        case eoCloudCover(EoCloudCoverInput)
        case landsatCloudCoverLand(LandsatCloudCoverLandInput)
        case platform(PlatformInput)
        case viewOffNadir(ViewOffNadirInput)
        case viewSunAzimuth(ViewSunAzimuthInput)
        case viewSunElevation(ViewSunElevationInput)

        public init(from decoder: Decoder) throws {
            let container = try decoder.container(keyedBy: CodingKeys.self)
            guard container.allKeys.count == 1, let key = container.allKeys.first else {
                let context = DecodingError.Context(
                    codingPath: container.codingPath,
                    debugDescription: "Expected exactly one key, but got \(container.allKeys.count)"
                )
                throw DecodingError.dataCorrupted(context)
            }
            switch key {
            case .eoCloudCover:
                let value = try container.decode(EoCloudCoverInput.self, forKey: .eoCloudCover)
                self = .eoCloudCover(value)
            case .landsatCloudCoverLand:
                let value = try container.decode(LandsatCloudCoverLandInput.self, forKey: .landsatCloudCoverLand)
                self = .landsatCloudCoverLand(value)
            case .platform:
                let value = try container.decode(PlatformInput.self, forKey: .platform)
                self = .platform(value)
            case .viewOffNadir:
                let value = try container.decode(ViewOffNadirInput.self, forKey: .viewOffNadir)
                self = .viewOffNadir(value)
            case .viewSunAzimuth:
                let value = try container.decode(ViewSunAzimuthInput.self, forKey: .viewSunAzimuth)
                self = .viewSunAzimuth(value)
            case .viewSunElevation:
                let value = try container.decode(ViewSunElevationInput.self, forKey: .viewSunElevation)
                self = .viewSunElevation(value)
            }
        }

        public func encode(to encoder: Encoder) throws {
            var container = encoder.container(keyedBy: CodingKeys.self)
            switch self {
            case .eoCloudCover(let value):
                try container.encode(value, forKey: .eoCloudCover)
            case .landsatCloudCoverLand(let value):
                try container.encode(value, forKey: .landsatCloudCoverLand)
            case .platform(let value):
                try container.encode(value, forKey: .platform)
            case .viewOffNadir(let value):
                try container.encode(value, forKey: .viewOffNadir)
            case .viewSunAzimuth(let value):
                try container.encode(value, forKey: .viewSunAzimuth)
            case .viewSunElevation(let value):
                try container.encode(value, forKey: .viewSunElevation)
            }
        }

        private enum CodingKeys: String, CodingKey {
            case eoCloudCover = "EoCloudCover"
            case landsatCloudCoverLand = "LandsatCloudCoverLand"
            case platform = "Platform"
            case viewOffNadir = "ViewOffNadir"
            case viewSunAzimuth = "ViewSunAzimuth"
            case viewSunElevation = "ViewSunElevation"
        }
    }

    public enum VectorEnrichmentJobConfig: AWSEncodableShape & AWSDecodableShape, _SotoSendable {
        case mapMatchingConfig(MapMatchingConfig)
        case reverseGeocodingConfig(ReverseGeocodingConfig)

        public init(from decoder: Decoder) throws {
            let container = try decoder.container(keyedBy: CodingKeys.self)
            guard container.allKeys.count == 1, let key = container.allKeys.first else {
                let context = DecodingError.Context(
                    codingPath: container.codingPath,
                    debugDescription: "Expected exactly one key, but got \(container.allKeys.count)"
                )
                throw DecodingError.dataCorrupted(context)
            }
            switch key {
            case .mapMatchingConfig:
                let value = try container.decode(MapMatchingConfig.self, forKey: .mapMatchingConfig)
                self = .mapMatchingConfig(value)
            case .reverseGeocodingConfig:
                let value = try container.decode(ReverseGeocodingConfig.self, forKey: .reverseGeocodingConfig)
                self = .reverseGeocodingConfig(value)
            }
        }

        public func encode(to encoder: Encoder) throws {
            var container = encoder.container(keyedBy: CodingKeys.self)
            switch self {
            case .mapMatchingConfig(let value):
                try container.encode(value, forKey: .mapMatchingConfig)
            case .reverseGeocodingConfig(let value):
                try container.encode(value, forKey: .reverseGeocodingConfig)
            }
        }

        private enum CodingKeys: String, CodingKey {
            case mapMatchingConfig = "MapMatchingConfig"
            case reverseGeocodingConfig = "ReverseGeocodingConfig"
        }
    }

    // MARK: Shapes

    public struct AssetValue: AWSDecodableShape {
        public let href: String?

        public init(href: String? = nil) {
            self.href = href
        }

        private enum CodingKeys: String, CodingKey {
            case href = "Href"
        }
    }

    public struct BandMathConfigInput: AWSEncodableShape & AWSDecodableShape {
        public let customIndices: CustomIndicesInput?
        public let predefinedIndices: [String]?

        public init(customIndices: CustomIndicesInput? = nil, predefinedIndices: [String]? = nil) {
            self.customIndices = customIndices
            self.predefinedIndices = predefinedIndices
        }

        public func validate(name: String) throws {
            try self.customIndices?.validate(name: "\(name).customIndices")
            try self.validate(self.predefinedIndices, name: "predefinedIndices", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case customIndices = "CustomIndices"
            case predefinedIndices = "PredefinedIndices"
        }
    }

    public struct CloudMaskingConfigInput: AWSEncodableShape & AWSDecodableShape {
        public init() {}
    }

    public struct CloudRemovalConfigInput: AWSEncodableShape & AWSDecodableShape {
        /// The name of the algorithm used for cloud removal.
        public let algorithmName: AlgorithmNameCloudRemoval?
        /// The interpolation value you provide for cloud removal.
        public let interpolationValue: String?
        public let targetBands: [String]?

        public init(algorithmName: AlgorithmNameCloudRemoval? = nil, interpolationValue: String? = nil, targetBands: [String]? = nil) {
            self.algorithmName = algorithmName
            self.interpolationValue = interpolationValue
            self.targetBands = targetBands
        }

        public func validate(name: String) throws {
            try self.validate(self.targetBands, name: "targetBands", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case algorithmName = "AlgorithmName"
            case interpolationValue = "InterpolationValue"
            case targetBands = "TargetBands"
        }
    }

    public struct CustomIndicesInput: AWSEncodableShape & AWSDecodableShape {
        public let operations: [Operation]?

        public init(operations: [Operation]? = nil) {
            self.operations = operations
        }

        public func validate(name: String) throws {
            try self.validate(self.operations, name: "operations", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case operations = "Operations"
        }
    }

    public struct DeleteEarthObservationJobInput: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "arn", location: .uri("Arn"))
        ]

        /// The Amazon Resource Name (ARN) of the Earth Observation job being deleted.
        public let arn: String

        public init(arn: String) {
            self.arn = arn
        }

        public func validate(name: String) throws {
            try self.validate(self.arn, name: "arn", parent: name, pattern: "^arn:aws[a-z-]{0,12}:sagemaker-geospatial:[a-z0-9-]{1,25}:[0-9]{12}:earth-observation-job/[a-z0-9]{12,}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteEarthObservationJobOutput: AWSDecodableShape {
        public init() {}
    }

    public struct DeleteVectorEnrichmentJobInput: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "arn", location: .uri("Arn"))
        ]

        /// The Amazon Resource Name (ARN) of the Vector Enrichment job being deleted.
        public let arn: String

        public init(arn: String) {
            self.arn = arn
        }

        public func validate(name: String) throws {
            try self.validate(self.arn, name: "arn", parent: name, pattern: "^arn:aws[a-z-]{0,12}:sagemaker-geospatial:[a-z0-9-]{1,25}:[0-9]{12}:vector-enrichment-job/[a-z0-9]{12,}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteVectorEnrichmentJobOutput: AWSDecodableShape {
        public init() {}
    }

    public struct EarthObservationJobErrorDetails: AWSDecodableShape {
        public let message: String?
        public let type: EarthObservationJobErrorType?

        public init(message: String? = nil, type: EarthObservationJobErrorType? = nil) {
            self.message = message
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case message = "Message"
            case type = "Type"
        }
    }

    public struct EoCloudCoverInput: AWSEncodableShape & AWSDecodableShape {
        public let lowerBound: Float
        public let upperBound: Float

        public init(lowerBound: Float, upperBound: Float) {
            self.lowerBound = lowerBound
            self.upperBound = upperBound
        }

        private enum CodingKeys: String, CodingKey {
            case lowerBound = "LowerBound"
            case upperBound = "UpperBound"
        }
    }

    public struct ExportEarthObservationJobInput: AWSEncodableShape {
        /// The input Amazon Resource Name (ARN) of the Earth Observation job being exported.
        public let arn: String
        /// The Amazon Resource Name (ARN) of the IAM role that you specified for the job.
        public let executionRoleArn: String
        /// The source images provided to the Earth Observation job being exported.
        public let exportSourceImages: Bool?
        /// An object containing information about the output file.
        public let outputConfig: OutputConfigInput

        public init(arn: String, executionRoleArn: String, exportSourceImages: Bool? = nil, outputConfig: OutputConfigInput) {
            self.arn = arn
            self.executionRoleArn = executionRoleArn
            self.exportSourceImages = exportSourceImages
            self.outputConfig = outputConfig
        }

        public func validate(name: String) throws {
            try self.validate(self.arn, name: "arn", parent: name, pattern: "^arn:aws[a-z-]{0,12}:sagemaker-geospatial:[a-z0-9-]{1,25}:[0-9]{12}:earth-observation-job/[a-z0-9]{12,}$")
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case executionRoleArn = "ExecutionRoleArn"
            case exportSourceImages = "ExportSourceImages"
            case outputConfig = "OutputConfig"
        }
    }

    public struct ExportEarthObservationJobOutput: AWSDecodableShape {
        /// The output Amazon Resource Name (ARN) of the Earth Observation job being exported.
        public let arn: String
        /// The creation time.
        public let creationTime: Date
        /// The Amazon Resource Name (ARN) of the IAM role that you specified for the job.
        public let executionRoleArn: String
        /// The source images provided to the Earth Observation job being exported.
        public let exportSourceImages: Bool?
        /// The status of the results of the Earth Observation job being exported.
        public let exportStatus: EarthObservationJobExportStatus
        /// An object containing information about the output file.
        public let outputConfig: OutputConfigInput

        public init(arn: String, creationTime: Date, executionRoleArn: String, exportSourceImages: Bool? = nil, exportStatus: EarthObservationJobExportStatus, outputConfig: OutputConfigInput) {
            self.arn = arn
            self.creationTime = creationTime
            self.executionRoleArn = executionRoleArn
            self.exportSourceImages = exportSourceImages
            self.exportStatus = exportStatus
            self.outputConfig = outputConfig
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case creationTime = "CreationTime"
            case executionRoleArn = "ExecutionRoleArn"
            case exportSourceImages = "ExportSourceImages"
            case exportStatus = "ExportStatus"
            case outputConfig = "OutputConfig"
        }
    }

    public struct ExportErrorDetails: AWSDecodableShape {
        public let exportResults: ExportErrorDetailsOutput?
        public let exportSourceImages: ExportErrorDetailsOutput?

        public init(exportResults: ExportErrorDetailsOutput? = nil, exportSourceImages: ExportErrorDetailsOutput? = nil) {
            self.exportResults = exportResults
            self.exportSourceImages = exportSourceImages
        }

        private enum CodingKeys: String, CodingKey {
            case exportResults = "ExportResults"
            case exportSourceImages = "ExportSourceImages"
        }
    }

    public struct ExportErrorDetailsOutput: AWSDecodableShape {
        public let message: String?
        public let type: ExportErrorType?

        public init(message: String? = nil, type: ExportErrorType? = nil) {
            self.message = message
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case message = "Message"
            case type = "Type"
        }
    }

    public struct ExportS3DataInput: AWSEncodableShape & AWSDecodableShape {
        /// The Amazon Key Management Service (KMS) key ID for server-side encryption.
        public let kmsKeyId: String?
        /// The URL to the Amazon S3 data input.
        public let s3Uri: String

        public init(kmsKeyId: String? = nil, s3Uri: String) {
            self.kmsKeyId = kmsKeyId
            self.s3Uri = s3Uri
        }

        private enum CodingKeys: String, CodingKey {
            case kmsKeyId = "KmsKeyId"
            case s3Uri = "S3Uri"
        }
    }

    public struct ExportVectorEnrichmentJobInput: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the Vector Enrichment job.
        public let arn: String
        /// The Amazon Resource Name (ARN) of the IAM rolewith permission to upload to the location in OutputConfig.
        public let executionRoleArn: String
        /// Output location information for exporting Vector Enrichment Job results.
        public let outputConfig: ExportVectorEnrichmentJobOutputConfig

        public init(arn: String, executionRoleArn: String, outputConfig: ExportVectorEnrichmentJobOutputConfig) {
            self.arn = arn
            self.executionRoleArn = executionRoleArn
            self.outputConfig = outputConfig
        }

        public func validate(name: String) throws {
            try self.validate(self.arn, name: "arn", parent: name, pattern: "^arn:aws[a-z-]{0,12}:sagemaker-geospatial:[a-z0-9-]{1,25}:[0-9]{12}:vector-enrichment-job/[a-z0-9]{12,}$")
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case executionRoleArn = "ExecutionRoleArn"
            case outputConfig = "OutputConfig"
        }
    }

    public struct ExportVectorEnrichmentJobOutput: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the Vector Enrichment job being exported.
        public let arn: String
        /// The creation time.
        public let creationTime: Date
        /// The Amazon Resource Name (ARN) of the IAM role with permission to upload to the location in OutputConfig.
        public let executionRoleArn: String
        /// The status of the results the Vector Enrichment job being exported.
        public let exportStatus: VectorEnrichmentJobExportStatus
        /// Output location information for exporting Vector Enrichment Job results.
        public let outputConfig: ExportVectorEnrichmentJobOutputConfig

        public init(arn: String, creationTime: Date, executionRoleArn: String, exportStatus: VectorEnrichmentJobExportStatus, outputConfig: ExportVectorEnrichmentJobOutputConfig) {
            self.arn = arn
            self.creationTime = creationTime
            self.executionRoleArn = executionRoleArn
            self.exportStatus = exportStatus
            self.outputConfig = outputConfig
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case creationTime = "CreationTime"
            case executionRoleArn = "ExecutionRoleArn"
            case exportStatus = "ExportStatus"
            case outputConfig = "OutputConfig"
        }
    }

    public struct ExportVectorEnrichmentJobOutputConfig: AWSEncodableShape & AWSDecodableShape {
        public let s3Data: VectorEnrichmentJobS3Data

        public init(s3Data: VectorEnrichmentJobS3Data) {
            self.s3Data = s3Data
        }

        private enum CodingKeys: String, CodingKey {
            case s3Data = "S3Data"
        }
    }

    public struct Filter: AWSDecodableShape {
        /// The maximum value of the filter.
        public let maximum: Float?
        /// The minimum value of the filter.
        public let minimum: Float?
        /// The name of the filter.
        public let name: String
        /// The type of the filter being used.
        public let type: String

        public init(maximum: Float? = nil, minimum: Float? = nil, name: String, type: String) {
            self.maximum = maximum
            self.minimum = minimum
            self.name = name
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case maximum = "Maximum"
            case minimum = "Minimum"
            case name = "Name"
            case type = "Type"
        }
    }

    public struct GeoMosaicConfigInput: AWSEncodableShape & AWSDecodableShape {
        /// The name of the algorithm being used for geomosaic.
        public let algorithmName: AlgorithmNameGeoMosaic?
        /// The target bands for geomosaic.
        public let targetBands: [String]?

        public init(algorithmName: AlgorithmNameGeoMosaic? = nil, targetBands: [String]? = nil) {
            self.algorithmName = algorithmName
            self.targetBands = targetBands
        }

        public func validate(name: String) throws {
            try self.validate(self.targetBands, name: "targetBands", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case algorithmName = "AlgorithmName"
            case targetBands = "TargetBands"
        }
    }

    public struct Geometry: AWSDecodableShape {
        public let coordinates: [[[Double]]]
        public let type: String

        public init(coordinates: [[[Double]]], type: String) {
            self.coordinates = coordinates
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case coordinates = "Coordinates"
            case type = "Type"
        }
    }

    public struct GetEarthObservationJobInput: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "arn", location: .uri("Arn"))
        ]

        /// The Amazon Resource Name (ARN) of the Earth Observation job.
        public let arn: String

        public init(arn: String) {
            self.arn = arn
        }

        public func validate(name: String) throws {
            try self.validate(self.arn, name: "arn", parent: name, pattern: "^arn:aws[a-z-]{0,12}:sagemaker-geospatial:[a-z0-9-]{1,25}:[0-9]{12}:earth-observation-job/[a-z0-9]{12,}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetEarthObservationJobOutput: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the Earth Observation job.
        public let arn: String
        /// The creation time of the initiated Earth Observation job.
        public let creationTime: Date
        /// The duration of Earth Observation job, in seconds.
        public let durationInSeconds: Int
        /// Details about the errors generated during the Earth Observation job.
        public let errorDetails: EarthObservationJobErrorDetails?
        /// The Amazon Resource Name (ARN) of the IAM role that you specified for the job.
        public let executionRoleArn: String?
        /// Details about the errors generated during ExportEarthObservationJob.
        public let exportErrorDetails: ExportErrorDetails?
        /// The status of the Earth Observation job.
        public let exportStatus: EarthObservationJobExportStatus?
        /// Input data for the Earth Observation job.
        public let inputConfig: InputConfigOutput
        /// An object containing information about the job configuration.
        public let jobConfig: JobConfigInput
        /// The Amazon Key Management Service (KMS) key ID for server-side encryption.
        public let kmsKeyId: String?
        /// The name of the Earth Observation job.
        public let name: String
        public let outputBands: [OutputBand]?
        /// The status of a previously initiated Earth Observation job.
        public let status: EarthObservationJobStatus
        /// Each tag consists of a key and a value.
        public let tags: [String: String]?

        public init(arn: String, creationTime: Date, durationInSeconds: Int, errorDetails: EarthObservationJobErrorDetails? = nil, executionRoleArn: String? = nil, exportErrorDetails: ExportErrorDetails? = nil, exportStatus: EarthObservationJobExportStatus? = nil, inputConfig: InputConfigOutput, jobConfig: JobConfigInput, kmsKeyId: String? = nil, name: String, outputBands: [OutputBand]? = nil, status: EarthObservationJobStatus, tags: [String: String]? = nil) {
            self.arn = arn
            self.creationTime = creationTime
            self.durationInSeconds = durationInSeconds
            self.errorDetails = errorDetails
            self.executionRoleArn = executionRoleArn
            self.exportErrorDetails = exportErrorDetails
            self.exportStatus = exportStatus
            self.inputConfig = inputConfig
            self.jobConfig = jobConfig
            self.kmsKeyId = kmsKeyId
            self.name = name
            self.outputBands = outputBands
            self.status = status
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case creationTime = "CreationTime"
            case durationInSeconds = "DurationInSeconds"
            case errorDetails = "ErrorDetails"
            case executionRoleArn = "ExecutionRoleArn"
            case exportErrorDetails = "ExportErrorDetails"
            case exportStatus = "ExportStatus"
            case inputConfig = "InputConfig"
            case jobConfig = "JobConfig"
            case kmsKeyId = "KmsKeyId"
            case name = "Name"
            case outputBands = "OutputBands"
            case status = "Status"
            case tags = "Tags"
        }
    }

    public struct GetRasterDataCollectionInput: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "arn", location: .uri("Arn"))
        ]

        /// The Amazon Resource Name (ARN) of the raster data collection.
        public let arn: String

        public init(arn: String) {
            self.arn = arn
        }

        public func validate(name: String) throws {
            try self.validate(self.arn, name: "arn", parent: name, pattern: "^arn:aws[a-z-]{0,12}:sagemaker-geospatial:[a-z0-9-]{1,25}:[0-9]{12}:raster-data-collection/(public|premium|user)/[a-z0-9]{12,}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetRasterDataCollectionOutput: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the raster data collection.
        public let arn: String
        /// A description of the raster data collection.
        public let description: String
        /// The URL of the description page.
        public let descriptionPageUrl: String
        public let imageSourceBands: [String]
        /// The name of the raster data collection.
        public let name: String
        /// The filters supported by the raster data collection.
        public let supportedFilters: [Filter]
        /// Each tag consists of a key and a value.
        public let tags: [String: String]?
        /// The raster data collection type.
        public let type: DataCollectionType

        public init(arn: String, description: String, descriptionPageUrl: String, imageSourceBands: [String], name: String, supportedFilters: [Filter], tags: [String: String]? = nil, type: DataCollectionType) {
            self.arn = arn
            self.description = description
            self.descriptionPageUrl = descriptionPageUrl
            self.imageSourceBands = imageSourceBands
            self.name = name
            self.supportedFilters = supportedFilters
            self.tags = tags
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case description = "Description"
            case descriptionPageUrl = "DescriptionPageUrl"
            case imageSourceBands = "ImageSourceBands"
            case name = "Name"
            case supportedFilters = "SupportedFilters"
            case tags = "Tags"
            case type = "Type"
        }
    }

    public struct GetTileInput: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "arn", location: .querystring("Arn")),
            AWSMemberEncoding(label: "imageAssets", location: .querystring("ImageAssets")),
            AWSMemberEncoding(label: "imageMask", location: .querystring("ImageMask")),
            AWSMemberEncoding(label: "outputDataType", location: .querystring("OutputDataType")),
            AWSMemberEncoding(label: "outputFormat", location: .querystring("OutputFormat")),
            AWSMemberEncoding(label: "propertyFilters", location: .querystring("PropertyFilters")),
            AWSMemberEncoding(label: "target", location: .querystring("Target")),
            AWSMemberEncoding(label: "timeRangeFilter", location: .querystring("TimeRangeFilter")),
            AWSMemberEncoding(label: "x", location: .uri("x")),
            AWSMemberEncoding(label: "y", location: .uri("y")),
            AWSMemberEncoding(label: "z", location: .uri("z"))
        ]

        /// The Amazon Resource Name (ARN) of the tile operation.
        public let arn: String
        /// The particular assets or bands to tile.
        public let imageAssets: [String]
        /// Determines whether or not to return a valid data mask.
        public let imageMask: Bool?
        /// The output data type of the tile operation.
        public let outputDataType: OutputType?
        /// The data format of the output tile. The formats include .npy, .png and .jpg.
        public let outputFormat: String?
        /// Property filters for the imagery to tile.
        public let propertyFilters: String?
        /// Determines what part of the Earth Observation job to tile. 'INPUT' or 'OUTPUT' are the valid options.
        public let target: TargetOptions
        /// Time range filter applied to imagery to find the images to tile.
        public let timeRangeFilter: String?
        /// The x coordinate of the tile input.
        public let x: Int
        /// The y coordinate of the tile input.
        public let y: Int
        /// The z coordinate of the tile input.
        public let z: Int

        public init(arn: String, imageAssets: [String], imageMask: Bool? = nil, outputDataType: OutputType? = nil, outputFormat: String? = nil, propertyFilters: String? = nil, target: TargetOptions, timeRangeFilter: String? = nil, x: Int, y: Int, z: Int) {
            self.arn = arn
            self.imageAssets = imageAssets
            self.imageMask = imageMask
            self.outputDataType = outputDataType
            self.outputFormat = outputFormat
            self.propertyFilters = propertyFilters
            self.target = target
            self.timeRangeFilter = timeRangeFilter
            self.x = x
            self.y = y
            self.z = z
        }

        public func validate(name: String) throws {
            try self.validate(self.arn, name: "arn", parent: name, pattern: "^arn:aws[a-z-]{0,12}:sagemaker-geospatial:[a-z0-9-]{1,25}:[0-9]{12}:earth-observation-job/[a-z0-9]{12,}$")
            try self.validate(self.imageAssets, name: "imageAssets", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetTileOutput: AWSDecodableShape & AWSShapeWithPayload {
        /// The key for the payload
        public static let _payloadPath: String = "binaryFile"
        public static let _options: AWSShapeOptions = [.rawPayload, .allowStreaming]
        public static var _encoding = [
            AWSMemberEncoding(label: "binaryFile", location: .body("BinaryFile"))
        ]

        /// The output binary file.
        public let binaryFile: AWSPayload?

        public init(binaryFile: AWSPayload? = nil) {
            self.binaryFile = binaryFile
        }

        private enum CodingKeys: String, CodingKey {
            case binaryFile = "BinaryFile"
        }
    }

    public struct GetVectorEnrichmentJobInput: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "arn", location: .uri("Arn"))
        ]

        /// The Amazon Resource Name (ARN) of the Vector Enrichment job.
        public let arn: String

        public init(arn: String) {
            self.arn = arn
        }

        public func validate(name: String) throws {
            try self.validate(self.arn, name: "arn", parent: name, pattern: "^arn:aws[a-z-]{0,12}:sagemaker-geospatial:[a-z0-9-]{1,25}:[0-9]{12}:vector-enrichment-job/[a-z0-9]{12,}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetVectorEnrichmentJobOutput: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the Vector Enrichment job.
        public let arn: String
        /// The creation time.
        public let creationTime: Date
        /// The duration of the Vector Enrichment job, in seconds.
        public let durationInSeconds: Int
        /// Details about the errors generated during the Vector Enrichment job.
        public let errorDetails: VectorEnrichmentJobErrorDetails?
        /// The Amazon Resource Name (ARN) of the IAM role that you specified for the job.
        public let executionRoleArn: String
        /// Details about the errors generated during the ExportVectorEnrichmentJob.
        public let exportErrorDetails: VectorEnrichmentJobExportErrorDetails?
        /// The export status of the Vector Enrichment job being initiated.
        public let exportStatus: VectorEnrichmentJobExportStatus?
        /// Input configuration information for the Vector Enrichment job.
        public let inputConfig: VectorEnrichmentJobInputConfig
        /// An object containing information about the job configuration.
        public let jobConfig: VectorEnrichmentJobConfig
        /// The Amazon Key Management Service (KMS) key ID for server-side encryption.
        public let kmsKeyId: String?
        /// The name of the Vector Enrichment job.
        public let name: String
        /// The status of the initiated Vector Enrichment job.
        public let status: VectorEnrichmentJobStatus
        /// Each tag consists of a key and a value.
        public let tags: [String: String]?
        /// The type of the Vector Enrichment job being initiated.
        public let type: VectorEnrichmentJobType

        public init(arn: String, creationTime: Date, durationInSeconds: Int, errorDetails: VectorEnrichmentJobErrorDetails? = nil, executionRoleArn: String, exportErrorDetails: VectorEnrichmentJobExportErrorDetails? = nil, exportStatus: VectorEnrichmentJobExportStatus? = nil, inputConfig: VectorEnrichmentJobInputConfig, jobConfig: VectorEnrichmentJobConfig, kmsKeyId: String? = nil, name: String, status: VectorEnrichmentJobStatus, tags: [String: String]? = nil, type: VectorEnrichmentJobType) {
            self.arn = arn
            self.creationTime = creationTime
            self.durationInSeconds = durationInSeconds
            self.errorDetails = errorDetails
            self.executionRoleArn = executionRoleArn
            self.exportErrorDetails = exportErrorDetails
            self.exportStatus = exportStatus
            self.inputConfig = inputConfig
            self.jobConfig = jobConfig
            self.kmsKeyId = kmsKeyId
            self.name = name
            self.status = status
            self.tags = tags
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case creationTime = "CreationTime"
            case durationInSeconds = "DurationInSeconds"
            case errorDetails = "ErrorDetails"
            case executionRoleArn = "ExecutionRoleArn"
            case exportErrorDetails = "ExportErrorDetails"
            case exportStatus = "ExportStatus"
            case inputConfig = "InputConfig"
            case jobConfig = "JobConfig"
            case kmsKeyId = "KmsKeyId"
            case name = "Name"
            case status = "Status"
            case tags = "Tags"
            case type = "Type"
        }
    }

    public struct InputConfigInput: AWSEncodableShape {
        /// The location of the input data.&gt;
        public let dataSourceConfig: EojDataSourceConfigInput?
        /// The Amazon Resource Name (ARN) of the previous Earth Observation job.
        public let previousEarthObservationJobArn: String?
        public let rasterDataCollectionQuery: RasterDataCollectionQueryInput?

        public init(dataSourceConfig: EojDataSourceConfigInput? = nil, previousEarthObservationJobArn: String? = nil, rasterDataCollectionQuery: RasterDataCollectionQueryInput? = nil) {
            self.dataSourceConfig = dataSourceConfig
            self.previousEarthObservationJobArn = previousEarthObservationJobArn
            self.rasterDataCollectionQuery = rasterDataCollectionQuery
        }

        public func validate(name: String) throws {
            try self.rasterDataCollectionQuery?.validate(name: "\(name).rasterDataCollectionQuery")
        }

        private enum CodingKeys: String, CodingKey {
            case dataSourceConfig = "DataSourceConfig"
            case previousEarthObservationJobArn = "PreviousEarthObservationJobArn"
            case rasterDataCollectionQuery = "RasterDataCollectionQuery"
        }
    }

    public struct InputConfigOutput: AWSDecodableShape {
        /// The location of the input data.
        public let dataSourceConfig: EojDataSourceConfigInput?
        /// The Amazon Resource Name (ARN) of the previous Earth Observation job.
        public let previousEarthObservationJobArn: String?
        public let rasterDataCollectionQuery: RasterDataCollectionQueryOutput?

        public init(dataSourceConfig: EojDataSourceConfigInput? = nil, previousEarthObservationJobArn: String? = nil, rasterDataCollectionQuery: RasterDataCollectionQueryOutput? = nil) {
            self.dataSourceConfig = dataSourceConfig
            self.previousEarthObservationJobArn = previousEarthObservationJobArn
            self.rasterDataCollectionQuery = rasterDataCollectionQuery
        }

        private enum CodingKeys: String, CodingKey {
            case dataSourceConfig = "DataSourceConfig"
            case previousEarthObservationJobArn = "PreviousEarthObservationJobArn"
            case rasterDataCollectionQuery = "RasterDataCollectionQuery"
        }
    }

    public struct ItemSource: AWSDecodableShape {
        public let assets: [String: AssetValue]?
        public let dateTime: Date
        public let geometry: Geometry
        /// A unique Id for the source item.
        public let id: String
        public let properties: Properties?

        public init(assets: [String: AssetValue]? = nil, dateTime: Date, geometry: Geometry, id: String, properties: Properties? = nil) {
            self.assets = assets
            self.dateTime = dateTime
            self.geometry = geometry
            self.id = id
            self.properties = properties
        }

        private enum CodingKeys: String, CodingKey {
            case assets = "Assets"
            case dateTime = "DateTime"
            case geometry = "Geometry"
            case id = "Id"
            case properties = "Properties"
        }
    }

    public struct LandCoverSegmentationConfigInput: AWSEncodableShape & AWSDecodableShape {
        public init() {}
    }

    public struct LandsatCloudCoverLandInput: AWSEncodableShape & AWSDecodableShape {
        public let lowerBound: Float
        public let upperBound: Float

        public init(lowerBound: Float, upperBound: Float) {
            self.lowerBound = lowerBound
            self.upperBound = upperBound
        }

        private enum CodingKeys: String, CodingKey {
            case lowerBound = "LowerBound"
            case upperBound = "UpperBound"
        }
    }

    public struct ListEarthObservationJobInput: AWSEncodableShape {
        /// The total number of items to return.
        public let maxResults: Int?
        /// If the previous response was truncated, you receive this token. Use it in your next request to receive the next set of results.
        public let nextToken: String?
        /// The parameter by which to sort the results.
        public let sortBy: String?
        /// An optional value that specifies whether you want the results sorted in Ascending or Descending order.
        public let sortOrder: SortOrder?
        /// A filter that retrieves only jobs with a specific status.
        public let statusEquals: EarthObservationJobStatus?

        public init(maxResults: Int? = nil, nextToken: String? = nil, sortBy: String? = nil, sortOrder: SortOrder? = nil, statusEquals: EarthObservationJobStatus? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.sortBy = sortBy
            self.sortOrder = sortOrder
            self.statusEquals = statusEquals
        }

        public func validate(name: String) throws {
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 8192)
        }

        private enum CodingKeys: String, CodingKey {
            case maxResults = "MaxResults"
            case nextToken = "NextToken"
            case sortBy = "SortBy"
            case sortOrder = "SortOrder"
            case statusEquals = "StatusEquals"
        }
    }

    public struct ListEarthObservationJobOutput: AWSDecodableShape {
        /// Contains summary information about the Earth Observation jobs.
        public let earthObservationJobSummaries: [ListEarthObservationJobOutputConfig]
        /// If the previous response was truncated, you receive this token. Use it in your next request to receive the next set of results.
        public let nextToken: String?

        public init(earthObservationJobSummaries: [ListEarthObservationJobOutputConfig], nextToken: String? = nil) {
            self.earthObservationJobSummaries = earthObservationJobSummaries
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case earthObservationJobSummaries = "EarthObservationJobSummaries"
            case nextToken = "NextToken"
        }
    }

    public struct ListEarthObservationJobOutputConfig: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the list of the Earth Observation jobs.
        public let arn: String
        /// The creation time.
        public let creationTime: Date
        /// The duration of the session, in seconds.
        public let durationInSeconds: Int
        /// The names of the Earth Observation jobs in the list.
        public let name: String
        public let operationType: String
        /// The status of the list of the Earth Observation jobs.
        public let status: EarthObservationJobStatus
        /// Each tag consists of a key and a value.
        public let tags: [String: String]?

        public init(arn: String, creationTime: Date, durationInSeconds: Int, name: String, operationType: String, status: EarthObservationJobStatus, tags: [String: String]? = nil) {
            self.arn = arn
            self.creationTime = creationTime
            self.durationInSeconds = durationInSeconds
            self.name = name
            self.operationType = operationType
            self.status = status
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case creationTime = "CreationTime"
            case durationInSeconds = "DurationInSeconds"
            case name = "Name"
            case operationType = "OperationType"
            case status = "Status"
            case tags = "Tags"
        }
    }

    public struct ListRasterDataCollectionsInput: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "maxResults", location: .querystring("MaxResults")),
            AWSMemberEncoding(label: "nextToken", location: .querystring("NextToken"))
        ]

        /// The total number of items to return.
        public let maxResults: Int?
        /// If the previous response was truncated, you receive this token. Use it in your next request to receive the next set of results.
        public let nextToken: String?

        public init(maxResults: Int? = nil, nextToken: String? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 8192)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListRasterDataCollectionsOutput: AWSDecodableShape {
        /// If the previous response was truncated, you receive this token. Use it in your next request to receive the next set of results.
        public let nextToken: String?
        /// Contains summary information about the raster data collection.
        public let rasterDataCollectionSummaries: [RasterDataCollectionMetadata]

        public init(nextToken: String? = nil, rasterDataCollectionSummaries: [RasterDataCollectionMetadata]) {
            self.nextToken = nextToken
            self.rasterDataCollectionSummaries = rasterDataCollectionSummaries
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "NextToken"
            case rasterDataCollectionSummaries = "RasterDataCollectionSummaries"
        }
    }

    public struct ListTagsForResourceRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "resourceArn", location: .uri("ResourceArn"))
        ]

        /// The Amazon Resource Name (ARN) of the resource you want to tag.
        public let resourceArn: String

        public init(resourceArn: String) {
            self.resourceArn = resourceArn
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, max: 2048)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListTagsForResourceResponse: AWSDecodableShape {
        /// Each tag consists of a key and a value.
        public let tags: [String: String]?

        public init(tags: [String: String]? = nil) {
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case tags = "Tags"
        }
    }

    public struct ListVectorEnrichmentJobInput: AWSEncodableShape {
        /// The maximum number of items to return.
        public let maxResults: Int?
        /// If the previous response was truncated, you receive this token. Use it in your next request to receive the next set of results.
        public let nextToken: String?
        /// The parameter by which to sort the results.
        public let sortBy: String?
        /// An optional value that specifies whether you want the results sorted in Ascending or Descending order.
        public let sortOrder: SortOrder?
        /// A filter that retrieves only jobs with a specific status.
        public let statusEquals: String?

        public init(maxResults: Int? = nil, nextToken: String? = nil, sortBy: String? = nil, sortOrder: SortOrder? = nil, statusEquals: String? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.sortBy = sortBy
            self.sortOrder = sortOrder
            self.statusEquals = statusEquals
        }

        public func validate(name: String) throws {
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 8192)
        }

        private enum CodingKeys: String, CodingKey {
            case maxResults = "MaxResults"
            case nextToken = "NextToken"
            case sortBy = "SortBy"
            case sortOrder = "SortOrder"
            case statusEquals = "StatusEquals"
        }
    }

    public struct ListVectorEnrichmentJobOutput: AWSDecodableShape {
        /// If the previous response was truncated, you receive this token. Use it in your next request to receive the next set of results.
        public let nextToken: String?
        /// Contains summary information about the Vector Enrichment jobs.
        public let vectorEnrichmentJobSummaries: [ListVectorEnrichmentJobOutputConfig]

        public init(nextToken: String? = nil, vectorEnrichmentJobSummaries: [ListVectorEnrichmentJobOutputConfig]) {
            self.nextToken = nextToken
            self.vectorEnrichmentJobSummaries = vectorEnrichmentJobSummaries
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "NextToken"
            case vectorEnrichmentJobSummaries = "VectorEnrichmentJobSummaries"
        }
    }

    public struct ListVectorEnrichmentJobOutputConfig: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the list of the Vector Enrichment jobs.
        public let arn: String
        /// The creation time.
        public let creationTime: Date
        /// The duration of the session, in seconds.
        public let durationInSeconds: Int
        /// The names of the Vector Enrichment jobs in the list.
        public let name: String
        /// The status of the Vector Enrichment jobs list.
        public let status: VectorEnrichmentJobStatus
        /// Each tag consists of a key and a value.
        public let tags: [String: String]?
        /// The type of the list of Vector Enrichment jobs.
        public let type: VectorEnrichmentJobType

        public init(arn: String, creationTime: Date, durationInSeconds: Int, name: String, status: VectorEnrichmentJobStatus, tags: [String: String]? = nil, type: VectorEnrichmentJobType) {
            self.arn = arn
            self.creationTime = creationTime
            self.durationInSeconds = durationInSeconds
            self.name = name
            self.status = status
            self.tags = tags
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case creationTime = "CreationTime"
            case durationInSeconds = "DurationInSeconds"
            case name = "Name"
            case status = "Status"
            case tags = "Tags"
            case type = "Type"
        }
    }

    public struct MapMatchingConfig: AWSEncodableShape & AWSDecodableShape {
        public let idAttributeName: String
        /// The name of the timestamp attribute.
        public let timestampAttributeName: String
        /// The name of the X-attribute
        public let xAttributeName: String
        /// The name of the Y-attribute
        public let yAttributeName: String

        public init(idAttributeName: String, timestampAttributeName: String, xAttributeName: String, yAttributeName: String) {
            self.idAttributeName = idAttributeName
            self.timestampAttributeName = timestampAttributeName
            self.xAttributeName = xAttributeName
            self.yAttributeName = yAttributeName
        }

        private enum CodingKeys: String, CodingKey {
            case idAttributeName = "IdAttributeName"
            case timestampAttributeName = "TimestampAttributeName"
            case xAttributeName = "XAttributeName"
            case yAttributeName = "YAttributeName"
        }
    }

    public struct MultiPolygonGeometryInput: AWSEncodableShape & AWSDecodableShape {
        /// The coordinates of the multipolygon geometry.
        public let coordinates: [[[[Double]]]]

        public init(coordinates: [[[[Double]]]]) {
            self.coordinates = coordinates
        }

        public func validate(name: String) throws {
            try self.coordinates.forEach {
                try validate($0, name: "coordinates[]", parent: name, min: 1)
            }
        }

        private enum CodingKeys: String, CodingKey {
            case coordinates = "Coordinates"
        }
    }

    public struct Operation: AWSEncodableShape & AWSDecodableShape {
        public let equation: String
        /// The name of the operation.
        public let name: String
        /// The type of the operation.
        public let outputType: OutputType?

        public init(equation: String, name: String, outputType: OutputType? = nil) {
            self.equation = equation
            self.name = name
            self.outputType = outputType
        }

        private enum CodingKeys: String, CodingKey {
            case equation = "Equation"
            case name = "Name"
            case outputType = "OutputType"
        }
    }

    public struct OutputBand: AWSDecodableShape {
        /// The name of the band.
        public let bandName: String
        /// The datatype of the output band.
        public let outputDataType: OutputType

        public init(bandName: String, outputDataType: OutputType) {
            self.bandName = bandName
            self.outputDataType = outputDataType
        }

        private enum CodingKeys: String, CodingKey {
            case bandName = "BandName"
            case outputDataType = "OutputDataType"
        }
    }

    public struct OutputConfigInput: AWSEncodableShape & AWSDecodableShape {
        /// Path to Amazon S3 storage location for the output configuration file.
        public let s3Data: ExportS3DataInput

        public init(s3Data: ExportS3DataInput) {
            self.s3Data = s3Data
        }

        private enum CodingKeys: String, CodingKey {
            case s3Data = "S3Data"
        }
    }

    public struct OutputResolutionResamplingInput: AWSEncodableShape & AWSDecodableShape {
        public let userDefined: UserDefined

        public init(userDefined: UserDefined) {
            self.userDefined = userDefined
        }

        private enum CodingKeys: String, CodingKey {
            case userDefined = "UserDefined"
        }
    }

    public struct OutputResolutionStackInput: AWSEncodableShape & AWSDecodableShape {
        public let predefined: PredefinedResolution?
        public let userDefined: UserDefined?

        public init(predefined: PredefinedResolution? = nil, userDefined: UserDefined? = nil) {
            self.predefined = predefined
            self.userDefined = userDefined
        }

        private enum CodingKeys: String, CodingKey {
            case predefined = "Predefined"
            case userDefined = "UserDefined"
        }
    }

    public struct PlatformInput: AWSEncodableShape & AWSDecodableShape {
        public let comparisonOperator: ComparisonOperator?
        /// The value of the platform.
        public let value: String

        public init(comparisonOperator: ComparisonOperator? = nil, value: String) {
            self.comparisonOperator = comparisonOperator
            self.value = value
        }

        private enum CodingKeys: String, CodingKey {
            case comparisonOperator = "ComparisonOperator"
            case value = "Value"
        }
    }

    public struct PolygonGeometryInput: AWSEncodableShape & AWSDecodableShape {
        public let coordinates: [[[Double]]]

        public init(coordinates: [[[Double]]]) {
            self.coordinates = coordinates
        }

        public func validate(name: String) throws {
            try self.coordinates.forEach {
                try validate($0, name: "coordinates[]", parent: name, min: 4)
            }
            try self.validate(self.coordinates, name: "coordinates", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case coordinates = "Coordinates"
        }
    }

    public struct Properties: AWSDecodableShape {
        public let eoCloudCover: Float?
        public let landsatCloudCoverLand: Float?
        public let platform: String?
        public let viewOffNadir: Float?
        public let viewSunAzimuth: Float?
        public let viewSunElevation: Float?

        public init(eoCloudCover: Float? = nil, landsatCloudCoverLand: Float? = nil, platform: String? = nil, viewOffNadir: Float? = nil, viewSunAzimuth: Float? = nil, viewSunElevation: Float? = nil) {
            self.eoCloudCover = eoCloudCover
            self.landsatCloudCoverLand = landsatCloudCoverLand
            self.platform = platform
            self.viewOffNadir = viewOffNadir
            self.viewSunAzimuth = viewSunAzimuth
            self.viewSunElevation = viewSunElevation
        }

        private enum CodingKeys: String, CodingKey {
            case eoCloudCover = "EoCloudCover"
            case landsatCloudCoverLand = "LandsatCloudCoverLand"
            case platform = "Platform"
            case viewOffNadir = "ViewOffNadir"
            case viewSunAzimuth = "ViewSunAzimuth"
            case viewSunElevation = "ViewSunElevation"
        }
    }

    public struct PropertyFilter: AWSEncodableShape & AWSDecodableShape {
        public let property: Property

        public init(property: Property) {
            self.property = property
        }

        private enum CodingKeys: String, CodingKey {
            case property = "Property"
        }
    }

    public struct PropertyFilters: AWSEncodableShape & AWSDecodableShape {
        public let logicalOperator: LogicalOperator?
        public let properties: [PropertyFilter]?

        public init(logicalOperator: LogicalOperator? = nil, properties: [PropertyFilter]? = nil) {
            self.logicalOperator = logicalOperator
            self.properties = properties
        }

        private enum CodingKeys: String, CodingKey {
            case logicalOperator = "LogicalOperator"
            case properties = "Properties"
        }
    }

    public struct RasterDataCollectionMetadata: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the raster data collection.
        public let arn: String
        /// A description of the raster data collection.
        public let description: String
        /// The description URL of the raster data collection.
        public let descriptionPageUrl: String?
        /// The name of the raster data collection.
        public let name: String
        public let supportedFilters: [Filter]
        /// Each tag consists of a key and a value.
        public let tags: [String: String]?
        /// The type of raster data collection.
        public let type: DataCollectionType

        public init(arn: String, description: String, descriptionPageUrl: String? = nil, name: String, supportedFilters: [Filter], tags: [String: String]? = nil, type: DataCollectionType) {
            self.arn = arn
            self.description = description
            self.descriptionPageUrl = descriptionPageUrl
            self.name = name
            self.supportedFilters = supportedFilters
            self.tags = tags
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case description = "Description"
            case descriptionPageUrl = "DescriptionPageUrl"
            case name = "Name"
            case supportedFilters = "SupportedFilters"
            case tags = "Tags"
            case type = "Type"
        }
    }

    public struct RasterDataCollectionQueryInput: AWSEncodableShape {
        /// The area of interest being queried for the raster data collection.
        public let areaOfInterest: AreaOfInterest?
        public let propertyFilters: PropertyFilters?
        /// The Amazon Resource Name (ARN) of the raster data collection.
        public let rasterDataCollectionArn: String
        public let timeRangeFilter: TimeRangeFilterInput

        public init(areaOfInterest: AreaOfInterest? = nil, propertyFilters: PropertyFilters? = nil, rasterDataCollectionArn: String, timeRangeFilter: TimeRangeFilterInput) {
            self.areaOfInterest = areaOfInterest
            self.propertyFilters = propertyFilters
            self.rasterDataCollectionArn = rasterDataCollectionArn
            self.timeRangeFilter = timeRangeFilter
        }

        public func validate(name: String) throws {
            try self.areaOfInterest?.validate(name: "\(name).areaOfInterest")
        }

        private enum CodingKeys: String, CodingKey {
            case areaOfInterest = "AreaOfInterest"
            case propertyFilters = "PropertyFilters"
            case rasterDataCollectionArn = "RasterDataCollectionArn"
            case timeRangeFilter = "TimeRangeFilter"
        }
    }

    public struct RasterDataCollectionQueryOutput: AWSDecodableShape {
        public let areaOfInterest: AreaOfInterest?
        public let propertyFilters: PropertyFilters?
        public let rasterDataCollectionArn: String
        /// The name of the raster data collection.
        public let rasterDataCollectionName: String
        public let timeRangeFilter: TimeRangeFilterInput

        public init(areaOfInterest: AreaOfInterest? = nil, propertyFilters: PropertyFilters? = nil, rasterDataCollectionArn: String, rasterDataCollectionName: String, timeRangeFilter: TimeRangeFilterInput) {
            self.areaOfInterest = areaOfInterest
            self.propertyFilters = propertyFilters
            self.rasterDataCollectionArn = rasterDataCollectionArn
            self.rasterDataCollectionName = rasterDataCollectionName
            self.timeRangeFilter = timeRangeFilter
        }

        private enum CodingKeys: String, CodingKey {
            case areaOfInterest = "AreaOfInterest"
            case propertyFilters = "PropertyFilters"
            case rasterDataCollectionArn = "RasterDataCollectionArn"
            case rasterDataCollectionName = "RasterDataCollectionName"
            case timeRangeFilter = "TimeRangeFilter"
        }
    }

    public struct RasterDataCollectionQueryWithBandFilterInput: AWSEncodableShape {
        public let areaOfInterest: AreaOfInterest?
        public let bandFilter: [String]?
        public let propertyFilters: PropertyFilters?
        public let timeRangeFilter: TimeRangeFilterInput

        public init(areaOfInterest: AreaOfInterest? = nil, bandFilter: [String]? = nil, propertyFilters: PropertyFilters? = nil, timeRangeFilter: TimeRangeFilterInput) {
            self.areaOfInterest = areaOfInterest
            self.bandFilter = bandFilter
            self.propertyFilters = propertyFilters
            self.timeRangeFilter = timeRangeFilter
        }

        public func validate(name: String) throws {
            try self.areaOfInterest?.validate(name: "\(name).areaOfInterest")
            try self.validate(self.bandFilter, name: "bandFilter", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case areaOfInterest = "AreaOfInterest"
            case bandFilter = "BandFilter"
            case propertyFilters = "PropertyFilters"
            case timeRangeFilter = "TimeRangeFilter"
        }
    }

    public struct ResamplingConfigInput: AWSEncodableShape & AWSDecodableShape {
        /// The name of the algorithm used for resampling.
        public let algorithmName: AlgorithmNameResampling?
        public let outputResolution: OutputResolutionResamplingInput
        public let targetBands: [String]?

        public init(algorithmName: AlgorithmNameResampling? = nil, outputResolution: OutputResolutionResamplingInput, targetBands: [String]? = nil) {
            self.algorithmName = algorithmName
            self.outputResolution = outputResolution
            self.targetBands = targetBands
        }

        public func validate(name: String) throws {
            try self.validate(self.targetBands, name: "targetBands", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case algorithmName = "AlgorithmName"
            case outputResolution = "OutputResolution"
            case targetBands = "TargetBands"
        }
    }

    public struct ReverseGeocodingConfig: AWSEncodableShape & AWSDecodableShape {
        public let xAttributeName: String
        public let yAttributeName: String

        public init(xAttributeName: String, yAttributeName: String) {
            self.xAttributeName = xAttributeName
            self.yAttributeName = yAttributeName
        }

        private enum CodingKeys: String, CodingKey {
            case xAttributeName = "XAttributeName"
            case yAttributeName = "YAttributeName"
        }
    }

    public struct S3DataInput: AWSEncodableShape & AWSDecodableShape {
        /// The Amazon Key Management Service (KMS) key ID for server-side encryption.
        public let kmsKeyId: String?
        public let metadataProvider: MetadataProvider
        /// The URL to the Amazon S3 input.
        public let s3Uri: String

        public init(kmsKeyId: String? = nil, metadataProvider: MetadataProvider, s3Uri: String) {
            self.kmsKeyId = kmsKeyId
            self.metadataProvider = metadataProvider
            self.s3Uri = s3Uri
        }

        private enum CodingKeys: String, CodingKey {
            case kmsKeyId = "KmsKeyId"
            case metadataProvider = "MetadataProvider"
            case s3Uri = "S3Uri"
        }
    }

    public struct SearchRasterDataCollectionInput: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the raster data collection.
        public let arn: String
        /// If the previous response was truncated, you receive this token. Use it in your next request to receive the next set of results.
        public let nextToken: String?
        public let rasterDataCollectionQuery: RasterDataCollectionQueryWithBandFilterInput

        public init(arn: String, nextToken: String? = nil, rasterDataCollectionQuery: RasterDataCollectionQueryWithBandFilterInput) {
            self.arn = arn
            self.nextToken = nextToken
            self.rasterDataCollectionQuery = rasterDataCollectionQuery
        }

        public func validate(name: String) throws {
            try self.validate(self.arn, name: "arn", parent: name, pattern: "^arn:aws[a-z-]{0,12}:sagemaker-geospatial:[a-z0-9-]{1,25}:[0-9]{12}:raster-data-collection/(public|premium|user)/[a-z0-9]{12,}$")
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 8192)
            try self.rasterDataCollectionQuery.validate(name: "\(name).rasterDataCollectionQuery")
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case nextToken = "NextToken"
            case rasterDataCollectionQuery = "RasterDataCollectionQuery"
        }
    }

    public struct SearchRasterDataCollectionOutput: AWSDecodableShape {
        public let approximateResultCount: Int
        public let items: [ItemSource]?
        /// If the previous response was truncated, you receive this token. Use it in your next request to receive the next set of results.
        public let nextToken: String?

        public init(approximateResultCount: Int, items: [ItemSource]? = nil, nextToken: String? = nil) {
            self.approximateResultCount = approximateResultCount
            self.items = items
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case approximateResultCount = "ApproximateResultCount"
            case items = "Items"
            case nextToken = "NextToken"
        }
    }

    public struct StackConfigInput: AWSEncodableShape & AWSDecodableShape {
        public let outputResolution: OutputResolutionStackInput?
        public let targetBands: [String]?

        public init(outputResolution: OutputResolutionStackInput? = nil, targetBands: [String]? = nil) {
            self.outputResolution = outputResolution
            self.targetBands = targetBands
        }

        public func validate(name: String) throws {
            try self.validate(self.targetBands, name: "targetBands", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case outputResolution = "OutputResolution"
            case targetBands = "TargetBands"
        }
    }

    public struct StartEarthObservationJobInput: AWSEncodableShape {
        /// A unique token that guarantees that the call to this API is idempotent.
        public let clientToken: String?
        /// The Amazon Resource Name (ARN) of the IAM role that you specified for the job.
        public let executionRoleArn: String?
        /// Input configuration information for the Earth Observation job.
        public let inputConfig: InputConfigInput
        /// An object containing information about the job configuration.
        public let jobConfig: JobConfigInput
        /// The Amazon Key Management Service (KMS) key ID for server-side encryption.
        public let kmsKeyId: String?
        /// The name of the Earth Observation job.
        public let name: String
        /// Each tag consists of a key and a value.
        public let tags: [String: String]?

        public init(clientToken: String? = StartEarthObservationJobInput.idempotencyToken(), executionRoleArn: String? = nil, inputConfig: InputConfigInput, jobConfig: JobConfigInput, kmsKeyId: String? = nil, name: String, tags: [String: String]? = nil) {
            self.clientToken = clientToken
            self.executionRoleArn = executionRoleArn
            self.inputConfig = inputConfig
            self.jobConfig = jobConfig
            self.kmsKeyId = kmsKeyId
            self.name = name
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.inputConfig.validate(name: "\(name).inputConfig")
            try self.jobConfig.validate(name: "\(name).jobConfig")
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "ClientToken"
            case executionRoleArn = "ExecutionRoleArn"
            case inputConfig = "InputConfig"
            case jobConfig = "JobConfig"
            case kmsKeyId = "KmsKeyId"
            case name = "Name"
            case tags = "Tags"
        }
    }

    public struct StartEarthObservationJobOutput: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the Earth Observation job.
        public let arn: String
        /// The creation time.
        public let creationTime: Date
        /// The duration of the session, in seconds.
        public let durationInSeconds: Int
        /// The Amazon Resource Name (ARN) of the IAM role that you specified for the job.
        public let executionRoleArn: String?
        /// Input configuration information for the Earth Observation job.
        public let inputConfig: InputConfigOutput?
        /// An object containing information about the job configuration.
        public let jobConfig: JobConfigInput
        /// The Amazon Key Management Service (KMS) key ID for server-side encryption.
        public let kmsKeyId: String?
        /// The name of the Earth Observation job.
        public let name: String
        /// The status of the Earth Observation job.
        public let status: EarthObservationJobStatus
        /// Each tag consists of a key and a value.
        public let tags: [String: String]?

        public init(arn: String, creationTime: Date, durationInSeconds: Int, executionRoleArn: String? = nil, inputConfig: InputConfigOutput? = nil, jobConfig: JobConfigInput, kmsKeyId: String? = nil, name: String, status: EarthObservationJobStatus, tags: [String: String]? = nil) {
            self.arn = arn
            self.creationTime = creationTime
            self.durationInSeconds = durationInSeconds
            self.executionRoleArn = executionRoleArn
            self.inputConfig = inputConfig
            self.jobConfig = jobConfig
            self.kmsKeyId = kmsKeyId
            self.name = name
            self.status = status
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case creationTime = "CreationTime"
            case durationInSeconds = "DurationInSeconds"
            case executionRoleArn = "ExecutionRoleArn"
            case inputConfig = "InputConfig"
            case jobConfig = "JobConfig"
            case kmsKeyId = "KmsKeyId"
            case name = "Name"
            case status = "Status"
            case tags = "Tags"
        }
    }

    public struct StartVectorEnrichmentJobInput: AWSEncodableShape {
        /// A unique token that guarantees that the call to this API is idempotent.
        public let clientToken: String?
        /// The Amazon Resource Name (ARN) of the IAM role that you specified for the job.
        public let executionRoleArn: String
        /// Input configuration information for the Vector Enrichment job.
        public let inputConfig: VectorEnrichmentJobInputConfig
        /// An object containing information about the job configuration.
        public let jobConfig: VectorEnrichmentJobConfig
        /// The Amazon Key Management Service (KMS) key ID for server-side encryption.
        public let kmsKeyId: String?
        /// The name of the Vector Enrichment job.
        public let name: String
        /// Each tag consists of a key and a value.
        public let tags: [String: String]?

        public init(clientToken: String? = StartVectorEnrichmentJobInput.idempotencyToken(), executionRoleArn: String, inputConfig: VectorEnrichmentJobInputConfig, jobConfig: VectorEnrichmentJobConfig, kmsKeyId: String? = nil, name: String, tags: [String: String]? = nil) {
            self.clientToken = clientToken
            self.executionRoleArn = executionRoleArn
            self.inputConfig = inputConfig
            self.jobConfig = jobConfig
            self.kmsKeyId = kmsKeyId
            self.name = name
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "ClientToken"
            case executionRoleArn = "ExecutionRoleArn"
            case inputConfig = "InputConfig"
            case jobConfig = "JobConfig"
            case kmsKeyId = "KmsKeyId"
            case name = "Name"
            case tags = "Tags"
        }
    }

    public struct StartVectorEnrichmentJobOutput: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the Vector Enrichment job.
        public let arn: String
        /// The creation time.
        public let creationTime: Date
        /// The duration of the Vector Enrichment job, in seconds.
        public let durationInSeconds: Int
        /// The Amazon Resource Name (ARN) of the IAM role that you specified for the job.
        public let executionRoleArn: String
        /// Input configuration information for starting the Vector Enrichment job.
        public let inputConfig: VectorEnrichmentJobInputConfig
        /// An object containing information about the job configuration.
        public let jobConfig: VectorEnrichmentJobConfig
        /// The Amazon Key Management Service (KMS) key ID for server-side encryption.
        public let kmsKeyId: String?
        /// The name of the Vector Enrichment job.
        public let name: String
        /// The status of the Vector Enrichment job being started.
        public let status: VectorEnrichmentJobStatus
        /// Each tag consists of a key and a value.
        public let tags: [String: String]?
        /// The type of the Vector Enrichment job.
        public let type: VectorEnrichmentJobType

        public init(arn: String, creationTime: Date, durationInSeconds: Int, executionRoleArn: String, inputConfig: VectorEnrichmentJobInputConfig, jobConfig: VectorEnrichmentJobConfig, kmsKeyId: String? = nil, name: String, status: VectorEnrichmentJobStatus, tags: [String: String]? = nil, type: VectorEnrichmentJobType) {
            self.arn = arn
            self.creationTime = creationTime
            self.durationInSeconds = durationInSeconds
            self.executionRoleArn = executionRoleArn
            self.inputConfig = inputConfig
            self.jobConfig = jobConfig
            self.kmsKeyId = kmsKeyId
            self.name = name
            self.status = status
            self.tags = tags
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case creationTime = "CreationTime"
            case durationInSeconds = "DurationInSeconds"
            case executionRoleArn = "ExecutionRoleArn"
            case inputConfig = "InputConfig"
            case jobConfig = "JobConfig"
            case kmsKeyId = "KmsKeyId"
            case name = "Name"
            case status = "Status"
            case tags = "Tags"
            case type = "Type"
        }
    }

    public struct StopEarthObservationJobInput: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the Earth Observation job being stopped.
        public let arn: String

        public init(arn: String) {
            self.arn = arn
        }

        public func validate(name: String) throws {
            try self.validate(self.arn, name: "arn", parent: name, pattern: "^arn:aws[a-z-]{0,12}:sagemaker-geospatial:[a-z0-9-]{1,25}:[0-9]{12}:earth-observation-job/[a-z0-9]{12,}$")
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
        }
    }

    public struct StopEarthObservationJobOutput: AWSDecodableShape {
        public init() {}
    }

    public struct StopVectorEnrichmentJobInput: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the Vector Enrichment job.
        public let arn: String

        public init(arn: String) {
            self.arn = arn
        }

        public func validate(name: String) throws {
            try self.validate(self.arn, name: "arn", parent: name, pattern: "^arn:aws[a-z-]{0,12}:sagemaker-geospatial:[a-z0-9-]{1,25}:[0-9]{12}:vector-enrichment-job/[a-z0-9]{12,}$")
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
        }
    }

    public struct StopVectorEnrichmentJobOutput: AWSDecodableShape {
        public init() {}
    }

    public struct TagResourceRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "resourceArn", location: .uri("ResourceArn"))
        ]

        /// The Amazon Resource Name (ARN) of the resource you want to tag.
        public let resourceArn: String
        /// Each tag consists of a key and a value.
        public let tags: [String: String]

        public init(resourceArn: String, tags: [String: String]) {
            self.resourceArn = resourceArn
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, max: 2048)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case tags = "Tags"
        }
    }

    public struct TagResourceResponse: AWSDecodableShape {
        public init() {}
    }

    public struct TemporalStatisticsConfigInput: AWSEncodableShape & AWSDecodableShape {
        public let groupBy: GroupBy?
        public let statistics: [TemporalStatistics]
        public let targetBands: [String]?

        public init(groupBy: GroupBy? = nil, statistics: [TemporalStatistics], targetBands: [String]? = nil) {
            self.groupBy = groupBy
            self.statistics = statistics
            self.targetBands = targetBands
        }

        public func validate(name: String) throws {
            try self.validate(self.statistics, name: "statistics", parent: name, min: 1)
            try self.validate(self.targetBands, name: "targetBands", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case groupBy = "GroupBy"
            case statistics = "Statistics"
            case targetBands = "TargetBands"
        }
    }

    public struct TimeRangeFilterInput: AWSEncodableShape & AWSDecodableShape {
        /// The end time for the time-range filter.
        public let endTime: Date
        /// The start time for the time-range filter.
        public let startTime: Date

        public init(endTime: Date, startTime: Date) {
            self.endTime = endTime
            self.startTime = startTime
        }

        private enum CodingKeys: String, CodingKey {
            case endTime = "EndTime"
            case startTime = "StartTime"
        }
    }

    public struct UntagResourceRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "resourceArn", location: .uri("ResourceArn")),
            AWSMemberEncoding(label: "tagKeys", location: .querystring("tagKeys"))
        ]

        /// The Amazon Resource Name (ARN) of the resource you want to untag.
        public let resourceArn: String
        /// Keys of the tags you want to remove.
        public let tagKeys: [String]

        public init(resourceArn: String, tagKeys: [String]) {
            self.resourceArn = resourceArn
            self.tagKeys = tagKeys
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, max: 2048)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, min: 1)
            try self.validate(self.tagKeys, name: "tagKeys", parent: name, max: 50)
            try self.validate(self.tagKeys, name: "tagKeys", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct UntagResourceResponse: AWSDecodableShape {
        public init() {}
    }

    public struct UserDefined: AWSEncodableShape & AWSDecodableShape {
        public let unit: Unit
        public let value: Float

        public init(unit: Unit, value: Float) {
            self.unit = unit
            self.value = value
        }

        private enum CodingKeys: String, CodingKey {
            case unit = "Unit"
            case value = "Value"
        }
    }

    public struct VectorEnrichmentJobErrorDetails: AWSDecodableShape {
        /// A message that you define and then is processed and rendered by  the Vector Enrichment job when the error occurs.
        public let errorMessage: String?
        /// The type of error generated during the Vector Enrichment job.
        public let errorType: VectorEnrichmentJobErrorType?

        public init(errorMessage: String? = nil, errorType: VectorEnrichmentJobErrorType? = nil) {
            self.errorMessage = errorMessage
            self.errorType = errorType
        }

        private enum CodingKeys: String, CodingKey {
            case errorMessage = "ErrorMessage"
            case errorType = "ErrorType"
        }
    }

    public struct VectorEnrichmentJobExportErrorDetails: AWSDecodableShape {
        /// The message providing details about the errors generated during the Vector Enrichment job.
        public let message: String?
        public let type: VectorEnrichmentJobExportErrorType?

        public init(message: String? = nil, type: VectorEnrichmentJobExportErrorType? = nil) {
            self.message = message
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case message = "Message"
            case type = "Type"
        }
    }

    public struct VectorEnrichmentJobInputConfig: AWSEncodableShape & AWSDecodableShape {
        public let dataSourceConfig: VectorEnrichmentJobDataSourceConfigInput
        public let documentType: VectorEnrichmentJobDocumentType

        public init(dataSourceConfig: VectorEnrichmentJobDataSourceConfigInput, documentType: VectorEnrichmentJobDocumentType) {
            self.dataSourceConfig = dataSourceConfig
            self.documentType = documentType
        }

        private enum CodingKeys: String, CodingKey {
            case dataSourceConfig = "DataSourceConfig"
            case documentType = "DocumentType"
        }
    }

    public struct VectorEnrichmentJobS3Data: AWSEncodableShape & AWSDecodableShape {
        /// The Amazon Key Management Service (KMS) key ID for server-side encryption.
        public let kmsKeyId: String?
        /// The URL to the Amazon S3 data for the Vector Enrichment job.
        public let s3Uri: String

        public init(kmsKeyId: String? = nil, s3Uri: String) {
            self.kmsKeyId = kmsKeyId
            self.s3Uri = s3Uri
        }

        private enum CodingKeys: String, CodingKey {
            case kmsKeyId = "KmsKeyId"
            case s3Uri = "S3Uri"
        }
    }

    public struct ViewOffNadirInput: AWSEncodableShape & AWSDecodableShape {
        public let lowerBound: Float
        public let upperBound: Float

        public init(lowerBound: Float, upperBound: Float) {
            self.lowerBound = lowerBound
            self.upperBound = upperBound
        }

        private enum CodingKeys: String, CodingKey {
            case lowerBound = "LowerBound"
            case upperBound = "UpperBound"
        }
    }

    public struct ViewSunAzimuthInput: AWSEncodableShape & AWSDecodableShape {
        public let lowerBound: Float
        public let upperBound: Float

        public init(lowerBound: Float, upperBound: Float) {
            self.lowerBound = lowerBound
            self.upperBound = upperBound
        }

        private enum CodingKeys: String, CodingKey {
            case lowerBound = "LowerBound"
            case upperBound = "UpperBound"
        }
    }

    public struct ViewSunElevationInput: AWSEncodableShape & AWSDecodableShape {
        /// The lower bound to view the sun elevation.
        public let lowerBound: Float
        /// The upper bound to view the sun elevation.
        public let upperBound: Float

        public init(lowerBound: Float, upperBound: Float) {
            self.lowerBound = lowerBound
            self.upperBound = upperBound
        }

        private enum CodingKeys: String, CodingKey {
            case lowerBound = "LowerBound"
            case upperBound = "UpperBound"
        }
    }

    public struct ZonalStatisticsConfigInput: AWSEncodableShape & AWSDecodableShape {
        public let statistics: [ZonalStatistics]
        public let targetBands: [String]?
        public let zoneS3Path: String

        public init(statistics: [ZonalStatistics], targetBands: [String]? = nil, zoneS3Path: String) {
            self.statistics = statistics
            self.targetBands = targetBands
            self.zoneS3Path = zoneS3Path
        }

        public func validate(name: String) throws {
            try self.validate(self.statistics, name: "statistics", parent: name, min: 1)
            try self.validate(self.targetBands, name: "targetBands", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case statistics = "Statistics"
            case targetBands = "TargetBands"
            case zoneS3Path = "ZoneS3Path"
        }
    }

    public struct AreaOfInterest: AWSEncodableShape & AWSDecodableShape {
        public let areaOfInterestGeometry: AreaOfInterestGeometry?

        public init(areaOfInterestGeometry: AreaOfInterestGeometry? = nil) {
            self.areaOfInterestGeometry = areaOfInterestGeometry
        }

        public func validate(name: String) throws {
            try self.areaOfInterestGeometry?.validate(name: "\(name).areaOfInterestGeometry")
        }

        private enum CodingKeys: String, CodingKey {
            case areaOfInterestGeometry = "AreaOfInterestGeometry"
        }
    }

    public struct EojDataSourceConfigInput: AWSEncodableShape & AWSDecodableShape {
        public let s3Data: S3DataInput?

        public init(s3Data: S3DataInput? = nil) {
            self.s3Data = s3Data
        }

        private enum CodingKeys: String, CodingKey {
            case s3Data = "S3Data"
        }
    }

    public struct VectorEnrichmentJobDataSourceConfigInput: AWSEncodableShape & AWSDecodableShape {
        public let s3Data: VectorEnrichmentJobS3Data?

        public init(s3Data: VectorEnrichmentJobS3Data? = nil) {
            self.s3Data = s3Data
        }

        private enum CodingKeys: String, CodingKey {
            case s3Data = "S3Data"
        }
    }
}

// MARK: - Errors

/// Error enum for SageMakerGeospatial
public struct SageMakerGeospatialErrorType: AWSErrorType {
    enum Code: String {
        case accessDeniedException = "AccessDeniedException"
        case conflictException = "ConflictException"
        case internalServerException = "InternalServerException"
        case resourceNotFoundException = "ResourceNotFoundException"
        case serviceQuotaExceededException = "ServiceQuotaExceededException"
        case throttlingException = "ThrottlingException"
        case validationException = "ValidationException"
    }

    private let error: Code
    public let context: AWSErrorContext?

    /// initialize SageMakerGeospatial
    public init?(errorCode: String, context: AWSErrorContext) {
        guard let error = Code(rawValue: errorCode) else { return nil }
        self.error = error
        self.context = context
    }

    internal init(_ error: Code) {
        self.error = error
        self.context = nil
    }

    /// return error code string
    public var errorCode: String { self.error.rawValue }

    /// You do not have sufficient access to perform this action.
    public static var accessDeniedException: Self { .init(.accessDeniedException) }
    public static var conflictException: Self { .init(.conflictException) }
    /// The request processing has failed because of an unknown error, exception, or failure.
    public static var internalServerException: Self { .init(.internalServerException) }
    public static var resourceNotFoundException: Self { .init(.resourceNotFoundException) }
    /// You have exceeded the service quota.
    public static var serviceQuotaExceededException: Self { .init(.serviceQuotaExceededException) }
    /// The request was denied due to request throttling.
    public static var throttlingException: Self { .init(.throttlingException) }
    /// The input fails to satisfy the constraints specified by an Amazon Web Services service.
    public static var validationException: Self { .init(.validationException) }
}

extension SageMakerGeospatialErrorType: Equatable {
    public static func == (lhs: SageMakerGeospatialErrorType, rhs: SageMakerGeospatialErrorType) -> Bool {
        lhs.error == rhs.error
    }
}

extension SageMakerGeospatialErrorType: CustomStringConvertible {
    public var description: String {
        return "\(self.error.rawValue): \(self.message ?? "")"
    }
}
