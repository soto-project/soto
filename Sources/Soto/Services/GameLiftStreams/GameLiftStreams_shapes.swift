//===----------------------------------------------------------------------===//
//
// This source file is part of the Soto for AWS open source project
//
// Copyright (c) 2017-2024 the Soto project authors
// Licensed under Apache License v2.0
//
// See LICENSE.txt for license information
// See CONTRIBUTORS.txt for the list of Soto project authors
//
// SPDX-License-Identifier: Apache-2.0
//
//===----------------------------------------------------------------------===//

// THIS FILE IS AUTOMATICALLY GENERATED by https://github.com/soto-project/soto-codegenerator.
// DO NOT EDIT.

#if canImport(FoundationEssentials)
import FoundationEssentials
#else
import Foundation
#endif
@_spi(SotoInternal) import SotoCore

extension GameLiftStreams {
    // MARK: Enums

    public enum ApplicationStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case deleting = "DELETING"
        case error = "ERROR"
        case initialized = "INITIALIZED"
        case processing = "PROCESSING"
        case ready = "READY"
        public var description: String { return self.rawValue }
    }

    public enum ApplicationStatusReason: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case accessDenied = "accessDenied"
        case internalError = "internalError"
        public var description: String { return self.rawValue }
    }

    public enum ExportFilesStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case failed = "FAILED"
        case pending = "PENDING"
        case succeeded = "SUCCEEDED"
        public var description: String { return self.rawValue }
    }

    public enum ReplicationStatusType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case completed = "COMPLETED"
        case replicating = "REPLICATING"
        public var description: String { return self.rawValue }
    }

    public enum RuntimeEnvironmentType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case proton = "PROTON"
        case ubuntu = "UBUNTU"
        case windows = "WINDOWS"
        public var description: String { return self.rawValue }
    }

    public enum StreamClass: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case gen4nHigh = "gen4n_high"
        case gen4nUltra = "gen4n_ultra"
        case gen4nWin2022 = "gen4n_win2022"
        case gen5nHigh = "gen5n_high"
        case gen5nUltra = "gen5n_ultra"
        case gen5nWin2022 = "gen5n_win2022"
        public var description: String { return self.rawValue }
    }

    public enum StreamGroupLocationStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case activating = "ACTIVATING"
        case active = "ACTIVE"
        case error = "ERROR"
        case removing = "REMOVING"
        public var description: String { return self.rawValue }
    }

    public enum StreamGroupStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case activating = "ACTIVATING"
        case active = "ACTIVE"
        case activeWithErrors = "ACTIVE_WITH_ERRORS"
        case deleting = "DELETING"
        case error = "ERROR"
        case updatingLocations = "UPDATING_LOCATIONS"
        public var description: String { return self.rawValue }
    }

    public enum StreamGroupStatusReason: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case internalError = "internalError"
        case noAvailableInstances = "noAvailableInstances"
        public var description: String { return self.rawValue }
    }

    public enum StreamSessionStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case activating = "ACTIVATING"
        case active = "ACTIVE"
        case connected = "CONNECTED"
        case error = "ERROR"
        case pendingClientReconnection = "PENDING_CLIENT_RECONNECTION"
        case reconnecting = "RECONNECTING"
        case terminated = "TERMINATED"
        case terminating = "TERMINATING"
        public var description: String { return self.rawValue }
    }

    public enum StreamSessionStatusReason: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case appLogS3DestinationError = "applicationLogS3DestinationError"
        case internalError = "internalError"
        case invalidSignalRequest = "invalidSignalRequest"
        case placementTimeout = "placementTimeout"
        public var description: String { return self.rawValue }
    }

    public enum `Protocol`: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case webrtc = "WebRTC"
        public var description: String { return self.rawValue }
    }

    // MARK: Shapes

    public struct AddStreamGroupLocationsInput: AWSEncodableShape {
        ///  A stream group to add the specified locations to.   This value is a
        /// 	Amazon Resource Name (ARN) that uniquely identifies the stream group resource. Format example: 1AB2C3De4.
        public let identifier: String
        ///  A set of one or more locations and the streaming capacity for each location.
        public let locationConfigurations: [LocationConfiguration]

        @inlinable
        public init(identifier: String, locationConfigurations: [LocationConfiguration]) {
            self.identifier = identifier
            self.locationConfigurations = locationConfigurations
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.identifier, key: "Identifier")
            try container.encode(self.locationConfigurations, forKey: .locationConfigurations)
        }

        public func validate(name: String) throws {
            try self.validate(self.identifier, name: "identifier", parent: name, max: 128)
            try self.validate(self.identifier, name: "identifier", parent: name, min: 1)
            try self.validate(self.identifier, name: "identifier", parent: name, pattern: "^(^[a-zA-Z0-9-]+$)|(^arn:aws:gameliftstreams:([^:\n]*):([0-9]{12}):([^:\n]*)$)$")
            try self.locationConfigurations.forEach {
                try $0.validate(name: "\(name).locationConfigurations[]")
            }
            try self.validate(self.locationConfigurations, name: "locationConfigurations", parent: name, max: 100)
            try self.validate(self.locationConfigurations, name: "locationConfigurations", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case locationConfigurations = "LocationConfigurations"
        }
    }

    public struct AddStreamGroupLocationsOutput: AWSDecodableShape {
        /// This value is the
        /// 	Amazon Resource Name (ARN) that uniquely identifies the stream group resource. Format example: 1AB2C3De4.
        public let identifier: String
        /// This value is
        /// 	set of locations, including their name, current status, and capacities.
        ///
        /// 	A location can be in one of the following states:
        ///     ACTIVATING: Amazon GameLift Streams is preparing the location. You cannot stream from, scale the capacity of, or remove this location yet.
        /// 		    ACTIVE: The location is provisioned with initial capacity. You can now stream from, scale the capacity of, or remove this location.
        /// 		    ERROR: Amazon GameLift Streams failed to set up this location. The StatusReason field describes the error. You can remove this location and try to add it again.
        /// 		    REMOVING: Amazon GameLift Streams is working to remove this location. It releases all provisioned capacity for this location in this stream group.
        ///
        public let locations: [LocationState]

        @inlinable
        public init(identifier: String, locations: [LocationState]) {
            self.identifier = identifier
            self.locations = locations
        }

        private enum CodingKeys: String, CodingKey {
            case identifier = "Identifier"
            case locations = "Locations"
        }
    }

    public struct ApplicationSummary: AWSDecodableShape {
        /// An Amazon Resource Name (ARN) that's assigned to an application resource and uniquely identifies the application across all Amazon Web Services Regions. Format is arn:aws:gameliftstreams:[AWS Region]:[AWS account]:application/[resource ID].
        public let arn: String
        /// A timestamp that indicates when this resource was created. Timestamps are expressed using in ISO8601 format, such as: 2022-12-27T22:29:40+00:00 (UTC).
        public let createdAt: Date?
        /// A human-readable label for the application. You can edit this value.
        public let description: String?
        /// An  Amazon Resource Name (ARN) or ID that uniquely identifies the application resource. Format example: ARN-arn:aws:gameliftstreams:us-west-2:123456789012:application/9ZY8X7Wv6 or ID-9ZY8X7Wv6.
        public let id: String?
        /// A timestamp that indicates when this resource  was last updated. Timestamps are expressed using in ISO8601 format, such as: 2022-12-27T22:29:40+00:00 (UTC).
        public let lastUpdatedAt: Date?
        ///  A set of configuration settings to run the application on a stream group. This configures the operating system, and can include compatibility layers and other drivers.  A runtime environment can be one of the following:    For Linux applications     Ubuntu 22.04 LTS(Type=UBUNTU, Version=22_04_LTS)       For Windows applications    Microsoft Windows Server 2022 Base (Type=WINDOWS, Version=2022)   Proton 8.0-5 (Type=PROTON, Version=20241007)   Proton 8.0-2c (Type=PROTON, Version=20230704)
        public let runtimeEnvironment: RuntimeEnvironment?
        /// The current status of the application resource. Possible statuses include the following:    INITIALIZED: Amazon GameLift Streams has received the request and is initiating the work flow to create an application.     PROCESSING: The create application work flow is in process. Amazon GameLift Streams is copying the content and caching for future deployment in a stream group.    READY: The application is ready to deploy in a stream group.    ERROR: An error occurred when setting up the application. See StatusReason for more information.    DELETING: Amazon GameLift Streams is in the process of deleting the application.
        public let status: ApplicationStatus?

        @inlinable
        public init(arn: String, createdAt: Date? = nil, description: String? = nil, id: String? = nil, lastUpdatedAt: Date? = nil, runtimeEnvironment: RuntimeEnvironment? = nil, status: ApplicationStatus? = nil) {
            self.arn = arn
            self.createdAt = createdAt
            self.description = description
            self.id = id
            self.lastUpdatedAt = lastUpdatedAt
            self.runtimeEnvironment = runtimeEnvironment
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case createdAt = "CreatedAt"
            case description = "Description"
            case id = "Id"
            case lastUpdatedAt = "LastUpdatedAt"
            case runtimeEnvironment = "RuntimeEnvironment"
            case status = "Status"
        }
    }

    public struct AssociateApplicationsInput: AWSEncodableShape {
        /// A set of applications to associate with the stream group. This value is a  set of either Amazon Resource Names (ARN) or IDs that uniquely identify application resources. Format example: ARN-arn:aws:gameliftstreams:us-west-2:123456789012:application/9ZY8X7Wv6 or ID-9ZY8X7Wv6.
        public let applicationIdentifiers: [String]
        /// A stream group to associate to the applications. This value is a  Amazon Resource Name (ARN) or ID that uniquely identifies the stream group resource. Format example: ARN-arn:aws:gameliftstreams:us-west-2:123456789012:streamgroup/1AB2C3De4 or ID-1AB2C3De4.
        public let identifier: String

        @inlinable
        public init(applicationIdentifiers: [String], identifier: String) {
            self.applicationIdentifiers = applicationIdentifiers
            self.identifier = identifier
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encode(self.applicationIdentifiers, forKey: .applicationIdentifiers)
            request.encodePath(self.identifier, key: "Identifier")
        }

        public func validate(name: String) throws {
            try self.applicationIdentifiers.forEach {
                try validate($0, name: "applicationIdentifiers[]", parent: name, max: 128)
                try validate($0, name: "applicationIdentifiers[]", parent: name, min: 1)
                try validate($0, name: "applicationIdentifiers[]", parent: name, pattern: "^(^[a-zA-Z0-9-]+$)|(^arn:aws:gameliftstreams:([^:\n]*):([0-9]{12}):([^:\n]*)$)$")
            }
            try self.validate(self.applicationIdentifiers, name: "applicationIdentifiers", parent: name, max: 50)
            try self.validate(self.applicationIdentifiers, name: "applicationIdentifiers", parent: name, min: 1)
            try self.validate(self.identifier, name: "identifier", parent: name, max: 128)
            try self.validate(self.identifier, name: "identifier", parent: name, min: 1)
            try self.validate(self.identifier, name: "identifier", parent: name, pattern: "^(^[a-zA-Z0-9-]+$)|(^arn:aws:gameliftstreams:([^:\n]*):([0-9]{12}):([^:\n]*)$)$")
        }

        private enum CodingKeys: String, CodingKey {
            case applicationIdentifiers = "ApplicationIdentifiers"
        }
    }

    public struct AssociateApplicationsOutput: AWSDecodableShape {
        /// A set of applications that are associated to the stream group. This value is a  set of either Amazon Resource Names (ARN) or IDs that uniquely identify application resources. Format example: ARN-arn:aws:gameliftstreams:us-west-2:123456789012:application/9ZY8X7Wv6 or ID-9ZY8X7Wv6.
        public let applicationArns: [String]?
        /// A stream group that is associated to the applications. This value is a  Amazon Resource Name (ARN) or ID that uniquely identifies the stream group resource. Format example: ARN-arn:aws:gameliftstreams:us-west-2:123456789012:streamgroup/1AB2C3De4 or ID-1AB2C3De4.
        public let arn: String?

        @inlinable
        public init(applicationArns: [String]? = nil, arn: String? = nil) {
            self.applicationArns = applicationArns
            self.arn = arn
        }

        private enum CodingKeys: String, CodingKey {
            case applicationArns = "ApplicationArns"
            case arn = "Arn"
        }
    }

    public struct CreateApplicationInput: AWSEncodableShape {
        /// An Amazon S3 URI to a bucket where you would like Amazon GameLift Streams to save application logs. Use the following format for the URI: s3://[bucket name]/[prefix].  Required if you specify one or more LogPaths.  The log bucket must have permissions that give Amazon GameLift Streams access to write the log files. For more information, see Getting Started in the Amazon GameLift Streams Developer Guide.
        public let applicationLogOutputUri: String?
        /// Locations of log files that your content generates during a stream session. Enter path values that are relative to the ApplicationSourceUri location. You can specify up to 10 log locations. Amazon GameLift Streams uploads designated log files to the Amazon S3 bucket that you specify in ApplicationLogOutputUri  at the end of a stream session. To retrieve stored log files, call GetStreamSession  and get the LogFileLocationUri.
        public let applicationLogPaths: [String]?
        /// The location of the content that you want to stream. Enter the URI of an Amazon S3 location (bucket name and prefixes) that contains your content. Use the following format for the URI: s3://[bucket name]/[prefix]. The location can have a multi-level prefix structure, but it must include all the files needed to run the content. Amazon GameLift Streams copies everything under the specified location. This value is immutable. To designate a different content location, create a new application.  The S3 bucket and the Amazon GameLift Streams application must be in the same Amazon Web Services Region.
        public let applicationSourceUri: String
        ///  A unique identifier that represents a client request. The request is idempotent, which ensures that an API request completes only once. When users send a request, Amazon GameLift Streams automatically populates this field.
        public let clientToken: String?
        /// A human-readable label for the application. You can update this value later.
        public let description: String
        /// The path and file name of the executable file that launches the content for streaming. Enter a path value that is relative to the location set in ApplicationSourceUri.
        public let executablePath: String
        /// A set of configuration settings to run the application on a stream group. This configures the operating system, and can include compatibility layers and other drivers. A runtime environment can be one of the following:    For Linux applications     Ubuntu 22.04 LTS(Type=UBUNTU, Version=22_04_LTS)       For Windows applications    Microsoft Windows Server 2022 Base (Type=WINDOWS, Version=2022)   Proton 8.0-5 (Type=PROTON, Version=20241007)   Proton 8.0-2c (Type=PROTON, Version=20230704)
        public let runtimeEnvironment: RuntimeEnvironment
        /// A list of labels to assign to the new application resource. Tags are developer-defined key-value pairs. Tagging Amazon Web Services resources is useful for resource management, access management and cost allocation. See  Tagging Amazon Web Services Resources in the Amazon Web Services General Reference. You can use TagResource to add tags, UntagResource to remove tags, and ListTagsForResource to view tags on existing resources. The maximum tag limit might be lower than stated. See the Amazon Web Services General Reference for actual tagging limits.
        public let tags: [String: String]?

        @inlinable
        public init(applicationLogOutputUri: String? = nil, applicationLogPaths: [String]? = nil, applicationSourceUri: String, clientToken: String? = CreateApplicationInput.idempotencyToken(), description: String, executablePath: String, runtimeEnvironment: RuntimeEnvironment, tags: [String: String]? = nil) {
            self.applicationLogOutputUri = applicationLogOutputUri
            self.applicationLogPaths = applicationLogPaths
            self.applicationSourceUri = applicationSourceUri
            self.clientToken = clientToken
            self.description = description
            self.executablePath = executablePath
            self.runtimeEnvironment = runtimeEnvironment
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.validate(self.applicationLogOutputUri, name: "applicationLogOutputUri", parent: name, max: 1024)
            try self.validate(self.applicationLogOutputUri, name: "applicationLogOutputUri", parent: name, pattern: "^$|^s3://([a-zA-Z0-9][a-zA-Z0-9._-]{1,61}[a-zA-Z0-9])(/[a-zA-Z0-9._-]+)*/?$")
            try self.applicationLogPaths?.forEach {
                try validate($0, name: "applicationLogPaths[]", parent: name, max: 1024)
            }
            try self.validate(self.applicationLogPaths, name: "applicationLogPaths", parent: name, max: 10)
            try self.validate(self.applicationSourceUri, name: "applicationSourceUri", parent: name, max: 1024)
            try self.validate(self.applicationSourceUri, name: "applicationSourceUri", parent: name, min: 1)
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 128)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 32)
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "^[\\x21-\\x7E]+$")
            try self.validate(self.description, name: "description", parent: name, max: 80)
            try self.validate(self.description, name: "description", parent: name, min: 1)
            try self.validate(self.description, name: "description", parent: name, pattern: "^[a-zA-Z0-9-_.!+@/][a-zA-Z0-9-_.!+@/ ]*$")
            try self.validate(self.executablePath, name: "executablePath", parent: name, max: 1024)
            try self.validate(self.executablePath, name: "executablePath", parent: name, min: 1)
            try self.runtimeEnvironment.validate(name: "\(name).runtimeEnvironment")
            try self.tags?.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 50)
            try self.validate(self.tags, name: "tags", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case applicationLogOutputUri = "ApplicationLogOutputUri"
            case applicationLogPaths = "ApplicationLogPaths"
            case applicationSourceUri = "ApplicationSourceUri"
            case clientToken = "ClientToken"
            case description = "Description"
            case executablePath = "ExecutablePath"
            case runtimeEnvironment = "RuntimeEnvironment"
            case tags = "Tags"
        }
    }

    public struct CreateApplicationOutput: AWSDecodableShape {
        /// An Amazon S3 URI to a bucket where you would like Amazon GameLift Streams to save application logs. Use the following format for the URI: s3://[bucket name]/[prefix].  Required if you specify one or more LogPaths.
        public let applicationLogOutputUri: String?
        /// Locations of log files that your content generates during a stream session.  Amazon GameLift Streams uploads log files to the Amazon S3 bucket that you specify in ApplicationLogOutputUri  at the end of a stream session. To retrieve stored log files, call GetStreamSession  and get the LogFileLocationUri.
        public let applicationLogPaths: [String]?
        /// The original Amazon S3 location of uploaded stream content for the application.
        public let applicationSourceUri: String?
        /// An Amazon Resource Name (ARN) that's assigned to an application resource and uniquely identifies it across all Amazon Web Services Regions. Format is arn:aws:gameliftstreams:[AWS Region]:[AWS account]:application/[resource ID].
        public let arn: String
        /// A newly created application is not associated to any stream groups. This value is empty.
        public let associatedStreamGroups: [String]?
        /// A timestamp that indicates when this resource was created. Timestamps are expressed using in ISO8601 format, such as: 2022-12-27T22:29:40+00:00 (UTC).
        public let createdAt: Date?
        /// A human-readable label for the application. You can edit this value.
        public let description: String?
        /// The path and file name of the executable file that launches the content for streaming.
        public let executablePath: String?
        /// An  Amazon Resource Name (ARN) or ID that uniquely identifies the application resource. Format example: ARN-arn:aws:gameliftstreams:us-west-2:123456789012:application/9ZY8X7Wv6 or ID-9ZY8X7Wv6.
        public let id: String?
        /// A timestamp that indicates when this resource  was last updated. Timestamps are expressed using in ISO8601 format, such as: 2022-12-27T22:29:40+00:00 (UTC).
        public let lastUpdatedAt: Date?
        /// A set of replication statuses for each location.
        public let replicationStatuses: [ReplicationStatus]?
        ///  A set of configuration settings to run the application on a stream group. This configures the operating system, and can include compatibility layers and other drivers.  A runtime environment can be one of the following:    For Linux applications     Ubuntu 22.04 LTS(Type=UBUNTU, Version=22_04_LTS)       For Windows applications    Microsoft Windows Server 2022 Base (Type=WINDOWS, Version=2022)   Proton 8.0-5 (Type=PROTON, Version=20241007)   Proton 8.0-2c (Type=PROTON, Version=20230704)
        public let runtimeEnvironment: RuntimeEnvironment?
        /// The current status of the application resource. Possible statuses include the following:    INITIALIZED: Amazon GameLift Streams has received the request and is initiating the work flow to create an application.     PROCESSING: The create application work flow is in process. Amazon GameLift Streams is copying the content and caching for future deployment in a stream group.    READY: The application is ready to deploy in a stream group.    ERROR: An error occurred when setting up the application. See StatusReason for more information.    DELETING: Amazon GameLift Streams is in the process of deleting the application.
        public let status: ApplicationStatus?
        /// A short description of the status reason when the application is in ERROR status.
        public let statusReason: ApplicationStatusReason?

        @inlinable
        public init(applicationLogOutputUri: String? = nil, applicationLogPaths: [String]? = nil, applicationSourceUri: String? = nil, arn: String, associatedStreamGroups: [String]? = nil, createdAt: Date? = nil, description: String? = nil, executablePath: String? = nil, id: String? = nil, lastUpdatedAt: Date? = nil, replicationStatuses: [ReplicationStatus]? = nil, runtimeEnvironment: RuntimeEnvironment? = nil, status: ApplicationStatus? = nil, statusReason: ApplicationStatusReason? = nil) {
            self.applicationLogOutputUri = applicationLogOutputUri
            self.applicationLogPaths = applicationLogPaths
            self.applicationSourceUri = applicationSourceUri
            self.arn = arn
            self.associatedStreamGroups = associatedStreamGroups
            self.createdAt = createdAt
            self.description = description
            self.executablePath = executablePath
            self.id = id
            self.lastUpdatedAt = lastUpdatedAt
            self.replicationStatuses = replicationStatuses
            self.runtimeEnvironment = runtimeEnvironment
            self.status = status
            self.statusReason = statusReason
        }

        private enum CodingKeys: String, CodingKey {
            case applicationLogOutputUri = "ApplicationLogOutputUri"
            case applicationLogPaths = "ApplicationLogPaths"
            case applicationSourceUri = "ApplicationSourceUri"
            case arn = "Arn"
            case associatedStreamGroups = "AssociatedStreamGroups"
            case createdAt = "CreatedAt"
            case description = "Description"
            case executablePath = "ExecutablePath"
            case id = "Id"
            case lastUpdatedAt = "LastUpdatedAt"
            case replicationStatuses = "ReplicationStatuses"
            case runtimeEnvironment = "RuntimeEnvironment"
            case status = "Status"
            case statusReason = "StatusReason"
        }
    }

    public struct CreateStreamGroupInput: AWSEncodableShape {
        ///  A unique identifier that represents a client request. The request is idempotent, which ensures that an API request completes only once. When users send a request, Amazon GameLift Streams automatically populates this field.
        public let clientToken: String?
        /// The unique identifier of the Amazon GameLift Streams application that you want to associate to a stream group as the default application. The application must be in READY status. By setting the default application identifier, you will optimize startup performance of this application in your stream group. Once set, this application cannot be disassociated from the stream group, unlike applications that are associated using AssociateApplications. If not set when creating a stream group, you will need to call AssociateApplications later, before you can start streaming.
        public let defaultApplicationIdentifier: String?
        /// A descriptive label for the stream group.
        public let description: String
        ///  A set of one or more locations and the streaming capacity for each location.
        public let locationConfigurations: [LocationConfiguration]?
        /// The target stream quality for sessions that are hosted in this stream group. Set a stream class that is appropriate to the type of content that you're streaming. Stream class determines the type of computing resources Amazon GameLift Streams uses and impacts the cost of streaming. The following options are available:  A stream class can be one of the following:     gen5n_win2022 (NVIDIA, ultra) Supports applications with extremely high 3D scene complexity. Runs applications on Microsoft Windows Server 2022 Base and supports DirectX 12. Compatible with most Unreal Engine 5.x builds, 32-bit applications, and anti-cheat technology. Uses NVIDIA A10G Tensor GPU.   Reference resolution: 1080p   Reference frame rate: 60 fps   Workload specifications: 8 vCPUs, 32 GB RAM, 24 GB VRAM   Tenancy: Supports 1 concurrent stream session       gen5n_high (NVIDIA, high) Supports applications with moderate to high 3D scene complexity. Uses NVIDIA A10G Tensor GPU.   Reference resolution: 1080p   Reference frame rate: 60 fps   Workload specifications: 4 vCPUs, 16 GB RAM, 12 GB VRAM   Tenancy: Supports up to 2 concurrent stream sessions       gen5n_ultra (NVIDIA, ultra) Supports applications with extremely high 3D scene complexity. Uses dedicated NVIDIA A10G Tensor GPU.   Reference resolution: 1080p   Reference frame rate: 60 fps   Workload specifications: 8 vCPUs, 32 GB RAM, 24 GB VRAM   Tenancy: Supports 1 concurrent stream session       gen4n_win2022 (NVIDIA, ultra) Supports applications with extremely high 3D scene complexity. Runs applications on Microsoft Windows Server 2022 Base and supports DirectX 12. Compatible with most Unreal Engine 5.2 and 5.3 builds, 32-bit applications, and anti-cheat technology. Uses NVIDIA T4 Tensor GPU.   Reference resolution: 1080p   Reference frame rate: 60 fps   Workload specifications: 8 vCPUs, 32 GB RAM, 16 GB VRAM   Tenancy: Supports 1 concurrent stream session       gen4n_high (NVIDIA, high) Supports applications with moderate to high 3D scene complexity. Uses NVIDIA T4 Tensor GPU.   Reference resolution: 1080p   Reference frame rate: 60 fps   Workload specifications: 4 vCPUs, 16 GB RAM, 8 GB VRAM   Tenancy: Supports up to 2 concurrent stream sessions       gen4n_ultra (NVIDIA, ultra) Supports applications with high 3D scene complexity. Uses dedicated NVIDIA T4 Tensor GPU.   Reference resolution: 1080p   Reference frame rate: 60 fps   Workload specifications: 8 vCPUs, 32 GB RAM, 16 GB VRAM   Tenancy: Supports 1 concurrent stream session
        public let streamClass: StreamClass
        /// A list of labels to assign to the new stream group resource. Tags are developer-defined key-value pairs. It is useful to tag Amazon Web Services resources for resource management, access management, and cost allocation. See  Tagging Amazon Web Services Resources in the Amazon Web Services General Reference. You can use TagResource, UntagResource, and ListTagsForResource to add, remove, and view tags on existing resources. The maximum tag limit might be lower than stated. See the Amazon Web Services  for actual tagging limits.
        public let tags: [String: String]?

        @inlinable
        public init(clientToken: String? = CreateStreamGroupInput.idempotencyToken(), defaultApplicationIdentifier: String? = nil, description: String, locationConfigurations: [LocationConfiguration]? = nil, streamClass: StreamClass, tags: [String: String]? = nil) {
            self.clientToken = clientToken
            self.defaultApplicationIdentifier = defaultApplicationIdentifier
            self.description = description
            self.locationConfigurations = locationConfigurations
            self.streamClass = streamClass
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 128)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 32)
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "^[\\x21-\\x7E]+$")
            try self.validate(self.defaultApplicationIdentifier, name: "defaultApplicationIdentifier", parent: name, max: 128)
            try self.validate(self.defaultApplicationIdentifier, name: "defaultApplicationIdentifier", parent: name, min: 1)
            try self.validate(self.defaultApplicationIdentifier, name: "defaultApplicationIdentifier", parent: name, pattern: "^(^[a-zA-Z0-9-]+$)|(^arn:aws:gameliftstreams:([^:\n]*):([0-9]{12}):([^:\n]*)$)$")
            try self.validate(self.description, name: "description", parent: name, max: 80)
            try self.validate(self.description, name: "description", parent: name, min: 1)
            try self.validate(self.description, name: "description", parent: name, pattern: "^[a-zA-Z0-9-_.!+@/][a-zA-Z0-9-_.!+@/ ]*$")
            try self.locationConfigurations?.forEach {
                try $0.validate(name: "\(name).locationConfigurations[]")
            }
            try self.validate(self.locationConfigurations, name: "locationConfigurations", parent: name, max: 100)
            try self.validate(self.locationConfigurations, name: "locationConfigurations", parent: name, min: 1)
            try self.tags?.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 50)
            try self.validate(self.tags, name: "tags", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "ClientToken"
            case defaultApplicationIdentifier = "DefaultApplicationIdentifier"
            case description = "Description"
            case locationConfigurations = "LocationConfigurations"
            case streamClass = "StreamClass"
            case tags = "Tags"
        }
    }

    public struct CreateStreamGroupOutput: AWSDecodableShape {
        /// An Amazon Resource Name (ARN) that is assigned to the stream group resource and that uniquely identifies the group across all Amazon Web Services Regions. Format is arn:aws:gameliftstreams:[AWS Region]:[AWS account]:streamgroup/[resource ID].
        public let arn: String
        ///  A set of applications that this stream group is associated to. You can stream any of these applications by using this stream group.  This value is a  set of Amazon Resource Names (ARNs) that uniquely identify application resources. Format example: arn:aws:gameliftstreams:us-west-2:123456789012:application/9ZY8X7Wv6.
        public let associatedApplications: [String]?
        /// A timestamp that indicates when this resource was created. Timestamps are expressed using in ISO8601 format, such as: 2022-12-27T22:29:40+00:00 (UTC).
        public let createdAt: Date?
        /// The Amazon GameLift Streams application that is associated with this stream group.
        public let defaultApplication: DefaultApplication?
        /// A descriptive label for the stream group.
        public let description: String?
        /// A unique ID value that is assigned to the resource when it's created. Format example: 1AB2C3De4.
        public let id: String?
        /// A timestamp that indicates when this resource  was last updated. Timestamps are expressed using in ISO8601 format, such as: 2022-12-27T22:29:40+00:00 (UTC).
        public let lastUpdatedAt: Date?
        /// This value is the
        /// 	set of locations, including their name, current status, and capacities.
        ///
        /// 	A location can be in one of the following states:
        ///     ACTIVATING: Amazon GameLift Streams is preparing the location. You cannot stream from, scale the capacity of, or remove this location yet.
        /// 		    ACTIVE: The location is provisioned with initial capacity. You can now stream from, scale the capacity of, or remove this location.
        /// 		    ERROR: Amazon GameLift Streams failed to set up this location. The StatusReason field describes the error. You can remove this location and try to add it again.
        /// 		    REMOVING: Amazon GameLift Streams is working to remove this location. It releases all provisioned capacity for this location in this stream group.
        ///
        public let locationStates: [LocationState]?
        /// The current status of the stream group resource. Possible statuses include the following:    ACTIVATING: The stream group is deploying and isn't ready to host streams.      ACTIVE: The stream group is ready to host streams.     ACTIVE_WITH_ERRORS: One or more locations in the stream group are in an error state. Verify the details of individual locations and remove any locations which are in error.     ERROR: An error occurred when the stream group deployed. See StatusReason for more information.     DELETING: Amazon GameLift Streams is in the process of deleting the stream group.     UPDATING_LOCATIONS: One or more locations in the stream group are in the process of updating (either activating or deleting).
        public let status: StreamGroupStatus?
        ///  A short description of the reason that the stream group is in ERROR status. The possible reasons can be one of the following:     internalError: The request can't process right now bcause of an issue with the server. Try again later. Reach out to the Amazon GameLift Streams team for more help.     noAvailableInstances: Amazon GameLift Streams does not currently have enough available On-Demand capacity to fulfill your request. Wait a few minutes and retry the request as capacity can shift frequently. You can also try to make the request using a different stream class or in another region.
        public let statusReason: StreamGroupStatusReason?
        /// The target stream quality for the stream group. A stream class can be one of the following:     gen5n_win2022 (NVIDIA, ultra) Supports applications with extremely high 3D scene complexity. Runs applications on Microsoft Windows Server 2022 Base and supports DirectX 12. Compatible with most Unreal Engine 5.x builds, 32-bit applications, and anti-cheat technology. Uses NVIDIA A10G Tensor GPU.   Reference resolution: 1080p   Reference frame rate: 60 fps   Workload specifications: 8 vCPUs, 32 GB RAM, 24 GB VRAM   Tenancy: Supports 1 concurrent stream session       gen5n_high (NVIDIA, high) Supports applications with moderate to high 3D scene complexity. Uses NVIDIA A10G Tensor GPU.   Reference resolution: 1080p   Reference frame rate: 60 fps   Workload specifications: 4 vCPUs, 16 GB RAM, 12 GB VRAM   Tenancy: Supports up to 2 concurrent stream sessions       gen5n_ultra (NVIDIA, ultra) Supports applications with extremely high 3D scene complexity. Uses dedicated NVIDIA A10G Tensor GPU.   Reference resolution: 1080p   Reference frame rate: 60 fps   Workload specifications: 8 vCPUs, 32 GB RAM, 24 GB VRAM   Tenancy: Supports 1 concurrent stream session       gen4n_win2022 (NVIDIA, ultra) Supports applications with extremely high 3D scene complexity. Runs applications on Microsoft Windows Server 2022 Base and supports DirectX 12. Compatible with most Unreal Engine 5.2 and 5.3 builds, 32-bit applications, and anti-cheat technology. Uses NVIDIA T4 Tensor GPU.   Reference resolution: 1080p   Reference frame rate: 60 fps   Workload specifications: 8 vCPUs, 32 GB RAM, 16 GB VRAM   Tenancy: Supports 1 concurrent stream session       gen4n_high (NVIDIA, high) Supports applications with moderate to high 3D scene complexity. Uses NVIDIA T4 Tensor GPU.   Reference resolution: 1080p   Reference frame rate: 60 fps   Workload specifications: 4 vCPUs, 16 GB RAM, 8 GB VRAM   Tenancy: Supports up to 2 concurrent stream sessions       gen4n_ultra (NVIDIA, ultra) Supports applications with high 3D scene complexity. Uses dedicated NVIDIA T4 Tensor GPU.   Reference resolution: 1080p   Reference frame rate: 60 fps   Workload specifications: 8 vCPUs, 32 GB RAM, 16 GB VRAM   Tenancy: Supports 1 concurrent stream session
        public let streamClass: StreamClass?

        @inlinable
        public init(arn: String, associatedApplications: [String]? = nil, createdAt: Date? = nil, defaultApplication: DefaultApplication? = nil, description: String? = nil, id: String? = nil, lastUpdatedAt: Date? = nil, locationStates: [LocationState]? = nil, status: StreamGroupStatus? = nil, statusReason: StreamGroupStatusReason? = nil, streamClass: StreamClass? = nil) {
            self.arn = arn
            self.associatedApplications = associatedApplications
            self.createdAt = createdAt
            self.defaultApplication = defaultApplication
            self.description = description
            self.id = id
            self.lastUpdatedAt = lastUpdatedAt
            self.locationStates = locationStates
            self.status = status
            self.statusReason = statusReason
            self.streamClass = streamClass
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case associatedApplications = "AssociatedApplications"
            case createdAt = "CreatedAt"
            case defaultApplication = "DefaultApplication"
            case description = "Description"
            case id = "Id"
            case lastUpdatedAt = "LastUpdatedAt"
            case locationStates = "LocationStates"
            case status = "Status"
            case statusReason = "StatusReason"
            case streamClass = "StreamClass"
        }
    }

    public struct CreateStreamSessionConnectionInput: AWSEncodableShape {
        ///  A unique identifier that represents a client request. The request is idempotent, which ensures that an API request completes only once. When users send a request, Amazon GameLift Streams automatically populates this field.
        public let clientToken: String?
        ///  Amazon Resource Name (ARN) or ID that uniquely identifies the stream group resource. Format example: ARN-arn:aws:gameliftstreams:us-west-2:123456789012:streamgroup/1AB2C3De4 or ID-1AB2C3De4.
        ///   The stream group that you want to run this stream session with. The stream group must be in ACTIVE status and have idle stream capacity.
        public let identifier: String
        /// A WebRTC ICE offer string to use when initializing a WebRTC connection. The offer is a very long JSON string. Provide the string as a text value in quotes. The offer must be newly generated, not the same offer provided to StartStreamSession.
        public let signalRequest: String
        ///  Amazon Resource Name (ARN) that uniquely identifies the stream session resource. Format example: 1AB2C3De4. The stream session must be in PENDING_CLIENT_RECONNECTION or ACTIVE status.
        public let streamSessionIdentifier: String

        @inlinable
        public init(clientToken: String? = CreateStreamSessionConnectionInput.idempotencyToken(), identifier: String, signalRequest: String, streamSessionIdentifier: String) {
            self.clientToken = clientToken
            self.identifier = identifier
            self.signalRequest = signalRequest
            self.streamSessionIdentifier = streamSessionIdentifier
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.clientToken, forKey: .clientToken)
            request.encodePath(self.identifier, key: "Identifier")
            try container.encode(self.signalRequest, forKey: .signalRequest)
            request.encodePath(self.streamSessionIdentifier, key: "StreamSessionIdentifier")
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 128)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 32)
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "^[\\x21-\\x7E]+$")
            try self.validate(self.identifier, name: "identifier", parent: name, max: 128)
            try self.validate(self.identifier, name: "identifier", parent: name, min: 1)
            try self.validate(self.identifier, name: "identifier", parent: name, pattern: "^(^[a-zA-Z0-9-]+$)|(^arn:aws:gameliftstreams:([^:\n]*):([0-9]{12}):([^:\n]*)$)$")
            try self.validate(self.signalRequest, name: "signalRequest", parent: name, min: 1)
            try self.validate(self.streamSessionIdentifier, name: "streamSessionIdentifier", parent: name, max: 128)
            try self.validate(self.streamSessionIdentifier, name: "streamSessionIdentifier", parent: name, min: 1)
            try self.validate(self.streamSessionIdentifier, name: "streamSessionIdentifier", parent: name, pattern: "^(^[a-zA-Z0-9-]+$)|(^arn:aws:gameliftstreams:([^:\n]*):([0-9]{12}):([^:\n]*)$)$")
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "ClientToken"
            case signalRequest = "SignalRequest"
        }
    }

    public struct CreateStreamSessionConnectionOutput: AWSDecodableShape {
        /// The WebRTC answer string that the stream server generates in response to the SignalRequest.
        public let signalResponse: String?

        @inlinable
        public init(signalResponse: String? = nil) {
            self.signalResponse = signalResponse
        }

        private enum CodingKeys: String, CodingKey {
            case signalResponse = "SignalResponse"
        }
    }

    public struct DefaultApplication: AWSDecodableShape {
        /// An  Amazon Resource Name (ARN) or ID that uniquely identifies the stream group resource. Format example: ARN-arn:aws:gameliftstreams:us-west-2:123456789012:streamgroup/1AB2C3De4 or ID-1AB2C3De4.
        public let arn: String?
        /// The default application of the stream group. This value is an  Amazon Resource Name (ARN) or ID that uniquely identifies the application resource. Format example: ARN-arn:aws:gameliftstreams:us-west-2:123456789012:application/9ZY8X7Wv6 or ID-9ZY8X7Wv6.
        public let id: String?

        @inlinable
        public init(arn: String? = nil, id: String? = nil) {
            self.arn = arn
            self.id = id
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case id = "Id"
        }
    }

    public struct DeleteApplicationInput: AWSEncodableShape {
        /// An  Amazon Resource Name (ARN) or ID that uniquely identifies the application resource. Format example: ARN-arn:aws:gameliftstreams:us-west-2:123456789012:application/9ZY8X7Wv6 or ID-9ZY8X7Wv6.
        public let identifier: String

        @inlinable
        public init(identifier: String) {
            self.identifier = identifier
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.identifier, key: "Identifier")
        }

        public func validate(name: String) throws {
            try self.validate(self.identifier, name: "identifier", parent: name, max: 128)
            try self.validate(self.identifier, name: "identifier", parent: name, min: 1)
            try self.validate(self.identifier, name: "identifier", parent: name, pattern: "^(^[a-zA-Z0-9-]+$)|(^arn:aws:gameliftstreams:([^:\n]*):([0-9]{12}):([^:\n]*)$)$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteStreamGroupInput: AWSEncodableShape {
        /// The unique ID value of the stream group resource to delete. Format example: 1AB2C3De4.
        public let identifier: String

        @inlinable
        public init(identifier: String) {
            self.identifier = identifier
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.identifier, key: "Identifier")
        }

        public func validate(name: String) throws {
            try self.validate(self.identifier, name: "identifier", parent: name, max: 128)
            try self.validate(self.identifier, name: "identifier", parent: name, min: 1)
            try self.validate(self.identifier, name: "identifier", parent: name, pattern: "^(^[a-zA-Z0-9-]+$)|(^arn:aws:gameliftstreams:([^:\n]*):([0-9]{12}):([^:\n]*)$)$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DisassociateApplicationsInput: AWSEncodableShape {
        /// A set of applications that you want to disassociate from the stream group. This value is a  set of either Amazon Resource Names (ARN) or IDs that uniquely identify application resources. Format example: ARN-arn:aws:gameliftstreams:us-west-2:123456789012:application/9ZY8X7Wv6 or ID-9ZY8X7Wv6.
        public let applicationIdentifiers: [String]
        /// A stream group to disassociate these applications from. This value is an  Amazon Resource Name (ARN) or ID that uniquely identifies the stream group resource. Format example: ARN-arn:aws:gameliftstreams:us-west-2:123456789012:streamgroup/1AB2C3De4 or ID-1AB2C3De4.
        public let identifier: String

        @inlinable
        public init(applicationIdentifiers: [String], identifier: String) {
            self.applicationIdentifiers = applicationIdentifiers
            self.identifier = identifier
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encode(self.applicationIdentifiers, forKey: .applicationIdentifiers)
            request.encodePath(self.identifier, key: "Identifier")
        }

        public func validate(name: String) throws {
            try self.applicationIdentifiers.forEach {
                try validate($0, name: "applicationIdentifiers[]", parent: name, max: 128)
                try validate($0, name: "applicationIdentifiers[]", parent: name, min: 1)
                try validate($0, name: "applicationIdentifiers[]", parent: name, pattern: "^(^[a-zA-Z0-9-]+$)|(^arn:aws:gameliftstreams:([^:\n]*):([0-9]{12}):([^:\n]*)$)$")
            }
            try self.validate(self.applicationIdentifiers, name: "applicationIdentifiers", parent: name, max: 50)
            try self.validate(self.applicationIdentifiers, name: "applicationIdentifiers", parent: name, min: 1)
            try self.validate(self.identifier, name: "identifier", parent: name, max: 128)
            try self.validate(self.identifier, name: "identifier", parent: name, min: 1)
            try self.validate(self.identifier, name: "identifier", parent: name, pattern: "^(^[a-zA-Z0-9-]+$)|(^arn:aws:gameliftstreams:([^:\n]*):([0-9]{12}):([^:\n]*)$)$")
        }

        private enum CodingKeys: String, CodingKey {
            case applicationIdentifiers = "ApplicationIdentifiers"
        }
    }

    public struct DisassociateApplicationsOutput: AWSDecodableShape {
        /// A set of applications that are disassociated from this stream group. This value is a  set of either Amazon Resource Names (ARN) or IDs that uniquely identify application resources. Format example: ARN-arn:aws:gameliftstreams:us-west-2:123456789012:application/9ZY8X7Wv6 or ID-9ZY8X7Wv6.
        public let applicationArns: [String]?
        /// An  Amazon Resource Name (ARN) or ID that uniquely identifies the stream group resource. Format example: ARN-arn:aws:gameliftstreams:us-west-2:123456789012:streamgroup/1AB2C3De4 or ID-1AB2C3De4.
        public let arn: String?

        @inlinable
        public init(applicationArns: [String]? = nil, arn: String? = nil) {
            self.applicationArns = applicationArns
            self.arn = arn
        }

        private enum CodingKeys: String, CodingKey {
            case applicationArns = "ApplicationArns"
            case arn = "Arn"
        }
    }

    public struct ExportFilesMetadata: AWSDecodableShape {
        ///  The S3 bucket URI where Amazon GameLift Streams uploaded the set of compressed exported files for a stream session. Amazon GameLift Streams generates a ZIP file name based on the stream session metadata. Alternatively, you can provide a custom file name with  a .zip file extension.  Example 1: If you provide an S3 URI called s3://MyBucket/MyGame_Session1.zip, then Amazon GameLift Streams will save the files at that location.  Example 2: If you provide an S3 URI called s3://MyBucket/MyGameSessions_ExportedFiles/, then Amazon GameLift Streams will save the files at s3://MyBucket/MyGameSessions_ExportedFiles/YYYYMMDD-HHMMSS-appId-sg-Id-sessionId.zip or another similar name.
        public let outputUri: String?
        /// The result of the ExportStreamSessionFiles operation.
        public let status: ExportFilesStatus?
        /// A short description of the reason the export is in FAILED status.
        public let statusReason: String?

        @inlinable
        public init(outputUri: String? = nil, status: ExportFilesStatus? = nil, statusReason: String? = nil) {
            self.outputUri = outputUri
            self.status = status
            self.statusReason = statusReason
        }

        private enum CodingKeys: String, CodingKey {
            case outputUri = "OutputUri"
            case status = "Status"
            case statusReason = "StatusReason"
        }
    }

    public struct ExportStreamSessionFilesInput: AWSEncodableShape {
        /// An  Amazon Resource Name (ARN) or ID that uniquely identifies the stream group resource. Format example: ARN-arn:aws:gameliftstreams:us-west-2:123456789012:streamgroup/1AB2C3De4 or ID-1AB2C3De4.
        public let identifier: String
        ///  The S3 bucket URI where Amazon GameLift Streams uploads the set of compressed exported files for this stream session. Amazon GameLift Streams generates a ZIP file name based on the stream session metadata. Alternatively, you can provide a custom file name with  a .zip file extension.  Example 1: If you provide an S3 URI called s3://MyBucket/MyGame_Session1.zip, then Amazon GameLift Streams will save the files at that location.  Example 2: If you provide an S3 URI called s3://MyBucket/MyGameSessions_ExportedFiles/, then Amazon GameLift Streams will save the files at s3://MyBucket/MyGameSessions_ExportedFiles/YYYYMMDD-HHMMSS-appId-sg-Id-sessionId.zip or another similar name.
        public let outputUri: String
        /// An  Amazon Resource Name (ARN) or ID that uniquely identifies the stream session resource. Format example: 1AB2C3De4.
        public let streamSessionIdentifier: String

        @inlinable
        public init(identifier: String, outputUri: String, streamSessionIdentifier: String) {
            self.identifier = identifier
            self.outputUri = outputUri
            self.streamSessionIdentifier = streamSessionIdentifier
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.identifier, key: "Identifier")
            try container.encode(self.outputUri, forKey: .outputUri)
            request.encodePath(self.streamSessionIdentifier, key: "StreamSessionIdentifier")
        }

        public func validate(name: String) throws {
            try self.validate(self.identifier, name: "identifier", parent: name, max: 128)
            try self.validate(self.identifier, name: "identifier", parent: name, min: 1)
            try self.validate(self.identifier, name: "identifier", parent: name, pattern: "^(^[a-zA-Z0-9-]+$)|(^arn:aws:gameliftstreams:([^:\n]*):([0-9]{12}):([^:\n]*)$)$")
            try self.validate(self.outputUri, name: "outputUri", parent: name, max: 1024)
            try self.validate(self.outputUri, name: "outputUri", parent: name, pattern: "^s3://.*(/|\\.zip|\\.ZIP)$")
            try self.validate(self.streamSessionIdentifier, name: "streamSessionIdentifier", parent: name, max: 128)
            try self.validate(self.streamSessionIdentifier, name: "streamSessionIdentifier", parent: name, min: 1)
            try self.validate(self.streamSessionIdentifier, name: "streamSessionIdentifier", parent: name, pattern: "^(^[a-zA-Z0-9-]+$)|(^arn:aws:gameliftstreams:([^:\n]*):([0-9]{12}):([^:\n]*)$)$")
        }

        private enum CodingKeys: String, CodingKey {
            case outputUri = "OutputUri"
        }
    }

    public struct ExportStreamSessionFilesOutput: AWSDecodableShape {
        public init() {}
    }

    public struct GetApplicationInput: AWSEncodableShape {
        /// An  Amazon Resource Name (ARN) or ID that uniquely identifies the application resource. Format example: ARN-arn:aws:gameliftstreams:us-west-2:123456789012:application/9ZY8X7Wv6 or ID-9ZY8X7Wv6.
        public let identifier: String

        @inlinable
        public init(identifier: String) {
            self.identifier = identifier
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.identifier, key: "Identifier")
        }

        public func validate(name: String) throws {
            try self.validate(self.identifier, name: "identifier", parent: name, max: 128)
            try self.validate(self.identifier, name: "identifier", parent: name, min: 1)
            try self.validate(self.identifier, name: "identifier", parent: name, pattern: "^(^[a-zA-Z0-9-]+$)|(^arn:aws:gameliftstreams:([^:\n]*):([0-9]{12}):([^:\n]*)$)$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetApplicationOutput: AWSDecodableShape {
        /// An Amazon S3 URI to a bucket where you would like Amazon GameLift Streams to save application logs. Use the following format for the URI: s3://[bucket name]/[prefix].  Required if you specify one or more LogPaths.
        public let applicationLogOutputUri: String?
        /// Locations of log files that your content generates during a stream session.  Amazon GameLift Streams uploads log files to the Amazon S3 bucket that you specify in ApplicationLogOutputUri  at the end of a stream session. To retrieve stored log files, call GetStreamSession  and get the LogFileLocationUri.
        public let applicationLogPaths: [String]?
        /// The original Amazon S3 location of uploaded stream content for the application.
        public let applicationSourceUri: String?
        /// An Amazon Resource Name (ARN) that's assigned to an application resource and uniquely identifies it across all Amazon Web Services Regions. Format is arn:aws:gameliftstreams:[AWS Region]:[AWS account]:application/[resource ID].
        public let arn: String
        ///  A set of stream groups that this application is associated with. You can use any of these stream groups to stream your application.  This value is a  set of Amazon Resource Names (ARNs) that uniquely identify stream group resources. Format example: arn:aws:gameliftstreams:us-west-2:123456789012:streamgroup/1AB2C3De4.
        public let associatedStreamGroups: [String]?
        /// A timestamp that indicates when this resource was created. Timestamps are expressed using in ISO8601 format, such as: 2022-12-27T22:29:40+00:00 (UTC).
        public let createdAt: Date?
        /// A human-readable label for the application. You can edit this value.
        public let description: String?
        /// The path and file name of the executable file that launches the content for streaming.
        public let executablePath: String?
        /// An  Amazon Resource Name (ARN) or ID that uniquely identifies the application resource. Format example: ARN-arn:aws:gameliftstreams:us-west-2:123456789012:application/9ZY8X7Wv6 or ID-9ZY8X7Wv6.
        public let id: String?
        /// A timestamp that indicates when this resource  was last updated. Timestamps are expressed using in ISO8601 format, such as: 2022-12-27T22:29:40+00:00 (UTC).
        public let lastUpdatedAt: Date?
        /// A set of replication statuses for each location.
        public let replicationStatuses: [ReplicationStatus]?
        ///  A set of configuration settings to run the application on a stream group. This configures the operating system, and can include compatibility layers and other drivers.  A runtime environment can be one of the following:    For Linux applications     Ubuntu 22.04 LTS(Type=UBUNTU, Version=22_04_LTS)       For Windows applications    Microsoft Windows Server 2022 Base (Type=WINDOWS, Version=2022)   Proton 8.0-5 (Type=PROTON, Version=20241007)   Proton 8.0-2c (Type=PROTON, Version=20230704)
        public let runtimeEnvironment: RuntimeEnvironment?
        /// The current status of the application resource. Possible statuses include the following:    INITIALIZED: Amazon GameLift Streams has received the request and is initiating the work flow to create an application.     PROCESSING: The create application work flow is in process. Amazon GameLift Streams is copying the content and caching for future deployment in a stream group.    READY: The application is ready to deploy in a stream group.    ERROR: An error occurred when setting up the application. See StatusReason for more information.    DELETING: Amazon GameLift Streams is in the process of deleting the application.
        public let status: ApplicationStatus?
        /// A short description of the status reason when the application is in ERROR status.
        public let statusReason: ApplicationStatusReason?

        @inlinable
        public init(applicationLogOutputUri: String? = nil, applicationLogPaths: [String]? = nil, applicationSourceUri: String? = nil, arn: String, associatedStreamGroups: [String]? = nil, createdAt: Date? = nil, description: String? = nil, executablePath: String? = nil, id: String? = nil, lastUpdatedAt: Date? = nil, replicationStatuses: [ReplicationStatus]? = nil, runtimeEnvironment: RuntimeEnvironment? = nil, status: ApplicationStatus? = nil, statusReason: ApplicationStatusReason? = nil) {
            self.applicationLogOutputUri = applicationLogOutputUri
            self.applicationLogPaths = applicationLogPaths
            self.applicationSourceUri = applicationSourceUri
            self.arn = arn
            self.associatedStreamGroups = associatedStreamGroups
            self.createdAt = createdAt
            self.description = description
            self.executablePath = executablePath
            self.id = id
            self.lastUpdatedAt = lastUpdatedAt
            self.replicationStatuses = replicationStatuses
            self.runtimeEnvironment = runtimeEnvironment
            self.status = status
            self.statusReason = statusReason
        }

        private enum CodingKeys: String, CodingKey {
            case applicationLogOutputUri = "ApplicationLogOutputUri"
            case applicationLogPaths = "ApplicationLogPaths"
            case applicationSourceUri = "ApplicationSourceUri"
            case arn = "Arn"
            case associatedStreamGroups = "AssociatedStreamGroups"
            case createdAt = "CreatedAt"
            case description = "Description"
            case executablePath = "ExecutablePath"
            case id = "Id"
            case lastUpdatedAt = "LastUpdatedAt"
            case replicationStatuses = "ReplicationStatuses"
            case runtimeEnvironment = "RuntimeEnvironment"
            case status = "Status"
            case statusReason = "StatusReason"
        }
    }

    public struct GetStreamGroupInput: AWSEncodableShape {
        /// The unique ID value of the stream group resource to retrieve. Format example: 1AB2C3De4.
        public let identifier: String

        @inlinable
        public init(identifier: String) {
            self.identifier = identifier
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.identifier, key: "Identifier")
        }

        public func validate(name: String) throws {
            try self.validate(self.identifier, name: "identifier", parent: name, max: 128)
            try self.validate(self.identifier, name: "identifier", parent: name, min: 1)
            try self.validate(self.identifier, name: "identifier", parent: name, pattern: "^(^[a-zA-Z0-9-]+$)|(^arn:aws:gameliftstreams:([^:\n]*):([0-9]{12}):([^:\n]*)$)$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetStreamGroupOutput: AWSDecodableShape {
        /// An Amazon Resource Name (ARN) that is assigned to the stream group resource and that uniquely identifies the group across all Amazon Web Services Regions. Format is arn:aws:gameliftstreams:[AWS Region]:[AWS account]:streamgroup/[resource ID].
        public let arn: String
        ///  A set of applications that this stream group is associated to. You can stream any of these applications by using this stream group.  This value is a  set of Amazon Resource Names (ARNs) that uniquely identify application resources. Format example: arn:aws:gameliftstreams:us-west-2:123456789012:application/9ZY8X7Wv6.
        public let associatedApplications: [String]?
        /// A timestamp that indicates when this resource was created. Timestamps are expressed using in ISO8601 format, such as: 2022-12-27T22:29:40+00:00 (UTC).
        public let createdAt: Date?
        /// The Amazon GameLift Streams application that is associated with this stream group.
        public let defaultApplication: DefaultApplication?
        /// A descriptive label for the stream group.
        public let description: String?
        /// A unique ID value that is assigned to the resource when it's created. Format example: 1AB2C3De4.
        public let id: String?
        /// A timestamp that indicates when this resource  was last updated. Timestamps are expressed using in ISO8601 format, such as: 2022-12-27T22:29:40+00:00 (UTC).
        public let lastUpdatedAt: Date?
        /// This value is the
        /// 	set of locations, including their name, current status, and capacities.
        ///
        /// 	A location can be in one of the following states:
        ///     ACTIVATING: Amazon GameLift Streams is preparing the location. You cannot stream from, scale the capacity of, or remove this location yet.
        /// 		    ACTIVE: The location is provisioned with initial capacity. You can now stream from, scale the capacity of, or remove this location.
        /// 		    ERROR: Amazon GameLift Streams failed to set up this location. The StatusReason field describes the error. You can remove this location and try to add it again.
        /// 		    REMOVING: Amazon GameLift Streams is working to remove this location. It releases all provisioned capacity for this location in this stream group.
        ///
        public let locationStates: [LocationState]?
        /// The current status of the stream group resource. Possible statuses include the following:    ACTIVATING: The stream group is deploying and isn't ready to host streams.      ACTIVE: The stream group is ready to host streams.     ACTIVE_WITH_ERRORS: One or more locations in the stream group are in an error state. Verify the details of individual locations and remove any locations which are in error.     ERROR: An error occurred when the stream group deployed. See StatusReason for more information.     DELETING: Amazon GameLift Streams is in the process of deleting the stream group.     UPDATING_LOCATIONS: One or more locations in the stream group are in the process of updating (either activating or deleting).
        public let status: StreamGroupStatus?
        ///  A short description of the reason that the stream group is in ERROR status. The possible reasons can be one of the following:     internalError: The request can't process right now bcause of an issue with the server. Try again later. Reach out to the Amazon GameLift Streams team for more help.     noAvailableInstances: Amazon GameLift Streams does not currently have enough available On-Demand capacity to fulfill your request. Wait a few minutes and retry the request as capacity can shift frequently. You can also try to make the request using a different stream class or in another region.
        public let statusReason: StreamGroupStatusReason?
        /// The target stream quality for the stream group. A stream class can be one of the following:     gen5n_win2022 (NVIDIA, ultra) Supports applications with extremely high 3D scene complexity. Runs applications on Microsoft Windows Server 2022 Base and supports DirectX 12. Compatible with most Unreal Engine 5.x builds, 32-bit applications, and anti-cheat technology. Uses NVIDIA A10G Tensor GPU.   Reference resolution: 1080p   Reference frame rate: 60 fps   Workload specifications: 8 vCPUs, 32 GB RAM, 24 GB VRAM   Tenancy: Supports 1 concurrent stream session       gen5n_high (NVIDIA, high) Supports applications with moderate to high 3D scene complexity. Uses NVIDIA A10G Tensor GPU.   Reference resolution: 1080p   Reference frame rate: 60 fps   Workload specifications: 4 vCPUs, 16 GB RAM, 12 GB VRAM   Tenancy: Supports up to 2 concurrent stream sessions       gen5n_ultra (NVIDIA, ultra) Supports applications with extremely high 3D scene complexity. Uses dedicated NVIDIA A10G Tensor GPU.   Reference resolution: 1080p   Reference frame rate: 60 fps   Workload specifications: 8 vCPUs, 32 GB RAM, 24 GB VRAM   Tenancy: Supports 1 concurrent stream session       gen4n_win2022 (NVIDIA, ultra) Supports applications with extremely high 3D scene complexity. Runs applications on Microsoft Windows Server 2022 Base and supports DirectX 12. Compatible with most Unreal Engine 5.2 and 5.3 builds, 32-bit applications, and anti-cheat technology. Uses NVIDIA T4 Tensor GPU.   Reference resolution: 1080p   Reference frame rate: 60 fps   Workload specifications: 8 vCPUs, 32 GB RAM, 16 GB VRAM   Tenancy: Supports 1 concurrent stream session       gen4n_high (NVIDIA, high) Supports applications with moderate to high 3D scene complexity. Uses NVIDIA T4 Tensor GPU.   Reference resolution: 1080p   Reference frame rate: 60 fps   Workload specifications: 4 vCPUs, 16 GB RAM, 8 GB VRAM   Tenancy: Supports up to 2 concurrent stream sessions       gen4n_ultra (NVIDIA, ultra) Supports applications with high 3D scene complexity. Uses dedicated NVIDIA T4 Tensor GPU.   Reference resolution: 1080p   Reference frame rate: 60 fps   Workload specifications: 8 vCPUs, 32 GB RAM, 16 GB VRAM   Tenancy: Supports 1 concurrent stream session
        public let streamClass: StreamClass?

        @inlinable
        public init(arn: String, associatedApplications: [String]? = nil, createdAt: Date? = nil, defaultApplication: DefaultApplication? = nil, description: String? = nil, id: String? = nil, lastUpdatedAt: Date? = nil, locationStates: [LocationState]? = nil, status: StreamGroupStatus? = nil, statusReason: StreamGroupStatusReason? = nil, streamClass: StreamClass? = nil) {
            self.arn = arn
            self.associatedApplications = associatedApplications
            self.createdAt = createdAt
            self.defaultApplication = defaultApplication
            self.description = description
            self.id = id
            self.lastUpdatedAt = lastUpdatedAt
            self.locationStates = locationStates
            self.status = status
            self.statusReason = statusReason
            self.streamClass = streamClass
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case associatedApplications = "AssociatedApplications"
            case createdAt = "CreatedAt"
            case defaultApplication = "DefaultApplication"
            case description = "Description"
            case id = "Id"
            case lastUpdatedAt = "LastUpdatedAt"
            case locationStates = "LocationStates"
            case status = "Status"
            case statusReason = "StatusReason"
            case streamClass = "StreamClass"
        }
    }

    public struct GetStreamSessionInput: AWSEncodableShape {
        /// The stream group that runs this stream session. This value is an  Amazon Resource Name (ARN) or ID that uniquely identifies the stream group resource. Format example: ARN-arn:aws:gameliftstreams:us-west-2:123456789012:streamgroup/1AB2C3De4 or ID-1AB2C3De4.
        public let identifier: String
        /// An  Amazon Resource Name (ARN) that uniquely identifies the stream session resource. Format example: 1AB2C3De4.
        public let streamSessionIdentifier: String

        @inlinable
        public init(identifier: String, streamSessionIdentifier: String) {
            self.identifier = identifier
            self.streamSessionIdentifier = streamSessionIdentifier
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.identifier, key: "Identifier")
            request.encodePath(self.streamSessionIdentifier, key: "StreamSessionIdentifier")
        }

        public func validate(name: String) throws {
            try self.validate(self.identifier, name: "identifier", parent: name, max: 128)
            try self.validate(self.identifier, name: "identifier", parent: name, min: 1)
            try self.validate(self.identifier, name: "identifier", parent: name, pattern: "^(^[a-zA-Z0-9-]+$)|(^arn:aws:gameliftstreams:([^:\n]*):([0-9]{12}):([^:\n]*)$)$")
            try self.validate(self.streamSessionIdentifier, name: "streamSessionIdentifier", parent: name, max: 128)
            try self.validate(self.streamSessionIdentifier, name: "streamSessionIdentifier", parent: name, min: 1)
            try self.validate(self.streamSessionIdentifier, name: "streamSessionIdentifier", parent: name, pattern: "^(^[a-zA-Z0-9-]+$)|(^arn:aws:gameliftstreams:([^:\n]*):([0-9]{12}):([^:\n]*)$)$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetStreamSessionOutput: AWSDecodableShape {
        /// A set of options that you can use to control the stream session runtime environment, expressed as a set of key-value pairs.  You can use this to configure the application or stream session details. You can also provide custom environment variables that Amazon GameLift Streams passes to your game client.  If you want to debug your application with environment variables, we recommend that you do so in a local environment outside of Amazon GameLift Streams.  For more information, refer to the Compatibility Guidance in the troubleshooting section of the Developer Guide.   AdditionalEnvironmentVariables and AdditionalLaunchArgs have similar purposes.  AdditionalEnvironmentVariables passes data using environment variables; while  AdditionalLaunchArgs passes data using command-line arguments.
        public let additionalEnvironmentVariables: [String: String]?
        /// A list of CLI arguments that are sent to the streaming server when a stream session launches. You can use this to configure the application or stream session details. You can also provide custom arguments that Amazon GameLift Streams passes to your game client.  AdditionalEnvironmentVariables and AdditionalLaunchArgs have similar purposes.  AdditionalEnvironmentVariables passes data using environment variables; while  AdditionalLaunchArgs passes data using command-line arguments.
        public let additionalLaunchArgs: [String]?
        /// The application streaming in this session. This value is an  Amazon Resource Name (ARN) that uniquely identifies the application resource. Format example: arn:aws:gameliftstreams:us-west-2:123456789012:application/9ZY8X7Wv6.
        public let applicationArn: String?
        /// The Amazon Resource Name (ARN) assigned to the stream session resource. When combined with the stream group ARN, this value uniquely identifies it across all Amazon Web Services Regions. Format is arn:aws:gameliftstreams:[AWS Region]:[AWS account]:streamsession/[resource ID].
        public let arn: String?
        /// The maximum length of time (in seconds) that Amazon GameLift Streams keeps the stream session open. At this point, Amazon GameLift Streams ends the stream session regardless of any existing client connections.
        public let connectionTimeoutSeconds: Int?
        /// A timestamp that indicates when this resource was created. Timestamps are expressed using in ISO8601 format, such as: 2022-12-27T22:29:40+00:00 (UTC).
        public let createdAt: Date?
        /// A human-readable label for the stream session. You can update this value at any time.
        public let description: String?
        /// Provides
        /// 	details about the stream session's exported files.
        public let exportFilesMetadata: ExportFilesMetadata?
        /// A timestamp that indicates when this resource  was last updated. Timestamps are expressed using in ISO8601 format, such as: 2022-12-27T22:29:40+00:00 (UTC).
        public let lastUpdatedAt: Date?
        /// The location where Amazon GameLift Streams is hosting the stream session.
        /// 	A location's name. For example, us-east-1. For a complete list of locations that Amazon GameLift Streams supports, see
        /// 	the Regions and quotas section in the Amazon GameLift Streams Developer Guide
        /// .
        public let location: String?
        /// Access location for log files that your content generates during a stream session. These log files are uploaded to cloud storage location at the end of a stream session. The Amazon GameLift Streams application resource defines which log files to upload.
        public let logFileLocationUri: String?
        /// The data transfer protocol in use with the stream session.
        public let `protocol`: `Protocol`?
        /// The length of time that Amazon GameLift Streams keeps the game session open.
        public let sessionLengthSeconds: Int?
        /// The WebRTC ICE offer string that a client generates to initiate a connection to the stream session.
        public let signalRequest: String?
        /// The WebRTC answer string that the stream server generates in response to the SignalRequest.
        public let signalResponse: String?
        /// The current status of the stream session. A stream session can host clients when in ACTIVE status.
        public let status: StreamSessionStatus?
        /// A short description of the reason the stream session is in ERROR status.
        public let statusReason: StreamSessionStatusReason?
        /// The unique identifier for the Amazon GameLift Streams stream group that is hosting the stream session.
        public let streamGroupId: String?
        ///  An opaque, unique identifier for an end-user, defined by the developer.
        public let userId: String?
        /// The URL of an S3 bucket that stores Amazon GameLift Streams WebSDK files. The URL is used to establish connection with the client.
        public let webSdkProtocolUrl: String?

        @inlinable
        public init(additionalEnvironmentVariables: [String: String]? = nil, additionalLaunchArgs: [String]? = nil, applicationArn: String? = nil, arn: String? = nil, connectionTimeoutSeconds: Int? = nil, createdAt: Date? = nil, description: String? = nil, exportFilesMetadata: ExportFilesMetadata? = nil, lastUpdatedAt: Date? = nil, location: String? = nil, logFileLocationUri: String? = nil, protocol: `Protocol`? = nil, sessionLengthSeconds: Int? = nil, signalRequest: String? = nil, signalResponse: String? = nil, status: StreamSessionStatus? = nil, statusReason: StreamSessionStatusReason? = nil, streamGroupId: String? = nil, userId: String? = nil, webSdkProtocolUrl: String? = nil) {
            self.additionalEnvironmentVariables = additionalEnvironmentVariables
            self.additionalLaunchArgs = additionalLaunchArgs
            self.applicationArn = applicationArn
            self.arn = arn
            self.connectionTimeoutSeconds = connectionTimeoutSeconds
            self.createdAt = createdAt
            self.description = description
            self.exportFilesMetadata = exportFilesMetadata
            self.lastUpdatedAt = lastUpdatedAt
            self.location = location
            self.logFileLocationUri = logFileLocationUri
            self.`protocol` = `protocol`
            self.sessionLengthSeconds = sessionLengthSeconds
            self.signalRequest = signalRequest
            self.signalResponse = signalResponse
            self.status = status
            self.statusReason = statusReason
            self.streamGroupId = streamGroupId
            self.userId = userId
            self.webSdkProtocolUrl = webSdkProtocolUrl
        }

        private enum CodingKeys: String, CodingKey {
            case additionalEnvironmentVariables = "AdditionalEnvironmentVariables"
            case additionalLaunchArgs = "AdditionalLaunchArgs"
            case applicationArn = "ApplicationArn"
            case arn = "Arn"
            case connectionTimeoutSeconds = "ConnectionTimeoutSeconds"
            case createdAt = "CreatedAt"
            case description = "Description"
            case exportFilesMetadata = "ExportFilesMetadata"
            case lastUpdatedAt = "LastUpdatedAt"
            case location = "Location"
            case logFileLocationUri = "LogFileLocationUri"
            case `protocol` = "Protocol"
            case sessionLengthSeconds = "SessionLengthSeconds"
            case signalRequest = "SignalRequest"
            case signalResponse = "SignalResponse"
            case status = "Status"
            case statusReason = "StatusReason"
            case streamGroupId = "StreamGroupId"
            case userId = "UserId"
            case webSdkProtocolUrl = "WebSdkProtocolUrl"
        }
    }

    public struct ListApplicationsInput: AWSEncodableShape {
        /// The number of results to return. Use this parameter with NextToken to return results in sequential pages. Default value is 25.
        public let maxResults: Int?
        /// The  token that marks the start of the next set of results. Use this token when you retrieve results as sequential pages. To get the first page of results, omit a token value. To get the remaining pages, provide the token returned with the previous result set.
        public let nextToken: String?

        @inlinable
        public init(maxResults: Int? = nil, nextToken: String? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.maxResults, key: "MaxResults")
            request.encodeQuery(self.nextToken, key: "NextToken")
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListApplicationsOutput: AWSDecodableShape {
        /// A collection of Amazon GameLift Streams applications that are associated with the Amazon Web Services account in use. Each item includes application metadata and status.
        public let items: [ApplicationSummary]?
        /// A  token that marks the start of the next sequential page of results. If an operation doesn't return a token, you've reached the end of the list.
        public let nextToken: String?

        @inlinable
        public init(items: [ApplicationSummary]? = nil, nextToken: String? = nil) {
            self.items = items
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case items = "Items"
            case nextToken = "NextToken"
        }
    }

    public struct ListStreamGroupsInput: AWSEncodableShape {
        /// The number of results to return. Use this parameter with NextToken to return results in sequential pages. Default value is 25.
        public let maxResults: Int?
        /// A  token that marks the start of the next set of results. Use this token when you retrieve results as sequential pages. To get the first page of results, omit a token value. To get the remaining pages, provide the token returned with the previous result set.
        public let nextToken: String?

        @inlinable
        public init(maxResults: Int? = nil, nextToken: String? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.maxResults, key: "MaxResults")
            request.encodeQuery(self.nextToken, key: "NextToken")
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListStreamGroupsOutput: AWSDecodableShape {
        /// A collection of Amazon GameLift Streams stream groups that are associated with the Amazon Web Services account in use. Each item includes stream group metadata and status, but doesn't include capacity information.
        public let items: [StreamGroupSummary]?
        /// A  token that marks the start of the next sequential page of results. If an operation doesn't return a token, you've reached the end of the list.
        public let nextToken: String?

        @inlinable
        public init(items: [StreamGroupSummary]? = nil, nextToken: String? = nil) {
            self.items = items
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case items = "Items"
            case nextToken = "NextToken"
        }
    }

    public struct ListStreamSessionsByAccountInput: AWSEncodableShape {
        /// Filter by the exported files status. You can specify one status in each request to retrieve only sessions that currently have that exported files status.
        public let exportFilesStatus: ExportFilesStatus?
        /// The  number of results to return. Use this parameter with NextToken to return results in sequential pages. Default value is 25.
        public let maxResults: Int?
        /// The  token that marks the start of the next set of results. Use this token when you retrieve results as sequential pages. To get the first page of results, omit a token value. To get the remaining pages, provide the token returned with the previous result set.
        public let nextToken: String?
        /// Filter by the stream session status. You can specify one status in each request to retrieve only sessions that are currently in that status.
        public let status: StreamSessionStatus?

        @inlinable
        public init(exportFilesStatus: ExportFilesStatus? = nil, maxResults: Int? = nil, nextToken: String? = nil, status: StreamSessionStatus? = nil) {
            self.exportFilesStatus = exportFilesStatus
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.status = status
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.exportFilesStatus, key: "ExportFilesStatus")
            request.encodeQuery(self.maxResults, key: "MaxResults")
            request.encodeQuery(self.nextToken, key: "NextToken")
            request.encodeQuery(self.status, key: "Status")
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListStreamSessionsByAccountOutput: AWSDecodableShape {
        /// A collection of Amazon GameLift Streams stream sessions that are associated with a stream group and returned in response to a list request. Each item includes stream session metadata and status.
        public let items: [StreamSessionSummary]?
        /// A  token that marks the start of the next sequential page of results. If an operation doesn't return a token, you've reached the end of the list.
        public let nextToken: String?

        @inlinable
        public init(items: [StreamSessionSummary]? = nil, nextToken: String? = nil) {
            self.items = items
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case items = "Items"
            case nextToken = "NextToken"
        }
    }

    public struct ListStreamSessionsInput: AWSEncodableShape {
        /// Filter by the exported files status. You can specify one status in each request to retrieve only sessions that currently have that exported files status.
        /// 		Exported files can be in one of the following states:
        /// 	    SUCCEEDED: The exported files are successfully stored in S3 bucket.
        /// 				    FAILED: The session ended but Amazon GameLift Streams couldn't collect and upload the to S3.
        /// 				    PENDING: Either the stream session is still in progress, or uploading the exported files to the S3 bucket is in progress.
        ///
        public let exportFilesStatus: ExportFilesStatus?
        /// The unique identifier of a Amazon GameLift Streams stream group to retrieve the stream session for. You can use either the stream group ID or the Amazon Resource Name (ARN).
        public let identifier: String
        /// The  number of results to return. Use this parameter with NextToken to return results in sequential pages. Default value is 25.
        public let maxResults: Int?
        /// The  token that marks the start of the next set of results. Use this token when you retrieve results as sequential pages. To get the first page of results, omit a token value. To get the remaining pages, provide the token returned with the previous result set.
        public let nextToken: String?
        /// Filter by the stream session status. You can specify one status in each request to retrieve only sessions that are currently in that status.
        public let status: StreamSessionStatus?

        @inlinable
        public init(exportFilesStatus: ExportFilesStatus? = nil, identifier: String, maxResults: Int? = nil, nextToken: String? = nil, status: StreamSessionStatus? = nil) {
            self.exportFilesStatus = exportFilesStatus
            self.identifier = identifier
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.status = status
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.exportFilesStatus, key: "ExportFilesStatus")
            request.encodePath(self.identifier, key: "Identifier")
            request.encodeQuery(self.maxResults, key: "MaxResults")
            request.encodeQuery(self.nextToken, key: "NextToken")
            request.encodeQuery(self.status, key: "Status")
        }

        public func validate(name: String) throws {
            try self.validate(self.identifier, name: "identifier", parent: name, max: 128)
            try self.validate(self.identifier, name: "identifier", parent: name, min: 1)
            try self.validate(self.identifier, name: "identifier", parent: name, pattern: "^(^[a-zA-Z0-9-]+$)|(^arn:aws:gameliftstreams:([^:\n]*):([0-9]{12}):([^:\n]*)$)$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListStreamSessionsOutput: AWSDecodableShape {
        /// A collection of Amazon GameLift Streams stream sessions that are associated with a stream group and returned in response to a list request. Each item includes stream session metadata and status.
        public let items: [StreamSessionSummary]?
        /// A  token that marks the start of the next sequential page of results. If an operation doesn't return a token, you've reached the end of the list.
        public let nextToken: String?

        @inlinable
        public init(items: [StreamSessionSummary]? = nil, nextToken: String? = nil) {
            self.items = items
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case items = "Items"
            case nextToken = "NextToken"
        }
    }

    public struct ListTagsForResourceRequest: AWSEncodableShape {
        /// The (Amazon Resource Name (ARN) that you want to retrieve tags for. To get a Amazon GameLift Streams resource ARN, call a List or Get operation for the resource.
        public let resourceArn: String

        @inlinable
        public init(resourceArn: String) {
            self.resourceArn = resourceArn
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.resourceArn, key: "ResourceArn")
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, max: 128)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, min: 1)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, pattern: "^arn:aws:gameliftstreams:([^:\n]*):([0-9]{12}):([^:\n]*)$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListTagsForResourceResponse: AWSDecodableShape {
        /// A collection of tags that have been assigned to the specified resource.
        public let tags: [String: String]?

        @inlinable
        public init(tags: [String: String]? = nil) {
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case tags = "Tags"
        }
    }

    public struct LocationConfiguration: AWSEncodableShape {
        ///  The streaming capacity that is allocated and ready to handle stream requests without delay. You pay for this capacity whether it's in use or not. Best for quickest time from streaming request to streaming session.
        public let alwaysOnCapacity: Int?
        /// 	A location's name. For example, us-east-1. For a complete list of locations that Amazon GameLift Streams supports, see
        /// 	the Regions and quotas section in the Amazon GameLift Streams Developer Guide
        /// .
        public let locationName: String
        ///  The streaming capacity that Amazon GameLift Streams can allocate in response to stream requests, and then de-allocate when the session has terminated. This offers a cost control measure at the expense of a greater startup time (typically under 5 minutes).
        public let onDemandCapacity: Int?

        @inlinable
        public init(alwaysOnCapacity: Int? = nil, locationName: String, onDemandCapacity: Int? = nil) {
            self.alwaysOnCapacity = alwaysOnCapacity
            self.locationName = locationName
            self.onDemandCapacity = onDemandCapacity
        }

        public func validate(name: String) throws {
            try self.validate(self.alwaysOnCapacity, name: "alwaysOnCapacity", parent: name, min: 0)
            try self.validate(self.locationName, name: "locationName", parent: name, max: 20)
            try self.validate(self.locationName, name: "locationName", parent: name, min: 1)
            try self.validate(self.locationName, name: "locationName", parent: name, pattern: "^[a-zA-Z0-9-]+$")
            try self.validate(self.onDemandCapacity, name: "onDemandCapacity", parent: name, min: 0)
        }

        private enum CodingKeys: String, CodingKey {
            case alwaysOnCapacity = "AlwaysOnCapacity"
            case locationName = "LocationName"
            case onDemandCapacity = "OnDemandCapacity"
        }
    }

    public struct LocationState: AWSDecodableShape {
        /// This value is the number of compute resources that a stream group has provisioned and is ready to stream. It includes resources that are currently streaming and resources that are idle and ready to respond to stream requests.
        public let allocatedCapacity: Int?
        ///  The streaming capacity that is allocated and ready to handle stream requests without delay. You pay for this capacity whether it's in use or not. Best for quickest time from streaming request to streaming session.
        public let alwaysOnCapacity: Int?
        /// This value is the amount of allocated capacity that is not currently streaming. It represents the stream group's availability to respond to new stream requests, but not including on-demand capacity.
        public let idleCapacity: Int?
        /// 	A location's name. For example, us-east-1. For a complete list of locations that Amazon GameLift Streams supports, see
        /// 	the Regions and quotas section in the Amazon GameLift Streams Developer Guide
        /// .
        public let locationName: String?
        ///  The streaming capacity that Amazon GameLift Streams can allocate in response to stream requests, and then de-allocate when the session has terminated. This offers a cost control measure at the expense of a greater startup time (typically under 5 minutes).
        public let onDemandCapacity: Int?
        /// This value is the total number of compute resources that you request for a stream group. This includes resources that Amazon GameLift Streams has either already provisioned or is working to provision. You request capacity for each location in a stream group.
        public let requestedCapacity: Int?
        /// This value is
        /// 	set of locations, including their name, current status, and capacities.
        ///
        /// 	A location can be in one of the following states:
        ///     ACTIVATING: Amazon GameLift Streams is preparing the location. You cannot stream from, scale the capacity of, or remove this location yet.
        /// 		    ACTIVE: The location is provisioned with initial capacity. You can now stream from, scale the capacity of, or remove this location.
        /// 		    ERROR: Amazon GameLift Streams failed to set up this location. The StatusReason field describes the error. You can remove this location and try to add it again.
        /// 		    REMOVING: Amazon GameLift Streams is working to remove this location. It releases all provisioned capacity for this location in this stream group.
        ///
        public let status: StreamGroupLocationStatus?

        @inlinable
        public init(allocatedCapacity: Int? = nil, alwaysOnCapacity: Int? = nil, idleCapacity: Int? = nil, locationName: String? = nil, onDemandCapacity: Int? = nil, requestedCapacity: Int? = nil, status: StreamGroupLocationStatus? = nil) {
            self.allocatedCapacity = allocatedCapacity
            self.alwaysOnCapacity = alwaysOnCapacity
            self.idleCapacity = idleCapacity
            self.locationName = locationName
            self.onDemandCapacity = onDemandCapacity
            self.requestedCapacity = requestedCapacity
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case allocatedCapacity = "AllocatedCapacity"
            case alwaysOnCapacity = "AlwaysOnCapacity"
            case idleCapacity = "IdleCapacity"
            case locationName = "LocationName"
            case onDemandCapacity = "OnDemandCapacity"
            case requestedCapacity = "RequestedCapacity"
            case status = "Status"
        }
    }

    public struct RemoveStreamGroupLocationsInput: AWSEncodableShape {
        ///  A stream group to remove the specified locations from.    This value is a
        /// 	Amazon Resource Name (ARN) that uniquely identifies the stream group resource. Format example: 1AB2C3De4.
        ///
        public let identifier: String
        ///  A set of locations to remove this stream group.    A set of location names. For example, us-east-1. For a complete list of locations that Amazon GameLift Streams supports, see
        /// 	the Regions and quotas section in the Amazon GameLift Streams Developer Guide
        /// .
        ///
        public let locations: [String]

        @inlinable
        public init(identifier: String, locations: [String]) {
            self.identifier = identifier
            self.locations = locations
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.identifier, key: "Identifier")
            request.encodeQuery(self.locations, key: "locations")
        }

        public func validate(name: String) throws {
            try self.validate(self.identifier, name: "identifier", parent: name, max: 128)
            try self.validate(self.identifier, name: "identifier", parent: name, min: 1)
            try self.validate(self.identifier, name: "identifier", parent: name, pattern: "^(^[a-zA-Z0-9-]+$)|(^arn:aws:gameliftstreams:([^:\n]*):([0-9]{12}):([^:\n]*)$)$")
            try self.validate(self.locations, name: "locations", parent: name, max: 100)
            try self.validate(self.locations, name: "locations", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ReplicationStatus: AWSDecodableShape {
        /// 	A location's name. For example, us-east-1. For a complete list of locations that Amazon GameLift Streams supports, see
        /// 	the Regions and quotas section in the Amazon GameLift Streams Developer Guide
        /// .
        public let location: String?
        /// The current status of the replication process.
        public let status: ReplicationStatusType?

        @inlinable
        public init(location: String? = nil, status: ReplicationStatusType? = nil) {
            self.location = location
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case location = "Location"
            case status = "Status"
        }
    }

    public struct RuntimeEnvironment: AWSEncodableShape & AWSDecodableShape {
        /// The operating system and other drivers. For Proton, this also includes the Proton compatibility layer.
        public let type: RuntimeEnvironmentType
        /// Versioned container environment for the application operating system.
        public let version: String

        @inlinable
        public init(type: RuntimeEnvironmentType, version: String) {
            self.type = type
            self.version = version
        }

        public func validate(name: String) throws {
            try self.validate(self.version, name: "version", parent: name, max: 256)
            try self.validate(self.version, name: "version", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case type = "Type"
            case version = "Version"
        }
    }

    public struct StartStreamSessionInput: AWSEncodableShape {
        /// A set of options that you can use to control the stream session runtime environment, expressed as a set of key-value pairs.  You can use this to configure the application or stream session details. You can also provide custom environment variables that Amazon GameLift Streams passes to your game client.  If you want to debug your application with environment variables, we recommend that you do so in a local environment outside of Amazon GameLift Streams.  For more information, refer to the Compatibility Guidance in the troubleshooting section of the Developer Guide.   AdditionalEnvironmentVariables and AdditionalLaunchArgs have similar purposes.  AdditionalEnvironmentVariables passes data using environment variables; while  AdditionalLaunchArgs passes data using command-line arguments.
        public let additionalEnvironmentVariables: [String: String]?
        /// A list of CLI arguments that are sent to the streaming server when a stream session launches. You can use this to configure the application or stream session details. You can also provide custom arguments that Amazon GameLift Streams passes to your game client.  AdditionalEnvironmentVariables and AdditionalLaunchArgs have similar purposes.  AdditionalEnvironmentVariables passes data using environment variables; while  AdditionalLaunchArgs passes data using command-line arguments.
        public let additionalLaunchArgs: [String]?
        /// An  Amazon Resource Name (ARN) or ID that uniquely identifies the application resource. Format example: ARN-arn:aws:gameliftstreams:us-west-2:123456789012:application/9ZY8X7Wv6 or ID-9ZY8X7Wv6.
        public let applicationIdentifier: String
        ///  A unique identifier that represents a client request. The request is idempotent, which ensures that an API request completes only once. When users send a request, Amazon GameLift Streams automatically populates this field.
        public let clientToken: String?
        /// Length of time (in seconds) that Amazon GameLift Streams should wait for a client to connect to the stream session. This time span starts when the stream session reaches ACTIVE status. If no client connects before the timeout, Amazon GameLift Streams stops the stream session with status of TERMINATED. Default value is 120.
        public let connectionTimeoutSeconds: Int?
        /// A human-readable label for the stream session. You can update this value later.
        public let description: String?
        /// The stream group to run this stream session with. This value is an  Amazon Resource Name (ARN) or ID that uniquely identifies the stream group resource. Format example: ARN-arn:aws:gameliftstreams:us-west-2:123456789012:streamgroup/1AB2C3De4 or ID-1AB2C3De4.
        public let identifier: String
        ///  A list of locations, in order of priority, where you want Amazon GameLift Streams to start a stream from. Amazon GameLift Streams selects the location with the next available capacity to start a single stream session in. If this value is empty, Amazon GameLift Streams attempts to start a stream session in the primary location.   This value is A set of location names. For example, us-east-1. For a complete list of locations that Amazon GameLift Streams supports, see
        /// 	the Regions and quotas section in the Amazon GameLift Streams Developer Guide
        /// .
        ///
        public let locations: [String]?
        /// The data transport protocol to use for the stream session.
        public let `protocol`: `Protocol`
        /// The maximum length of time (in seconds) that Amazon GameLift Streams keeps the stream session open. At this point, Amazon GameLift Streams ends the stream session regardless of any existing client connections. Default value is 43200.
        public let sessionLengthSeconds: Int?
        /// A WebRTC ICE offer string to use when initializing a WebRTC connection. The offer is a very long JSON string. Provide the string as a text value in quotes.
        public let signalRequest: String
        ///  An opaque, unique identifier for an end-user, defined by the developer.
        public let userId: String?

        @inlinable
        public init(additionalEnvironmentVariables: [String: String]? = nil, additionalLaunchArgs: [String]? = nil, applicationIdentifier: String, clientToken: String? = StartStreamSessionInput.idempotencyToken(), connectionTimeoutSeconds: Int? = nil, description: String? = nil, identifier: String, locations: [String]? = nil, protocol: `Protocol`, sessionLengthSeconds: Int? = nil, signalRequest: String, userId: String? = nil) {
            self.additionalEnvironmentVariables = additionalEnvironmentVariables
            self.additionalLaunchArgs = additionalLaunchArgs
            self.applicationIdentifier = applicationIdentifier
            self.clientToken = clientToken
            self.connectionTimeoutSeconds = connectionTimeoutSeconds
            self.description = description
            self.identifier = identifier
            self.locations = locations
            self.`protocol` = `protocol`
            self.sessionLengthSeconds = sessionLengthSeconds
            self.signalRequest = signalRequest
            self.userId = userId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.additionalEnvironmentVariables, forKey: .additionalEnvironmentVariables)
            try container.encodeIfPresent(self.additionalLaunchArgs, forKey: .additionalLaunchArgs)
            try container.encode(self.applicationIdentifier, forKey: .applicationIdentifier)
            try container.encodeIfPresent(self.clientToken, forKey: .clientToken)
            try container.encodeIfPresent(self.connectionTimeoutSeconds, forKey: .connectionTimeoutSeconds)
            try container.encodeIfPresent(self.description, forKey: .description)
            request.encodePath(self.identifier, key: "Identifier")
            try container.encodeIfPresent(self.locations, forKey: .locations)
            try container.encode(self.`protocol`, forKey: .`protocol`)
            try container.encodeIfPresent(self.sessionLengthSeconds, forKey: .sessionLengthSeconds)
            try container.encode(self.signalRequest, forKey: .signalRequest)
            try container.encodeIfPresent(self.userId, forKey: .userId)
        }

        public func validate(name: String) throws {
            try self.validate(self.additionalEnvironmentVariables, name: "additionalEnvironmentVariables", parent: name, max: 50)
            try self.validate(self.additionalLaunchArgs, name: "additionalLaunchArgs", parent: name, max: 100)
            try self.validate(self.applicationIdentifier, name: "applicationIdentifier", parent: name, max: 128)
            try self.validate(self.applicationIdentifier, name: "applicationIdentifier", parent: name, min: 1)
            try self.validate(self.applicationIdentifier, name: "applicationIdentifier", parent: name, pattern: "^(^[a-zA-Z0-9-]+$)|(^arn:aws:gameliftstreams:([^:\n]*):([0-9]{12}):([^:\n]*)$)$")
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 128)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 32)
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "^[\\x21-\\x7E]+$")
            try self.validate(self.connectionTimeoutSeconds, name: "connectionTimeoutSeconds", parent: name, max: 3600)
            try self.validate(self.connectionTimeoutSeconds, name: "connectionTimeoutSeconds", parent: name, min: 1)
            try self.validate(self.description, name: "description", parent: name, max: 80)
            try self.validate(self.description, name: "description", parent: name, min: 1)
            try self.validate(self.description, name: "description", parent: name, pattern: "^[a-zA-Z0-9-_.!+@/][a-zA-Z0-9-_.!+@/ ]*$")
            try self.validate(self.identifier, name: "identifier", parent: name, max: 128)
            try self.validate(self.identifier, name: "identifier", parent: name, min: 1)
            try self.validate(self.identifier, name: "identifier", parent: name, pattern: "^(^[a-zA-Z0-9-]+$)|(^arn:aws:gameliftstreams:([^:\n]*):([0-9]{12}):([^:\n]*)$)$")
            try self.locations?.forEach {
                try validate($0, name: "locations[]", parent: name, max: 20)
                try validate($0, name: "locations[]", parent: name, min: 1)
                try validate($0, name: "locations[]", parent: name, pattern: "^[a-zA-Z0-9-]+$")
            }
            try self.validate(self.locations, name: "locations", parent: name, min: 1)
            try self.validate(self.sessionLengthSeconds, name: "sessionLengthSeconds", parent: name, max: 86400)
            try self.validate(self.sessionLengthSeconds, name: "sessionLengthSeconds", parent: name, min: 1)
            try self.validate(self.signalRequest, name: "signalRequest", parent: name, min: 1)
            try self.validate(self.userId, name: "userId", parent: name, max: 1024)
            try self.validate(self.userId, name: "userId", parent: name, pattern: "^[-_a-zA-Z0-9/=+]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case additionalEnvironmentVariables = "AdditionalEnvironmentVariables"
            case additionalLaunchArgs = "AdditionalLaunchArgs"
            case applicationIdentifier = "ApplicationIdentifier"
            case clientToken = "ClientToken"
            case connectionTimeoutSeconds = "ConnectionTimeoutSeconds"
            case description = "Description"
            case locations = "Locations"
            case `protocol` = "Protocol"
            case sessionLengthSeconds = "SessionLengthSeconds"
            case signalRequest = "SignalRequest"
            case userId = "UserId"
        }
    }

    public struct StartStreamSessionOutput: AWSDecodableShape {
        /// A set of options that you can use to control the stream session runtime environment, expressed as a set of key-value pairs.  You can use this to configure the application or stream session details. You can also provide custom environment variables that Amazon GameLift Streams passes to your game client.  If you want to debug your application with environment variables, we recommend that you do so in a local environment outside of Amazon GameLift Streams.  For more information, refer to the Compatibility Guidance in the troubleshooting section of the Developer Guide.   AdditionalEnvironmentVariables and AdditionalLaunchArgs have similar purposes.  AdditionalEnvironmentVariables passes data using environment variables; while  AdditionalLaunchArgs passes data using command-line arguments.
        public let additionalEnvironmentVariables: [String: String]?
        /// A list of CLI arguments that are sent to the streaming server when a stream session launches. You can use this to configure the application or stream session details. You can also provide custom arguments that Amazon GameLift Streams passes to your game client.  AdditionalEnvironmentVariables and AdditionalLaunchArgs have similar purposes.  AdditionalEnvironmentVariables passes data using environment variables; while  AdditionalLaunchArgs passes data using command-line arguments.
        public let additionalLaunchArgs: [String]?
        /// An  Amazon Resource Name (ARN) that uniquely identifies the application resource. Format example: arn:aws:gameliftstreams:us-west-2:123456789012:application/9ZY8X7Wv6.
        public let applicationArn: String?
        /// The Amazon Resource Name (ARN) assigned to the stream session resource. When combined with the stream group ARN, this value uniquely identifies it across all Amazon Web Services Regions. Format is arn:aws:gameliftstreams:[AWS Region]:[AWS account]:streamsession/[resource ID].
        public let arn: String?
        /// The maximum length of time (in seconds) that Amazon GameLift Streams keeps the stream session open. At this point, Amazon GameLift Streams ends the stream session regardless of any existing client connections.
        public let connectionTimeoutSeconds: Int?
        /// A timestamp that indicates when this resource was created. Timestamps are expressed using in ISO8601 format, such as: 2022-12-27T22:29:40+00:00 (UTC).
        public let createdAt: Date?
        /// A human-readable label for the stream session. You can update this value at any time.
        public let description: String?
        /// Provides
        /// 	details about the stream session's exported files.
        public let exportFilesMetadata: ExportFilesMetadata?
        /// A timestamp that indicates when this resource  was last updated. Timestamps are expressed using in ISO8601 format, such as: 2022-12-27T22:29:40+00:00 (UTC).
        public let lastUpdatedAt: Date?
        ///  The location where Amazon GameLift Streams is streaming your application from.
        /// 	A location's name. For example, us-east-1. For a complete list of locations that Amazon GameLift Streams supports, see
        /// 	the Regions and quotas section in the Amazon GameLift Streams Developer Guide
        /// .
        public let location: String?
        /// Access location for log files that your content generates during a stream session. These log files are uploaded to cloud storage location at the end of a stream session. The Amazon GameLift Streams application resource defines which log files to upload.
        public let logFileLocationUri: String?
        /// The data transfer protocol in use with the stream session.
        public let `protocol`: `Protocol`?
        /// The length of time that Amazon GameLift Streams keeps the game session open.
        public let sessionLengthSeconds: Int?
        /// The WebRTC ICE offer string that a client generates to initiate a connection to the stream session.
        public let signalRequest: String?
        /// The WebRTC answer string that the stream server generates in response to the SignalRequest.
        public let signalResponse: String?
        /// The current status of the stream session. A stream session can host clients when in ACTIVE status.
        public let status: StreamSessionStatus?
        /// A short description of the reason the stream session is in ERROR status.
        public let statusReason: StreamSessionStatusReason?
        /// The unique identifier for the Amazon GameLift Streams stream group that is hosting the stream session.
        public let streamGroupId: String?
        ///  An opaque, unique identifier for an end-user, defined by the developer.
        public let userId: String?
        /// The URL of an S3 bucket that stores Amazon GameLift Streams WebSDK files. The URL is used to establish connection with the client.
        public let webSdkProtocolUrl: String?

        @inlinable
        public init(additionalEnvironmentVariables: [String: String]? = nil, additionalLaunchArgs: [String]? = nil, applicationArn: String? = nil, arn: String? = nil, connectionTimeoutSeconds: Int? = nil, createdAt: Date? = nil, description: String? = nil, exportFilesMetadata: ExportFilesMetadata? = nil, lastUpdatedAt: Date? = nil, location: String? = nil, logFileLocationUri: String? = nil, protocol: `Protocol`? = nil, sessionLengthSeconds: Int? = nil, signalRequest: String? = nil, signalResponse: String? = nil, status: StreamSessionStatus? = nil, statusReason: StreamSessionStatusReason? = nil, streamGroupId: String? = nil, userId: String? = nil, webSdkProtocolUrl: String? = nil) {
            self.additionalEnvironmentVariables = additionalEnvironmentVariables
            self.additionalLaunchArgs = additionalLaunchArgs
            self.applicationArn = applicationArn
            self.arn = arn
            self.connectionTimeoutSeconds = connectionTimeoutSeconds
            self.createdAt = createdAt
            self.description = description
            self.exportFilesMetadata = exportFilesMetadata
            self.lastUpdatedAt = lastUpdatedAt
            self.location = location
            self.logFileLocationUri = logFileLocationUri
            self.`protocol` = `protocol`
            self.sessionLengthSeconds = sessionLengthSeconds
            self.signalRequest = signalRequest
            self.signalResponse = signalResponse
            self.status = status
            self.statusReason = statusReason
            self.streamGroupId = streamGroupId
            self.userId = userId
            self.webSdkProtocolUrl = webSdkProtocolUrl
        }

        private enum CodingKeys: String, CodingKey {
            case additionalEnvironmentVariables = "AdditionalEnvironmentVariables"
            case additionalLaunchArgs = "AdditionalLaunchArgs"
            case applicationArn = "ApplicationArn"
            case arn = "Arn"
            case connectionTimeoutSeconds = "ConnectionTimeoutSeconds"
            case createdAt = "CreatedAt"
            case description = "Description"
            case exportFilesMetadata = "ExportFilesMetadata"
            case lastUpdatedAt = "LastUpdatedAt"
            case location = "Location"
            case logFileLocationUri = "LogFileLocationUri"
            case `protocol` = "Protocol"
            case sessionLengthSeconds = "SessionLengthSeconds"
            case signalRequest = "SignalRequest"
            case signalResponse = "SignalResponse"
            case status = "Status"
            case statusReason = "StatusReason"
            case streamGroupId = "StreamGroupId"
            case userId = "UserId"
            case webSdkProtocolUrl = "WebSdkProtocolUrl"
        }
    }

    public struct StreamGroupSummary: AWSDecodableShape {
        /// An  Amazon Resource Name (ARN) or ID that uniquely identifies the stream group resource. Format example: ARN-arn:aws:gameliftstreams:us-west-2:123456789012:streamgroup/1AB2C3De4 or ID-1AB2C3De4.
        public let arn: String
        /// A timestamp that indicates when this resource was created. Timestamps are expressed using in ISO8601 format, such as: 2022-12-27T22:29:40+00:00 (UTC).
        public let createdAt: Date?
        /// Object that identifies the Amazon GameLift Streams application to stream with this stream group.
        public let defaultApplication: DefaultApplication?
        /// A descriptive label for the stream group.
        public let description: String?
        /// An  Amazon Resource Name (ARN) or ID that uniquely identifies the stream group resource. Format example: ARN-arn:aws:gameliftstreams:us-west-2:123456789012:streamgroup/1AB2C3De4 or ID-1AB2C3De4.
        public let id: String?
        /// A timestamp that indicates when this resource  was last updated. Timestamps are expressed using in ISO8601 format, such as: 2022-12-27T22:29:40+00:00 (UTC).
        public let lastUpdatedAt: Date?
        /// The current status of the stream group resource. Possible statuses include the following:    ACTIVATING: The stream group is deploying and isn't ready to host streams.      ACTIVE: The stream group is ready to host streams.     ACTIVE_WITH_ERRORS: One or more locations in the stream group are in an error state. Verify the details of individual locations and remove any locations which are in error.     ERROR: An error occurred when the stream group deployed. See StatusReason for more information.     DELETING: Amazon GameLift Streams is in the process of deleting the stream group.     UPDATING_LOCATIONS: One or more locations in the stream group are in the process of updating (either activating or deleting).
        public let status: StreamGroupStatus?
        /// The target stream quality for the stream group.  A stream class can be one of the following:     gen5n_win2022 (NVIDIA, ultra) Supports applications with extremely high 3D scene complexity. Runs applications on Microsoft Windows Server 2022 Base and supports DirectX 12. Compatible with most Unreal Engine 5.x builds, 32-bit applications, and anti-cheat technology. Uses NVIDIA A10G Tensor GPU.   Reference resolution: 1080p   Reference frame rate: 60 fps   Workload specifications: 8 vCPUs, 32 GB RAM, 24 GB VRAM   Tenancy: Supports 1 concurrent stream session       gen5n_high (NVIDIA, high) Supports applications with moderate to high 3D scene complexity. Uses NVIDIA A10G Tensor GPU.   Reference resolution: 1080p   Reference frame rate: 60 fps   Workload specifications: 4 vCPUs, 16 GB RAM, 12 GB VRAM   Tenancy: Supports up to 2 concurrent stream sessions       gen5n_ultra (NVIDIA, ultra) Supports applications with extremely high 3D scene complexity. Uses dedicated NVIDIA A10G Tensor GPU.   Reference resolution: 1080p   Reference frame rate: 60 fps   Workload specifications: 8 vCPUs, 32 GB RAM, 24 GB VRAM   Tenancy: Supports 1 concurrent stream session       gen4n_win2022 (NVIDIA, ultra) Supports applications with extremely high 3D scene complexity. Runs applications on Microsoft Windows Server 2022 Base and supports DirectX 12. Compatible with most Unreal Engine 5.2 and 5.3 builds, 32-bit applications, and anti-cheat technology. Uses NVIDIA T4 Tensor GPU.   Reference resolution: 1080p   Reference frame rate: 60 fps   Workload specifications: 8 vCPUs, 32 GB RAM, 16 GB VRAM   Tenancy: Supports 1 concurrent stream session       gen4n_high (NVIDIA, high) Supports applications with moderate to high 3D scene complexity. Uses NVIDIA T4 Tensor GPU.   Reference resolution: 1080p   Reference frame rate: 60 fps   Workload specifications: 4 vCPUs, 16 GB RAM, 8 GB VRAM   Tenancy: Supports up to 2 concurrent stream sessions       gen4n_ultra (NVIDIA, ultra) Supports applications with high 3D scene complexity. Uses dedicated NVIDIA T4 Tensor GPU.   Reference resolution: 1080p   Reference frame rate: 60 fps   Workload specifications: 8 vCPUs, 32 GB RAM, 16 GB VRAM   Tenancy: Supports 1 concurrent stream session
        public let streamClass: StreamClass?

        @inlinable
        public init(arn: String, createdAt: Date? = nil, defaultApplication: DefaultApplication? = nil, description: String? = nil, id: String? = nil, lastUpdatedAt: Date? = nil, status: StreamGroupStatus? = nil, streamClass: StreamClass? = nil) {
            self.arn = arn
            self.createdAt = createdAt
            self.defaultApplication = defaultApplication
            self.description = description
            self.id = id
            self.lastUpdatedAt = lastUpdatedAt
            self.status = status
            self.streamClass = streamClass
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case createdAt = "CreatedAt"
            case defaultApplication = "DefaultApplication"
            case description = "Description"
            case id = "Id"
            case lastUpdatedAt = "LastUpdatedAt"
            case status = "Status"
            case streamClass = "StreamClass"
        }
    }

    public struct StreamSessionSummary: AWSDecodableShape {
        /// An  Amazon Resource Name (ARN) or ID that uniquely identifies the application resource. Format example: ARN-arn:aws:gameliftstreams:us-west-2:123456789012:application/9ZY8X7Wv6 or ID-9ZY8X7Wv6.
        public let applicationArn: String?
        /// An  Amazon Resource Name (ARN) that uniquely identifies the stream session resource. Format example: 1AB2C3De4.
        /// .
        public let arn: String?
        /// A timestamp that indicates when this resource was created. Timestamps are expressed using in ISO8601 format, such as: 2022-12-27T22:29:40+00:00 (UTC).
        public let createdAt: Date?
        /// Provides
        /// 	details about the stream session's exported files.
        public let exportFilesMetadata: ExportFilesMetadata?
        /// A timestamp that indicates when this resource  was last updated. Timestamps are expressed using in ISO8601 format, such as: 2022-12-27T22:29:40+00:00 (UTC).
        public let lastUpdatedAt: Date?
        /// The location where Amazon GameLift Streams is hosting the stream session.
        /// 	A location's name. For example, us-east-1. For a complete list of locations that Amazon GameLift Streams supports, see
        /// 	the Regions and quotas section in the Amazon GameLift Streams Developer Guide
        /// .
        public let location: String?
        /// The data transfer protocol in use with the stream session.
        public let `protocol`: `Protocol`?
        /// The current status of the stream session resource. Possible statuses include the following:     ACTIVATING: The stream session is starting and preparing to stream.    ACTIVE: The stream session is ready to accept client connections.    CONNECTED: The stream session has a connected client.    PENDING_CLIENT_RECONNECTION: A client has recently disconnected, and the stream session is waiting for the client to reconnect. After a short time, if the client doesn't reconnect, the stream session status transitions to TERMINATED.    TERMINATING: The stream session is ending.    TERMINATED: The stream session has ended.    ERROR: The stream session failed to activate.
        public let status: StreamSessionStatus?
        ///  An opaque, unique identifier for an end-user, defined by the developer.
        public let userId: String?

        @inlinable
        public init(applicationArn: String? = nil, arn: String? = nil, createdAt: Date? = nil, exportFilesMetadata: ExportFilesMetadata? = nil, lastUpdatedAt: Date? = nil, location: String? = nil, protocol: `Protocol`? = nil, status: StreamSessionStatus? = nil, userId: String? = nil) {
            self.applicationArn = applicationArn
            self.arn = arn
            self.createdAt = createdAt
            self.exportFilesMetadata = exportFilesMetadata
            self.lastUpdatedAt = lastUpdatedAt
            self.location = location
            self.`protocol` = `protocol`
            self.status = status
            self.userId = userId
        }

        private enum CodingKeys: String, CodingKey {
            case applicationArn = "ApplicationArn"
            case arn = "Arn"
            case createdAt = "CreatedAt"
            case exportFilesMetadata = "ExportFilesMetadata"
            case lastUpdatedAt = "LastUpdatedAt"
            case location = "Location"
            case `protocol` = "Protocol"
            case status = "Status"
            case userId = "UserId"
        }
    }

    public struct TagResourceRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the Amazon GameLift Streams resource that you want to apply tags to.
        public let resourceArn: String
        /// A list of tags, in the form of key-value pairs, to assign to the specified Amazon GameLift Streams resource.
        public let tags: [String: String]

        @inlinable
        public init(resourceArn: String, tags: [String: String]) {
            self.resourceArn = resourceArn
            self.tags = tags
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.resourceArn, key: "ResourceArn")
            try container.encode(self.tags, forKey: .tags)
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, max: 128)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, min: 1)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, pattern: "^arn:aws:gameliftstreams:([^:\n]*):([0-9]{12}):([^:\n]*)$")
            try self.tags.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 50)
            try self.validate(self.tags, name: "tags", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case tags = "Tags"
        }
    }

    public struct TagResourceResponse: AWSDecodableShape {
        public init() {}
    }

    public struct TerminateStreamSessionInput: AWSEncodableShape {
        ///  Amazon Resource Name (ARN) or ID that uniquely identifies the stream group resource. Format example: ARN-arn:aws:gameliftstreams:us-west-2:123456789012:streamgroup/1AB2C3De4 or ID-1AB2C3De4.
        ///  The stream group that runs this stream session.
        public let identifier: String
        ///  Amazon Resource Name (ARN) that uniquely identifies the stream session resource. Format example: 1AB2C3De4.
        public let streamSessionIdentifier: String

        @inlinable
        public init(identifier: String, streamSessionIdentifier: String) {
            self.identifier = identifier
            self.streamSessionIdentifier = streamSessionIdentifier
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.identifier, key: "Identifier")
            request.encodePath(self.streamSessionIdentifier, key: "StreamSessionIdentifier")
        }

        public func validate(name: String) throws {
            try self.validate(self.identifier, name: "identifier", parent: name, max: 128)
            try self.validate(self.identifier, name: "identifier", parent: name, min: 1)
            try self.validate(self.identifier, name: "identifier", parent: name, pattern: "^(^[a-zA-Z0-9-]+$)|(^arn:aws:gameliftstreams:([^:\n]*):([0-9]{12}):([^:\n]*)$)$")
            try self.validate(self.streamSessionIdentifier, name: "streamSessionIdentifier", parent: name, max: 128)
            try self.validate(self.streamSessionIdentifier, name: "streamSessionIdentifier", parent: name, min: 1)
            try self.validate(self.streamSessionIdentifier, name: "streamSessionIdentifier", parent: name, pattern: "^(^[a-zA-Z0-9-]+$)|(^arn:aws:gameliftstreams:([^:\n]*):([0-9]{12}):([^:\n]*)$)$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct UntagResourceRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the Amazon GameLift Streams resource that you want to remove tags from.
        public let resourceArn: String
        /// A list of tag keys to remove from the specified Amazon GameLift Streams resource.
        public let tagKeys: [String]

        @inlinable
        public init(resourceArn: String, tagKeys: [String]) {
            self.resourceArn = resourceArn
            self.tagKeys = tagKeys
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.resourceArn, key: "ResourceArn")
            request.encodeQuery(self.tagKeys, key: "tagKeys")
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, max: 128)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, min: 1)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, pattern: "^arn:aws:gameliftstreams:([^:\n]*):([0-9]{12}):([^:\n]*)$")
            try self.tagKeys.forEach {
                try validate($0, name: "tagKeys[]", parent: name, max: 128)
                try validate($0, name: "tagKeys[]", parent: name, min: 1)
            }
            try self.validate(self.tagKeys, name: "tagKeys", parent: name, max: 50)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct UntagResourceResponse: AWSDecodableShape {
        public init() {}
    }

    public struct UpdateApplicationInput: AWSEncodableShape {
        /// An Amazon S3 URI to a bucket where you would like Amazon GameLift Streams to save application logs. Use the following format for the URI: s3://[bucket name]/[prefix].  Required if you specify one or more LogPaths.  The log bucket must have permissions that give Amazon GameLift Streams access to write the log files. For more information, see Getting Started in the Amazon GameLift Streams Developer Guide.
        public let applicationLogOutputUri: String?
        /// Locations of log files that your content generates during a stream session. Enter path values that are relative to the ApplicationSourceUri location. You can specify up to 10 log locations. Amazon GameLift Streams uploads designated log files to the Amazon S3 bucket that you specify in ApplicationLogOutputUri  at the end of a stream session. To retrieve stored log files, call GetStreamSession  and get the LogFileLocationUri.
        public let applicationLogPaths: [String]?
        /// A human-readable label for the application.
        public let description: String?
        /// An  Amazon Resource Name (ARN) or ID that uniquely identifies the application resource. Format example: ARN-arn:aws:gameliftstreams:us-west-2:123456789012:application/9ZY8X7Wv6 or ID-9ZY8X7Wv6.
        public let identifier: String

        @inlinable
        public init(applicationLogOutputUri: String? = nil, applicationLogPaths: [String]? = nil, description: String? = nil, identifier: String) {
            self.applicationLogOutputUri = applicationLogOutputUri
            self.applicationLogPaths = applicationLogPaths
            self.description = description
            self.identifier = identifier
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.applicationLogOutputUri, forKey: .applicationLogOutputUri)
            try container.encodeIfPresent(self.applicationLogPaths, forKey: .applicationLogPaths)
            try container.encodeIfPresent(self.description, forKey: .description)
            request.encodePath(self.identifier, key: "Identifier")
        }

        public func validate(name: String) throws {
            try self.validate(self.applicationLogOutputUri, name: "applicationLogOutputUri", parent: name, max: 1024)
            try self.validate(self.applicationLogOutputUri, name: "applicationLogOutputUri", parent: name, pattern: "^$|^s3://([a-zA-Z0-9][a-zA-Z0-9._-]{1,61}[a-zA-Z0-9])(/[a-zA-Z0-9._-]+)*/?$")
            try self.applicationLogPaths?.forEach {
                try validate($0, name: "applicationLogPaths[]", parent: name, max: 1024)
            }
            try self.validate(self.applicationLogPaths, name: "applicationLogPaths", parent: name, max: 10)
            try self.validate(self.description, name: "description", parent: name, max: 80)
            try self.validate(self.description, name: "description", parent: name, min: 1)
            try self.validate(self.description, name: "description", parent: name, pattern: "^[a-zA-Z0-9-_.!+@/][a-zA-Z0-9-_.!+@/ ]*$")
            try self.validate(self.identifier, name: "identifier", parent: name, max: 128)
            try self.validate(self.identifier, name: "identifier", parent: name, min: 1)
            try self.validate(self.identifier, name: "identifier", parent: name, pattern: "^(^[a-zA-Z0-9-]+$)|(^arn:aws:gameliftstreams:([^:\n]*):([0-9]{12}):([^:\n]*)$)$")
        }

        private enum CodingKeys: String, CodingKey {
            case applicationLogOutputUri = "ApplicationLogOutputUri"
            case applicationLogPaths = "ApplicationLogPaths"
            case description = "Description"
        }
    }

    public struct UpdateApplicationOutput: AWSDecodableShape {
        /// An Amazon S3 URI to a bucket where you would like Amazon GameLift Streams to save application logs. Use the following format for the URI: s3://[bucket name]/[prefix].  Required if you specify one or more LogPaths.
        public let applicationLogOutputUri: String?
        /// Locations of log files that your content generates during a stream session.  Amazon GameLift Streams uploads log files to the Amazon S3 bucket that you specify in ApplicationLogOutputUri  at the end of a stream session. To retrieve stored log files, call GetStreamSession  and get the LogFileLocationUri.
        public let applicationLogPaths: [String]?
        /// The original Amazon S3 location of uploaded stream content for the application.
        public let applicationSourceUri: String?
        /// An Amazon Resource Name (ARN) that's assigned to an application resource and uniquely identifies it across all Amazon Web Services Regions. Format is arn:aws:gameliftstreams:[AWS Region]:[AWS account]:application/[resource ID].
        public let arn: String
        ///  A set of stream groups that this application is associated with. You can use any of these stream groups to stream your application.  This value is a  set of Amazon Resource Names (ARNs) that uniquely identify stream group resources. Format example: arn:aws:gameliftstreams:us-west-2:123456789012:streamgroup/1AB2C3De4.
        public let associatedStreamGroups: [String]?
        /// A timestamp that indicates when this resource was created. Timestamps are expressed using in ISO8601 format, such as: 2022-12-27T22:29:40+00:00 (UTC).
        public let createdAt: Date?
        /// A human-readable label for the application. You can edit this value.
        public let description: String?
        /// The path and file name of the executable file that launches the content for streaming.
        public let executablePath: String?
        /// An  Amazon Resource Name (ARN) or ID that uniquely identifies the application resource. Format example: ARN-arn:aws:gameliftstreams:us-west-2:123456789012:application/9ZY8X7Wv6 or ID-9ZY8X7Wv6.
        public let id: String?
        /// A timestamp that indicates when this resource  was last updated. Timestamps are expressed using in ISO8601 format, such as: 2022-12-27T22:29:40+00:00 (UTC).
        public let lastUpdatedAt: Date?
        /// A set of replication statuses for each location.
        public let replicationStatuses: [ReplicationStatus]?
        ///  A set of configuration settings to run the application on a stream group. This configures the operating system, and can include compatibility layers and other drivers.  A runtime environment can be one of the following:    For Linux applications     Ubuntu 22.04 LTS(Type=UBUNTU, Version=22_04_LTS)       For Windows applications    Microsoft Windows Server 2022 Base (Type=WINDOWS, Version=2022)   Proton 8.0-5 (Type=PROTON, Version=20241007)   Proton 8.0-2c (Type=PROTON, Version=20230704)
        public let runtimeEnvironment: RuntimeEnvironment?
        /// The current status of the application resource. Possible statuses include the following:    INITIALIZED: Amazon GameLift Streams has received the request and is initiating the work flow to create an application.     PROCESSING: The create application work flow is in process. Amazon GameLift Streams is copying the content and caching for future deployment in a stream group.    READY: The application is ready to deploy in a stream group.    ERROR: An error occurred when setting up the application. See StatusReason for more information.    DELETING: Amazon GameLift Streams is in the process of deleting the application.
        public let status: ApplicationStatus?
        /// A short description of the status reason when the application is in ERROR status.
        public let statusReason: ApplicationStatusReason?

        @inlinable
        public init(applicationLogOutputUri: String? = nil, applicationLogPaths: [String]? = nil, applicationSourceUri: String? = nil, arn: String, associatedStreamGroups: [String]? = nil, createdAt: Date? = nil, description: String? = nil, executablePath: String? = nil, id: String? = nil, lastUpdatedAt: Date? = nil, replicationStatuses: [ReplicationStatus]? = nil, runtimeEnvironment: RuntimeEnvironment? = nil, status: ApplicationStatus? = nil, statusReason: ApplicationStatusReason? = nil) {
            self.applicationLogOutputUri = applicationLogOutputUri
            self.applicationLogPaths = applicationLogPaths
            self.applicationSourceUri = applicationSourceUri
            self.arn = arn
            self.associatedStreamGroups = associatedStreamGroups
            self.createdAt = createdAt
            self.description = description
            self.executablePath = executablePath
            self.id = id
            self.lastUpdatedAt = lastUpdatedAt
            self.replicationStatuses = replicationStatuses
            self.runtimeEnvironment = runtimeEnvironment
            self.status = status
            self.statusReason = statusReason
        }

        private enum CodingKeys: String, CodingKey {
            case applicationLogOutputUri = "ApplicationLogOutputUri"
            case applicationLogPaths = "ApplicationLogPaths"
            case applicationSourceUri = "ApplicationSourceUri"
            case arn = "Arn"
            case associatedStreamGroups = "AssociatedStreamGroups"
            case createdAt = "CreatedAt"
            case description = "Description"
            case executablePath = "ExecutablePath"
            case id = "Id"
            case lastUpdatedAt = "LastUpdatedAt"
            case replicationStatuses = "ReplicationStatuses"
            case runtimeEnvironment = "RuntimeEnvironment"
            case status = "Status"
            case statusReason = "StatusReason"
        }
    }

    public struct UpdateStreamGroupInput: AWSEncodableShape {
        /// A descriptive label for the stream group.
        public let description: String?
        /// An  Amazon Resource Name (ARN) or ID that uniquely identifies the stream group resource. Format example: ARN-arn:aws:gameliftstreams:us-west-2:123456789012:streamgroup/1AB2C3De4 or ID-1AB2C3De4.
        public let identifier: String
        ///  A set of one or more locations and the streaming capacity for each location.
        public let locationConfigurations: [LocationConfiguration]?

        @inlinable
        public init(description: String? = nil, identifier: String, locationConfigurations: [LocationConfiguration]? = nil) {
            self.description = description
            self.identifier = identifier
            self.locationConfigurations = locationConfigurations
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.description, forKey: .description)
            request.encodePath(self.identifier, key: "Identifier")
            try container.encodeIfPresent(self.locationConfigurations, forKey: .locationConfigurations)
        }

        public func validate(name: String) throws {
            try self.validate(self.description, name: "description", parent: name, max: 80)
            try self.validate(self.description, name: "description", parent: name, min: 1)
            try self.validate(self.description, name: "description", parent: name, pattern: "^[a-zA-Z0-9-_.!+@/][a-zA-Z0-9-_.!+@/ ]*$")
            try self.validate(self.identifier, name: "identifier", parent: name, max: 128)
            try self.validate(self.identifier, name: "identifier", parent: name, min: 1)
            try self.validate(self.identifier, name: "identifier", parent: name, pattern: "^(^[a-zA-Z0-9-]+$)|(^arn:aws:gameliftstreams:([^:\n]*):([0-9]{12}):([^:\n]*)$)$")
            try self.locationConfigurations?.forEach {
                try $0.validate(name: "\(name).locationConfigurations[]")
            }
            try self.validate(self.locationConfigurations, name: "locationConfigurations", parent: name, max: 100)
            try self.validate(self.locationConfigurations, name: "locationConfigurations", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case description = "Description"
            case locationConfigurations = "LocationConfigurations"
        }
    }

    public struct UpdateStreamGroupOutput: AWSDecodableShape {
        /// An Amazon Resource Name (ARN) that is assigned to the stream group resource and that uniquely identifies the group across all Amazon Web Services Regions. Format is arn:aws:gameliftstreams:[AWS Region]:[AWS account]:streamgroup/[resource ID].
        public let arn: String
        ///  A set of applications that this stream group is associated with. You can stream any of these applications with the stream group.  This value is a  set of Amazon Resource Names (ARNs) that uniquely identify application resources. Format example: arn:aws:gameliftstreams:us-west-2:123456789012:application/9ZY8X7Wv6.
        public let associatedApplications: [String]?
        /// A timestamp that indicates when this resource was created. Timestamps are expressed using in ISO8601 format, such as: 2022-12-27T22:29:40+00:00 (UTC).
        public let createdAt: Date?
        /// The Amazon GameLift Streams application that is associated with this stream group.
        public let defaultApplication: DefaultApplication?
        /// A descriptive label for the stream group.
        public let description: String?
        /// A unique ID value that is assigned to the resource when it's created. Format example: 1AB2C3De4.
        public let id: String?
        /// A timestamp that indicates when this resource  was last updated. Timestamps are expressed using in ISO8601 format, such as: 2022-12-27T22:29:40+00:00 (UTC).
        public let lastUpdatedAt: Date?
        /// This value is
        /// 	set of locations, including their name, current status, and capacities.
        ///
        /// 	A location can be in one of the following states:
        ///     ACTIVATING: Amazon GameLift Streams is preparing the location. You cannot stream from, scale the capacity of, or remove this location yet.
        /// 		    ACTIVE: The location is provisioned with initial capacity. You can now stream from, scale the capacity of, or remove this location.
        /// 		    ERROR: Amazon GameLift Streams failed to set up this location. The StatusReason field describes the error. You can remove this location and try to add it again.
        /// 		    REMOVING: Amazon GameLift Streams is working to remove this location. It releases all provisioned capacity for this location in this stream group.
        ///
        public let locationStates: [LocationState]?
        /// The current status of the stream group resource. Possible statuses include the following:    ACTIVATING: The stream group is deploying and isn't ready to host streams.      ACTIVE: The stream group is ready to host streams.     ACTIVE_WITH_ERRORS: One or more locations in the stream group are in an error state. Verify the details of individual locations and remove any locations which are in error.     ERROR: An error occurred when the stream group deployed. See StatusReason for more information.     DELETING: Amazon GameLift Streams is in the process of deleting the stream group.     UPDATING_LOCATIONS: One or more locations in the stream group are in the process of updating (either activating or deleting).
        public let status: StreamGroupStatus?
        ///  A short description of the reason that the stream group is in ERROR status. The possible reasons can be one of the following:     internalError: The request can't process right now bcause of an issue with the server. Try again later. Reach out to the Amazon GameLift Streams team for more help.     noAvailableInstances: Amazon GameLift Streams does not currently have enough available On-Demand capacity to fulfill your request. Wait a few minutes and retry the request as capacity can shift frequently. You can also try to make the request using a different stream class or in another region.
        public let statusReason: StreamGroupStatusReason?
        /// The target stream quality for the stream group. A stream class can be one of the following:     gen5n_win2022 (NVIDIA, ultra) Supports applications with extremely high 3D scene complexity. Runs applications on Microsoft Windows Server 2022 Base and supports DirectX 12. Compatible with most Unreal Engine 5.x builds, 32-bit applications, and anti-cheat technology. Uses NVIDIA A10G Tensor GPU.   Reference resolution: 1080p   Reference frame rate: 60 fps   Workload specifications: 8 vCPUs, 32 GB RAM, 24 GB VRAM   Tenancy: Supports 1 concurrent stream session       gen5n_high (NVIDIA, high) Supports applications with moderate to high 3D scene complexity. Uses NVIDIA A10G Tensor GPU.   Reference resolution: 1080p   Reference frame rate: 60 fps   Workload specifications: 4 vCPUs, 16 GB RAM, 12 GB VRAM   Tenancy: Supports up to 2 concurrent stream sessions       gen5n_ultra (NVIDIA, ultra) Supports applications with extremely high 3D scene complexity. Uses dedicated NVIDIA A10G Tensor GPU.   Reference resolution: 1080p   Reference frame rate: 60 fps   Workload specifications: 8 vCPUs, 32 GB RAM, 24 GB VRAM   Tenancy: Supports 1 concurrent stream session       gen4n_win2022 (NVIDIA, ultra) Supports applications with extremely high 3D scene complexity. Runs applications on Microsoft Windows Server 2022 Base and supports DirectX 12. Compatible with most Unreal Engine 5.2 and 5.3 builds, 32-bit applications, and anti-cheat technology. Uses NVIDIA T4 Tensor GPU.   Reference resolution: 1080p   Reference frame rate: 60 fps   Workload specifications: 8 vCPUs, 32 GB RAM, 16 GB VRAM   Tenancy: Supports 1 concurrent stream session       gen4n_high (NVIDIA, high) Supports applications with moderate to high 3D scene complexity. Uses NVIDIA T4 Tensor GPU.   Reference resolution: 1080p   Reference frame rate: 60 fps   Workload specifications: 4 vCPUs, 16 GB RAM, 8 GB VRAM   Tenancy: Supports up to 2 concurrent stream sessions       gen4n_ultra (NVIDIA, ultra) Supports applications with high 3D scene complexity. Uses dedicated NVIDIA T4 Tensor GPU.   Reference resolution: 1080p   Reference frame rate: 60 fps   Workload specifications: 8 vCPUs, 32 GB RAM, 16 GB VRAM   Tenancy: Supports 1 concurrent stream session
        public let streamClass: StreamClass?

        @inlinable
        public init(arn: String, associatedApplications: [String]? = nil, createdAt: Date? = nil, defaultApplication: DefaultApplication? = nil, description: String? = nil, id: String? = nil, lastUpdatedAt: Date? = nil, locationStates: [LocationState]? = nil, status: StreamGroupStatus? = nil, statusReason: StreamGroupStatusReason? = nil, streamClass: StreamClass? = nil) {
            self.arn = arn
            self.associatedApplications = associatedApplications
            self.createdAt = createdAt
            self.defaultApplication = defaultApplication
            self.description = description
            self.id = id
            self.lastUpdatedAt = lastUpdatedAt
            self.locationStates = locationStates
            self.status = status
            self.statusReason = statusReason
            self.streamClass = streamClass
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case associatedApplications = "AssociatedApplications"
            case createdAt = "CreatedAt"
            case defaultApplication = "DefaultApplication"
            case description = "Description"
            case id = "Id"
            case lastUpdatedAt = "LastUpdatedAt"
            case locationStates = "LocationStates"
            case status = "Status"
            case statusReason = "StatusReason"
            case streamClass = "StreamClass"
        }
    }
}

// MARK: - Errors

/// Error enum for GameLiftStreams
public struct GameLiftStreamsErrorType: AWSErrorType {
    enum Code: String {
        case accessDeniedException = "AccessDeniedException"
        case conflictException = "ConflictException"
        case internalServerException = "InternalServerException"
        case resourceNotFoundException = "ResourceNotFoundException"
        case serviceQuotaExceededException = "ServiceQuotaExceededException"
        case throttlingException = "ThrottlingException"
        case validationException = "ValidationException"
    }

    private let error: Code
    public let context: AWSErrorContext?

    /// initialize GameLiftStreams
    public init?(errorCode: String, context: AWSErrorContext) {
        guard let error = Code(rawValue: errorCode) else { return nil }
        self.error = error
        self.context = context
    }

    internal init(_ error: Code) {
        self.error = error
        self.context = nil
    }

    /// return error code string
    public var errorCode: String { self.error.rawValue }

    /// You don't have the required permissions to access this Amazon GameLift Streams resource. Correct the permissions before you try again.
    public static var accessDeniedException: Self { .init(.accessDeniedException) }
    /// The requested operation would cause a conflict with the current state of a service resource associated with the request. Resolve the conflict before retrying this request.
    public static var conflictException: Self { .init(.conflictException) }
    /// The service encountered an internal error and is unable to complete the request.
    public static var internalServerException: Self { .init(.internalServerException) }
    /// The resource specified in the request was not found. Correct the request before you try again.
    public static var resourceNotFoundException: Self { .init(.resourceNotFoundException) }
    /// The request would cause the resource to exceed an allowed service quota. Resolve the issue before you try again.
    public static var serviceQuotaExceededException: Self { .init(.serviceQuotaExceededException) }
    /// The request was denied due to request throttling. Retry the request after the suggested wait time.
    public static var throttlingException: Self { .init(.throttlingException) }
    /// One or more parameter values in the request fail to satisfy the specified constraints.  Correct the invalid parameter values before retrying the request.
    public static var validationException: Self { .init(.validationException) }
}

extension GameLiftStreamsErrorType: Equatable {
    public static func == (lhs: GameLiftStreamsErrorType, rhs: GameLiftStreamsErrorType) -> Bool {
        lhs.error == rhs.error
    }
}

extension GameLiftStreamsErrorType: CustomStringConvertible {
    public var description: String {
        return "\(self.error.rawValue): \(self.message ?? "")"
    }
}
