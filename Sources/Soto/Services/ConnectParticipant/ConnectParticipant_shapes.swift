//===----------------------------------------------------------------------===//
//
// This source file is part of the Soto for AWS open source project
//
// Copyright (c) 2017-2024 the Soto project authors
// Licensed under Apache License v2.0
//
// See LICENSE.txt for license information
// See CONTRIBUTORS.txt for the list of Soto project authors
//
// SPDX-License-Identifier: Apache-2.0
//
//===----------------------------------------------------------------------===//

// THIS FILE IS AUTOMATICALLY GENERATED by https://github.com/soto-project/soto-codegenerator.
// DO NOT EDIT.

#if canImport(FoundationEssentials)
import FoundationEssentials
#else
import Foundation
#endif
@_spi(SotoInternal) import SotoCore

extension ConnectParticipant {
    // MARK: Enums

    public enum ArtifactStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case approved = "APPROVED"
        case inProgress = "IN_PROGRESS"
        case rejected = "REJECTED"
        public var description: String { return self.rawValue }
    }

    public enum ChatItemType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case attachment = "ATTACHMENT"
        case chatEnded = "CHAT_ENDED"
        case connectionAck = "CONNECTION_ACK"
        case event = "EVENT"
        case message = "MESSAGE"
        case messageDelivered = "MESSAGE_DELIVERED"
        case messageRead = "MESSAGE_READ"
        case participantJoined = "PARTICIPANT_JOINED"
        case participantLeft = "PARTICIPANT_LEFT"
        case transferFailed = "TRANSFER_FAILED"
        case transferSucceeded = "TRANSFER_SUCCEEDED"
        case typing = "TYPING"
        public var description: String { return self.rawValue }
    }

    public enum ConnectionType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case connectionCredentials = "CONNECTION_CREDENTIALS"
        case websocket = "WEBSOCKET"
        public var description: String { return self.rawValue }
    }

    public enum ParticipantRole: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case agent = "AGENT"
        case customBot = "CUSTOM_BOT"
        case customer = "CUSTOMER"
        case supervisor = "SUPERVISOR"
        case system = "SYSTEM"
        public var description: String { return self.rawValue }
    }

    public enum ResourceType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case contact = "CONTACT"
        case contactFlow = "CONTACT_FLOW"
        case hierarchyGroup = "HIERARCHY_GROUP"
        case hierarchyLevel = "HIERARCHY_LEVEL"
        case instance = "INSTANCE"
        case participant = "PARTICIPANT"
        case phoneNumber = "PHONE_NUMBER"
        case user = "USER"
        public var description: String { return self.rawValue }
    }

    public enum ScanDirection: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case backward = "BACKWARD"
        case forward = "FORWARD"
        public var description: String { return self.rawValue }
    }

    public enum SortKey: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case ascending = "ASCENDING"
        case descending = "DESCENDING"
        public var description: String { return self.rawValue }
    }

    // MARK: Shapes

    public struct AttachmentItem: AWSDecodableShape {
        /// A unique identifier for the attachment.
        public let attachmentId: String?
        /// A case-sensitive name of the attachment being uploaded.
        public let attachmentName: String?
        /// Describes the MIME file type of the attachment. For a list of supported file types, see Feature specifications in the Amazon Connect Administrator Guide.
        public let contentType: String?
        /// Status of the attachment.
        public let status: ArtifactStatus?

        @inlinable
        public init(attachmentId: String? = nil, attachmentName: String? = nil, contentType: String? = nil, status: ArtifactStatus? = nil) {
            self.attachmentId = attachmentId
            self.attachmentName = attachmentName
            self.contentType = contentType
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case attachmentId = "AttachmentId"
            case attachmentName = "AttachmentName"
            case contentType = "ContentType"
            case status = "Status"
        }
    }

    public struct CancelParticipantAuthenticationRequest: AWSEncodableShape {
        /// The authentication token associated with the participant's connection.
        public let connectionToken: String
        /// The sessionId provided in the authenticationInitiated event.
        public let sessionId: String

        @inlinable
        public init(connectionToken: String, sessionId: String) {
            self.connectionToken = connectionToken
            self.sessionId = sessionId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodeHeader(self.connectionToken, key: "X-Amz-Bearer")
            try container.encode(self.sessionId, forKey: .sessionId)
        }

        public func validate(name: String) throws {
            try self.validate(self.connectionToken, name: "connectionToken", parent: name, max: 1000)
            try self.validate(self.connectionToken, name: "connectionToken", parent: name, min: 1)
            try self.validate(self.sessionId, name: "sessionId", parent: name, max: 36)
            try self.validate(self.sessionId, name: "sessionId", parent: name, min: 36)
        }

        private enum CodingKeys: String, CodingKey {
            case sessionId = "SessionId"
        }
    }

    public struct CancelParticipantAuthenticationResponse: AWSDecodableShape {
        public init() {}
    }

    public struct CompleteAttachmentUploadRequest: AWSEncodableShape {
        /// A list of unique identifiers for the attachments.
        public let attachmentIds: [String]
        /// A unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If not provided, the Amazon Web Services SDK populates this field. For more information about idempotency, see Making retries safe with idempotent APIs.
        public let clientToken: String
        /// The authentication token associated with the participant's connection.
        public let connectionToken: String

        @inlinable
        public init(attachmentIds: [String], clientToken: String = CompleteAttachmentUploadRequest.idempotencyToken(), connectionToken: String) {
            self.attachmentIds = attachmentIds
            self.clientToken = clientToken
            self.connectionToken = connectionToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encode(self.attachmentIds, forKey: .attachmentIds)
            try container.encode(self.clientToken, forKey: .clientToken)
            request.encodeHeader(self.connectionToken, key: "X-Amz-Bearer")
        }

        public func validate(name: String) throws {
            try self.attachmentIds.forEach {
                try validate($0, name: "attachmentIds[]", parent: name, max: 256)
                try validate($0, name: "attachmentIds[]", parent: name, min: 1)
            }
            try self.validate(self.attachmentIds, name: "attachmentIds", parent: name, max: 1)
            try self.validate(self.attachmentIds, name: "attachmentIds", parent: name, min: 1)
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 500)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.validate(self.connectionToken, name: "connectionToken", parent: name, max: 1000)
            try self.validate(self.connectionToken, name: "connectionToken", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case attachmentIds = "AttachmentIds"
            case clientToken = "ClientToken"
        }
    }

    public struct CompleteAttachmentUploadResponse: AWSDecodableShape {
        public init() {}
    }

    public struct ConnectionCredentials: AWSDecodableShape {
        /// The connection token.
        public let connectionToken: String?
        /// The expiration of the token. It's specified in ISO 8601 format: yyyy-MM-ddThh:mm:ss.SSSZ. For example, 2019-11-08T02:41:28.172Z.
        public let expiry: String?

        @inlinable
        public init(connectionToken: String? = nil, expiry: String? = nil) {
            self.connectionToken = connectionToken
            self.expiry = expiry
        }

        private enum CodingKeys: String, CodingKey {
            case connectionToken = "ConnectionToken"
            case expiry = "Expiry"
        }
    }

    public struct CreateParticipantConnectionRequest: AWSEncodableShape {
        /// Amazon Connect Participant is used to mark the participant as connected for customer participant in message streaming, as well as for agent or manager participant in non-streaming chats.
        public let connectParticipant: Bool?
        /// This is a header parameter. The ParticipantToken as obtained from StartChatContact API response.
        public let participantToken: String
        /// Type of connection information required. If you need CONNECTION_CREDENTIALS along with marking participant as connected, pass CONNECTION_CREDENTIALS in Type.
        public let type: [ConnectionType]?

        @inlinable
        public init(connectParticipant: Bool? = nil, participantToken: String, type: [ConnectionType]? = nil) {
            self.connectParticipant = connectParticipant
            self.participantToken = participantToken
            self.type = type
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.connectParticipant, forKey: .connectParticipant)
            request.encodeHeader(self.participantToken, key: "X-Amz-Bearer")
            try container.encodeIfPresent(self.type, forKey: .type)
        }

        public func validate(name: String) throws {
            try self.validate(self.participantToken, name: "participantToken", parent: name, max: 1000)
            try self.validate(self.participantToken, name: "participantToken", parent: name, min: 1)
            try self.validate(self.type, name: "type", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case connectParticipant = "ConnectParticipant"
            case type = "Type"
        }
    }

    public struct CreateParticipantConnectionResponse: AWSDecodableShape {
        /// Creates the participant's connection credentials. The authentication token associated with the participant's connection.
        public let connectionCredentials: ConnectionCredentials?
        /// Creates the participant's websocket connection.
        public let websocket: Websocket?

        @inlinable
        public init(connectionCredentials: ConnectionCredentials? = nil, websocket: Websocket? = nil) {
            self.connectionCredentials = connectionCredentials
            self.websocket = websocket
        }

        private enum CodingKeys: String, CodingKey {
            case connectionCredentials = "ConnectionCredentials"
            case websocket = "Websocket"
        }
    }

    public struct DescribeViewRequest: AWSEncodableShape {
        /// The connection token.
        public let connectionToken: String
        /// An encrypted token originating from the interactive message of a ShowView block operation. Represents the desired view.
        public let viewToken: String

        @inlinable
        public init(connectionToken: String, viewToken: String) {
            self.connectionToken = connectionToken
            self.viewToken = viewToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeHeader(self.connectionToken, key: "X-Amz-Bearer")
            request.encodePath(self.viewToken, key: "ViewToken")
        }

        public func validate(name: String) throws {
            try self.validate(self.connectionToken, name: "connectionToken", parent: name, max: 1000)
            try self.validate(self.connectionToken, name: "connectionToken", parent: name, min: 1)
            try self.validate(self.viewToken, name: "viewToken", parent: name, max: 1000)
            try self.validate(self.viewToken, name: "viewToken", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DescribeViewResponse: AWSDecodableShape {
        /// A view resource object. Contains metadata and content necessary to render the view.
        public let view: View?

        @inlinable
        public init(view: View? = nil) {
            self.view = view
        }

        private enum CodingKeys: String, CodingKey {
            case view = "View"
        }
    }

    public struct DisconnectParticipantRequest: AWSEncodableShape {
        /// A unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If not provided, the Amazon Web Services SDK populates this field. For more information about idempotency, see Making retries safe with idempotent APIs.
        public let clientToken: String?
        /// The authentication token associated with the participant's connection.
        public let connectionToken: String

        @inlinable
        public init(clientToken: String? = DisconnectParticipantRequest.idempotencyToken(), connectionToken: String) {
            self.clientToken = clientToken
            self.connectionToken = connectionToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.clientToken, forKey: .clientToken)
            request.encodeHeader(self.connectionToken, key: "X-Amz-Bearer")
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 500)
            try self.validate(self.connectionToken, name: "connectionToken", parent: name, max: 1000)
            try self.validate(self.connectionToken, name: "connectionToken", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "ClientToken"
        }
    }

    public struct DisconnectParticipantResponse: AWSDecodableShape {
        public init() {}
    }

    public struct GetAttachmentRequest: AWSEncodableShape {
        /// A unique identifier for the attachment.
        public let attachmentId: String
        /// The authentication token associated with the participant's connection.
        public let connectionToken: String
        /// The expiration time of the URL in ISO timestamp. It's specified in ISO 8601 format: yyyy-MM-ddThh:mm:ss.SSSZ. For example, 2019-11-08T02:41:28.172Z.
        public let urlExpiryInSeconds: Int?

        @inlinable
        public init(attachmentId: String, connectionToken: String, urlExpiryInSeconds: Int? = nil) {
            self.attachmentId = attachmentId
            self.connectionToken = connectionToken
            self.urlExpiryInSeconds = urlExpiryInSeconds
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encode(self.attachmentId, forKey: .attachmentId)
            request.encodeHeader(self.connectionToken, key: "X-Amz-Bearer")
            try container.encodeIfPresent(self.urlExpiryInSeconds, forKey: .urlExpiryInSeconds)
        }

        public func validate(name: String) throws {
            try self.validate(self.attachmentId, name: "attachmentId", parent: name, max: 256)
            try self.validate(self.attachmentId, name: "attachmentId", parent: name, min: 1)
            try self.validate(self.connectionToken, name: "connectionToken", parent: name, max: 1000)
            try self.validate(self.connectionToken, name: "connectionToken", parent: name, min: 1)
            try self.validate(self.urlExpiryInSeconds, name: "urlExpiryInSeconds", parent: name, max: 300)
            try self.validate(self.urlExpiryInSeconds, name: "urlExpiryInSeconds", parent: name, min: 5)
        }

        private enum CodingKeys: String, CodingKey {
            case attachmentId = "AttachmentId"
            case urlExpiryInSeconds = "UrlExpiryInSeconds"
        }
    }

    public struct GetAttachmentResponse: AWSDecodableShape {
        /// The size of the attachment in bytes.
        public let attachmentSizeInBytes: Int64
        /// This is the pre-signed URL that can be used for uploading the file to Amazon S3 when used in response
        /// to StartAttachmentUpload.
        public let url: String?
        /// The expiration time of the URL in ISO timestamp. It's specified in ISO 8601 format: yyyy-MM-ddThh:mm:ss.SSSZ. For example, 2019-11-08T02:41:28.172Z.
        public let urlExpiry: String?

        @inlinable
        public init(attachmentSizeInBytes: Int64, url: String? = nil, urlExpiry: String? = nil) {
            self.attachmentSizeInBytes = attachmentSizeInBytes
            self.url = url
            self.urlExpiry = urlExpiry
        }

        private enum CodingKeys: String, CodingKey {
            case attachmentSizeInBytes = "AttachmentSizeInBytes"
            case url = "Url"
            case urlExpiry = "UrlExpiry"
        }
    }

    public struct GetAuthenticationUrlRequest: AWSEncodableShape {
        /// The authentication token associated with the participant's connection.
        public let connectionToken: String
        /// The URL where the customer will be redirected after Amazon Cognito authorizes the user.
        public let redirectUri: String
        /// The sessionId provided in the authenticationInitiated event.
        public let sessionId: String

        @inlinable
        public init(connectionToken: String, redirectUri: String, sessionId: String) {
            self.connectionToken = connectionToken
            self.redirectUri = redirectUri
            self.sessionId = sessionId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodeHeader(self.connectionToken, key: "X-Amz-Bearer")
            try container.encode(self.redirectUri, forKey: .redirectUri)
            try container.encode(self.sessionId, forKey: .sessionId)
        }

        public func validate(name: String) throws {
            try self.validate(self.connectionToken, name: "connectionToken", parent: name, max: 1000)
            try self.validate(self.connectionToken, name: "connectionToken", parent: name, min: 1)
            try self.validate(self.redirectUri, name: "redirectUri", parent: name, max: 1024)
            try self.validate(self.redirectUri, name: "redirectUri", parent: name, min: 1)
            try self.validate(self.sessionId, name: "sessionId", parent: name, max: 36)
            try self.validate(self.sessionId, name: "sessionId", parent: name, min: 36)
        }

        private enum CodingKeys: String, CodingKey {
            case redirectUri = "RedirectUri"
            case sessionId = "SessionId"
        }
    }

    public struct GetAuthenticationUrlResponse: AWSDecodableShape {
        /// The URL where the customer will sign in to the identity provider. This URL contains the authorize endpoint for the Cognito UserPool used in the authentication.
        public let authenticationUrl: String?

        @inlinable
        public init(authenticationUrl: String? = nil) {
            self.authenticationUrl = authenticationUrl
        }

        private enum CodingKeys: String, CodingKey {
            case authenticationUrl = "AuthenticationUrl"
        }
    }

    public struct GetTranscriptRequest: AWSEncodableShape {
        /// The authentication token associated with the participant's connection.
        public let connectionToken: String
        /// The contactId from the current contact chain for which transcript is needed.
        public let contactId: String?
        /// The maximum number of results to return in the page. Default: 10.
        public let maxResults: Int?
        /// The pagination token. Use the value returned previously in the next subsequent request to retrieve the next set of results.
        public let nextToken: String?
        /// The direction from StartPosition from which to retrieve message. Default: BACKWARD when no StartPosition is provided, FORWARD with StartPosition.
        public let scanDirection: ScanDirection?
        /// The sort order for the records. Default: DESCENDING.
        public let sortOrder: SortKey?
        /// A filtering option for where to start.
        public let startPosition: StartPosition?

        @inlinable
        public init(connectionToken: String, contactId: String? = nil, maxResults: Int? = nil, nextToken: String? = nil, scanDirection: ScanDirection? = nil, sortOrder: SortKey? = nil, startPosition: StartPosition? = nil) {
            self.connectionToken = connectionToken
            self.contactId = contactId
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.scanDirection = scanDirection
            self.sortOrder = sortOrder
            self.startPosition = startPosition
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodeHeader(self.connectionToken, key: "X-Amz-Bearer")
            try container.encodeIfPresent(self.contactId, forKey: .contactId)
            try container.encodeIfPresent(self.maxResults, forKey: .maxResults)
            try container.encodeIfPresent(self.nextToken, forKey: .nextToken)
            try container.encodeIfPresent(self.scanDirection, forKey: .scanDirection)
            try container.encodeIfPresent(self.sortOrder, forKey: .sortOrder)
            try container.encodeIfPresent(self.startPosition, forKey: .startPosition)
        }

        public func validate(name: String) throws {
            try self.validate(self.connectionToken, name: "connectionToken", parent: name, max: 1000)
            try self.validate(self.connectionToken, name: "connectionToken", parent: name, min: 1)
            try self.validate(self.contactId, name: "contactId", parent: name, max: 256)
            try self.validate(self.contactId, name: "contactId", parent: name, min: 1)
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 0)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 1000)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.startPosition?.validate(name: "\(name).startPosition")
        }

        private enum CodingKeys: String, CodingKey {
            case contactId = "ContactId"
            case maxResults = "MaxResults"
            case nextToken = "NextToken"
            case scanDirection = "ScanDirection"
            case sortOrder = "SortOrder"
            case startPosition = "StartPosition"
        }
    }

    public struct GetTranscriptResponse: AWSDecodableShape {
        /// The initial contact ID for the contact.
        public let initialContactId: String?
        /// The pagination token. Use the value returned previously in the next subsequent request to retrieve the next set of results.
        public let nextToken: String?
        /// The list of messages in the session.
        public let transcript: [Item]?

        @inlinable
        public init(initialContactId: String? = nil, nextToken: String? = nil, transcript: [Item]? = nil) {
            self.initialContactId = initialContactId
            self.nextToken = nextToken
            self.transcript = transcript
        }

        private enum CodingKeys: String, CodingKey {
            case initialContactId = "InitialContactId"
            case nextToken = "NextToken"
            case transcript = "Transcript"
        }
    }

    public struct Item: AWSDecodableShape {
        /// The time when the message or event was sent. It's specified in ISO 8601 format: yyyy-MM-ddThh:mm:ss.SSSZ. For example, 2019-11-08T02:41:28.172Z.
        public let absoluteTime: String?
        /// Provides information about the attachments.
        public let attachments: [AttachmentItem]?
        /// The contactId on which the transcript item was originally sent. This field is populated only when the transcript item is from the current chat session.
        public let contactId: String?
        /// The content of the message or event.
        public let content: String?
        /// The type of content of the item.
        public let contentType: String?
        /// The chat display name of the sender.
        public let displayName: String?
        /// The ID of the item.
        public let id: String?
        /// The metadata related to the message. Currently this supports only information related to message receipts.
        public let messageMetadata: MessageMetadata?
        /// The ID of the sender in the session.
        public let participantId: String?
        /// The role of the sender. For example, is it a customer, agent, or system.
        public let participantRole: ParticipantRole?
        /// The contactId on which the transcript item was originally sent. This field is only populated for persistent chats when the transcript item is from the past chat session. For more information, see Enable persistent chat.
        public let relatedContactId: String?
        /// Type of the item: message or event.
        public let type: ChatItemType?

        @inlinable
        public init(absoluteTime: String? = nil, attachments: [AttachmentItem]? = nil, contactId: String? = nil, content: String? = nil, contentType: String? = nil, displayName: String? = nil, id: String? = nil, messageMetadata: MessageMetadata? = nil, participantId: String? = nil, participantRole: ParticipantRole? = nil, relatedContactId: String? = nil, type: ChatItemType? = nil) {
            self.absoluteTime = absoluteTime
            self.attachments = attachments
            self.contactId = contactId
            self.content = content
            self.contentType = contentType
            self.displayName = displayName
            self.id = id
            self.messageMetadata = messageMetadata
            self.participantId = participantId
            self.participantRole = participantRole
            self.relatedContactId = relatedContactId
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case absoluteTime = "AbsoluteTime"
            case attachments = "Attachments"
            case contactId = "ContactId"
            case content = "Content"
            case contentType = "ContentType"
            case displayName = "DisplayName"
            case id = "Id"
            case messageMetadata = "MessageMetadata"
            case participantId = "ParticipantId"
            case participantRole = "ParticipantRole"
            case relatedContactId = "RelatedContactId"
            case type = "Type"
        }
    }

    public struct MessageMetadata: AWSDecodableShape {
        /// The identifier of the message that contains the metadata information.
        public let messageId: String?
        /// The list of receipt information for a message for different recipients.
        public let receipts: [Receipt]?

        @inlinable
        public init(messageId: String? = nil, receipts: [Receipt]? = nil) {
            self.messageId = messageId
            self.receipts = receipts
        }

        private enum CodingKeys: String, CodingKey {
            case messageId = "MessageId"
            case receipts = "Receipts"
        }
    }

    public struct Receipt: AWSDecodableShape {
        /// The time when the message was delivered to the recipient.
        public let deliveredTimestamp: String?
        /// The time when the message was read by the recipient.
        public let readTimestamp: String?
        /// The identifier of the recipient of the message.
        public let recipientParticipantId: String?

        @inlinable
        public init(deliveredTimestamp: String? = nil, readTimestamp: String? = nil, recipientParticipantId: String? = nil) {
            self.deliveredTimestamp = deliveredTimestamp
            self.readTimestamp = readTimestamp
            self.recipientParticipantId = recipientParticipantId
        }

        private enum CodingKeys: String, CodingKey {
            case deliveredTimestamp = "DeliveredTimestamp"
            case readTimestamp = "ReadTimestamp"
            case recipientParticipantId = "RecipientParticipantId"
        }
    }

    public struct ResourceNotFoundException: AWSErrorShape {
        public let message: String?
        /// The identifier of the resource.
        public let resourceId: String?
        /// The type of Amazon Connect resource.
        public let resourceType: ResourceType?

        @inlinable
        public init(message: String? = nil, resourceId: String? = nil, resourceType: ResourceType? = nil) {
            self.message = message
            self.resourceId = resourceId
            self.resourceType = resourceType
        }

        private enum CodingKeys: String, CodingKey {
            case message = "Message"
            case resourceId = "ResourceId"
            case resourceType = "ResourceType"
        }
    }

    public struct SendEventRequest: AWSEncodableShape {
        /// A unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If not provided, the Amazon Web Services SDK populates this field. For more information about idempotency, see Making retries safe with idempotent APIs.
        public let clientToken: String?
        /// The authentication token associated with the participant's connection.
        public let connectionToken: String
        /// The content of the event to be sent (for example, message text). For content related to message receipts, this is supported in the form of a JSON string. Sample Content: "{\"messageId\":\"11111111-aaaa-bbbb-cccc-EXAMPLE01234\"}"
        public let content: String?
        /// The content type of the request. Supported types are:   application/vnd.amazonaws.connect.event.typing   application/vnd.amazonaws.connect.event.connection.acknowledged (will be deprecated on December 31, 2024)    application/vnd.amazonaws.connect.event.message.delivered   application/vnd.amazonaws.connect.event.message.read
        public let contentType: String

        @inlinable
        public init(clientToken: String? = SendEventRequest.idempotencyToken(), connectionToken: String, content: String? = nil, contentType: String) {
            self.clientToken = clientToken
            self.connectionToken = connectionToken
            self.content = content
            self.contentType = contentType
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.clientToken, forKey: .clientToken)
            request.encodeHeader(self.connectionToken, key: "X-Amz-Bearer")
            try container.encodeIfPresent(self.content, forKey: .content)
            try container.encode(self.contentType, forKey: .contentType)
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 500)
            try self.validate(self.connectionToken, name: "connectionToken", parent: name, max: 1000)
            try self.validate(self.connectionToken, name: "connectionToken", parent: name, min: 1)
            try self.validate(self.content, name: "content", parent: name, max: 16384)
            try self.validate(self.content, name: "content", parent: name, min: 1)
            try self.validate(self.contentType, name: "contentType", parent: name, max: 100)
            try self.validate(self.contentType, name: "contentType", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "ClientToken"
            case content = "Content"
            case contentType = "ContentType"
        }
    }

    public struct SendEventResponse: AWSDecodableShape {
        /// The time when the event was sent. It's specified in ISO 8601 format: yyyy-MM-ddThh:mm:ss.SSSZ. For example, 2019-11-08T02:41:28.172Z.
        public let absoluteTime: String?
        /// The ID of the response.
        public let id: String?

        @inlinable
        public init(absoluteTime: String? = nil, id: String? = nil) {
            self.absoluteTime = absoluteTime
            self.id = id
        }

        private enum CodingKeys: String, CodingKey {
            case absoluteTime = "AbsoluteTime"
            case id = "Id"
        }
    }

    public struct SendMessageRequest: AWSEncodableShape {
        /// A unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If not provided, the Amazon Web Services SDK populates this field. For more information about idempotency, see Making retries safe with idempotent APIs.
        public let clientToken: String?
        /// The authentication token associated with the connection.
        public let connectionToken: String
        /// The content of the message.    For text/plain and text/markdown, the Length Constraints are Minimum of 1, Maximum of 1024.    For application/json, the Length Constraints are Minimum of 1, Maximum of 12000.    For application/vnd.amazonaws.connect.message.interactive.response, the Length Constraints are Minimum of 1, Maximum of 12288.
        public let content: String
        /// The type of the content. Supported types are text/plain, text/markdown, application/json, and application/vnd.amazonaws.connect.message.interactive.response.
        public let contentType: String

        @inlinable
        public init(clientToken: String? = SendMessageRequest.idempotencyToken(), connectionToken: String, content: String, contentType: String) {
            self.clientToken = clientToken
            self.connectionToken = connectionToken
            self.content = content
            self.contentType = contentType
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.clientToken, forKey: .clientToken)
            request.encodeHeader(self.connectionToken, key: "X-Amz-Bearer")
            try container.encode(self.content, forKey: .content)
            try container.encode(self.contentType, forKey: .contentType)
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 500)
            try self.validate(self.connectionToken, name: "connectionToken", parent: name, max: 1000)
            try self.validate(self.connectionToken, name: "connectionToken", parent: name, min: 1)
            try self.validate(self.content, name: "content", parent: name, max: 16384)
            try self.validate(self.content, name: "content", parent: name, min: 1)
            try self.validate(self.contentType, name: "contentType", parent: name, max: 100)
            try self.validate(self.contentType, name: "contentType", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "ClientToken"
            case content = "Content"
            case contentType = "ContentType"
        }
    }

    public struct SendMessageResponse: AWSDecodableShape {
        /// The time when the message was sent. It's specified in ISO 8601 format: yyyy-MM-ddThh:mm:ss.SSSZ. For example, 2019-11-08T02:41:28.172Z.
        public let absoluteTime: String?
        /// The ID of the message.
        public let id: String?

        @inlinable
        public init(absoluteTime: String? = nil, id: String? = nil) {
            self.absoluteTime = absoluteTime
            self.id = id
        }

        private enum CodingKeys: String, CodingKey {
            case absoluteTime = "AbsoluteTime"
            case id = "Id"
        }
    }

    public struct StartAttachmentUploadRequest: AWSEncodableShape {
        /// A case-sensitive name of the attachment being uploaded.
        public let attachmentName: String
        /// The size of the attachment in bytes.
        public let attachmentSizeInBytes: Int64
        /// A unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If not provided, the Amazon Web Services SDK populates this field. For more information about idempotency, see Making retries safe with idempotent APIs.
        public let clientToken: String
        /// The authentication token associated with the participant's connection.
        public let connectionToken: String
        /// Describes the MIME file type of the attachment. For a list of supported file types, see Feature specifications in the Amazon Connect Administrator Guide.
        public let contentType: String

        @inlinable
        public init(attachmentName: String, attachmentSizeInBytes: Int64 = 0, clientToken: String = StartAttachmentUploadRequest.idempotencyToken(), connectionToken: String, contentType: String) {
            self.attachmentName = attachmentName
            self.attachmentSizeInBytes = attachmentSizeInBytes
            self.clientToken = clientToken
            self.connectionToken = connectionToken
            self.contentType = contentType
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encode(self.attachmentName, forKey: .attachmentName)
            try container.encode(self.attachmentSizeInBytes, forKey: .attachmentSizeInBytes)
            try container.encode(self.clientToken, forKey: .clientToken)
            request.encodeHeader(self.connectionToken, key: "X-Amz-Bearer")
            try container.encode(self.contentType, forKey: .contentType)
        }

        public func validate(name: String) throws {
            try self.validate(self.attachmentName, name: "attachmentName", parent: name, max: 256)
            try self.validate(self.attachmentName, name: "attachmentName", parent: name, min: 1)
            try self.validate(self.attachmentSizeInBytes, name: "attachmentSizeInBytes", parent: name, min: 1)
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 500)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.validate(self.connectionToken, name: "connectionToken", parent: name, max: 1000)
            try self.validate(self.connectionToken, name: "connectionToken", parent: name, min: 1)
            try self.validate(self.contentType, name: "contentType", parent: name, max: 255)
            try self.validate(self.contentType, name: "contentType", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case attachmentName = "AttachmentName"
            case attachmentSizeInBytes = "AttachmentSizeInBytes"
            case clientToken = "ClientToken"
            case contentType = "ContentType"
        }
    }

    public struct StartAttachmentUploadResponse: AWSDecodableShape {
        /// A unique identifier for the attachment.
        public let attachmentId: String?
        /// The headers to be provided while uploading the file to the URL.
        public let uploadMetadata: UploadMetadata?

        @inlinable
        public init(attachmentId: String? = nil, uploadMetadata: UploadMetadata? = nil) {
            self.attachmentId = attachmentId
            self.uploadMetadata = uploadMetadata
        }

        private enum CodingKeys: String, CodingKey {
            case attachmentId = "AttachmentId"
            case uploadMetadata = "UploadMetadata"
        }
    }

    public struct StartPosition: AWSEncodableShape {
        /// The time in ISO format where to start. It's specified in ISO 8601 format: yyyy-MM-ddThh:mm:ss.SSSZ. For example, 2019-11-08T02:41:28.172Z.
        public let absoluteTime: String?
        /// The ID of the message or event where to start.
        public let id: String?
        /// The start position of the most recent message where you want to start.
        public let mostRecent: Int?

        @inlinable
        public init(absoluteTime: String? = nil, id: String? = nil, mostRecent: Int? = nil) {
            self.absoluteTime = absoluteTime
            self.id = id
            self.mostRecent = mostRecent
        }

        public func validate(name: String) throws {
            try self.validate(self.absoluteTime, name: "absoluteTime", parent: name, max: 100)
            try self.validate(self.absoluteTime, name: "absoluteTime", parent: name, min: 1)
            try self.validate(self.id, name: "id", parent: name, max: 256)
            try self.validate(self.id, name: "id", parent: name, min: 1)
            try self.validate(self.mostRecent, name: "mostRecent", parent: name, max: 100)
            try self.validate(self.mostRecent, name: "mostRecent", parent: name, min: 0)
        }

        private enum CodingKeys: String, CodingKey {
            case absoluteTime = "AbsoluteTime"
            case id = "Id"
            case mostRecent = "MostRecent"
        }
    }

    public struct UploadMetadata: AWSDecodableShape {
        /// The headers to be provided while uploading the file to the URL.
        public let headersToInclude: [String: String]?
        /// This is the pre-signed URL that can be used for uploading the file to Amazon S3 when used in response
        /// to StartAttachmentUpload.
        public let url: String?
        /// The expiration time of the URL in ISO timestamp. It's specified in ISO 8601 format: yyyy-MM-ddThh:mm:ss.SSSZ. For example, 2019-11-08T02:41:28.172Z.
        public let urlExpiry: String?

        @inlinable
        public init(headersToInclude: [String: String]? = nil, url: String? = nil, urlExpiry: String? = nil) {
            self.headersToInclude = headersToInclude
            self.url = url
            self.urlExpiry = urlExpiry
        }

        private enum CodingKeys: String, CodingKey {
            case headersToInclude = "HeadersToInclude"
            case url = "Url"
            case urlExpiry = "UrlExpiry"
        }
    }

    public struct View: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the view.
        public let arn: String?
        /// View content containing all content necessary to render a view except for runtime input data.
        public let content: ViewContent?
        /// The identifier of the view.
        public let id: String?
        /// The name of the view.
        public let name: String?
        /// The current version of the view.
        public let version: Int?

        @inlinable
        public init(arn: String? = nil, content: ViewContent? = nil, id: String? = nil, name: String? = nil, version: Int? = nil) {
            self.arn = arn
            self.content = content
            self.id = id
            self.name = name
            self.version = version
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case content = "Content"
            case id = "Id"
            case name = "Name"
            case version = "Version"
        }
    }

    public struct ViewContent: AWSDecodableShape {
        /// A list of actions possible from the view
        public let actions: [String]?
        /// The schema representing the input data that the view template must be supplied to render.
        public let inputSchema: String?
        /// The view template representing the structure of the view.
        public let template: String?

        @inlinable
        public init(actions: [String]? = nil, inputSchema: String? = nil, template: String? = nil) {
            self.actions = actions
            self.inputSchema = inputSchema
            self.template = template
        }

        private enum CodingKeys: String, CodingKey {
            case actions = "Actions"
            case inputSchema = "InputSchema"
            case template = "Template"
        }
    }

    public struct Websocket: AWSDecodableShape {
        /// The URL expiration timestamp in ISO date format. It's specified in ISO 8601 format: yyyy-MM-ddThh:mm:ss.SSSZ. For example, 2019-11-08T02:41:28.172Z.
        public let connectionExpiry: String?
        /// The URL of the websocket.
        public let url: String?

        @inlinable
        public init(connectionExpiry: String? = nil, url: String? = nil) {
            self.connectionExpiry = connectionExpiry
            self.url = url
        }

        private enum CodingKeys: String, CodingKey {
            case connectionExpiry = "ConnectionExpiry"
            case url = "Url"
        }
    }
}

// MARK: - Errors

/// Error enum for ConnectParticipant
public struct ConnectParticipantErrorType: AWSErrorType {
    enum Code: String {
        case accessDeniedException = "AccessDeniedException"
        case conflictException = "ConflictException"
        case internalServerException = "InternalServerException"
        case resourceNotFoundException = "ResourceNotFoundException"
        case serviceQuotaExceededException = "ServiceQuotaExceededException"
        case throttlingException = "ThrottlingException"
        case validationException = "ValidationException"
    }

    private let error: Code
    public let context: AWSErrorContext?

    /// initialize ConnectParticipant
    public init?(errorCode: String, context: AWSErrorContext) {
        guard let error = Code(rawValue: errorCode) else { return nil }
        self.error = error
        self.context = context
    }

    internal init(_ error: Code) {
        self.error = error
        self.context = nil
    }

    /// return error code string
    public var errorCode: String { self.error.rawValue }

    /// You do not have sufficient access to perform this action.
    public static var accessDeniedException: Self { .init(.accessDeniedException) }
    /// The requested operation conflicts with the current state of a service resource associated with the request.
    public static var conflictException: Self { .init(.conflictException) }
    /// This exception occurs when there is an internal failure in the Amazon Connect service.
    public static var internalServerException: Self { .init(.internalServerException) }
    /// The resource was not found.
    public static var resourceNotFoundException: Self { .init(.resourceNotFoundException) }
    /// The number of attachments per contact exceeds the quota.
    public static var serviceQuotaExceededException: Self { .init(.serviceQuotaExceededException) }
    /// The request was denied due to request throttling.
    public static var throttlingException: Self { .init(.throttlingException) }
    /// The input fails to satisfy the constraints specified by Amazon Connect.
    public static var validationException: Self { .init(.validationException) }
}

extension ConnectParticipantErrorType: AWSServiceErrorType {
    public static let errorCodeMap: [String: AWSErrorShape.Type] = [
        "ResourceNotFoundException": ConnectParticipant.ResourceNotFoundException.self
    ]
}

extension ConnectParticipantErrorType: Equatable {
    public static func == (lhs: ConnectParticipantErrorType, rhs: ConnectParticipantErrorType) -> Bool {
        lhs.error == rhs.error
    }
}

extension ConnectParticipantErrorType: CustomStringConvertible {
    public var description: String {
        return "\(self.error.rawValue): \(self.message ?? "")"
    }
}
