//===----------------------------------------------------------------------===//
//
// This source file is part of the Soto for AWS open source project
//
// Copyright (c) 2017-2021 the Soto project authors
// Licensed under Apache License v2.0
//
// See LICENSE.txt for license information
// See CONTRIBUTORS.txt for the list of Soto project authors
//
// SPDX-License-Identifier: Apache-2.0
//
//===----------------------------------------------------------------------===//

// THIS FILE IS AUTOMATICALLY GENERATED by https://github.com/soto-project/soto/tree/main/CodeGenerator. DO NOT EDIT.

import Foundation
import SotoCore

extension AppRunner {
    // MARK: Enums

    public enum AutoScalingConfigurationStatus: String, CustomStringConvertible, Codable {
        case active = "ACTIVE"
        case inactive = "INACTIVE"
        public var description: String { return self.rawValue }
    }

    public enum CertificateValidationRecordStatus: String, CustomStringConvertible, Codable {
        case failed = "FAILED"
        case pendingValidation = "PENDING_VALIDATION"
        case success = "SUCCESS"
        public var description: String { return self.rawValue }
    }

    public enum ConfigurationSource: String, CustomStringConvertible, Codable {
        case api = "API"
        case repository = "REPOSITORY"
        public var description: String { return self.rawValue }
    }

    public enum ConnectionStatus: String, CustomStringConvertible, Codable {
        case available = "AVAILABLE"
        case deleted = "DELETED"
        case error = "ERROR"
        case pendingHandshake = "PENDING_HANDSHAKE"
        public var description: String { return self.rawValue }
    }

    public enum CustomDomainAssociationStatus: String, CustomStringConvertible, Codable {
        case active = "ACTIVE"
        case bindingCertificate = "BINDING_CERTIFICATE"
        case createFailed = "CREATE_FAILED"
        case creating = "CREATING"
        case deleteFailed = "DELETE_FAILED"
        case deleting = "DELETING"
        case pendingCertificateDnsValidation = "PENDING_CERTIFICATE_DNS_VALIDATION"
        public var description: String { return self.rawValue }
    }

    public enum HealthCheckProtocol: String, CustomStringConvertible, Codable {
        case http = "HTTP"
        case tcp = "TCP"
        public var description: String { return self.rawValue }
    }

    public enum ImageRepositoryType: String, CustomStringConvertible, Codable {
        case ecr = "ECR"
        case ecrPublic = "ECR_PUBLIC"
        public var description: String { return self.rawValue }
    }

    public enum OperationStatus: String, CustomStringConvertible, Codable {
        case failed = "FAILED"
        case inProgress = "IN_PROGRESS"
        case pending = "PENDING"
        case rollbackFailed = "ROLLBACK_FAILED"
        case rollbackInProgress = "ROLLBACK_IN_PROGRESS"
        case rollbackSucceeded = "ROLLBACK_SUCCEEDED"
        case succeeded = "SUCCEEDED"
        public var description: String { return self.rawValue }
    }

    public enum OperationType: String, CustomStringConvertible, Codable {
        case createService = "CREATE_SERVICE"
        case deleteService = "DELETE_SERVICE"
        case pauseService = "PAUSE_SERVICE"
        case resumeService = "RESUME_SERVICE"
        case startDeployment = "START_DEPLOYMENT"
        public var description: String { return self.rawValue }
    }

    public enum ProviderType: String, CustomStringConvertible, Codable {
        case github = "GITHUB"
        public var description: String { return self.rawValue }
    }

    public enum Runtime: String, CustomStringConvertible, Codable {
        case nodejs12 = "NODEJS_12"
        case python3 = "PYTHON_3"
        public var description: String { return self.rawValue }
    }

    public enum ServiceStatus: String, CustomStringConvertible, Codable {
        case createFailed = "CREATE_FAILED"
        case deleteFailed = "DELETE_FAILED"
        case deleted = "DELETED"
        case operationInProgress = "OPERATION_IN_PROGRESS"
        case paused = "PAUSED"
        case running = "RUNNING"
        public var description: String { return self.rawValue }
    }

    public enum SourceCodeVersionType: String, CustomStringConvertible, Codable {
        case branch = "BRANCH"
        public var description: String { return self.rawValue }
    }

    // MARK: Shapes

    public struct AssociateCustomDomainRequest: AWSEncodableShape {
        /// A custom domain endpoint to associate. Specify a root domain (for example, example.com), a subdomain (for example, login.example.com or admin.login.example.com), or a wildcard (for example, *.example.com).
        public let domainName: String
        /// Set to true to associate the subdomain www.DomainName  with the App Runner service in addition to the base domain. Default: true
        public let enableWWWSubdomain: Bool?
        /// The Amazon Resource Name (ARN) of the App Runner service that you want to associate a custom domain name with.
        public let serviceArn: String

        public init(domainName: String, enableWWWSubdomain: Bool? = nil, serviceArn: String) {
            self.domainName = domainName
            self.enableWWWSubdomain = enableWWWSubdomain
            self.serviceArn = serviceArn
        }

        public func validate(name: String) throws {
            try self.validate(self.domainName, name: "domainName", parent: name, max: 255)
            try self.validate(self.domainName, name: "domainName", parent: name, min: 1)
            try self.validate(self.serviceArn, name: "serviceArn", parent: name, max: 1011)
            try self.validate(self.serviceArn, name: "serviceArn", parent: name, min: 1)
            try self.validate(self.serviceArn, name: "serviceArn", parent: name, pattern: "arn:aws(-[\\w]+)*:[a-z0-9-\\\\.]{0,63}:[a-z0-9-\\\\.]{0,63}:[0-9]{12}:(\\w|\\/|-){1,1011}")
        }

        private enum CodingKeys: String, CodingKey {
            case domainName = "DomainName"
            case enableWWWSubdomain = "EnableWWWSubdomain"
            case serviceArn = "ServiceArn"
        }
    }

    public struct AssociateCustomDomainResponse: AWSDecodableShape {
        /// A description of the domain name that's being associated.
        public let customDomain: CustomDomain
        /// The App Runner subdomain of the App Runner service. The custom domain name is mapped to this target name.
        public let dNSTarget: String
        /// The Amazon Resource Name (ARN) of the App Runner service with which a custom domain name is associated.
        public let serviceArn: String

        public init(customDomain: CustomDomain, dNSTarget: String, serviceArn: String) {
            self.customDomain = customDomain
            self.dNSTarget = dNSTarget
            self.serviceArn = serviceArn
        }

        private enum CodingKeys: String, CodingKey {
            case customDomain = "CustomDomain"
            case dNSTarget = "DNSTarget"
            case serviceArn = "ServiceArn"
        }
    }

    public struct AuthenticationConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the IAM role that grants the App Runner service access to a source repository. It's required for ECR image repositories (but not for ECR Public repositories).
        public let accessRoleArn: String?
        /// The Amazon Resource Name (ARN) of the App Runner connection that enables the App Runner service to connect to a source repository. It's required for GitHub code repositories.
        public let connectionArn: String?

        public init(accessRoleArn: String? = nil, connectionArn: String? = nil) {
            self.accessRoleArn = accessRoleArn
            self.connectionArn = connectionArn
        }

        public func validate(name: String) throws {
            try self.validate(self.accessRoleArn, name: "accessRoleArn", parent: name, max: 102)
            try self.validate(self.accessRoleArn, name: "accessRoleArn", parent: name, min: 29)
            try self.validate(self.accessRoleArn, name: "accessRoleArn", parent: name, pattern: "arn:(aws|aws-us-gov|aws-cn|aws-iso|aws-iso-b):iam::[0-9]{12}:role/[\\w+=,.@-]{1,64}")
            try self.validate(self.connectionArn, name: "connectionArn", parent: name, max: 1011)
            try self.validate(self.connectionArn, name: "connectionArn", parent: name, min: 1)
            try self.validate(self.connectionArn, name: "connectionArn", parent: name, pattern: "arn:aws(-[\\w]+)*:[a-z0-9-\\\\.]{0,63}:[a-z0-9-\\\\.]{0,63}:[0-9]{12}:(\\w|\\/|-){1,1011}")
        }

        private enum CodingKeys: String, CodingKey {
            case accessRoleArn = "AccessRoleArn"
            case connectionArn = "ConnectionArn"
        }
    }

    public struct AutoScalingConfiguration: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of this auto scaling configuration.
        public let autoScalingConfigurationArn: String?
        /// The customer-provided auto scaling configuration name. It can be used in multiple revisions of a configuration.
        public let autoScalingConfigurationName: String?
        /// The revision of this auto scaling configuration. It's unique among all the active configurations ("Status": "ACTIVE") that share the same AutoScalingConfigurationName.
        public let autoScalingConfigurationRevision: Int?
        /// The time when the auto scaling configuration was created. It's in Unix time stamp format.
        public let createdAt: Date?
        /// The time when the auto scaling configuration was deleted. It's in Unix time stamp format.
        public let deletedAt: Date?
        /// It's set to true for the configuration with the highest Revision among all configurations that share the same Name. It's set to false otherwise.
        public let latest: Bool?
        /// The maximum number of concurrent requests that an instance processes. If the number of concurrent requests exceeds this limit, App Runner scales the service up.
        public let maxConcurrency: Int?
        /// The maximum number of instances that a service scales up to. At most MaxSize instances actively serve traffic for your service.
        public let maxSize: Int?
        /// The minimum number of instances that App Runner provisions for a service. The service always has at least MinSize provisioned instances. Some of them actively serve traffic. The rest of them (provisioned and inactive instances) are a cost-effective compute capacity reserve and are ready to be quickly activated. You pay for memory usage of all the provisioned instances. You pay for CPU usage of only the active subset. App Runner temporarily doubles the number of provisioned instances during deployments, to maintain the same capacity for both old and new code.
        public let minSize: Int?
        /// The current state of the auto scaling configuration. If the status of a configuration revision is INACTIVE, it was deleted and can't be used. Inactive configuration revisions are permanently removed some time after they are deleted.
        public let status: AutoScalingConfigurationStatus?

        public init(autoScalingConfigurationArn: String? = nil, autoScalingConfigurationName: String? = nil, autoScalingConfigurationRevision: Int? = nil, createdAt: Date? = nil, deletedAt: Date? = nil, latest: Bool? = nil, maxConcurrency: Int? = nil, maxSize: Int? = nil, minSize: Int? = nil, status: AutoScalingConfigurationStatus? = nil) {
            self.autoScalingConfigurationArn = autoScalingConfigurationArn
            self.autoScalingConfigurationName = autoScalingConfigurationName
            self.autoScalingConfigurationRevision = autoScalingConfigurationRevision
            self.createdAt = createdAt
            self.deletedAt = deletedAt
            self.latest = latest
            self.maxConcurrency = maxConcurrency
            self.maxSize = maxSize
            self.minSize = minSize
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case autoScalingConfigurationArn = "AutoScalingConfigurationArn"
            case autoScalingConfigurationName = "AutoScalingConfigurationName"
            case autoScalingConfigurationRevision = "AutoScalingConfigurationRevision"
            case createdAt = "CreatedAt"
            case deletedAt = "DeletedAt"
            case latest = "Latest"
            case maxConcurrency = "MaxConcurrency"
            case maxSize = "MaxSize"
            case minSize = "MinSize"
            case status = "Status"
        }
    }

    public struct AutoScalingConfigurationSummary: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of this auto scaling configuration.
        public let autoScalingConfigurationArn: String?
        /// The customer-provided auto scaling configuration name. It can be used in multiple revisions of a configuration.
        public let autoScalingConfigurationName: String?
        /// The revision of this auto scaling configuration. It's unique among all the active configurations ("Status": "ACTIVE") with the same AutoScalingConfigurationName.
        public let autoScalingConfigurationRevision: Int?

        public init(autoScalingConfigurationArn: String? = nil, autoScalingConfigurationName: String? = nil, autoScalingConfigurationRevision: Int? = nil) {
            self.autoScalingConfigurationArn = autoScalingConfigurationArn
            self.autoScalingConfigurationName = autoScalingConfigurationName
            self.autoScalingConfigurationRevision = autoScalingConfigurationRevision
        }

        private enum CodingKeys: String, CodingKey {
            case autoScalingConfigurationArn = "AutoScalingConfigurationArn"
            case autoScalingConfigurationName = "AutoScalingConfigurationName"
            case autoScalingConfigurationRevision = "AutoScalingConfigurationRevision"
        }
    }

    public struct CertificateValidationRecord: AWSDecodableShape {
        /// The certificate CNAME record name.
        public let name: String?
        /// The current state of the certificate CNAME record validation. It should change to SUCCESS after App Runner completes validation with your DNS.
        public let status: CertificateValidationRecordStatus?
        /// The record type, always CNAME.
        public let type: String?
        /// The certificate CNAME record value.
        public let value: String?

        public init(name: String? = nil, status: CertificateValidationRecordStatus? = nil, type: String? = nil, value: String? = nil) {
            self.name = name
            self.status = status
            self.type = type
            self.value = value
        }

        private enum CodingKeys: String, CodingKey {
            case name = "Name"
            case status = "Status"
            case type = "Type"
            case value = "Value"
        }
    }

    public struct CodeConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The basic configuration for building and running the App Runner service. Use it to quickly launch an App Runner service without providing a apprunner.yaml file in the source code repository (or ignoring the file if it exists).
        public let codeConfigurationValues: CodeConfigurationValues?
        /// The source of the App Runner configuration. Values are interpreted as follows:    REPOSITORY – App Runner reads configuration values from the apprunner.yaml file in the source code repository and ignores CodeConfigurationValues.    API – App Runner uses configuration values provided in CodeConfigurationValues and ignores the apprunner.yaml file in the source code repository.
        public let configurationSource: ConfigurationSource

        public init(codeConfigurationValues: CodeConfigurationValues? = nil, configurationSource: ConfigurationSource) {
            self.codeConfigurationValues = codeConfigurationValues
            self.configurationSource = configurationSource
        }

        public func validate(name: String) throws {
            try self.codeConfigurationValues?.validate(name: "\(name).codeConfigurationValues")
        }

        private enum CodingKeys: String, CodingKey {
            case codeConfigurationValues = "CodeConfigurationValues"
            case configurationSource = "ConfigurationSource"
        }
    }

    public struct CodeConfigurationValues: AWSEncodableShape & AWSDecodableShape {
        /// The command App Runner runs to build your application.
        public let buildCommand: String?
        /// The port that your application listens to in the container. Default: 8080
        public let port: String?
        /// A runtime environment type for building and running an App Runner service. It represents a programming language runtime.
        public let runtime: Runtime
        /// The environment variables that are available to your running App Runner service. An array of key-value pairs. Keys with a prefix of AWSAPPRUNNER are reserved for system use and aren't valid.
        public let runtimeEnvironmentVariables: [String: String]?
        /// The command App Runner runs to start your application.
        public let startCommand: String?

        public init(buildCommand: String? = nil, port: String? = nil, runtime: Runtime, runtimeEnvironmentVariables: [String: String]? = nil, startCommand: String? = nil) {
            self.buildCommand = buildCommand
            self.port = port
            self.runtime = runtime
            self.runtimeEnvironmentVariables = runtimeEnvironmentVariables
            self.startCommand = startCommand
        }

        public func validate(name: String) throws {
            try self.validate(self.port, name: "port", parent: name, max: 51200)
            try self.validate(self.port, name: "port", parent: name, min: 0)
            try self.validate(self.port, name: "port", parent: name, pattern: ".*")
        }

        private enum CodingKeys: String, CodingKey {
            case buildCommand = "BuildCommand"
            case port = "Port"
            case runtime = "Runtime"
            case runtimeEnvironmentVariables = "RuntimeEnvironmentVariables"
            case startCommand = "StartCommand"
        }
    }

    public struct CodeRepository: AWSEncodableShape & AWSDecodableShape {
        /// Configuration for building and running the service from a source code repository.
        public let codeConfiguration: CodeConfiguration?
        /// The location of the repository that contains the source code.
        public let repositoryUrl: String
        /// The version that should be used within the source code repository.
        public let sourceCodeVersion: SourceCodeVersion

        public init(codeConfiguration: CodeConfiguration? = nil, repositoryUrl: String, sourceCodeVersion: SourceCodeVersion) {
            self.codeConfiguration = codeConfiguration
            self.repositoryUrl = repositoryUrl
            self.sourceCodeVersion = sourceCodeVersion
        }

        public func validate(name: String) throws {
            try self.codeConfiguration?.validate(name: "\(name).codeConfiguration")
            try self.validate(self.repositoryUrl, name: "repositoryUrl", parent: name, max: 51200)
            try self.validate(self.repositoryUrl, name: "repositoryUrl", parent: name, min: 0)
            try self.validate(self.repositoryUrl, name: "repositoryUrl", parent: name, pattern: ".*")
            try self.sourceCodeVersion.validate(name: "\(name).sourceCodeVersion")
        }

        private enum CodingKeys: String, CodingKey {
            case codeConfiguration = "CodeConfiguration"
            case repositoryUrl = "RepositoryUrl"
            case sourceCodeVersion = "SourceCodeVersion"
        }
    }

    public struct Connection: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of this connection.
        public let connectionArn: String?
        /// The customer-provided connection name.
        public let connectionName: String?
        /// The App Runner connection creation time, expressed as a Unix time stamp.
        public let createdAt: Date?
        /// The source repository provider.
        public let providerType: ProviderType?
        /// The current state of the App Runner connection. When the state is AVAILABLE, you can use the connection to create an App Runner service.
        public let status: ConnectionStatus?

        public init(connectionArn: String? = nil, connectionName: String? = nil, createdAt: Date? = nil, providerType: ProviderType? = nil, status: ConnectionStatus? = nil) {
            self.connectionArn = connectionArn
            self.connectionName = connectionName
            self.createdAt = createdAt
            self.providerType = providerType
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case connectionArn = "ConnectionArn"
            case connectionName = "ConnectionName"
            case createdAt = "CreatedAt"
            case providerType = "ProviderType"
            case status = "Status"
        }
    }

    public struct ConnectionSummary: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of this connection.
        public let connectionArn: String?
        /// The customer-provided connection name.
        public let connectionName: String?
        /// The App Runner connection creation time, expressed as a Unix time stamp.
        public let createdAt: Date?
        /// The source repository provider.
        public let providerType: ProviderType?
        /// The current state of the App Runner connection. When the state is AVAILABLE, you can use the connection to create an App Runner service.
        public let status: ConnectionStatus?

        public init(connectionArn: String? = nil, connectionName: String? = nil, createdAt: Date? = nil, providerType: ProviderType? = nil, status: ConnectionStatus? = nil) {
            self.connectionArn = connectionArn
            self.connectionName = connectionName
            self.createdAt = createdAt
            self.providerType = providerType
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case connectionArn = "ConnectionArn"
            case connectionName = "ConnectionName"
            case createdAt = "CreatedAt"
            case providerType = "ProviderType"
            case status = "Status"
        }
    }

    public struct CreateAutoScalingConfigurationRequest: AWSEncodableShape {
        /// A name for the auto scaling configuration. When you use it for the first time in an AWS Region, App Runner creates revision number 1 of this name. When you use the same name in subsequent calls, App Runner creates incremental revisions of the configuration.
        public let autoScalingConfigurationName: String
        /// The maximum number of concurrent requests that you want an instance to process. If the number of concurrent requests exceeds this limit, App Runner scales up your service. Default: 100
        public let maxConcurrency: Int?
        /// The maximum number of instances that your service scales up to. At most MaxSize instances actively serve traffic for your service. Default: 25
        public let maxSize: Int?
        /// The minimum number of instances that App Runner provisions for your service. The service always has at least MinSize provisioned instances. Some of them actively serve traffic. The rest of them (provisioned and inactive instances) are a cost-effective compute capacity reserve and are ready to be quickly activated. You pay for memory usage of all the provisioned instances. You pay for CPU usage of only the active subset. App Runner temporarily doubles the number of provisioned instances during deployments, to maintain the same capacity for both old and new code. Default: 1
        public let minSize: Int?
        /// A list of metadata items that you can associate with your auto scaling configuration resource. A tag is a key-value pair.
        public let tags: [Tag]?

        public init(autoScalingConfigurationName: String, maxConcurrency: Int? = nil, maxSize: Int? = nil, minSize: Int? = nil, tags: [Tag]? = nil) {
            self.autoScalingConfigurationName = autoScalingConfigurationName
            self.maxConcurrency = maxConcurrency
            self.maxSize = maxSize
            self.minSize = minSize
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.validate(self.autoScalingConfigurationName, name: "autoScalingConfigurationName", parent: name, max: 32)
            try self.validate(self.autoScalingConfigurationName, name: "autoScalingConfigurationName", parent: name, min: 4)
            try self.validate(self.autoScalingConfigurationName, name: "autoScalingConfigurationName", parent: name, pattern: "[A-Za-z0-9][A-Za-z0-9\\-_]{3,31}")
            try self.validate(self.maxConcurrency, name: "maxConcurrency", parent: name, max: 200)
            try self.validate(self.maxConcurrency, name: "maxConcurrency", parent: name, min: 1)
            try self.validate(self.maxSize, name: "maxSize", parent: name, max: 25)
            try self.validate(self.maxSize, name: "maxSize", parent: name, min: 1)
            try self.validate(self.minSize, name: "minSize", parent: name, max: 25)
            try self.validate(self.minSize, name: "minSize", parent: name, min: 1)
            try self.tags?.forEach {
                try $0.validate(name: "\(name).tags[]")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case autoScalingConfigurationName = "AutoScalingConfigurationName"
            case maxConcurrency = "MaxConcurrency"
            case maxSize = "MaxSize"
            case minSize = "MinSize"
            case tags = "Tags"
        }
    }

    public struct CreateAutoScalingConfigurationResponse: AWSDecodableShape {
        /// A description of the App Runner auto scaling configuration that's created by this request.
        public let autoScalingConfiguration: AutoScalingConfiguration

        public init(autoScalingConfiguration: AutoScalingConfiguration) {
            self.autoScalingConfiguration = autoScalingConfiguration
        }

        private enum CodingKeys: String, CodingKey {
            case autoScalingConfiguration = "AutoScalingConfiguration"
        }
    }

    public struct CreateConnectionRequest: AWSEncodableShape {
        /// A name for the new connection. It must be unique across all App Runner connections for the AWS account in the AWS Region.
        public let connectionName: String
        /// The source repository provider.
        public let providerType: ProviderType
        /// A list of metadata items that you can associate with your connection resource. A tag is a key-value pair.
        public let tags: [Tag]?

        public init(connectionName: String, providerType: ProviderType, tags: [Tag]? = nil) {
            self.connectionName = connectionName
            self.providerType = providerType
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.validate(self.connectionName, name: "connectionName", parent: name, max: 32)
            try self.validate(self.connectionName, name: "connectionName", parent: name, min: 4)
            try self.validate(self.connectionName, name: "connectionName", parent: name, pattern: "[A-Za-z0-9][A-Za-z0-9\\-_]{3,31}")
            try self.tags?.forEach {
                try $0.validate(name: "\(name).tags[]")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case connectionName = "ConnectionName"
            case providerType = "ProviderType"
            case tags = "Tags"
        }
    }

    public struct CreateConnectionResponse: AWSDecodableShape {
        /// A description of the App Runner connection that's created by this request.
        public let connection: Connection

        public init(connection: Connection) {
            self.connection = connection
        }

        private enum CodingKeys: String, CodingKey {
            case connection = "Connection"
        }
    }

    public struct CreateServiceRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of an App Runner automatic scaling configuration resource that you want to associate with your service. If not provided, App Runner associates the latest revision of a default auto scaling configuration.
        public let autoScalingConfigurationArn: String?
        /// An optional custom encryption key that App Runner uses to encrypt the copy of your source repository that it maintains and your service logs. By default, App Runner uses an AWS managed CMK.
        public let encryptionConfiguration: EncryptionConfiguration?
        /// The settings for the health check that AWS App Runner performs to monitor the health of your service.
        public let healthCheckConfiguration: HealthCheckConfiguration?
        /// The runtime configuration of instances (scaling units) of the App Runner service.
        public let instanceConfiguration: InstanceConfiguration?
        /// A name for the new service. It must be unique across all the running App Runner services in your AWS account in the AWS Region.
        public let serviceName: String
        /// The source to deploy to the App Runner service. It can be a code or an image repository.
        public let sourceConfiguration: SourceConfiguration
        /// An optional list of metadata items that you can associate with your service resource. A tag is a key-value pair.
        public let tags: [Tag]?

        public init(autoScalingConfigurationArn: String? = nil, encryptionConfiguration: EncryptionConfiguration? = nil, healthCheckConfiguration: HealthCheckConfiguration? = nil, instanceConfiguration: InstanceConfiguration? = nil, serviceName: String, sourceConfiguration: SourceConfiguration, tags: [Tag]? = nil) {
            self.autoScalingConfigurationArn = autoScalingConfigurationArn
            self.encryptionConfiguration = encryptionConfiguration
            self.healthCheckConfiguration = healthCheckConfiguration
            self.instanceConfiguration = instanceConfiguration
            self.serviceName = serviceName
            self.sourceConfiguration = sourceConfiguration
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.validate(self.autoScalingConfigurationArn, name: "autoScalingConfigurationArn", parent: name, max: 1011)
            try self.validate(self.autoScalingConfigurationArn, name: "autoScalingConfigurationArn", parent: name, min: 1)
            try self.validate(self.autoScalingConfigurationArn, name: "autoScalingConfigurationArn", parent: name, pattern: "arn:aws(-[\\w]+)*:[a-z0-9-\\\\.]{0,63}:[a-z0-9-\\\\.]{0,63}:[0-9]{12}:(\\w|\\/|-){1,1011}")
            try self.encryptionConfiguration?.validate(name: "\(name).encryptionConfiguration")
            try self.healthCheckConfiguration?.validate(name: "\(name).healthCheckConfiguration")
            try self.instanceConfiguration?.validate(name: "\(name).instanceConfiguration")
            try self.validate(self.serviceName, name: "serviceName", parent: name, max: 40)
            try self.validate(self.serviceName, name: "serviceName", parent: name, min: 4)
            try self.validate(self.serviceName, name: "serviceName", parent: name, pattern: "[A-Za-z0-9][A-Za-z0-9-_]{3,39}")
            try self.sourceConfiguration.validate(name: "\(name).sourceConfiguration")
            try self.tags?.forEach {
                try $0.validate(name: "\(name).tags[]")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case autoScalingConfigurationArn = "AutoScalingConfigurationArn"
            case encryptionConfiguration = "EncryptionConfiguration"
            case healthCheckConfiguration = "HealthCheckConfiguration"
            case instanceConfiguration = "InstanceConfiguration"
            case serviceName = "ServiceName"
            case sourceConfiguration = "SourceConfiguration"
            case tags = "Tags"
        }
    }

    public struct CreateServiceResponse: AWSDecodableShape {
        /// The unique ID of the asynchronous operation that this request started. You can use it combined with the ListOperations call to track the operation's progress.
        public let operationId: String
        /// A description of the App Runner service that's created by this request.
        public let service: Service

        public init(operationId: String, service: Service) {
            self.operationId = operationId
            self.service = service
        }

        private enum CodingKeys: String, CodingKey {
            case operationId = "OperationId"
            case service = "Service"
        }
    }

    public struct CustomDomain: AWSDecodableShape {
        /// A list of certificate CNAME records that's used for this domain name.
        public let certificateValidationRecords: [CertificateValidationRecord]?
        /// An associated custom domain endpoint. It can be a root domain (for example, example.com), a subdomain (for example, login.example.com or admin.login.example.com), or a wildcard (for example, *.example.com).
        public let domainName: String
        /// When true, the subdomain www.DomainName  is associated with the App Runner service in addition to the base domain.
        public let enableWWWSubdomain: Bool
        /// The current state of the domain name association.
        public let status: CustomDomainAssociationStatus

        public init(certificateValidationRecords: [CertificateValidationRecord]? = nil, domainName: String, enableWWWSubdomain: Bool, status: CustomDomainAssociationStatus) {
            self.certificateValidationRecords = certificateValidationRecords
            self.domainName = domainName
            self.enableWWWSubdomain = enableWWWSubdomain
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case certificateValidationRecords = "CertificateValidationRecords"
            case domainName = "DomainName"
            case enableWWWSubdomain = "EnableWWWSubdomain"
            case status = "Status"
        }
    }

    public struct DeleteAutoScalingConfigurationRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the App Runner auto scaling configuration that you want to delete. The ARN can be a full auto scaling configuration ARN, or a partial ARN ending with either .../name  or .../name/revision . If a revision isn't specified, the latest active revision is deleted.
        public let autoScalingConfigurationArn: String

        public init(autoScalingConfigurationArn: String) {
            self.autoScalingConfigurationArn = autoScalingConfigurationArn
        }

        public func validate(name: String) throws {
            try self.validate(self.autoScalingConfigurationArn, name: "autoScalingConfigurationArn", parent: name, max: 1011)
            try self.validate(self.autoScalingConfigurationArn, name: "autoScalingConfigurationArn", parent: name, min: 1)
            try self.validate(self.autoScalingConfigurationArn, name: "autoScalingConfigurationArn", parent: name, pattern: "arn:aws(-[\\w]+)*:[a-z0-9-\\\\.]{0,63}:[a-z0-9-\\\\.]{0,63}:[0-9]{12}:(\\w|\\/|-){1,1011}")
        }

        private enum CodingKeys: String, CodingKey {
            case autoScalingConfigurationArn = "AutoScalingConfigurationArn"
        }
    }

    public struct DeleteAutoScalingConfigurationResponse: AWSDecodableShape {
        /// A description of the App Runner auto scaling configuration that this request just deleted.
        public let autoScalingConfiguration: AutoScalingConfiguration

        public init(autoScalingConfiguration: AutoScalingConfiguration) {
            self.autoScalingConfiguration = autoScalingConfiguration
        }

        private enum CodingKeys: String, CodingKey {
            case autoScalingConfiguration = "AutoScalingConfiguration"
        }
    }

    public struct DeleteConnectionRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the App Runner connection that you want to delete.
        public let connectionArn: String

        public init(connectionArn: String) {
            self.connectionArn = connectionArn
        }

        public func validate(name: String) throws {
            try self.validate(self.connectionArn, name: "connectionArn", parent: name, max: 1011)
            try self.validate(self.connectionArn, name: "connectionArn", parent: name, min: 1)
            try self.validate(self.connectionArn, name: "connectionArn", parent: name, pattern: "arn:aws(-[\\w]+)*:[a-z0-9-\\\\.]{0,63}:[a-z0-9-\\\\.]{0,63}:[0-9]{12}:(\\w|\\/|-){1,1011}")
        }

        private enum CodingKeys: String, CodingKey {
            case connectionArn = "ConnectionArn"
        }
    }

    public struct DeleteConnectionResponse: AWSDecodableShape {
        /// A description of the App Runner connection that this request just deleted.
        public let connection: Connection?

        public init(connection: Connection? = nil) {
            self.connection = connection
        }

        private enum CodingKeys: String, CodingKey {
            case connection = "Connection"
        }
    }

    public struct DeleteServiceRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the App Runner service that you want to delete.
        public let serviceArn: String

        public init(serviceArn: String) {
            self.serviceArn = serviceArn
        }

        public func validate(name: String) throws {
            try self.validate(self.serviceArn, name: "serviceArn", parent: name, max: 1011)
            try self.validate(self.serviceArn, name: "serviceArn", parent: name, min: 1)
            try self.validate(self.serviceArn, name: "serviceArn", parent: name, pattern: "arn:aws(-[\\w]+)*:[a-z0-9-\\\\.]{0,63}:[a-z0-9-\\\\.]{0,63}:[0-9]{12}:(\\w|\\/|-){1,1011}")
        }

        private enum CodingKeys: String, CodingKey {
            case serviceArn = "ServiceArn"
        }
    }

    public struct DeleteServiceResponse: AWSDecodableShape {
        /// The unique ID of the asynchronous operation that this request started. You can use it combined with the ListOperations call to track the operation's progress.
        public let operationId: String
        /// A description of the App Runner service that this request just deleted.
        public let service: Service

        public init(operationId: String, service: Service) {
            self.operationId = operationId
            self.service = service
        }

        private enum CodingKeys: String, CodingKey {
            case operationId = "OperationId"
            case service = "Service"
        }
    }

    public struct DescribeAutoScalingConfigurationRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the App Runner auto scaling configuration that you want a description for. The ARN can be a full auto scaling configuration ARN, or a partial ARN ending with either .../name  or .../name/revision . If a revision isn't specified, the latest active revision is described.
        public let autoScalingConfigurationArn: String

        public init(autoScalingConfigurationArn: String) {
            self.autoScalingConfigurationArn = autoScalingConfigurationArn
        }

        public func validate(name: String) throws {
            try self.validate(self.autoScalingConfigurationArn, name: "autoScalingConfigurationArn", parent: name, max: 1011)
            try self.validate(self.autoScalingConfigurationArn, name: "autoScalingConfigurationArn", parent: name, min: 1)
            try self.validate(self.autoScalingConfigurationArn, name: "autoScalingConfigurationArn", parent: name, pattern: "arn:aws(-[\\w]+)*:[a-z0-9-\\\\.]{0,63}:[a-z0-9-\\\\.]{0,63}:[0-9]{12}:(\\w|\\/|-){1,1011}")
        }

        private enum CodingKeys: String, CodingKey {
            case autoScalingConfigurationArn = "AutoScalingConfigurationArn"
        }
    }

    public struct DescribeAutoScalingConfigurationResponse: AWSDecodableShape {
        /// A full description of the App Runner auto scaling configuration that you specified in this request.
        public let autoScalingConfiguration: AutoScalingConfiguration

        public init(autoScalingConfiguration: AutoScalingConfiguration) {
            self.autoScalingConfiguration = autoScalingConfiguration
        }

        private enum CodingKeys: String, CodingKey {
            case autoScalingConfiguration = "AutoScalingConfiguration"
        }
    }

    public struct DescribeCustomDomainsRequest: AWSEncodableShape {
        /// The maximum number of results that each response (result page) can include. It's used for a paginated request. If you don't specify MaxResults, the request retrieves all available results in a single response.
        public let maxResults: Int?
        /// A token from a previous result page. It's used for a paginated request. The request retrieves the next result page. All other parameter values must be identical to the ones that are specified in the initial request. If you don't specify NextToken, the request retrieves the first result page.
        public let nextToken: String?
        /// The Amazon Resource Name (ARN) of the App Runner service that you want associated custom domain names to be described for.
        public let serviceArn: String

        public init(maxResults: Int? = nil, nextToken: String? = nil, serviceArn: String) {
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.serviceArn = serviceArn
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 5)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 51200)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 0)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: ".*")
            try self.validate(self.serviceArn, name: "serviceArn", parent: name, max: 1011)
            try self.validate(self.serviceArn, name: "serviceArn", parent: name, min: 1)
            try self.validate(self.serviceArn, name: "serviceArn", parent: name, pattern: "arn:aws(-[\\w]+)*:[a-z0-9-\\\\.]{0,63}:[a-z0-9-\\\\.]{0,63}:[0-9]{12}:(\\w|\\/|-){1,1011}")
        }

        private enum CodingKeys: String, CodingKey {
            case maxResults = "MaxResults"
            case nextToken = "NextToken"
            case serviceArn = "ServiceArn"
        }
    }

    public struct DescribeCustomDomainsResponse: AWSDecodableShape {
        /// A list of descriptions of custom domain names that are associated with the service. In a paginated request, the request returns up to MaxResults records per call.
        public let customDomains: [CustomDomain]
        /// The App Runner subdomain of the App Runner service. The associated custom domain names are mapped to this target name.
        public let dNSTarget: String
        /// The token that you can pass in a subsequent request to get the next result page. It's returned in a paginated request.
        public let nextToken: String?
        /// The Amazon Resource Name (ARN) of the App Runner service whose associated custom domain names you want to describe.
        public let serviceArn: String

        public init(customDomains: [CustomDomain], dNSTarget: String, nextToken: String? = nil, serviceArn: String) {
            self.customDomains = customDomains
            self.dNSTarget = dNSTarget
            self.nextToken = nextToken
            self.serviceArn = serviceArn
        }

        private enum CodingKeys: String, CodingKey {
            case customDomains = "CustomDomains"
            case dNSTarget = "DNSTarget"
            case nextToken = "NextToken"
            case serviceArn = "ServiceArn"
        }
    }

    public struct DescribeServiceRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the App Runner service that you want a description for.
        public let serviceArn: String

        public init(serviceArn: String) {
            self.serviceArn = serviceArn
        }

        public func validate(name: String) throws {
            try self.validate(self.serviceArn, name: "serviceArn", parent: name, max: 1011)
            try self.validate(self.serviceArn, name: "serviceArn", parent: name, min: 1)
            try self.validate(self.serviceArn, name: "serviceArn", parent: name, pattern: "arn:aws(-[\\w]+)*:[a-z0-9-\\\\.]{0,63}:[a-z0-9-\\\\.]{0,63}:[0-9]{12}:(\\w|\\/|-){1,1011}")
        }

        private enum CodingKeys: String, CodingKey {
            case serviceArn = "ServiceArn"
        }
    }

    public struct DescribeServiceResponse: AWSDecodableShape {
        /// A full description of the App Runner service that you specified in this request.
        public let service: Service

        public init(service: Service) {
            self.service = service
        }

        private enum CodingKeys: String, CodingKey {
            case service = "Service"
        }
    }

    public struct DisassociateCustomDomainRequest: AWSEncodableShape {
        /// The domain name that you want to disassociate from the App Runner service.
        public let domainName: String
        /// The Amazon Resource Name (ARN) of the App Runner service that you want to disassociate a custom domain name from.
        public let serviceArn: String

        public init(domainName: String, serviceArn: String) {
            self.domainName = domainName
            self.serviceArn = serviceArn
        }

        public func validate(name: String) throws {
            try self.validate(self.domainName, name: "domainName", parent: name, max: 255)
            try self.validate(self.domainName, name: "domainName", parent: name, min: 1)
            try self.validate(self.serviceArn, name: "serviceArn", parent: name, max: 1011)
            try self.validate(self.serviceArn, name: "serviceArn", parent: name, min: 1)
            try self.validate(self.serviceArn, name: "serviceArn", parent: name, pattern: "arn:aws(-[\\w]+)*:[a-z0-9-\\\\.]{0,63}:[a-z0-9-\\\\.]{0,63}:[0-9]{12}:(\\w|\\/|-){1,1011}")
        }

        private enum CodingKeys: String, CodingKey {
            case domainName = "DomainName"
            case serviceArn = "ServiceArn"
        }
    }

    public struct DisassociateCustomDomainResponse: AWSDecodableShape {
        /// A description of the domain name that's being disassociated.
        public let customDomain: CustomDomain
        /// The App Runner subdomain of the App Runner service. The disassociated custom domain name was mapped to this target name.
        public let dNSTarget: String
        /// The Amazon Resource Name (ARN) of the App Runner service that a custom domain name is disassociated from.
        public let serviceArn: String

        public init(customDomain: CustomDomain, dNSTarget: String, serviceArn: String) {
            self.customDomain = customDomain
            self.dNSTarget = dNSTarget
            self.serviceArn = serviceArn
        }

        private enum CodingKeys: String, CodingKey {
            case customDomain = "CustomDomain"
            case dNSTarget = "DNSTarget"
            case serviceArn = "ServiceArn"
        }
    }

    public struct EncryptionConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The ARN of the KMS key that's used for encryption.
        public let kmsKey: String

        public init(kmsKey: String) {
            self.kmsKey = kmsKey
        }

        public func validate(name: String) throws {
            try self.validate(self.kmsKey, name: "kmsKey", parent: name, max: 256)
            try self.validate(self.kmsKey, name: "kmsKey", parent: name, min: 0)
            try self.validate(self.kmsKey, name: "kmsKey", parent: name, pattern: "arn:aws(-[\\w]+)*:kms:[a-z\\-]+-[0-9]{1}:[0-9]{12}:key\\/[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}")
        }

        private enum CodingKeys: String, CodingKey {
            case kmsKey = "KmsKey"
        }
    }

    public struct HealthCheckConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The number of consecutive checks that must succeed before App Runner decides that the service is healthy. Default: 3
        public let healthyThreshold: Int?
        /// The time interval, in seconds, between health checks. Default: 5
        public let interval: Int?
        /// The URL that health check requests are sent to.  Path is only applicable when you set Protocol to HTTP. Default: "/"
        public let path: String?
        /// The IP protocol that App Runner uses to perform health checks for your service. If you set Protocol to HTTP, App Runner sends health check requests to the HTTP path specified by Path. Default: TCP
        public let `protocol`: HealthCheckProtocol?
        /// The time, in seconds, to wait for a health check response before deciding it failed. Default: 2
        public let timeout: Int?
        /// The number of consecutive checks that must fail before App Runner decides that the service is unhealthy. Default: 3
        public let unhealthyThreshold: Int?

        public init(healthyThreshold: Int? = nil, interval: Int? = nil, path: String? = nil, protocol: HealthCheckProtocol? = nil, timeout: Int? = nil, unhealthyThreshold: Int? = nil) {
            self.healthyThreshold = healthyThreshold
            self.interval = interval
            self.path = path
            self.`protocol` = `protocol`
            self.timeout = timeout
            self.unhealthyThreshold = unhealthyThreshold
        }

        public func validate(name: String) throws {
            try self.validate(self.healthyThreshold, name: "healthyThreshold", parent: name, max: 20)
            try self.validate(self.healthyThreshold, name: "healthyThreshold", parent: name, min: 1)
            try self.validate(self.interval, name: "interval", parent: name, max: 20)
            try self.validate(self.interval, name: "interval", parent: name, min: 1)
            try self.validate(self.path, name: "path", parent: name, max: 51200)
            try self.validate(self.path, name: "path", parent: name, min: 0)
            try self.validate(self.path, name: "path", parent: name, pattern: ".*")
            try self.validate(self.timeout, name: "timeout", parent: name, max: 20)
            try self.validate(self.timeout, name: "timeout", parent: name, min: 1)
            try self.validate(self.unhealthyThreshold, name: "unhealthyThreshold", parent: name, max: 20)
            try self.validate(self.unhealthyThreshold, name: "unhealthyThreshold", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case healthyThreshold = "HealthyThreshold"
            case interval = "Interval"
            case path = "Path"
            case `protocol` = "Protocol"
            case timeout = "Timeout"
            case unhealthyThreshold = "UnhealthyThreshold"
        }
    }

    public struct ImageConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The port that your application listens to in the container. Default: 8080
        public let port: String?
        /// Environment variables that are available to your running App Runner service. An array of key-value pairs. Keys with a prefix of AWSAPPRUNNER are reserved for system use and aren't valid.
        public let runtimeEnvironmentVariables: [String: String]?
        /// An optional command that App Runner runs to start the application in the source image. If specified, this command overrides the Docker image’s default start command.
        public let startCommand: String?

        public init(port: String? = nil, runtimeEnvironmentVariables: [String: String]? = nil, startCommand: String? = nil) {
            self.port = port
            self.runtimeEnvironmentVariables = runtimeEnvironmentVariables
            self.startCommand = startCommand
        }

        public func validate(name: String) throws {
            try self.validate(self.port, name: "port", parent: name, max: 51200)
            try self.validate(self.port, name: "port", parent: name, min: 0)
            try self.validate(self.port, name: "port", parent: name, pattern: ".*")
            try self.validate(self.startCommand, name: "startCommand", parent: name, max: 51200)
            try self.validate(self.startCommand, name: "startCommand", parent: name, min: 0)
            try self.validate(self.startCommand, name: "startCommand", parent: name, pattern: ".*")
        }

        private enum CodingKeys: String, CodingKey {
            case port = "Port"
            case runtimeEnvironmentVariables = "RuntimeEnvironmentVariables"
            case startCommand = "StartCommand"
        }
    }

    public struct ImageRepository: AWSEncodableShape & AWSDecodableShape {
        /// Configuration for running the identified image.
        public let imageConfiguration: ImageConfiguration?
        /// The identifier of an image. For an image in Amazon Elastic Container Registry (Amazon ECR), this is an image name. For the image name format, see Pulling an image in the Amazon ECR User Guide.
        public let imageIdentifier: String
        /// The type of the image repository. This reflects the repository provider and whether the repository is private or public.
        public let imageRepositoryType: ImageRepositoryType

        public init(imageConfiguration: ImageConfiguration? = nil, imageIdentifier: String, imageRepositoryType: ImageRepositoryType) {
            self.imageConfiguration = imageConfiguration
            self.imageIdentifier = imageIdentifier
            self.imageRepositoryType = imageRepositoryType
        }

        public func validate(name: String) throws {
            try self.imageConfiguration?.validate(name: "\(name).imageConfiguration")
            try self.validate(self.imageIdentifier, name: "imageIdentifier", parent: name, max: 1024)
            try self.validate(self.imageIdentifier, name: "imageIdentifier", parent: name, min: 1)
            try self.validate(self.imageIdentifier, name: "imageIdentifier", parent: name, pattern: "([0-9]{12}.dkr.ecr.[a-z\\-]+-[0-9]{1}.amazonaws.com\\/.*)|(^public\\.ecr\\.aws\\/.+\\/.+)")
        }

        private enum CodingKeys: String, CodingKey {
            case imageConfiguration = "ImageConfiguration"
            case imageIdentifier = "ImageIdentifier"
            case imageRepositoryType = "ImageRepositoryType"
        }
    }

    public struct InstanceConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The number of CPU units reserved for each instance of your App Runner service. Default: 1 vCPU
        public let cpu: String?
        /// The Amazon Resource Name (ARN) of an IAM role that provides permissions to your App Runner service. These are permissions that your code needs when it calls any AWS APIs.
        public let instanceRoleArn: String?
        /// The amount of memory, in MB or GB, reserved for each instance of your App Runner service. Default: 2 GB
        public let memory: String?

        public init(cpu: String? = nil, instanceRoleArn: String? = nil, memory: String? = nil) {
            self.cpu = cpu
            self.instanceRoleArn = instanceRoleArn
            self.memory = memory
        }

        public func validate(name: String) throws {
            try self.validate(self.cpu, name: "cpu", parent: name, max: 6)
            try self.validate(self.cpu, name: "cpu", parent: name, min: 4)
            try self.validate(self.cpu, name: "cpu", parent: name, pattern: "1024|2048|(1|2) vCPU")
            try self.validate(self.instanceRoleArn, name: "instanceRoleArn", parent: name, max: 102)
            try self.validate(self.instanceRoleArn, name: "instanceRoleArn", parent: name, min: 29)
            try self.validate(self.instanceRoleArn, name: "instanceRoleArn", parent: name, pattern: "arn:(aws|aws-us-gov|aws-cn|aws-iso|aws-iso-b):iam::[0-9]{12}:role/[\\w+=,.@-]{1,64}")
            try self.validate(self.memory, name: "memory", parent: name, max: 4)
            try self.validate(self.memory, name: "memory", parent: name, min: 4)
            try self.validate(self.memory, name: "memory", parent: name, pattern: "2048|3072|4096|(2|3|4) GB")
        }

        private enum CodingKeys: String, CodingKey {
            case cpu = "Cpu"
            case instanceRoleArn = "InstanceRoleArn"
            case memory = "Memory"
        }
    }

    public struct ListAutoScalingConfigurationsRequest: AWSEncodableShape {
        /// The name of the App Runner auto scaling configuration that you want to list. If specified, App Runner lists revisions that share this name. If not specified, App Runner returns revisions of all configurations.
        public let autoScalingConfigurationName: String?
        /// Set to true to list only the latest revision for each requested configuration name. Keep as false to list all revisions for each requested configuration name. Default: false
        public let latestOnly: Bool?
        /// The maximum number of results to include in each response (result page). It's used for a paginated request. If you don't specify MaxResults, the request retrieves all available results in a single response.
        public let maxResults: Int?
        /// A token from a previous result page. It's used for a paginated request. The request retrieves the next result page. All other parameter values must be identical to the ones that are specified in the initial request. If you don't specify NextToken, the request retrieves the first result page.
        public let nextToken: String?

        public init(autoScalingConfigurationName: String? = nil, latestOnly: Bool? = nil, maxResults: Int? = nil, nextToken: String? = nil) {
            self.autoScalingConfigurationName = autoScalingConfigurationName
            self.latestOnly = latestOnly
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.validate(self.autoScalingConfigurationName, name: "autoScalingConfigurationName", parent: name, max: 32)
            try self.validate(self.autoScalingConfigurationName, name: "autoScalingConfigurationName", parent: name, min: 4)
            try self.validate(self.autoScalingConfigurationName, name: "autoScalingConfigurationName", parent: name, pattern: "[A-Za-z0-9][A-Za-z0-9\\-_]{3,31}")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 1024)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: ".*")
        }

        private enum CodingKeys: String, CodingKey {
            case autoScalingConfigurationName = "AutoScalingConfigurationName"
            case latestOnly = "LatestOnly"
            case maxResults = "MaxResults"
            case nextToken = "NextToken"
        }
    }

    public struct ListAutoScalingConfigurationsResponse: AWSDecodableShape {
        /// A list of summary information records for auto scaling configurations. In a paginated request, the request returns up to MaxResults records for each call.
        public let autoScalingConfigurationSummaryList: [AutoScalingConfigurationSummary]
        /// The token that you can pass in a subsequent request to get the next result page. It's returned in a paginated request.
        public let nextToken: String?

        public init(autoScalingConfigurationSummaryList: [AutoScalingConfigurationSummary], nextToken: String? = nil) {
            self.autoScalingConfigurationSummaryList = autoScalingConfigurationSummaryList
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case autoScalingConfigurationSummaryList = "AutoScalingConfigurationSummaryList"
            case nextToken = "NextToken"
        }
    }

    public struct ListConnectionsRequest: AWSEncodableShape {
        /// If specified, only this connection is returned. If not specified, the result isn't filtered by name.
        public let connectionName: String?
        /// The maximum number of results to include in each response (result page). Used for a paginated request. If you don't specify MaxResults, the request retrieves all available results in a single response.
        public let maxResults: Int?
        /// A token from a previous result page. Used for a paginated request. The request retrieves the next result page. All other parameter values must be identical to the ones specified in the initial request. If you don't specify NextToken, the request retrieves the first result page.
        public let nextToken: String?

        public init(connectionName: String? = nil, maxResults: Int? = nil, nextToken: String? = nil) {
            self.connectionName = connectionName
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.validate(self.connectionName, name: "connectionName", parent: name, max: 32)
            try self.validate(self.connectionName, name: "connectionName", parent: name, min: 4)
            try self.validate(self.connectionName, name: "connectionName", parent: name, pattern: "[A-Za-z0-9][A-Za-z0-9\\-_]{3,31}")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 1024)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: ".*")
        }

        private enum CodingKeys: String, CodingKey {
            case connectionName = "ConnectionName"
            case maxResults = "MaxResults"
            case nextToken = "NextToken"
        }
    }

    public struct ListConnectionsResponse: AWSDecodableShape {
        /// A list of summary information records for connections. In a paginated request, the request returns up to MaxResults records for each call.
        public let connectionSummaryList: [ConnectionSummary]
        /// The token that you can pass in a subsequent request to get the next result page. Returned in a paginated request.
        public let nextToken: String?

        public init(connectionSummaryList: [ConnectionSummary], nextToken: String? = nil) {
            self.connectionSummaryList = connectionSummaryList
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case connectionSummaryList = "ConnectionSummaryList"
            case nextToken = "NextToken"
        }
    }

    public struct ListOperationsRequest: AWSEncodableShape {
        /// The maximum number of results to include in each response (result page). It's used for a paginated request. If you don't specify MaxResults, the request retrieves all available results in a single response.
        public let maxResults: Int?
        /// A token from a previous result page. It's used for a paginated request. The request retrieves the next result page. All other parameter values must be identical to the ones specified in the initial request. If you don't specify NextToken, the request retrieves the first result page.
        public let nextToken: String?
        /// The Amazon Resource Name (ARN) of the App Runner service that you want a list of operations for.
        public let serviceArn: String

        public init(maxResults: Int? = nil, nextToken: String? = nil, serviceArn: String) {
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.serviceArn = serviceArn
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 20)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 51200)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 0)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: ".*")
            try self.validate(self.serviceArn, name: "serviceArn", parent: name, max: 1011)
            try self.validate(self.serviceArn, name: "serviceArn", parent: name, min: 1)
            try self.validate(self.serviceArn, name: "serviceArn", parent: name, pattern: "arn:aws(-[\\w]+)*:[a-z0-9-\\\\.]{0,63}:[a-z0-9-\\\\.]{0,63}:[0-9]{12}:(\\w|\\/|-){1,1011}")
        }

        private enum CodingKeys: String, CodingKey {
            case maxResults = "MaxResults"
            case nextToken = "NextToken"
            case serviceArn = "ServiceArn"
        }
    }

    public struct ListOperationsResponse: AWSDecodableShape {
        /// The token that you can pass in a subsequent request to get the next result page. It's returned in a paginated request.
        public let nextToken: String?
        /// A list of operation summary information records. In a paginated request, the request returns up to MaxResults records for each call.
        public let operationSummaryList: [OperationSummary]?

        public init(nextToken: String? = nil, operationSummaryList: [OperationSummary]? = nil) {
            self.nextToken = nextToken
            self.operationSummaryList = operationSummaryList
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "NextToken"
            case operationSummaryList = "OperationSummaryList"
        }
    }

    public struct ListServicesRequest: AWSEncodableShape {
        /// The maximum number of results to include in each response (result page). It's used for a paginated request. If you don't specify MaxResults, the request retrieves all available results in a single response.
        public let maxResults: Int?
        /// A token from a previous result page. Used for a paginated request. The request retrieves the next result page. All other parameter values must be identical to the ones specified in the initial request. If you don't specify NextToken, the request retrieves the first result page.
        public let nextToken: String?

        public init(maxResults: Int? = nil, nextToken: String? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 20)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 51200)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 0)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: ".*")
        }

        private enum CodingKeys: String, CodingKey {
            case maxResults = "MaxResults"
            case nextToken = "NextToken"
        }
    }

    public struct ListServicesResponse: AWSDecodableShape {
        /// The token that you can pass in a subsequent request to get the next result page. It's returned in a paginated request.
        public let nextToken: String?
        /// A list of service summary information records. In a paginated request, the request returns up to MaxResults records for each call.
        public let serviceSummaryList: [ServiceSummary]

        public init(nextToken: String? = nil, serviceSummaryList: [ServiceSummary]) {
            self.nextToken = nextToken
            self.serviceSummaryList = serviceSummaryList
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "NextToken"
            case serviceSummaryList = "ServiceSummaryList"
        }
    }

    public struct ListTagsForResourceRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the resource that a tag list is requested for. It must be the ARN of an App Runner resource.
        public let resourceArn: String

        public init(resourceArn: String) {
            self.resourceArn = resourceArn
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, max: 1011)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, min: 1)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, pattern: "arn:aws(-[\\w]+)*:[a-z0-9-\\\\.]{0,63}:[a-z0-9-\\\\.]{0,63}:[0-9]{12}:(\\w|\\/|-){1,1011}")
        }

        private enum CodingKeys: String, CodingKey {
            case resourceArn = "ResourceArn"
        }
    }

    public struct ListTagsForResourceResponse: AWSDecodableShape {
        /// A list of the tag key-value pairs that are associated with the resource.
        public let tags: [Tag]?

        public init(tags: [Tag]? = nil) {
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case tags = "Tags"
        }
    }

    public struct OperationSummary: AWSDecodableShape {
        /// The time when the operation ended. It's in the Unix time stamp format.
        public let endedAt: Date?
        /// A unique ID of this operation. It's unique in the scope of the App Runner service.
        public let id: String?
        /// The time when the operation started. It's in the Unix time stamp format.
        public let startedAt: Date?
        /// The current state of the operation.
        public let status: OperationStatus?
        /// The Amazon Resource Name (ARN) of the resource that the operation acted on (for example, an App Runner service).
        public let targetArn: String?
        /// The type of operation. It indicates a specific action that occured.
        public let type: OperationType?
        /// The time when the operation was last updated. It's in the Unix time stamp format.
        public let updatedAt: Date?

        public init(endedAt: Date? = nil, id: String? = nil, startedAt: Date? = nil, status: OperationStatus? = nil, targetArn: String? = nil, type: OperationType? = nil, updatedAt: Date? = nil) {
            self.endedAt = endedAt
            self.id = id
            self.startedAt = startedAt
            self.status = status
            self.targetArn = targetArn
            self.type = type
            self.updatedAt = updatedAt
        }

        private enum CodingKeys: String, CodingKey {
            case endedAt = "EndedAt"
            case id = "Id"
            case startedAt = "StartedAt"
            case status = "Status"
            case targetArn = "TargetArn"
            case type = "Type"
            case updatedAt = "UpdatedAt"
        }
    }

    public struct PauseServiceRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the App Runner service that you want to pause.
        public let serviceArn: String

        public init(serviceArn: String) {
            self.serviceArn = serviceArn
        }

        public func validate(name: String) throws {
            try self.validate(self.serviceArn, name: "serviceArn", parent: name, max: 1011)
            try self.validate(self.serviceArn, name: "serviceArn", parent: name, min: 1)
            try self.validate(self.serviceArn, name: "serviceArn", parent: name, pattern: "arn:aws(-[\\w]+)*:[a-z0-9-\\\\.]{0,63}:[a-z0-9-\\\\.]{0,63}:[0-9]{12}:(\\w|\\/|-){1,1011}")
        }

        private enum CodingKeys: String, CodingKey {
            case serviceArn = "ServiceArn"
        }
    }

    public struct PauseServiceResponse: AWSDecodableShape {
        /// The unique ID of the asynchronous operation that this request started. You can use it combined with the ListOperations call to track the operation's progress.
        public let operationId: String?
        /// A description of the App Runner service that this request just paused.
        public let service: Service

        public init(operationId: String? = nil, service: Service) {
            self.operationId = operationId
            self.service = service
        }

        private enum CodingKeys: String, CodingKey {
            case operationId = "OperationId"
            case service = "Service"
        }
    }

    public struct ResumeServiceRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the App Runner service that you want to resume.
        public let serviceArn: String

        public init(serviceArn: String) {
            self.serviceArn = serviceArn
        }

        public func validate(name: String) throws {
            try self.validate(self.serviceArn, name: "serviceArn", parent: name, max: 1011)
            try self.validate(self.serviceArn, name: "serviceArn", parent: name, min: 1)
            try self.validate(self.serviceArn, name: "serviceArn", parent: name, pattern: "arn:aws(-[\\w]+)*:[a-z0-9-\\\\.]{0,63}:[a-z0-9-\\\\.]{0,63}:[0-9]{12}:(\\w|\\/|-){1,1011}")
        }

        private enum CodingKeys: String, CodingKey {
            case serviceArn = "ServiceArn"
        }
    }

    public struct ResumeServiceResponse: AWSDecodableShape {
        /// The unique ID of the asynchronous operation that this request started. You can use it combined with the ListOperations call to track the operation's progress.
        public let operationId: String?
        /// A description of the App Runner service that this request just resumed.
        public let service: Service

        public init(operationId: String? = nil, service: Service) {
            self.operationId = operationId
            self.service = service
        }

        private enum CodingKeys: String, CodingKey {
            case operationId = "OperationId"
            case service = "Service"
        }
    }

    public struct Service: AWSDecodableShape {
        /// Summary information for the App Runner automatic scaling configuration resource that's associated with this service.
        public let autoScalingConfigurationSummary: AutoScalingConfigurationSummary
        /// The time when the App Runner service was created. It's in the Unix time stamp format.
        public let createdAt: Date
        /// The time when the App Runner service was deleted. It's in the Unix time stamp format.
        public let deletedAt: Date?
        /// The encryption key that App Runner uses to encrypt the service logs and the copy of the source repository that App Runner maintains for the service. It can be either a customer-provided encryption key or an AWS managed CMK.
        public let encryptionConfiguration: EncryptionConfiguration?
        /// The settings for the health check that App Runner performs to monitor the health of this service.
        public let healthCheckConfiguration: HealthCheckConfiguration?
        /// The runtime configuration of instances (scaling units) of this service.
        public let instanceConfiguration: InstanceConfiguration
        /// The Amazon Resource Name (ARN) of this service.
        public let serviceArn: String
        /// An ID that App Runner generated for this service. It's unique within the AWS Region.
        public let serviceId: String
        /// The customer-provided service name.
        public let serviceName: String
        /// A subdomain URL that App Runner generated for this service. You can use this URL to access your service web application.
        public let serviceUrl: String
        /// The source deployed to the App Runner service. It can be a code or an image repository.
        public let sourceConfiguration: SourceConfiguration
        /// The current state of the App Runner service. These particular values mean the following.    CREATE_FAILED – The service failed to create. To troubleshoot this failure, read the failure events and logs, change any parameters that need to be fixed, and retry the call to create the service. The failed service isn't usable, and still counts towards your service quota. When you're done analyzing the failure, delete the service.    DELETE_FAILED – The service failed to delete and can't be successfully recovered. Retry the service deletion call to ensure that all related resources are removed.
        public let status: ServiceStatus
        /// The time when the App Runner service was last updated at. It's in the Unix time stamp format.
        public let updatedAt: Date

        public init(autoScalingConfigurationSummary: AutoScalingConfigurationSummary, createdAt: Date, deletedAt: Date? = nil, encryptionConfiguration: EncryptionConfiguration? = nil, healthCheckConfiguration: HealthCheckConfiguration? = nil, instanceConfiguration: InstanceConfiguration, serviceArn: String, serviceId: String, serviceName: String, serviceUrl: String, sourceConfiguration: SourceConfiguration, status: ServiceStatus, updatedAt: Date) {
            self.autoScalingConfigurationSummary = autoScalingConfigurationSummary
            self.createdAt = createdAt
            self.deletedAt = deletedAt
            self.encryptionConfiguration = encryptionConfiguration
            self.healthCheckConfiguration = healthCheckConfiguration
            self.instanceConfiguration = instanceConfiguration
            self.serviceArn = serviceArn
            self.serviceId = serviceId
            self.serviceName = serviceName
            self.serviceUrl = serviceUrl
            self.sourceConfiguration = sourceConfiguration
            self.status = status
            self.updatedAt = updatedAt
        }

        private enum CodingKeys: String, CodingKey {
            case autoScalingConfigurationSummary = "AutoScalingConfigurationSummary"
            case createdAt = "CreatedAt"
            case deletedAt = "DeletedAt"
            case encryptionConfiguration = "EncryptionConfiguration"
            case healthCheckConfiguration = "HealthCheckConfiguration"
            case instanceConfiguration = "InstanceConfiguration"
            case serviceArn = "ServiceArn"
            case serviceId = "ServiceId"
            case serviceName = "ServiceName"
            case serviceUrl = "ServiceUrl"
            case sourceConfiguration = "SourceConfiguration"
            case status = "Status"
            case updatedAt = "UpdatedAt"
        }
    }

    public struct ServiceSummary: AWSDecodableShape {
        /// The time when the App Runner service was created. It's in the Unix time stamp format.
        public let createdAt: Date?
        /// The Amazon Resource Name (ARN) of this service.
        public let serviceArn: String?
        /// An ID that App Runner generated for this service. It's unique within the AWS Region.
        public let serviceId: String?
        /// The customer-provided service name.
        public let serviceName: String?
        /// A subdomain URL that App Runner generated for this service. You can use this URL to access your service web application.
        public let serviceUrl: String?
        /// The current state of the App Runner service. These particular values mean the following.    CREATE_FAILED – The service failed to create. Read the failure events and logs, change any parameters that need to be fixed, and retry the call to create the service. The failed service isn't usable, and still counts towards your service quota. When you're done analyzing the failure, delete the service.    DELETE_FAILED – The service failed to delete and can't be successfully recovered. Retry the service deletion call to ensure that all related resources are removed.
        public let status: ServiceStatus?
        /// The time when the App Runner service was last updated. It's in theUnix time stamp format.
        public let updatedAt: Date?

        public init(createdAt: Date? = nil, serviceArn: String? = nil, serviceId: String? = nil, serviceName: String? = nil, serviceUrl: String? = nil, status: ServiceStatus? = nil, updatedAt: Date? = nil) {
            self.createdAt = createdAt
            self.serviceArn = serviceArn
            self.serviceId = serviceId
            self.serviceName = serviceName
            self.serviceUrl = serviceUrl
            self.status = status
            self.updatedAt = updatedAt
        }

        private enum CodingKeys: String, CodingKey {
            case createdAt = "CreatedAt"
            case serviceArn = "ServiceArn"
            case serviceId = "ServiceId"
            case serviceName = "ServiceName"
            case serviceUrl = "ServiceUrl"
            case status = "Status"
            case updatedAt = "UpdatedAt"
        }
    }

    public struct SourceCodeVersion: AWSEncodableShape & AWSDecodableShape {
        /// The type of version identifier. For a git-based repository, branches represent versions.
        public let type: SourceCodeVersionType
        /// A source code version. For a git-based repository, a branch name maps to a specific version. App Runner uses the most recent commit to the branch.
        public let value: String

        public init(type: SourceCodeVersionType, value: String) {
            self.type = type
            self.value = value
        }

        public func validate(name: String) throws {
            try self.validate(self.value, name: "value", parent: name, max: 51200)
            try self.validate(self.value, name: "value", parent: name, min: 0)
            try self.validate(self.value, name: "value", parent: name, pattern: ".*")
        }

        private enum CodingKeys: String, CodingKey {
            case type = "Type"
            case value = "Value"
        }
    }

    public struct SourceConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// Describes the resources that are needed to authenticate access to some source repositories.
        public let authenticationConfiguration: AuthenticationConfiguration?
        /// If true, continuous integration from the source repository is enabled for the App Runner service. Each repository change (source code commit or new image version) starts a deployment. Default: true
        public let autoDeploymentsEnabled: Bool?
        /// The description of a source code repository. You must provide either this member or ImageRepository (but not both).
        public let codeRepository: CodeRepository?
        /// The description of a source image repository. You must provide either this member or CodeRepository (but not both).
        public let imageRepository: ImageRepository?

        public init(authenticationConfiguration: AuthenticationConfiguration? = nil, autoDeploymentsEnabled: Bool? = nil, codeRepository: CodeRepository? = nil, imageRepository: ImageRepository? = nil) {
            self.authenticationConfiguration = authenticationConfiguration
            self.autoDeploymentsEnabled = autoDeploymentsEnabled
            self.codeRepository = codeRepository
            self.imageRepository = imageRepository
        }

        public func validate(name: String) throws {
            try self.authenticationConfiguration?.validate(name: "\(name).authenticationConfiguration")
            try self.codeRepository?.validate(name: "\(name).codeRepository")
            try self.imageRepository?.validate(name: "\(name).imageRepository")
        }

        private enum CodingKeys: String, CodingKey {
            case authenticationConfiguration = "AuthenticationConfiguration"
            case autoDeploymentsEnabled = "AutoDeploymentsEnabled"
            case codeRepository = "CodeRepository"
            case imageRepository = "ImageRepository"
        }
    }

    public struct StartDeploymentRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the App Runner service that you want to manually deploy to.
        public let serviceArn: String

        public init(serviceArn: String) {
            self.serviceArn = serviceArn
        }

        public func validate(name: String) throws {
            try self.validate(self.serviceArn, name: "serviceArn", parent: name, max: 1011)
            try self.validate(self.serviceArn, name: "serviceArn", parent: name, min: 1)
            try self.validate(self.serviceArn, name: "serviceArn", parent: name, pattern: "arn:aws(-[\\w]+)*:[a-z0-9-\\\\.]{0,63}:[a-z0-9-\\\\.]{0,63}:[0-9]{12}:(\\w|\\/|-){1,1011}")
        }

        private enum CodingKeys: String, CodingKey {
            case serviceArn = "ServiceArn"
        }
    }

    public struct StartDeploymentResponse: AWSDecodableShape {
        /// The unique ID of the asynchronous operation that this request started. You can use it combined with the ListOperations call to track the operation's progress.
        public let operationId: String

        public init(operationId: String) {
            self.operationId = operationId
        }

        private enum CodingKeys: String, CodingKey {
            case operationId = "OperationId"
        }
    }

    public struct Tag: AWSEncodableShape & AWSDecodableShape {
        /// The key of the tag.
        public let key: String?
        /// The value of the tag.
        public let value: String?

        public init(key: String? = nil, value: String? = nil) {
            self.key = key
            self.value = value
        }

        public func validate(name: String) throws {
            try self.validate(self.key, name: "key", parent: name, max: 128)
            try self.validate(self.key, name: "key", parent: name, min: 1)
            try self.validate(self.key, name: "key", parent: name, pattern: "^(?!aws:).+")
            try self.validate(self.value, name: "value", parent: name, max: 256)
            try self.validate(self.value, name: "value", parent: name, min: 0)
            try self.validate(self.value, name: "value", parent: name, pattern: ".*")
        }

        private enum CodingKeys: String, CodingKey {
            case key = "Key"
            case value = "Value"
        }
    }

    public struct TagResourceRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the resource that you want to update tags for. It must be the ARN of an App Runner resource.
        public let resourceArn: String
        /// A list of tag key-value pairs to add or update. If a key is new to the resource, the tag is added with the provided value. If a key is already associated with the resource, the value of the tag is updated.
        public let tags: [Tag]

        public init(resourceArn: String, tags: [Tag]) {
            self.resourceArn = resourceArn
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, max: 1011)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, min: 1)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, pattern: "arn:aws(-[\\w]+)*:[a-z0-9-\\\\.]{0,63}:[a-z0-9-\\\\.]{0,63}:[0-9]{12}:(\\w|\\/|-){1,1011}")
            try self.tags.forEach {
                try $0.validate(name: "\(name).tags[]")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case resourceArn = "ResourceArn"
            case tags = "Tags"
        }
    }

    public struct TagResourceResponse: AWSDecodableShape {
        public init() {}
    }

    public struct UntagResourceRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the resource that you want to remove tags from. It must be the ARN of an App Runner resource.
        public let resourceArn: String
        /// A list of tag keys that you want to remove.
        public let tagKeys: [String]

        public init(resourceArn: String, tagKeys: [String]) {
            self.resourceArn = resourceArn
            self.tagKeys = tagKeys
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, max: 1011)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, min: 1)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, pattern: "arn:aws(-[\\w]+)*:[a-z0-9-\\\\.]{0,63}:[a-z0-9-\\\\.]{0,63}:[0-9]{12}:(\\w|\\/|-){1,1011}")
            try self.tagKeys.forEach {
                try validate($0, name: "tagKeys[]", parent: name, max: 128)
                try validate($0, name: "tagKeys[]", parent: name, min: 1)
                try validate($0, name: "tagKeys[]", parent: name, pattern: "^(?!aws:).+")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case resourceArn = "ResourceArn"
            case tagKeys = "TagKeys"
        }
    }

    public struct UntagResourceResponse: AWSDecodableShape {
        public init() {}
    }

    public struct UpdateServiceRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of an App Runner automatic scaling configuration resource that you want to associate with your service.
        public let autoScalingConfigurationArn: String?
        /// The settings for the health check that AWS App Runner performs to monitor the health of your service.
        public let healthCheckConfiguration: HealthCheckConfiguration?
        /// The runtime configuration to apply to instances (scaling units) of the App Runner service.
        public let instanceConfiguration: InstanceConfiguration?
        /// The Amazon Resource Name (ARN) of the App Runner service that you want to update.
        public let serviceArn: String
        /// The source configuration to apply to the App Runner service. You can change the configuration of the code or image repository that the service uses. However, you can't switch from code to image or the other way around. This means that you must provide the same structure member of SourceConfiguration that you originally included when you created the service. Specifically, you can include either CodeRepository or ImageRepository. To update the source configuration, set the values to members of the structure that you include.
        public let sourceConfiguration: SourceConfiguration?

        public init(autoScalingConfigurationArn: String? = nil, healthCheckConfiguration: HealthCheckConfiguration? = nil, instanceConfiguration: InstanceConfiguration? = nil, serviceArn: String, sourceConfiguration: SourceConfiguration? = nil) {
            self.autoScalingConfigurationArn = autoScalingConfigurationArn
            self.healthCheckConfiguration = healthCheckConfiguration
            self.instanceConfiguration = instanceConfiguration
            self.serviceArn = serviceArn
            self.sourceConfiguration = sourceConfiguration
        }

        public func validate(name: String) throws {
            try self.validate(self.autoScalingConfigurationArn, name: "autoScalingConfigurationArn", parent: name, max: 1011)
            try self.validate(self.autoScalingConfigurationArn, name: "autoScalingConfigurationArn", parent: name, min: 1)
            try self.validate(self.autoScalingConfigurationArn, name: "autoScalingConfigurationArn", parent: name, pattern: "arn:aws(-[\\w]+)*:[a-z0-9-\\\\.]{0,63}:[a-z0-9-\\\\.]{0,63}:[0-9]{12}:(\\w|\\/|-){1,1011}")
            try self.healthCheckConfiguration?.validate(name: "\(name).healthCheckConfiguration")
            try self.instanceConfiguration?.validate(name: "\(name).instanceConfiguration")
            try self.validate(self.serviceArn, name: "serviceArn", parent: name, max: 1011)
            try self.validate(self.serviceArn, name: "serviceArn", parent: name, min: 1)
            try self.validate(self.serviceArn, name: "serviceArn", parent: name, pattern: "arn:aws(-[\\w]+)*:[a-z0-9-\\\\.]{0,63}:[a-z0-9-\\\\.]{0,63}:[0-9]{12}:(\\w|\\/|-){1,1011}")
            try self.sourceConfiguration?.validate(name: "\(name).sourceConfiguration")
        }

        private enum CodingKeys: String, CodingKey {
            case autoScalingConfigurationArn = "AutoScalingConfigurationArn"
            case healthCheckConfiguration = "HealthCheckConfiguration"
            case instanceConfiguration = "InstanceConfiguration"
            case serviceArn = "ServiceArn"
            case sourceConfiguration = "SourceConfiguration"
        }
    }

    public struct UpdateServiceResponse: AWSDecodableShape {
        /// The unique ID of the asynchronous operation that this request started. You can use it combined with the ListOperations call to track the operation's progress.
        public let operationId: String
        /// A description of the App Runner service updated by this request. All configuration values in the returned Service structure reflect configuration changes that are being applied by this request.
        public let service: Service

        public init(operationId: String, service: Service) {
            self.operationId = operationId
            self.service = service
        }

        private enum CodingKeys: String, CodingKey {
            case operationId = "OperationId"
            case service = "Service"
        }
    }
}
