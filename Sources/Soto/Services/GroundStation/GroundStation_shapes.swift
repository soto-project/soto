//===----------------------------------------------------------------------===//
//
// This source file is part of the Soto for AWS open source project
//
// Copyright (c) 2017-2022 the Soto project authors
// Licensed under Apache License v2.0
//
// See LICENSE.txt for license information
// See CONTRIBUTORS.txt for the list of Soto project authors
//
// SPDX-License-Identifier: Apache-2.0
//
//===----------------------------------------------------------------------===//

// THIS FILE IS AUTOMATICALLY GENERATED by https://github.com/soto-project/soto-codegenerator.
// DO NOT EDIT.

import Foundation
import SotoCore

extension GroundStation {
    // MARK: Enums

    public enum AngleUnits: String, CustomStringConvertible, Codable, _SotoSendable {
        case degreeAngle = "DEGREE_ANGLE"
        case radian = "RADIAN"
        public var description: String { return self.rawValue }
    }

    public enum BandwidthUnits: String, CustomStringConvertible, Codable, _SotoSendable {
        case gHz = "GHz"
        case mHz = "MHz"
        case kHz
        public var description: String { return self.rawValue }
    }

    public enum ConfigCapabilityType: String, CustomStringConvertible, Codable, _SotoSendable {
        case antennaDownlink = "antenna-downlink"
        case antennaDownlinkDemodDecode = "antenna-downlink-demod-decode"
        case antennaUplink = "antenna-uplink"
        case dataflowEndpoint = "dataflow-endpoint"
        case s3Recording = "s3-recording"
        case tracking
        case uplinkEcho = "uplink-echo"
        public var description: String { return self.rawValue }
    }

    public enum ContactStatus: String, CustomStringConvertible, Codable, _SotoSendable {
        case available = "AVAILABLE"
        case awsCancelled = "AWS_CANCELLED"
        case awsFailed = "AWS_FAILED"
        case cancelled = "CANCELLED"
        case cancelling = "CANCELLING"
        case completed = "COMPLETED"
        case failed = "FAILED"
        case failedToSchedule = "FAILED_TO_SCHEDULE"
        case pass = "PASS"
        case postpass = "POSTPASS"
        case prepass = "PREPASS"
        case scheduled = "SCHEDULED"
        case scheduling = "SCHEDULING"
        public var description: String { return self.rawValue }
    }

    public enum Criticality: String, CustomStringConvertible, Codable, _SotoSendable {
        case preferred = "PREFERRED"
        case removed = "REMOVED"
        case required = "REQUIRED"
        public var description: String { return self.rawValue }
    }

    public enum EirpUnits: String, CustomStringConvertible, Codable, _SotoSendable {
        case dBW
        public var description: String { return self.rawValue }
    }

    public enum EndpointStatus: String, CustomStringConvertible, Codable, _SotoSendable {
        case created
        case creating
        case deleted
        case deleting
        case failed
        public var description: String { return self.rawValue }
    }

    public enum EphemerisInvalidReason: String, CustomStringConvertible, Codable, _SotoSendable {
        /// Provided KMS key is invalid
        case kmsKeyInvalid = "KMS_KEY_INVALID"
        /// Provided spacecraft identifiers such as spacecraft NORAD Id are invalid
        case metadataInvalid = "METADATA_INVALID"
        /// Start, end, or expiration time(s) are invalid for the provided ephemeris
        case timeRangeInvalid = "TIME_RANGE_INVALID"
        /// Provided ephemeris defines invalid spacecraft trajectory
        case trajectoryInvalid = "TRAJECTORY_INVALID"
        /// Internal Service Error occurred while processing ephemeris
        case validationError = "VALIDATION_ERROR"
        public var description: String { return self.rawValue }
    }

    public enum EphemerisSource: String, CustomStringConvertible, Codable, _SotoSendable {
        case customerProvided = "CUSTOMER_PROVIDED"
        case spaceTrack = "SPACE_TRACK"
        public var description: String { return self.rawValue }
    }

    public enum EphemerisStatus: String, CustomStringConvertible, Codable, _SotoSendable {
        case disabled = "DISABLED"
        case enabled = "ENABLED"
        case error = "ERROR"
        case expired = "EXPIRED"
        case invalid = "INVALID"
        case validating = "VALIDATING"
        public var description: String { return self.rawValue }
    }

    public enum FrequencyUnits: String, CustomStringConvertible, Codable, _SotoSendable {
        case gHz = "GHz"
        case mHz = "MHz"
        case kHz
        public var description: String { return self.rawValue }
    }

    public enum Polarization: String, CustomStringConvertible, Codable, _SotoSendable {
        case leftHand = "LEFT_HAND"
        case none = "NONE"
        case rightHand = "RIGHT_HAND"
        public var description: String { return self.rawValue }
    }

    public enum ConfigDetails: AWSDecodableShape, _SotoSendable {
        /// Details for antenna demod decode Config in a contact.
        case antennaDemodDecodeDetails(AntennaDemodDecodeDetails)
        case endpointDetails(EndpointDetails)
        /// Details for an S3 recording Config in a contact.
        case s3RecordingDetails(S3RecordingDetails)

        public init(from decoder: Decoder) throws {
            let container = try decoder.container(keyedBy: CodingKeys.self)
            guard container.allKeys.count == 1, let key = container.allKeys.first else {
                let context = DecodingError.Context(
                    codingPath: container.codingPath,
                    debugDescription: "Expected exactly one key, but got \(container.allKeys.count)"
                )
                throw DecodingError.dataCorrupted(context)
            }
            switch key {
            case .antennaDemodDecodeDetails:
                let value = try container.decode(AntennaDemodDecodeDetails.self, forKey: .antennaDemodDecodeDetails)
                self = .antennaDemodDecodeDetails(value)
            case .endpointDetails:
                let value = try container.decode(EndpointDetails.self, forKey: .endpointDetails)
                self = .endpointDetails(value)
            case .s3RecordingDetails:
                let value = try container.decode(S3RecordingDetails.self, forKey: .s3RecordingDetails)
                self = .s3RecordingDetails(value)
            }
        }

        private enum CodingKeys: String, CodingKey {
            case antennaDemodDecodeDetails
            case endpointDetails
            case s3RecordingDetails
        }
    }

    public enum ConfigTypeData: AWSEncodableShape & AWSDecodableShape, _SotoSendable {
        /// Information about how AWS Ground Station should configure an antenna for downlink during a contact.
        case antennaDownlinkConfig(AntennaDownlinkConfig)
        /// Information about how AWS Ground Station should conﬁgure an antenna for downlink demod decode during a contact.
        case antennaDownlinkDemodDecodeConfig(AntennaDownlinkDemodDecodeConfig)
        /// Information about how AWS Ground Station should conﬁgure an antenna for uplink during a contact.
        case antennaUplinkConfig(AntennaUplinkConfig)
        /// Information about the dataflow endpoint Config.
        case dataflowEndpointConfig(DataflowEndpointConfig)
        /// Information about an S3 recording Config.
        case s3RecordingConfig(S3RecordingConfig)
        /// Object that determines whether tracking should be used during a contact executed with this Config in the mission profile.
        case trackingConfig(TrackingConfig)
        /// Information about an uplink echo Config. Parameters from the AntennaUplinkConfig, corresponding to the specified AntennaUplinkConfigArn, are used when this UplinkEchoConfig is used in a contact.
        case uplinkEchoConfig(UplinkEchoConfig)

        public init(from decoder: Decoder) throws {
            let container = try decoder.container(keyedBy: CodingKeys.self)
            guard container.allKeys.count == 1, let key = container.allKeys.first else {
                let context = DecodingError.Context(
                    codingPath: container.codingPath,
                    debugDescription: "Expected exactly one key, but got \(container.allKeys.count)"
                )
                throw DecodingError.dataCorrupted(context)
            }
            switch key {
            case .antennaDownlinkConfig:
                let value = try container.decode(AntennaDownlinkConfig.self, forKey: .antennaDownlinkConfig)
                self = .antennaDownlinkConfig(value)
            case .antennaDownlinkDemodDecodeConfig:
                let value = try container.decode(AntennaDownlinkDemodDecodeConfig.self, forKey: .antennaDownlinkDemodDecodeConfig)
                self = .antennaDownlinkDemodDecodeConfig(value)
            case .antennaUplinkConfig:
                let value = try container.decode(AntennaUplinkConfig.self, forKey: .antennaUplinkConfig)
                self = .antennaUplinkConfig(value)
            case .dataflowEndpointConfig:
                let value = try container.decode(DataflowEndpointConfig.self, forKey: .dataflowEndpointConfig)
                self = .dataflowEndpointConfig(value)
            case .s3RecordingConfig:
                let value = try container.decode(S3RecordingConfig.self, forKey: .s3RecordingConfig)
                self = .s3RecordingConfig(value)
            case .trackingConfig:
                let value = try container.decode(TrackingConfig.self, forKey: .trackingConfig)
                self = .trackingConfig(value)
            case .uplinkEchoConfig:
                let value = try container.decode(UplinkEchoConfig.self, forKey: .uplinkEchoConfig)
                self = .uplinkEchoConfig(value)
            }
        }

        public func encode(to encoder: Encoder) throws {
            var container = encoder.container(keyedBy: CodingKeys.self)
            switch self {
            case .antennaDownlinkConfig(let value):
                try container.encode(value, forKey: .antennaDownlinkConfig)
            case .antennaDownlinkDemodDecodeConfig(let value):
                try container.encode(value, forKey: .antennaDownlinkDemodDecodeConfig)
            case .antennaUplinkConfig(let value):
                try container.encode(value, forKey: .antennaUplinkConfig)
            case .dataflowEndpointConfig(let value):
                try container.encode(value, forKey: .dataflowEndpointConfig)
            case .s3RecordingConfig(let value):
                try container.encode(value, forKey: .s3RecordingConfig)
            case .trackingConfig(let value):
                try container.encode(value, forKey: .trackingConfig)
            case .uplinkEchoConfig(let value):
                try container.encode(value, forKey: .uplinkEchoConfig)
            }
        }

        public func validate(name: String) throws {
            switch self {
            case .antennaDownlinkDemodDecodeConfig(let value):
                try value.validate(name: "\(name).antennaDownlinkDemodDecodeConfig")
            case .s3RecordingConfig(let value):
                try value.validate(name: "\(name).s3RecordingConfig")
            default:
                break
            }
        }

        private enum CodingKeys: String, CodingKey {
            case antennaDownlinkConfig
            case antennaDownlinkDemodDecodeConfig
            case antennaUplinkConfig
            case dataflowEndpointConfig
            case s3RecordingConfig
            case trackingConfig
            case uplinkEchoConfig
        }
    }

    public enum EphemerisData: AWSEncodableShape, _SotoSendable {
        case oem(OEMEphemeris)
        case tle(TLEEphemeris)

        public func encode(to encoder: Encoder) throws {
            var container = encoder.container(keyedBy: CodingKeys.self)
            switch self {
            case .oem(let value):
                try container.encode(value, forKey: .oem)
            case .tle(let value):
                try container.encode(value, forKey: .tle)
            }
        }

        public func validate(name: String) throws {
            switch self {
            case .oem(let value):
                try value.validate(name: "\(name).oem")
            case .tle(let value):
                try value.validate(name: "\(name).tle")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case oem
            case tle
        }
    }

    public enum EphemerisTypeDescription: AWSDecodableShape, _SotoSendable {
        case oem(EphemerisDescription)
        case tle(EphemerisDescription)

        public init(from decoder: Decoder) throws {
            let container = try decoder.container(keyedBy: CodingKeys.self)
            guard container.allKeys.count == 1, let key = container.allKeys.first else {
                let context = DecodingError.Context(
                    codingPath: container.codingPath,
                    debugDescription: "Expected exactly one key, but got \(container.allKeys.count)"
                )
                throw DecodingError.dataCorrupted(context)
            }
            switch key {
            case .oem:
                let value = try container.decode(EphemerisDescription.self, forKey: .oem)
                self = .oem(value)
            case .tle:
                let value = try container.decode(EphemerisDescription.self, forKey: .tle)
                self = .tle(value)
            }
        }

        private enum CodingKeys: String, CodingKey {
            case oem
            case tle
        }
    }

    // MARK: Shapes

    public struct AntennaDemodDecodeDetails: AWSDecodableShape {
        /// Name of an antenna demod decode output node used in a contact.
        public let outputNode: String?

        public init(outputNode: String? = nil) {
            self.outputNode = outputNode
        }

        private enum CodingKeys: String, CodingKey {
            case outputNode
        }
    }

    public struct AntennaDownlinkConfig: AWSEncodableShape & AWSDecodableShape {
        /// Object that describes a spectral Config.
        public let spectrumConfig: SpectrumConfig

        public init(spectrumConfig: SpectrumConfig) {
            self.spectrumConfig = spectrumConfig
        }

        private enum CodingKeys: String, CodingKey {
            case spectrumConfig
        }
    }

    public struct AntennaDownlinkDemodDecodeConfig: AWSEncodableShape & AWSDecodableShape {
        /// Information about the decode Config.
        public let decodeConfig: DecodeConfig
        /// Information about the demodulation Config.
        public let demodulationConfig: DemodulationConfig
        /// Information about the spectral Config.
        public let spectrumConfig: SpectrumConfig

        public init(decodeConfig: DecodeConfig, demodulationConfig: DemodulationConfig, spectrumConfig: SpectrumConfig) {
            self.decodeConfig = decodeConfig
            self.demodulationConfig = demodulationConfig
            self.spectrumConfig = spectrumConfig
        }

        public func validate(name: String) throws {
            try self.decodeConfig.validate(name: "\(name).decodeConfig")
            try self.demodulationConfig.validate(name: "\(name).demodulationConfig")
        }

        private enum CodingKeys: String, CodingKey {
            case decodeConfig
            case demodulationConfig
            case spectrumConfig
        }
    }

    public struct AntennaUplinkConfig: AWSEncodableShape & AWSDecodableShape {
        /// Information about the uplink spectral Config.
        public let spectrumConfig: UplinkSpectrumConfig
        /// EIRP of the target.
        public let targetEirp: Eirp
        /// Whether or not uplink transmit is disabled.
        public let transmitDisabled: Bool?

        public init(spectrumConfig: UplinkSpectrumConfig, targetEirp: Eirp, transmitDisabled: Bool? = nil) {
            self.spectrumConfig = spectrumConfig
            self.targetEirp = targetEirp
            self.transmitDisabled = transmitDisabled
        }

        private enum CodingKeys: String, CodingKey {
            case spectrumConfig
            case targetEirp
            case transmitDisabled
        }
    }

    public struct CancelContactRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "contactId", location: .uri("contactId"))
        ]

        /// UUID of a contact.
        public let contactId: String

        public init(contactId: String) {
            self.contactId = contactId
        }

        public func validate(name: String) throws {
            try self.validate(self.contactId, name: "contactId", parent: name, max: 128)
            try self.validate(self.contactId, name: "contactId", parent: name, min: 1)
            try self.validate(self.contactId, name: "contactId", parent: name, pattern: "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ConfigIdResponse: AWSDecodableShape {
        /// ARN of a Config.
        public let configArn: String?
        /// UUID of a Config.
        public let configId: String?
        /// Type of a Config.
        public let configType: ConfigCapabilityType?

        public init(configArn: String? = nil, configId: String? = nil, configType: ConfigCapabilityType? = nil) {
            self.configArn = configArn
            self.configId = configId
            self.configType = configType
        }

        private enum CodingKeys: String, CodingKey {
            case configArn
            case configId
            case configType
        }
    }

    public struct ConfigListItem: AWSDecodableShape {
        /// ARN of a Config.
        public let configArn: String?
        /// UUID of a Config.
        public let configId: String?
        /// Type of a Config.
        public let configType: ConfigCapabilityType?
        /// Name of a Config.
        public let name: String?

        public init(configArn: String? = nil, configId: String? = nil, configType: ConfigCapabilityType? = nil, name: String? = nil) {
            self.configArn = configArn
            self.configId = configId
            self.configType = configType
            self.name = name
        }

        private enum CodingKeys: String, CodingKey {
            case configArn
            case configId
            case configType
            case name
        }
    }

    public struct ContactData: AWSDecodableShape {
        /// UUID of a contact.
        public let contactId: String?
        /// Status of a contact.
        public let contactStatus: ContactStatus?
        /// End time of a contact in UTC.
        public let endTime: Date?
        /// Error message of a contact.
        public let errorMessage: String?
        /// Name of a ground station.
        public let groundStation: String?
        /// Maximum elevation angle of a contact.
        public let maximumElevation: Elevation?
        /// ARN of a mission profile.
        public let missionProfileArn: String?
        /// Amount of time after a contact ends that you’d like to receive a CloudWatch event indicating the pass has finished.
        public let postPassEndTime: Date?
        /// Amount of time prior to contact start you’d like to receive a CloudWatch event indicating an upcoming pass.
        public let prePassStartTime: Date?
        /// Region of a contact.
        public let region: String?
        /// ARN of a satellite.
        public let satelliteArn: String?
        /// Start time of a contact in UTC.
        public let startTime: Date?
        /// Tags assigned to a contact.
        public let tags: [String: String]?

        public init(contactId: String? = nil, contactStatus: ContactStatus? = nil, endTime: Date? = nil, errorMessage: String? = nil, groundStation: String? = nil, maximumElevation: Elevation? = nil, missionProfileArn: String? = nil, postPassEndTime: Date? = nil, prePassStartTime: Date? = nil, region: String? = nil, satelliteArn: String? = nil, startTime: Date? = nil, tags: [String: String]? = nil) {
            self.contactId = contactId
            self.contactStatus = contactStatus
            self.endTime = endTime
            self.errorMessage = errorMessage
            self.groundStation = groundStation
            self.maximumElevation = maximumElevation
            self.missionProfileArn = missionProfileArn
            self.postPassEndTime = postPassEndTime
            self.prePassStartTime = prePassStartTime
            self.region = region
            self.satelliteArn = satelliteArn
            self.startTime = startTime
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case contactId
            case contactStatus
            case endTime
            case errorMessage
            case groundStation
            case maximumElevation
            case missionProfileArn
            case postPassEndTime
            case prePassStartTime
            case region
            case satelliteArn
            case startTime
            case tags
        }
    }

    public struct ContactIdResponse: AWSDecodableShape {
        /// UUID of a contact.
        public let contactId: String?

        public init(contactId: String? = nil) {
            self.contactId = contactId
        }

        private enum CodingKeys: String, CodingKey {
            case contactId
        }
    }

    public struct CreateConfigRequest: AWSEncodableShape {
        /// Parameters of a Config.
        public let configData: ConfigTypeData
        /// Name of a Config.
        public let name: String
        /// Tags assigned to a Config.
        public let tags: [String: String]?

        public init(configData: ConfigTypeData, name: String, tags: [String: String]? = nil) {
            self.configData = configData
            self.name = name
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.configData.validate(name: "\(name).configData")
            try self.validate(self.name, name: "name", parent: name, max: 256)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[ a-zA-Z0-9_:-]{1,256}$")
        }

        private enum CodingKeys: String, CodingKey {
            case configData
            case name
            case tags
        }
    }

    public struct CreateDataflowEndpointGroupRequest: AWSEncodableShape {
        /// Endpoint details of each endpoint in the dataflow endpoint group.
        public let endpointDetails: [EndpointDetails]
        /// Tags of a dataflow endpoint group.
        public let tags: [String: String]?

        public init(endpointDetails: [EndpointDetails], tags: [String: String]? = nil) {
            self.endpointDetails = endpointDetails
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.endpointDetails.forEach {
                try $0.validate(name: "\(name).endpointDetails[]")
            }
            try self.validate(self.endpointDetails, name: "endpointDetails", parent: name, max: 500)
        }

        private enum CodingKeys: String, CodingKey {
            case endpointDetails
            case tags
        }
    }

    public struct CreateEphemerisRequest: AWSEncodableShape {
        /// Whether to set the ephemeris status to ENABLED after validation. Setting this to false will set the ephemeris status to DISABLED after validation.
        public let enabled: Bool?
        /// Ephemeris data.
        public let ephemeris: EphemerisData?
        /// An overall expiration time for the ephemeris in UTC, after which it will become EXPIRED.
        public let expirationTime: Date?
        /// The ARN of a KMS key used to encrypt the ephemeris in Ground Station.
        public let kmsKeyArn: String?
        /// A name string associated with the ephemeris. Used as a human-readable identifier for the ephemeris.
        public let name: String
        /// Customer-provided priority score to establish the order in which overlapping ephemerides should be used. The default for customer-provided ephemeris priority is 1, and higher numbers take precedence. Priority must be 1 or greater
        public let priority: Int?
        /// AWS Ground Station satellite ID for this ephemeris.
        public let satelliteId: String
        /// Tags assigned to an ephemeris.
        public let tags: [String: String]?

        public init(enabled: Bool? = nil, ephemeris: EphemerisData? = nil, expirationTime: Date? = nil, kmsKeyArn: String? = nil, name: String, priority: Int? = nil, satelliteId: String, tags: [String: String]? = nil) {
            self.enabled = enabled
            self.ephemeris = ephemeris
            self.expirationTime = expirationTime
            self.kmsKeyArn = kmsKeyArn
            self.name = name
            self.priority = priority
            self.satelliteId = satelliteId
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.ephemeris?.validate(name: "\(name).ephemeris")
            try self.validate(self.name, name: "name", parent: name, max: 256)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[ a-zA-Z0-9_:-]{1,256}$")
            try self.validate(self.priority, name: "priority", parent: name, max: 99999)
            try self.validate(self.priority, name: "priority", parent: name, min: 1)
            try self.validate(self.satelliteId, name: "satelliteId", parent: name, max: 128)
            try self.validate(self.satelliteId, name: "satelliteId", parent: name, min: 1)
            try self.validate(self.satelliteId, name: "satelliteId", parent: name, pattern: "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$")
        }

        private enum CodingKeys: String, CodingKey {
            case enabled
            case ephemeris
            case expirationTime
            case kmsKeyArn
            case name
            case priority
            case satelliteId
            case tags
        }
    }

    public struct CreateMissionProfileRequest: AWSEncodableShape {
        /// Amount of time after a contact ends that you’d like to receive a CloudWatch event indicating the pass has finished.
        public let contactPostPassDurationSeconds: Int?
        /// Amount of time prior to contact start you’d like to receive a CloudWatch event indicating an upcoming pass.
        public let contactPrePassDurationSeconds: Int?
        /// A list of lists of ARNs. Each list of ARNs is an edge, with a from  Config and a to Config.
        public let dataflowEdges: [[String]]
        /// Smallest amount of time in seconds that you’d like to see for an available contact. AWS Ground Station will not present you with contacts shorter than this duration.
        public let minimumViableContactDurationSeconds: Int
        /// Name of a mission profile.
        public let name: String
        /// Tags assigned to a mission profile.
        public let tags: [String: String]?
        /// ARN of a tracking Config.
        public let trackingConfigArn: String

        public init(contactPostPassDurationSeconds: Int? = nil, contactPrePassDurationSeconds: Int? = nil, dataflowEdges: [[String]], minimumViableContactDurationSeconds: Int, name: String, tags: [String: String]? = nil, trackingConfigArn: String) {
            self.contactPostPassDurationSeconds = contactPostPassDurationSeconds
            self.contactPrePassDurationSeconds = contactPrePassDurationSeconds
            self.dataflowEdges = dataflowEdges
            self.minimumViableContactDurationSeconds = minimumViableContactDurationSeconds
            self.name = name
            self.tags = tags
            self.trackingConfigArn = trackingConfigArn
        }

        public func validate(name: String) throws {
            try self.validate(self.contactPostPassDurationSeconds, name: "contactPostPassDurationSeconds", parent: name, max: 21600)
            try self.validate(self.contactPostPassDurationSeconds, name: "contactPostPassDurationSeconds", parent: name, min: 0)
            try self.validate(self.contactPrePassDurationSeconds, name: "contactPrePassDurationSeconds", parent: name, max: 21600)
            try self.validate(self.contactPrePassDurationSeconds, name: "contactPrePassDurationSeconds", parent: name, min: 0)
            try self.dataflowEdges.forEach {
                try validate($0, name: "dataflowEdges[]", parent: name, max: 2)
                try validate($0, name: "dataflowEdges[]", parent: name, min: 2)
            }
            try self.validate(self.dataflowEdges, name: "dataflowEdges", parent: name, max: 500)
            try self.validate(self.minimumViableContactDurationSeconds, name: "minimumViableContactDurationSeconds", parent: name, max: 21600)
            try self.validate(self.minimumViableContactDurationSeconds, name: "minimumViableContactDurationSeconds", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, max: 256)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[ a-zA-Z0-9_:-]{1,256}$")
        }

        private enum CodingKeys: String, CodingKey {
            case contactPostPassDurationSeconds
            case contactPrePassDurationSeconds
            case dataflowEdges
            case minimumViableContactDurationSeconds
            case name
            case tags
            case trackingConfigArn
        }
    }

    public struct DataflowDetail: AWSDecodableShape {
        public let destination: Destination?
        /// Error message for a dataflow.
        public let errorMessage: String?
        public let source: Source?

        public init(destination: Destination? = nil, errorMessage: String? = nil, source: Source? = nil) {
            self.destination = destination
            self.errorMessage = errorMessage
            self.source = source
        }

        private enum CodingKeys: String, CodingKey {
            case destination
            case errorMessage
            case source
        }
    }

    public struct DataflowEndpoint: AWSEncodableShape & AWSDecodableShape {
        /// Socket address of a dataflow endpoint.
        public let address: SocketAddress?
        /// Maximum transmission unit (MTU) size in bytes of a dataflow endpoint.
        public let mtu: Int?
        /// Name of a dataflow endpoint.
        public let name: String?
        /// Status of a dataflow endpoint.
        public let status: EndpointStatus?

        public init(address: SocketAddress? = nil, mtu: Int? = nil, name: String? = nil, status: EndpointStatus? = nil) {
            self.address = address
            self.mtu = mtu
            self.name = name
            self.status = status
        }

        public func validate(name: String) throws {
            try self.validate(self.name, name: "name", parent: name, max: 256)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[ a-zA-Z0-9_:-]{1,256}$")
        }

        private enum CodingKeys: String, CodingKey {
            case address
            case mtu
            case name
            case status
        }
    }

    public struct DataflowEndpointConfig: AWSEncodableShape & AWSDecodableShape {
        /// Name of a dataflow endpoint.
        public let dataflowEndpointName: String
        /// Region of a dataflow endpoint.
        public let dataflowEndpointRegion: String?

        public init(dataflowEndpointName: String, dataflowEndpointRegion: String? = nil) {
            self.dataflowEndpointName = dataflowEndpointName
            self.dataflowEndpointRegion = dataflowEndpointRegion
        }

        private enum CodingKeys: String, CodingKey {
            case dataflowEndpointName
            case dataflowEndpointRegion
        }
    }

    public struct DataflowEndpointGroupIdResponse: AWSDecodableShape {
        /// UUID of a dataflow endpoint group.
        public let dataflowEndpointGroupId: String?

        public init(dataflowEndpointGroupId: String? = nil) {
            self.dataflowEndpointGroupId = dataflowEndpointGroupId
        }

        private enum CodingKeys: String, CodingKey {
            case dataflowEndpointGroupId
        }
    }

    public struct DataflowEndpointListItem: AWSDecodableShape {
        /// ARN of a dataflow endpoint group.
        public let dataflowEndpointGroupArn: String?
        /// UUID of a dataflow endpoint group.
        public let dataflowEndpointGroupId: String?

        public init(dataflowEndpointGroupArn: String? = nil, dataflowEndpointGroupId: String? = nil) {
            self.dataflowEndpointGroupArn = dataflowEndpointGroupArn
            self.dataflowEndpointGroupId = dataflowEndpointGroupId
        }

        private enum CodingKeys: String, CodingKey {
            case dataflowEndpointGroupArn
            case dataflowEndpointGroupId
        }
    }

    public struct DecodeConfig: AWSEncodableShape & AWSDecodableShape {
        /// Unvalidated JSON of a decode Config.
        public let unvalidatedJSON: String

        public init(unvalidatedJSON: String) {
            self.unvalidatedJSON = unvalidatedJSON
        }

        public func validate(name: String) throws {
            try self.validate(self.unvalidatedJSON, name: "unvalidatedJSON", parent: name, max: 8192)
            try self.validate(self.unvalidatedJSON, name: "unvalidatedJSON", parent: name, min: 2)
            try self.validate(self.unvalidatedJSON, name: "unvalidatedJSON", parent: name, pattern: "^[{}\\[\\]:.,\"0-9A-z\\-_\\s]{2,8192}$")
        }

        private enum CodingKeys: String, CodingKey {
            case unvalidatedJSON
        }
    }

    public struct DeleteConfigRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "configId", location: .uri("configId")),
            AWSMemberEncoding(label: "configType", location: .uri("configType"))
        ]

        /// UUID of a Config.
        public let configId: String
        /// Type of a Config.
        public let configType: ConfigCapabilityType

        public init(configId: String, configType: ConfigCapabilityType) {
            self.configId = configId
            self.configType = configType
        }

        public func validate(name: String) throws {
            try self.validate(self.configId, name: "configId", parent: name, max: 128)
            try self.validate(self.configId, name: "configId", parent: name, min: 1)
            try self.validate(self.configId, name: "configId", parent: name, pattern: "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteDataflowEndpointGroupRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "dataflowEndpointGroupId", location: .uri("dataflowEndpointGroupId"))
        ]

        /// UUID of a dataflow endpoint group.
        public let dataflowEndpointGroupId: String

        public init(dataflowEndpointGroupId: String) {
            self.dataflowEndpointGroupId = dataflowEndpointGroupId
        }

        public func validate(name: String) throws {
            try self.validate(self.dataflowEndpointGroupId, name: "dataflowEndpointGroupId", parent: name, max: 128)
            try self.validate(self.dataflowEndpointGroupId, name: "dataflowEndpointGroupId", parent: name, min: 1)
            try self.validate(self.dataflowEndpointGroupId, name: "dataflowEndpointGroupId", parent: name, pattern: "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteEphemerisRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "ephemerisId", location: .uri("ephemerisId"))
        ]

        /// The AWS Ground Station ephemeris ID.
        public let ephemerisId: String

        public init(ephemerisId: String) {
            self.ephemerisId = ephemerisId
        }

        public func validate(name: String) throws {
            try self.validate(self.ephemerisId, name: "ephemerisId", parent: name, max: 128)
            try self.validate(self.ephemerisId, name: "ephemerisId", parent: name, min: 1)
            try self.validate(self.ephemerisId, name: "ephemerisId", parent: name, pattern: "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteMissionProfileRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "missionProfileId", location: .uri("missionProfileId"))
        ]

        /// UUID of a mission profile.
        public let missionProfileId: String

        public init(missionProfileId: String) {
            self.missionProfileId = missionProfileId
        }

        public func validate(name: String) throws {
            try self.validate(self.missionProfileId, name: "missionProfileId", parent: name, max: 128)
            try self.validate(self.missionProfileId, name: "missionProfileId", parent: name, min: 1)
            try self.validate(self.missionProfileId, name: "missionProfileId", parent: name, pattern: "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DemodulationConfig: AWSEncodableShape & AWSDecodableShape {
        /// Unvalidated JSON of a demodulation Config.
        public let unvalidatedJSON: String

        public init(unvalidatedJSON: String) {
            self.unvalidatedJSON = unvalidatedJSON
        }

        public func validate(name: String) throws {
            try self.validate(self.unvalidatedJSON, name: "unvalidatedJSON", parent: name, max: 8192)
            try self.validate(self.unvalidatedJSON, name: "unvalidatedJSON", parent: name, min: 2)
            try self.validate(self.unvalidatedJSON, name: "unvalidatedJSON", parent: name, pattern: "^[{}\\[\\]:.,\"0-9A-z\\-_\\s]{2,8192}$")
        }

        private enum CodingKeys: String, CodingKey {
            case unvalidatedJSON
        }
    }

    public struct DescribeContactRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "contactId", location: .uri("contactId"))
        ]

        /// UUID of a contact.
        public let contactId: String

        public init(contactId: String) {
            self.contactId = contactId
        }

        public func validate(name: String) throws {
            try self.validate(self.contactId, name: "contactId", parent: name, max: 128)
            try self.validate(self.contactId, name: "contactId", parent: name, min: 1)
            try self.validate(self.contactId, name: "contactId", parent: name, pattern: "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DescribeContactResponse: AWSDecodableShape {
        /// UUID of a contact.
        public let contactId: String?
        /// Status of a contact.
        public let contactStatus: ContactStatus?
        /// List describing source and destination details for each dataflow edge.
        public let dataflowList: [DataflowDetail]?
        /// End time of a contact in UTC.
        public let endTime: Date?
        /// Error message for a contact.
        public let errorMessage: String?
        /// Ground station for a contact.
        public let groundStation: String?
        /// Maximum elevation angle of a contact.
        public let maximumElevation: Elevation?
        /// ARN of a mission profile.
        public let missionProfileArn: String?
        /// Amount of time after a contact ends that you’d like to receive a CloudWatch event indicating the pass has finished.
        public let postPassEndTime: Date?
        /// Amount of time prior to contact start you’d like to receive a CloudWatch event indicating an upcoming pass.
        public let prePassStartTime: Date?
        /// Region of a contact.
        public let region: String?
        /// ARN of a satellite.
        public let satelliteArn: String?
        /// Start time of a contact in UTC.
        public let startTime: Date?
        /// Tags assigned to a contact.
        public let tags: [String: String]?

        public init(contactId: String? = nil, contactStatus: ContactStatus? = nil, dataflowList: [DataflowDetail]? = nil, endTime: Date? = nil, errorMessage: String? = nil, groundStation: String? = nil, maximumElevation: Elevation? = nil, missionProfileArn: String? = nil, postPassEndTime: Date? = nil, prePassStartTime: Date? = nil, region: String? = nil, satelliteArn: String? = nil, startTime: Date? = nil, tags: [String: String]? = nil) {
            self.contactId = contactId
            self.contactStatus = contactStatus
            self.dataflowList = dataflowList
            self.endTime = endTime
            self.errorMessage = errorMessage
            self.groundStation = groundStation
            self.maximumElevation = maximumElevation
            self.missionProfileArn = missionProfileArn
            self.postPassEndTime = postPassEndTime
            self.prePassStartTime = prePassStartTime
            self.region = region
            self.satelliteArn = satelliteArn
            self.startTime = startTime
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case contactId
            case contactStatus
            case dataflowList
            case endTime
            case errorMessage
            case groundStation
            case maximumElevation
            case missionProfileArn
            case postPassEndTime
            case prePassStartTime
            case region
            case satelliteArn
            case startTime
            case tags
        }
    }

    public struct DescribeEphemerisRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "ephemerisId", location: .uri("ephemerisId"))
        ]

        /// The AWS Ground Station ephemeris ID.
        public let ephemerisId: String

        public init(ephemerisId: String) {
            self.ephemerisId = ephemerisId
        }

        public func validate(name: String) throws {
            try self.validate(self.ephemerisId, name: "ephemerisId", parent: name, max: 128)
            try self.validate(self.ephemerisId, name: "ephemerisId", parent: name, min: 1)
            try self.validate(self.ephemerisId, name: "ephemerisId", parent: name, pattern: "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DescribeEphemerisResponse: AWSDecodableShape {
        /// The time the ephemeris was uploaded in UTC.
        public let creationTime: Date?
        /// Whether or not the ephemeris is enabled.
        public let enabled: Bool?
        /// The AWS Ground Station ephemeris ID.
        public let ephemerisId: String?
        /// Reason that an ephemeris failed validation. Only provided for ephemerides with INVALID status.
        public let invalidReason: EphemerisInvalidReason?
        /// A name string associated with the ephemeris. Used as a human-readable identifier for the ephemeris.
        public let name: String?
        /// Customer-provided priority score to establish the order in which overlapping ephemerides should be used. The default for customer-provided ephemeris priority is 1, and higher numbers take precedence. Priority must be 1 or greater
        public let priority: Int?
        /// The AWS Ground Station satellite ID associated with ephemeris.
        public let satelliteId: String?
        /// The status of the ephemeris.
        public let status: EphemerisStatus?
        /// Supplied ephemeris data.
        public let suppliedData: EphemerisTypeDescription?
        /// Tags assigned to an ephemeris.
        public let tags: [String: String]?

        public init(creationTime: Date? = nil, enabled: Bool? = nil, ephemerisId: String? = nil, invalidReason: EphemerisInvalidReason? = nil, name: String? = nil, priority: Int? = nil, satelliteId: String? = nil, status: EphemerisStatus? = nil, suppliedData: EphemerisTypeDescription? = nil, tags: [String: String]? = nil) {
            self.creationTime = creationTime
            self.enabled = enabled
            self.ephemerisId = ephemerisId
            self.invalidReason = invalidReason
            self.name = name
            self.priority = priority
            self.satelliteId = satelliteId
            self.status = status
            self.suppliedData = suppliedData
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case creationTime
            case enabled
            case ephemerisId
            case invalidReason
            case name
            case priority
            case satelliteId
            case status
            case suppliedData
            case tags
        }
    }

    public struct Destination: AWSDecodableShape {
        /// Additional details for a Config, if type is dataflow endpoint or antenna demod decode.
        public let configDetails: ConfigDetails?
        /// UUID of a Config.
        public let configId: String?
        /// Type of a Config.
        public let configType: ConfigCapabilityType?
        /// Region of a dataflow destination.
        public let dataflowDestinationRegion: String?

        public init(configDetails: ConfigDetails? = nil, configId: String? = nil, configType: ConfigCapabilityType? = nil, dataflowDestinationRegion: String? = nil) {
            self.configDetails = configDetails
            self.configId = configId
            self.configType = configType
            self.dataflowDestinationRegion = dataflowDestinationRegion
        }

        private enum CodingKeys: String, CodingKey {
            case configDetails
            case configId
            case configType
            case dataflowDestinationRegion
        }
    }

    public struct Eirp: AWSEncodableShape & AWSDecodableShape {
        /// Units of an EIRP.
        public let units: EirpUnits
        /// Value of an EIRP. Valid values are between 20.0 to 50.0 dBW.
        public let value: Double

        public init(units: EirpUnits, value: Double) {
            self.units = units
            self.value = value
        }

        private enum CodingKeys: String, CodingKey {
            case units
            case value
        }
    }

    public struct Elevation: AWSDecodableShape {
        /// Elevation angle units.
        public let unit: AngleUnits
        /// Elevation angle value.
        public let value: Double

        public init(unit: AngleUnits, value: Double) {
            self.unit = unit
            self.value = value
        }

        private enum CodingKeys: String, CodingKey {
            case unit
            case value
        }
    }

    public struct EndpointDetails: AWSEncodableShape & AWSDecodableShape {
        /// A dataflow endpoint.
        public let endpoint: DataflowEndpoint?
        /// Endpoint security details including a list of subnets, a list of security groups and a role to connect streams to instances.
        public let securityDetails: SecurityDetails?

        public init(endpoint: DataflowEndpoint? = nil, securityDetails: SecurityDetails? = nil) {
            self.endpoint = endpoint
            self.securityDetails = securityDetails
        }

        public func validate(name: String) throws {
            try self.endpoint?.validate(name: "\(name).endpoint")
        }

        private enum CodingKeys: String, CodingKey {
            case endpoint
            case securityDetails
        }
    }

    public struct EphemerisDescription: AWSDecodableShape {
        /// Supplied ephemeris data.
        public let ephemerisData: String?
        /// Source S3 object used for the ephemeris.
        public let sourceS3Object: S3Object?

        public init(ephemerisData: String? = nil, sourceS3Object: S3Object? = nil) {
            self.ephemerisData = ephemerisData
            self.sourceS3Object = sourceS3Object
        }

        private enum CodingKeys: String, CodingKey {
            case ephemerisData
            case sourceS3Object
        }
    }

    public struct EphemerisIdResponse: AWSDecodableShape {
        /// The AWS Ground Station ephemeris ID.
        public let ephemerisId: String?

        public init(ephemerisId: String? = nil) {
            self.ephemerisId = ephemerisId
        }

        private enum CodingKeys: String, CodingKey {
            case ephemerisId
        }
    }

    public struct EphemerisItem: AWSDecodableShape {
        /// The time the ephemeris was uploaded in UTC.
        public let creationTime: Date?
        /// Whether or not the ephemeris is enabled.
        public let enabled: Bool?
        /// The AWS Ground Station ephemeris ID.
        public let ephemerisId: String?
        /// A name string associated with the ephemeris. Used as a human-readable identifier for the ephemeris.
        public let name: String?
        /// Customer-provided priority score to establish the order in which overlapping ephemerides should be used. The default for customer-provided ephemeris priority is 1, and higher numbers take precedence. Priority must be 1 or greater
        public let priority: Int?
        /// Source S3 object used for the ephemeris.
        public let sourceS3Object: S3Object?
        /// The status of the ephemeris.
        public let status: EphemerisStatus?

        public init(creationTime: Date? = nil, enabled: Bool? = nil, ephemerisId: String? = nil, name: String? = nil, priority: Int? = nil, sourceS3Object: S3Object? = nil, status: EphemerisStatus? = nil) {
            self.creationTime = creationTime
            self.enabled = enabled
            self.ephemerisId = ephemerisId
            self.name = name
            self.priority = priority
            self.sourceS3Object = sourceS3Object
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case creationTime
            case enabled
            case ephemerisId
            case name
            case priority
            case sourceS3Object
            case status
        }
    }

    public struct EphemerisMetaData: AWSDecodableShape {
        /// UUID of a customer-provided ephemeris. This field is not populated for default ephemerides from Space Track.
        public let ephemerisId: String?
        /// The epoch of a default, ephemeris from Space Track in UTC. This field is not populated for customer-provided ephemerides.
        public let epoch: Date?
        /// A name string associated with the ephemeris. Used as a human-readable identifier for the ephemeris. A name is only returned for customer-provider ephemerides that have a name associated.
        public let name: String?
        /// The EphemerisSource that generated a given ephemeris.
        public let source: EphemerisSource

        public init(ephemerisId: String? = nil, epoch: Date? = nil, name: String? = nil, source: EphemerisSource) {
            self.ephemerisId = ephemerisId
            self.epoch = epoch
            self.name = name
            self.source = source
        }

        private enum CodingKeys: String, CodingKey {
            case ephemerisId
            case epoch
            case name
            case source
        }
    }

    public struct Frequency: AWSEncodableShape & AWSDecodableShape {
        /// Frequency units.
        public let units: FrequencyUnits
        /// Frequency value. Valid values are between 2200 to 2300 MHz and 7750 to 8400 MHz for downlink and 2025 to 2120 MHz for uplink.
        public let value: Double

        public init(units: FrequencyUnits, value: Double) {
            self.units = units
            self.value = value
        }

        private enum CodingKeys: String, CodingKey {
            case units
            case value
        }
    }

    public struct FrequencyBandwidth: AWSEncodableShape & AWSDecodableShape {
        /// Frequency bandwidth units.
        public let units: BandwidthUnits
        /// Frequency bandwidth value. AWS Ground Station currently has the following bandwidth limitations:   For AntennaDownlinkDemodDecodeconfig, valid values are between 125 kHz to 650 MHz.   For AntennaDownlinkconfig, valid values are between 10 kHz to 54 MHz.   For AntennaUplinkConfig, valid values are between 10 kHz to 54 MHz.
        public let value: Double

        public init(units: BandwidthUnits, value: Double) {
            self.units = units
            self.value = value
        }

        private enum CodingKeys: String, CodingKey {
            case units
            case value
        }
    }

    public struct GetConfigRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "configId", location: .uri("configId")),
            AWSMemberEncoding(label: "configType", location: .uri("configType"))
        ]

        /// UUID of a Config.
        public let configId: String
        /// Type of a Config.
        public let configType: ConfigCapabilityType

        public init(configId: String, configType: ConfigCapabilityType) {
            self.configId = configId
            self.configType = configType
        }

        public func validate(name: String) throws {
            try self.validate(self.configId, name: "configId", parent: name, max: 128)
            try self.validate(self.configId, name: "configId", parent: name, min: 1)
            try self.validate(self.configId, name: "configId", parent: name, pattern: "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetConfigResponse: AWSDecodableShape {
        /// ARN of a Config
        public let configArn: String
        /// Data elements in a Config.
        public let configData: ConfigTypeData
        /// UUID of a Config.
        public let configId: String
        /// Type of a Config.
        public let configType: ConfigCapabilityType?
        /// Name of a Config.
        public let name: String
        /// Tags assigned to a Config.
        public let tags: [String: String]?

        public init(configArn: String, configData: ConfigTypeData, configId: String, configType: ConfigCapabilityType? = nil, name: String, tags: [String: String]? = nil) {
            self.configArn = configArn
            self.configData = configData
            self.configId = configId
            self.configType = configType
            self.name = name
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case configArn
            case configData
            case configId
            case configType
            case name
            case tags
        }
    }

    public struct GetDataflowEndpointGroupRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "dataflowEndpointGroupId", location: .uri("dataflowEndpointGroupId"))
        ]

        /// UUID of a dataflow endpoint group.
        public let dataflowEndpointGroupId: String

        public init(dataflowEndpointGroupId: String) {
            self.dataflowEndpointGroupId = dataflowEndpointGroupId
        }

        public func validate(name: String) throws {
            try self.validate(self.dataflowEndpointGroupId, name: "dataflowEndpointGroupId", parent: name, max: 128)
            try self.validate(self.dataflowEndpointGroupId, name: "dataflowEndpointGroupId", parent: name, min: 1)
            try self.validate(self.dataflowEndpointGroupId, name: "dataflowEndpointGroupId", parent: name, pattern: "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetDataflowEndpointGroupResponse: AWSDecodableShape {
        /// ARN of a dataflow endpoint group.
        public let dataflowEndpointGroupArn: String?
        /// UUID of a dataflow endpoint group.
        public let dataflowEndpointGroupId: String?
        /// Details of a dataflow endpoint.
        public let endpointsDetails: [EndpointDetails]?
        /// Tags assigned to a dataflow endpoint group.
        public let tags: [String: String]?

        public init(dataflowEndpointGroupArn: String? = nil, dataflowEndpointGroupId: String? = nil, endpointsDetails: [EndpointDetails]? = nil, tags: [String: String]? = nil) {
            self.dataflowEndpointGroupArn = dataflowEndpointGroupArn
            self.dataflowEndpointGroupId = dataflowEndpointGroupId
            self.endpointsDetails = endpointsDetails
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case dataflowEndpointGroupArn
            case dataflowEndpointGroupId
            case endpointsDetails
            case tags
        }
    }

    public struct GetMinuteUsageRequest: AWSEncodableShape {
        /// The month being requested, with a value of 1-12.
        public let month: Int
        /// The year being requested, in the format of YYYY.
        public let year: Int

        public init(month: Int, year: Int) {
            self.month = month
            self.year = year
        }

        public func validate(name: String) throws {
            try self.validate(self.month, name: "month", parent: name, max: 12)
            try self.validate(self.month, name: "month", parent: name, min: 1)
            try self.validate(self.year, name: "year", parent: name, max: 3000)
            try self.validate(self.year, name: "year", parent: name, min: 2018)
        }

        private enum CodingKeys: String, CodingKey {
            case month
            case year
        }
    }

    public struct GetMinuteUsageResponse: AWSDecodableShape {
        /// Estimated number of minutes remaining for an account, specific to the month being requested.
        public let estimatedMinutesRemaining: Int?
        /// Returns whether or not an account has signed up for the reserved minutes pricing plan, specific to the month being requested.
        public let isReservedMinutesCustomer: Bool?
        /// Total number of reserved minutes allocated, specific to the month being requested.
        public let totalReservedMinuteAllocation: Int?
        /// Total scheduled minutes for an account, specific to the month being requested.
        public let totalScheduledMinutes: Int?
        /// Upcoming minutes scheduled for an account, specific to the month being requested.
        public let upcomingMinutesScheduled: Int?

        public init(estimatedMinutesRemaining: Int? = nil, isReservedMinutesCustomer: Bool? = nil, totalReservedMinuteAllocation: Int? = nil, totalScheduledMinutes: Int? = nil, upcomingMinutesScheduled: Int? = nil) {
            self.estimatedMinutesRemaining = estimatedMinutesRemaining
            self.isReservedMinutesCustomer = isReservedMinutesCustomer
            self.totalReservedMinuteAllocation = totalReservedMinuteAllocation
            self.totalScheduledMinutes = totalScheduledMinutes
            self.upcomingMinutesScheduled = upcomingMinutesScheduled
        }

        private enum CodingKeys: String, CodingKey {
            case estimatedMinutesRemaining
            case isReservedMinutesCustomer
            case totalReservedMinuteAllocation
            case totalScheduledMinutes
            case upcomingMinutesScheduled
        }
    }

    public struct GetMissionProfileRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "missionProfileId", location: .uri("missionProfileId"))
        ]

        /// UUID of a mission profile.
        public let missionProfileId: String

        public init(missionProfileId: String) {
            self.missionProfileId = missionProfileId
        }

        public func validate(name: String) throws {
            try self.validate(self.missionProfileId, name: "missionProfileId", parent: name, max: 128)
            try self.validate(self.missionProfileId, name: "missionProfileId", parent: name, min: 1)
            try self.validate(self.missionProfileId, name: "missionProfileId", parent: name, pattern: "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetMissionProfileResponse: AWSDecodableShape {
        /// Amount of time after a contact ends that you’d like to receive a CloudWatch event indicating the pass has finished.
        public let contactPostPassDurationSeconds: Int?
        /// Amount of time prior to contact start you’d like to receive a CloudWatch event indicating an upcoming pass.
        public let contactPrePassDurationSeconds: Int?
        /// A list of lists of ARNs. Each list of ARNs is an edge, with a from  Config and a to  Config.
        public let dataflowEdges: [[String]]?
        /// Smallest amount of time in seconds that you’d like to see for an available contact. AWS Ground Station will not present you with contacts shorter than this duration.
        public let minimumViableContactDurationSeconds: Int?
        /// ARN of a mission profile.
        public let missionProfileArn: String?
        /// UUID of a mission profile.
        public let missionProfileId: String?
        /// Name of a mission profile.
        public let name: String?
        /// Region of a mission profile.
        public let region: String?
        /// Tags assigned to a mission profile.
        public let tags: [String: String]?
        /// ARN of a tracking Config.
        public let trackingConfigArn: String?

        public init(contactPostPassDurationSeconds: Int? = nil, contactPrePassDurationSeconds: Int? = nil, dataflowEdges: [[String]]? = nil, minimumViableContactDurationSeconds: Int? = nil, missionProfileArn: String? = nil, missionProfileId: String? = nil, name: String? = nil, region: String? = nil, tags: [String: String]? = nil, trackingConfigArn: String? = nil) {
            self.contactPostPassDurationSeconds = contactPostPassDurationSeconds
            self.contactPrePassDurationSeconds = contactPrePassDurationSeconds
            self.dataflowEdges = dataflowEdges
            self.minimumViableContactDurationSeconds = minimumViableContactDurationSeconds
            self.missionProfileArn = missionProfileArn
            self.missionProfileId = missionProfileId
            self.name = name
            self.region = region
            self.tags = tags
            self.trackingConfigArn = trackingConfigArn
        }

        private enum CodingKeys: String, CodingKey {
            case contactPostPassDurationSeconds
            case contactPrePassDurationSeconds
            case dataflowEdges
            case minimumViableContactDurationSeconds
            case missionProfileArn
            case missionProfileId
            case name
            case region
            case tags
            case trackingConfigArn
        }
    }

    public struct GetSatelliteRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "satelliteId", location: .uri("satelliteId"))
        ]

        /// UUID of a satellite.
        public let satelliteId: String

        public init(satelliteId: String) {
            self.satelliteId = satelliteId
        }

        public func validate(name: String) throws {
            try self.validate(self.satelliteId, name: "satelliteId", parent: name, max: 128)
            try self.validate(self.satelliteId, name: "satelliteId", parent: name, min: 1)
            try self.validate(self.satelliteId, name: "satelliteId", parent: name, pattern: "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetSatelliteResponse: AWSDecodableShape {
        /// The current ephemeris being used to compute the trajectory of the satellite.
        public let currentEphemeris: EphemerisMetaData?
        /// A list of ground stations to which the satellite is on-boarded.
        public let groundStations: [String]?
        /// NORAD satellite ID number.
        public let noradSatelliteID: Int?
        /// ARN of a satellite.
        public let satelliteArn: String?
        /// UUID of a satellite.
        public let satelliteId: String?

        public init(currentEphemeris: EphemerisMetaData? = nil, groundStations: [String]? = nil, noradSatelliteID: Int? = nil, satelliteArn: String? = nil, satelliteId: String? = nil) {
            self.currentEphemeris = currentEphemeris
            self.groundStations = groundStations
            self.noradSatelliteID = noradSatelliteID
            self.satelliteArn = satelliteArn
            self.satelliteId = satelliteId
        }

        private enum CodingKeys: String, CodingKey {
            case currentEphemeris
            case groundStations
            case noradSatelliteID
            case satelliteArn
            case satelliteId
        }
    }

    public struct GroundStationData: AWSDecodableShape {
        /// UUID of a ground station.
        public let groundStationId: String?
        /// Name of a ground station.
        public let groundStationName: String?
        /// Ground station Region.
        public let region: String?

        public init(groundStationId: String? = nil, groundStationName: String? = nil, region: String? = nil) {
            self.groundStationId = groundStationId
            self.groundStationName = groundStationName
            self.region = region
        }

        private enum CodingKeys: String, CodingKey {
            case groundStationId
            case groundStationName
            case region
        }
    }

    public struct ListConfigsRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "maxResults", location: .querystring("maxResults")),
            AWSMemberEncoding(label: "nextToken", location: .querystring("nextToken"))
        ]

        /// Maximum number of Configs returned.
        public let maxResults: Int?
        /// Next token returned in the request of a previous ListConfigs call. Used to get the next page of results.
        public let nextToken: String?

        public init(maxResults: Int? = nil, nextToken: String? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 0)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 1000)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 3)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^[A-Za-z0-9-/+_.=]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListConfigsResponse: AWSDecodableShape {
        /// List of Config items.
        public let configList: [ConfigListItem]?
        /// Next token returned in the response of a previous ListConfigs call. Used to get the next page of results.
        public let nextToken: String?

        public init(configList: [ConfigListItem]? = nil, nextToken: String? = nil) {
            self.configList = configList
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case configList
            case nextToken
        }
    }

    public struct ListContactsRequest: AWSEncodableShape {
        /// End time of a contact in UTC.
        public let endTime: Date
        /// Name of a ground station.
        public let groundStation: String?
        /// Maximum number of contacts returned.
        public let maxResults: Int?
        /// ARN of a mission profile.
        public let missionProfileArn: String?
        /// Next token returned in the request of a previous ListContacts call. Used to get the next page of results.
        public let nextToken: String?
        /// ARN of a satellite.
        public let satelliteArn: String?
        /// Start time of a contact in UTC.
        public let startTime: Date
        /// Status of a contact reservation.
        public let statusList: [ContactStatus]

        public init(endTime: Date, groundStation: String? = nil, maxResults: Int? = nil, missionProfileArn: String? = nil, nextToken: String? = nil, satelliteArn: String? = nil, startTime: Date, statusList: [ContactStatus]) {
            self.endTime = endTime
            self.groundStation = groundStation
            self.maxResults = maxResults
            self.missionProfileArn = missionProfileArn
            self.nextToken = nextToken
            self.satelliteArn = satelliteArn
            self.startTime = startTime
            self.statusList = statusList
        }

        public func validate(name: String) throws {
            try self.validate(self.groundStation, name: "groundStation", parent: name, max: 500)
            try self.validate(self.groundStation, name: "groundStation", parent: name, min: 4)
            try self.validate(self.groundStation, name: "groundStation", parent: name, pattern: "^[ a-zA-Z0-9-._:=]{4,256}$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 0)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 1000)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 3)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^[A-Za-z0-9-/+_.=]+$")
            try self.validate(self.statusList, name: "statusList", parent: name, max: 500)
        }

        private enum CodingKeys: String, CodingKey {
            case endTime
            case groundStation
            case maxResults
            case missionProfileArn
            case nextToken
            case satelliteArn
            case startTime
            case statusList
        }
    }

    public struct ListContactsResponse: AWSDecodableShape {
        /// List of contacts.
        public let contactList: [ContactData]?
        /// Next token returned in the response of a previous ListContacts call. Used to get the next page of results.
        public let nextToken: String?

        public init(contactList: [ContactData]? = nil, nextToken: String? = nil) {
            self.contactList = contactList
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case contactList
            case nextToken
        }
    }

    public struct ListDataflowEndpointGroupsRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "maxResults", location: .querystring("maxResults")),
            AWSMemberEncoding(label: "nextToken", location: .querystring("nextToken"))
        ]

        /// Maximum number of dataflow endpoint groups returned.
        public let maxResults: Int?
        /// Next token returned in the request of a previous ListDataflowEndpointGroups call. Used to get the next page of results.
        public let nextToken: String?

        public init(maxResults: Int? = nil, nextToken: String? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 0)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 1000)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 3)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^[A-Za-z0-9-/+_.=]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListDataflowEndpointGroupsResponse: AWSDecodableShape {
        /// A list of dataflow endpoint groups.
        public let dataflowEndpointGroupList: [DataflowEndpointListItem]?
        /// Next token returned in the response of a previous ListDataflowEndpointGroups call. Used to get the next page of results.
        public let nextToken: String?

        public init(dataflowEndpointGroupList: [DataflowEndpointListItem]? = nil, nextToken: String? = nil) {
            self.dataflowEndpointGroupList = dataflowEndpointGroupList
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case dataflowEndpointGroupList
            case nextToken
        }
    }

    public struct ListEphemeridesRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "maxResults", location: .querystring("maxResults")),
            AWSMemberEncoding(label: "nextToken", location: .querystring("nextToken"))
        ]

        /// The end time to list in UTC. The operation will return an ephemeris if its expiration time is within the time range defined by the startTime and endTime.
        public let endTime: Date
        /// Maximum number of ephemerides to return.
        public let maxResults: Int?
        /// Pagination token.
        public let nextToken: String?
        /// The AWS Ground Station satellite ID to list ephemeris for.
        public let satelliteId: String
        /// The start time to list in UTC. The operation will return an ephemeris if its expiration time is within the time range defined by the startTime and endTime.
        public let startTime: Date
        /// The list of ephemeris status to return.
        public let statusList: [EphemerisStatus]?

        public init(endTime: Date, maxResults: Int? = nil, nextToken: String? = nil, satelliteId: String, startTime: Date, statusList: [EphemerisStatus]? = nil) {
            self.endTime = endTime
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.satelliteId = satelliteId
            self.startTime = startTime
            self.statusList = statusList
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 0)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 1000)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 3)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^[A-Za-z0-9-/+_.=]+$")
            try self.validate(self.satelliteId, name: "satelliteId", parent: name, max: 128)
            try self.validate(self.satelliteId, name: "satelliteId", parent: name, min: 1)
            try self.validate(self.satelliteId, name: "satelliteId", parent: name, pattern: "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$")
            try self.validate(self.statusList, name: "statusList", parent: name, max: 500)
        }

        private enum CodingKeys: String, CodingKey {
            case endTime
            case satelliteId
            case startTime
            case statusList
        }
    }

    public struct ListEphemeridesResponse: AWSDecodableShape {
        /// List of ephemerides.
        public let ephemerides: [EphemerisItem]?
        /// Pagination token.
        public let nextToken: String?

        public init(ephemerides: [EphemerisItem]? = nil, nextToken: String? = nil) {
            self.ephemerides = ephemerides
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case ephemerides
            case nextToken
        }
    }

    public struct ListGroundStationsRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "maxResults", location: .querystring("maxResults")),
            AWSMemberEncoding(label: "nextToken", location: .querystring("nextToken")),
            AWSMemberEncoding(label: "satelliteId", location: .querystring("satelliteId"))
        ]

        /// Maximum number of ground stations returned.
        public let maxResults: Int?
        /// Next token that can be supplied in the next call to get the next page of ground stations.
        public let nextToken: String?
        /// Satellite ID to retrieve on-boarded ground stations.
        public let satelliteId: String?

        public init(maxResults: Int? = nil, nextToken: String? = nil, satelliteId: String? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.satelliteId = satelliteId
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 0)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 1000)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 3)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^[A-Za-z0-9-/+_.=]+$")
            try self.validate(self.satelliteId, name: "satelliteId", parent: name, max: 128)
            try self.validate(self.satelliteId, name: "satelliteId", parent: name, min: 1)
            try self.validate(self.satelliteId, name: "satelliteId", parent: name, pattern: "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListGroundStationsResponse: AWSDecodableShape {
        /// List of ground stations.
        public let groundStationList: [GroundStationData]?
        /// Next token that can be supplied in the next call to get the next page of ground stations.
        public let nextToken: String?

        public init(groundStationList: [GroundStationData]? = nil, nextToken: String? = nil) {
            self.groundStationList = groundStationList
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case groundStationList
            case nextToken
        }
    }

    public struct ListMissionProfilesRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "maxResults", location: .querystring("maxResults")),
            AWSMemberEncoding(label: "nextToken", location: .querystring("nextToken"))
        ]

        /// Maximum number of mission profiles returned.
        public let maxResults: Int?
        /// Next token returned in the request of a previous ListMissionProfiles call. Used to get the next page of results.
        public let nextToken: String?

        public init(maxResults: Int? = nil, nextToken: String? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 0)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 1000)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 3)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^[A-Za-z0-9-/+_.=]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListMissionProfilesResponse: AWSDecodableShape {
        /// List of mission profiles.
        public let missionProfileList: [MissionProfileListItem]?
        /// Next token returned in the response of a previous ListMissionProfiles call. Used to get the next page of results.
        public let nextToken: String?

        public init(missionProfileList: [MissionProfileListItem]? = nil, nextToken: String? = nil) {
            self.missionProfileList = missionProfileList
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case missionProfileList
            case nextToken
        }
    }

    public struct ListSatellitesRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "maxResults", location: .querystring("maxResults")),
            AWSMemberEncoding(label: "nextToken", location: .querystring("nextToken"))
        ]

        /// Maximum number of satellites returned.
        public let maxResults: Int?
        /// Next token that can be supplied in the next call to get the next page of satellites.
        public let nextToken: String?

        public init(maxResults: Int? = nil, nextToken: String? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 0)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 1000)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 3)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^[A-Za-z0-9-/+_.=]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListSatellitesResponse: AWSDecodableShape {
        /// Next token that can be supplied in the next call to get the next page of satellites.
        public let nextToken: String?
        /// List of satellites.
        public let satellites: [SatelliteListItem]?

        public init(nextToken: String? = nil, satellites: [SatelliteListItem]? = nil) {
            self.nextToken = nextToken
            self.satellites = satellites
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken
            case satellites
        }
    }

    public struct ListTagsForResourceRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "resourceArn", location: .uri("resourceArn"))
        ]

        /// ARN of a resource.
        public let resourceArn: String

        public init(resourceArn: String) {
            self.resourceArn = resourceArn
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, max: 1024)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, min: 5)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, pattern: "^(arn:aws:)[\\s\\S]{0,1024}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListTagsForResourceResponse: AWSDecodableShape {
        /// Tags assigned to a resource.
        public let tags: [String: String]?

        public init(tags: [String: String]? = nil) {
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case tags
        }
    }

    public struct MissionProfileIdResponse: AWSDecodableShape {
        /// UUID of a mission profile.
        public let missionProfileId: String?

        public init(missionProfileId: String? = nil) {
            self.missionProfileId = missionProfileId
        }

        private enum CodingKeys: String, CodingKey {
            case missionProfileId
        }
    }

    public struct MissionProfileListItem: AWSDecodableShape {
        /// ARN of a mission profile.
        public let missionProfileArn: String?
        /// UUID of a mission profile.
        public let missionProfileId: String?
        /// Name of a mission profile.
        public let name: String?
        /// Region of a mission profile.
        public let region: String?

        public init(missionProfileArn: String? = nil, missionProfileId: String? = nil, name: String? = nil, region: String? = nil) {
            self.missionProfileArn = missionProfileArn
            self.missionProfileId = missionProfileId
            self.name = name
            self.region = region
        }

        private enum CodingKeys: String, CodingKey {
            case missionProfileArn
            case missionProfileId
            case name
            case region
        }
    }

    public struct OEMEphemeris: AWSEncodableShape {
        /// The data for an OEM ephemeris, supplied directly in the request rather than through an S3 object.
        public let oemData: String?
        /// Identifies the S3 object to be used as the ephemeris.
        public let s3Object: S3Object?

        public init(oemData: String? = nil, s3Object: S3Object? = nil) {
            self.oemData = oemData
            self.s3Object = s3Object
        }

        public func validate(name: String) throws {
            try self.validate(self.oemData, name: "oemData", parent: name, min: 1)
            try self.validate(self.oemData, name: "oemData", parent: name, pattern: "^[\\s\\S]+$")
            try self.s3Object?.validate(name: "\(name).s3Object")
        }

        private enum CodingKeys: String, CodingKey {
            case oemData
            case s3Object
        }
    }

    public struct ReserveContactRequest: AWSEncodableShape {
        /// End time of a contact in UTC.
        public let endTime: Date
        /// Name of a ground station.
        public let groundStation: String
        /// ARN of a mission profile.
        public let missionProfileArn: String
        /// ARN of a satellite
        public let satelliteArn: String
        /// Start time of a contact in UTC.
        public let startTime: Date
        /// Tags assigned to a contact.
        public let tags: [String: String]?

        public init(endTime: Date, groundStation: String, missionProfileArn: String, satelliteArn: String, startTime: Date, tags: [String: String]? = nil) {
            self.endTime = endTime
            self.groundStation = groundStation
            self.missionProfileArn = missionProfileArn
            self.satelliteArn = satelliteArn
            self.startTime = startTime
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.validate(self.groundStation, name: "groundStation", parent: name, max: 500)
            try self.validate(self.groundStation, name: "groundStation", parent: name, min: 4)
            try self.validate(self.groundStation, name: "groundStation", parent: name, pattern: "^[ a-zA-Z0-9-._:=]{4,256}$")
        }

        private enum CodingKeys: String, CodingKey {
            case endTime
            case groundStation
            case missionProfileArn
            case satelliteArn
            case startTime
            case tags
        }
    }

    public struct S3Object: AWSEncodableShape & AWSDecodableShape {
        /// An Amazon S3 Bucket name.
        public let bucket: String?
        /// An Amazon S3 key for the ephemeris.
        public let key: String?
        /// For versioned S3 objects, the version to use for the ephemeris.
        public let version: String?

        public init(bucket: String? = nil, key: String? = nil, version: String? = nil) {
            self.bucket = bucket
            self.key = key
            self.version = version
        }

        public func validate(name: String) throws {
            try self.validate(self.bucket, name: "bucket", parent: name, max: 63)
            try self.validate(self.bucket, name: "bucket", parent: name, min: 3)
            try self.validate(self.bucket, name: "bucket", parent: name, pattern: "^[a-z0-9.-]{3,63}$")
            try self.validate(self.key, name: "key", parent: name, max: 1024)
            try self.validate(self.key, name: "key", parent: name, min: 1)
            try self.validate(self.key, name: "key", parent: name, pattern: "^[a-zA-Z0-9!*'\\)\\(./_-]{1,1024}$")
            try self.validate(self.version, name: "version", parent: name, max: 1024)
            try self.validate(self.version, name: "version", parent: name, min: 1)
            try self.validate(self.version, name: "version", parent: name, pattern: "^[\\s\\S]{1,1024}$")
        }

        private enum CodingKeys: String, CodingKey {
            case bucket
            case key
            case version
        }
    }

    public struct S3RecordingConfig: AWSEncodableShape & AWSDecodableShape {
        /// ARN of the bucket to record to.
        public let bucketArn: String
        /// S3 Key prefix to prefice data files.
        public let prefix: String?
        /// ARN of the role Ground Station assumes to write data to the bucket.
        public let roleArn: String

        public init(bucketArn: String, prefix: String? = nil, roleArn: String) {
            self.bucketArn = bucketArn
            self.prefix = prefix
            self.roleArn = roleArn
        }

        public func validate(name: String) throws {
            try self.validate(self.prefix, name: "prefix", parent: name, max: 900)
            try self.validate(self.prefix, name: "prefix", parent: name, min: 1)
            try self.validate(self.prefix, name: "prefix", parent: name, pattern: "^([a-zA-Z0-9_\\-=/]|\\{satellite_id\\}|\\{config\\-name}|\\{s3\\-config-id}|\\{year\\}|\\{month\\}|\\{day\\}){1,900}$")
        }

        private enum CodingKeys: String, CodingKey {
            case bucketArn
            case prefix
            case roleArn
        }
    }

    public struct S3RecordingDetails: AWSDecodableShape {
        /// ARN of the bucket used.
        public let bucketArn: String?
        /// Key template used for the S3 Recording Configuration
        public let keyTemplate: String?

        public init(bucketArn: String? = nil, keyTemplate: String? = nil) {
            self.bucketArn = bucketArn
            self.keyTemplate = keyTemplate
        }

        private enum CodingKeys: String, CodingKey {
            case bucketArn
            case keyTemplate
        }
    }

    public struct SatelliteListItem: AWSDecodableShape {
        /// The current ephemeris being used to compute the trajectory of the satellite.
        public let currentEphemeris: EphemerisMetaData?
        /// A list of ground stations to which the satellite is on-boarded.
        public let groundStations: [String]?
        /// NORAD satellite ID number.
        public let noradSatelliteID: Int?
        /// ARN of a satellite.
        public let satelliteArn: String?
        /// UUID of a satellite.
        public let satelliteId: String?

        public init(currentEphemeris: EphemerisMetaData? = nil, groundStations: [String]? = nil, noradSatelliteID: Int? = nil, satelliteArn: String? = nil, satelliteId: String? = nil) {
            self.currentEphemeris = currentEphemeris
            self.groundStations = groundStations
            self.noradSatelliteID = noradSatelliteID
            self.satelliteArn = satelliteArn
            self.satelliteId = satelliteId
        }

        private enum CodingKeys: String, CodingKey {
            case currentEphemeris
            case groundStations
            case noradSatelliteID
            case satelliteArn
            case satelliteId
        }
    }

    public struct SecurityDetails: AWSEncodableShape & AWSDecodableShape {
        /// ARN to a role needed for connecting streams to your instances.
        public let roleArn: String
        /// The security groups to attach to the elastic network interfaces.
        public let securityGroupIds: [String]
        /// A list of subnets where AWS Ground Station places elastic network interfaces to send streams to your instances.
        public let subnetIds: [String]

        public init(roleArn: String, securityGroupIds: [String], subnetIds: [String]) {
            self.roleArn = roleArn
            self.securityGroupIds = securityGroupIds
            self.subnetIds = subnetIds
        }

        private enum CodingKeys: String, CodingKey {
            case roleArn
            case securityGroupIds
            case subnetIds
        }
    }

    public struct SocketAddress: AWSEncodableShape & AWSDecodableShape {
        /// Name of a socket address.
        public let name: String
        /// Port of a socket address.
        public let port: Int

        public init(name: String, port: Int) {
            self.name = name
            self.port = port
        }

        private enum CodingKeys: String, CodingKey {
            case name
            case port
        }
    }

    public struct Source: AWSDecodableShape {
        /// Additional details for a Config, if type is dataflow-endpoint or antenna-downlink-demod-decode
        public let configDetails: ConfigDetails?
        /// UUID of a Config.
        public let configId: String?
        /// Type of a Config.
        public let configType: ConfigCapabilityType?
        /// Region of a dataflow source.
        public let dataflowSourceRegion: String?

        public init(configDetails: ConfigDetails? = nil, configId: String? = nil, configType: ConfigCapabilityType? = nil, dataflowSourceRegion: String? = nil) {
            self.configDetails = configDetails
            self.configId = configId
            self.configType = configType
            self.dataflowSourceRegion = dataflowSourceRegion
        }

        private enum CodingKeys: String, CodingKey {
            case configDetails
            case configId
            case configType
            case dataflowSourceRegion
        }
    }

    public struct SpectrumConfig: AWSEncodableShape & AWSDecodableShape {
        /// Bandwidth of a spectral Config. AWS Ground Station currently has the following bandwidth limitations:   For AntennaDownlinkDemodDecodeconfig, valid values are between 125 kHz to 650 MHz.   For AntennaDownlinkconfig valid values are between 10 kHz to 54 MHz.   For AntennaUplinkConfig, valid values are between 10 kHz to 54 MHz.
        public let bandwidth: FrequencyBandwidth
        /// Center frequency of a spectral Config. Valid values are between 2200 to 2300 MHz and 7750 to 8400 MHz for downlink and 2025 to 2120 MHz for uplink.
        public let centerFrequency: Frequency
        /// Polarization of a spectral Config. Capturing both "RIGHT_HAND" and "LEFT_HAND" polarization requires two separate configs.
        public let polarization: Polarization?

        public init(bandwidth: FrequencyBandwidth, centerFrequency: Frequency, polarization: Polarization? = nil) {
            self.bandwidth = bandwidth
            self.centerFrequency = centerFrequency
            self.polarization = polarization
        }

        private enum CodingKeys: String, CodingKey {
            case bandwidth
            case centerFrequency
            case polarization
        }
    }

    public struct TLEData: AWSEncodableShape {
        /// First line of two-line element set (TLE) data.
        public let tleLine1: String
        /// Second line of two-line element set (TLE) data.
        public let tleLine2: String
        /// The valid time range for the TLE. Gaps or overlap are not permitted.
        public let validTimeRange: TimeRange

        public init(tleLine1: String, tleLine2: String, validTimeRange: TimeRange) {
            self.tleLine1 = tleLine1
            self.tleLine2 = tleLine2
            self.validTimeRange = validTimeRange
        }

        public func validate(name: String) throws {
            try self.validate(self.tleLine1, name: "tleLine1", parent: name, max: 69)
            try self.validate(self.tleLine1, name: "tleLine1", parent: name, min: 69)
            try self.validate(self.tleLine1, name: "tleLine1", parent: name, pattern: "^1 [ 0-9]{5}[A-Z] [ 0-9]{5}[ A-Z]{3} [ 0-9]{5}[.][ 0-9]{8} (?:(?:[ 0+-][.][ 0-9]{8})|(?: [ +-][.][ 0-9]{7})) [ +-][ 0-9]{5}[+-][ 0-9] [ +-][ 0-9]{5}[+-][ 0-9] [ 0-9] [ 0-9]{4}[ 0-9]$")
            try self.validate(self.tleLine2, name: "tleLine2", parent: name, max: 69)
            try self.validate(self.tleLine2, name: "tleLine2", parent: name, min: 69)
            try self.validate(self.tleLine2, name: "tleLine2", parent: name, pattern: "^2 [ 0-9]{5} [ 0-9]{3}[.][ 0-9]{4} [ 0-9]{3}[.][ 0-9]{4} [ 0-9]{7} [ 0-9]{3}[.][ 0-9]{4} [ 0-9]{3}[.][ 0-9]{4} [ 0-9]{2}[.][ 0-9]{13}[ 0-9]$")
        }

        private enum CodingKeys: String, CodingKey {
            case tleLine1
            case tleLine2
            case validTimeRange
        }
    }

    public struct TLEEphemeris: AWSEncodableShape {
        /// Identifies the S3 object to be used as the ephemeris.
        public let s3Object: S3Object?
        /// The data for a TLE ephemeris, supplied directly in the request rather than through an S3 object.
        public let tleData: [TLEData]?

        public init(s3Object: S3Object? = nil, tleData: [TLEData]? = nil) {
            self.s3Object = s3Object
            self.tleData = tleData
        }

        public func validate(name: String) throws {
            try self.s3Object?.validate(name: "\(name).s3Object")
            try self.tleData?.forEach {
                try $0.validate(name: "\(name).tleData[]")
            }
            try self.validate(self.tleData, name: "tleData", parent: name, max: 500)
            try self.validate(self.tleData, name: "tleData", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case s3Object
            case tleData
        }
    }

    public struct TagResourceRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "resourceArn", location: .uri("resourceArn"))
        ]

        /// ARN of a resource tag.
        public let resourceArn: String
        /// Tags assigned to a resource.
        public let tags: [String: String]

        public init(resourceArn: String, tags: [String: String]) {
            self.resourceArn = resourceArn
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, max: 1024)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, min: 5)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, pattern: "^(arn:aws:)[\\s\\S]{0,1024}$")
        }

        private enum CodingKeys: String, CodingKey {
            case tags
        }
    }

    public struct TagResourceResponse: AWSDecodableShape {
        public init() {}
    }

    public struct TimeRange: AWSEncodableShape {
        /// Time in UTC at which the time range ends.
        public let endTime: Date
        /// Time in UTC at which the time range starts.
        public let startTime: Date

        public init(endTime: Date, startTime: Date) {
            self.endTime = endTime
            self.startTime = startTime
        }

        private enum CodingKeys: String, CodingKey {
            case endTime
            case startTime
        }
    }

    public struct TrackingConfig: AWSEncodableShape & AWSDecodableShape {
        /// Current setting for autotrack.
        public let autotrack: Criticality

        public init(autotrack: Criticality) {
            self.autotrack = autotrack
        }

        private enum CodingKeys: String, CodingKey {
            case autotrack
        }
    }

    public struct UntagResourceRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "resourceArn", location: .uri("resourceArn")),
            AWSMemberEncoding(label: "tagKeys", location: .querystring("tagKeys"))
        ]

        /// ARN of a resource.
        public let resourceArn: String
        /// Keys of a resource tag.
        public let tagKeys: [String]

        public init(resourceArn: String, tagKeys: [String]) {
            self.resourceArn = resourceArn
            self.tagKeys = tagKeys
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, max: 1024)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, min: 5)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, pattern: "^(arn:aws:)[\\s\\S]{0,1024}$")
            try self.tagKeys.forEach {
                try validate($0, name: "tagKeys[]", parent: name, min: 1)
                try validate($0, name: "tagKeys[]", parent: name, pattern: "^[\\s\\S]+$")
            }
            try self.validate(self.tagKeys, name: "tagKeys", parent: name, max: 500)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct UntagResourceResponse: AWSDecodableShape {
        public init() {}
    }

    public struct UpdateConfigRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "configId", location: .uri("configId")),
            AWSMemberEncoding(label: "configType", location: .uri("configType"))
        ]

        /// Parameters of a Config.
        public let configData: ConfigTypeData
        /// UUID of a Config.
        public let configId: String
        /// Type of a Config.
        public let configType: ConfigCapabilityType
        /// Name of a Config.
        public let name: String

        public init(configData: ConfigTypeData, configId: String, configType: ConfigCapabilityType, name: String) {
            self.configData = configData
            self.configId = configId
            self.configType = configType
            self.name = name
        }

        public func validate(name: String) throws {
            try self.configData.validate(name: "\(name).configData")
            try self.validate(self.configId, name: "configId", parent: name, max: 128)
            try self.validate(self.configId, name: "configId", parent: name, min: 1)
            try self.validate(self.configId, name: "configId", parent: name, pattern: "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$")
            try self.validate(self.name, name: "name", parent: name, max: 256)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[ a-zA-Z0-9_:-]{1,256}$")
        }

        private enum CodingKeys: String, CodingKey {
            case configData
            case name
        }
    }

    public struct UpdateEphemerisRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "ephemerisId", location: .uri("ephemerisId"))
        ]

        /// Whether the ephemeris is enabled or not. Changing this value will not require the ephemeris to be re-validated.
        public let enabled: Bool
        /// The AWS Ground Station ephemeris ID.
        public let ephemerisId: String
        /// A name string associated with the ephemeris. Used as a human-readable identifier for the ephemeris.
        public let name: String?
        /// Customer-provided priority score to establish the order in which overlapping ephemerides should be used. The default for customer-provided ephemeris priority is 1, and higher numbers take precedence. Priority must be 1 or greater
        public let priority: Int?

        public init(enabled: Bool, ephemerisId: String, name: String? = nil, priority: Int? = nil) {
            self.enabled = enabled
            self.ephemerisId = ephemerisId
            self.name = name
            self.priority = priority
        }

        public func validate(name: String) throws {
            try self.validate(self.ephemerisId, name: "ephemerisId", parent: name, max: 128)
            try self.validate(self.ephemerisId, name: "ephemerisId", parent: name, min: 1)
            try self.validate(self.ephemerisId, name: "ephemerisId", parent: name, pattern: "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$")
            try self.validate(self.name, name: "name", parent: name, max: 256)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[ a-zA-Z0-9_:-]{1,256}$")
            try self.validate(self.priority, name: "priority", parent: name, max: 99999)
            try self.validate(self.priority, name: "priority", parent: name, min: 0)
        }

        private enum CodingKeys: String, CodingKey {
            case enabled
            case name
            case priority
        }
    }

    public struct UpdateMissionProfileRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "missionProfileId", location: .uri("missionProfileId"))
        ]

        /// Amount of time after a contact ends that you’d like to receive a CloudWatch event indicating the pass has finished.
        public let contactPostPassDurationSeconds: Int?
        /// Amount of time after a contact ends that you’d like to receive a CloudWatch event indicating the pass has finished.
        public let contactPrePassDurationSeconds: Int?
        /// A list of lists of ARNs. Each list of ARNs is an edge, with a from  Config and a to  Config.
        public let dataflowEdges: [[String]]?
        /// Smallest amount of time in seconds that you’d like to see for an available contact. AWS Ground Station will not present you with contacts shorter than this duration.
        public let minimumViableContactDurationSeconds: Int?
        /// UUID of a mission profile.
        public let missionProfileId: String
        /// Name of a mission profile.
        public let name: String?
        /// ARN of a tracking Config.
        public let trackingConfigArn: String?

        public init(contactPostPassDurationSeconds: Int? = nil, contactPrePassDurationSeconds: Int? = nil, dataflowEdges: [[String]]? = nil, minimumViableContactDurationSeconds: Int? = nil, missionProfileId: String, name: String? = nil, trackingConfigArn: String? = nil) {
            self.contactPostPassDurationSeconds = contactPostPassDurationSeconds
            self.contactPrePassDurationSeconds = contactPrePassDurationSeconds
            self.dataflowEdges = dataflowEdges
            self.minimumViableContactDurationSeconds = minimumViableContactDurationSeconds
            self.missionProfileId = missionProfileId
            self.name = name
            self.trackingConfigArn = trackingConfigArn
        }

        public func validate(name: String) throws {
            try self.validate(self.contactPostPassDurationSeconds, name: "contactPostPassDurationSeconds", parent: name, max: 21600)
            try self.validate(self.contactPostPassDurationSeconds, name: "contactPostPassDurationSeconds", parent: name, min: 0)
            try self.validate(self.contactPrePassDurationSeconds, name: "contactPrePassDurationSeconds", parent: name, max: 21600)
            try self.validate(self.contactPrePassDurationSeconds, name: "contactPrePassDurationSeconds", parent: name, min: 0)
            try self.dataflowEdges?.forEach {
                try validate($0, name: "dataflowEdges[]", parent: name, max: 2)
                try validate($0, name: "dataflowEdges[]", parent: name, min: 2)
            }
            try self.validate(self.dataflowEdges, name: "dataflowEdges", parent: name, max: 500)
            try self.validate(self.minimumViableContactDurationSeconds, name: "minimumViableContactDurationSeconds", parent: name, max: 21600)
            try self.validate(self.minimumViableContactDurationSeconds, name: "minimumViableContactDurationSeconds", parent: name, min: 1)
            try self.validate(self.missionProfileId, name: "missionProfileId", parent: name, max: 128)
            try self.validate(self.missionProfileId, name: "missionProfileId", parent: name, min: 1)
            try self.validate(self.missionProfileId, name: "missionProfileId", parent: name, pattern: "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$")
            try self.validate(self.name, name: "name", parent: name, max: 256)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[ a-zA-Z0-9_:-]{1,256}$")
        }

        private enum CodingKeys: String, CodingKey {
            case contactPostPassDurationSeconds
            case contactPrePassDurationSeconds
            case dataflowEdges
            case minimumViableContactDurationSeconds
            case name
            case trackingConfigArn
        }
    }

    public struct UplinkEchoConfig: AWSEncodableShape & AWSDecodableShape {
        /// ARN of an uplink Config.
        public let antennaUplinkConfigArn: String
        /// Whether or not an uplink Config is enabled.
        public let enabled: Bool

        public init(antennaUplinkConfigArn: String, enabled: Bool) {
            self.antennaUplinkConfigArn = antennaUplinkConfigArn
            self.enabled = enabled
        }

        private enum CodingKeys: String, CodingKey {
            case antennaUplinkConfigArn
            case enabled
        }
    }

    public struct UplinkSpectrumConfig: AWSEncodableShape & AWSDecodableShape {
        /// Center frequency of an uplink spectral Config. Valid values are between 2025 to 2120 MHz.
        public let centerFrequency: Frequency
        /// Polarization of an uplink spectral Config. Capturing both "RIGHT_HAND" and "LEFT_HAND" polarization requires two separate configs.
        public let polarization: Polarization?

        public init(centerFrequency: Frequency, polarization: Polarization? = nil) {
            self.centerFrequency = centerFrequency
            self.polarization = polarization
        }

        private enum CodingKeys: String, CodingKey {
            case centerFrequency
            case polarization
        }
    }
}

// MARK: - Errors

/// Error enum for GroundStation
public struct GroundStationErrorType: AWSErrorType {
    enum Code: String {
        case dependencyException = "DependencyException"
        case invalidParameterException = "InvalidParameterException"
        case resourceLimitExceededException = "ResourceLimitExceededException"
        case resourceNotFoundException = "ResourceNotFoundException"
    }

    private let error: Code
    public let context: AWSErrorContext?

    /// initialize GroundStation
    public init?(errorCode: String, context: AWSErrorContext) {
        guard let error = Code(rawValue: errorCode) else { return nil }
        self.error = error
        self.context = context
    }

    internal init(_ error: Code) {
        self.error = error
        self.context = nil
    }

    /// return error code string
    public var errorCode: String { self.error.rawValue }

    /// Dependency encountered an error.
    public static var dependencyException: Self { .init(.dependencyException) }
    /// One or more parameters are not valid.
    public static var invalidParameterException: Self { .init(.invalidParameterException) }
    /// Account limits for this resource have been exceeded.
    public static var resourceLimitExceededException: Self { .init(.resourceLimitExceededException) }
    /// Resource was not found.
    public static var resourceNotFoundException: Self { .init(.resourceNotFoundException) }
}

extension GroundStationErrorType: Equatable {
    public static func == (lhs: GroundStationErrorType, rhs: GroundStationErrorType) -> Bool {
        lhs.error == rhs.error
    }
}

extension GroundStationErrorType: CustomStringConvertible {
    public var description: String {
        return "\(self.error.rawValue): \(self.message ?? "")"
    }
}
