//===----------------------------------------------------------------------===//
//
// This source file is part of the Soto for AWS open source project
//
// Copyright (c) 2017-2024 the Soto project authors
// Licensed under Apache License v2.0
//
// See LICENSE.txt for license information
// See CONTRIBUTORS.txt for the list of Soto project authors
//
// SPDX-License-Identifier: Apache-2.0
//
//===----------------------------------------------------------------------===//

// THIS FILE IS AUTOMATICALLY GENERATED by https://github.com/soto-project/soto-codegenerator.
// DO NOT EDIT.

#if canImport(FoundationEssentials)
import FoundationEssentials
#else
import Foundation
#endif
@_spi(SotoInternal) import SotoCore

extension GroundStation {
    // MARK: Enums

    public enum AgentStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case active = "ACTIVE"
        case failed = "FAILED"
        case inactive = "INACTIVE"
        case success = "SUCCESS"
        public var description: String { return self.rawValue }
    }

    public enum AngleUnits: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case degreeAngle = "DEGREE_ANGLE"
        case radian = "RADIAN"
        public var description: String { return self.rawValue }
    }

    public enum AuditResults: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case healthy = "HEALTHY"
        case unhealthy = "UNHEALTHY"
        public var description: String { return self.rawValue }
    }

    public enum BandwidthUnits: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case ghz = "GHz"
        case khz = "kHz"
        case mhz = "MHz"
        public var description: String { return self.rawValue }
    }

    public enum CapabilityHealth: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case healthy = "HEALTHY"
        case unhealthy = "UNHEALTHY"
        public var description: String { return self.rawValue }
    }

    public enum CapabilityHealthReason: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case dataplaneFailure = "DATAPLANE_FAILURE"
        case healthy = "HEALTHY"
        case initializingDataplane = "INITIALIZING_DATAPLANE"
        case invalidIpOwnership = "INVALID_IP_OWNERSHIP"
        case noRegisteredAgent = "NO_REGISTERED_AGENT"
        case notAuthorizedToCreateSlr = "NOT_AUTHORIZED_TO_CREATE_SLR"
        case unverifiedIpOwnership = "UNVERIFIED_IP_OWNERSHIP"
        public var description: String { return self.rawValue }
    }

    public enum ConfigCapabilityType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case antennaDownlink = "antenna-downlink"
        case antennaDownlinkDemodDecode = "antenna-downlink-demod-decode"
        case antennaUplink = "antenna-uplink"
        case dataflowEndpoint = "dataflow-endpoint"
        case s3Recording = "s3-recording"
        case tracking = "tracking"
        case uplinkEcho = "uplink-echo"
        public var description: String { return self.rawValue }
    }

    public enum ContactStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case available = "AVAILABLE"
        case awsCancelled = "AWS_CANCELLED"
        case awsFailed = "AWS_FAILED"
        case cancelled = "CANCELLED"
        case cancelling = "CANCELLING"
        case completed = "COMPLETED"
        case failed = "FAILED"
        case failedToSchedule = "FAILED_TO_SCHEDULE"
        case pass = "PASS"
        case postpass = "POSTPASS"
        case prepass = "PREPASS"
        case scheduled = "SCHEDULED"
        case scheduling = "SCHEDULING"
        public var description: String { return self.rawValue }
    }

    public enum Criticality: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case preferred = "PREFERRED"
        case removed = "REMOVED"
        case required = "REQUIRED"
        public var description: String { return self.rawValue }
    }

    public enum EirpUnits: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case dbw = "dBW"
        public var description: String { return self.rawValue }
    }

    public enum EndpointStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case created = "created"
        case creating = "creating"
        case deleted = "deleted"
        case deleting = "deleting"
        case failed = "failed"
        public var description: String { return self.rawValue }
    }

    public enum EphemerisInvalidReason: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        /// Provided KMS key is invalid
        case kmsKeyInvalid = "KMS_KEY_INVALID"
        /// Provided spacecraft identifiers such as spacecraft NORAD Id are invalid
        case metadataInvalid = "METADATA_INVALID"
        /// Start, end, or expiration time(s) are invalid for the provided ephemeris
        case timeRangeInvalid = "TIME_RANGE_INVALID"
        /// Provided ephemeris defines invalid spacecraft trajectory
        case trajectoryInvalid = "TRAJECTORY_INVALID"
        /// Internal Service Error occurred while processing ephemeris
        case validationError = "VALIDATION_ERROR"
        public var description: String { return self.rawValue }
    }

    public enum EphemerisSource: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case customerProvided = "CUSTOMER_PROVIDED"
        case spaceTrack = "SPACE_TRACK"
        public var description: String { return self.rawValue }
    }

    public enum EphemerisStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case disabled = "DISABLED"
        case enabled = "ENABLED"
        case error = "ERROR"
        case expired = "EXPIRED"
        case invalid = "INVALID"
        case validating = "VALIDATING"
        public var description: String { return self.rawValue }
    }

    public enum FrequencyUnits: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case ghz = "GHz"
        case khz = "kHz"
        case mhz = "MHz"
        public var description: String { return self.rawValue }
    }

    public enum Polarization: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case leftHand = "LEFT_HAND"
        case none = "NONE"
        case rightHand = "RIGHT_HAND"
        public var description: String { return self.rawValue }
    }

    public enum ConfigDetails: AWSDecodableShape, Sendable {
        /// Details for antenna demod decode Config in a contact.
        case antennaDemodDecodeDetails(AntennaDemodDecodeDetails)
        case endpointDetails(EndpointDetails)
        /// Details for an S3 recording Config in a contact.
        case s3RecordingDetails(S3RecordingDetails)

        public init(from decoder: Decoder) throws {
            let container = try decoder.container(keyedBy: CodingKeys.self)
            guard container.allKeys.count == 1, let key = container.allKeys.first else {
                let context = DecodingError.Context(
                    codingPath: container.codingPath,
                    debugDescription: "Expected exactly one key, but got \(container.allKeys.count)"
                )
                throw DecodingError.dataCorrupted(context)
            }
            switch key {
            case .antennaDemodDecodeDetails:
                let value = try container.decode(AntennaDemodDecodeDetails.self, forKey: .antennaDemodDecodeDetails)
                self = .antennaDemodDecodeDetails(value)
            case .endpointDetails:
                let value = try container.decode(EndpointDetails.self, forKey: .endpointDetails)
                self = .endpointDetails(value)
            case .s3RecordingDetails:
                let value = try container.decode(S3RecordingDetails.self, forKey: .s3RecordingDetails)
                self = .s3RecordingDetails(value)
            }
        }

        private enum CodingKeys: String, CodingKey {
            case antennaDemodDecodeDetails = "antennaDemodDecodeDetails"
            case endpointDetails = "endpointDetails"
            case s3RecordingDetails = "s3RecordingDetails"
        }
    }

    public enum ConfigTypeData: AWSEncodableShape & AWSDecodableShape, Sendable {
        /// Information about how AWS Ground Station should configure an antenna for downlink during a contact.
        case antennaDownlinkConfig(AntennaDownlinkConfig)
        /// Information about how AWS Ground Station should conﬁgure an antenna for downlink demod decode during a contact.
        case antennaDownlinkDemodDecodeConfig(AntennaDownlinkDemodDecodeConfig)
        /// Information about how AWS Ground Station should conﬁgure an antenna for uplink during a contact.
        case antennaUplinkConfig(AntennaUplinkConfig)
        /// Information about the dataflow endpoint Config.
        case dataflowEndpointConfig(DataflowEndpointConfig)
        /// Information about an S3 recording Config.
        case s3RecordingConfig(S3RecordingConfig)
        /// Object that determines whether tracking should be used during a contact executed with this Config in the mission profile.
        case trackingConfig(TrackingConfig)
        /// Information about an uplink echo Config. Parameters from the AntennaUplinkConfig, corresponding to the specified AntennaUplinkConfigArn, are used when this UplinkEchoConfig is used in a contact.
        case uplinkEchoConfig(UplinkEchoConfig)

        public init(from decoder: Decoder) throws {
            let container = try decoder.container(keyedBy: CodingKeys.self)
            guard container.allKeys.count == 1, let key = container.allKeys.first else {
                let context = DecodingError.Context(
                    codingPath: container.codingPath,
                    debugDescription: "Expected exactly one key, but got \(container.allKeys.count)"
                )
                throw DecodingError.dataCorrupted(context)
            }
            switch key {
            case .antennaDownlinkConfig:
                let value = try container.decode(AntennaDownlinkConfig.self, forKey: .antennaDownlinkConfig)
                self = .antennaDownlinkConfig(value)
            case .antennaDownlinkDemodDecodeConfig:
                let value = try container.decode(AntennaDownlinkDemodDecodeConfig.self, forKey: .antennaDownlinkDemodDecodeConfig)
                self = .antennaDownlinkDemodDecodeConfig(value)
            case .antennaUplinkConfig:
                let value = try container.decode(AntennaUplinkConfig.self, forKey: .antennaUplinkConfig)
                self = .antennaUplinkConfig(value)
            case .dataflowEndpointConfig:
                let value = try container.decode(DataflowEndpointConfig.self, forKey: .dataflowEndpointConfig)
                self = .dataflowEndpointConfig(value)
            case .s3RecordingConfig:
                let value = try container.decode(S3RecordingConfig.self, forKey: .s3RecordingConfig)
                self = .s3RecordingConfig(value)
            case .trackingConfig:
                let value = try container.decode(TrackingConfig.self, forKey: .trackingConfig)
                self = .trackingConfig(value)
            case .uplinkEchoConfig:
                let value = try container.decode(UplinkEchoConfig.self, forKey: .uplinkEchoConfig)
                self = .uplinkEchoConfig(value)
            }
        }

        public func encode(to encoder: Encoder) throws {
            var container = encoder.container(keyedBy: CodingKeys.self)
            switch self {
            case .antennaDownlinkConfig(let value):
                try container.encode(value, forKey: .antennaDownlinkConfig)
            case .antennaDownlinkDemodDecodeConfig(let value):
                try container.encode(value, forKey: .antennaDownlinkDemodDecodeConfig)
            case .antennaUplinkConfig(let value):
                try container.encode(value, forKey: .antennaUplinkConfig)
            case .dataflowEndpointConfig(let value):
                try container.encode(value, forKey: .dataflowEndpointConfig)
            case .s3RecordingConfig(let value):
                try container.encode(value, forKey: .s3RecordingConfig)
            case .trackingConfig(let value):
                try container.encode(value, forKey: .trackingConfig)
            case .uplinkEchoConfig(let value):
                try container.encode(value, forKey: .uplinkEchoConfig)
            }
        }

        public func validate(name: String) throws {
            switch self {
            case .antennaDownlinkDemodDecodeConfig(let value):
                try value.validate(name: "\(name).antennaDownlinkDemodDecodeConfig")
            case .s3RecordingConfig(let value):
                try value.validate(name: "\(name).s3RecordingConfig")
            case .uplinkEchoConfig(let value):
                try value.validate(name: "\(name).uplinkEchoConfig")
            default:
                break
            }
        }

        private enum CodingKeys: String, CodingKey {
            case antennaDownlinkConfig = "antennaDownlinkConfig"
            case antennaDownlinkDemodDecodeConfig = "antennaDownlinkDemodDecodeConfig"
            case antennaUplinkConfig = "antennaUplinkConfig"
            case dataflowEndpointConfig = "dataflowEndpointConfig"
            case s3RecordingConfig = "s3RecordingConfig"
            case trackingConfig = "trackingConfig"
            case uplinkEchoConfig = "uplinkEchoConfig"
        }
    }

    public enum EphemerisData: AWSEncodableShape, Sendable {
        case oem(OEMEphemeris)
        case tle(TLEEphemeris)

        public func encode(to encoder: Encoder) throws {
            var container = encoder.container(keyedBy: CodingKeys.self)
            switch self {
            case .oem(let value):
                try container.encode(value, forKey: .oem)
            case .tle(let value):
                try container.encode(value, forKey: .tle)
            }
        }

        public func validate(name: String) throws {
            switch self {
            case .oem(let value):
                try value.validate(name: "\(name).oem")
            case .tle(let value):
                try value.validate(name: "\(name).tle")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case oem = "oem"
            case tle = "tle"
        }
    }

    public enum EphemerisTypeDescription: AWSDecodableShape, Sendable {
        case oem(EphemerisDescription)
        case tle(EphemerisDescription)

        public init(from decoder: Decoder) throws {
            let container = try decoder.container(keyedBy: CodingKeys.self)
            guard container.allKeys.count == 1, let key = container.allKeys.first else {
                let context = DecodingError.Context(
                    codingPath: container.codingPath,
                    debugDescription: "Expected exactly one key, but got \(container.allKeys.count)"
                )
                throw DecodingError.dataCorrupted(context)
            }
            switch key {
            case .oem:
                let value = try container.decode(EphemerisDescription.self, forKey: .oem)
                self = .oem(value)
            case .tle:
                let value = try container.decode(EphemerisDescription.self, forKey: .tle)
                self = .tle(value)
            }
        }

        private enum CodingKeys: String, CodingKey {
            case oem = "oem"
            case tle = "tle"
        }
    }

    public enum KmsKey: AWSEncodableShape & AWSDecodableShape, Sendable {
        /// KMS Alias Arn.
        case kmsAliasArn(String)
        /// KMS Alias Name.
        case kmsAliasName(String)
        /// KMS Key Arn.
        case kmsKeyArn(String)

        public init(from decoder: Decoder) throws {
            let container = try decoder.container(keyedBy: CodingKeys.self)
            guard container.allKeys.count == 1, let key = container.allKeys.first else {
                let context = DecodingError.Context(
                    codingPath: container.codingPath,
                    debugDescription: "Expected exactly one key, but got \(container.allKeys.count)"
                )
                throw DecodingError.dataCorrupted(context)
            }
            switch key {
            case .kmsAliasArn:
                let value = try container.decode(String.self, forKey: .kmsAliasArn)
                self = .kmsAliasArn(value)
            case .kmsAliasName:
                let value = try container.decode(String.self, forKey: .kmsAliasName)
                self = .kmsAliasName(value)
            case .kmsKeyArn:
                let value = try container.decode(String.self, forKey: .kmsKeyArn)
                self = .kmsKeyArn(value)
            }
        }

        public func encode(to encoder: Encoder) throws {
            var container = encoder.container(keyedBy: CodingKeys.self)
            switch self {
            case .kmsAliasArn(let value):
                try container.encode(value, forKey: .kmsAliasArn)
            case .kmsAliasName(let value):
                try container.encode(value, forKey: .kmsAliasName)
            case .kmsKeyArn(let value):
                try container.encode(value, forKey: .kmsKeyArn)
            }
        }

        public func validate(name: String) throws {
            switch self {
            case .kmsAliasArn(let value):
                try self.validate(value, name: "kmsAliasArn", parent: name, max: 512)
                try self.validate(value, name: "kmsAliasArn", parent: name, min: 1)
                try self.validate(value, name: "kmsAliasArn", parent: name, pattern: "^arn:aws[a-zA-Z-]{0,16}:kms:[-a-z0-9]{1,50}:[0-9]{12}:((alias/[a-zA-Z0-9:/_-]{1,256}))$")
            case .kmsAliasName(let value):
                try self.validate(value, name: "kmsAliasName", parent: name, max: 256)
                try self.validate(value, name: "kmsAliasName", parent: name, min: 1)
                try self.validate(value, name: "kmsAliasName", parent: name, pattern: "^alias/[a-zA-Z0-9:/_-]+$")
            default:
                break
            }
        }

        private enum CodingKeys: String, CodingKey {
            case kmsAliasArn = "kmsAliasArn"
            case kmsAliasName = "kmsAliasName"
            case kmsKeyArn = "kmsKeyArn"
        }
    }

    // MARK: Shapes

    public struct AgentDetails: AWSEncodableShape {
        /// List of CPU cores reserved for the agent.
        public let agentCpuCores: [Int]?
        /// Current agent version.
        public let agentVersion: String
        /// List of versions being used by agent components.
        public let componentVersions: [ComponentVersion]
        /// ID of EC2 instance agent is running on.
        public let instanceId: String
        /// Type of EC2 instance agent is running on.
        public let instanceType: String
        ///  This field should not be used. Use agentCpuCores instead.  List of CPU cores reserved for processes other than the agent running on the EC2 instance.
        public let reservedCpuCores: [Int]?

        @inlinable
        public init(agentCpuCores: [Int]? = nil, agentVersion: String, componentVersions: [ComponentVersion], instanceId: String, instanceType: String, reservedCpuCores: [Int]? = nil) {
            self.agentCpuCores = agentCpuCores
            self.agentVersion = agentVersion
            self.componentVersions = componentVersions
            self.instanceId = instanceId
            self.instanceType = instanceType
            self.reservedCpuCores = reservedCpuCores
        }

        public func validate(name: String) throws {
            try self.validate(self.agentCpuCores, name: "agentCpuCores", parent: name, max: 256)
            try self.validate(self.agentVersion, name: "agentVersion", parent: name, max: 64)
            try self.validate(self.agentVersion, name: "agentVersion", parent: name, min: 1)
            try self.validate(self.agentVersion, name: "agentVersion", parent: name, pattern: "^(0|[1-9]\\d*)(\\.(0|[1-9]\\d*))*$")
            try self.componentVersions.forEach {
                try $0.validate(name: "\(name).componentVersions[]")
            }
            try self.validate(self.componentVersions, name: "componentVersions", parent: name, max: 20)
            try self.validate(self.componentVersions, name: "componentVersions", parent: name, min: 1)
            try self.validate(self.instanceId, name: "instanceId", parent: name, max: 64)
            try self.validate(self.instanceId, name: "instanceId", parent: name, min: 10)
            try self.validate(self.instanceId, name: "instanceId", parent: name, pattern: "^[a-z0-9-]{10,64}$")
            try self.validate(self.instanceType, name: "instanceType", parent: name, max: 64)
            try self.validate(self.instanceType, name: "instanceType", parent: name, min: 1)
            try self.validate(self.instanceType, name: "instanceType", parent: name, pattern: "^[a-z0-9.-]{1,64}$")
            try self.validate(self.reservedCpuCores, name: "reservedCpuCores", parent: name, max: 256)
        }

        private enum CodingKeys: String, CodingKey {
            case agentCpuCores = "agentCpuCores"
            case agentVersion = "agentVersion"
            case componentVersions = "componentVersions"
            case instanceId = "instanceId"
            case instanceType = "instanceType"
            case reservedCpuCores = "reservedCpuCores"
        }
    }

    public struct AggregateStatus: AWSEncodableShape {
        /// Sparse map of failure signatures.
        public let signatureMap: [String: Bool]?
        /// Aggregate status.
        public let status: AgentStatus

        @inlinable
        public init(signatureMap: [String: Bool]? = nil, status: AgentStatus) {
            self.signatureMap = signatureMap
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case signatureMap = "signatureMap"
            case status = "status"
        }
    }

    public struct AntennaDemodDecodeDetails: AWSDecodableShape {
        /// Name of an antenna demod decode output node used in a contact.
        public let outputNode: String?

        @inlinable
        public init(outputNode: String? = nil) {
            self.outputNode = outputNode
        }

        private enum CodingKeys: String, CodingKey {
            case outputNode = "outputNode"
        }
    }

    public struct AntennaDownlinkConfig: AWSEncodableShape & AWSDecodableShape {
        /// Object that describes a spectral Config.
        public let spectrumConfig: SpectrumConfig

        @inlinable
        public init(spectrumConfig: SpectrumConfig) {
            self.spectrumConfig = spectrumConfig
        }

        private enum CodingKeys: String, CodingKey {
            case spectrumConfig = "spectrumConfig"
        }
    }

    public struct AntennaDownlinkDemodDecodeConfig: AWSEncodableShape & AWSDecodableShape {
        /// Information about the decode Config.
        public let decodeConfig: DecodeConfig
        /// Information about the demodulation Config.
        public let demodulationConfig: DemodulationConfig
        /// Information about the spectral Config.
        public let spectrumConfig: SpectrumConfig

        @inlinable
        public init(decodeConfig: DecodeConfig, demodulationConfig: DemodulationConfig, spectrumConfig: SpectrumConfig) {
            self.decodeConfig = decodeConfig
            self.demodulationConfig = demodulationConfig
            self.spectrumConfig = spectrumConfig
        }

        public func validate(name: String) throws {
            try self.decodeConfig.validate(name: "\(name).decodeConfig")
            try self.demodulationConfig.validate(name: "\(name).demodulationConfig")
        }

        private enum CodingKeys: String, CodingKey {
            case decodeConfig = "decodeConfig"
            case demodulationConfig = "demodulationConfig"
            case spectrumConfig = "spectrumConfig"
        }
    }

    public struct AntennaUplinkConfig: AWSEncodableShape & AWSDecodableShape {
        /// Information about the uplink spectral Config.
        public let spectrumConfig: UplinkSpectrumConfig
        /// EIRP of the target.
        public let targetEirp: Eirp
        /// Whether or not uplink transmit is disabled.
        public let transmitDisabled: Bool?

        @inlinable
        public init(spectrumConfig: UplinkSpectrumConfig, targetEirp: Eirp, transmitDisabled: Bool? = nil) {
            self.spectrumConfig = spectrumConfig
            self.targetEirp = targetEirp
            self.transmitDisabled = transmitDisabled
        }

        private enum CodingKeys: String, CodingKey {
            case spectrumConfig = "spectrumConfig"
            case targetEirp = "targetEirp"
            case transmitDisabled = "transmitDisabled"
        }
    }

    public struct AwsGroundStationAgentEndpoint: AWSEncodableShape & AWSDecodableShape {
        /// The status of AgentEndpoint.
        public let agentStatus: AgentStatus?
        /// The results of the audit.
        public let auditResults: AuditResults?
        /// The egress address of AgentEndpoint.
        public let egressAddress: ConnectionDetails
        /// The ingress address of AgentEndpoint.
        public let ingressAddress: RangedConnectionDetails
        /// Name string associated with AgentEndpoint. Used as a human-readable identifier for AgentEndpoint.
        public let name: String

        @inlinable
        public init(agentStatus: AgentStatus? = nil, auditResults: AuditResults? = nil, egressAddress: ConnectionDetails, ingressAddress: RangedConnectionDetails, name: String) {
            self.agentStatus = agentStatus
            self.auditResults = auditResults
            self.egressAddress = egressAddress
            self.ingressAddress = ingressAddress
            self.name = name
        }

        public func validate(name: String) throws {
            try self.ingressAddress.validate(name: "\(name).ingressAddress")
            try self.validate(self.name, name: "name", parent: name, max: 256)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[ a-zA-Z0-9_:-]{1,256}$")
        }

        private enum CodingKeys: String, CodingKey {
            case agentStatus = "agentStatus"
            case auditResults = "auditResults"
            case egressAddress = "egressAddress"
            case ingressAddress = "ingressAddress"
            case name = "name"
        }
    }

    public struct CancelContactRequest: AWSEncodableShape {
        /// UUID of a contact.
        public let contactId: String

        @inlinable
        public init(contactId: String) {
            self.contactId = contactId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.contactId, key: "contactId")
        }

        public func validate(name: String) throws {
            try self.validate(self.contactId, name: "contactId", parent: name, max: 36)
            try self.validate(self.contactId, name: "contactId", parent: name, min: 36)
            try self.validate(self.contactId, name: "contactId", parent: name, pattern: "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ComponentStatusData: AWSEncodableShape {
        /// Bytes received by the component.
        public let bytesReceived: Int64?
        /// Bytes sent by the component.
        public let bytesSent: Int64?
        /// Capability ARN of the component.
        public let capabilityArn: String
        /// The Component type.
        public let componentType: String
        /// Dataflow UUID associated with the component.
        public let dataflowId: String
        /// Packets dropped by component.
        public let packetsDropped: Int64?
        /// Component status.
        public let status: AgentStatus

        @inlinable
        public init(bytesReceived: Int64? = nil, bytesSent: Int64? = nil, capabilityArn: String, componentType: String, dataflowId: String, packetsDropped: Int64? = nil, status: AgentStatus) {
            self.bytesReceived = bytesReceived
            self.bytesSent = bytesSent
            self.capabilityArn = capabilityArn
            self.componentType = componentType
            self.dataflowId = dataflowId
            self.packetsDropped = packetsDropped
            self.status = status
        }

        public func validate(name: String) throws {
            try self.validate(self.componentType, name: "componentType", parent: name, pattern: "^[a-zA-Z0-9_]{1,64}$")
            try self.validate(self.dataflowId, name: "dataflowId", parent: name, max: 36)
            try self.validate(self.dataflowId, name: "dataflowId", parent: name, min: 36)
            try self.validate(self.dataflowId, name: "dataflowId", parent: name, pattern: "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$")
        }

        private enum CodingKeys: String, CodingKey {
            case bytesReceived = "bytesReceived"
            case bytesSent = "bytesSent"
            case capabilityArn = "capabilityArn"
            case componentType = "componentType"
            case dataflowId = "dataflowId"
            case packetsDropped = "packetsDropped"
            case status = "status"
        }
    }

    public struct ComponentVersion: AWSEncodableShape {
        /// Component type.
        public let componentType: String
        /// List of versions.
        public let versions: [String]

        @inlinable
        public init(componentType: String, versions: [String]) {
            self.componentType = componentType
            self.versions = versions
        }

        public func validate(name: String) throws {
            try self.validate(self.componentType, name: "componentType", parent: name, pattern: "^[a-zA-Z0-9_]{1,64}$")
            try self.versions.forEach {
                try validate($0, name: "versions[]", parent: name, max: 64)
                try validate($0, name: "versions[]", parent: name, min: 1)
                try validate($0, name: "versions[]", parent: name, pattern: "^(0|[1-9]\\d*)(\\.(0|[1-9]\\d*))*$")
            }
            try self.validate(self.versions, name: "versions", parent: name, max: 20)
            try self.validate(self.versions, name: "versions", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case componentType = "componentType"
            case versions = "versions"
        }
    }

    public struct ConfigIdResponse: AWSDecodableShape {
        /// ARN of a Config.
        public let configArn: String?
        /// UUID of a Config.
        public let configId: String?
        /// Type of a Config.
        public let configType: ConfigCapabilityType?

        @inlinable
        public init(configArn: String? = nil, configId: String? = nil, configType: ConfigCapabilityType? = nil) {
            self.configArn = configArn
            self.configId = configId
            self.configType = configType
        }

        private enum CodingKeys: String, CodingKey {
            case configArn = "configArn"
            case configId = "configId"
            case configType = "configType"
        }
    }

    public struct ConfigListItem: AWSDecodableShape {
        /// ARN of a Config.
        public let configArn: String?
        /// UUID of a Config.
        public let configId: String?
        /// Type of a Config.
        public let configType: ConfigCapabilityType?
        /// Name of a Config.
        public let name: String?

        @inlinable
        public init(configArn: String? = nil, configId: String? = nil, configType: ConfigCapabilityType? = nil, name: String? = nil) {
            self.configArn = configArn
            self.configId = configId
            self.configType = configType
            self.name = name
        }

        private enum CodingKeys: String, CodingKey {
            case configArn = "configArn"
            case configId = "configId"
            case configType = "configType"
            case name = "name"
        }
    }

    public struct ConnectionDetails: AWSEncodableShape & AWSDecodableShape {
        /// Maximum transmission unit (MTU) size in bytes of a dataflow endpoint.
        public let mtu: Int?
        /// A socket address.
        public let socketAddress: SocketAddress

        @inlinable
        public init(mtu: Int? = nil, socketAddress: SocketAddress) {
            self.mtu = mtu
            self.socketAddress = socketAddress
        }

        private enum CodingKeys: String, CodingKey {
            case mtu = "mtu"
            case socketAddress = "socketAddress"
        }
    }

    public struct ContactData: AWSDecodableShape {
        /// UUID of a contact.
        public let contactId: String?
        /// Status of a contact.
        public let contactStatus: ContactStatus?
        /// End time of a contact in UTC.
        public let endTime: Date?
        /// Error message of a contact.
        public let errorMessage: String?
        /// Name of a ground station.
        public let groundStation: String?
        /// Maximum elevation angle of a contact.
        public let maximumElevation: Elevation?
        /// ARN of a mission profile.
        public let missionProfileArn: String?
        /// Amount of time after a contact ends that you’d like to receive a CloudWatch event indicating the pass has finished.
        public let postPassEndTime: Date?
        /// Amount of time prior to contact start you’d like to receive a CloudWatch event indicating an upcoming pass.
        public let prePassStartTime: Date?
        /// Region of a contact.
        public let region: String?
        /// ARN of a satellite.
        public let satelliteArn: String?
        /// Start time of a contact in UTC.
        public let startTime: Date?
        /// Tags assigned to a contact.
        public let tags: [String: String]?
        ///  Projected time in UTC your satellite will set below the receive mask. This time is based on the satellite's current active ephemeris for future contacts and the ephemeris that was active during contact execution for completed contacts. This field is not present for contacts with a SCHEDULING or SCHEDULED status.
        public let visibilityEndTime: Date?
        ///  Projected time in UTC your satellite will rise above the receive mask. This time is based on the satellite's current active ephemeris for future contacts and the ephemeris that was active during contact execution for completed contacts. This field is not present for contacts with a SCHEDULING or SCHEDULED status.
        public let visibilityStartTime: Date?

        @inlinable
        public init(contactId: String? = nil, contactStatus: ContactStatus? = nil, endTime: Date? = nil, errorMessage: String? = nil, groundStation: String? = nil, maximumElevation: Elevation? = nil, missionProfileArn: String? = nil, postPassEndTime: Date? = nil, prePassStartTime: Date? = nil, region: String? = nil, satelliteArn: String? = nil, startTime: Date? = nil, tags: [String: String]? = nil, visibilityEndTime: Date? = nil, visibilityStartTime: Date? = nil) {
            self.contactId = contactId
            self.contactStatus = contactStatus
            self.endTime = endTime
            self.errorMessage = errorMessage
            self.groundStation = groundStation
            self.maximumElevation = maximumElevation
            self.missionProfileArn = missionProfileArn
            self.postPassEndTime = postPassEndTime
            self.prePassStartTime = prePassStartTime
            self.region = region
            self.satelliteArn = satelliteArn
            self.startTime = startTime
            self.tags = tags
            self.visibilityEndTime = visibilityEndTime
            self.visibilityStartTime = visibilityStartTime
        }

        private enum CodingKeys: String, CodingKey {
            case contactId = "contactId"
            case contactStatus = "contactStatus"
            case endTime = "endTime"
            case errorMessage = "errorMessage"
            case groundStation = "groundStation"
            case maximumElevation = "maximumElevation"
            case missionProfileArn = "missionProfileArn"
            case postPassEndTime = "postPassEndTime"
            case prePassStartTime = "prePassStartTime"
            case region = "region"
            case satelliteArn = "satelliteArn"
            case startTime = "startTime"
            case tags = "tags"
            case visibilityEndTime = "visibilityEndTime"
            case visibilityStartTime = "visibilityStartTime"
        }
    }

    public struct ContactIdResponse: AWSDecodableShape {
        /// UUID of a contact.
        public let contactId: String?

        @inlinable
        public init(contactId: String? = nil) {
            self.contactId = contactId
        }

        private enum CodingKeys: String, CodingKey {
            case contactId = "contactId"
        }
    }

    public struct CreateConfigRequest: AWSEncodableShape {
        /// Parameters of a Config.
        public let configData: ConfigTypeData
        /// Name of a Config.
        public let name: String
        /// Tags assigned to a Config.
        public let tags: [String: String]?

        @inlinable
        public init(configData: ConfigTypeData, name: String, tags: [String: String]? = nil) {
            self.configData = configData
            self.name = name
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.configData.validate(name: "\(name).configData")
            try self.validate(self.name, name: "name", parent: name, max: 256)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[ a-zA-Z0-9_:-]{1,256}$")
        }

        private enum CodingKeys: String, CodingKey {
            case configData = "configData"
            case name = "name"
            case tags = "tags"
        }
    }

    public struct CreateDataflowEndpointGroupRequest: AWSEncodableShape {
        /// Amount of time, in seconds, after a contact ends that the Ground Station Dataflow Endpoint Group will be in a POSTPASS state. A Ground Station Dataflow Endpoint Group State Change event will be emitted when the Dataflow Endpoint Group enters and exits the POSTPASS state.
        public let contactPostPassDurationSeconds: Int?
        /// Amount of time, in seconds, before a contact starts that the Ground Station Dataflow Endpoint Group will be in a PREPASS state. A Ground Station Dataflow Endpoint Group State Change event will be emitted when the Dataflow Endpoint Group enters and exits the PREPASS state.
        public let contactPrePassDurationSeconds: Int?
        /// Endpoint details of each endpoint in the dataflow endpoint group.
        ///  All dataflow endpoints within a single dataflow endpoint group must be of the same type. You cannot mix  AWS Ground Station Agent endpoints with Dataflow endpoints in the same group. If your use case requires both types of endpoints, you must create separate dataflow endpoint groups for each type.
        public let endpointDetails: [EndpointDetails]
        /// Tags of a dataflow endpoint group.
        public let tags: [String: String]?

        @inlinable
        public init(contactPostPassDurationSeconds: Int? = nil, contactPrePassDurationSeconds: Int? = nil, endpointDetails: [EndpointDetails], tags: [String: String]? = nil) {
            self.contactPostPassDurationSeconds = contactPostPassDurationSeconds
            self.contactPrePassDurationSeconds = contactPrePassDurationSeconds
            self.endpointDetails = endpointDetails
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.validate(self.contactPostPassDurationSeconds, name: "contactPostPassDurationSeconds", parent: name, max: 480)
            try self.validate(self.contactPostPassDurationSeconds, name: "contactPostPassDurationSeconds", parent: name, min: 120)
            try self.validate(self.contactPrePassDurationSeconds, name: "contactPrePassDurationSeconds", parent: name, max: 480)
            try self.validate(self.contactPrePassDurationSeconds, name: "contactPrePassDurationSeconds", parent: name, min: 120)
            try self.endpointDetails.forEach {
                try $0.validate(name: "\(name).endpointDetails[]")
            }
            try self.validate(self.endpointDetails, name: "endpointDetails", parent: name, max: 500)
        }

        private enum CodingKeys: String, CodingKey {
            case contactPostPassDurationSeconds = "contactPostPassDurationSeconds"
            case contactPrePassDurationSeconds = "contactPrePassDurationSeconds"
            case endpointDetails = "endpointDetails"
            case tags = "tags"
        }
    }

    public struct CreateEphemerisRequest: AWSEncodableShape {
        /// Whether to set the ephemeris status to ENABLED after validation. Setting this to false will set the ephemeris status to DISABLED after validation.
        public let enabled: Bool?
        /// Ephemeris data.
        public let ephemeris: EphemerisData?
        /// An overall expiration time for the ephemeris in UTC, after which it will become EXPIRED.
        public let expirationTime: Date?
        /// The ARN of a KMS key used to encrypt the ephemeris in Ground Station.
        public let kmsKeyArn: String?
        /// A name string associated with the ephemeris. Used as a human-readable identifier for the ephemeris.
        public let name: String
        /// Customer-provided priority score to establish the order in which overlapping ephemerides should be used. The default for customer-provided ephemeris priority is 1, and higher numbers take precedence. Priority must be 1 or greater
        public let priority: Int?
        /// AWS Ground Station satellite ID for this ephemeris.
        public let satelliteId: String
        /// Tags assigned to an ephemeris.
        public let tags: [String: String]?

        @inlinable
        public init(enabled: Bool? = nil, ephemeris: EphemerisData? = nil, expirationTime: Date? = nil, kmsKeyArn: String? = nil, name: String, priority: Int? = nil, satelliteId: String, tags: [String: String]? = nil) {
            self.enabled = enabled
            self.ephemeris = ephemeris
            self.expirationTime = expirationTime
            self.kmsKeyArn = kmsKeyArn
            self.name = name
            self.priority = priority
            self.satelliteId = satelliteId
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.ephemeris?.validate(name: "\(name).ephemeris")
            try self.validate(self.name, name: "name", parent: name, max: 256)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[ a-zA-Z0-9_:-]{1,256}$")
            try self.validate(self.priority, name: "priority", parent: name, max: 99999)
            try self.validate(self.priority, name: "priority", parent: name, min: 1)
            try self.validate(self.satelliteId, name: "satelliteId", parent: name, max: 36)
            try self.validate(self.satelliteId, name: "satelliteId", parent: name, min: 36)
            try self.validate(self.satelliteId, name: "satelliteId", parent: name, pattern: "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$")
        }

        private enum CodingKeys: String, CodingKey {
            case enabled = "enabled"
            case ephemeris = "ephemeris"
            case expirationTime = "expirationTime"
            case kmsKeyArn = "kmsKeyArn"
            case name = "name"
            case priority = "priority"
            case satelliteId = "satelliteId"
            case tags = "tags"
        }
    }

    public struct CreateMissionProfileRequest: AWSEncodableShape {
        /// Amount of time after a contact ends that you’d like to receive a Ground Station Contact State Change event indicating the pass has finished.
        public let contactPostPassDurationSeconds: Int?
        /// Amount of time prior to contact start you’d like to receive a Ground Station Contact State Change event indicating an upcoming pass.
        public let contactPrePassDurationSeconds: Int?
        /// A list of lists of ARNs. Each list of ARNs is an edge, with a from Config and a to Config.
        public let dataflowEdges: [[String]]
        /// Smallest amount of time in seconds that you’d like to see for an available contact. AWS Ground Station will not present you with contacts shorter than this duration.
        public let minimumViableContactDurationSeconds: Int
        /// Name of a mission profile.
        public let name: String
        /// KMS key to use for encrypting streams.
        public let streamsKmsKey: KmsKey?
        /// Role to use for encrypting streams with KMS key.
        public let streamsKmsRole: String?
        /// Tags assigned to a mission profile.
        public let tags: [String: String]?
        /// ARN of a tracking Config.
        public let trackingConfigArn: String

        @inlinable
        public init(contactPostPassDurationSeconds: Int? = nil, contactPrePassDurationSeconds: Int? = nil, dataflowEdges: [[String]], minimumViableContactDurationSeconds: Int, name: String, streamsKmsKey: KmsKey? = nil, streamsKmsRole: String? = nil, tags: [String: String]? = nil, trackingConfigArn: String) {
            self.contactPostPassDurationSeconds = contactPostPassDurationSeconds
            self.contactPrePassDurationSeconds = contactPrePassDurationSeconds
            self.dataflowEdges = dataflowEdges
            self.minimumViableContactDurationSeconds = minimumViableContactDurationSeconds
            self.name = name
            self.streamsKmsKey = streamsKmsKey
            self.streamsKmsRole = streamsKmsRole
            self.tags = tags
            self.trackingConfigArn = trackingConfigArn
        }

        public func validate(name: String) throws {
            try self.validate(self.contactPostPassDurationSeconds, name: "contactPostPassDurationSeconds", parent: name, max: 21600)
            try self.validate(self.contactPostPassDurationSeconds, name: "contactPostPassDurationSeconds", parent: name, min: 0)
            try self.validate(self.contactPrePassDurationSeconds, name: "contactPrePassDurationSeconds", parent: name, max: 21600)
            try self.validate(self.contactPrePassDurationSeconds, name: "contactPrePassDurationSeconds", parent: name, min: 0)
            try self.dataflowEdges.forEach {
                try validate($0, name: "dataflowEdges[]", parent: name, max: 2)
                try validate($0, name: "dataflowEdges[]", parent: name, min: 2)
            }
            try self.validate(self.dataflowEdges, name: "dataflowEdges", parent: name, max: 500)
            try self.validate(self.minimumViableContactDurationSeconds, name: "minimumViableContactDurationSeconds", parent: name, max: 21600)
            try self.validate(self.minimumViableContactDurationSeconds, name: "minimumViableContactDurationSeconds", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, max: 256)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[ a-zA-Z0-9_:-]{1,256}$")
            try self.streamsKmsKey?.validate(name: "\(name).streamsKmsKey")
            try self.validate(self.trackingConfigArn, name: "trackingConfigArn", parent: name, max: 424)
            try self.validate(self.trackingConfigArn, name: "trackingConfigArn", parent: name, min: 82)
            try self.validate(self.trackingConfigArn, name: "trackingConfigArn", parent: name, pattern: "^arn:aws:groundstation:[-a-z0-9]{1,50}:[0-9]{12}:config/[a-z0-9]+(-[a-z0-9]+){0,4}/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}(/.{1,256})?$")
        }

        private enum CodingKeys: String, CodingKey {
            case contactPostPassDurationSeconds = "contactPostPassDurationSeconds"
            case contactPrePassDurationSeconds = "contactPrePassDurationSeconds"
            case dataflowEdges = "dataflowEdges"
            case minimumViableContactDurationSeconds = "minimumViableContactDurationSeconds"
            case name = "name"
            case streamsKmsKey = "streamsKmsKey"
            case streamsKmsRole = "streamsKmsRole"
            case tags = "tags"
            case trackingConfigArn = "trackingConfigArn"
        }
    }

    public struct DataflowDetail: AWSDecodableShape {
        public let destination: Destination?
        /// Error message for a dataflow.
        public let errorMessage: String?
        public let source: Source?

        @inlinable
        public init(destination: Destination? = nil, errorMessage: String? = nil, source: Source? = nil) {
            self.destination = destination
            self.errorMessage = errorMessage
            self.source = source
        }

        private enum CodingKeys: String, CodingKey {
            case destination = "destination"
            case errorMessage = "errorMessage"
            case source = "source"
        }
    }

    public struct DataflowEndpoint: AWSEncodableShape & AWSDecodableShape {
        /// Socket address of a dataflow endpoint.
        public let address: SocketAddress?
        /// Maximum transmission unit (MTU) size in bytes of a dataflow endpoint.
        public let mtu: Int?
        /// Name of a dataflow endpoint.
        public let name: String?
        /// Status of a dataflow endpoint.
        public let status: EndpointStatus?

        @inlinable
        public init(address: SocketAddress? = nil, mtu: Int? = nil, name: String? = nil, status: EndpointStatus? = nil) {
            self.address = address
            self.mtu = mtu
            self.name = name
            self.status = status
        }

        public func validate(name: String) throws {
            try self.validate(self.name, name: "name", parent: name, max: 256)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[ a-zA-Z0-9_:-]{1,256}$")
        }

        private enum CodingKeys: String, CodingKey {
            case address = "address"
            case mtu = "mtu"
            case name = "name"
            case status = "status"
        }
    }

    public struct DataflowEndpointConfig: AWSEncodableShape & AWSDecodableShape {
        /// Name of a dataflow endpoint.
        public let dataflowEndpointName: String
        /// Region of a dataflow endpoint.
        public let dataflowEndpointRegion: String?

        @inlinable
        public init(dataflowEndpointName: String, dataflowEndpointRegion: String? = nil) {
            self.dataflowEndpointName = dataflowEndpointName
            self.dataflowEndpointRegion = dataflowEndpointRegion
        }

        private enum CodingKeys: String, CodingKey {
            case dataflowEndpointName = "dataflowEndpointName"
            case dataflowEndpointRegion = "dataflowEndpointRegion"
        }
    }

    public struct DataflowEndpointGroupIdResponse: AWSDecodableShape {
        /// UUID of a dataflow endpoint group.
        public let dataflowEndpointGroupId: String?

        @inlinable
        public init(dataflowEndpointGroupId: String? = nil) {
            self.dataflowEndpointGroupId = dataflowEndpointGroupId
        }

        private enum CodingKeys: String, CodingKey {
            case dataflowEndpointGroupId = "dataflowEndpointGroupId"
        }
    }

    public struct DataflowEndpointListItem: AWSDecodableShape {
        /// ARN of a dataflow endpoint group.
        public let dataflowEndpointGroupArn: String?
        /// UUID of a dataflow endpoint group.
        public let dataflowEndpointGroupId: String?

        @inlinable
        public init(dataflowEndpointGroupArn: String? = nil, dataflowEndpointGroupId: String? = nil) {
            self.dataflowEndpointGroupArn = dataflowEndpointGroupArn
            self.dataflowEndpointGroupId = dataflowEndpointGroupId
        }

        private enum CodingKeys: String, CodingKey {
            case dataflowEndpointGroupArn = "dataflowEndpointGroupArn"
            case dataflowEndpointGroupId = "dataflowEndpointGroupId"
        }
    }

    public struct DecodeConfig: AWSEncodableShape & AWSDecodableShape {
        /// Unvalidated JSON of a decode Config.
        public let unvalidatedJSON: String

        @inlinable
        public init(unvalidatedJSON: String) {
            self.unvalidatedJSON = unvalidatedJSON
        }

        public func validate(name: String) throws {
            try self.validate(self.unvalidatedJSON, name: "unvalidatedJSON", parent: name, max: 8192)
            try self.validate(self.unvalidatedJSON, name: "unvalidatedJSON", parent: name, min: 2)
            try self.validate(self.unvalidatedJSON, name: "unvalidatedJSON", parent: name, pattern: "^[{}\\[\\]:.,\"0-9A-Za-z\\-_\\s]{2,8192}$")
        }

        private enum CodingKeys: String, CodingKey {
            case unvalidatedJSON = "unvalidatedJSON"
        }
    }

    public struct DeleteConfigRequest: AWSEncodableShape {
        /// UUID of a Config.
        public let configId: String
        /// Type of a Config.
        public let configType: ConfigCapabilityType

        @inlinable
        public init(configId: String, configType: ConfigCapabilityType) {
            self.configId = configId
            self.configType = configType
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.configId, key: "configId")
            request.encodePath(self.configType, key: "configType")
        }

        public func validate(name: String) throws {
            try self.validate(self.configId, name: "configId", parent: name, max: 36)
            try self.validate(self.configId, name: "configId", parent: name, min: 36)
            try self.validate(self.configId, name: "configId", parent: name, pattern: "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteDataflowEndpointGroupRequest: AWSEncodableShape {
        /// UUID of a dataflow endpoint group.
        public let dataflowEndpointGroupId: String

        @inlinable
        public init(dataflowEndpointGroupId: String) {
            self.dataflowEndpointGroupId = dataflowEndpointGroupId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.dataflowEndpointGroupId, key: "dataflowEndpointGroupId")
        }

        public func validate(name: String) throws {
            try self.validate(self.dataflowEndpointGroupId, name: "dataflowEndpointGroupId", parent: name, max: 36)
            try self.validate(self.dataflowEndpointGroupId, name: "dataflowEndpointGroupId", parent: name, min: 36)
            try self.validate(self.dataflowEndpointGroupId, name: "dataflowEndpointGroupId", parent: name, pattern: "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteEphemerisRequest: AWSEncodableShape {
        /// The AWS Ground Station ephemeris ID.
        public let ephemerisId: String

        @inlinable
        public init(ephemerisId: String) {
            self.ephemerisId = ephemerisId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.ephemerisId, key: "ephemerisId")
        }

        public func validate(name: String) throws {
            try self.validate(self.ephemerisId, name: "ephemerisId", parent: name, max: 36)
            try self.validate(self.ephemerisId, name: "ephemerisId", parent: name, min: 36)
            try self.validate(self.ephemerisId, name: "ephemerisId", parent: name, pattern: "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteMissionProfileRequest: AWSEncodableShape {
        /// UUID of a mission profile.
        public let missionProfileId: String

        @inlinable
        public init(missionProfileId: String) {
            self.missionProfileId = missionProfileId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.missionProfileId, key: "missionProfileId")
        }

        public func validate(name: String) throws {
            try self.validate(self.missionProfileId, name: "missionProfileId", parent: name, max: 36)
            try self.validate(self.missionProfileId, name: "missionProfileId", parent: name, min: 36)
            try self.validate(self.missionProfileId, name: "missionProfileId", parent: name, pattern: "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DemodulationConfig: AWSEncodableShape & AWSDecodableShape {
        /// Unvalidated JSON of a demodulation Config.
        public let unvalidatedJSON: String

        @inlinable
        public init(unvalidatedJSON: String) {
            self.unvalidatedJSON = unvalidatedJSON
        }

        public func validate(name: String) throws {
            try self.validate(self.unvalidatedJSON, name: "unvalidatedJSON", parent: name, max: 8192)
            try self.validate(self.unvalidatedJSON, name: "unvalidatedJSON", parent: name, min: 2)
            try self.validate(self.unvalidatedJSON, name: "unvalidatedJSON", parent: name, pattern: "^[{}\\[\\]:.,\"0-9A-Za-z\\-_\\s]{2,8192}$")
        }

        private enum CodingKeys: String, CodingKey {
            case unvalidatedJSON = "unvalidatedJSON"
        }
    }

    public struct DependencyException: AWSErrorShape {
        public let message: String?
        public let parameterName: String?

        @inlinable
        public init(message: String? = nil, parameterName: String? = nil) {
            self.message = message
            self.parameterName = parameterName
        }

        private enum CodingKeys: String, CodingKey {
            case message = "message"
            case parameterName = "parameterName"
        }
    }

    public struct DescribeContactRequest: AWSEncodableShape {
        /// UUID of a contact.
        public let contactId: String

        @inlinable
        public init(contactId: String) {
            self.contactId = contactId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.contactId, key: "contactId")
        }

        public func validate(name: String) throws {
            try self.validate(self.contactId, name: "contactId", parent: name, max: 36)
            try self.validate(self.contactId, name: "contactId", parent: name, min: 36)
            try self.validate(self.contactId, name: "contactId", parent: name, pattern: "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DescribeContactResponse: AWSDecodableShape {
        /// UUID of a contact.
        public let contactId: String?
        /// Status of a contact.
        public let contactStatus: ContactStatus?
        /// List describing source and destination details for each dataflow edge.
        public let dataflowList: [DataflowDetail]?
        /// End time of a contact in UTC.
        public let endTime: Date?
        /// Error message for a contact.
        public let errorMessage: String?
        /// Ground station for a contact.
        public let groundStation: String?
        /// Maximum elevation angle of a contact.
        public let maximumElevation: Elevation?
        /// ARN of a mission profile.
        public let missionProfileArn: String?
        /// Amount of time after a contact ends that you’d like to receive a CloudWatch event indicating the pass has finished.
        public let postPassEndTime: Date?
        /// Amount of time prior to contact start you’d like to receive a CloudWatch event indicating an upcoming pass.
        public let prePassStartTime: Date?
        /// Region of a contact.
        public let region: String?
        /// ARN of a satellite.
        public let satelliteArn: String?
        /// Start time of a contact in UTC.
        public let startTime: Date?
        /// Tags assigned to a contact.
        public let tags: [String: String]?
        ///  Projected time in UTC your satellite will set below the receive mask. This time is based on the satellite's current active ephemeris for future contacts and the ephemeris that was active during contact execution for completed contacts.
        public let visibilityEndTime: Date?
        ///  Projected time in UTC your satellite will rise above the receive mask. This time is based on the satellite's current active ephemeris for future contacts and the ephemeris that was active during contact execution for completed contacts.
        public let visibilityStartTime: Date?

        @inlinable
        public init(contactId: String? = nil, contactStatus: ContactStatus? = nil, dataflowList: [DataflowDetail]? = nil, endTime: Date? = nil, errorMessage: String? = nil, groundStation: String? = nil, maximumElevation: Elevation? = nil, missionProfileArn: String? = nil, postPassEndTime: Date? = nil, prePassStartTime: Date? = nil, region: String? = nil, satelliteArn: String? = nil, startTime: Date? = nil, tags: [String: String]? = nil, visibilityEndTime: Date? = nil, visibilityStartTime: Date? = nil) {
            self.contactId = contactId
            self.contactStatus = contactStatus
            self.dataflowList = dataflowList
            self.endTime = endTime
            self.errorMessage = errorMessage
            self.groundStation = groundStation
            self.maximumElevation = maximumElevation
            self.missionProfileArn = missionProfileArn
            self.postPassEndTime = postPassEndTime
            self.prePassStartTime = prePassStartTime
            self.region = region
            self.satelliteArn = satelliteArn
            self.startTime = startTime
            self.tags = tags
            self.visibilityEndTime = visibilityEndTime
            self.visibilityStartTime = visibilityStartTime
        }

        private enum CodingKeys: String, CodingKey {
            case contactId = "contactId"
            case contactStatus = "contactStatus"
            case dataflowList = "dataflowList"
            case endTime = "endTime"
            case errorMessage = "errorMessage"
            case groundStation = "groundStation"
            case maximumElevation = "maximumElevation"
            case missionProfileArn = "missionProfileArn"
            case postPassEndTime = "postPassEndTime"
            case prePassStartTime = "prePassStartTime"
            case region = "region"
            case satelliteArn = "satelliteArn"
            case startTime = "startTime"
            case tags = "tags"
            case visibilityEndTime = "visibilityEndTime"
            case visibilityStartTime = "visibilityStartTime"
        }
    }

    public struct DescribeEphemerisRequest: AWSEncodableShape {
        /// The AWS Ground Station ephemeris ID.
        public let ephemerisId: String

        @inlinable
        public init(ephemerisId: String) {
            self.ephemerisId = ephemerisId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.ephemerisId, key: "ephemerisId")
        }

        public func validate(name: String) throws {
            try self.validate(self.ephemerisId, name: "ephemerisId", parent: name, max: 36)
            try self.validate(self.ephemerisId, name: "ephemerisId", parent: name, min: 36)
            try self.validate(self.ephemerisId, name: "ephemerisId", parent: name, pattern: "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DescribeEphemerisResponse: AWSDecodableShape {
        /// The time the ephemeris was uploaded in UTC.
        public let creationTime: Date?
        /// Whether or not the ephemeris is enabled.
        public let enabled: Bool?
        /// The AWS Ground Station ephemeris ID.
        public let ephemerisId: String?
        /// Reason that an ephemeris failed validation. Only provided for ephemerides with INVALID status.
        public let invalidReason: EphemerisInvalidReason?
        /// A name string associated with the ephemeris. Used as a human-readable identifier for the ephemeris.
        public let name: String?
        /// Customer-provided priority score to establish the order in which overlapping ephemerides should be used. The default for customer-provided ephemeris priority is 1, and higher numbers take precedence. Priority must be 1 or greater
        public let priority: Int?
        /// The AWS Ground Station satellite ID associated with ephemeris.
        public let satelliteId: String?
        /// The status of the ephemeris.
        public let status: EphemerisStatus?
        /// Supplied ephemeris data.
        public let suppliedData: EphemerisTypeDescription?
        /// Tags assigned to an ephemeris.
        public let tags: [String: String]?

        @inlinable
        public init(creationTime: Date? = nil, enabled: Bool? = nil, ephemerisId: String? = nil, invalidReason: EphemerisInvalidReason? = nil, name: String? = nil, priority: Int? = nil, satelliteId: String? = nil, status: EphemerisStatus? = nil, suppliedData: EphemerisTypeDescription? = nil, tags: [String: String]? = nil) {
            self.creationTime = creationTime
            self.enabled = enabled
            self.ephemerisId = ephemerisId
            self.invalidReason = invalidReason
            self.name = name
            self.priority = priority
            self.satelliteId = satelliteId
            self.status = status
            self.suppliedData = suppliedData
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case creationTime = "creationTime"
            case enabled = "enabled"
            case ephemerisId = "ephemerisId"
            case invalidReason = "invalidReason"
            case name = "name"
            case priority = "priority"
            case satelliteId = "satelliteId"
            case status = "status"
            case suppliedData = "suppliedData"
            case tags = "tags"
        }
    }

    public struct Destination: AWSDecodableShape {
        /// Additional details for a Config, if type is dataflow endpoint or antenna demod decode.
        public let configDetails: ConfigDetails?
        /// UUID of a Config.
        public let configId: String?
        /// Type of a Config.
        public let configType: ConfigCapabilityType?
        /// Region of a dataflow destination.
        public let dataflowDestinationRegion: String?

        @inlinable
        public init(configDetails: ConfigDetails? = nil, configId: String? = nil, configType: ConfigCapabilityType? = nil, dataflowDestinationRegion: String? = nil) {
            self.configDetails = configDetails
            self.configId = configId
            self.configType = configType
            self.dataflowDestinationRegion = dataflowDestinationRegion
        }

        private enum CodingKeys: String, CodingKey {
            case configDetails = "configDetails"
            case configId = "configId"
            case configType = "configType"
            case dataflowDestinationRegion = "dataflowDestinationRegion"
        }
    }

    public struct DiscoveryData: AWSEncodableShape {
        /// List of capabilities to associate with agent.
        public let capabilityArns: [String]
        /// List of private IP addresses to associate with agent.
        public let privateIpAddresses: [String]
        /// List of public IP addresses to associate with agent.
        public let publicIpAddresses: [String]

        @inlinable
        public init(capabilityArns: [String], privateIpAddresses: [String], publicIpAddresses: [String]) {
            self.capabilityArns = capabilityArns
            self.privateIpAddresses = privateIpAddresses
            self.publicIpAddresses = publicIpAddresses
        }

        public func validate(name: String) throws {
            try self.validate(self.capabilityArns, name: "capabilityArns", parent: name, max: 20)
            try self.validate(self.capabilityArns, name: "capabilityArns", parent: name, min: 1)
            try self.privateIpAddresses.forEach {
                try validate($0, name: "privateIpAddresses[]", parent: name, max: 16)
                try validate($0, name: "privateIpAddresses[]", parent: name, min: 7)
                try validate($0, name: "privateIpAddresses[]", parent: name, pattern: "^\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}$")
            }
            try self.validate(self.privateIpAddresses, name: "privateIpAddresses", parent: name, max: 20)
            try self.validate(self.privateIpAddresses, name: "privateIpAddresses", parent: name, min: 1)
            try self.publicIpAddresses.forEach {
                try validate($0, name: "publicIpAddresses[]", parent: name, max: 16)
                try validate($0, name: "publicIpAddresses[]", parent: name, min: 7)
                try validate($0, name: "publicIpAddresses[]", parent: name, pattern: "^\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}$")
            }
            try self.validate(self.publicIpAddresses, name: "publicIpAddresses", parent: name, max: 20)
            try self.validate(self.publicIpAddresses, name: "publicIpAddresses", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case capabilityArns = "capabilityArns"
            case privateIpAddresses = "privateIpAddresses"
            case publicIpAddresses = "publicIpAddresses"
        }
    }

    public struct Eirp: AWSEncodableShape & AWSDecodableShape {
        /// Units of an EIRP.
        public let units: EirpUnits
        /// Value of an EIRP. Valid values are between 20.0 to 50.0 dBW.
        public let value: Double

        @inlinable
        public init(units: EirpUnits, value: Double) {
            self.units = units
            self.value = value
        }

        private enum CodingKeys: String, CodingKey {
            case units = "units"
            case value = "value"
        }
    }

    public struct Elevation: AWSDecodableShape {
        /// Elevation angle units.
        public let unit: AngleUnits
        /// Elevation angle value.
        public let value: Double

        @inlinable
        public init(unit: AngleUnits, value: Double) {
            self.unit = unit
            self.value = value
        }

        private enum CodingKeys: String, CodingKey {
            case unit = "unit"
            case value = "value"
        }
    }

    public struct EndpointDetails: AWSEncodableShape & AWSDecodableShape {
        /// An agent endpoint.
        public let awsGroundStationAgentEndpoint: AwsGroundStationAgentEndpoint?
        /// A dataflow endpoint.
        public let endpoint: DataflowEndpoint?
        /// Health reasons for a dataflow endpoint. This field is ignored when calling CreateDataflowEndpointGroup.
        public let healthReasons: [CapabilityHealthReason]?
        /// A dataflow endpoint health status. This field is ignored when calling CreateDataflowEndpointGroup.
        public let healthStatus: CapabilityHealth?
        /// Endpoint security details including a list of subnets, a list of security groups and a role to connect streams to instances.
        public let securityDetails: SecurityDetails?

        @inlinable
        public init(awsGroundStationAgentEndpoint: AwsGroundStationAgentEndpoint? = nil, endpoint: DataflowEndpoint? = nil, healthReasons: [CapabilityHealthReason]? = nil, healthStatus: CapabilityHealth? = nil, securityDetails: SecurityDetails? = nil) {
            self.awsGroundStationAgentEndpoint = awsGroundStationAgentEndpoint
            self.endpoint = endpoint
            self.healthReasons = healthReasons
            self.healthStatus = healthStatus
            self.securityDetails = securityDetails
        }

        public func validate(name: String) throws {
            try self.awsGroundStationAgentEndpoint?.validate(name: "\(name).awsGroundStationAgentEndpoint")
            try self.endpoint?.validate(name: "\(name).endpoint")
            try self.validate(self.healthReasons, name: "healthReasons", parent: name, max: 500)
        }

        private enum CodingKeys: String, CodingKey {
            case awsGroundStationAgentEndpoint = "awsGroundStationAgentEndpoint"
            case endpoint = "endpoint"
            case healthReasons = "healthReasons"
            case healthStatus = "healthStatus"
            case securityDetails = "securityDetails"
        }
    }

    public struct EphemerisDescription: AWSDecodableShape {
        /// Supplied ephemeris data.
        public let ephemerisData: String?
        /// Source S3 object used for the ephemeris.
        public let sourceS3Object: S3Object?

        @inlinable
        public init(ephemerisData: String? = nil, sourceS3Object: S3Object? = nil) {
            self.ephemerisData = ephemerisData
            self.sourceS3Object = sourceS3Object
        }

        private enum CodingKeys: String, CodingKey {
            case ephemerisData = "ephemerisData"
            case sourceS3Object = "sourceS3Object"
        }
    }

    public struct EphemerisIdResponse: AWSDecodableShape {
        /// The AWS Ground Station ephemeris ID.
        public let ephemerisId: String?

        @inlinable
        public init(ephemerisId: String? = nil) {
            self.ephemerisId = ephemerisId
        }

        private enum CodingKeys: String, CodingKey {
            case ephemerisId = "ephemerisId"
        }
    }

    public struct EphemerisItem: AWSDecodableShape {
        /// The time the ephemeris was uploaded in UTC.
        public let creationTime: Date?
        /// Whether or not the ephemeris is enabled.
        public let enabled: Bool?
        /// The AWS Ground Station ephemeris ID.
        public let ephemerisId: String?
        /// A name string associated with the ephemeris. Used as a human-readable identifier for the ephemeris.
        public let name: String?
        /// Customer-provided priority score to establish the order in which overlapping ephemerides should be used. The default for customer-provided ephemeris priority is 1, and higher numbers take precedence. Priority must be 1 or greater
        public let priority: Int?
        /// Source S3 object used for the ephemeris.
        public let sourceS3Object: S3Object?
        /// The status of the ephemeris.
        public let status: EphemerisStatus?

        @inlinable
        public init(creationTime: Date? = nil, enabled: Bool? = nil, ephemerisId: String? = nil, name: String? = nil, priority: Int? = nil, sourceS3Object: S3Object? = nil, status: EphemerisStatus? = nil) {
            self.creationTime = creationTime
            self.enabled = enabled
            self.ephemerisId = ephemerisId
            self.name = name
            self.priority = priority
            self.sourceS3Object = sourceS3Object
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case creationTime = "creationTime"
            case enabled = "enabled"
            case ephemerisId = "ephemerisId"
            case name = "name"
            case priority = "priority"
            case sourceS3Object = "sourceS3Object"
            case status = "status"
        }
    }

    public struct EphemerisMetaData: AWSDecodableShape {
        /// UUID of a customer-provided ephemeris. This field is not populated for default ephemerides from Space Track.
        public let ephemerisId: String?
        /// The epoch of a default, ephemeris from Space Track in UTC. This field is not populated for customer-provided ephemerides.
        public let epoch: Date?
        /// A name string associated with the ephemeris. Used as a human-readable identifier for the ephemeris. A name is only returned for customer-provider ephemerides that have a name associated.
        public let name: String?
        /// The EphemerisSource that generated a given ephemeris.
        public let source: EphemerisSource

        @inlinable
        public init(ephemerisId: String? = nil, epoch: Date? = nil, name: String? = nil, source: EphemerisSource) {
            self.ephemerisId = ephemerisId
            self.epoch = epoch
            self.name = name
            self.source = source
        }

        private enum CodingKeys: String, CodingKey {
            case ephemerisId = "ephemerisId"
            case epoch = "epoch"
            case name = "name"
            case source = "source"
        }
    }

    public struct Frequency: AWSEncodableShape & AWSDecodableShape {
        /// Frequency units.
        public let units: FrequencyUnits
        /// Frequency value. Valid values are between 2200 to 2300 MHz and 7750 to 8400 MHz for downlink and 2025 to 2120 MHz for uplink.
        public let value: Double

        @inlinable
        public init(units: FrequencyUnits, value: Double) {
            self.units = units
            self.value = value
        }

        private enum CodingKeys: String, CodingKey {
            case units = "units"
            case value = "value"
        }
    }

    public struct FrequencyBandwidth: AWSEncodableShape & AWSDecodableShape {
        /// Frequency bandwidth units.
        public let units: BandwidthUnits
        /// Frequency bandwidth value. AWS Ground Station currently has the following bandwidth limitations:   For AntennaDownlinkDemodDecodeconfig, valid values are between 125 kHz to 650 MHz.   For AntennaDownlinkconfig, valid values are between 10 kHz to 54 MHz.   For AntennaUplinkConfig, valid values are between 10 kHz to 54 MHz.
        public let value: Double

        @inlinable
        public init(units: BandwidthUnits, value: Double) {
            self.units = units
            self.value = value
        }

        private enum CodingKeys: String, CodingKey {
            case units = "units"
            case value = "value"
        }
    }

    public struct GetAgentConfigurationRequest: AWSEncodableShape {
        /// UUID of agent to get configuration information for.
        public let agentId: String

        @inlinable
        public init(agentId: String) {
            self.agentId = agentId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.agentId, key: "agentId")
        }

        public func validate(name: String) throws {
            try self.validate(self.agentId, name: "agentId", parent: name, max: 36)
            try self.validate(self.agentId, name: "agentId", parent: name, min: 36)
            try self.validate(self.agentId, name: "agentId", parent: name, pattern: "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetAgentConfigurationResponse: AWSDecodableShape {
        /// UUID of agent.
        public let agentId: String?
        /// Tasking document for agent.
        public let taskingDocument: String?

        @inlinable
        public init(agentId: String? = nil, taskingDocument: String? = nil) {
            self.agentId = agentId
            self.taskingDocument = taskingDocument
        }

        private enum CodingKeys: String, CodingKey {
            case agentId = "agentId"
            case taskingDocument = "taskingDocument"
        }
    }

    public struct GetConfigRequest: AWSEncodableShape {
        /// UUID of a Config.
        public let configId: String
        /// Type of a Config.
        public let configType: ConfigCapabilityType

        @inlinable
        public init(configId: String, configType: ConfigCapabilityType) {
            self.configId = configId
            self.configType = configType
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.configId, key: "configId")
            request.encodePath(self.configType, key: "configType")
        }

        public func validate(name: String) throws {
            try self.validate(self.configId, name: "configId", parent: name, max: 36)
            try self.validate(self.configId, name: "configId", parent: name, min: 36)
            try self.validate(self.configId, name: "configId", parent: name, pattern: "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetConfigResponse: AWSDecodableShape {
        /// ARN of a Config
        public let configArn: String
        /// Data elements in a Config.
        public let configData: ConfigTypeData
        /// UUID of a Config.
        public let configId: String
        /// Type of a Config.
        public let configType: ConfigCapabilityType?
        /// Name of a Config.
        public let name: String
        /// Tags assigned to a Config.
        public let tags: [String: String]?

        @inlinable
        public init(configArn: String, configData: ConfigTypeData, configId: String, configType: ConfigCapabilityType? = nil, name: String, tags: [String: String]? = nil) {
            self.configArn = configArn
            self.configData = configData
            self.configId = configId
            self.configType = configType
            self.name = name
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case configArn = "configArn"
            case configData = "configData"
            case configId = "configId"
            case configType = "configType"
            case name = "name"
            case tags = "tags"
        }
    }

    public struct GetDataflowEndpointGroupRequest: AWSEncodableShape {
        /// UUID of a dataflow endpoint group.
        public let dataflowEndpointGroupId: String

        @inlinable
        public init(dataflowEndpointGroupId: String) {
            self.dataflowEndpointGroupId = dataflowEndpointGroupId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.dataflowEndpointGroupId, key: "dataflowEndpointGroupId")
        }

        public func validate(name: String) throws {
            try self.validate(self.dataflowEndpointGroupId, name: "dataflowEndpointGroupId", parent: name, max: 36)
            try self.validate(self.dataflowEndpointGroupId, name: "dataflowEndpointGroupId", parent: name, min: 36)
            try self.validate(self.dataflowEndpointGroupId, name: "dataflowEndpointGroupId", parent: name, pattern: "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetDataflowEndpointGroupResponse: AWSDecodableShape {
        /// Amount of time, in seconds, after a contact ends that the Ground Station Dataflow Endpoint Group will be in a POSTPASS state. A Ground Station Dataflow Endpoint Group State Change event will be emitted when the Dataflow Endpoint Group enters and exits the POSTPASS state.
        public let contactPostPassDurationSeconds: Int?
        /// Amount of time, in seconds, before a contact starts that the Ground Station Dataflow Endpoint Group will be in a PREPASS state. A Ground Station Dataflow Endpoint Group State Change event will be emitted when the Dataflow Endpoint Group enters and exits the PREPASS state.
        public let contactPrePassDurationSeconds: Int?
        /// ARN of a dataflow endpoint group.
        public let dataflowEndpointGroupArn: String?
        /// UUID of a dataflow endpoint group.
        public let dataflowEndpointGroupId: String?
        /// Details of a dataflow endpoint.
        public let endpointsDetails: [EndpointDetails]?
        /// Tags assigned to a dataflow endpoint group.
        public let tags: [String: String]?

        @inlinable
        public init(contactPostPassDurationSeconds: Int? = nil, contactPrePassDurationSeconds: Int? = nil, dataflowEndpointGroupArn: String? = nil, dataflowEndpointGroupId: String? = nil, endpointsDetails: [EndpointDetails]? = nil, tags: [String: String]? = nil) {
            self.contactPostPassDurationSeconds = contactPostPassDurationSeconds
            self.contactPrePassDurationSeconds = contactPrePassDurationSeconds
            self.dataflowEndpointGroupArn = dataflowEndpointGroupArn
            self.dataflowEndpointGroupId = dataflowEndpointGroupId
            self.endpointsDetails = endpointsDetails
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case contactPostPassDurationSeconds = "contactPostPassDurationSeconds"
            case contactPrePassDurationSeconds = "contactPrePassDurationSeconds"
            case dataflowEndpointGroupArn = "dataflowEndpointGroupArn"
            case dataflowEndpointGroupId = "dataflowEndpointGroupId"
            case endpointsDetails = "endpointsDetails"
            case tags = "tags"
        }
    }

    public struct GetMinuteUsageRequest: AWSEncodableShape {
        /// The month being requested, with a value of 1-12.
        public let month: Int
        /// The year being requested, in the format of YYYY.
        public let year: Int

        @inlinable
        public init(month: Int, year: Int) {
            self.month = month
            self.year = year
        }

        public func validate(name: String) throws {
            try self.validate(self.month, name: "month", parent: name, max: 12)
            try self.validate(self.month, name: "month", parent: name, min: 1)
            try self.validate(self.year, name: "year", parent: name, max: 3000)
            try self.validate(self.year, name: "year", parent: name, min: 2018)
        }

        private enum CodingKeys: String, CodingKey {
            case month = "month"
            case year = "year"
        }
    }

    public struct GetMinuteUsageResponse: AWSDecodableShape {
        /// Estimated number of minutes remaining for an account, specific to the month being requested.
        public let estimatedMinutesRemaining: Int?
        /// Returns whether or not an account has signed up for the reserved minutes pricing plan, specific to the month being requested.
        public let isReservedMinutesCustomer: Bool?
        /// Total number of reserved minutes allocated, specific to the month being requested.
        public let totalReservedMinuteAllocation: Int?
        /// Total scheduled minutes for an account, specific to the month being requested.
        public let totalScheduledMinutes: Int?
        /// Upcoming minutes scheduled for an account, specific to the month being requested.
        public let upcomingMinutesScheduled: Int?

        @inlinable
        public init(estimatedMinutesRemaining: Int? = nil, isReservedMinutesCustomer: Bool? = nil, totalReservedMinuteAllocation: Int? = nil, totalScheduledMinutes: Int? = nil, upcomingMinutesScheduled: Int? = nil) {
            self.estimatedMinutesRemaining = estimatedMinutesRemaining
            self.isReservedMinutesCustomer = isReservedMinutesCustomer
            self.totalReservedMinuteAllocation = totalReservedMinuteAllocation
            self.totalScheduledMinutes = totalScheduledMinutes
            self.upcomingMinutesScheduled = upcomingMinutesScheduled
        }

        private enum CodingKeys: String, CodingKey {
            case estimatedMinutesRemaining = "estimatedMinutesRemaining"
            case isReservedMinutesCustomer = "isReservedMinutesCustomer"
            case totalReservedMinuteAllocation = "totalReservedMinuteAllocation"
            case totalScheduledMinutes = "totalScheduledMinutes"
            case upcomingMinutesScheduled = "upcomingMinutesScheduled"
        }
    }

    public struct GetMissionProfileRequest: AWSEncodableShape {
        /// UUID of a mission profile.
        public let missionProfileId: String

        @inlinable
        public init(missionProfileId: String) {
            self.missionProfileId = missionProfileId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.missionProfileId, key: "missionProfileId")
        }

        public func validate(name: String) throws {
            try self.validate(self.missionProfileId, name: "missionProfileId", parent: name, max: 36)
            try self.validate(self.missionProfileId, name: "missionProfileId", parent: name, min: 36)
            try self.validate(self.missionProfileId, name: "missionProfileId", parent: name, pattern: "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetMissionProfileResponse: AWSDecodableShape {
        /// Amount of time after a contact ends that you’d like to receive a CloudWatch event indicating the pass has finished.
        public let contactPostPassDurationSeconds: Int?
        /// Amount of time prior to contact start you’d like to receive a CloudWatch event indicating an upcoming pass.
        public let contactPrePassDurationSeconds: Int?
        /// A list of lists of ARNs. Each list of ARNs is an edge, with a from Config and a to Config.
        public let dataflowEdges: [[String]]?
        /// Smallest amount of time in seconds that you’d like to see for an available contact. AWS Ground Station will not present you with contacts shorter than this duration.
        public let minimumViableContactDurationSeconds: Int?
        /// ARN of a mission profile.
        public let missionProfileArn: String?
        /// UUID of a mission profile.
        public let missionProfileId: String?
        /// Name of a mission profile.
        public let name: String?
        /// Region of a mission profile.
        public let region: String?
        /// KMS key to use for encrypting streams.
        public let streamsKmsKey: KmsKey?
        /// Role to use for encrypting streams with KMS key.
        public let streamsKmsRole: String?
        /// Tags assigned to a mission profile.
        public let tags: [String: String]?
        /// ARN of a tracking Config.
        public let trackingConfigArn: String?

        @inlinable
        public init(contactPostPassDurationSeconds: Int? = nil, contactPrePassDurationSeconds: Int? = nil, dataflowEdges: [[String]]? = nil, minimumViableContactDurationSeconds: Int? = nil, missionProfileArn: String? = nil, missionProfileId: String? = nil, name: String? = nil, region: String? = nil, streamsKmsKey: KmsKey? = nil, streamsKmsRole: String? = nil, tags: [String: String]? = nil, trackingConfigArn: String? = nil) {
            self.contactPostPassDurationSeconds = contactPostPassDurationSeconds
            self.contactPrePassDurationSeconds = contactPrePassDurationSeconds
            self.dataflowEdges = dataflowEdges
            self.minimumViableContactDurationSeconds = minimumViableContactDurationSeconds
            self.missionProfileArn = missionProfileArn
            self.missionProfileId = missionProfileId
            self.name = name
            self.region = region
            self.streamsKmsKey = streamsKmsKey
            self.streamsKmsRole = streamsKmsRole
            self.tags = tags
            self.trackingConfigArn = trackingConfigArn
        }

        private enum CodingKeys: String, CodingKey {
            case contactPostPassDurationSeconds = "contactPostPassDurationSeconds"
            case contactPrePassDurationSeconds = "contactPrePassDurationSeconds"
            case dataflowEdges = "dataflowEdges"
            case minimumViableContactDurationSeconds = "minimumViableContactDurationSeconds"
            case missionProfileArn = "missionProfileArn"
            case missionProfileId = "missionProfileId"
            case name = "name"
            case region = "region"
            case streamsKmsKey = "streamsKmsKey"
            case streamsKmsRole = "streamsKmsRole"
            case tags = "tags"
            case trackingConfigArn = "trackingConfigArn"
        }
    }

    public struct GetSatelliteRequest: AWSEncodableShape {
        /// UUID of a satellite.
        public let satelliteId: String

        @inlinable
        public init(satelliteId: String) {
            self.satelliteId = satelliteId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.satelliteId, key: "satelliteId")
        }

        public func validate(name: String) throws {
            try self.validate(self.satelliteId, name: "satelliteId", parent: name, max: 36)
            try self.validate(self.satelliteId, name: "satelliteId", parent: name, min: 36)
            try self.validate(self.satelliteId, name: "satelliteId", parent: name, pattern: "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetSatelliteResponse: AWSDecodableShape {
        /// The current ephemeris being used to compute the trajectory of the satellite.
        public let currentEphemeris: EphemerisMetaData?
        /// A list of ground stations to which the satellite is on-boarded.
        public let groundStations: [String]?
        /// NORAD satellite ID number.
        public let noradSatelliteID: Int?
        /// ARN of a satellite.
        public let satelliteArn: String?
        /// UUID of a satellite.
        public let satelliteId: String?

        @inlinable
        public init(currentEphemeris: EphemerisMetaData? = nil, groundStations: [String]? = nil, noradSatelliteID: Int? = nil, satelliteArn: String? = nil, satelliteId: String? = nil) {
            self.currentEphemeris = currentEphemeris
            self.groundStations = groundStations
            self.noradSatelliteID = noradSatelliteID
            self.satelliteArn = satelliteArn
            self.satelliteId = satelliteId
        }

        private enum CodingKeys: String, CodingKey {
            case currentEphemeris = "currentEphemeris"
            case groundStations = "groundStations"
            case noradSatelliteID = "noradSatelliteID"
            case satelliteArn = "satelliteArn"
            case satelliteId = "satelliteId"
        }
    }

    public struct GroundStationData: AWSDecodableShape {
        /// UUID of a ground station.
        public let groundStationId: String?
        /// Name of a ground station.
        public let groundStationName: String?
        /// Ground station Region.
        public let region: String?

        @inlinable
        public init(groundStationId: String? = nil, groundStationName: String? = nil, region: String? = nil) {
            self.groundStationId = groundStationId
            self.groundStationName = groundStationName
            self.region = region
        }

        private enum CodingKeys: String, CodingKey {
            case groundStationId = "groundStationId"
            case groundStationName = "groundStationName"
            case region = "region"
        }
    }

    public struct IntegerRange: AWSEncodableShape & AWSDecodableShape {
        /// A maximum value.
        public let maximum: Int
        /// A minimum value.
        public let minimum: Int

        @inlinable
        public init(maximum: Int, minimum: Int) {
            self.maximum = maximum
            self.minimum = minimum
        }

        private enum CodingKeys: String, CodingKey {
            case maximum = "maximum"
            case minimum = "minimum"
        }
    }

    public struct InvalidParameterException: AWSErrorShape {
        public let message: String?
        public let parameterName: String?

        @inlinable
        public init(message: String? = nil, parameterName: String? = nil) {
            self.message = message
            self.parameterName = parameterName
        }

        private enum CodingKeys: String, CodingKey {
            case message = "message"
            case parameterName = "parameterName"
        }
    }

    public struct ListConfigsRequest: AWSEncodableShape {
        /// Maximum number of Configs returned.
        public let maxResults: Int?
        /// Next token returned in the request of a previous ListConfigs call. Used to get the next page of results.
        public let nextToken: String?

        @inlinable
        public init(maxResults: Int? = nil, nextToken: String? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 1000)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 3)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^[A-Za-z0-9-/+_.=]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListConfigsResponse: AWSDecodableShape {
        /// List of Config items.
        public let configList: [ConfigListItem]?
        /// Next token returned in the response of a previous ListConfigs call. Used to get the next page of results.
        public let nextToken: String?

        @inlinable
        public init(configList: [ConfigListItem]? = nil, nextToken: String? = nil) {
            self.configList = configList
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case configList = "configList"
            case nextToken = "nextToken"
        }
    }

    public struct ListContactsRequest: AWSEncodableShape {
        /// End time of a contact in UTC.
        public let endTime: Date
        /// Name of a ground station.
        public let groundStation: String?
        /// Maximum number of contacts returned.
        public let maxResults: Int?
        /// ARN of a mission profile.
        public let missionProfileArn: String?
        /// Next token returned in the request of a previous ListContacts call. Used to get the next page of results.
        public let nextToken: String?
        /// ARN of a satellite.
        public let satelliteArn: String?
        /// Start time of a contact in UTC.
        public let startTime: Date
        /// Status of a contact reservation.
        public let statusList: [ContactStatus]

        @inlinable
        public init(endTime: Date, groundStation: String? = nil, maxResults: Int? = nil, missionProfileArn: String? = nil, nextToken: String? = nil, satelliteArn: String? = nil, startTime: Date, statusList: [ContactStatus]) {
            self.endTime = endTime
            self.groundStation = groundStation
            self.maxResults = maxResults
            self.missionProfileArn = missionProfileArn
            self.nextToken = nextToken
            self.satelliteArn = satelliteArn
            self.startTime = startTime
            self.statusList = statusList
        }

        public func validate(name: String) throws {
            try self.validate(self.groundStation, name: "groundStation", parent: name, max: 500)
            try self.validate(self.groundStation, name: "groundStation", parent: name, min: 4)
            try self.validate(self.groundStation, name: "groundStation", parent: name, pattern: "^[ a-zA-Z0-9-._:=]{4,256}$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.missionProfileArn, name: "missionProfileArn", parent: name, max: 138)
            try self.validate(self.missionProfileArn, name: "missionProfileArn", parent: name, min: 89)
            try self.validate(self.missionProfileArn, name: "missionProfileArn", parent: name, pattern: "^arn:aws:groundstation:[-a-z0-9]{1,50}:[0-9]{12}:mission-profile/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$")
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 1000)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 3)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^[A-Za-z0-9-/+_.=]+$")
            try self.validate(self.satelliteArn, name: "satelliteArn", parent: name, max: 132)
            try self.validate(self.satelliteArn, name: "satelliteArn", parent: name, min: 82)
            try self.validate(self.satelliteArn, name: "satelliteArn", parent: name, pattern: "^arn:aws:groundstation:([-a-z0-9]{1,50})?:[0-9]{12}:satellite/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$")
            try self.validate(self.statusList, name: "statusList", parent: name, max: 500)
        }

        private enum CodingKeys: String, CodingKey {
            case endTime = "endTime"
            case groundStation = "groundStation"
            case maxResults = "maxResults"
            case missionProfileArn = "missionProfileArn"
            case nextToken = "nextToken"
            case satelliteArn = "satelliteArn"
            case startTime = "startTime"
            case statusList = "statusList"
        }
    }

    public struct ListContactsResponse: AWSDecodableShape {
        /// List of contacts.
        public let contactList: [ContactData]?
        /// Next token returned in the response of a previous ListContacts call. Used to get the next page of results.
        public let nextToken: String?

        @inlinable
        public init(contactList: [ContactData]? = nil, nextToken: String? = nil) {
            self.contactList = contactList
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case contactList = "contactList"
            case nextToken = "nextToken"
        }
    }

    public struct ListDataflowEndpointGroupsRequest: AWSEncodableShape {
        /// Maximum number of dataflow endpoint groups returned.
        public let maxResults: Int?
        /// Next token returned in the request of a previous ListDataflowEndpointGroups call. Used to get the next page of results.
        public let nextToken: String?

        @inlinable
        public init(maxResults: Int? = nil, nextToken: String? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 1000)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 3)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^[A-Za-z0-9-/+_.=]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListDataflowEndpointGroupsResponse: AWSDecodableShape {
        /// A list of dataflow endpoint groups.
        public let dataflowEndpointGroupList: [DataflowEndpointListItem]?
        /// Next token returned in the response of a previous ListDataflowEndpointGroups call. Used to get the next page of results.
        public let nextToken: String?

        @inlinable
        public init(dataflowEndpointGroupList: [DataflowEndpointListItem]? = nil, nextToken: String? = nil) {
            self.dataflowEndpointGroupList = dataflowEndpointGroupList
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case dataflowEndpointGroupList = "dataflowEndpointGroupList"
            case nextToken = "nextToken"
        }
    }

    public struct ListEphemeridesRequest: AWSEncodableShape {
        /// The end time to list in UTC. The operation will return an ephemeris if its expiration time is within the time range defined by the startTime and endTime.
        public let endTime: Date
        /// Maximum number of ephemerides to return.
        public let maxResults: Int?
        /// Pagination token.
        public let nextToken: String?
        /// The AWS Ground Station satellite ID to list ephemeris for.
        public let satelliteId: String
        /// The start time to list in UTC. The operation will return an ephemeris if its expiration time is within the time range defined by the startTime and endTime.
        public let startTime: Date
        /// The list of ephemeris status to return.
        public let statusList: [EphemerisStatus]?

        @inlinable
        public init(endTime: Date, maxResults: Int? = nil, nextToken: String? = nil, satelliteId: String, startTime: Date, statusList: [EphemerisStatus]? = nil) {
            self.endTime = endTime
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.satelliteId = satelliteId
            self.startTime = startTime
            self.statusList = statusList
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encode(self.endTime, forKey: .endTime)
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
            try container.encode(self.satelliteId, forKey: .satelliteId)
            try container.encode(self.startTime, forKey: .startTime)
            try container.encodeIfPresent(self.statusList, forKey: .statusList)
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 1000)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 3)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^[A-Za-z0-9-/+_.=]+$")
            try self.validate(self.satelliteId, name: "satelliteId", parent: name, max: 36)
            try self.validate(self.satelliteId, name: "satelliteId", parent: name, min: 36)
            try self.validate(self.satelliteId, name: "satelliteId", parent: name, pattern: "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$")
            try self.validate(self.statusList, name: "statusList", parent: name, max: 500)
        }

        private enum CodingKeys: String, CodingKey {
            case endTime = "endTime"
            case satelliteId = "satelliteId"
            case startTime = "startTime"
            case statusList = "statusList"
        }
    }

    public struct ListEphemeridesResponse: AWSDecodableShape {
        /// List of ephemerides.
        public let ephemerides: [EphemerisItem]?
        /// Pagination token.
        public let nextToken: String?

        @inlinable
        public init(ephemerides: [EphemerisItem]? = nil, nextToken: String? = nil) {
            self.ephemerides = ephemerides
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case ephemerides = "ephemerides"
            case nextToken = "nextToken"
        }
    }

    public struct ListGroundStationsRequest: AWSEncodableShape {
        /// Maximum number of ground stations returned.
        public let maxResults: Int?
        /// Next token that can be supplied in the next call to get the next page of ground stations.
        public let nextToken: String?
        /// Satellite ID to retrieve on-boarded ground stations.
        public let satelliteId: String?

        @inlinable
        public init(maxResults: Int? = nil, nextToken: String? = nil, satelliteId: String? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.satelliteId = satelliteId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
            request.encodeQuery(self.satelliteId, key: "satelliteId")
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 1000)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 3)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^[A-Za-z0-9-/+_.=]+$")
            try self.validate(self.satelliteId, name: "satelliteId", parent: name, max: 36)
            try self.validate(self.satelliteId, name: "satelliteId", parent: name, min: 36)
            try self.validate(self.satelliteId, name: "satelliteId", parent: name, pattern: "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListGroundStationsResponse: AWSDecodableShape {
        /// List of ground stations.
        public let groundStationList: [GroundStationData]?
        /// Next token that can be supplied in the next call to get the next page of ground stations.
        public let nextToken: String?

        @inlinable
        public init(groundStationList: [GroundStationData]? = nil, nextToken: String? = nil) {
            self.groundStationList = groundStationList
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case groundStationList = "groundStationList"
            case nextToken = "nextToken"
        }
    }

    public struct ListMissionProfilesRequest: AWSEncodableShape {
        /// Maximum number of mission profiles returned.
        public let maxResults: Int?
        /// Next token returned in the request of a previous ListMissionProfiles call. Used to get the next page of results.
        public let nextToken: String?

        @inlinable
        public init(maxResults: Int? = nil, nextToken: String? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 1000)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 3)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^[A-Za-z0-9-/+_.=]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListMissionProfilesResponse: AWSDecodableShape {
        /// List of mission profiles.
        public let missionProfileList: [MissionProfileListItem]?
        /// Next token returned in the response of a previous ListMissionProfiles call. Used to get the next page of results.
        public let nextToken: String?

        @inlinable
        public init(missionProfileList: [MissionProfileListItem]? = nil, nextToken: String? = nil) {
            self.missionProfileList = missionProfileList
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case missionProfileList = "missionProfileList"
            case nextToken = "nextToken"
        }
    }

    public struct ListSatellitesRequest: AWSEncodableShape {
        /// Maximum number of satellites returned.
        public let maxResults: Int?
        /// Next token that can be supplied in the next call to get the next page of satellites.
        public let nextToken: String?

        @inlinable
        public init(maxResults: Int? = nil, nextToken: String? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 1000)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 3)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^[A-Za-z0-9-/+_.=]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListSatellitesResponse: AWSDecodableShape {
        /// Next token that can be supplied in the next call to get the next page of satellites.
        public let nextToken: String?
        /// List of satellites.
        public let satellites: [SatelliteListItem]?

        @inlinable
        public init(nextToken: String? = nil, satellites: [SatelliteListItem]? = nil) {
            self.nextToken = nextToken
            self.satellites = satellites
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "nextToken"
            case satellites = "satellites"
        }
    }

    public struct ListTagsForResourceRequest: AWSEncodableShape {
        /// ARN of a resource.
        public let resourceArn: String

        @inlinable
        public init(resourceArn: String) {
            self.resourceArn = resourceArn
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.resourceArn, key: "resourceArn")
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, max: 1024)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, min: 5)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, pattern: "^(arn:aws:)[\\s\\S]{0,1024}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListTagsForResourceResponse: AWSDecodableShape {
        /// Tags assigned to a resource.
        public let tags: [String: String]?

        @inlinable
        public init(tags: [String: String]? = nil) {
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case tags = "tags"
        }
    }

    public struct MissionProfileIdResponse: AWSDecodableShape {
        /// UUID of a mission profile.
        public let missionProfileId: String?

        @inlinable
        public init(missionProfileId: String? = nil) {
            self.missionProfileId = missionProfileId
        }

        private enum CodingKeys: String, CodingKey {
            case missionProfileId = "missionProfileId"
        }
    }

    public struct MissionProfileListItem: AWSDecodableShape {
        /// ARN of a mission profile.
        public let missionProfileArn: String?
        /// UUID of a mission profile.
        public let missionProfileId: String?
        /// Name of a mission profile.
        public let name: String?
        /// Region of a mission profile.
        public let region: String?

        @inlinable
        public init(missionProfileArn: String? = nil, missionProfileId: String? = nil, name: String? = nil, region: String? = nil) {
            self.missionProfileArn = missionProfileArn
            self.missionProfileId = missionProfileId
            self.name = name
            self.region = region
        }

        private enum CodingKeys: String, CodingKey {
            case missionProfileArn = "missionProfileArn"
            case missionProfileId = "missionProfileId"
            case name = "name"
            case region = "region"
        }
    }

    public struct OEMEphemeris: AWSEncodableShape {
        /// The data for an OEM ephemeris, supplied directly in the request rather than through an S3 object.
        public let oemData: String?
        /// Identifies the S3 object to be used as the ephemeris.
        public let s3Object: S3Object?

        @inlinable
        public init(oemData: String? = nil, s3Object: S3Object? = nil) {
            self.oemData = oemData
            self.s3Object = s3Object
        }

        public func validate(name: String) throws {
            try self.validate(self.oemData, name: "oemData", parent: name, min: 1)
            try self.validate(self.oemData, name: "oemData", parent: name, pattern: "^[\\s\\S]+$")
            try self.s3Object?.validate(name: "\(name).s3Object")
        }

        private enum CodingKeys: String, CodingKey {
            case oemData = "oemData"
            case s3Object = "s3Object"
        }
    }

    public struct RangedConnectionDetails: AWSEncodableShape & AWSDecodableShape {
        /// Maximum transmission unit (MTU) size in bytes of a dataflow endpoint.
        public let mtu: Int?
        /// A ranged socket address.
        public let socketAddress: RangedSocketAddress

        @inlinable
        public init(mtu: Int? = nil, socketAddress: RangedSocketAddress) {
            self.mtu = mtu
            self.socketAddress = socketAddress
        }

        public func validate(name: String) throws {
            try self.socketAddress.validate(name: "\(name).socketAddress")
        }

        private enum CodingKeys: String, CodingKey {
            case mtu = "mtu"
            case socketAddress = "socketAddress"
        }
    }

    public struct RangedSocketAddress: AWSEncodableShape & AWSDecodableShape {
        /// IPv4 socket address.
        public let name: String
        /// Port range of a socket address.
        public let portRange: IntegerRange

        @inlinable
        public init(name: String, portRange: IntegerRange) {
            self.name = name
            self.portRange = portRange
        }

        public func validate(name: String) throws {
            try self.validate(self.name, name: "name", parent: name, max: 16)
            try self.validate(self.name, name: "name", parent: name, min: 7)
            try self.validate(self.name, name: "name", parent: name, pattern: "^\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}$")
        }

        private enum CodingKeys: String, CodingKey {
            case name = "name"
            case portRange = "portRange"
        }
    }

    public struct RegisterAgentRequest: AWSEncodableShape {
        /// Detailed information about the agent being registered.
        public let agentDetails: AgentDetails
        /// Data for associating an agent with the capabilities it is managing.
        public let discoveryData: DiscoveryData
        /// Tags assigned to an Agent.
        public let tags: [String: String]?

        @inlinable
        public init(agentDetails: AgentDetails, discoveryData: DiscoveryData, tags: [String: String]? = nil) {
            self.agentDetails = agentDetails
            self.discoveryData = discoveryData
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.agentDetails.validate(name: "\(name).agentDetails")
            try self.discoveryData.validate(name: "\(name).discoveryData")
        }

        private enum CodingKeys: String, CodingKey {
            case agentDetails = "agentDetails"
            case discoveryData = "discoveryData"
            case tags = "tags"
        }
    }

    public struct RegisterAgentResponse: AWSDecodableShape {
        /// UUID of registered agent.
        public let agentId: String?

        @inlinable
        public init(agentId: String? = nil) {
            self.agentId = agentId
        }

        private enum CodingKeys: String, CodingKey {
            case agentId = "agentId"
        }
    }

    public struct ReserveContactRequest: AWSEncodableShape {
        /// End time of a contact in UTC.
        public let endTime: Date
        /// Name of a ground station.
        public let groundStation: String
        /// ARN of a mission profile.
        public let missionProfileArn: String
        /// ARN of a satellite
        public let satelliteArn: String
        /// Start time of a contact in UTC.
        public let startTime: Date
        /// Tags assigned to a contact.
        public let tags: [String: String]?

        @inlinable
        public init(endTime: Date, groundStation: String, missionProfileArn: String, satelliteArn: String, startTime: Date, tags: [String: String]? = nil) {
            self.endTime = endTime
            self.groundStation = groundStation
            self.missionProfileArn = missionProfileArn
            self.satelliteArn = satelliteArn
            self.startTime = startTime
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.validate(self.groundStation, name: "groundStation", parent: name, max: 500)
            try self.validate(self.groundStation, name: "groundStation", parent: name, min: 4)
            try self.validate(self.groundStation, name: "groundStation", parent: name, pattern: "^[ a-zA-Z0-9-._:=]{4,256}$")
            try self.validate(self.missionProfileArn, name: "missionProfileArn", parent: name, max: 138)
            try self.validate(self.missionProfileArn, name: "missionProfileArn", parent: name, min: 89)
            try self.validate(self.missionProfileArn, name: "missionProfileArn", parent: name, pattern: "^arn:aws:groundstation:[-a-z0-9]{1,50}:[0-9]{12}:mission-profile/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$")
            try self.validate(self.satelliteArn, name: "satelliteArn", parent: name, max: 132)
            try self.validate(self.satelliteArn, name: "satelliteArn", parent: name, min: 82)
            try self.validate(self.satelliteArn, name: "satelliteArn", parent: name, pattern: "^arn:aws:groundstation:([-a-z0-9]{1,50})?:[0-9]{12}:satellite/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$")
        }

        private enum CodingKeys: String, CodingKey {
            case endTime = "endTime"
            case groundStation = "groundStation"
            case missionProfileArn = "missionProfileArn"
            case satelliteArn = "satelliteArn"
            case startTime = "startTime"
            case tags = "tags"
        }
    }

    public struct ResourceLimitExceededException: AWSErrorShape {
        public let message: String?
        public let parameterName: String?

        @inlinable
        public init(message: String? = nil, parameterName: String? = nil) {
            self.message = message
            self.parameterName = parameterName
        }

        private enum CodingKeys: String, CodingKey {
            case message = "message"
            case parameterName = "parameterName"
        }
    }

    public struct S3Object: AWSEncodableShape & AWSDecodableShape {
        /// An Amazon S3 Bucket name.
        public let bucket: String?
        /// An Amazon S3 key for the ephemeris.
        public let key: String?
        /// For versioned S3 objects, the version to use for the ephemeris.
        public let version: String?

        @inlinable
        public init(bucket: String? = nil, key: String? = nil, version: String? = nil) {
            self.bucket = bucket
            self.key = key
            self.version = version
        }

        public func validate(name: String) throws {
            try self.validate(self.bucket, name: "bucket", parent: name, max: 63)
            try self.validate(self.bucket, name: "bucket", parent: name, min: 3)
            try self.validate(self.bucket, name: "bucket", parent: name, pattern: "^[a-z0-9.-]{3,63}$")
            try self.validate(self.key, name: "key", parent: name, max: 1024)
            try self.validate(self.key, name: "key", parent: name, min: 1)
            try self.validate(self.key, name: "key", parent: name, pattern: "^[a-zA-Z0-9!*'\\)\\(./_-]{1,1024}$")
            try self.validate(self.version, name: "version", parent: name, max: 1024)
            try self.validate(self.version, name: "version", parent: name, min: 1)
            try self.validate(self.version, name: "version", parent: name, pattern: "^[\\s\\S]{1,1024}$")
        }

        private enum CodingKeys: String, CodingKey {
            case bucket = "bucket"
            case key = "key"
            case version = "version"
        }
    }

    public struct S3RecordingConfig: AWSEncodableShape & AWSDecodableShape {
        /// ARN of the bucket to record to.
        public let bucketArn: String
        /// S3 Key prefix to prefice data files.
        public let prefix: String?
        /// ARN of the role Ground Station assumes to write data to the bucket.
        public let roleArn: String

        @inlinable
        public init(bucketArn: String, prefix: String? = nil, roleArn: String) {
            self.bucketArn = bucketArn
            self.prefix = prefix
            self.roleArn = roleArn
        }

        public func validate(name: String) throws {
            try self.validate(self.prefix, name: "prefix", parent: name, max: 900)
            try self.validate(self.prefix, name: "prefix", parent: name, min: 1)
            try self.validate(self.prefix, name: "prefix", parent: name, pattern: "^([a-zA-Z0-9_\\-=/]|\\{satellite_id\\}|\\{config\\-name}|\\{s3\\-config-id}|\\{year\\}|\\{month\\}|\\{day\\}){1,900}$")
        }

        private enum CodingKeys: String, CodingKey {
            case bucketArn = "bucketArn"
            case prefix = "prefix"
            case roleArn = "roleArn"
        }
    }

    public struct S3RecordingDetails: AWSDecodableShape {
        /// ARN of the bucket used.
        public let bucketArn: String?
        /// Key template used for the S3 Recording Configuration
        public let keyTemplate: String?

        @inlinable
        public init(bucketArn: String? = nil, keyTemplate: String? = nil) {
            self.bucketArn = bucketArn
            self.keyTemplate = keyTemplate
        }

        private enum CodingKeys: String, CodingKey {
            case bucketArn = "bucketArn"
            case keyTemplate = "keyTemplate"
        }
    }

    public struct SatelliteListItem: AWSDecodableShape {
        /// The current ephemeris being used to compute the trajectory of the satellite.
        public let currentEphemeris: EphemerisMetaData?
        /// A list of ground stations to which the satellite is on-boarded.
        public let groundStations: [String]?
        /// NORAD satellite ID number.
        public let noradSatelliteID: Int?
        /// ARN of a satellite.
        public let satelliteArn: String?
        /// UUID of a satellite.
        public let satelliteId: String?

        @inlinable
        public init(currentEphemeris: EphemerisMetaData? = nil, groundStations: [String]? = nil, noradSatelliteID: Int? = nil, satelliteArn: String? = nil, satelliteId: String? = nil) {
            self.currentEphemeris = currentEphemeris
            self.groundStations = groundStations
            self.noradSatelliteID = noradSatelliteID
            self.satelliteArn = satelliteArn
            self.satelliteId = satelliteId
        }

        private enum CodingKeys: String, CodingKey {
            case currentEphemeris = "currentEphemeris"
            case groundStations = "groundStations"
            case noradSatelliteID = "noradSatelliteID"
            case satelliteArn = "satelliteArn"
            case satelliteId = "satelliteId"
        }
    }

    public struct SecurityDetails: AWSEncodableShape & AWSDecodableShape {
        /// ARN to a role needed for connecting streams to your instances.
        public let roleArn: String
        /// The security groups to attach to the elastic network interfaces.
        public let securityGroupIds: [String]
        /// A list of subnets where AWS Ground Station places elastic network interfaces to send streams to your instances.
        public let subnetIds: [String]

        @inlinable
        public init(roleArn: String, securityGroupIds: [String], subnetIds: [String]) {
            self.roleArn = roleArn
            self.securityGroupIds = securityGroupIds
            self.subnetIds = subnetIds
        }

        private enum CodingKeys: String, CodingKey {
            case roleArn = "roleArn"
            case securityGroupIds = "securityGroupIds"
            case subnetIds = "subnetIds"
        }
    }

    public struct SocketAddress: AWSEncodableShape & AWSDecodableShape {
        /// Name of a socket address.
        public let name: String
        /// Port of a socket address.
        public let port: Int

        @inlinable
        public init(name: String, port: Int) {
            self.name = name
            self.port = port
        }

        private enum CodingKeys: String, CodingKey {
            case name = "name"
            case port = "port"
        }
    }

    public struct Source: AWSDecodableShape {
        /// Additional details for a Config, if type is dataflow-endpoint or antenna-downlink-demod-decode
        public let configDetails: ConfigDetails?
        /// UUID of a Config.
        public let configId: String?
        /// Type of a Config.
        public let configType: ConfigCapabilityType?
        /// Region of a dataflow source.
        public let dataflowSourceRegion: String?

        @inlinable
        public init(configDetails: ConfigDetails? = nil, configId: String? = nil, configType: ConfigCapabilityType? = nil, dataflowSourceRegion: String? = nil) {
            self.configDetails = configDetails
            self.configId = configId
            self.configType = configType
            self.dataflowSourceRegion = dataflowSourceRegion
        }

        private enum CodingKeys: String, CodingKey {
            case configDetails = "configDetails"
            case configId = "configId"
            case configType = "configType"
            case dataflowSourceRegion = "dataflowSourceRegion"
        }
    }

    public struct SpectrumConfig: AWSEncodableShape & AWSDecodableShape {
        /// Bandwidth of a spectral Config. AWS Ground Station currently has the following bandwidth limitations:   For AntennaDownlinkDemodDecodeconfig, valid values are between 125 kHz to 650 MHz.   For AntennaDownlinkconfig valid values are between 10 kHz to 54 MHz.   For AntennaUplinkConfig, valid values are between 10 kHz to 54 MHz.
        public let bandwidth: FrequencyBandwidth
        /// Center frequency of a spectral Config. Valid values are between 2200 to 2300 MHz and 7750 to 8400 MHz for downlink and 2025 to 2120 MHz for uplink.
        public let centerFrequency: Frequency
        /// Polarization of a spectral Config. Capturing both "RIGHT_HAND" and "LEFT_HAND" polarization requires two separate configs.
        public let polarization: Polarization?

        @inlinable
        public init(bandwidth: FrequencyBandwidth, centerFrequency: Frequency, polarization: Polarization? = nil) {
            self.bandwidth = bandwidth
            self.centerFrequency = centerFrequency
            self.polarization = polarization
        }

        private enum CodingKeys: String, CodingKey {
            case bandwidth = "bandwidth"
            case centerFrequency = "centerFrequency"
            case polarization = "polarization"
        }
    }

    public struct TLEData: AWSEncodableShape {
        /// First line of two-line element set (TLE) data.
        public let tleLine1: String
        /// Second line of two-line element set (TLE) data.
        public let tleLine2: String
        /// The valid time range for the TLE. Gaps or overlap are not permitted.
        public let validTimeRange: TimeRange

        @inlinable
        public init(tleLine1: String, tleLine2: String, validTimeRange: TimeRange) {
            self.tleLine1 = tleLine1
            self.tleLine2 = tleLine2
            self.validTimeRange = validTimeRange
        }

        public func validate(name: String) throws {
            try self.validate(self.tleLine1, name: "tleLine1", parent: name, max: 69)
            try self.validate(self.tleLine1, name: "tleLine1", parent: name, min: 69)
            try self.validate(self.tleLine1, name: "tleLine1", parent: name, pattern: "^1 [ 0-9]{5}[A-Z] [ 0-9]{5}[ A-Z]{3} [ 0-9]{5}[.][ 0-9]{8} (?:(?:[ 0+-][.][ 0-9]{8})|(?: [ +-][.][ 0-9]{7})) [ +-][ 0-9]{5}[+-][ 0-9] [ +-][ 0-9]{5}[+-][ 0-9] [ 0-9] [ 0-9]{4}[ 0-9]$")
            try self.validate(self.tleLine2, name: "tleLine2", parent: name, max: 69)
            try self.validate(self.tleLine2, name: "tleLine2", parent: name, min: 69)
            try self.validate(self.tleLine2, name: "tleLine2", parent: name, pattern: "^2 [ 0-9]{5} [ 0-9]{3}[.][ 0-9]{4} [ 0-9]{3}[.][ 0-9]{4} [ 0-9]{7} [ 0-9]{3}[.][ 0-9]{4} [ 0-9]{3}[.][ 0-9]{4} [ 0-9]{2}[.][ 0-9]{13}[ 0-9]$")
        }

        private enum CodingKeys: String, CodingKey {
            case tleLine1 = "tleLine1"
            case tleLine2 = "tleLine2"
            case validTimeRange = "validTimeRange"
        }
    }

    public struct TLEEphemeris: AWSEncodableShape {
        /// Identifies the S3 object to be used as the ephemeris.
        public let s3Object: S3Object?
        /// The data for a TLE ephemeris, supplied directly in the request rather than through an S3 object.
        public let tleData: [TLEData]?

        @inlinable
        public init(s3Object: S3Object? = nil, tleData: [TLEData]? = nil) {
            self.s3Object = s3Object
            self.tleData = tleData
        }

        public func validate(name: String) throws {
            try self.s3Object?.validate(name: "\(name).s3Object")
            try self.tleData?.forEach {
                try $0.validate(name: "\(name).tleData[]")
            }
            try self.validate(self.tleData, name: "tleData", parent: name, max: 500)
            try self.validate(self.tleData, name: "tleData", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case s3Object = "s3Object"
            case tleData = "tleData"
        }
    }

    public struct TagResourceRequest: AWSEncodableShape {
        /// ARN of a resource tag.
        public let resourceArn: String
        /// Tags assigned to a resource.
        public let tags: [String: String]

        @inlinable
        public init(resourceArn: String, tags: [String: String]) {
            self.resourceArn = resourceArn
            self.tags = tags
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.resourceArn, key: "resourceArn")
            try container.encode(self.tags, forKey: .tags)
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, max: 1024)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, min: 5)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, pattern: "^(arn:aws:)[\\s\\S]{0,1024}$")
        }

        private enum CodingKeys: String, CodingKey {
            case tags = "tags"
        }
    }

    public struct TagResourceResponse: AWSDecodableShape {
        public init() {}
    }

    public struct TimeRange: AWSEncodableShape {
        /// Time in UTC at which the time range ends.
        public let endTime: Date
        /// Time in UTC at which the time range starts.
        public let startTime: Date

        @inlinable
        public init(endTime: Date, startTime: Date) {
            self.endTime = endTime
            self.startTime = startTime
        }

        private enum CodingKeys: String, CodingKey {
            case endTime = "endTime"
            case startTime = "startTime"
        }
    }

    public struct TrackingConfig: AWSEncodableShape & AWSDecodableShape {
        /// Current setting for autotrack.
        public let autotrack: Criticality

        @inlinable
        public init(autotrack: Criticality) {
            self.autotrack = autotrack
        }

        private enum CodingKeys: String, CodingKey {
            case autotrack = "autotrack"
        }
    }

    public struct UntagResourceRequest: AWSEncodableShape {
        /// ARN of a resource.
        public let resourceArn: String
        /// Keys of a resource tag.
        public let tagKeys: [String]

        @inlinable
        public init(resourceArn: String, tagKeys: [String]) {
            self.resourceArn = resourceArn
            self.tagKeys = tagKeys
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.resourceArn, key: "resourceArn")
            request.encodeQuery(self.tagKeys, key: "tagKeys")
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, max: 1024)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, min: 5)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, pattern: "^(arn:aws:)[\\s\\S]{0,1024}$")
            try self.tagKeys.forEach {
                try validate($0, name: "tagKeys[]", parent: name, min: 1)
                try validate($0, name: "tagKeys[]", parent: name, pattern: "^[\\s\\S]+$")
            }
            try self.validate(self.tagKeys, name: "tagKeys", parent: name, max: 500)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct UntagResourceResponse: AWSDecodableShape {
        public init() {}
    }

    public struct UpdateAgentStatusRequest: AWSEncodableShape {
        /// UUID of agent to update.
        public let agentId: String
        /// Aggregate status for agent.
        public let aggregateStatus: AggregateStatus
        /// List of component statuses for agent.
        public let componentStatuses: [ComponentStatusData]
        /// GUID of agent task.
        public let taskId: String

        @inlinable
        public init(agentId: String, aggregateStatus: AggregateStatus, componentStatuses: [ComponentStatusData], taskId: String) {
            self.agentId = agentId
            self.aggregateStatus = aggregateStatus
            self.componentStatuses = componentStatuses
            self.taskId = taskId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.agentId, key: "agentId")
            try container.encode(self.aggregateStatus, forKey: .aggregateStatus)
            try container.encode(self.componentStatuses, forKey: .componentStatuses)
            try container.encode(self.taskId, forKey: .taskId)
        }

        public func validate(name: String) throws {
            try self.validate(self.agentId, name: "agentId", parent: name, max: 36)
            try self.validate(self.agentId, name: "agentId", parent: name, min: 36)
            try self.validate(self.agentId, name: "agentId", parent: name, pattern: "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$")
            try self.componentStatuses.forEach {
                try $0.validate(name: "\(name).componentStatuses[]")
            }
            try self.validate(self.componentStatuses, name: "componentStatuses", parent: name, max: 20)
            try self.validate(self.taskId, name: "taskId", parent: name, max: 36)
            try self.validate(self.taskId, name: "taskId", parent: name, min: 36)
            try self.validate(self.taskId, name: "taskId", parent: name, pattern: "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$")
        }

        private enum CodingKeys: String, CodingKey {
            case aggregateStatus = "aggregateStatus"
            case componentStatuses = "componentStatuses"
            case taskId = "taskId"
        }
    }

    public struct UpdateAgentStatusResponse: AWSDecodableShape {
        /// UUID of updated agent.
        public let agentId: String

        @inlinable
        public init(agentId: String) {
            self.agentId = agentId
        }

        private enum CodingKeys: String, CodingKey {
            case agentId = "agentId"
        }
    }

    public struct UpdateConfigRequest: AWSEncodableShape {
        /// Parameters of a Config.
        public let configData: ConfigTypeData
        /// UUID of a Config.
        public let configId: String
        /// Type of a Config.
        public let configType: ConfigCapabilityType
        /// Name of a Config.
        public let name: String

        @inlinable
        public init(configData: ConfigTypeData, configId: String, configType: ConfigCapabilityType, name: String) {
            self.configData = configData
            self.configId = configId
            self.configType = configType
            self.name = name
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encode(self.configData, forKey: .configData)
            request.encodePath(self.configId, key: "configId")
            request.encodePath(self.configType, key: "configType")
            try container.encode(self.name, forKey: .name)
        }

        public func validate(name: String) throws {
            try self.configData.validate(name: "\(name).configData")
            try self.validate(self.configId, name: "configId", parent: name, max: 36)
            try self.validate(self.configId, name: "configId", parent: name, min: 36)
            try self.validate(self.configId, name: "configId", parent: name, pattern: "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$")
            try self.validate(self.name, name: "name", parent: name, max: 256)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[ a-zA-Z0-9_:-]{1,256}$")
        }

        private enum CodingKeys: String, CodingKey {
            case configData = "configData"
            case name = "name"
        }
    }

    public struct UpdateEphemerisRequest: AWSEncodableShape {
        /// Whether the ephemeris is enabled or not. Changing this value will not require the ephemeris to be re-validated.
        public let enabled: Bool
        /// The AWS Ground Station ephemeris ID.
        public let ephemerisId: String
        /// A name string associated with the ephemeris. Used as a human-readable identifier for the ephemeris.
        public let name: String?
        /// Customer-provided priority score to establish the order in which overlapping ephemerides should be used. The default for customer-provided ephemeris priority is 1, and higher numbers take precedence. Priority must be 1 or greater
        public let priority: Int?

        @inlinable
        public init(enabled: Bool, ephemerisId: String, name: String? = nil, priority: Int? = nil) {
            self.enabled = enabled
            self.ephemerisId = ephemerisId
            self.name = name
            self.priority = priority
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encode(self.enabled, forKey: .enabled)
            request.encodePath(self.ephemerisId, key: "ephemerisId")
            try container.encodeIfPresent(self.name, forKey: .name)
            try container.encodeIfPresent(self.priority, forKey: .priority)
        }

        public func validate(name: String) throws {
            try self.validate(self.ephemerisId, name: "ephemerisId", parent: name, max: 36)
            try self.validate(self.ephemerisId, name: "ephemerisId", parent: name, min: 36)
            try self.validate(self.ephemerisId, name: "ephemerisId", parent: name, pattern: "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$")
            try self.validate(self.name, name: "name", parent: name, max: 256)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[ a-zA-Z0-9_:-]{1,256}$")
            try self.validate(self.priority, name: "priority", parent: name, max: 99999)
            try self.validate(self.priority, name: "priority", parent: name, min: 0)
        }

        private enum CodingKeys: String, CodingKey {
            case enabled = "enabled"
            case name = "name"
            case priority = "priority"
        }
    }

    public struct UpdateMissionProfileRequest: AWSEncodableShape {
        /// Amount of time after a contact ends that you’d like to receive a Ground Station Contact State Change event indicating the pass has finished.
        public let contactPostPassDurationSeconds: Int?
        /// Amount of time after a contact ends that you’d like to receive a Ground Station Contact State Change event indicating the pass has finished.
        public let contactPrePassDurationSeconds: Int?
        /// A list of lists of ARNs. Each list of ARNs is an edge, with a from Config and a to Config.
        public let dataflowEdges: [[String]]?
        /// Smallest amount of time in seconds that you’d like to see for an available contact. AWS Ground Station will not present you with contacts shorter than this duration.
        public let minimumViableContactDurationSeconds: Int?
        /// UUID of a mission profile.
        public let missionProfileId: String
        /// Name of a mission profile.
        public let name: String?
        /// KMS key to use for encrypting streams.
        public let streamsKmsKey: KmsKey?
        /// Role to use for encrypting streams with KMS key.
        public let streamsKmsRole: String?
        /// ARN of a tracking Config.
        public let trackingConfigArn: String?

        @inlinable
        public init(contactPostPassDurationSeconds: Int? = nil, contactPrePassDurationSeconds: Int? = nil, dataflowEdges: [[String]]? = nil, minimumViableContactDurationSeconds: Int? = nil, missionProfileId: String, name: String? = nil, streamsKmsKey: KmsKey? = nil, streamsKmsRole: String? = nil, trackingConfigArn: String? = nil) {
            self.contactPostPassDurationSeconds = contactPostPassDurationSeconds
            self.contactPrePassDurationSeconds = contactPrePassDurationSeconds
            self.dataflowEdges = dataflowEdges
            self.minimumViableContactDurationSeconds = minimumViableContactDurationSeconds
            self.missionProfileId = missionProfileId
            self.name = name
            self.streamsKmsKey = streamsKmsKey
            self.streamsKmsRole = streamsKmsRole
            self.trackingConfigArn = trackingConfigArn
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.contactPostPassDurationSeconds, forKey: .contactPostPassDurationSeconds)
            try container.encodeIfPresent(self.contactPrePassDurationSeconds, forKey: .contactPrePassDurationSeconds)
            try container.encodeIfPresent(self.dataflowEdges, forKey: .dataflowEdges)
            try container.encodeIfPresent(self.minimumViableContactDurationSeconds, forKey: .minimumViableContactDurationSeconds)
            request.encodePath(self.missionProfileId, key: "missionProfileId")
            try container.encodeIfPresent(self.name, forKey: .name)
            try container.encodeIfPresent(self.streamsKmsKey, forKey: .streamsKmsKey)
            try container.encodeIfPresent(self.streamsKmsRole, forKey: .streamsKmsRole)
            try container.encodeIfPresent(self.trackingConfigArn, forKey: .trackingConfigArn)
        }

        public func validate(name: String) throws {
            try self.validate(self.contactPostPassDurationSeconds, name: "contactPostPassDurationSeconds", parent: name, max: 21600)
            try self.validate(self.contactPostPassDurationSeconds, name: "contactPostPassDurationSeconds", parent: name, min: 0)
            try self.validate(self.contactPrePassDurationSeconds, name: "contactPrePassDurationSeconds", parent: name, max: 21600)
            try self.validate(self.contactPrePassDurationSeconds, name: "contactPrePassDurationSeconds", parent: name, min: 0)
            try self.dataflowEdges?.forEach {
                try validate($0, name: "dataflowEdges[]", parent: name, max: 2)
                try validate($0, name: "dataflowEdges[]", parent: name, min: 2)
            }
            try self.validate(self.dataflowEdges, name: "dataflowEdges", parent: name, max: 500)
            try self.validate(self.minimumViableContactDurationSeconds, name: "minimumViableContactDurationSeconds", parent: name, max: 21600)
            try self.validate(self.minimumViableContactDurationSeconds, name: "minimumViableContactDurationSeconds", parent: name, min: 1)
            try self.validate(self.missionProfileId, name: "missionProfileId", parent: name, max: 36)
            try self.validate(self.missionProfileId, name: "missionProfileId", parent: name, min: 36)
            try self.validate(self.missionProfileId, name: "missionProfileId", parent: name, pattern: "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$")
            try self.validate(self.name, name: "name", parent: name, max: 256)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[ a-zA-Z0-9_:-]{1,256}$")
            try self.streamsKmsKey?.validate(name: "\(name).streamsKmsKey")
            try self.validate(self.trackingConfigArn, name: "trackingConfigArn", parent: name, max: 424)
            try self.validate(self.trackingConfigArn, name: "trackingConfigArn", parent: name, min: 82)
            try self.validate(self.trackingConfigArn, name: "trackingConfigArn", parent: name, pattern: "^arn:aws:groundstation:[-a-z0-9]{1,50}:[0-9]{12}:config/[a-z0-9]+(-[a-z0-9]+){0,4}/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}(/.{1,256})?$")
        }

        private enum CodingKeys: String, CodingKey {
            case contactPostPassDurationSeconds = "contactPostPassDurationSeconds"
            case contactPrePassDurationSeconds = "contactPrePassDurationSeconds"
            case dataflowEdges = "dataflowEdges"
            case minimumViableContactDurationSeconds = "minimumViableContactDurationSeconds"
            case name = "name"
            case streamsKmsKey = "streamsKmsKey"
            case streamsKmsRole = "streamsKmsRole"
            case trackingConfigArn = "trackingConfigArn"
        }
    }

    public struct UplinkEchoConfig: AWSEncodableShape & AWSDecodableShape {
        /// ARN of an uplink Config.
        public let antennaUplinkConfigArn: String
        /// Whether or not an uplink Config is enabled.
        public let enabled: Bool

        @inlinable
        public init(antennaUplinkConfigArn: String, enabled: Bool) {
            self.antennaUplinkConfigArn = antennaUplinkConfigArn
            self.enabled = enabled
        }

        public func validate(name: String) throws {
            try self.validate(self.antennaUplinkConfigArn, name: "antennaUplinkConfigArn", parent: name, max: 424)
            try self.validate(self.antennaUplinkConfigArn, name: "antennaUplinkConfigArn", parent: name, min: 82)
            try self.validate(self.antennaUplinkConfigArn, name: "antennaUplinkConfigArn", parent: name, pattern: "^arn:aws:groundstation:[-a-z0-9]{1,50}:[0-9]{12}:config/[a-z0-9]+(-[a-z0-9]+){0,4}/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}(/.{1,256})?$")
        }

        private enum CodingKeys: String, CodingKey {
            case antennaUplinkConfigArn = "antennaUplinkConfigArn"
            case enabled = "enabled"
        }
    }

    public struct UplinkSpectrumConfig: AWSEncodableShape & AWSDecodableShape {
        /// Center frequency of an uplink spectral Config. Valid values are between 2025 to 2120 MHz.
        public let centerFrequency: Frequency
        /// Polarization of an uplink spectral Config. Capturing both "RIGHT_HAND" and "LEFT_HAND" polarization requires two separate configs.
        public let polarization: Polarization?

        @inlinable
        public init(centerFrequency: Frequency, polarization: Polarization? = nil) {
            self.centerFrequency = centerFrequency
            self.polarization = polarization
        }

        private enum CodingKeys: String, CodingKey {
            case centerFrequency = "centerFrequency"
            case polarization = "polarization"
        }
    }
}

// MARK: - Errors

/// Error enum for GroundStation
public struct GroundStationErrorType: AWSErrorType {
    enum Code: String {
        case dependencyException = "DependencyException"
        case invalidParameterException = "InvalidParameterException"
        case resourceLimitExceededException = "ResourceLimitExceededException"
        case resourceNotFoundException = "ResourceNotFoundException"
    }

    private let error: Code
    public let context: AWSErrorContext?

    /// initialize GroundStation
    public init?(errorCode: String, context: AWSErrorContext) {
        guard let error = Code(rawValue: errorCode) else { return nil }
        self.error = error
        self.context = context
    }

    internal init(_ error: Code) {
        self.error = error
        self.context = nil
    }

    /// return error code string
    public var errorCode: String { self.error.rawValue }

    /// Dependency encountered an error.
    public static var dependencyException: Self { .init(.dependencyException) }
    /// One or more parameters are not valid.
    public static var invalidParameterException: Self { .init(.invalidParameterException) }
    /// Account limits for this resource have been exceeded.
    public static var resourceLimitExceededException: Self { .init(.resourceLimitExceededException) }
    /// Resource was not found.
    public static var resourceNotFoundException: Self { .init(.resourceNotFoundException) }
}

extension GroundStationErrorType: AWSServiceErrorType {
    public static let errorCodeMap: [String: AWSErrorShape.Type] = [
        "DependencyException": GroundStation.DependencyException.self,
        "InvalidParameterException": GroundStation.InvalidParameterException.self,
        "ResourceLimitExceededException": GroundStation.ResourceLimitExceededException.self
    ]
}

extension GroundStationErrorType: Equatable {
    public static func == (lhs: GroundStationErrorType, rhs: GroundStationErrorType) -> Bool {
        lhs.error == rhs.error
    }
}

extension GroundStationErrorType: CustomStringConvertible {
    public var description: String {
        return "\(self.error.rawValue): \(self.message ?? "")"
    }
}
