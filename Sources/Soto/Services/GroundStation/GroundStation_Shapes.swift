//===----------------------------------------------------------------------===//
//
// This source file is part of the Soto for AWS open source project
//
// Copyright (c) 2017-2021 the Soto project authors
// Licensed under Apache License v2.0
//
// See LICENSE.txt for license information
// See CONTRIBUTORS.txt for the list of Soto project authors
//
// SPDX-License-Identifier: Apache-2.0
//
//===----------------------------------------------------------------------===//

// THIS FILE IS AUTOMATICALLY GENERATED by https://github.com/soto-project/soto-codegenerator.
// DO NOT EDIT.

import Foundation
import SotoCore

extension GroundStation {
    // MARK: Enums

    public enum AngleUnits: String, CustomStringConvertible, Codable {
        case degreeAngle = "DEGREE_ANGLE"
        case radian = "RADIAN"
        public var description: String { return self.rawValue }
    }

    public enum BandwidthUnits: String, CustomStringConvertible, Codable {
        case ghz = "GHz"
        case mhz = "MHz"
        case khz = "kHz"
        public var description: String { return self.rawValue }
    }

    public enum ConfigCapabilityType: String, CustomStringConvertible, Codable {
        case antennaDownlink = "antenna-downlink"
        case antennaDownlinkDemodDecode = "antenna-downlink-demod-decode"
        case antennaUplink = "antenna-uplink"
        case dataflowEndpoint = "dataflow-endpoint"
        case s3Recording = "s3-recording"
        case tracking
        case uplinkEcho = "uplink-echo"
        public var description: String { return self.rawValue }
    }

    public enum ContactStatus: String, CustomStringConvertible, Codable {
        case available = "AVAILABLE"
        case awsCancelled = "AWS_CANCELLED"
        case awsFailed = "AWS_FAILED"
        case cancelled = "CANCELLED"
        case cancelling = "CANCELLING"
        case completed = "COMPLETED"
        case failed = "FAILED"
        case failedToSchedule = "FAILED_TO_SCHEDULE"
        case pass = "PASS"
        case postpass = "POSTPASS"
        case prepass = "PREPASS"
        case scheduled = "SCHEDULED"
        case scheduling = "SCHEDULING"
        public var description: String { return self.rawValue }
    }

    public enum Criticality: String, CustomStringConvertible, Codable {
        case preferred = "PREFERRED"
        case removed = "REMOVED"
        case required = "REQUIRED"
        public var description: String { return self.rawValue }
    }

    public enum EirpUnits: String, CustomStringConvertible, Codable {
        case dbw = "dBW"
        public var description: String { return self.rawValue }
    }

    public enum EndpointStatus: String, CustomStringConvertible, Codable {
        case created
        case creating
        case deleted
        case deleting
        case failed
        public var description: String { return self.rawValue }
    }

    public enum FrequencyUnits: String, CustomStringConvertible, Codable {
        case ghz = "GHz"
        case mhz = "MHz"
        case khz = "kHz"
        public var description: String { return self.rawValue }
    }

    public enum Polarization: String, CustomStringConvertible, Codable {
        case leftHand = "LEFT_HAND"
        case none = "NONE"
        case rightHand = "RIGHT_HAND"
        public var description: String { return self.rawValue }
    }

    public enum ConfigDetails: AWSDecodableShape {
        /// Details for antenna demod decode Config in a contact.
        case antennaDemodDecodeDetails(AntennaDemodDecodeDetails)
        case endpointDetails(EndpointDetails)
        /// Details for an S3 recording Config in a contact.
        case s3RecordingDetails(S3RecordingDetails)

        public init(from decoder: Decoder) throws {
            let container = try decoder.container(keyedBy: CodingKeys.self)
            guard container.allKeys.count == 1, let key = container.allKeys.first else {
                let context = DecodingError.Context(
                    codingPath: container.codingPath,
                    debugDescription: "Expected exactly one key, but got \(container.allKeys.count)"
                )
                throw DecodingError.dataCorrupted(context)
            }
            switch key {
            case .antennaDemodDecodeDetails:
                let value = try container.decode(AntennaDemodDecodeDetails.self, forKey: .antennaDemodDecodeDetails)
                self = .antennaDemodDecodeDetails(value)
            case .endpointDetails:
                let value = try container.decode(EndpointDetails.self, forKey: .endpointDetails)
                self = .endpointDetails(value)
            case .s3RecordingDetails:
                let value = try container.decode(S3RecordingDetails.self, forKey: .s3RecordingDetails)
                self = .s3RecordingDetails(value)
            }
        }

        private enum CodingKeys: String, CodingKey {
            case antennaDemodDecodeDetails
            case endpointDetails
            case s3RecordingDetails
        }
    }

    public enum ConfigTypeData: AWSEncodableShape & AWSDecodableShape {
        /// Information about how AWS Ground Station should configure an antenna for downlink during a contact.
        case antennaDownlinkConfig(AntennaDownlinkConfig)
        /// Information about how AWS Ground Station should conﬁgure an antenna for downlink demod decode during a contact.
        case antennaDownlinkDemodDecodeConfig(AntennaDownlinkDemodDecodeConfig)
        /// Information about how AWS Ground Station should conﬁgure an antenna for uplink during a contact.
        case antennaUplinkConfig(AntennaUplinkConfig)
        /// Information about the dataflow endpoint Config.
        case dataflowEndpointConfig(DataflowEndpointConfig)
        /// Information about an S3 recording Config.
        case s3RecordingConfig(S3RecordingConfig)
        /// Object that determines whether tracking should be used during a contact executed with this Config in the mission profile.
        case trackingConfig(TrackingConfig)
        /// Information about an uplink echo Config. Parameters from the AntennaUplinkConfig, corresponding to the specified AntennaUplinkConfigArn, are used when this UplinkEchoConfig is used in a contact.
        case uplinkEchoConfig(UplinkEchoConfig)

        public init(from decoder: Decoder) throws {
            let container = try decoder.container(keyedBy: CodingKeys.self)
            guard container.allKeys.count == 1, let key = container.allKeys.first else {
                let context = DecodingError.Context(
                    codingPath: container.codingPath,
                    debugDescription: "Expected exactly one key, but got \(container.allKeys.count)"
                )
                throw DecodingError.dataCorrupted(context)
            }
            switch key {
            case .antennaDownlinkConfig:
                let value = try container.decode(AntennaDownlinkConfig.self, forKey: .antennaDownlinkConfig)
                self = .antennaDownlinkConfig(value)
            case .antennaDownlinkDemodDecodeConfig:
                let value = try container.decode(AntennaDownlinkDemodDecodeConfig.self, forKey: .antennaDownlinkDemodDecodeConfig)
                self = .antennaDownlinkDemodDecodeConfig(value)
            case .antennaUplinkConfig:
                let value = try container.decode(AntennaUplinkConfig.self, forKey: .antennaUplinkConfig)
                self = .antennaUplinkConfig(value)
            case .dataflowEndpointConfig:
                let value = try container.decode(DataflowEndpointConfig.self, forKey: .dataflowEndpointConfig)
                self = .dataflowEndpointConfig(value)
            case .s3RecordingConfig:
                let value = try container.decode(S3RecordingConfig.self, forKey: .s3RecordingConfig)
                self = .s3RecordingConfig(value)
            case .trackingConfig:
                let value = try container.decode(TrackingConfig.self, forKey: .trackingConfig)
                self = .trackingConfig(value)
            case .uplinkEchoConfig:
                let value = try container.decode(UplinkEchoConfig.self, forKey: .uplinkEchoConfig)
                self = .uplinkEchoConfig(value)
            }
        }

        public func encode(to encoder: Encoder) throws {
            var container = encoder.container(keyedBy: CodingKeys.self)
            switch self {
            case .antennaDownlinkConfig(let value):
                try container.encode(value, forKey: .antennaDownlinkConfig)
            case .antennaDownlinkDemodDecodeConfig(let value):
                try container.encode(value, forKey: .antennaDownlinkDemodDecodeConfig)
            case .antennaUplinkConfig(let value):
                try container.encode(value, forKey: .antennaUplinkConfig)
            case .dataflowEndpointConfig(let value):
                try container.encode(value, forKey: .dataflowEndpointConfig)
            case .s3RecordingConfig(let value):
                try container.encode(value, forKey: .s3RecordingConfig)
            case .trackingConfig(let value):
                try container.encode(value, forKey: .trackingConfig)
            case .uplinkEchoConfig(let value):
                try container.encode(value, forKey: .uplinkEchoConfig)
            }
        }

        public func validate(name: String) throws {
            switch self {
            case .antennaDownlinkDemodDecodeConfig(let value):
                try value.validate(name: "\(name).antennaDownlinkDemodDecodeConfig")
            case .s3RecordingConfig(let value):
                try value.validate(name: "\(name).s3RecordingConfig")
            default:
                break
            }
        }

        private enum CodingKeys: String, CodingKey {
            case antennaDownlinkConfig
            case antennaDownlinkDemodDecodeConfig
            case antennaUplinkConfig
            case dataflowEndpointConfig
            case s3RecordingConfig
            case trackingConfig
            case uplinkEchoConfig
        }
    }

    // MARK: Shapes

    public struct AntennaDemodDecodeDetails: AWSDecodableShape {
        /// Name of an antenna demod decode output node used in a contact.
        public let outputNode: String?

        public init(outputNode: String? = nil) {
            self.outputNode = outputNode
        }

        private enum CodingKeys: String, CodingKey {
            case outputNode
        }
    }

    public struct AntennaDownlinkConfig: AWSEncodableShape & AWSDecodableShape {
        /// Object that describes a spectral Config.
        public let spectrumConfig: SpectrumConfig

        public init(spectrumConfig: SpectrumConfig) {
            self.spectrumConfig = spectrumConfig
        }

        private enum CodingKeys: String, CodingKey {
            case spectrumConfig
        }
    }

    public struct AntennaDownlinkDemodDecodeConfig: AWSEncodableShape & AWSDecodableShape {
        /// Information about the decode Config.
        public let decodeConfig: DecodeConfig
        /// Information about the demodulation Config.
        public let demodulationConfig: DemodulationConfig
        /// Information about the spectral Config.
        public let spectrumConfig: SpectrumConfig

        public init(decodeConfig: DecodeConfig, demodulationConfig: DemodulationConfig, spectrumConfig: SpectrumConfig) {
            self.decodeConfig = decodeConfig
            self.demodulationConfig = demodulationConfig
            self.spectrumConfig = spectrumConfig
        }

        public func validate(name: String) throws {
            try self.decodeConfig.validate(name: "\(name).decodeConfig")
            try self.demodulationConfig.validate(name: "\(name).demodulationConfig")
        }

        private enum CodingKeys: String, CodingKey {
            case decodeConfig
            case demodulationConfig
            case spectrumConfig
        }
    }

    public struct AntennaUplinkConfig: AWSEncodableShape & AWSDecodableShape {
        /// Information about the uplink spectral Config.
        public let spectrumConfig: UplinkSpectrumConfig
        /// EIRP of the target.
        public let targetEirp: Eirp
        /// Whether or not uplink transmit is disabled.
        public let transmitDisabled: Bool?

        public init(spectrumConfig: UplinkSpectrumConfig, targetEirp: Eirp, transmitDisabled: Bool? = nil) {
            self.spectrumConfig = spectrumConfig
            self.targetEirp = targetEirp
            self.transmitDisabled = transmitDisabled
        }

        private enum CodingKeys: String, CodingKey {
            case spectrumConfig
            case targetEirp
            case transmitDisabled
        }
    }

    public struct CancelContactRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "contactId", location: .uri(locationName: "contactId"))
        ]

        /// UUID of a contact.
        public let contactId: String

        public init(contactId: String) {
            self.contactId = contactId
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ConfigIdResponse: AWSDecodableShape {
        /// ARN of a Config.
        public let configArn: String?
        /// UUID of a Config.
        public let configId: String?
        /// Type of a Config.
        public let configType: ConfigCapabilityType?

        public init(configArn: String? = nil, configId: String? = nil, configType: ConfigCapabilityType? = nil) {
            self.configArn = configArn
            self.configId = configId
            self.configType = configType
        }

        private enum CodingKeys: String, CodingKey {
            case configArn
            case configId
            case configType
        }
    }

    public struct ConfigListItem: AWSDecodableShape {
        /// ARN of a Config.
        public let configArn: String?
        /// UUID of a Config.
        public let configId: String?
        /// Type of a Config.
        public let configType: ConfigCapabilityType?
        /// Name of a Config.
        public let name: String?

        public init(configArn: String? = nil, configId: String? = nil, configType: ConfigCapabilityType? = nil, name: String? = nil) {
            self.configArn = configArn
            self.configId = configId
            self.configType = configType
            self.name = name
        }

        private enum CodingKeys: String, CodingKey {
            case configArn
            case configId
            case configType
            case name
        }
    }

    public struct ContactData: AWSDecodableShape {
        /// UUID of a contact.
        public let contactId: String?
        /// Status of a contact.
        public let contactStatus: ContactStatus?
        /// End time of a contact.
        public let endTime: Date?
        /// Error message of a contact.
        public let errorMessage: String?
        /// Name of a ground station.
        public let groundStation: String?
        /// Maximum elevation angle of a contact.
        public let maximumElevation: Elevation?
        /// ARN of a mission profile.
        public let missionProfileArn: String?
        /// Amount of time after a contact ends that you’d like to receive a CloudWatch event indicating the pass has finished.
        public let postPassEndTime: Date?
        /// Amount of time prior to contact start you’d like to receive a CloudWatch event indicating an upcoming pass.
        public let prePassStartTime: Date?
        /// Region of a contact.
        public let region: String?
        /// ARN of a satellite.
        public let satelliteArn: String?
        /// Start time of a contact.
        public let startTime: Date?
        /// Tags assigned to a contact.
        public let tags: [String: String]?

        public init(contactId: String? = nil, contactStatus: ContactStatus? = nil, endTime: Date? = nil, errorMessage: String? = nil, groundStation: String? = nil, maximumElevation: Elevation? = nil, missionProfileArn: String? = nil, postPassEndTime: Date? = nil, prePassStartTime: Date? = nil, region: String? = nil, satelliteArn: String? = nil, startTime: Date? = nil, tags: [String: String]? = nil) {
            self.contactId = contactId
            self.contactStatus = contactStatus
            self.endTime = endTime
            self.errorMessage = errorMessage
            self.groundStation = groundStation
            self.maximumElevation = maximumElevation
            self.missionProfileArn = missionProfileArn
            self.postPassEndTime = postPassEndTime
            self.prePassStartTime = prePassStartTime
            self.region = region
            self.satelliteArn = satelliteArn
            self.startTime = startTime
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case contactId
            case contactStatus
            case endTime
            case errorMessage
            case groundStation
            case maximumElevation
            case missionProfileArn
            case postPassEndTime
            case prePassStartTime
            case region
            case satelliteArn
            case startTime
            case tags
        }
    }

    public struct ContactIdResponse: AWSDecodableShape {
        /// UUID of a contact.
        public let contactId: String?

        public init(contactId: String? = nil) {
            self.contactId = contactId
        }

        private enum CodingKeys: String, CodingKey {
            case contactId
        }
    }

    public struct CreateConfigRequest: AWSEncodableShape {
        /// Parameters of a Config.
        public let configData: ConfigTypeData
        /// Name of a Config.
        public let name: String
        /// Tags assigned to a Config.
        public let tags: [String: String]?

        public init(configData: ConfigTypeData, name: String, tags: [String: String]? = nil) {
            self.configData = configData
            self.name = name
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.configData.validate(name: "\(name).configData")
            try self.validate(self.name, name: "name", parent: name, max: 256)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[ a-zA-Z0-9_:-]{1,256}$")
        }

        private enum CodingKeys: String, CodingKey {
            case configData
            case name
            case tags
        }
    }

    public struct CreateDataflowEndpointGroupRequest: AWSEncodableShape {
        /// Endpoint details of each endpoint in the dataflow endpoint group.
        public let endpointDetails: [EndpointDetails]
        /// Tags of a dataflow endpoint group.
        public let tags: [String: String]?

        public init(endpointDetails: [EndpointDetails], tags: [String: String]? = nil) {
            self.endpointDetails = endpointDetails
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.endpointDetails.forEach {
                try $0.validate(name: "\(name).endpointDetails[]")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case endpointDetails
            case tags
        }
    }

    public struct CreateMissionProfileRequest: AWSEncodableShape {
        /// Amount of time after a contact ends that you’d like to receive a CloudWatch event indicating the pass has finished.
        public let contactPostPassDurationSeconds: Int?
        /// Amount of time prior to contact start you’d like to receive a CloudWatch event indicating an upcoming pass.
        public let contactPrePassDurationSeconds: Int?
        /// A list of lists of ARNs. Each list of ARNs is an edge, with a from  Config and a to Config.
        public let dataflowEdges: [[String]]
        /// Smallest amount of time in seconds that you’d like to see for an available contact. AWS Ground Station will not present you with contacts shorter than this duration.
        public let minimumViableContactDurationSeconds: Int
        /// Name of a mission profile.
        public let name: String
        /// Tags assigned to a mission profile.
        public let tags: [String: String]?
        /// ARN of a tracking Config.
        public let trackingConfigArn: String

        public init(contactPostPassDurationSeconds: Int? = nil, contactPrePassDurationSeconds: Int? = nil, dataflowEdges: [[String]], minimumViableContactDurationSeconds: Int, name: String, tags: [String: String]? = nil, trackingConfigArn: String) {
            self.contactPostPassDurationSeconds = contactPostPassDurationSeconds
            self.contactPrePassDurationSeconds = contactPrePassDurationSeconds
            self.dataflowEdges = dataflowEdges
            self.minimumViableContactDurationSeconds = minimumViableContactDurationSeconds
            self.name = name
            self.tags = tags
            self.trackingConfigArn = trackingConfigArn
        }

        public func validate(name: String) throws {
            try self.validate(self.contactPostPassDurationSeconds, name: "contactPostPassDurationSeconds", parent: name, max: 21600)
            try self.validate(self.contactPostPassDurationSeconds, name: "contactPostPassDurationSeconds", parent: name, min: 1)
            try self.validate(self.contactPrePassDurationSeconds, name: "contactPrePassDurationSeconds", parent: name, max: 21600)
            try self.validate(self.contactPrePassDurationSeconds, name: "contactPrePassDurationSeconds", parent: name, min: 1)
            try self.dataflowEdges.forEach {
                try validate($0, name: "dataflowEdges[]", parent: name, max: 2)
                try validate($0, name: "dataflowEdges[]", parent: name, min: 2)
            }
            try self.validate(self.minimumViableContactDurationSeconds, name: "minimumViableContactDurationSeconds", parent: name, max: 21600)
            try self.validate(self.minimumViableContactDurationSeconds, name: "minimumViableContactDurationSeconds", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, max: 256)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[ a-zA-Z0-9_:-]{1,256}$")
        }

        private enum CodingKeys: String, CodingKey {
            case contactPostPassDurationSeconds
            case contactPrePassDurationSeconds
            case dataflowEdges
            case minimumViableContactDurationSeconds
            case name
            case tags
            case trackingConfigArn
        }
    }

    public struct DataflowDetail: AWSDecodableShape {
        public let destination: Destination?
        /// Error message for a dataflow.
        public let errorMessage: String?
        public let source: Source?

        public init(destination: Destination? = nil, errorMessage: String? = nil, source: Source? = nil) {
            self.destination = destination
            self.errorMessage = errorMessage
            self.source = source
        }

        private enum CodingKeys: String, CodingKey {
            case destination
            case errorMessage
            case source
        }
    }

    public struct DataflowEndpoint: AWSEncodableShape & AWSDecodableShape {
        /// Socket address of a dataflow endpoint.
        public let address: SocketAddress?
        /// Maximum transmission unit (MTU) size in bytes of a dataflow endpoint.
        public let mtu: Int?
        /// Name of a dataflow endpoint.
        public let name: String?
        /// Status of a dataflow endpoint.
        public let status: EndpointStatus?

        public init(address: SocketAddress? = nil, mtu: Int? = nil, name: String? = nil, status: EndpointStatus? = nil) {
            self.address = address
            self.mtu = mtu
            self.name = name
            self.status = status
        }

        public func validate(name: String) throws {
            try self.validate(self.name, name: "name", parent: name, max: 256)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[ a-zA-Z0-9_:-]{1,256}$")
        }

        private enum CodingKeys: String, CodingKey {
            case address
            case mtu
            case name
            case status
        }
    }

    public struct DataflowEndpointConfig: AWSEncodableShape & AWSDecodableShape {
        /// Name of a dataflow endpoint.
        public let dataflowEndpointName: String
        /// Region of a dataflow endpoint.
        public let dataflowEndpointRegion: String?

        public init(dataflowEndpointName: String, dataflowEndpointRegion: String? = nil) {
            self.dataflowEndpointName = dataflowEndpointName
            self.dataflowEndpointRegion = dataflowEndpointRegion
        }

        private enum CodingKeys: String, CodingKey {
            case dataflowEndpointName
            case dataflowEndpointRegion
        }
    }

    public struct DataflowEndpointGroupIdResponse: AWSDecodableShape {
        /// UUID of a dataflow endpoint group.
        public let dataflowEndpointGroupId: String?

        public init(dataflowEndpointGroupId: String? = nil) {
            self.dataflowEndpointGroupId = dataflowEndpointGroupId
        }

        private enum CodingKeys: String, CodingKey {
            case dataflowEndpointGroupId
        }
    }

    public struct DataflowEndpointListItem: AWSDecodableShape {
        /// ARN of a dataflow endpoint group.
        public let dataflowEndpointGroupArn: String?
        /// UUID of a dataflow endpoint group.
        public let dataflowEndpointGroupId: String?

        public init(dataflowEndpointGroupArn: String? = nil, dataflowEndpointGroupId: String? = nil) {
            self.dataflowEndpointGroupArn = dataflowEndpointGroupArn
            self.dataflowEndpointGroupId = dataflowEndpointGroupId
        }

        private enum CodingKeys: String, CodingKey {
            case dataflowEndpointGroupArn
            case dataflowEndpointGroupId
        }
    }

    public struct DecodeConfig: AWSEncodableShape & AWSDecodableShape {
        /// Unvalidated JSON of a decode Config.
        public let unvalidatedJSON: String

        public init(unvalidatedJSON: String) {
            self.unvalidatedJSON = unvalidatedJSON
        }

        public func validate(name: String) throws {
            try self.validate(self.unvalidatedJSON, name: "unvalidatedJSON", parent: name, max: 8192)
            try self.validate(self.unvalidatedJSON, name: "unvalidatedJSON", parent: name, min: 2)
            try self.validate(self.unvalidatedJSON, name: "unvalidatedJSON", parent: name, pattern: "^[{}\\[\\]:.,\"0-9A-z\\-_\\s]{2,8192}$")
        }

        private enum CodingKeys: String, CodingKey {
            case unvalidatedJSON
        }
    }

    public struct DeleteConfigRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "configId", location: .uri(locationName: "configId")),
            AWSMemberEncoding(label: "configType", location: .uri(locationName: "configType"))
        ]

        /// UUID of a Config.
        public let configId: String
        /// Type of a Config.
        public let configType: ConfigCapabilityType

        public init(configId: String, configType: ConfigCapabilityType) {
            self.configId = configId
            self.configType = configType
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteDataflowEndpointGroupRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "dataflowEndpointGroupId", location: .uri(locationName: "dataflowEndpointGroupId"))
        ]

        /// UUID of a dataflow endpoint group.
        public let dataflowEndpointGroupId: String

        public init(dataflowEndpointGroupId: String) {
            self.dataflowEndpointGroupId = dataflowEndpointGroupId
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteMissionProfileRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "missionProfileId", location: .uri(locationName: "missionProfileId"))
        ]

        /// UUID of a mission profile.
        public let missionProfileId: String

        public init(missionProfileId: String) {
            self.missionProfileId = missionProfileId
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DemodulationConfig: AWSEncodableShape & AWSDecodableShape {
        /// Unvalidated JSON of a demodulation Config.
        public let unvalidatedJSON: String

        public init(unvalidatedJSON: String) {
            self.unvalidatedJSON = unvalidatedJSON
        }

        public func validate(name: String) throws {
            try self.validate(self.unvalidatedJSON, name: "unvalidatedJSON", parent: name, max: 8192)
            try self.validate(self.unvalidatedJSON, name: "unvalidatedJSON", parent: name, min: 2)
            try self.validate(self.unvalidatedJSON, name: "unvalidatedJSON", parent: name, pattern: "^[{}\\[\\]:.,\"0-9A-z\\-_\\s]{2,8192}$")
        }

        private enum CodingKeys: String, CodingKey {
            case unvalidatedJSON
        }
    }

    public struct DescribeContactRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "contactId", location: .uri(locationName: "contactId"))
        ]

        /// UUID of a contact.
        public let contactId: String

        public init(contactId: String) {
            self.contactId = contactId
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DescribeContactResponse: AWSDecodableShape {
        /// UUID of a contact.
        public let contactId: String?
        /// Status of a contact.
        public let contactStatus: ContactStatus?
        /// List describing source and destination details for each dataflow edge.
        public let dataflowList: [DataflowDetail]?
        /// End time of a contact.
        public let endTime: Date?
        /// Error message for a contact.
        public let errorMessage: String?
        /// Ground station for a contact.
        public let groundStation: String?
        /// Maximum elevation angle of a contact.
        public let maximumElevation: Elevation?
        /// ARN of a mission profile.
        public let missionProfileArn: String?
        /// Amount of time after a contact ends that you’d like to receive a CloudWatch event indicating the pass has finished.
        public let postPassEndTime: Date?
        /// Amount of time prior to contact start you’d like to receive a CloudWatch event indicating an upcoming pass.
        public let prePassStartTime: Date?
        /// Region of a contact.
        public let region: String?
        /// ARN of a satellite.
        public let satelliteArn: String?
        /// Start time of a contact.
        public let startTime: Date?
        /// Tags assigned to a contact.
        public let tags: [String: String]?

        public init(contactId: String? = nil, contactStatus: ContactStatus? = nil, dataflowList: [DataflowDetail]? = nil, endTime: Date? = nil, errorMessage: String? = nil, groundStation: String? = nil, maximumElevation: Elevation? = nil, missionProfileArn: String? = nil, postPassEndTime: Date? = nil, prePassStartTime: Date? = nil, region: String? = nil, satelliteArn: String? = nil, startTime: Date? = nil, tags: [String: String]? = nil) {
            self.contactId = contactId
            self.contactStatus = contactStatus
            self.dataflowList = dataflowList
            self.endTime = endTime
            self.errorMessage = errorMessage
            self.groundStation = groundStation
            self.maximumElevation = maximumElevation
            self.missionProfileArn = missionProfileArn
            self.postPassEndTime = postPassEndTime
            self.prePassStartTime = prePassStartTime
            self.region = region
            self.satelliteArn = satelliteArn
            self.startTime = startTime
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case contactId
            case contactStatus
            case dataflowList
            case endTime
            case errorMessage
            case groundStation
            case maximumElevation
            case missionProfileArn
            case postPassEndTime
            case prePassStartTime
            case region
            case satelliteArn
            case startTime
            case tags
        }
    }

    public struct Destination: AWSDecodableShape {
        /// Additional details for a Config, if type is dataflow endpoint or antenna demod decode.
        public let configDetails: ConfigDetails?
        /// UUID of a Config.
        public let configId: String?
        /// Type of a Config.
        public let configType: ConfigCapabilityType?
        /// Region of a dataflow destination.
        public let dataflowDestinationRegion: String?

        public init(configDetails: ConfigDetails? = nil, configId: String? = nil, configType: ConfigCapabilityType? = nil, dataflowDestinationRegion: String? = nil) {
            self.configDetails = configDetails
            self.configId = configId
            self.configType = configType
            self.dataflowDestinationRegion = dataflowDestinationRegion
        }

        private enum CodingKeys: String, CodingKey {
            case configDetails
            case configId
            case configType
            case dataflowDestinationRegion
        }
    }

    public struct Eirp: AWSEncodableShape & AWSDecodableShape {
        /// Units of an EIRP.
        public let units: EirpUnits
        /// Value of an EIRP. Valid values are between 20.0 to 50.0 dBW.
        public let value: Double

        public init(units: EirpUnits, value: Double) {
            self.units = units
            self.value = value
        }

        private enum CodingKeys: String, CodingKey {
            case units
            case value
        }
    }

    public struct Elevation: AWSDecodableShape {
        /// Elevation angle units.
        public let unit: AngleUnits
        /// Elevation angle value.
        public let value: Double

        public init(unit: AngleUnits, value: Double) {
            self.unit = unit
            self.value = value
        }

        private enum CodingKeys: String, CodingKey {
            case unit
            case value
        }
    }

    public struct EndpointDetails: AWSEncodableShape & AWSDecodableShape {
        /// A dataflow endpoint.
        public let endpoint: DataflowEndpoint?
        /// Endpoint security details.
        public let securityDetails: SecurityDetails?

        public init(endpoint: DataflowEndpoint? = nil, securityDetails: SecurityDetails? = nil) {
            self.endpoint = endpoint
            self.securityDetails = securityDetails
        }

        public func validate(name: String) throws {
            try self.endpoint?.validate(name: "\(name).endpoint")
        }

        private enum CodingKeys: String, CodingKey {
            case endpoint
            case securityDetails
        }
    }

    public struct Frequency: AWSEncodableShape & AWSDecodableShape {
        /// Frequency units.
        public let units: FrequencyUnits
        /// Frequency value. Valid values are between 2200 to 2300 MHz and 7750 to 8400 MHz for downlink and 2025 to 2120 MHz for uplink.
        public let value: Double

        public init(units: FrequencyUnits, value: Double) {
            self.units = units
            self.value = value
        }

        private enum CodingKeys: String, CodingKey {
            case units
            case value
        }
    }

    public struct FrequencyBandwidth: AWSEncodableShape & AWSDecodableShape {
        /// Frequency bandwidth units.
        public let units: BandwidthUnits
        /// Frequency bandwidth value. AWS Ground Station currently has the following bandwidth limitations:   For AntennaDownlinkDemodDecodeconfig, valid values are between 125 kHz to 650 MHz.   For AntennaDownlinkconfig, valid values are between 10 kHz to 54 MHz.   For AntennaUplinkConfig, valid values are between 10 kHz to 54 MHz.
        public let value: Double

        public init(units: BandwidthUnits, value: Double) {
            self.units = units
            self.value = value
        }

        private enum CodingKeys: String, CodingKey {
            case units
            case value
        }
    }

    public struct GetConfigRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "configId", location: .uri(locationName: "configId")),
            AWSMemberEncoding(label: "configType", location: .uri(locationName: "configType"))
        ]

        /// UUID of a Config.
        public let configId: String
        /// Type of a Config.
        public let configType: ConfigCapabilityType

        public init(configId: String, configType: ConfigCapabilityType) {
            self.configId = configId
            self.configType = configType
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetConfigResponse: AWSDecodableShape {
        /// ARN of a Config
        public let configArn: String
        /// Data elements in a Config.
        public let configData: ConfigTypeData
        /// UUID of a Config.
        public let configId: String
        /// Type of a Config.
        public let configType: ConfigCapabilityType?
        /// Name of a Config.
        public let name: String
        /// Tags assigned to a Config.
        public let tags: [String: String]?

        public init(configArn: String, configData: ConfigTypeData, configId: String, configType: ConfigCapabilityType? = nil, name: String, tags: [String: String]? = nil) {
            self.configArn = configArn
            self.configData = configData
            self.configId = configId
            self.configType = configType
            self.name = name
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case configArn
            case configData
            case configId
            case configType
            case name
            case tags
        }
    }

    public struct GetDataflowEndpointGroupRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "dataflowEndpointGroupId", location: .uri(locationName: "dataflowEndpointGroupId"))
        ]

        /// UUID of a dataflow endpoint group.
        public let dataflowEndpointGroupId: String

        public init(dataflowEndpointGroupId: String) {
            self.dataflowEndpointGroupId = dataflowEndpointGroupId
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetDataflowEndpointGroupResponse: AWSDecodableShape {
        /// ARN of a dataflow endpoint group.
        public let dataflowEndpointGroupArn: String?
        /// UUID of a dataflow endpoint group.
        public let dataflowEndpointGroupId: String?
        /// Details of a dataflow endpoint.
        public let endpointsDetails: [EndpointDetails]?
        /// Tags assigned to a dataflow endpoint group.
        public let tags: [String: String]?

        public init(dataflowEndpointGroupArn: String? = nil, dataflowEndpointGroupId: String? = nil, endpointsDetails: [EndpointDetails]? = nil, tags: [String: String]? = nil) {
            self.dataflowEndpointGroupArn = dataflowEndpointGroupArn
            self.dataflowEndpointGroupId = dataflowEndpointGroupId
            self.endpointsDetails = endpointsDetails
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case dataflowEndpointGroupArn
            case dataflowEndpointGroupId
            case endpointsDetails
            case tags
        }
    }

    public struct GetMinuteUsageRequest: AWSEncodableShape {
        /// The month being requested, with a value of 1-12.
        public let month: Int
        /// The year being requested, in the format of YYYY.
        public let year: Int

        public init(month: Int, year: Int) {
            self.month = month
            self.year = year
        }

        private enum CodingKeys: String, CodingKey {
            case month
            case year
        }
    }

    public struct GetMinuteUsageResponse: AWSDecodableShape {
        /// Estimated number of minutes remaining for an account, specific to the month being requested.
        public let estimatedMinutesRemaining: Int?
        /// Returns whether or not an account has signed up for the reserved minutes pricing plan, specific to the month being requested.
        public let isReservedMinutesCustomer: Bool?
        /// Total number of reserved minutes allocated, specific to the month being requested.
        public let totalReservedMinuteAllocation: Int?
        /// Total scheduled minutes for an account, specific to the month being requested.
        public let totalScheduledMinutes: Int?
        /// Upcoming minutes scheduled for an account, specific to the month being requested.
        public let upcomingMinutesScheduled: Int?

        public init(estimatedMinutesRemaining: Int? = nil, isReservedMinutesCustomer: Bool? = nil, totalReservedMinuteAllocation: Int? = nil, totalScheduledMinutes: Int? = nil, upcomingMinutesScheduled: Int? = nil) {
            self.estimatedMinutesRemaining = estimatedMinutesRemaining
            self.isReservedMinutesCustomer = isReservedMinutesCustomer
            self.totalReservedMinuteAllocation = totalReservedMinuteAllocation
            self.totalScheduledMinutes = totalScheduledMinutes
            self.upcomingMinutesScheduled = upcomingMinutesScheduled
        }

        private enum CodingKeys: String, CodingKey {
            case estimatedMinutesRemaining
            case isReservedMinutesCustomer
            case totalReservedMinuteAllocation
            case totalScheduledMinutes
            case upcomingMinutesScheduled
        }
    }

    public struct GetMissionProfileRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "missionProfileId", location: .uri(locationName: "missionProfileId"))
        ]

        /// UUID of a mission profile.
        public let missionProfileId: String

        public init(missionProfileId: String) {
            self.missionProfileId = missionProfileId
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetMissionProfileResponse: AWSDecodableShape {
        /// Amount of time after a contact ends that you’d like to receive a CloudWatch event indicating the pass has finished.
        public let contactPostPassDurationSeconds: Int?
        /// Amount of time prior to contact start you’d like to receive a CloudWatch event indicating an upcoming pass.
        public let contactPrePassDurationSeconds: Int?
        /// A list of lists of ARNs. Each list of ARNs is an edge, with a from  Config and a to  Config.
        public let dataflowEdges: [[String]]?
        /// Smallest amount of time in seconds that you’d like to see for an available contact. AWS Ground Station will not present you with contacts shorter than this duration.
        public let minimumViableContactDurationSeconds: Int?
        /// ARN of a mission profile.
        public let missionProfileArn: String?
        /// UUID of a mission profile.
        public let missionProfileId: String?
        /// Name of a mission profile.
        public let name: String?
        /// Region of a mission profile.
        public let region: String?
        /// Tags assigned to a mission profile.
        public let tags: [String: String]?
        /// ARN of a tracking Config.
        public let trackingConfigArn: String?

        public init(contactPostPassDurationSeconds: Int? = nil, contactPrePassDurationSeconds: Int? = nil, dataflowEdges: [[String]]? = nil, minimumViableContactDurationSeconds: Int? = nil, missionProfileArn: String? = nil, missionProfileId: String? = nil, name: String? = nil, region: String? = nil, tags: [String: String]? = nil, trackingConfigArn: String? = nil) {
            self.contactPostPassDurationSeconds = contactPostPassDurationSeconds
            self.contactPrePassDurationSeconds = contactPrePassDurationSeconds
            self.dataflowEdges = dataflowEdges
            self.minimumViableContactDurationSeconds = minimumViableContactDurationSeconds
            self.missionProfileArn = missionProfileArn
            self.missionProfileId = missionProfileId
            self.name = name
            self.region = region
            self.tags = tags
            self.trackingConfigArn = trackingConfigArn
        }

        private enum CodingKeys: String, CodingKey {
            case contactPostPassDurationSeconds
            case contactPrePassDurationSeconds
            case dataflowEdges
            case minimumViableContactDurationSeconds
            case missionProfileArn
            case missionProfileId
            case name
            case region
            case tags
            case trackingConfigArn
        }
    }

    public struct GetSatelliteRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "satelliteId", location: .uri(locationName: "satelliteId"))
        ]

        /// UUID of a satellite.
        public let satelliteId: String

        public init(satelliteId: String) {
            self.satelliteId = satelliteId
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetSatelliteResponse: AWSDecodableShape {
        /// A list of ground stations to which the satellite is on-boarded.
        public let groundStations: [String]?
        /// NORAD satellite ID number.
        public let noradSatelliteID: Int?
        /// ARN of a satellite.
        public let satelliteArn: String?
        /// UUID of a satellite.
        public let satelliteId: String?

        public init(groundStations: [String]? = nil, noradSatelliteID: Int? = nil, satelliteArn: String? = nil, satelliteId: String? = nil) {
            self.groundStations = groundStations
            self.noradSatelliteID = noradSatelliteID
            self.satelliteArn = satelliteArn
            self.satelliteId = satelliteId
        }

        private enum CodingKeys: String, CodingKey {
            case groundStations
            case noradSatelliteID
            case satelliteArn
            case satelliteId
        }
    }

    public struct GroundStationData: AWSDecodableShape {
        /// UUID of a ground station.
        public let groundStationId: String?
        /// Name of a ground station.
        public let groundStationName: String?
        /// Ground station Region.
        public let region: String?

        public init(groundStationId: String? = nil, groundStationName: String? = nil, region: String? = nil) {
            self.groundStationId = groundStationId
            self.groundStationName = groundStationName
            self.region = region
        }

        private enum CodingKeys: String, CodingKey {
            case groundStationId
            case groundStationName
            case region
        }
    }

    public struct ListConfigsRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "maxResults", location: .querystring(locationName: "maxResults")),
            AWSMemberEncoding(label: "nextToken", location: .querystring(locationName: "nextToken"))
        ]

        /// Maximum number of Configs returned.
        public let maxResults: Int?
        /// Next token returned in the request of a previous ListConfigs call. Used to get the next page of results.
        public let nextToken: String?

        public init(maxResults: Int? = nil, nextToken: String? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListConfigsResponse: AWSDecodableShape {
        /// List of Config items.
        public let configList: [ConfigListItem]?
        /// Next token returned in the response of a previous ListConfigs call. Used to get the next page of results.
        public let nextToken: String?

        public init(configList: [ConfigListItem]? = nil, nextToken: String? = nil) {
            self.configList = configList
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case configList
            case nextToken
        }
    }

    public struct ListContactsRequest: AWSEncodableShape {
        /// End time of a contact.
        public let endTime: Date
        /// Name of a ground station.
        public let groundStation: String?
        /// Maximum number of contacts returned.
        public let maxResults: Int?
        /// ARN of a mission profile.
        public let missionProfileArn: String?
        /// Next token returned in the request of a previous ListContacts call. Used to get the next page of results.
        public let nextToken: String?
        /// ARN of a satellite.
        public let satelliteArn: String?
        /// Start time of a contact.
        public let startTime: Date
        /// Status of a contact reservation.
        public let statusList: [ContactStatus]

        public init(endTime: Date, groundStation: String? = nil, maxResults: Int? = nil, missionProfileArn: String? = nil, nextToken: String? = nil, satelliteArn: String? = nil, startTime: Date, statusList: [ContactStatus]) {
            self.endTime = endTime
            self.groundStation = groundStation
            self.maxResults = maxResults
            self.missionProfileArn = missionProfileArn
            self.nextToken = nextToken
            self.satelliteArn = satelliteArn
            self.startTime = startTime
            self.statusList = statusList
        }

        private enum CodingKeys: String, CodingKey {
            case endTime
            case groundStation
            case maxResults
            case missionProfileArn
            case nextToken
            case satelliteArn
            case startTime
            case statusList
        }
    }

    public struct ListContactsResponse: AWSDecodableShape {
        /// List of contacts.
        public let contactList: [ContactData]?
        /// Next token returned in the response of a previous ListContacts call. Used to get the next page of results.
        public let nextToken: String?

        public init(contactList: [ContactData]? = nil, nextToken: String? = nil) {
            self.contactList = contactList
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case contactList
            case nextToken
        }
    }

    public struct ListDataflowEndpointGroupsRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "maxResults", location: .querystring(locationName: "maxResults")),
            AWSMemberEncoding(label: "nextToken", location: .querystring(locationName: "nextToken"))
        ]

        /// Maximum number of dataflow endpoint groups returned.
        public let maxResults: Int?
        /// Next token returned in the request of a previous ListDataflowEndpointGroups call. Used to get the next page of results.
        public let nextToken: String?

        public init(maxResults: Int? = nil, nextToken: String? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListDataflowEndpointGroupsResponse: AWSDecodableShape {
        /// A list of dataflow endpoint groups.
        public let dataflowEndpointGroupList: [DataflowEndpointListItem]?
        /// Next token returned in the response of a previous ListDataflowEndpointGroups call. Used to get the next page of results.
        public let nextToken: String?

        public init(dataflowEndpointGroupList: [DataflowEndpointListItem]? = nil, nextToken: String? = nil) {
            self.dataflowEndpointGroupList = dataflowEndpointGroupList
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case dataflowEndpointGroupList
            case nextToken
        }
    }

    public struct ListGroundStationsRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "maxResults", location: .querystring(locationName: "maxResults")),
            AWSMemberEncoding(label: "nextToken", location: .querystring(locationName: "nextToken")),
            AWSMemberEncoding(label: "satelliteId", location: .querystring(locationName: "satelliteId"))
        ]

        /// Maximum number of ground stations returned.
        public let maxResults: Int?
        /// Next token that can be supplied in the next call to get the next page of ground stations.
        public let nextToken: String?
        /// Satellite ID to retrieve on-boarded ground stations.
        public let satelliteId: String?

        public init(maxResults: Int? = nil, nextToken: String? = nil, satelliteId: String? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.satelliteId = satelliteId
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListGroundStationsResponse: AWSDecodableShape {
        /// List of ground stations.
        public let groundStationList: [GroundStationData]?
        /// Next token that can be supplied in the next call to get the next page of ground stations.
        public let nextToken: String?

        public init(groundStationList: [GroundStationData]? = nil, nextToken: String? = nil) {
            self.groundStationList = groundStationList
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case groundStationList
            case nextToken
        }
    }

    public struct ListMissionProfilesRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "maxResults", location: .querystring(locationName: "maxResults")),
            AWSMemberEncoding(label: "nextToken", location: .querystring(locationName: "nextToken"))
        ]

        /// Maximum number of mission profiles returned.
        public let maxResults: Int?
        /// Next token returned in the request of a previous ListMissionProfiles call. Used to get the next page of results.
        public let nextToken: String?

        public init(maxResults: Int? = nil, nextToken: String? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListMissionProfilesResponse: AWSDecodableShape {
        /// List of mission profiles.
        public let missionProfileList: [MissionProfileListItem]?
        /// Next token returned in the response of a previous ListMissionProfiles call. Used to get the next page of results.
        public let nextToken: String?

        public init(missionProfileList: [MissionProfileListItem]? = nil, nextToken: String? = nil) {
            self.missionProfileList = missionProfileList
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case missionProfileList
            case nextToken
        }
    }

    public struct ListSatellitesRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "maxResults", location: .querystring(locationName: "maxResults")),
            AWSMemberEncoding(label: "nextToken", location: .querystring(locationName: "nextToken"))
        ]

        /// Maximum number of satellites returned.
        public let maxResults: Int?
        /// Next token that can be supplied in the next call to get the next page of satellites.
        public let nextToken: String?

        public init(maxResults: Int? = nil, nextToken: String? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListSatellitesResponse: AWSDecodableShape {
        /// Next token that can be supplied in the next call to get the next page of satellites.
        public let nextToken: String?
        /// List of satellites.
        public let satellites: [SatelliteListItem]?

        public init(nextToken: String? = nil, satellites: [SatelliteListItem]? = nil) {
            self.nextToken = nextToken
            self.satellites = satellites
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken
            case satellites
        }
    }

    public struct ListTagsForResourceRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "resourceArn", location: .uri(locationName: "resourceArn"))
        ]

        /// ARN of a resource.
        public let resourceArn: String

        public init(resourceArn: String) {
            self.resourceArn = resourceArn
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListTagsForResourceResponse: AWSDecodableShape {
        /// Tags assigned to a resource.
        public let tags: [String: String]?

        public init(tags: [String: String]? = nil) {
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case tags
        }
    }

    public struct MissionProfileIdResponse: AWSDecodableShape {
        /// UUID of a mission profile.
        public let missionProfileId: String?

        public init(missionProfileId: String? = nil) {
            self.missionProfileId = missionProfileId
        }

        private enum CodingKeys: String, CodingKey {
            case missionProfileId
        }
    }

    public struct MissionProfileListItem: AWSDecodableShape {
        /// ARN of a mission profile.
        public let missionProfileArn: String?
        /// UUID of a mission profile.
        public let missionProfileId: String?
        /// Name of a mission profile.
        public let name: String?
        /// Region of a mission profile.
        public let region: String?

        public init(missionProfileArn: String? = nil, missionProfileId: String? = nil, name: String? = nil, region: String? = nil) {
            self.missionProfileArn = missionProfileArn
            self.missionProfileId = missionProfileId
            self.name = name
            self.region = region
        }

        private enum CodingKeys: String, CodingKey {
            case missionProfileArn
            case missionProfileId
            case name
            case region
        }
    }

    public struct ReserveContactRequest: AWSEncodableShape {
        /// End time of a contact.
        public let endTime: Date
        /// Name of a ground station.
        public let groundStation: String
        /// ARN of a mission profile.
        public let missionProfileArn: String
        /// ARN of a satellite
        public let satelliteArn: String
        /// Start time of a contact.
        public let startTime: Date
        /// Tags assigned to a contact.
        public let tags: [String: String]?

        public init(endTime: Date, groundStation: String, missionProfileArn: String, satelliteArn: String, startTime: Date, tags: [String: String]? = nil) {
            self.endTime = endTime
            self.groundStation = groundStation
            self.missionProfileArn = missionProfileArn
            self.satelliteArn = satelliteArn
            self.startTime = startTime
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case endTime
            case groundStation
            case missionProfileArn
            case satelliteArn
            case startTime
            case tags
        }
    }

    public struct S3RecordingConfig: AWSEncodableShape & AWSDecodableShape {
        /// ARN of the bucket to record to.
        public let bucketArn: String
        /// S3 Key prefix to prefice data files.
        public let prefix: String?
        /// ARN of the role Ground Station assumes to write data to the bucket.
        public let roleArn: String

        public init(bucketArn: String, prefix: String? = nil, roleArn: String) {
            self.bucketArn = bucketArn
            self.prefix = prefix
            self.roleArn = roleArn
        }

        public func validate(name: String) throws {
            try self.validate(self.prefix, name: "prefix", parent: name, max: 900)
            try self.validate(self.prefix, name: "prefix", parent: name, min: 1)
            try self.validate(self.prefix, name: "prefix", parent: name, pattern: "^([a-zA-Z0-9_\\-=/]|\\{satellite_id\\}|\\{config\\-name}|\\{s3\\-config-id}|\\{year\\}|\\{month\\}|\\{day\\}){1,900}$")
        }

        private enum CodingKeys: String, CodingKey {
            case bucketArn
            case prefix
            case roleArn
        }
    }

    public struct S3RecordingDetails: AWSDecodableShape {
        /// ARN of the bucket used.
        public let bucketArn: String?
        /// Template of the S3 key used.
        public let keyTemplate: String?

        public init(bucketArn: String? = nil, keyTemplate: String? = nil) {
            self.bucketArn = bucketArn
            self.keyTemplate = keyTemplate
        }

        private enum CodingKeys: String, CodingKey {
            case bucketArn
            case keyTemplate
        }
    }

    public struct SatelliteListItem: AWSDecodableShape {
        /// A list of ground stations to which the satellite is on-boarded.
        public let groundStations: [String]?
        /// NORAD satellite ID number.
        public let noradSatelliteID: Int?
        /// ARN of a satellite.
        public let satelliteArn: String?
        /// UUID of a satellite.
        public let satelliteId: String?

        public init(groundStations: [String]? = nil, noradSatelliteID: Int? = nil, satelliteArn: String? = nil, satelliteId: String? = nil) {
            self.groundStations = groundStations
            self.noradSatelliteID = noradSatelliteID
            self.satelliteArn = satelliteArn
            self.satelliteId = satelliteId
        }

        private enum CodingKeys: String, CodingKey {
            case groundStations
            case noradSatelliteID
            case satelliteArn
            case satelliteId
        }
    }

    public struct SecurityDetails: AWSEncodableShape & AWSDecodableShape {
        /// ARN to a role needed for connecting streams to your instances.
        public let roleArn: String
        /// The security groups to attach to the elastic network interfaces.
        public let securityGroupIds: [String]
        /// A list of subnets where AWS Ground Station places elastic network interfaces to send streams to your instances.
        public let subnetIds: [String]

        public init(roleArn: String, securityGroupIds: [String], subnetIds: [String]) {
            self.roleArn = roleArn
            self.securityGroupIds = securityGroupIds
            self.subnetIds = subnetIds
        }

        private enum CodingKeys: String, CodingKey {
            case roleArn
            case securityGroupIds
            case subnetIds
        }
    }

    public struct SocketAddress: AWSEncodableShape & AWSDecodableShape {
        /// Name of a socket address.
        public let name: String
        /// Port of a socket address.
        public let port: Int

        public init(name: String, port: Int) {
            self.name = name
            self.port = port
        }

        private enum CodingKeys: String, CodingKey {
            case name
            case port
        }
    }

    public struct Source: AWSDecodableShape {
        /// Additional details for a Config, if type is dataflow endpoint or antenna demod decode.
        public let configDetails: ConfigDetails?
        /// UUID of a Config.
        public let configId: String?
        /// Type of a Config.
        public let configType: ConfigCapabilityType?
        /// Region of a dataflow source.
        public let dataflowSourceRegion: String?

        public init(configDetails: ConfigDetails? = nil, configId: String? = nil, configType: ConfigCapabilityType? = nil, dataflowSourceRegion: String? = nil) {
            self.configDetails = configDetails
            self.configId = configId
            self.configType = configType
            self.dataflowSourceRegion = dataflowSourceRegion
        }

        private enum CodingKeys: String, CodingKey {
            case configDetails
            case configId
            case configType
            case dataflowSourceRegion
        }
    }

    public struct SpectrumConfig: AWSEncodableShape & AWSDecodableShape {
        /// Bandwidth of a spectral Config. AWS Ground Station currently has the following bandwidth limitations:   For AntennaDownlinkDemodDecodeconfig, valid values are between 125 kHz to 650 MHz.   For AntennaDownlinkconfig valid values are between 10 kHz to 54 MHz.   For AntennaUplinkConfig, valid values are between 10 kHz to 54 MHz.
        public let bandwidth: FrequencyBandwidth
        /// Center frequency of a spectral Config. Valid values are between 2200 to 2300 MHz and 7750 to 8400 MHz for downlink and 2025 to 2120 MHz for uplink.
        public let centerFrequency: Frequency
        /// Polarization of a spectral Config. Capturing both "RIGHT_HAND" and "LEFT_HAND" polarization requires two separate configs.
        public let polarization: Polarization?

        public init(bandwidth: FrequencyBandwidth, centerFrequency: Frequency, polarization: Polarization? = nil) {
            self.bandwidth = bandwidth
            self.centerFrequency = centerFrequency
            self.polarization = polarization
        }

        private enum CodingKeys: String, CodingKey {
            case bandwidth
            case centerFrequency
            case polarization
        }
    }

    public struct TagResourceRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "resourceArn", location: .uri(locationName: "resourceArn"))
        ]

        /// ARN of a resource tag.
        public let resourceArn: String
        /// Tags assigned to a resource.
        public let tags: [String: String]

        public init(resourceArn: String, tags: [String: String]) {
            self.resourceArn = resourceArn
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case tags
        }
    }

    public struct TagResourceResponse: AWSDecodableShape {
        public init() {}
    }

    public struct TrackingConfig: AWSEncodableShape & AWSDecodableShape {
        /// Current setting for autotrack.
        public let autotrack: Criticality

        public init(autotrack: Criticality) {
            self.autotrack = autotrack
        }

        private enum CodingKeys: String, CodingKey {
            case autotrack
        }
    }

    public struct UntagResourceRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "resourceArn", location: .uri(locationName: "resourceArn")),
            AWSMemberEncoding(label: "tagKeys", location: .querystring(locationName: "tagKeys"))
        ]

        /// ARN of a resource.
        public let resourceArn: String
        /// Keys of a resource tag.
        public let tagKeys: [String]

        public init(resourceArn: String, tagKeys: [String]) {
            self.resourceArn = resourceArn
            self.tagKeys = tagKeys
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct UntagResourceResponse: AWSDecodableShape {
        public init() {}
    }

    public struct UpdateConfigRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "configId", location: .uri(locationName: "configId")),
            AWSMemberEncoding(label: "configType", location: .uri(locationName: "configType"))
        ]

        /// Parameters of a Config.
        public let configData: ConfigTypeData
        /// UUID of a Config.
        public let configId: String
        /// Type of a Config.
        public let configType: ConfigCapabilityType
        /// Name of a Config.
        public let name: String

        public init(configData: ConfigTypeData, configId: String, configType: ConfigCapabilityType, name: String) {
            self.configData = configData
            self.configId = configId
            self.configType = configType
            self.name = name
        }

        public func validate(name: String) throws {
            try self.configData.validate(name: "\(name).configData")
            try self.validate(self.name, name: "name", parent: name, max: 256)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[ a-zA-Z0-9_:-]{1,256}$")
        }

        private enum CodingKeys: String, CodingKey {
            case configData
            case name
        }
    }

    public struct UpdateMissionProfileRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "missionProfileId", location: .uri(locationName: "missionProfileId"))
        ]

        /// Amount of time after a contact ends that you’d like to receive a CloudWatch event indicating the pass has finished.
        public let contactPostPassDurationSeconds: Int?
        /// Amount of time after a contact ends that you’d like to receive a CloudWatch event indicating the pass has finished.
        public let contactPrePassDurationSeconds: Int?
        /// A list of lists of ARNs. Each list of ARNs is an edge, with a from  Config and a to  Config.
        public let dataflowEdges: [[String]]?
        /// Smallest amount of time in seconds that you’d like to see for an available contact. AWS Ground Station will not present you with contacts shorter than this duration.
        public let minimumViableContactDurationSeconds: Int?
        /// UUID of a mission profile.
        public let missionProfileId: String
        /// Name of a mission profile.
        public let name: String?
        /// ARN of a tracking Config.
        public let trackingConfigArn: String?

        public init(contactPostPassDurationSeconds: Int? = nil, contactPrePassDurationSeconds: Int? = nil, dataflowEdges: [[String]]? = nil, minimumViableContactDurationSeconds: Int? = nil, missionProfileId: String, name: String? = nil, trackingConfigArn: String? = nil) {
            self.contactPostPassDurationSeconds = contactPostPassDurationSeconds
            self.contactPrePassDurationSeconds = contactPrePassDurationSeconds
            self.dataflowEdges = dataflowEdges
            self.minimumViableContactDurationSeconds = minimumViableContactDurationSeconds
            self.missionProfileId = missionProfileId
            self.name = name
            self.trackingConfigArn = trackingConfigArn
        }

        public func validate(name: String) throws {
            try self.validate(self.contactPostPassDurationSeconds, name: "contactPostPassDurationSeconds", parent: name, max: 21600)
            try self.validate(self.contactPostPassDurationSeconds, name: "contactPostPassDurationSeconds", parent: name, min: 1)
            try self.validate(self.contactPrePassDurationSeconds, name: "contactPrePassDurationSeconds", parent: name, max: 21600)
            try self.validate(self.contactPrePassDurationSeconds, name: "contactPrePassDurationSeconds", parent: name, min: 1)
            try self.dataflowEdges?.forEach {
                try validate($0, name: "dataflowEdges[]", parent: name, max: 2)
                try validate($0, name: "dataflowEdges[]", parent: name, min: 2)
            }
            try self.validate(self.minimumViableContactDurationSeconds, name: "minimumViableContactDurationSeconds", parent: name, max: 21600)
            try self.validate(self.minimumViableContactDurationSeconds, name: "minimumViableContactDurationSeconds", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, max: 256)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[ a-zA-Z0-9_:-]{1,256}$")
        }

        private enum CodingKeys: String, CodingKey {
            case contactPostPassDurationSeconds
            case contactPrePassDurationSeconds
            case dataflowEdges
            case minimumViableContactDurationSeconds
            case name
            case trackingConfigArn
        }
    }

    public struct UplinkEchoConfig: AWSEncodableShape & AWSDecodableShape {
        /// ARN of an uplink Config.
        public let antennaUplinkConfigArn: String
        /// Whether or not an uplink Config is enabled.
        public let enabled: Bool

        public init(antennaUplinkConfigArn: String, enabled: Bool) {
            self.antennaUplinkConfigArn = antennaUplinkConfigArn
            self.enabled = enabled
        }

        private enum CodingKeys: String, CodingKey {
            case antennaUplinkConfigArn
            case enabled
        }
    }

    public struct UplinkSpectrumConfig: AWSEncodableShape & AWSDecodableShape {
        /// Center frequency of an uplink spectral Config. Valid values are between 2025 to 2120 MHz.
        public let centerFrequency: Frequency
        /// Polarization of an uplink spectral Config. Capturing both "RIGHT_HAND" and "LEFT_HAND" polarization requires two separate configs.
        public let polarization: Polarization?

        public init(centerFrequency: Frequency, polarization: Polarization? = nil) {
            self.centerFrequency = centerFrequency
            self.polarization = polarization
        }

        private enum CodingKeys: String, CodingKey {
            case centerFrequency
            case polarization
        }
    }
}
