//===----------------------------------------------------------------------===//
//
// This source file is part of the Soto for AWS open source project
//
// Copyright (c) 2017-2024 the Soto project authors
// Licensed under Apache License v2.0
//
// See LICENSE.txt for license information
// See CONTRIBUTORS.txt for the list of Soto project authors
//
// SPDX-License-Identifier: Apache-2.0
//
//===----------------------------------------------------------------------===//

// THIS FILE IS AUTOMATICALLY GENERATED by https://github.com/soto-project/soto-codegenerator.
// DO NOT EDIT.

#if canImport(FoundationEssentials)
import FoundationEssentials
#else
import Foundation
#endif
@_spi(SotoInternal) import SotoCore

extension BedrockAgentCore {
    // MARK: Enums

    public enum AutomationStreamStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case disabled = "DISABLED"
        case enabled = "ENABLED"
        public var description: String { return self.rawValue }
    }

    public enum BrowserSessionStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case ready = "READY"
        case terminated = "TERMINATED"
        public var description: String { return self.rawValue }
    }

    public enum CodeInterpreterSessionStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case ready = "READY"
        case terminated = "TERMINATED"
        public var description: String { return self.rawValue }
    }

    public enum ContentBlockType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case embeddedResource = "resource"
        case image = "image"
        case resourceLink = "resource_link"
        case text = "text"
        public var description: String { return self.rawValue }
    }

    public enum ExtractionJobStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case failed = "FAILED"
        public var description: String { return self.rawValue }
    }

    public enum MemoryRecordStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case failed = "FAILED"
        case succeeded = "SUCCEEDED"
        public var description: String { return self.rawValue }
    }

    public enum Oauth2FlowType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case m2m = "M2M"
        case userFederation = "USER_FEDERATION"
        public var description: String { return self.rawValue }
    }

    public enum OperatorType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case equalsTo = "EQUALS_TO"
        case exists = "EXISTS"
        case notExists = "NOT_EXISTS"
        public var description: String { return self.rawValue }
    }

    public enum ProgrammingLanguage: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case javascript = "javascript"
        case python = "python"
        case typescript = "typescript"
        public var description: String { return self.rawValue }
    }

    public enum ResourceContentType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case blob = "blob"
        case text = "text"
        public var description: String { return self.rawValue }
    }

    public enum Role: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case assistant = "ASSISTANT"
        case other = "OTHER"
        case tool = "TOOL"
        case user = "USER"
        public var description: String { return self.rawValue }
    }

    public enum SessionStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case failed = "FAILED"
        case inProgress = "IN_PROGRESS"
        public var description: String { return self.rawValue }
    }

    public enum TaskStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case canceled = "canceled"
        case completed = "completed"
        case failed = "failed"
        case submitted = "submitted"
        case working = "working"
        public var description: String { return self.rawValue }
    }

    public enum ToolName: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case executeCode = "executeCode"
        case executeCommand = "executeCommand"
        case getTask = "getTask"
        case listFiles = "listFiles"
        case readFiles = "readFiles"
        case removeFiles = "removeFiles"
        case startCommandExecution = "startCommandExecution"
        case stopTask = "stopTask"
        case writeFiles = "writeFiles"
        public var description: String { return self.rawValue }
    }

    public enum ValidationExceptionReason: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case cannotParse = "CannotParse"
        case fieldValidationFailed = "FieldValidationFailed"
        case idempotentParameterMismatchException = "IdempotentParameterMismatchException"
        case resourceConflict = "ResourceConflict"
        case rootEventInOtherSession = "EventInOtherSession"
        public var description: String { return self.rawValue }
    }

    public enum CodeInterpreterStreamOutput: AWSDecodableShape, Sendable {
        case accessDeniedException(AccessDeniedException)
        case conflictException(ConflictException)
        case internalServerException(InternalServerException)
        case resourceNotFoundException(ResourceNotFoundException)
        case result(CodeInterpreterResult)
        case serviceQuotaExceededException(ServiceQuotaExceededException)
        case throttlingException(ThrottlingException)
        case validationException(ValidationException)

        public init(from decoder: Decoder) throws {
            let container = try decoder.container(keyedBy: CodingKeys.self)
            guard container.allKeys.count == 1, let key = container.allKeys.first else {
                let context = DecodingError.Context(
                    codingPath: container.codingPath,
                    debugDescription: "Expected exactly one key, but got \(container.allKeys.count)"
                )
                throw DecodingError.dataCorrupted(context)
            }
            switch key {
            case .accessDeniedException:
                let value = try container.decode(AccessDeniedException.self, forKey: .accessDeniedException)
                self = .accessDeniedException(value)
            case .conflictException:
                let value = try container.decode(ConflictException.self, forKey: .conflictException)
                self = .conflictException(value)
            case .internalServerException:
                let value = try container.decode(InternalServerException.self, forKey: .internalServerException)
                self = .internalServerException(value)
            case .resourceNotFoundException:
                let value = try container.decode(ResourceNotFoundException.self, forKey: .resourceNotFoundException)
                self = .resourceNotFoundException(value)
            case .result:
                let value = try container.decode(CodeInterpreterResult.self, forKey: .result)
                self = .result(value)
            case .serviceQuotaExceededException:
                let value = try container.decode(ServiceQuotaExceededException.self, forKey: .serviceQuotaExceededException)
                self = .serviceQuotaExceededException(value)
            case .throttlingException:
                let value = try container.decode(ThrottlingException.self, forKey: .throttlingException)
                self = .throttlingException(value)
            case .validationException:
                let value = try container.decode(ValidationException.self, forKey: .validationException)
                self = .validationException(value)
            }
        }

        private enum CodingKeys: String, CodingKey {
            case accessDeniedException = "accessDeniedException"
            case conflictException = "conflictException"
            case internalServerException = "internalServerException"
            case resourceNotFoundException = "resourceNotFoundException"
            case result = "result"
            case serviceQuotaExceededException = "serviceQuotaExceededException"
            case throttlingException = "throttlingException"
            case validationException = "validationException"
        }
    }

    public enum EvaluationTarget: AWSEncodableShape, Sendable {
        ///  The list of specific span IDs to evaluate within the provided traces. Used to target evaluation at individual tool calls or specific operations within the agent's execution flow.
        case spanIds([String])
        ///  The list of trace IDs to evaluate, representing complete request-response interactions. Used to evaluate entire conversation turns or specific agent interactions within a session.
        case traceIds([String])

        public func encode(to encoder: Encoder) throws {
            var container = encoder.container(keyedBy: CodingKeys.self)
            switch self {
            case .spanIds(let value):
                try container.encode(value, forKey: .spanIds)
            case .traceIds(let value):
                try container.encode(value, forKey: .traceIds)
            }
        }

        public func validate(name: String) throws {
            switch self {
            case .spanIds(let value):
                try value.forEach {
                    try validate($0, name: "spanIds[]", parent: name, max: 16)
                    try validate($0, name: "spanIds[]", parent: name, min: 16)
                }
                try self.validate(value, name: "spanIds", parent: name, max: 10)
                try self.validate(value, name: "spanIds", parent: name, min: 1)
            case .traceIds(let value):
                try value.forEach {
                    try validate($0, name: "traceIds[]", parent: name, max: 32)
                    try validate($0, name: "traceIds[]", parent: name, min: 32)
                }
                try self.validate(value, name: "traceIds", parent: name, max: 10)
                try self.validate(value, name: "traceIds", parent: name, min: 1)
            }
        }

        private enum CodingKeys: String, CodingKey {
            case spanIds = "spanIds"
            case traceIds = "traceIds"
        }
    }

    public enum PayloadType: AWSEncodableShape & AWSDecodableShape, Sendable {
        /// The binary content of the payload.
        case blob(AWSDocument)
        /// The conversational content of the payload.
        case conversational(Conversational)

        public init(from decoder: Decoder) throws {
            let container = try decoder.container(keyedBy: CodingKeys.self)
            guard container.allKeys.count == 1, let key = container.allKeys.first else {
                let context = DecodingError.Context(
                    codingPath: container.codingPath,
                    debugDescription: "Expected exactly one key, but got \(container.allKeys.count)"
                )
                throw DecodingError.dataCorrupted(context)
            }
            switch key {
            case .blob:
                let value = try container.decode(AWSDocument.self, forKey: .blob)
                self = .blob(value)
            case .conversational:
                let value = try container.decode(Conversational.self, forKey: .conversational)
                self = .conversational(value)
            }
        }

        public func encode(to encoder: Encoder) throws {
            var container = encoder.container(keyedBy: CodingKeys.self)
            switch self {
            case .blob(let value):
                try container.encode(value, forKey: .blob)
            case .conversational(let value):
                try container.encode(value, forKey: .conversational)
            }
        }

        private enum CodingKeys: String, CodingKey {
            case blob = "blob"
            case conversational = "conversational"
        }
    }

    public enum UserIdentifier: AWSEncodableShape, Sendable {
        /// The ID of the user for whom you have retrieved a workload access token for
        case userId(String)
        /// The OAuth2.0 token issued by the userâ€™s identity provider
        case userToken(String)

        public func encode(to encoder: Encoder) throws {
            var container = encoder.container(keyedBy: CodingKeys.self)
            switch self {
            case .userId(let value):
                try container.encode(value, forKey: .userId)
            case .userToken(let value):
                try container.encode(value, forKey: .userToken)
            }
        }

        public func validate(name: String) throws {
            switch self {
            case .userId(let value):
                try self.validate(value, name: "userId", parent: name, max: 128)
                try self.validate(value, name: "userId", parent: name, min: 1)
            case .userToken(let value):
                try self.validate(value, name: "userToken", parent: name, max: 131072)
                try self.validate(value, name: "userToken", parent: name, min: 1)
                try self.validate(value, name: "userToken", parent: name, pattern: "^[A-Za-z0-9-_=]+.[A-Za-z0-9-_=]+.[A-Za-z0-9-_=]+$")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case userId = "userId"
            case userToken = "userToken"
        }
    }

    // MARK: Shapes

    public struct AccessDeniedException: AWSDecodableShape {
        public let message: String?

        @inlinable
        public init(message: String? = nil) {
            self.message = message
        }

        private enum CodingKeys: String, CodingKey {
            case message = "message"
        }
    }

    public struct ActorSummary: AWSDecodableShape {
        /// The unique identifier of the actor.
        public let actorId: String

        @inlinable
        public init(actorId: String) {
            self.actorId = actorId
        }

        private enum CodingKeys: String, CodingKey {
            case actorId = "actorId"
        }
    }

    public struct AutomationStream: AWSDecodableShape {
        /// The endpoint URL for the automation stream. This URL is used to establish a WebSocket connection to the stream for sending commands and receiving responses.
        public let streamEndpoint: String
        /// The current status of the automation stream. This indicates whether the stream is available for use. Possible values include ACTIVE, CONNECTING, and DISCONNECTED.
        public let streamStatus: AutomationStreamStatus

        @inlinable
        public init(streamEndpoint: String, streamStatus: AutomationStreamStatus) {
            self.streamEndpoint = streamEndpoint
            self.streamStatus = streamStatus
        }

        private enum CodingKeys: String, CodingKey {
            case streamEndpoint = "streamEndpoint"
            case streamStatus = "streamStatus"
        }
    }

    public struct AutomationStreamUpdate: AWSEncodableShape {
        /// The status of the automation stream.
        public let streamStatus: AutomationStreamStatus?

        @inlinable
        public init(streamStatus: AutomationStreamStatus? = nil) {
            self.streamStatus = streamStatus
        }

        private enum CodingKeys: String, CodingKey {
            case streamStatus = "streamStatus"
        }
    }

    public struct BatchCreateMemoryRecordsInput: AWSEncodableShape {
        /// A unique, case-sensitive identifier to ensure idempotent processing of the batch request.
        public let clientToken: String?
        /// The unique ID of the memory resource where records will be created.
        public let memoryId: String
        /// A list of memory record creation inputs to be processed in the batch operation.
        public let records: [MemoryRecordCreateInput]

        @inlinable
        public init(clientToken: String? = BatchCreateMemoryRecordsInput.idempotencyToken(), memoryId: String, records: [MemoryRecordCreateInput]) {
            self.clientToken = clientToken
            self.memoryId = memoryId
            self.records = records
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.clientToken, forKey: .clientToken)
            request.encodePath(self.memoryId, key: "memoryId")
            try container.encode(self.records, forKey: .records)
        }

        public func validate(name: String) throws {
            try self.validate(self.memoryId, name: "memoryId", parent: name, min: 12)
            try self.validate(self.memoryId, name: "memoryId", parent: name, pattern: "^[a-zA-Z][a-zA-Z0-9-_]{0,99}-[a-zA-Z0-9]{10}$")
            try self.records.forEach {
                try $0.validate(name: "\(name).records[]")
            }
            try self.validate(self.records, name: "records", parent: name, max: 100)
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "clientToken"
            case records = "records"
        }
    }

    public struct BatchCreateMemoryRecordsOutput: AWSDecodableShape {
        /// A list of memory records that failed to be created, including error details for each failure.
        public let failedRecords: [MemoryRecordOutput]
        /// A list of memory records that were successfully created during the batch operation.
        public let successfulRecords: [MemoryRecordOutput]

        @inlinable
        public init(failedRecords: [MemoryRecordOutput], successfulRecords: [MemoryRecordOutput]) {
            self.failedRecords = failedRecords
            self.successfulRecords = successfulRecords
        }

        private enum CodingKeys: String, CodingKey {
            case failedRecords = "failedRecords"
            case successfulRecords = "successfulRecords"
        }
    }

    public struct BatchDeleteMemoryRecordsInput: AWSEncodableShape {
        /// The unique ID of the memory resource where records will be deleted.
        public let memoryId: String
        /// A list of memory record deletion inputs to be processed in the batch operation.
        public let records: [MemoryRecordDeleteInput]

        @inlinable
        public init(memoryId: String, records: [MemoryRecordDeleteInput]) {
            self.memoryId = memoryId
            self.records = records
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.memoryId, key: "memoryId")
            try container.encode(self.records, forKey: .records)
        }

        public func validate(name: String) throws {
            try self.validate(self.memoryId, name: "memoryId", parent: name, min: 12)
            try self.validate(self.memoryId, name: "memoryId", parent: name, pattern: "^[a-zA-Z][a-zA-Z0-9-_]{0,99}-[a-zA-Z0-9]{10}$")
            try self.records.forEach {
                try $0.validate(name: "\(name).records[]")
            }
            try self.validate(self.records, name: "records", parent: name, max: 100)
        }

        private enum CodingKeys: String, CodingKey {
            case records = "records"
        }
    }

    public struct BatchDeleteMemoryRecordsOutput: AWSDecodableShape {
        /// A list of memory records that failed to be deleted, including error details for each failure.
        public let failedRecords: [MemoryRecordOutput]
        /// A list of memory records that were successfully deleted during the batch operation.
        public let successfulRecords: [MemoryRecordOutput]

        @inlinable
        public init(failedRecords: [MemoryRecordOutput], successfulRecords: [MemoryRecordOutput]) {
            self.failedRecords = failedRecords
            self.successfulRecords = successfulRecords
        }

        private enum CodingKeys: String, CodingKey {
            case failedRecords = "failedRecords"
            case successfulRecords = "successfulRecords"
        }
    }

    public struct BatchUpdateMemoryRecordsInput: AWSEncodableShape {
        /// The unique ID of the memory resource where records will be updated.
        public let memoryId: String
        /// A list of memory record update inputs to be processed in the batch operation.
        public let records: [MemoryRecordUpdateInput]

        @inlinable
        public init(memoryId: String, records: [MemoryRecordUpdateInput]) {
            self.memoryId = memoryId
            self.records = records
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.memoryId, key: "memoryId")
            try container.encode(self.records, forKey: .records)
        }

        public func validate(name: String) throws {
            try self.validate(self.memoryId, name: "memoryId", parent: name, min: 12)
            try self.validate(self.memoryId, name: "memoryId", parent: name, pattern: "^[a-zA-Z][a-zA-Z0-9-_]{0,99}-[a-zA-Z0-9]{10}$")
            try self.records.forEach {
                try $0.validate(name: "\(name).records[]")
            }
            try self.validate(self.records, name: "records", parent: name, max: 100)
        }

        private enum CodingKeys: String, CodingKey {
            case records = "records"
        }
    }

    public struct BatchUpdateMemoryRecordsOutput: AWSDecodableShape {
        /// A list of memory records that failed to be updated, including error details for each failure.
        public let failedRecords: [MemoryRecordOutput]
        /// A list of memory records that were successfully updated during the batch operation.
        public let successfulRecords: [MemoryRecordOutput]

        @inlinable
        public init(failedRecords: [MemoryRecordOutput], successfulRecords: [MemoryRecordOutput]) {
            self.failedRecords = failedRecords
            self.successfulRecords = successfulRecords
        }

        private enum CodingKeys: String, CodingKey {
            case failedRecords = "failedRecords"
            case successfulRecords = "successfulRecords"
        }
    }

    public struct Branch: AWSEncodableShape & AWSDecodableShape {
        /// The name of the branch.
        public let name: String
        /// The identifier of the root event for this branch.
        public let rootEventId: String?

        @inlinable
        public init(name: String, rootEventId: String? = nil) {
            self.name = name
            self.rootEventId = rootEventId
        }

        public func validate(name: String) throws {
            try self.validate(self.name, name: "name", parent: name, max: 100)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[a-zA-Z0-9][a-zA-Z0-9-_]*$")
            try self.validate(self.rootEventId, name: "rootEventId", parent: name, pattern: "^[0-9]+#[a-fA-F0-9]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case name = "name"
            case rootEventId = "rootEventId"
        }
    }

    public struct BranchFilter: AWSEncodableShape {
        /// Specifies whether to include parent branches in the results. Set to true to include parent branches, or false to exclude them.
        public let includeParentBranches: Bool?
        /// The name of the branch to filter by.
        public let name: String

        @inlinable
        public init(includeParentBranches: Bool? = nil, name: String) {
            self.includeParentBranches = includeParentBranches
            self.name = name
        }

        public func validate(name: String) throws {
            try self.validate(self.name, name: "name", parent: name, max: 100)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[a-zA-Z0-9][a-zA-Z0-9-_]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case includeParentBranches = "includeParentBranches"
            case name = "name"
        }
    }

    public struct BrowserSessionStream: AWSDecodableShape {
        /// The stream that enables programmatic control of the browser. This stream allows agents to perform actions such as navigating to URLs, clicking elements, and filling forms.
        public let automationStream: AutomationStream
        /// The stream that provides a visual representation of the browser content. This stream allows agents to observe the current state of the browser, including rendered web pages and visual elements.
        public let liveViewStream: LiveViewStream?

        @inlinable
        public init(automationStream: AutomationStream, liveViewStream: LiveViewStream? = nil) {
            self.automationStream = automationStream
            self.liveViewStream = liveViewStream
        }

        private enum CodingKeys: String, CodingKey {
            case automationStream = "automationStream"
            case liveViewStream = "liveViewStream"
        }
    }

    public struct BrowserSessionSummary: AWSDecodableShape {
        /// The unique identifier of the browser associated with the session. This identifier specifies which browser environment is used for the session.
        public let browserIdentifier: String
        /// The timestamp when the browser session was created. This value is in ISO 8601 format.
        @CustomCoding<ISO8601DateCoder>
        public var createdAt: Date
        /// The timestamp when the browser session was last updated. This value is in ISO 8601 format.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var lastUpdatedAt: Date?
        /// The name of the browser session. This name helps identify and manage the session.
        public let name: String?
        /// The unique identifier of the browser session. This identifier is used in operations that interact with the session.
        public let sessionId: String
        /// The current status of the browser session. Possible values include ACTIVE, STOPPING, and STOPPED.
        public let status: BrowserSessionStatus

        @inlinable
        public init(browserIdentifier: String, createdAt: Date, lastUpdatedAt: Date? = nil, name: String? = nil, sessionId: String, status: BrowserSessionStatus) {
            self.browserIdentifier = browserIdentifier
            self.createdAt = createdAt
            self.lastUpdatedAt = lastUpdatedAt
            self.name = name
            self.sessionId = sessionId
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case browserIdentifier = "browserIdentifier"
            case createdAt = "createdAt"
            case lastUpdatedAt = "lastUpdatedAt"
            case name = "name"
            case sessionId = "sessionId"
            case status = "status"
        }
    }

    public struct CodeInterpreterResult: AWSDecodableShape {
        /// The textual content of the execution result. This includes standard output from the code execution, such as print statements, console output, and text representations of results.
        public let content: [ContentBlock]
        /// Indicates whether the result represents an error. If true, the content contains error messages or exception information. If false, the content contains successful execution results.
        public let isError: Bool?
        /// The structured content of the execution result. This includes additional metadata about the execution, such as execution time, memory usage, and structured representations of output data. The format depends on the specific code interpreter and execution context.
        public let structuredContent: ToolResultStructuredContent?

        @inlinable
        public init(content: [ContentBlock], isError: Bool? = nil, structuredContent: ToolResultStructuredContent? = nil) {
            self.content = content
            self.isError = isError
            self.structuredContent = structuredContent
        }

        private enum CodingKeys: String, CodingKey {
            case content = "content"
            case isError = "isError"
            case structuredContent = "structuredContent"
        }
    }

    public struct CodeInterpreterSessionSummary: AWSDecodableShape {
        /// The unique identifier of the code interpreter associated with the session. This identifier specifies which code interpreter environment is used for the session.
        public let codeInterpreterIdentifier: String
        /// The timestamp when the code interpreter session was created. This value is in ISO 8601 format.
        @CustomCoding<ISO8601DateCoder>
        public var createdAt: Date
        /// The timestamp when the code interpreter session was last updated. This value is in ISO 8601 format.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var lastUpdatedAt: Date?
        /// The name of the code interpreter session. This name helps identify and manage the session.
        public let name: String?
        /// The unique identifier of the code interpreter session. This identifier is used in operations that interact with the session.
        public let sessionId: String
        /// The current status of the code interpreter session. Possible values include ACTIVE, STOPPING, and STOPPED.
        public let status: CodeInterpreterSessionStatus

        @inlinable
        public init(codeInterpreterIdentifier: String, createdAt: Date, lastUpdatedAt: Date? = nil, name: String? = nil, sessionId: String, status: CodeInterpreterSessionStatus) {
            self.codeInterpreterIdentifier = codeInterpreterIdentifier
            self.createdAt = createdAt
            self.lastUpdatedAt = lastUpdatedAt
            self.name = name
            self.sessionId = sessionId
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case codeInterpreterIdentifier = "codeInterpreterIdentifier"
            case createdAt = "createdAt"
            case lastUpdatedAt = "lastUpdatedAt"
            case name = "name"
            case sessionId = "sessionId"
            case status = "status"
        }
    }

    public struct CompleteResourceTokenAuthRequest: AWSEncodableShape {
        /// Unique identifier for the user's authentication session for retrieving OAuth2 tokens. This ID tracks the authorization flow state across multiple requests and responses during the OAuth2 authentication process.
        public let sessionUri: String
        /// The OAuth2.0 token or user ID that was used to generate the workload access token used for initiating the user authorization flow to retrieve OAuth2.0 tokens.
        public let userIdentifier: UserIdentifier

        @inlinable
        public init(sessionUri: String, userIdentifier: UserIdentifier) {
            self.sessionUri = sessionUri
            self.userIdentifier = userIdentifier
        }

        public func validate(name: String) throws {
            try self.validate(self.sessionUri, name: "sessionUri", parent: name, max: 1024)
            try self.validate(self.sessionUri, name: "sessionUri", parent: name, min: 1)
            try self.validate(self.sessionUri, name: "sessionUri", parent: name, pattern: "^urn:ietf:params:oauth:request_uri:[a-zA-Z0-9-._~]+$")
            try self.userIdentifier.validate(name: "\(name).userIdentifier")
        }

        private enum CodingKeys: String, CodingKey {
            case sessionUri = "sessionUri"
            case userIdentifier = "userIdentifier"
        }
    }

    public struct CompleteResourceTokenAuthResponse: AWSDecodableShape {
        public init() {}
    }

    public struct ConflictException: AWSDecodableShape {
        public let message: String?

        @inlinable
        public init(message: String? = nil) {
            self.message = message
        }

        private enum CodingKeys: String, CodingKey {
            case message = "message"
        }
    }

    public struct ContentBlock: AWSDecodableShape {
        /// The binary data content of the block.
        public let data: AWSBase64Data?
        /// The description of the content block.
        public let description: String?
        /// The MIME type of the content.
        public let mimeType: String?
        /// The name of the content block.
        public let name: String?
        /// The resource associated with the content block.
        public let resource: ResourceContent?
        /// The size of the content in bytes.
        public let size: Int64?
        /// The text content of the block.
        public let text: String?
        /// The type of content in the block.
        public let type: ContentBlockType
        /// The URI of the content.
        public let uri: String?

        @inlinable
        public init(data: AWSBase64Data? = nil, description: String? = nil, mimeType: String? = nil, name: String? = nil, resource: ResourceContent? = nil, size: Int64? = nil, text: String? = nil, type: ContentBlockType, uri: String? = nil) {
            self.data = data
            self.description = description
            self.mimeType = mimeType
            self.name = name
            self.resource = resource
            self.size = size
            self.text = text
            self.type = type
            self.uri = uri
        }

        private enum CodingKeys: String, CodingKey {
            case data = "data"
            case description = "description"
            case mimeType = "mimeType"
            case name = "name"
            case resource = "resource"
            case size = "size"
            case text = "text"
            case type = "type"
            case uri = "uri"
        }
    }

    public struct Conversational: AWSEncodableShape & AWSDecodableShape {
        /// The content of the conversation message.
        public let content: Content
        /// The role of the participant in the conversation (for example, "user" or "assistant").
        public let role: Role

        @inlinable
        public init(content: Content, role: Role) {
            self.content = content
            self.role = role
        }

        private enum CodingKeys: String, CodingKey {
            case content = "content"
            case role = "role"
        }
    }

    public struct CreateEventInput: AWSEncodableShape {
        /// The identifier of the actor associated with this event. An actor represents an entity that participates in sessions and generates events.
        public let actorId: String
        /// The branch information for this event. Branches allow for organizing events into different conversation threads or paths.
        public let branch: Branch?
        /// A unique, case-sensitive identifier to ensure that the operation completes no more than one time. If this token matches a previous request, AgentCore ignores the request, but does not return an error.
        public let clientToken: String?
        /// The timestamp when the event occurred. If not specified, the current time is used.
        public let eventTimestamp: Date
        /// The identifier of the AgentCore Memory resource in which to create the event.
        public let memoryId: String
        /// The key-value metadata to attach to the event.
        public let metadata: [String: MetadataValue]?
        /// The content payload of the event. This can include conversational data or binary content.
        public let payload: [PayloadType]
        /// The identifier of the session in which this event occurs. A session represents a sequence of related events.
        public let sessionId: String?

        @inlinable
        public init(actorId: String, branch: Branch? = nil, clientToken: String? = CreateEventInput.idempotencyToken(), eventTimestamp: Date, memoryId: String, metadata: [String: MetadataValue]? = nil, payload: [PayloadType], sessionId: String? = nil) {
            self.actorId = actorId
            self.branch = branch
            self.clientToken = clientToken
            self.eventTimestamp = eventTimestamp
            self.memoryId = memoryId
            self.metadata = metadata
            self.payload = payload
            self.sessionId = sessionId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encode(self.actorId, forKey: .actorId)
            try container.encodeIfPresent(self.branch, forKey: .branch)
            try container.encodeIfPresent(self.clientToken, forKey: .clientToken)
            try container.encode(self.eventTimestamp, forKey: .eventTimestamp)
            request.encodePath(self.memoryId, key: "memoryId")
            try container.encodeIfPresent(self.metadata, forKey: .metadata)
            try container.encode(self.payload, forKey: .payload)
            try container.encodeIfPresent(self.sessionId, forKey: .sessionId)
        }

        public func validate(name: String) throws {
            try self.validate(self.actorId, name: "actorId", parent: name, max: 255)
            try self.validate(self.actorId, name: "actorId", parent: name, min: 1)
            try self.validate(self.actorId, name: "actorId", parent: name, pattern: "^[a-zA-Z0-9][a-zA-Z0-9-_/]*(?::[a-zA-Z0-9-_/]+)*[a-zA-Z0-9-_/]*$")
            try self.branch?.validate(name: "\(name).branch")
            try self.validate(self.memoryId, name: "memoryId", parent: name, min: 12)
            try self.validate(self.memoryId, name: "memoryId", parent: name, pattern: "^[a-zA-Z][a-zA-Z0-9-_]{0,99}-[a-zA-Z0-9]{10}$")
            try self.metadata?.forEach {
                try validate($0.key, name: "metadata.key", parent: name, max: 128)
                try validate($0.key, name: "metadata.key", parent: name, min: 1)
                try validate($0.key, name: "metadata.key", parent: name, pattern: "^[a-zA-Z0-9\\s._:/=+@-]*$")
            }
            try self.validate(self.metadata, name: "metadata", parent: name, max: 15)
            try self.validate(self.payload, name: "payload", parent: name, max: 100)
            try self.validate(self.sessionId, name: "sessionId", parent: name, max: 100)
            try self.validate(self.sessionId, name: "sessionId", parent: name, min: 1)
            try self.validate(self.sessionId, name: "sessionId", parent: name, pattern: "^[a-zA-Z0-9][a-zA-Z0-9-_]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case actorId = "actorId"
            case branch = "branch"
            case clientToken = "clientToken"
            case eventTimestamp = "eventTimestamp"
            case metadata = "metadata"
            case payload = "payload"
            case sessionId = "sessionId"
        }
    }

    public struct CreateEventOutput: AWSDecodableShape {
        /// The event that was created.
        public let event: Event

        @inlinable
        public init(event: Event) {
            self.event = event
        }

        private enum CodingKeys: String, CodingKey {
            case event = "event"
        }
    }

    public struct DeleteEventInput: AWSEncodableShape {
        /// The identifier of the actor associated with the event to delete.
        public let actorId: String
        /// The identifier of the event to delete.
        public let eventId: String
        /// The identifier of the AgentCore Memory resource from which to delete the event.
        public let memoryId: String
        /// The identifier of the session containing the event to delete.
        public let sessionId: String

        @inlinable
        public init(actorId: String, eventId: String, memoryId: String, sessionId: String) {
            self.actorId = actorId
            self.eventId = eventId
            self.memoryId = memoryId
            self.sessionId = sessionId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.actorId, key: "actorId")
            request.encodePath(self.eventId, key: "eventId")
            request.encodePath(self.memoryId, key: "memoryId")
            request.encodePath(self.sessionId, key: "sessionId")
        }

        public func validate(name: String) throws {
            try self.validate(self.actorId, name: "actorId", parent: name, max: 255)
            try self.validate(self.actorId, name: "actorId", parent: name, min: 1)
            try self.validate(self.actorId, name: "actorId", parent: name, pattern: "^[a-zA-Z0-9][a-zA-Z0-9-_/]*(?::[a-zA-Z0-9-_/]+)*[a-zA-Z0-9-_/]*$")
            try self.validate(self.eventId, name: "eventId", parent: name, pattern: "^[0-9]+#[a-fA-F0-9]+$")
            try self.validate(self.memoryId, name: "memoryId", parent: name, min: 12)
            try self.validate(self.memoryId, name: "memoryId", parent: name, pattern: "^[a-zA-Z][a-zA-Z0-9-_]{0,99}-[a-zA-Z0-9]{10}$")
            try self.validate(self.sessionId, name: "sessionId", parent: name, max: 100)
            try self.validate(self.sessionId, name: "sessionId", parent: name, min: 1)
            try self.validate(self.sessionId, name: "sessionId", parent: name, pattern: "^[a-zA-Z0-9][a-zA-Z0-9-_]*$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteEventOutput: AWSDecodableShape {
        /// The identifier of the event that was deleted.
        public let eventId: String

        @inlinable
        public init(eventId: String) {
            self.eventId = eventId
        }

        private enum CodingKeys: String, CodingKey {
            case eventId = "eventId"
        }
    }

    public struct DeleteMemoryRecordInput: AWSEncodableShape {
        /// The identifier of the AgentCore Memory resource from which to delete the memory record.
        public let memoryId: String
        /// The identifier of the memory record to delete.
        public let memoryRecordId: String

        @inlinable
        public init(memoryId: String, memoryRecordId: String) {
            self.memoryId = memoryId
            self.memoryRecordId = memoryRecordId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.memoryId, key: "memoryId")
            request.encodePath(self.memoryRecordId, key: "memoryRecordId")
        }

        public func validate(name: String) throws {
            try self.validate(self.memoryId, name: "memoryId", parent: name, min: 12)
            try self.validate(self.memoryId, name: "memoryId", parent: name, pattern: "^[a-zA-Z][a-zA-Z0-9-_]{0,99}-[a-zA-Z0-9]{10}$")
            try self.validate(self.memoryRecordId, name: "memoryRecordId", parent: name, max: 50)
            try self.validate(self.memoryRecordId, name: "memoryRecordId", parent: name, min: 40)
            try self.validate(self.memoryRecordId, name: "memoryRecordId", parent: name, pattern: "^mem-[a-zA-Z0-9-_]*$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteMemoryRecordOutput: AWSDecodableShape {
        /// The identifier of the memory record that was deleted.
        public let memoryRecordId: String

        @inlinable
        public init(memoryRecordId: String) {
            self.memoryRecordId = memoryRecordId
        }

        private enum CodingKeys: String, CodingKey {
            case memoryRecordId = "memoryRecordId"
        }
    }

    public struct EvaluateRequest: AWSEncodableShape {
        ///  The input data containing agent session spans to be evaluated. Includes a list of spans in OpenTelemetry format from supported frameworks like Strands (AgentCore Runtime) or LangGraph with OpenInference instrumentation.
        public let evaluationInput: EvaluationInput
        ///  The specific trace or span IDs to evaluate within the provided input. Allows targeting evaluation at different levels: individual tool calls, single request-response interactions (traces), or entire conversation sessions.
        public let evaluationTarget: EvaluationTarget?
        ///  The unique identifier of the evaluator to use for scoring. Can be a built-in evaluator (e.g., Builtin.Helpfulness, Builtin.Correctness) or a custom evaluator ARN created through the control plane API.
        public let evaluatorId: String

        @inlinable
        public init(evaluationInput: EvaluationInput, evaluationTarget: EvaluationTarget? = nil, evaluatorId: String) {
            self.evaluationInput = evaluationInput
            self.evaluationTarget = evaluationTarget
            self.evaluatorId = evaluatorId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encode(self.evaluationInput, forKey: .evaluationInput)
            try container.encodeIfPresent(self.evaluationTarget, forKey: .evaluationTarget)
            request.encodePath(self.evaluatorId, key: "evaluatorId")
        }

        public func validate(name: String) throws {
            try self.evaluationInput.validate(name: "\(name).evaluationInput")
            try self.evaluationTarget?.validate(name: "\(name).evaluationTarget")
            try self.validate(self.evaluatorId, name: "evaluatorId", parent: name, pattern: "^(Builtin.[a-zA-Z0-9_-]+|[a-zA-Z][a-zA-Z0-9-_]{0,99}-[a-zA-Z0-9]{10})$")
        }

        private enum CodingKeys: String, CodingKey {
            case evaluationInput = "evaluationInput"
            case evaluationTarget = "evaluationTarget"
        }
    }

    public struct EvaluateResponse: AWSDecodableShape {
        ///  The detailed evaluation results containing scores, explanations, and metadata. Includes the evaluator information, numerical or categorical ratings based on the evaluator's rating scale, and token usage statistics for the evaluation process.
        public let evaluationResults: [EvaluationResultContent]

        @inlinable
        public init(evaluationResults: [EvaluationResultContent]) {
            self.evaluationResults = evaluationResults
        }

        private enum CodingKeys: String, CodingKey {
            case evaluationResults = "evaluationResults"
        }
    }

    public struct EvaluationResultContent: AWSDecodableShape {
        ///  The contextual information associated with this evaluation result, including span context details that identify the specific traces and sessions that were evaluated.
        public let context: Context
        ///  The error code indicating the type of failure that occurred during evaluation. Used to programmatically identify and handle different categories of evaluation errors.
        public let errorCode: String?
        ///  The error message describing what went wrong if the evaluation failed. Provides detailed information about evaluation failures to help diagnose and resolve issues with evaluator configuration or input data.
        public let errorMessage: String?
        ///  The Amazon Resource Name (ARN) of the evaluator used to generate this result. For custom evaluators, this is the full ARN; for built-in evaluators, this follows the pattern Builtin.{EvaluatorName}.
        public let evaluatorArn: String
        ///  The unique identifier of the evaluator that produced this result. This matches the evaluatorId provided in the evaluation request and can be used to identify which evaluator generated specific results.
        public let evaluatorId: String
        ///  The human-readable name of the evaluator used for this evaluation. For built-in evaluators, this is the descriptive name (e.g., "Helpfulness", "Correctness"); for custom evaluators, this is the user-defined name.
        public let evaluatorName: String
        ///  The detailed explanation provided by the evaluator describing the reasoning behind the assigned score. This qualitative feedback helps understand why specific ratings were given and provides actionable insights for improvement.
        public let explanation: String?
        ///  The categorical label assigned by the evaluator when using a categorical rating scale. This provides a human-readable description of the evaluation result (e.g., "Excellent", "Good", "Poor") corresponding to the numerical value. For numerical scales, this field is optional and provides a natural language explanation of what the value means (e.g., value 0.5 = "Somewhat Helpful").
        public let label: String?
        ///  The token consumption statistics for this evaluation, including input tokens, output tokens, and total tokens used by the underlying language model during the evaluation process.
        public let tokenUsage: TokenUsage?
        ///  The numerical score assigned by the evaluator according to its configured rating scale. For numerical scales, this is a decimal value within the defined range. This field is not allowed for categorical scales.
        public let value: Double?

        @inlinable
        public init(context: Context, errorCode: String? = nil, errorMessage: String? = nil, evaluatorArn: String, evaluatorId: String, evaluatorName: String, explanation: String? = nil, label: String? = nil, tokenUsage: TokenUsage? = nil, value: Double? = nil) {
            self.context = context
            self.errorCode = errorCode
            self.errorMessage = errorMessage
            self.evaluatorArn = evaluatorArn
            self.evaluatorId = evaluatorId
            self.evaluatorName = evaluatorName
            self.explanation = explanation
            self.label = label
            self.tokenUsage = tokenUsage
            self.value = value
        }

        private enum CodingKeys: String, CodingKey {
            case context = "context"
            case errorCode = "errorCode"
            case errorMessage = "errorMessage"
            case evaluatorArn = "evaluatorArn"
            case evaluatorId = "evaluatorId"
            case evaluatorName = "evaluatorName"
            case explanation = "explanation"
            case label = "label"
            case tokenUsage = "tokenUsage"
            case value = "value"
        }
    }

    public struct Event: AWSDecodableShape {
        /// The identifier of the actor associated with the event.
        public let actorId: String
        /// The branch information for the event.
        public let branch: Branch?
        /// The unique identifier of the event.
        public let eventId: String
        /// The timestamp when the event occurred.
        public let eventTimestamp: Date
        /// The identifier of the AgentCore Memory resource containing the event.
        public let memoryId: String
        /// Metadata associated with an event.
        public let metadata: [String: MetadataValue]?
        /// The content payload of the event.
        public let payload: [PayloadType]
        /// The identifier of the session containing the event.
        public let sessionId: String

        @inlinable
        public init(actorId: String, branch: Branch? = nil, eventId: String, eventTimestamp: Date, memoryId: String, metadata: [String: MetadataValue]? = nil, payload: [PayloadType], sessionId: String) {
            self.actorId = actorId
            self.branch = branch
            self.eventId = eventId
            self.eventTimestamp = eventTimestamp
            self.memoryId = memoryId
            self.metadata = metadata
            self.payload = payload
            self.sessionId = sessionId
        }

        private enum CodingKeys: String, CodingKey {
            case actorId = "actorId"
            case branch = "branch"
            case eventId = "eventId"
            case eventTimestamp = "eventTimestamp"
            case memoryId = "memoryId"
            case metadata = "metadata"
            case payload = "payload"
            case sessionId = "sessionId"
        }
    }

    public struct EventMetadataFilterExpression: AWSEncodableShape {
        /// Left operand of the event metadata filter expression.
        public let left: LeftExpression
        /// Operator applied to the event metadata filter expression.
        public let `operator`: OperatorType
        /// Right operand of the event metadata filter expression.
        public let right: RightExpression?

        @inlinable
        public init(left: LeftExpression, operator: OperatorType, right: RightExpression? = nil) {
            self.left = left
            self.`operator` = `operator`
            self.right = right
        }

        public func validate(name: String) throws {
            try self.left.validate(name: "\(name).left")
        }

        private enum CodingKeys: String, CodingKey {
            case left = "left"
            case `operator` = "operator"
            case right = "right"
        }
    }

    public struct ExtractionJob: AWSEncodableShape {
        /// The unique identifier of the extraction job.
        public let jobId: String

        @inlinable
        public init(jobId: String) {
            self.jobId = jobId
        }

        private enum CodingKeys: String, CodingKey {
            case jobId = "jobId"
        }
    }

    public struct ExtractionJobFilterInput: AWSEncodableShape {
        /// The identifier of the actor. If specified, only extraction jobs with this actor ID are returned.
        public let actorId: String?
        /// The unique identifier of the session. If specified, only extraction jobs with this session ID are returned.
        public let sessionId: String?
        /// The status of the extraction job. If specified, only extraction jobs with this status are returned.
        public let status: ExtractionJobStatus?
        /// The memory strategy identifier to filter extraction jobs by. If specified, only extraction jobs with this strategy ID are returned.
        public let strategyId: String?

        @inlinable
        public init(actorId: String? = nil, sessionId: String? = nil, status: ExtractionJobStatus? = nil, strategyId: String? = nil) {
            self.actorId = actorId
            self.sessionId = sessionId
            self.status = status
            self.strategyId = strategyId
        }

        private enum CodingKeys: String, CodingKey {
            case actorId = "actorId"
            case sessionId = "sessionId"
            case status = "status"
            case strategyId = "strategyId"
        }
    }

    public struct ExtractionJobMetadata: AWSDecodableShape {
        /// The identifier of the actor for this extraction job.
        public let actorId: String?
        /// The cause of failure, if the job did not complete successfully.
        public let failureReason: String?
        /// The unique identifier for the extraction job.
        public let jobID: String
        /// The messages associated with the extraction job.
        public let messages: ExtractionJobMessages
        /// The identifier of the session for this extraction job.
        public let sessionId: String?
        /// The current status of the extraction job.
        public let status: ExtractionJobStatus?
        /// The identifier of the memory strategy for this extraction job.
        public let strategyId: String?

        @inlinable
        public init(actorId: String? = nil, failureReason: String? = nil, jobID: String, messages: ExtractionJobMessages, sessionId: String? = nil, status: ExtractionJobStatus? = nil, strategyId: String? = nil) {
            self.actorId = actorId
            self.failureReason = failureReason
            self.jobID = jobID
            self.messages = messages
            self.sessionId = sessionId
            self.status = status
            self.strategyId = strategyId
        }

        private enum CodingKeys: String, CodingKey {
            case actorId = "actorId"
            case failureReason = "failureReason"
            case jobID = "jobID"
            case messages = "messages"
            case sessionId = "sessionId"
            case status = "status"
            case strategyId = "strategyId"
        }
    }

    public struct FilterInput: AWSEncodableShape {
        /// The branch filter criteria to apply when listing events.
        public let branch: BranchFilter?
        /// Event metadata filter criteria to apply when retrieving events.
        public let eventMetadata: [EventMetadataFilterExpression]?

        @inlinable
        public init(branch: BranchFilter? = nil, eventMetadata: [EventMetadataFilterExpression]? = nil) {
            self.branch = branch
            self.eventMetadata = eventMetadata
        }

        public func validate(name: String) throws {
            try self.branch?.validate(name: "\(name).branch")
            try self.eventMetadata?.forEach {
                try $0.validate(name: "\(name).eventMetadata[]")
            }
            try self.validate(self.eventMetadata, name: "eventMetadata", parent: name, max: 5)
            try self.validate(self.eventMetadata, name: "eventMetadata", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case branch = "branch"
            case eventMetadata = "eventMetadata"
        }
    }

    public struct GetAgentCardRequest: AWSEncodableShape {
        /// The ARN of the AgentCore Runtime agent for which you want to get the A2A agent card.
        public let agentRuntimeArn: String
        /// Optional qualifier to specify an agent alias, such as prodcode&gt; or dev. If you don't provide a value, the DEFAULT alias is used.
        public let qualifier: String?
        /// The session ID that the AgentCore Runtime agent is using.
        public let runtimeSessionId: String?

        @inlinable
        public init(agentRuntimeArn: String, qualifier: String? = nil, runtimeSessionId: String? = GetAgentCardRequest.idempotencyToken()) {
            self.agentRuntimeArn = agentRuntimeArn
            self.qualifier = qualifier
            self.runtimeSessionId = runtimeSessionId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.agentRuntimeArn, key: "agentRuntimeArn")
            request.encodeQuery(self.qualifier, key: "qualifier")
            request.encodeHeader(self.runtimeSessionId, key: "X-Amzn-Bedrock-AgentCore-Runtime-Session-Id")
        }

        public func validate(name: String) throws {
            try self.validate(self.runtimeSessionId, name: "runtimeSessionId", parent: name, max: 256)
            try self.validate(self.runtimeSessionId, name: "runtimeSessionId", parent: name, min: 33)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetAgentCardResponse: AWSDecodableShape {
        /// An agent card document that contains metadata and capabilities for an AgentCore Runtime agent.
        public let agentCard: AWSDocument
        /// The ID of the session associated with the AgentCore Runtime agent.
        public let runtimeSessionId: String?
        /// The status code of the request.
        public let statusCode: Int?

        @inlinable
        public init(agentCard: AWSDocument, runtimeSessionId: String? = nil, statusCode: Int? = nil) {
            self.agentCard = agentCard
            self.runtimeSessionId = runtimeSessionId
            self.statusCode = statusCode
        }

        public init(from decoder: Decoder) throws {
            let response = decoder.userInfo[.awsResponse]! as! ResponseDecodingContainer
            let container = try decoder.singleValueContainer()
            self.agentCard = try container.decode(AWSDocument.self)
            self.runtimeSessionId = try response.decodeHeaderIfPresent(String.self, key: "X-Amzn-Bedrock-AgentCore-Runtime-Session-Id")
            self.statusCode = response.decodeStatus()
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetBrowserSessionRequest: AWSEncodableShape {
        /// The unique identifier of the browser associated with the session.
        public let browserIdentifier: String
        /// The unique identifier of the browser session to retrieve.
        public let sessionId: String

        @inlinable
        public init(browserIdentifier: String, sessionId: String) {
            self.browserIdentifier = browserIdentifier
            self.sessionId = sessionId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.browserIdentifier, key: "browserIdentifier")
            request.encodeQuery(self.sessionId, key: "sessionId")
        }

        public func validate(name: String) throws {
            try self.validate(self.sessionId, name: "sessionId", parent: name, pattern: "^[0-9a-zA-Z]{1,40}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetBrowserSessionResponse: AWSDecodableShape {
        /// The identifier of the browser.
        public let browserIdentifier: String
        /// The time at which the browser session was created.
        @CustomCoding<ISO8601DateCoder>
        public var createdAt: Date
        /// The time at which the browser session was last updated.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var lastUpdatedAt: Date?
        /// The name of the browser session.
        public let name: String?
        /// The identifier of the browser session.
        public let sessionId: String
        /// The artifact containing the session replay information.
        public let sessionReplayArtifact: String?
        /// The timeout period for the browser session in seconds.
        public let sessionTimeoutSeconds: Int?
        /// The current status of the browser session. Possible values include ACTIVE, STOPPING, and STOPPED.
        public let status: BrowserSessionStatus?
        /// The streams associated with this browser session. These include the automation stream and live view stream.
        public let streams: BrowserSessionStream?
        public let viewPort: ViewPort?

        @inlinable
        public init(browserIdentifier: String, createdAt: Date, lastUpdatedAt: Date? = nil, name: String? = nil, sessionId: String, sessionReplayArtifact: String? = nil, sessionTimeoutSeconds: Int? = nil, status: BrowserSessionStatus? = nil, streams: BrowserSessionStream? = nil, viewPort: ViewPort? = nil) {
            self.browserIdentifier = browserIdentifier
            self.createdAt = createdAt
            self.lastUpdatedAt = lastUpdatedAt
            self.name = name
            self.sessionId = sessionId
            self.sessionReplayArtifact = sessionReplayArtifact
            self.sessionTimeoutSeconds = sessionTimeoutSeconds
            self.status = status
            self.streams = streams
            self.viewPort = viewPort
        }

        private enum CodingKeys: String, CodingKey {
            case browserIdentifier = "browserIdentifier"
            case createdAt = "createdAt"
            case lastUpdatedAt = "lastUpdatedAt"
            case name = "name"
            case sessionId = "sessionId"
            case sessionReplayArtifact = "sessionReplayArtifact"
            case sessionTimeoutSeconds = "sessionTimeoutSeconds"
            case status = "status"
            case streams = "streams"
            case viewPort = "viewPort"
        }
    }

    public struct GetCodeInterpreterSessionRequest: AWSEncodableShape {
        /// The unique identifier of the code interpreter associated with the session.
        public let codeInterpreterIdentifier: String
        /// The unique identifier of the code interpreter session to retrieve.
        public let sessionId: String

        @inlinable
        public init(codeInterpreterIdentifier: String, sessionId: String) {
            self.codeInterpreterIdentifier = codeInterpreterIdentifier
            self.sessionId = sessionId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.codeInterpreterIdentifier, key: "codeInterpreterIdentifier")
            request.encodeQuery(self.sessionId, key: "sessionId")
        }

        public func validate(name: String) throws {
            try self.validate(self.sessionId, name: "sessionId", parent: name, pattern: "^[0-9a-zA-Z]{1,40}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetCodeInterpreterSessionResponse: AWSDecodableShape {
        /// The identifier of the code interpreter.
        public let codeInterpreterIdentifier: String
        /// The time at which the code interpreter session was created.
        @CustomCoding<ISO8601DateCoder>
        public var createdAt: Date
        /// The name of the code interpreter session.
        public let name: String?
        /// The identifier of the code interpreter session.
        public let sessionId: String
        /// The timeout period for the code interpreter session in seconds.
        public let sessionTimeoutSeconds: Int?
        /// The current status of the code interpreter session. Possible values include ACTIVE, STOPPING, and STOPPED.
        public let status: CodeInterpreterSessionStatus?

        @inlinable
        public init(codeInterpreterIdentifier: String, createdAt: Date, name: String? = nil, sessionId: String, sessionTimeoutSeconds: Int? = nil, status: CodeInterpreterSessionStatus? = nil) {
            self.codeInterpreterIdentifier = codeInterpreterIdentifier
            self.createdAt = createdAt
            self.name = name
            self.sessionId = sessionId
            self.sessionTimeoutSeconds = sessionTimeoutSeconds
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case codeInterpreterIdentifier = "codeInterpreterIdentifier"
            case createdAt = "createdAt"
            case name = "name"
            case sessionId = "sessionId"
            case sessionTimeoutSeconds = "sessionTimeoutSeconds"
            case status = "status"
        }
    }

    public struct GetEventInput: AWSEncodableShape {
        /// The identifier of the actor associated with the event.
        public let actorId: String
        /// The identifier of the event to retrieve.
        public let eventId: String
        /// The identifier of the AgentCore Memory resource containing the event.
        public let memoryId: String
        /// The identifier of the session containing the event.
        public let sessionId: String

        @inlinable
        public init(actorId: String, eventId: String, memoryId: String, sessionId: String) {
            self.actorId = actorId
            self.eventId = eventId
            self.memoryId = memoryId
            self.sessionId = sessionId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.actorId, key: "actorId")
            request.encodePath(self.eventId, key: "eventId")
            request.encodePath(self.memoryId, key: "memoryId")
            request.encodePath(self.sessionId, key: "sessionId")
        }

        public func validate(name: String) throws {
            try self.validate(self.actorId, name: "actorId", parent: name, max: 255)
            try self.validate(self.actorId, name: "actorId", parent: name, min: 1)
            try self.validate(self.actorId, name: "actorId", parent: name, pattern: "^[a-zA-Z0-9][a-zA-Z0-9-_/]*(?::[a-zA-Z0-9-_/]+)*[a-zA-Z0-9-_/]*$")
            try self.validate(self.eventId, name: "eventId", parent: name, pattern: "^[0-9]+#[a-fA-F0-9]+$")
            try self.validate(self.memoryId, name: "memoryId", parent: name, min: 12)
            try self.validate(self.memoryId, name: "memoryId", parent: name, pattern: "^[a-zA-Z][a-zA-Z0-9-_]{0,99}-[a-zA-Z0-9]{10}$")
            try self.validate(self.sessionId, name: "sessionId", parent: name, max: 100)
            try self.validate(self.sessionId, name: "sessionId", parent: name, min: 1)
            try self.validate(self.sessionId, name: "sessionId", parent: name, pattern: "^[a-zA-Z0-9][a-zA-Z0-9-_]*$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetEventOutput: AWSDecodableShape {
        /// The requested event information.
        public let event: Event

        @inlinable
        public init(event: Event) {
            self.event = event
        }

        private enum CodingKeys: String, CodingKey {
            case event = "event"
        }
    }

    public struct GetMemoryRecordInput: AWSEncodableShape {
        /// The identifier of the AgentCore Memory resource containing the memory record.
        public let memoryId: String
        /// The identifier of the memory record to retrieve.
        public let memoryRecordId: String

        @inlinable
        public init(memoryId: String, memoryRecordId: String) {
            self.memoryId = memoryId
            self.memoryRecordId = memoryRecordId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.memoryId, key: "memoryId")
            request.encodePath(self.memoryRecordId, key: "memoryRecordId")
        }

        public func validate(name: String) throws {
            try self.validate(self.memoryId, name: "memoryId", parent: name, min: 12)
            try self.validate(self.memoryId, name: "memoryId", parent: name, pattern: "^[a-zA-Z][a-zA-Z0-9-_]{0,99}-[a-zA-Z0-9]{10}$")
            try self.validate(self.memoryRecordId, name: "memoryRecordId", parent: name, max: 50)
            try self.validate(self.memoryRecordId, name: "memoryRecordId", parent: name, min: 40)
            try self.validate(self.memoryRecordId, name: "memoryRecordId", parent: name, pattern: "^mem-[a-zA-Z0-9-_]*$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetMemoryRecordOutput: AWSDecodableShape {
        /// The requested memory record.
        public let memoryRecord: MemoryRecord

        @inlinable
        public init(memoryRecord: MemoryRecord) {
            self.memoryRecord = memoryRecord
        }

        private enum CodingKeys: String, CodingKey {
            case memoryRecord = "memoryRecord"
        }
    }

    public struct GetResourceApiKeyRequest: AWSEncodableShape {
        /// The credential provider name for the resource from which you are retrieving the API key.
        public let resourceCredentialProviderName: String
        /// The identity token of the workload from which you want to retrieve the API key.
        public let workloadIdentityToken: String

        @inlinable
        public init(resourceCredentialProviderName: String, workloadIdentityToken: String) {
            self.resourceCredentialProviderName = resourceCredentialProviderName
            self.workloadIdentityToken = workloadIdentityToken
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceCredentialProviderName, name: "resourceCredentialProviderName", parent: name, max: 128)
            try self.validate(self.resourceCredentialProviderName, name: "resourceCredentialProviderName", parent: name, min: 1)
            try self.validate(self.resourceCredentialProviderName, name: "resourceCredentialProviderName", parent: name, pattern: "^[a-zA-Z0-9\\-_]+$")
            try self.validate(self.workloadIdentityToken, name: "workloadIdentityToken", parent: name, max: 131072)
            try self.validate(self.workloadIdentityToken, name: "workloadIdentityToken", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case resourceCredentialProviderName = "resourceCredentialProviderName"
            case workloadIdentityToken = "workloadIdentityToken"
        }
    }

    public struct GetResourceApiKeyResponse: AWSDecodableShape {
        /// The API key associated with the resource requested.
        public let apiKey: String

        @inlinable
        public init(apiKey: String) {
            self.apiKey = apiKey
        }

        private enum CodingKeys: String, CodingKey {
            case apiKey = "apiKey"
        }
    }

    public struct GetResourceOauth2TokenRequest: AWSEncodableShape {
        /// A map of custom parameters to include in the authorization request to the resource credential provider. These parameters are in addition to the standard OAuth 2.0 flow parameters, and will not override them.
        public let customParameters: [String: String]?
        /// An opaque string that will be sent back to the callback URL provided in resourceOauth2ReturnUrl. This state should be used to protect the callback URL of your application against CSRF attacks by ensuring the response corresponds to the original request.
        public let customState: String?
        /// Indicates whether to always initiate a new three-legged OAuth (3LO) flow, regardless of any existing session.
        public let forceAuthentication: Bool?
        /// The type of flow to be performed.
        public let oauth2Flow: Oauth2FlowType
        /// The name of the resource's credential provider.
        public let resourceCredentialProviderName: String
        /// The callback URL to redirect to after the OAuth 2.0 token retrieval is complete. This URL must be one of the provided URLs configured for the workload identity.
        public let resourceOauth2ReturnUrl: String?
        /// The OAuth scopes being requested.
        public let scopes: [String]
        /// Unique identifier for the user's authentication session for retrieving OAuth2 tokens. This ID tracks the authorization flow state across multiple requests and responses during the OAuth2 authentication process.
        public let sessionUri: String?
        /// The identity token of the workload from which you want to retrieve the OAuth2 token.
        public let workloadIdentityToken: String

        @inlinable
        public init(customParameters: [String: String]? = nil, customState: String? = nil, forceAuthentication: Bool? = nil, oauth2Flow: Oauth2FlowType, resourceCredentialProviderName: String, resourceOauth2ReturnUrl: String? = nil, scopes: [String], sessionUri: String? = nil, workloadIdentityToken: String) {
            self.customParameters = customParameters
            self.customState = customState
            self.forceAuthentication = forceAuthentication
            self.oauth2Flow = oauth2Flow
            self.resourceCredentialProviderName = resourceCredentialProviderName
            self.resourceOauth2ReturnUrl = resourceOauth2ReturnUrl
            self.scopes = scopes
            self.sessionUri = sessionUri
            self.workloadIdentityToken = workloadIdentityToken
        }

        public func validate(name: String) throws {
            try self.customParameters?.forEach {
                try validate($0.key, name: "customParameters.key", parent: name, max: 256)
                try validate($0.key, name: "customParameters.key", parent: name, min: 1)
                try validate($0.key, name: "customParameters.key", parent: name, pattern: "^[a-zA-Z0-9\\-_\\.]+$")
                try validate($0.value, name: "customParameters[\"\($0.key)\"]", parent: name, max: 2048)
                try validate($0.value, name: "customParameters[\"\($0.key)\"]", parent: name, min: 1)
            }
            try self.validate(self.customState, name: "customState", parent: name, max: 4096)
            try self.validate(self.customState, name: "customState", parent: name, min: 1)
            try self.validate(self.resourceCredentialProviderName, name: "resourceCredentialProviderName", parent: name, max: 128)
            try self.validate(self.resourceCredentialProviderName, name: "resourceCredentialProviderName", parent: name, min: 1)
            try self.validate(self.resourceCredentialProviderName, name: "resourceCredentialProviderName", parent: name, pattern: "^[a-zA-Z0-9\\-_]+$")
            try self.validate(self.resourceOauth2ReturnUrl, name: "resourceOauth2ReturnUrl", parent: name, max: 2048)
            try self.validate(self.resourceOauth2ReturnUrl, name: "resourceOauth2ReturnUrl", parent: name, min: 1)
            try self.validate(self.resourceOauth2ReturnUrl, name: "resourceOauth2ReturnUrl", parent: name, pattern: "^\\w+:(\\/?\\/?)[^\\s]+$")
            try self.scopes.forEach {
                try validate($0, name: "scopes[]", parent: name, max: 128)
                try validate($0, name: "scopes[]", parent: name, min: 1)
            }
            try self.validate(self.sessionUri, name: "sessionUri", parent: name, max: 1024)
            try self.validate(self.sessionUri, name: "sessionUri", parent: name, min: 1)
            try self.validate(self.sessionUri, name: "sessionUri", parent: name, pattern: "^urn:ietf:params:oauth:request_uri:[a-zA-Z0-9-._~]+$")
            try self.validate(self.workloadIdentityToken, name: "workloadIdentityToken", parent: name, max: 131072)
            try self.validate(self.workloadIdentityToken, name: "workloadIdentityToken", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case customParameters = "customParameters"
            case customState = "customState"
            case forceAuthentication = "forceAuthentication"
            case oauth2Flow = "oauth2Flow"
            case resourceCredentialProviderName = "resourceCredentialProviderName"
            case resourceOauth2ReturnUrl = "resourceOauth2ReturnUrl"
            case scopes = "scopes"
            case sessionUri = "sessionUri"
            case workloadIdentityToken = "workloadIdentityToken"
        }
    }

    public struct GetResourceOauth2TokenResponse: AWSDecodableShape {
        /// The OAuth 2.0 access token to use.
        public let accessToken: String?
        /// The URL to initiate the authorization process, provided when the access token requires user authorization.
        public let authorizationUrl: String?
        /// Status indicating whether the user's authorization session is in progress or has failed. This helps determine the next steps in the OAuth2 authentication flow.
        public let sessionStatus: SessionStatus?
        /// Unique identifier for the user's authorization session for retrieving OAuth2 tokens. This matches the sessionId from the request and can be used to track the session state.
        public let sessionUri: String?

        @inlinable
        public init(accessToken: String? = nil, authorizationUrl: String? = nil, sessionStatus: SessionStatus? = nil, sessionUri: String? = nil) {
            self.accessToken = accessToken
            self.authorizationUrl = authorizationUrl
            self.sessionStatus = sessionStatus
            self.sessionUri = sessionUri
        }

        private enum CodingKeys: String, CodingKey {
            case accessToken = "accessToken"
            case authorizationUrl = "authorizationUrl"
            case sessionStatus = "sessionStatus"
            case sessionUri = "sessionUri"
        }
    }

    public struct GetWorkloadAccessTokenForJWTRequest: AWSEncodableShape {
        /// The OAuth 2.0 token issued by the user's identity provider.
        public let userToken: String
        /// The unique identifier for the registered workload.
        public let workloadName: String

        @inlinable
        public init(userToken: String, workloadName: String) {
            self.userToken = userToken
            self.workloadName = workloadName
        }

        public func validate(name: String) throws {
            try self.validate(self.userToken, name: "userToken", parent: name, max: 131072)
            try self.validate(self.userToken, name: "userToken", parent: name, min: 1)
            try self.validate(self.userToken, name: "userToken", parent: name, pattern: "^[A-Za-z0-9-_=]+.[A-Za-z0-9-_=]+.[A-Za-z0-9-_=]+$")
            try self.validate(self.workloadName, name: "workloadName", parent: name, max: 255)
            try self.validate(self.workloadName, name: "workloadName", parent: name, min: 3)
            try self.validate(self.workloadName, name: "workloadName", parent: name, pattern: "^[A-Za-z0-9_.-]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case userToken = "userToken"
            case workloadName = "workloadName"
        }
    }

    public struct GetWorkloadAccessTokenForJWTResponse: AWSDecodableShape {
        /// An opaque token representing the identity of both the workload and the user.
        public let workloadAccessToken: String

        @inlinable
        public init(workloadAccessToken: String) {
            self.workloadAccessToken = workloadAccessToken
        }

        private enum CodingKeys: String, CodingKey {
            case workloadAccessToken = "workloadAccessToken"
        }
    }

    public struct GetWorkloadAccessTokenForUserIdRequest: AWSEncodableShape {
        /// The ID of the user for whom you are retrieving the access token.
        public let userId: String
        /// The name of the workload from which you want to retrieve the access token.
        public let workloadName: String

        @inlinable
        public init(userId: String, workloadName: String) {
            self.userId = userId
            self.workloadName = workloadName
        }

        public func validate(name: String) throws {
            try self.validate(self.userId, name: "userId", parent: name, max: 128)
            try self.validate(self.userId, name: "userId", parent: name, min: 1)
            try self.validate(self.workloadName, name: "workloadName", parent: name, max: 255)
            try self.validate(self.workloadName, name: "workloadName", parent: name, min: 3)
            try self.validate(self.workloadName, name: "workloadName", parent: name, pattern: "^[A-Za-z0-9_.-]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case userId = "userId"
            case workloadName = "workloadName"
        }
    }

    public struct GetWorkloadAccessTokenForUserIdResponse: AWSDecodableShape {
        /// The access token for the specified workload.
        public let workloadAccessToken: String

        @inlinable
        public init(workloadAccessToken: String) {
            self.workloadAccessToken = workloadAccessToken
        }

        private enum CodingKeys: String, CodingKey {
            case workloadAccessToken = "workloadAccessToken"
        }
    }

    public struct GetWorkloadAccessTokenRequest: AWSEncodableShape {
        /// The unique identifier for the registered workload.
        public let workloadName: String

        @inlinable
        public init(workloadName: String) {
            self.workloadName = workloadName
        }

        public func validate(name: String) throws {
            try self.validate(self.workloadName, name: "workloadName", parent: name, max: 255)
            try self.validate(self.workloadName, name: "workloadName", parent: name, min: 3)
            try self.validate(self.workloadName, name: "workloadName", parent: name, pattern: "^[A-Za-z0-9_.-]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case workloadName = "workloadName"
        }
    }

    public struct GetWorkloadAccessTokenResponse: AWSDecodableShape {
        /// An opaque token representing the identity of both the workload and the user.
        public let workloadAccessToken: String

        @inlinable
        public init(workloadAccessToken: String) {
            self.workloadAccessToken = workloadAccessToken
        }

        private enum CodingKeys: String, CodingKey {
            case workloadAccessToken = "workloadAccessToken"
        }
    }

    public struct InputContentBlock: AWSEncodableShape {
        /// The binary input content.
        public let blob: AWSBase64Data?
        /// The path to the input content.
        public let path: String
        /// The text input content.
        public let text: String?

        @inlinable
        public init(blob: AWSBase64Data? = nil, path: String, text: String? = nil) {
            self.blob = blob
            self.path = path
            self.text = text
        }

        public func validate(name: String) throws {
            try self.validate(self.blob, name: "blob", parent: name, max: 100000000)
            try self.validate(self.path, name: "path", parent: name, max: 100000000)
            try self.validate(self.text, name: "text", parent: name, max: 100000000)
        }

        private enum CodingKeys: String, CodingKey {
            case blob = "blob"
            case path = "path"
            case text = "text"
        }
    }

    public struct InternalServerException: AWSDecodableShape {
        public let message: String?

        @inlinable
        public init(message: String? = nil) {
            self.message = message
        }

        private enum CodingKeys: String, CodingKey {
            case message = "message"
        }
    }

    public struct InvokeAgentRuntimeRequest: AWSEncodableShape {
        /// The desired MIME type for the response from the agent runtime. This tells the agent runtime what format to use for the response data. Common values include application/json for JSON data.
        public let accept: String?
        /// The identifier of the Amazon Web Services account for the agent runtime resource.
        public let accountId: String?
        /// The Amazon Web Services Resource Name (ARN) of the agent runtime to invoke. The ARN uniquely identifies the agent runtime resource in Amazon Bedrock.
        public let agentRuntimeArn: String
        /// Additional context information for distributed tracing.
        public let baggage: String?
        /// The MIME type of the input data in the payload. This tells the agent runtime how to interpret the payload data. Common values include application/json for JSON data.
        public let contentType: String?
        /// The version of the MCP protocol being used.
        public let mcpProtocolVersion: String?
        /// The identifier of the MCP session.
        public let mcpSessionId: String?
        /// The input data to send to the agent runtime. The format of this data depends on the specific agent configuration and must match the specified content type. For most agents, this is a JSON object containing the user's request.
        public let payload: AWSHTTPBody
        /// The qualifier to use for the agent runtime. This can be a version number or an endpoint name that points to a specific version. If not specified, Amazon Bedrock uses the default version of the agent runtime.
        public let qualifier: String?
        /// The identifier of the runtime session.
        public let runtimeSessionId: String?
        /// The identifier of the runtime user.
        public let runtimeUserId: String?
        /// The trace identifier for request tracking.
        public let traceId: String?
        /// The parent trace information for distributed tracing.
        public let traceParent: String?
        /// The trace state information for distributed tracing.
        public let traceState: String?

        @inlinable
        public init(accept: String? = nil, accountId: String? = nil, agentRuntimeArn: String, baggage: String? = nil, contentType: String? = nil, mcpProtocolVersion: String? = nil, mcpSessionId: String? = nil, payload: AWSHTTPBody, qualifier: String? = nil, runtimeSessionId: String? = InvokeAgentRuntimeRequest.idempotencyToken(), runtimeUserId: String? = nil, traceId: String? = nil, traceParent: String? = nil, traceState: String? = nil) {
            self.accept = accept
            self.accountId = accountId
            self.agentRuntimeArn = agentRuntimeArn
            self.baggage = baggage
            self.contentType = contentType
            self.mcpProtocolVersion = mcpProtocolVersion
            self.mcpSessionId = mcpSessionId
            self.payload = payload
            self.qualifier = qualifier
            self.runtimeSessionId = runtimeSessionId
            self.runtimeUserId = runtimeUserId
            self.traceId = traceId
            self.traceParent = traceParent
            self.traceState = traceState
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.singleValueContainer()
            request.encodeHeader(self.accept, key: "Accept")
            request.encodeQuery(self.accountId, key: "accountId")
            request.encodePath(self.agentRuntimeArn, key: "agentRuntimeArn")
            request.encodeHeader(self.baggage, key: "baggage")
            request.encodeHeader(self.contentType, key: "Content-Type")
            request.encodeHeader(self.mcpProtocolVersion, key: "Mcp-Protocol-Version")
            request.encodeHeader(self.mcpSessionId, key: "Mcp-Session-Id")
            try container.encode(self.payload)
            request.encodeQuery(self.qualifier, key: "qualifier")
            request.encodeHeader(self.runtimeSessionId, key: "X-Amzn-Bedrock-AgentCore-Runtime-Session-Id")
            request.encodeHeader(self.runtimeUserId, key: "X-Amzn-Bedrock-AgentCore-Runtime-User-Id")
            request.encodeHeader(self.traceId, key: "X-Amzn-Trace-Id")
            request.encodeHeader(self.traceParent, key: "traceparent")
            request.encodeHeader(self.traceState, key: "tracestate")
        }

        public func validate(name: String) throws {
            try self.validate(self.accept, name: "accept", parent: name, max: 256)
            try self.validate(self.accept, name: "accept", parent: name, min: 1)
            try self.validate(self.contentType, name: "contentType", parent: name, max: 256)
            try self.validate(self.contentType, name: "contentType", parent: name, min: 1)
            try self.validate(self.mcpProtocolVersion, name: "mcpProtocolVersion", parent: name, max: 1024)
            try self.validate(self.mcpProtocolVersion, name: "mcpProtocolVersion", parent: name, min: 1)
            try self.validate(self.mcpSessionId, name: "mcpSessionId", parent: name, max: 1024)
            try self.validate(self.mcpSessionId, name: "mcpSessionId", parent: name, min: 1)
            try self.validate(self.payload, name: "payload", parent: name, max: 100000000)
            try self.validate(self.runtimeSessionId, name: "runtimeSessionId", parent: name, max: 256)
            try self.validate(self.runtimeSessionId, name: "runtimeSessionId", parent: name, min: 33)
            try self.validate(self.runtimeUserId, name: "runtimeUserId", parent: name, max: 1024)
            try self.validate(self.runtimeUserId, name: "runtimeUserId", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct InvokeAgentRuntimeResponse: AWSDecodableShape {
        public static let _options: AWSShapeOptions = [.rawPayload]
        /// Additional context information for distributed tracing.
        public let baggage: String?
        /// The MIME type of the response data. This indicates how to interpret the response data. Common values include application/json for JSON data.
        public let contentType: String
        /// The version of the MCP protocol being used.
        public let mcpProtocolVersion: String?
        /// The identifier of the MCP session.
        public let mcpSessionId: String?
        /// The response data from the agent runtime. The format of this data depends on the specific agent configuration and the requested accept type. For most agents, this is a JSON object containing the agent's response to the user's request.
        public let response: AWSHTTPBody
        /// The identifier of the runtime session.
        public let runtimeSessionId: String?
        /// The HTTP status code of the response. A status code of 200 indicates a successful operation. Other status codes indicate various error conditions.
        public let statusCode: Int?
        /// The trace identifier for request tracking.
        public let traceId: String?
        /// The parent trace information for distributed tracing.
        public let traceParent: String?
        /// The trace state information for distributed tracing.
        public let traceState: String?

        @inlinable
        public init(baggage: String? = nil, contentType: String, mcpProtocolVersion: String? = nil, mcpSessionId: String? = nil, response: AWSHTTPBody, runtimeSessionId: String? = nil, statusCode: Int? = nil, traceId: String? = nil, traceParent: String? = nil, traceState: String? = nil) {
            self.baggage = baggage
            self.contentType = contentType
            self.mcpProtocolVersion = mcpProtocolVersion
            self.mcpSessionId = mcpSessionId
            self.response = response
            self.runtimeSessionId = runtimeSessionId
            self.statusCode = statusCode
            self.traceId = traceId
            self.traceParent = traceParent
            self.traceState = traceState
        }

        public init(from decoder: Decoder) throws {
            let response = decoder.userInfo[.awsResponse]! as! ResponseDecodingContainer
            let container = try decoder.singleValueContainer()
            self.baggage = try response.decodeHeaderIfPresent(String.self, key: "baggage")
            self.contentType = try response.decodeHeader(String.self, key: "Content-Type")
            self.mcpProtocolVersion = try response.decodeHeaderIfPresent(String.self, key: "Mcp-Protocol-Version")
            self.mcpSessionId = try response.decodeHeaderIfPresent(String.self, key: "Mcp-Session-Id")
            self.response = try container.decode(AWSHTTPBody.self)
            self.runtimeSessionId = try response.decodeHeaderIfPresent(String.self, key: "X-Amzn-Bedrock-AgentCore-Runtime-Session-Id")
            self.statusCode = response.decodeStatus()
            self.traceId = try response.decodeHeaderIfPresent(String.self, key: "X-Amzn-Trace-Id")
            self.traceParent = try response.decodeHeaderIfPresent(String.self, key: "traceparent")
            self.traceState = try response.decodeHeaderIfPresent(String.self, key: "tracestate")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct InvokeCodeInterpreterRequest: AWSEncodableShape {
        /// The arguments for the code interpreter. This includes the code to execute and any additional parameters such as the programming language, whether to clear the execution context, and other execution options. The structure of this parameter depends on the specific code interpreter being used.
        public let arguments: ToolArguments?
        /// The unique identifier of the code interpreter associated with the session. This must match the identifier used when creating the session with StartCodeInterpreterSession.
        public let codeInterpreterIdentifier: String
        /// The name of the code interpreter to invoke.
        public let name: ToolName
        /// The unique identifier of the code interpreter session to use. This must be an active session created with StartCodeInterpreterSession. If the session has expired or been stopped, the request will fail.
        public let sessionId: String?
        /// The trace identifier for request tracking.
        public let traceId: String?
        /// The parent trace information for distributed tracing.
        public let traceParent: String?

        @inlinable
        public init(arguments: ToolArguments? = nil, codeInterpreterIdentifier: String, name: ToolName, sessionId: String? = nil, traceId: String? = nil, traceParent: String? = nil) {
            self.arguments = arguments
            self.codeInterpreterIdentifier = codeInterpreterIdentifier
            self.name = name
            self.sessionId = sessionId
            self.traceId = traceId
            self.traceParent = traceParent
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.arguments, forKey: .arguments)
            request.encodePath(self.codeInterpreterIdentifier, key: "codeInterpreterIdentifier")
            try container.encode(self.name, forKey: .name)
            request.encodeHeader(self.sessionId, key: "x-amzn-code-interpreter-session-id")
            request.encodeHeader(self.traceId, key: "X-Amzn-Trace-Id")
            request.encodeHeader(self.traceParent, key: "traceparent")
        }

        public func validate(name: String) throws {
            try self.arguments?.validate(name: "\(name).arguments")
            try self.validate(self.sessionId, name: "sessionId", parent: name, pattern: "^[0-9a-zA-Z]{1,40}$")
        }

        private enum CodingKeys: String, CodingKey {
            case arguments = "arguments"
            case name = "name"
        }
    }

    public struct InvokeCodeInterpreterResponse: AWSDecodableShape {
        public static let _options: AWSShapeOptions = [.rawPayload]
        /// The identifier of the code interpreter session.
        public let sessionId: String?
        /// The stream containing the results of the code execution. This includes output, errors, and execution status.
        public let stream: AWSEventStream<CodeInterpreterStreamOutput>

        @inlinable
        public init(sessionId: String? = nil, stream: AWSEventStream<CodeInterpreterStreamOutput>) {
            self.sessionId = sessionId
            self.stream = stream
        }

        public init(from decoder: Decoder) throws {
            let response = decoder.userInfo[.awsResponse]! as! ResponseDecodingContainer
            let container = try decoder.singleValueContainer()
            self.sessionId = try response.decodeHeaderIfPresent(String.self, key: "x-amzn-code-interpreter-session-id")
            self.stream = try container.decode(AWSEventStream<CodeInterpreterStreamOutput>.self)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListActorsInput: AWSEncodableShape {
        /// The maximum number of results to return in a single call. The default value is 20.
        public let maxResults: Int?
        /// The identifier of the AgentCore Memory resource for which to list actors.
        public let memoryId: String
        /// The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.
        public let nextToken: String?

        @inlinable
        public init(maxResults: Int? = nil, memoryId: String, nextToken: String? = nil) {
            self.maxResults = maxResults
            self.memoryId = memoryId
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.maxResults, forKey: .maxResults)
            request.encodePath(self.memoryId, key: "memoryId")
            try container.encodeIfPresent(self.nextToken, forKey: .nextToken)
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.memoryId, name: "memoryId", parent: name, min: 12)
            try self.validate(self.memoryId, name: "memoryId", parent: name, pattern: "^[a-zA-Z][a-zA-Z0-9-_]{0,99}-[a-zA-Z0-9]{10}$")
        }

        private enum CodingKeys: String, CodingKey {
            case maxResults = "maxResults"
            case nextToken = "nextToken"
        }
    }

    public struct ListActorsOutput: AWSDecodableShape {
        /// The list of actor summaries.
        public let actorSummaries: [ActorSummary]
        /// The token to use in a subsequent request to get the next set of results. This value is null when there are no more results to return.
        public let nextToken: String?

        @inlinable
        public init(actorSummaries: [ActorSummary], nextToken: String? = nil) {
            self.actorSummaries = actorSummaries
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case actorSummaries = "actorSummaries"
            case nextToken = "nextToken"
        }
    }

    public struct ListBrowserSessionsRequest: AWSEncodableShape {
        /// The unique identifier of the browser to list sessions for. If specified, only sessions for this browser are returned. If not specified, sessions for all browsers are returned.
        public let browserIdentifier: String
        /// The maximum number of results to return in a single call. The default value is 10. Valid values range from 1 to 100. To retrieve the remaining results, make another call with the returned nextToken value.
        public let maxResults: Int?
        /// The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results. If not specified, Amazon Bedrock returns the first page of results.
        public let nextToken: String?
        /// The status of the browser sessions to list. Valid values include ACTIVE, STOPPING, and STOPPED. If not specified, sessions with any status are returned.
        public let status: BrowserSessionStatus?

        @inlinable
        public init(browserIdentifier: String, maxResults: Int? = nil, nextToken: String? = nil, status: BrowserSessionStatus? = nil) {
            self.browserIdentifier = browserIdentifier
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.status = status
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.browserIdentifier, key: "browserIdentifier")
            try container.encodeIfPresent(self.maxResults, forKey: .maxResults)
            try container.encodeIfPresent(self.nextToken, forKey: .nextToken)
            try container.encodeIfPresent(self.status, forKey: .status)
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 2048)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^\\S*$")
        }

        private enum CodingKeys: String, CodingKey {
            case maxResults = "maxResults"
            case nextToken = "nextToken"
            case status = "status"
        }
    }

    public struct ListBrowserSessionsResponse: AWSDecodableShape {
        /// The list of browser sessions that match the specified criteria.
        public let items: [BrowserSessionSummary]
        /// The token to use in a subsequent ListBrowserSessions request to get the next set of results.
        public let nextToken: String?

        @inlinable
        public init(items: [BrowserSessionSummary], nextToken: String? = nil) {
            self.items = items
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case items = "items"
            case nextToken = "nextToken"
        }
    }

    public struct ListCodeInterpreterSessionsRequest: AWSEncodableShape {
        /// The unique identifier of the code interpreter to list sessions for. If specified, only sessions for this code interpreter are returned. If not specified, sessions for all code interpreters are returned.
        public let codeInterpreterIdentifier: String
        /// The maximum number of results to return in a single call. The default value is 10. Valid values range from 1 to 100. To retrieve the remaining results, make another call with the returned nextToken value.
        public let maxResults: Int?
        /// The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results. If not specified, Amazon Bedrock returns the first page of results.
        public let nextToken: String?
        /// The status of the code interpreter sessions to list. Valid values include ACTIVE, STOPPING, and STOPPED. If not specified, sessions with any status are returned.
        public let status: CodeInterpreterSessionStatus?

        @inlinable
        public init(codeInterpreterIdentifier: String, maxResults: Int? = nil, nextToken: String? = nil, status: CodeInterpreterSessionStatus? = nil) {
            self.codeInterpreterIdentifier = codeInterpreterIdentifier
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.status = status
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.codeInterpreterIdentifier, key: "codeInterpreterIdentifier")
            try container.encodeIfPresent(self.maxResults, forKey: .maxResults)
            try container.encodeIfPresent(self.nextToken, forKey: .nextToken)
            try container.encodeIfPresent(self.status, forKey: .status)
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 2048)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^\\S*$")
        }

        private enum CodingKeys: String, CodingKey {
            case maxResults = "maxResults"
            case nextToken = "nextToken"
            case status = "status"
        }
    }

    public struct ListCodeInterpreterSessionsResponse: AWSDecodableShape {
        /// The list of code interpreter sessions that match the specified criteria.
        public let items: [CodeInterpreterSessionSummary]
        /// The token to use in a subsequent ListCodeInterpreterSessions request to get the next set of results.
        public let nextToken: String?

        @inlinable
        public init(items: [CodeInterpreterSessionSummary], nextToken: String? = nil) {
            self.items = items
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case items = "items"
            case nextToken = "nextToken"
        }
    }

    public struct ListEventsInput: AWSEncodableShape {
        /// The identifier of the actor for which to list events.
        public let actorId: String
        /// Filter criteria to apply when listing events.
        public let filter: FilterInput?
        /// Specifies whether to include event payloads in the response. Set to true to include payloads, or false to exclude them.
        public let includePayloads: Bool?
        /// The maximum number of results to return in a single call. The default value is 20.
        public let maxResults: Int?
        /// The identifier of the AgentCore Memory resource for which to list events.
        public let memoryId: String
        /// The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.
        public let nextToken: String?
        /// The identifier of the session for which to list events.
        public let sessionId: String

        @inlinable
        public init(actorId: String, filter: FilterInput? = nil, includePayloads: Bool? = nil, maxResults: Int? = nil, memoryId: String, nextToken: String? = nil, sessionId: String) {
            self.actorId = actorId
            self.filter = filter
            self.includePayloads = includePayloads
            self.maxResults = maxResults
            self.memoryId = memoryId
            self.nextToken = nextToken
            self.sessionId = sessionId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.actorId, key: "actorId")
            try container.encodeIfPresent(self.filter, forKey: .filter)
            try container.encodeIfPresent(self.includePayloads, forKey: .includePayloads)
            try container.encodeIfPresent(self.maxResults, forKey: .maxResults)
            request.encodePath(self.memoryId, key: "memoryId")
            try container.encodeIfPresent(self.nextToken, forKey: .nextToken)
            request.encodePath(self.sessionId, key: "sessionId")
        }

        public func validate(name: String) throws {
            try self.validate(self.actorId, name: "actorId", parent: name, max: 255)
            try self.validate(self.actorId, name: "actorId", parent: name, min: 1)
            try self.validate(self.actorId, name: "actorId", parent: name, pattern: "^[a-zA-Z0-9][a-zA-Z0-9-_/]*(?::[a-zA-Z0-9-_/]+)*[a-zA-Z0-9-_/]*$")
            try self.filter?.validate(name: "\(name).filter")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.memoryId, name: "memoryId", parent: name, min: 12)
            try self.validate(self.memoryId, name: "memoryId", parent: name, pattern: "^[a-zA-Z][a-zA-Z0-9-_]{0,99}-[a-zA-Z0-9]{10}$")
            try self.validate(self.sessionId, name: "sessionId", parent: name, max: 100)
            try self.validate(self.sessionId, name: "sessionId", parent: name, min: 1)
            try self.validate(self.sessionId, name: "sessionId", parent: name, pattern: "^[a-zA-Z0-9][a-zA-Z0-9-_]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case filter = "filter"
            case includePayloads = "includePayloads"
            case maxResults = "maxResults"
            case nextToken = "nextToken"
        }
    }

    public struct ListEventsOutput: AWSDecodableShape {
        /// The list of events that match the specified criteria.
        public let events: [Event]
        /// The token to use in a subsequent request to get the next set of results. This value is null when there are no more results to return.
        public let nextToken: String?

        @inlinable
        public init(events: [Event], nextToken: String? = nil) {
            self.events = events
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case events = "events"
            case nextToken = "nextToken"
        }
    }

    public struct ListMemoryExtractionJobsInput: AWSEncodableShape {
        /// Filter criteria to apply when listing extraction jobs.
        public let filter: ExtractionJobFilterInput?
        /// The maximum number of results to return in a single call. The default value is 20.
        public let maxResults: Int?
        /// The unique identifier of the memory to list extraction jobs for.
        public let memoryId: String
        /// The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.
        public let nextToken: String?

        @inlinable
        public init(filter: ExtractionJobFilterInput? = nil, maxResults: Int? = nil, memoryId: String, nextToken: String? = nil) {
            self.filter = filter
            self.maxResults = maxResults
            self.memoryId = memoryId
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.filter, forKey: .filter)
            try container.encodeIfPresent(self.maxResults, forKey: .maxResults)
            request.encodePath(self.memoryId, key: "memoryId")
            try container.encodeIfPresent(self.nextToken, forKey: .nextToken)
        }

        public func validate(name: String) throws {
            try self.validate(self.memoryId, name: "memoryId", parent: name, min: 12)
            try self.validate(self.memoryId, name: "memoryId", parent: name, pattern: "^[a-zA-Z][a-zA-Z0-9-_]{0,99}-[a-zA-Z0-9]{10}$")
        }

        private enum CodingKeys: String, CodingKey {
            case filter = "filter"
            case maxResults = "maxResults"
            case nextToken = "nextToken"
        }
    }

    public struct ListMemoryExtractionJobsOutput: AWSDecodableShape {
        /// List of extraction job metadata matching the specified criteria.
        public let jobs: [ExtractionJobMetadata]
        /// Token to retrieve the next page of results, if available.
        public let nextToken: String?

        @inlinable
        public init(jobs: [ExtractionJobMetadata], nextToken: String? = nil) {
            self.jobs = jobs
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case jobs = "jobs"
            case nextToken = "nextToken"
        }
    }

    public struct ListMemoryRecordsInput: AWSEncodableShape {
        /// The maximum number of results to return in a single call. The default value is 20.
        public let maxResults: Int?
        /// The identifier of the AgentCore Memory resource for which to list memory records.
        public let memoryId: String
        /// The memory strategy identifier to filter memory records by. If specified, only memory records with this strategy ID are returned.
        public let memoryStrategyId: String?
        /// The namespace to filter memory records by. If specified, only memory records in this namespace are returned.
        public let namespace: String
        /// The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.
        public let nextToken: String?

        @inlinable
        public init(maxResults: Int? = nil, memoryId: String, memoryStrategyId: String? = nil, namespace: String, nextToken: String? = nil) {
            self.maxResults = maxResults
            self.memoryId = memoryId
            self.memoryStrategyId = memoryStrategyId
            self.namespace = namespace
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.maxResults, forKey: .maxResults)
            request.encodePath(self.memoryId, key: "memoryId")
            try container.encodeIfPresent(self.memoryStrategyId, forKey: .memoryStrategyId)
            try container.encode(self.namespace, forKey: .namespace)
            try container.encodeIfPresent(self.nextToken, forKey: .nextToken)
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.memoryId, name: "memoryId", parent: name, min: 12)
            try self.validate(self.memoryId, name: "memoryId", parent: name, pattern: "^[a-zA-Z][a-zA-Z0-9-_]{0,99}-[a-zA-Z0-9]{10}$")
            try self.validate(self.memoryStrategyId, name: "memoryStrategyId", parent: name, max: 100)
            try self.validate(self.memoryStrategyId, name: "memoryStrategyId", parent: name, min: 1)
            try self.validate(self.memoryStrategyId, name: "memoryStrategyId", parent: name, pattern: "^[a-zA-Z0-9][a-zA-Z0-9-_]*$")
            try self.validate(self.namespace, name: "namespace", parent: name, max: 1024)
            try self.validate(self.namespace, name: "namespace", parent: name, min: 1)
            try self.validate(self.namespace, name: "namespace", parent: name, pattern: "^[a-zA-Z0-9/*][a-zA-Z0-9-_/*]*(?::[a-zA-Z0-9-_/*]+)*[a-zA-Z0-9-_/*]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case maxResults = "maxResults"
            case memoryStrategyId = "memoryStrategyId"
            case namespace = "namespace"
            case nextToken = "nextToken"
        }
    }

    public struct ListMemoryRecordsOutput: AWSDecodableShape {
        /// The list of memory record summaries that match the specified criteria.
        public let memoryRecordSummaries: [MemoryRecordSummary]
        /// The token to use in a subsequent request to get the next set of results. This value is null when there are no more results to return.
        public let nextToken: String?

        @inlinable
        public init(memoryRecordSummaries: [MemoryRecordSummary], nextToken: String? = nil) {
            self.memoryRecordSummaries = memoryRecordSummaries
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case memoryRecordSummaries = "memoryRecordSummaries"
            case nextToken = "nextToken"
        }
    }

    public struct ListSessionsInput: AWSEncodableShape {
        /// The identifier of the actor for which to list sessions.
        public let actorId: String
        /// The maximum number of results to return in a single call. The default value is 20.
        public let maxResults: Int?
        /// The identifier of the AgentCore Memory resource for which to list sessions.
        public let memoryId: String
        /// The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.
        public let nextToken: String?

        @inlinable
        public init(actorId: String, maxResults: Int? = nil, memoryId: String, nextToken: String? = nil) {
            self.actorId = actorId
            self.maxResults = maxResults
            self.memoryId = memoryId
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.actorId, key: "actorId")
            try container.encodeIfPresent(self.maxResults, forKey: .maxResults)
            request.encodePath(self.memoryId, key: "memoryId")
            try container.encodeIfPresent(self.nextToken, forKey: .nextToken)
        }

        public func validate(name: String) throws {
            try self.validate(self.actorId, name: "actorId", parent: name, max: 255)
            try self.validate(self.actorId, name: "actorId", parent: name, min: 1)
            try self.validate(self.actorId, name: "actorId", parent: name, pattern: "^[a-zA-Z0-9][a-zA-Z0-9-_/]*(?::[a-zA-Z0-9-_/]+)*[a-zA-Z0-9-_/]*$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.memoryId, name: "memoryId", parent: name, min: 12)
            try self.validate(self.memoryId, name: "memoryId", parent: name, pattern: "^[a-zA-Z][a-zA-Z0-9-_]{0,99}-[a-zA-Z0-9]{10}$")
        }

        private enum CodingKeys: String, CodingKey {
            case maxResults = "maxResults"
            case nextToken = "nextToken"
        }
    }

    public struct ListSessionsOutput: AWSDecodableShape {
        /// The token to use in a subsequent request to get the next set of results. This value is null when there are no more results to return.
        public let nextToken: String?
        /// The list of session summaries that match the specified criteria.
        public let sessionSummaries: [SessionSummary]

        @inlinable
        public init(nextToken: String? = nil, sessionSummaries: [SessionSummary]) {
            self.nextToken = nextToken
            self.sessionSummaries = sessionSummaries
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "nextToken"
            case sessionSummaries = "sessionSummaries"
        }
    }

    public struct LiveViewStream: AWSDecodableShape {
        /// The endpoint URL for the live view stream. This URL is used to establish a connection to receive visual updates from the browser session.
        public let streamEndpoint: String?

        @inlinable
        public init(streamEndpoint: String? = nil) {
            self.streamEndpoint = streamEndpoint
        }

        private enum CodingKeys: String, CodingKey {
            case streamEndpoint = "streamEndpoint"
        }
    }

    public struct MemoryMetadataFilterExpression: AWSEncodableShape {
        public let left: LeftExpression
        /// The relationship between the metadata key and value to match when applying the metadata filter.
        public let `operator`: OperatorType
        public let right: RightExpression?

        @inlinable
        public init(left: LeftExpression, operator: OperatorType, right: RightExpression? = nil) {
            self.left = left
            self.`operator` = `operator`
            self.right = right
        }

        public func validate(name: String) throws {
            try self.left.validate(name: "\(name).left")
        }

        private enum CodingKeys: String, CodingKey {
            case left = "left"
            case `operator` = "operator"
            case right = "right"
        }
    }

    public struct MemoryRecord: AWSDecodableShape {
        /// The content of the memory record.
        public let content: MemoryContent
        /// The timestamp when the memory record was created.
        public let createdAt: Date
        /// The unique identifier of the memory record.
        public let memoryRecordId: String
        /// The identifier of the memory strategy associated with this record.
        public let memoryStrategyId: String
        /// A map of metadata key-value pairs associated with a memory record.
        public let metadata: [String: MetadataValue]?
        /// The namespaces associated with this memory record. Namespaces help organize and categorize memory records.
        public let namespaces: [String]

        @inlinable
        public init(content: MemoryContent, createdAt: Date, memoryRecordId: String, memoryStrategyId: String, metadata: [String: MetadataValue]? = nil, namespaces: [String]) {
            self.content = content
            self.createdAt = createdAt
            self.memoryRecordId = memoryRecordId
            self.memoryStrategyId = memoryStrategyId
            self.metadata = metadata
            self.namespaces = namespaces
        }

        private enum CodingKeys: String, CodingKey {
            case content = "content"
            case createdAt = "createdAt"
            case memoryRecordId = "memoryRecordId"
            case memoryStrategyId = "memoryStrategyId"
            case metadata = "metadata"
            case namespaces = "namespaces"
        }
    }

    public struct MemoryRecordCreateInput: AWSEncodableShape {
        /// The content to be stored within the memory record.
        public let content: MemoryContent
        /// The ID of the memory strategy that defines how this memory record is grouped.
        public let memoryStrategyId: String?
        /// A list of namespace identifiers that categorize or group the memory record.
        public let namespaces: [String]
        /// A client-provided identifier for tracking this specific record creation request.
        public let requestIdentifier: String
        /// Time at which the memory record was created.
        public let timestamp: Date

        @inlinable
        public init(content: MemoryContent, memoryStrategyId: String? = nil, namespaces: [String], requestIdentifier: String, timestamp: Date) {
            self.content = content
            self.memoryStrategyId = memoryStrategyId
            self.namespaces = namespaces
            self.requestIdentifier = requestIdentifier
            self.timestamp = timestamp
        }

        public func validate(name: String) throws {
            try self.validate(self.memoryStrategyId, name: "memoryStrategyId", parent: name, max: 100)
            try self.validate(self.memoryStrategyId, name: "memoryStrategyId", parent: name, min: 1)
            try self.validate(self.memoryStrategyId, name: "memoryStrategyId", parent: name, pattern: "^[a-zA-Z0-9][a-zA-Z0-9-_]*$")
            try self.namespaces.forEach {
                try validate($0, name: "namespaces[]", parent: name, max: 1024)
                try validate($0, name: "namespaces[]", parent: name, min: 1)
                try validate($0, name: "namespaces[]", parent: name, pattern: "^[a-zA-Z0-9/*][a-zA-Z0-9-_/*]*(?::[a-zA-Z0-9-_/*]+)*[a-zA-Z0-9-_/*]*$")
            }
            try self.validate(self.namespaces, name: "namespaces", parent: name, max: 1)
            try self.validate(self.requestIdentifier, name: "requestIdentifier", parent: name, max: 80)
            try self.validate(self.requestIdentifier, name: "requestIdentifier", parent: name, min: 1)
            try self.validate(self.requestIdentifier, name: "requestIdentifier", parent: name, pattern: "^[a-zA-Z0-9_-]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case content = "content"
            case memoryStrategyId = "memoryStrategyId"
            case namespaces = "namespaces"
            case requestIdentifier = "requestIdentifier"
            case timestamp = "timestamp"
        }
    }

    public struct MemoryRecordDeleteInput: AWSEncodableShape {
        /// The unique ID of the memory record to be deleted.
        public let memoryRecordId: String

        @inlinable
        public init(memoryRecordId: String) {
            self.memoryRecordId = memoryRecordId
        }

        public func validate(name: String) throws {
            try self.validate(self.memoryRecordId, name: "memoryRecordId", parent: name, max: 50)
            try self.validate(self.memoryRecordId, name: "memoryRecordId", parent: name, min: 40)
            try self.validate(self.memoryRecordId, name: "memoryRecordId", parent: name, pattern: "^mem-[a-zA-Z0-9-_]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case memoryRecordId = "memoryRecordId"
        }
    }

    public struct MemoryRecordOutput: AWSDecodableShape {
        /// The error code returned when the memory record operation fails.
        public let errorCode: Int?
        /// A human-readable error message describing why the memory record operation failed.
        public let errorMessage: String?
        /// The unique ID associated to the memory record.
        public let memoryRecordId: String
        /// The client-provided identifier that was used to track this record operation.
        public let requestIdentifier: String?
        /// The status of the memory record operation (e.g., SUCCEEDED, FAILED).
        public let status: MemoryRecordStatus

        @inlinable
        public init(errorCode: Int? = nil, errorMessage: String? = nil, memoryRecordId: String, requestIdentifier: String? = nil, status: MemoryRecordStatus) {
            self.errorCode = errorCode
            self.errorMessage = errorMessage
            self.memoryRecordId = memoryRecordId
            self.requestIdentifier = requestIdentifier
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case errorCode = "errorCode"
            case errorMessage = "errorMessage"
            case memoryRecordId = "memoryRecordId"
            case requestIdentifier = "requestIdentifier"
            case status = "status"
        }
    }

    public struct MemoryRecordSummary: AWSDecodableShape {
        /// The content of the memory record.
        public let content: MemoryContent
        /// The timestamp when the memory record was created.
        public let createdAt: Date
        /// The unique identifier of the memory record.
        public let memoryRecordId: String
        /// The identifier of the memory strategy associated with this record.
        public let memoryStrategyId: String
        /// A map of metadata key-value pairs associated with a memory record.
        public let metadata: [String: MetadataValue]?
        /// The namespaces associated with this memory record.
        public let namespaces: [String]
        /// The relevance score of the memory record when returned as part of a search result. Higher values indicate greater relevance to the search query.
        public let score: Double?

        @inlinable
        public init(content: MemoryContent, createdAt: Date, memoryRecordId: String, memoryStrategyId: String, metadata: [String: MetadataValue]? = nil, namespaces: [String], score: Double? = nil) {
            self.content = content
            self.createdAt = createdAt
            self.memoryRecordId = memoryRecordId
            self.memoryStrategyId = memoryStrategyId
            self.metadata = metadata
            self.namespaces = namespaces
            self.score = score
        }

        private enum CodingKeys: String, CodingKey {
            case content = "content"
            case createdAt = "createdAt"
            case memoryRecordId = "memoryRecordId"
            case memoryStrategyId = "memoryStrategyId"
            case metadata = "metadata"
            case namespaces = "namespaces"
            case score = "score"
        }
    }

    public struct MemoryRecordUpdateInput: AWSEncodableShape {
        /// The content to be stored within the memory record.
        public let content: MemoryContent?
        /// The unique ID of the memory record to be updated.
        public let memoryRecordId: String
        /// The updated ID of the memory strategy that defines how this memory record is grouped.
        public let memoryStrategyId: String?
        /// The updated list of namespace identifiers for categorizing the memory record.
        public let namespaces: [String]?
        /// Time at which the memory record was updated
        public let timestamp: Date

        @inlinable
        public init(content: MemoryContent? = nil, memoryRecordId: String, memoryStrategyId: String? = nil, namespaces: [String]? = nil, timestamp: Date) {
            self.content = content
            self.memoryRecordId = memoryRecordId
            self.memoryStrategyId = memoryStrategyId
            self.namespaces = namespaces
            self.timestamp = timestamp
        }

        public func validate(name: String) throws {
            try self.validate(self.memoryRecordId, name: "memoryRecordId", parent: name, max: 50)
            try self.validate(self.memoryRecordId, name: "memoryRecordId", parent: name, min: 40)
            try self.validate(self.memoryRecordId, name: "memoryRecordId", parent: name, pattern: "^mem-[a-zA-Z0-9-_]*$")
            try self.validate(self.memoryStrategyId, name: "memoryStrategyId", parent: name, max: 100)
            try self.validate(self.memoryStrategyId, name: "memoryStrategyId", parent: name, min: 1)
            try self.validate(self.memoryStrategyId, name: "memoryStrategyId", parent: name, pattern: "^[a-zA-Z0-9][a-zA-Z0-9-_]*$")
            try self.namespaces?.forEach {
                try validate($0, name: "namespaces[]", parent: name, max: 1024)
                try validate($0, name: "namespaces[]", parent: name, min: 1)
                try validate($0, name: "namespaces[]", parent: name, pattern: "^[a-zA-Z0-9/*][a-zA-Z0-9-_/*]*(?::[a-zA-Z0-9-_/*]+)*[a-zA-Z0-9-_/*]*$")
            }
            try self.validate(self.namespaces, name: "namespaces", parent: name, max: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case content = "content"
            case memoryRecordId = "memoryRecordId"
            case memoryStrategyId = "memoryStrategyId"
            case namespaces = "namespaces"
            case timestamp = "timestamp"
        }
    }

    public struct MessageMetadata: AWSDecodableShape {
        /// The identifier of the event associated with this message.
        public let eventId: String
        /// The position of this message within that eventâ€™s ordered list of messages.
        public let messageIndex: Int

        @inlinable
        public init(eventId: String, messageIndex: Int) {
            self.eventId = eventId
            self.messageIndex = messageIndex
        }

        private enum CodingKeys: String, CodingKey {
            case eventId = "eventId"
            case messageIndex = "messageIndex"
        }
    }

    public struct ResourceContent: AWSDecodableShape {
        /// The binary resource content.
        public let blob: AWSBase64Data?
        /// The MIME type of the resource content.
        public let mimeType: String?
        /// The text resource content.
        public let text: String?
        /// The type of resource content.
        public let type: ResourceContentType
        /// The URI of the resource content.
        public let uri: String?

        @inlinable
        public init(blob: AWSBase64Data? = nil, mimeType: String? = nil, text: String? = nil, type: ResourceContentType, uri: String? = nil) {
            self.blob = blob
            self.mimeType = mimeType
            self.text = text
            self.type = type
            self.uri = uri
        }

        private enum CodingKeys: String, CodingKey {
            case blob = "blob"
            case mimeType = "mimeType"
            case text = "text"
            case type = "type"
            case uri = "uri"
        }
    }

    public struct ResourceNotFoundException: AWSDecodableShape {
        public let message: String?

        @inlinable
        public init(message: String? = nil) {
            self.message = message
        }

        private enum CodingKeys: String, CodingKey {
            case message = "message"
        }
    }

    public struct RetrieveMemoryRecordsInput: AWSEncodableShape {
        /// The maximum number of results to return in a single call. The default value is 20.
        public let maxResults: Int?
        /// The identifier of the AgentCore Memory resource from which to retrieve memory records.
        public let memoryId: String
        /// The namespace to filter memory records by.
        public let namespace: String
        /// The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.
        public let nextToken: String?
        /// The search criteria to use for finding relevant memory records. This includes the search query, memory strategy ID, and other search parameters.
        public let searchCriteria: SearchCriteria

        @inlinable
        public init(maxResults: Int? = nil, memoryId: String, namespace: String, nextToken: String? = nil, searchCriteria: SearchCriteria) {
            self.maxResults = maxResults
            self.memoryId = memoryId
            self.namespace = namespace
            self.nextToken = nextToken
            self.searchCriteria = searchCriteria
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.maxResults, forKey: .maxResults)
            request.encodePath(self.memoryId, key: "memoryId")
            try container.encode(self.namespace, forKey: .namespace)
            try container.encodeIfPresent(self.nextToken, forKey: .nextToken)
            try container.encode(self.searchCriteria, forKey: .searchCriteria)
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.memoryId, name: "memoryId", parent: name, min: 12)
            try self.validate(self.memoryId, name: "memoryId", parent: name, pattern: "^[a-zA-Z][a-zA-Z0-9-_]{0,99}-[a-zA-Z0-9]{10}$")
            try self.validate(self.namespace, name: "namespace", parent: name, max: 1024)
            try self.validate(self.namespace, name: "namespace", parent: name, min: 1)
            try self.validate(self.namespace, name: "namespace", parent: name, pattern: "^[a-zA-Z0-9/*][a-zA-Z0-9-_/*]*(?::[a-zA-Z0-9-_/*]+)*[a-zA-Z0-9-_/*]*$")
            try self.searchCriteria.validate(name: "\(name).searchCriteria")
        }

        private enum CodingKeys: String, CodingKey {
            case maxResults = "maxResults"
            case namespace = "namespace"
            case nextToken = "nextToken"
            case searchCriteria = "searchCriteria"
        }
    }

    public struct RetrieveMemoryRecordsOutput: AWSDecodableShape {
        /// The list of memory record summaries that match the search criteria, ordered by relevance.
        public let memoryRecordSummaries: [MemoryRecordSummary]
        /// The token to use in a subsequent request to get the next set of results. This value is null when there are no more results to return.
        public let nextToken: String?

        @inlinable
        public init(memoryRecordSummaries: [MemoryRecordSummary], nextToken: String? = nil) {
            self.memoryRecordSummaries = memoryRecordSummaries
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case memoryRecordSummaries = "memoryRecordSummaries"
            case nextToken = "nextToken"
        }
    }

    public struct SearchCriteria: AWSEncodableShape {
        /// The memory strategy identifier to filter memory records by.
        public let memoryStrategyId: String?
        /// Filters to apply to metadata associated with a memory.
        public let metadataFilters: [MemoryMetadataFilterExpression]?
        /// The search query to use for finding relevant memory records.
        public let searchQuery: String
        /// The maximum number of top-scoring memory records to return. This value is used for semantic search ranking.
        public let topK: Int?

        @inlinable
        public init(memoryStrategyId: String? = nil, metadataFilters: [MemoryMetadataFilterExpression]? = nil, searchQuery: String, topK: Int? = nil) {
            self.memoryStrategyId = memoryStrategyId
            self.metadataFilters = metadataFilters
            self.searchQuery = searchQuery
            self.topK = topK
        }

        public func validate(name: String) throws {
            try self.validate(self.memoryStrategyId, name: "memoryStrategyId", parent: name, max: 100)
            try self.validate(self.memoryStrategyId, name: "memoryStrategyId", parent: name, min: 1)
            try self.validate(self.memoryStrategyId, name: "memoryStrategyId", parent: name, pattern: "^[a-zA-Z0-9][a-zA-Z0-9-_]*$")
            try self.metadataFilters?.forEach {
                try $0.validate(name: "\(name).metadataFilters[]")
            }
            try self.validate(self.metadataFilters, name: "metadataFilters", parent: name, max: 1)
            try self.validate(self.metadataFilters, name: "metadataFilters", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case memoryStrategyId = "memoryStrategyId"
            case metadataFilters = "metadataFilters"
            case searchQuery = "searchQuery"
            case topK = "topK"
        }
    }

    public struct ServiceQuotaExceededException: AWSDecodableShape {
        public let message: String?

        @inlinable
        public init(message: String? = nil) {
            self.message = message
        }

        private enum CodingKeys: String, CodingKey {
            case message = "message"
        }
    }

    public struct SessionSummary: AWSDecodableShape {
        /// The identifier of the actor associated with the session.
        public let actorId: String
        /// The timestamp when the session was created.
        public let createdAt: Date
        /// The unique identifier of the session.
        public let sessionId: String

        @inlinable
        public init(actorId: String, createdAt: Date, sessionId: String) {
            self.actorId = actorId
            self.createdAt = createdAt
            self.sessionId = sessionId
        }

        private enum CodingKeys: String, CodingKey {
            case actorId = "actorId"
            case createdAt = "createdAt"
            case sessionId = "sessionId"
        }
    }

    public struct SpanContext: AWSDecodableShape {
        ///  The unique identifier of the session containing this span. Sessions represent complete conversation flows and are detected using configurable SessionTimeoutMinutes (default 15 minutes).
        public let sessionId: String
        ///  The unique identifier of the specific span being referenced. Spans represent individual operations like tool calls, model invocations, or other discrete actions within the agent's execution.
        public let spanId: String?
        ///  The unique identifier of the trace containing this span. Traces represent individual request-response interactions within a session and group related spans together.
        public let traceId: String?

        @inlinable
        public init(sessionId: String, spanId: String? = nil, traceId: String? = nil) {
            self.sessionId = sessionId
            self.spanId = spanId
            self.traceId = traceId
        }

        private enum CodingKeys: String, CodingKey {
            case sessionId = "sessionId"
            case spanId = "spanId"
            case traceId = "traceId"
        }
    }

    public struct StartBrowserSessionRequest: AWSEncodableShape {
        /// The unique identifier of the browser to use for this session. This identifier specifies which browser environment to initialize for the session.
        public let browserIdentifier: String
        /// A unique, case-sensitive identifier to ensure that the API request completes no more than one time. If this token matches a previous request, Amazon Bedrock ignores the request, but does not return an error. This parameter helps prevent the creation of duplicate sessions if there are temporary network issues.
        public let clientToken: String?
        /// The name of the browser session. This name helps you identify and manage the session. The name does not need to be unique.
        public let name: String?
        /// The time in seconds after which the session automatically terminates if there is no activity. The default value is 3600 seconds (1 hour). The minimum allowed value is 60 seconds, and the maximum allowed value is 28800 seconds (8 hours).
        public let sessionTimeoutSeconds: Int?
        /// The trace identifier for request tracking.
        public let traceId: String?
        /// The parent trace information for distributed tracing.
        public let traceParent: String?
        /// The dimensions of the browser viewport for this session. This determines the visible area of the web content and affects how web pages are rendered. If not specified, Amazon Bedrock uses a default viewport size.
        public let viewPort: ViewPort?

        @inlinable
        public init(browserIdentifier: String, clientToken: String? = StartBrowserSessionRequest.idempotencyToken(), name: String? = nil, sessionTimeoutSeconds: Int? = nil, traceId: String? = nil, traceParent: String? = nil, viewPort: ViewPort? = nil) {
            self.browserIdentifier = browserIdentifier
            self.clientToken = clientToken
            self.name = name
            self.sessionTimeoutSeconds = sessionTimeoutSeconds
            self.traceId = traceId
            self.traceParent = traceParent
            self.viewPort = viewPort
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.browserIdentifier, key: "browserIdentifier")
            try container.encodeIfPresent(self.clientToken, forKey: .clientToken)
            try container.encodeIfPresent(self.name, forKey: .name)
            try container.encodeIfPresent(self.sessionTimeoutSeconds, forKey: .sessionTimeoutSeconds)
            request.encodeHeader(self.traceId, key: "X-Amzn-Trace-Id")
            request.encodeHeader(self.traceParent, key: "traceparent")
            try container.encodeIfPresent(self.viewPort, forKey: .viewPort)
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 256)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 33)
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "^[a-zA-Z0-9](-*[a-zA-Z0-9]){0,256}$")
            try self.validate(self.name, name: "name", parent: name, max: 100)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.sessionTimeoutSeconds, name: "sessionTimeoutSeconds", parent: name, max: 28800)
            try self.validate(self.sessionTimeoutSeconds, name: "sessionTimeoutSeconds", parent: name, min: 1)
            try self.viewPort?.validate(name: "\(name).viewPort")
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "clientToken"
            case name = "name"
            case sessionTimeoutSeconds = "sessionTimeoutSeconds"
            case viewPort = "viewPort"
        }
    }

    public struct StartBrowserSessionResponse: AWSDecodableShape {
        /// The identifier of the browser.
        public let browserIdentifier: String
        /// The timestamp when the browser session was created.
        @CustomCoding<ISO8601DateCoder>
        public var createdAt: Date
        /// The unique identifier of the created browser session.
        public let sessionId: String
        /// The streams associated with this browser session. These include the automation stream and live view stream.
        public let streams: BrowserSessionStream?

        @inlinable
        public init(browserIdentifier: String, createdAt: Date, sessionId: String, streams: BrowserSessionStream? = nil) {
            self.browserIdentifier = browserIdentifier
            self.createdAt = createdAt
            self.sessionId = sessionId
            self.streams = streams
        }

        private enum CodingKeys: String, CodingKey {
            case browserIdentifier = "browserIdentifier"
            case createdAt = "createdAt"
            case sessionId = "sessionId"
            case streams = "streams"
        }
    }

    public struct StartCodeInterpreterSessionRequest: AWSEncodableShape {
        /// A unique, case-sensitive identifier to ensure that the API request completes no more than one time. If this token matches a previous request, Amazon Bedrock ignores the request, but does not return an error. This parameter helps prevent the creation of duplicate sessions if there are temporary network issues.
        public let clientToken: String?
        /// The unique identifier of the code interpreter to use for this session. This identifier specifies which code interpreter environment to initialize for the session.
        public let codeInterpreterIdentifier: String
        /// The name of the code interpreter session. This name helps you identify and manage the session. The name does not need to be unique.
        public let name: String?
        /// The time in seconds after which the session automatically terminates if there is no activity. The default value is 900 seconds (15 minutes). The minimum allowed value is 60 seconds, and the maximum allowed value is 28800 seconds (8 hours).
        public let sessionTimeoutSeconds: Int?
        /// The trace identifier for request tracking.
        public let traceId: String?
        /// The parent trace information for distributed tracing.
        public let traceParent: String?

        @inlinable
        public init(clientToken: String? = StartCodeInterpreterSessionRequest.idempotencyToken(), codeInterpreterIdentifier: String, name: String? = nil, sessionTimeoutSeconds: Int? = nil, traceId: String? = nil, traceParent: String? = nil) {
            self.clientToken = clientToken
            self.codeInterpreterIdentifier = codeInterpreterIdentifier
            self.name = name
            self.sessionTimeoutSeconds = sessionTimeoutSeconds
            self.traceId = traceId
            self.traceParent = traceParent
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.clientToken, forKey: .clientToken)
            request.encodePath(self.codeInterpreterIdentifier, key: "codeInterpreterIdentifier")
            try container.encodeIfPresent(self.name, forKey: .name)
            try container.encodeIfPresent(self.sessionTimeoutSeconds, forKey: .sessionTimeoutSeconds)
            request.encodeHeader(self.traceId, key: "X-Amzn-Trace-Id")
            request.encodeHeader(self.traceParent, key: "traceparent")
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 256)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 33)
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "^[a-zA-Z0-9](-*[a-zA-Z0-9]){0,256}$")
            try self.validate(self.name, name: "name", parent: name, max: 100)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.sessionTimeoutSeconds, name: "sessionTimeoutSeconds", parent: name, max: 28800)
            try self.validate(self.sessionTimeoutSeconds, name: "sessionTimeoutSeconds", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "clientToken"
            case name = "name"
            case sessionTimeoutSeconds = "sessionTimeoutSeconds"
        }
    }

    public struct StartCodeInterpreterSessionResponse: AWSDecodableShape {
        /// The identifier of the code interpreter.
        public let codeInterpreterIdentifier: String
        /// The time at which the code interpreter session was created.
        @CustomCoding<ISO8601DateCoder>
        public var createdAt: Date
        /// The unique identifier of the created code interpreter session.
        public let sessionId: String

        @inlinable
        public init(codeInterpreterIdentifier: String, createdAt: Date, sessionId: String) {
            self.codeInterpreterIdentifier = codeInterpreterIdentifier
            self.createdAt = createdAt
            self.sessionId = sessionId
        }

        private enum CodingKeys: String, CodingKey {
            case codeInterpreterIdentifier = "codeInterpreterIdentifier"
            case createdAt = "createdAt"
            case sessionId = "sessionId"
        }
    }

    public struct StartMemoryExtractionJobInput: AWSEncodableShape {
        /// A unique, case-sensitive identifier to ensure idempotent processing of the request.
        public let clientToken: String?
        /// Extraction job to start in this operation.
        public let extractionJob: ExtractionJob
        /// The unique identifier of the memory for which to start extraction jobs.
        public let memoryId: String

        @inlinable
        public init(clientToken: String? = StartMemoryExtractionJobInput.idempotencyToken(), extractionJob: ExtractionJob, memoryId: String) {
            self.clientToken = clientToken
            self.extractionJob = extractionJob
            self.memoryId = memoryId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.clientToken, forKey: .clientToken)
            try container.encode(self.extractionJob, forKey: .extractionJob)
            request.encodePath(self.memoryId, key: "memoryId")
        }

        public func validate(name: String) throws {
            try self.validate(self.memoryId, name: "memoryId", parent: name, min: 12)
            try self.validate(self.memoryId, name: "memoryId", parent: name, pattern: "^[a-zA-Z][a-zA-Z0-9-_]{0,99}-[a-zA-Z0-9]{10}$")
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "clientToken"
            case extractionJob = "extractionJob"
        }
    }

    public struct StartMemoryExtractionJobOutput: AWSDecodableShape {
        /// Extraction Job ID that was attempted to start.
        public let jobId: String

        @inlinable
        public init(jobId: String) {
            self.jobId = jobId
        }

        private enum CodingKeys: String, CodingKey {
            case jobId = "jobId"
        }
    }

    public struct StopBrowserSessionRequest: AWSEncodableShape {
        /// The unique identifier of the browser associated with the session.
        public let browserIdentifier: String
        /// A unique, case-sensitive identifier to ensure that the API request completes no more than one time. If this token matches a previous request, Amazon Bedrock ignores the request, but does not return an error.
        public let clientToken: String?
        /// The unique identifier of the browser session to stop.
        public let sessionId: String
        /// The trace identifier for request tracking.
        public let traceId: String?
        /// The parent trace information for distributed tracing.
        public let traceParent: String?

        @inlinable
        public init(browserIdentifier: String, clientToken: String? = StopBrowserSessionRequest.idempotencyToken(), sessionId: String, traceId: String? = nil, traceParent: String? = nil) {
            self.browserIdentifier = browserIdentifier
            self.clientToken = clientToken
            self.sessionId = sessionId
            self.traceId = traceId
            self.traceParent = traceParent
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.browserIdentifier, key: "browserIdentifier")
            try container.encodeIfPresent(self.clientToken, forKey: .clientToken)
            request.encodeQuery(self.sessionId, key: "sessionId")
            request.encodeHeader(self.traceId, key: "X-Amzn-Trace-Id")
            request.encodeHeader(self.traceParent, key: "traceparent")
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 256)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 33)
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "^[a-zA-Z0-9](-*[a-zA-Z0-9]){0,256}$")
            try self.validate(self.sessionId, name: "sessionId", parent: name, pattern: "^[0-9a-zA-Z]{1,40}$")
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "clientToken"
        }
    }

    public struct StopBrowserSessionResponse: AWSDecodableShape {
        /// The identifier of the browser.
        public let browserIdentifier: String
        /// The time at which the browser session was last updated.
        @CustomCoding<ISO8601DateCoder>
        public var lastUpdatedAt: Date
        /// The identifier of the browser session.
        public let sessionId: String

        @inlinable
        public init(browserIdentifier: String, lastUpdatedAt: Date, sessionId: String) {
            self.browserIdentifier = browserIdentifier
            self.lastUpdatedAt = lastUpdatedAt
            self.sessionId = sessionId
        }

        private enum CodingKeys: String, CodingKey {
            case browserIdentifier = "browserIdentifier"
            case lastUpdatedAt = "lastUpdatedAt"
            case sessionId = "sessionId"
        }
    }

    public struct StopCodeInterpreterSessionRequest: AWSEncodableShape {
        /// A unique, case-sensitive identifier to ensure that the API request completes no more than one time. If this token matches a previous request, Amazon Bedrock ignores the request, but does not return an error.
        public let clientToken: String?
        /// The unique identifier of the code interpreter associated with the session.
        public let codeInterpreterIdentifier: String
        /// The unique identifier of the code interpreter session to stop.
        public let sessionId: String
        /// The trace identifier for request tracking.
        public let traceId: String?
        /// The parent trace information for distributed tracing.
        public let traceParent: String?

        @inlinable
        public init(clientToken: String? = StopCodeInterpreterSessionRequest.idempotencyToken(), codeInterpreterIdentifier: String, sessionId: String, traceId: String? = nil, traceParent: String? = nil) {
            self.clientToken = clientToken
            self.codeInterpreterIdentifier = codeInterpreterIdentifier
            self.sessionId = sessionId
            self.traceId = traceId
            self.traceParent = traceParent
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.clientToken, forKey: .clientToken)
            request.encodePath(self.codeInterpreterIdentifier, key: "codeInterpreterIdentifier")
            request.encodeQuery(self.sessionId, key: "sessionId")
            request.encodeHeader(self.traceId, key: "X-Amzn-Trace-Id")
            request.encodeHeader(self.traceParent, key: "traceparent")
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 256)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 33)
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "^[a-zA-Z0-9](-*[a-zA-Z0-9]){0,256}$")
            try self.validate(self.sessionId, name: "sessionId", parent: name, pattern: "^[0-9a-zA-Z]{1,40}$")
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "clientToken"
        }
    }

    public struct StopCodeInterpreterSessionResponse: AWSDecodableShape {
        /// The identifier of the code interpreter.
        public let codeInterpreterIdentifier: String
        /// The timestamp when the code interpreter session was last updated.
        @CustomCoding<ISO8601DateCoder>
        public var lastUpdatedAt: Date
        /// The identifier of the code interpreter session.
        public let sessionId: String

        @inlinable
        public init(codeInterpreterIdentifier: String, lastUpdatedAt: Date, sessionId: String) {
            self.codeInterpreterIdentifier = codeInterpreterIdentifier
            self.lastUpdatedAt = lastUpdatedAt
            self.sessionId = sessionId
        }

        private enum CodingKeys: String, CodingKey {
            case codeInterpreterIdentifier = "codeInterpreterIdentifier"
            case lastUpdatedAt = "lastUpdatedAt"
            case sessionId = "sessionId"
        }
    }

    public struct StopRuntimeSessionRequest: AWSEncodableShape {
        /// The ARN of the agent that contains the session that you want to stop.
        public let agentRuntimeArn: String
        /// Idempotent token used to identify the request. If you use the same token with multiple requests, the same response is returned. Use ClientToken to prevent the same request from being processed more than once.
        public let clientToken: String?
        /// Optional qualifier to specify an agent alias, such as prodcode&gt; or dev. If you don't provide a value, the DEFAULT alias is used.
        public let qualifier: String?
        /// The ID of the session that you want to stop.
        public let runtimeSessionId: String

        @inlinable
        public init(agentRuntimeArn: String, clientToken: String? = StopRuntimeSessionRequest.idempotencyToken(), qualifier: String? = nil, runtimeSessionId: String) {
            self.agentRuntimeArn = agentRuntimeArn
            self.clientToken = clientToken
            self.qualifier = qualifier
            self.runtimeSessionId = runtimeSessionId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.agentRuntimeArn, key: "agentRuntimeArn")
            try container.encodeIfPresent(self.clientToken, forKey: .clientToken)
            request.encodeQuery(self.qualifier, key: "qualifier")
            request.encodeHeader(self.runtimeSessionId, key: "X-Amzn-Bedrock-AgentCore-Runtime-Session-Id")
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 256)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 33)
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "^[a-zA-Z0-9](-*[a-zA-Z0-9]){0,256}$")
            try self.validate(self.runtimeSessionId, name: "runtimeSessionId", parent: name, max: 256)
            try self.validate(self.runtimeSessionId, name: "runtimeSessionId", parent: name, min: 33)
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "clientToken"
        }
    }

    public struct StopRuntimeSessionResponse: AWSDecodableShape {
        /// The ID of the session that you requested to stop.
        public let runtimeSessionId: String?
        /// The status code of the request to stop the session.
        public let statusCode: Int?

        @inlinable
        public init(runtimeSessionId: String? = nil, statusCode: Int? = nil) {
            self.runtimeSessionId = runtimeSessionId
            self.statusCode = statusCode
        }

        public init(from decoder: Decoder) throws {
            let response = decoder.userInfo[.awsResponse]! as! ResponseDecodingContainer
            self.runtimeSessionId = try response.decodeHeaderIfPresent(String.self, key: "X-Amzn-Bedrock-AgentCore-Runtime-Session-Id")
            self.statusCode = response.decodeStatus()
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ThrottlingException: AWSDecodableShape {
        public let message: String?

        @inlinable
        public init(message: String? = nil) {
            self.message = message
        }

        private enum CodingKeys: String, CodingKey {
            case message = "message"
        }
    }

    public struct TokenUsage: AWSDecodableShape {
        ///  The number of tokens consumed for input processing during the evaluation. Includes tokens from the evaluation prompt, agent traces, and any additional context provided to the evaluator model.
        public let inputTokens: Int?
        ///  The number of tokens generated by the evaluator model in its response. Includes tokens for the score, explanation, and any additional output produced during the evaluation process.
        public let outputTokens: Int?
        ///  The total number of tokens consumed during the evaluation, calculated as the sum of input and output tokens. Used for cost calculation and rate limiting within the service limits.
        public let totalTokens: Int?

        @inlinable
        public init(inputTokens: Int? = nil, outputTokens: Int? = nil, totalTokens: Int? = nil) {
            self.inputTokens = inputTokens
            self.outputTokens = outputTokens
            self.totalTokens = totalTokens
        }

        private enum CodingKeys: String, CodingKey {
            case inputTokens = "inputTokens"
            case outputTokens = "outputTokens"
            case totalTokens = "totalTokens"
        }
    }

    public struct ToolArguments: AWSEncodableShape {
        /// Whether to clear the context for the tool.
        public let clearContext: Bool?
        /// The code to execute in a code interpreter session. This is the source code in the specified programming language that will be executed by the code interpreter.
        public let code: String?
        /// The command to execute with the tool.
        public let command: String?
        /// The content for the tool operation.
        public let content: [InputContentBlock]?
        /// The directory path for the tool operation.
        public let directoryPath: String?
        /// The programming language of the code to execute. This tells the code interpreter which language runtime to use for execution. Common values include 'python', 'javascript', and 'r'.
        public let language: ProgrammingLanguage?
        /// The path for the tool operation.
        public let path: String?
        /// The paths for the tool operation.
        public let paths: [String]?
        /// The identifier of the task for the tool operation.
        public let taskId: String?

        @inlinable
        public init(clearContext: Bool? = nil, code: String? = nil, command: String? = nil, content: [InputContentBlock]? = nil, directoryPath: String? = nil, language: ProgrammingLanguage? = nil, path: String? = nil, paths: [String]? = nil, taskId: String? = nil) {
            self.clearContext = clearContext
            self.code = code
            self.command = command
            self.content = content
            self.directoryPath = directoryPath
            self.language = language
            self.path = path
            self.paths = paths
            self.taskId = taskId
        }

        public func validate(name: String) throws {
            try self.validate(self.code, name: "code", parent: name, max: 100000000)
            try self.validate(self.command, name: "command", parent: name, max: 100000000)
            try self.content?.forEach {
                try $0.validate(name: "\(name).content[]")
            }
            try self.validate(self.directoryPath, name: "directoryPath", parent: name, max: 100000000)
            try self.validate(self.path, name: "path", parent: name, max: 100000000)
            try self.paths?.forEach {
                try validate($0, name: "paths[]", parent: name, max: 100000000)
            }
            try self.validate(self.taskId, name: "taskId", parent: name, max: 100000000)
        }

        private enum CodingKeys: String, CodingKey {
            case clearContext = "clearContext"
            case code = "code"
            case command = "command"
            case content = "content"
            case directoryPath = "directoryPath"
            case language = "language"
            case path = "path"
            case paths = "paths"
            case taskId = "taskId"
        }
    }

    public struct ToolResultStructuredContent: AWSDecodableShape {
        /// The execution time of the tool operation in milliseconds.
        public let executionTime: Double?
        /// The exit code from the tool execution.
        public let exitCode: Int?
        /// The standard error output from the tool execution.
        public let stderr: String?
        /// The standard output from the tool execution.
        public let stdout: String?
        /// The identifier of the task that produced the result.
        public let taskId: String?
        /// The status of the task that produced the result.
        public let taskStatus: TaskStatus?

        @inlinable
        public init(executionTime: Double? = nil, exitCode: Int? = nil, stderr: String? = nil, stdout: String? = nil, taskId: String? = nil, taskStatus: TaskStatus? = nil) {
            self.executionTime = executionTime
            self.exitCode = exitCode
            self.stderr = stderr
            self.stdout = stdout
            self.taskId = taskId
            self.taskStatus = taskStatus
        }

        private enum CodingKeys: String, CodingKey {
            case executionTime = "executionTime"
            case exitCode = "exitCode"
            case stderr = "stderr"
            case stdout = "stdout"
            case taskId = "taskId"
            case taskStatus = "taskStatus"
        }
    }

    public struct UpdateBrowserStreamRequest: AWSEncodableShape {
        /// The identifier of the browser.
        public let browserIdentifier: String
        /// A unique, case-sensitive identifier to ensure that the operation completes no more than one time. If this token matches a previous request, Amazon Bedrock ignores the request, but does not return an error.
        public let clientToken: String?
        /// The identifier of the browser session.
        public let sessionId: String
        /// The update to apply to the browser stream.
        public let streamUpdate: StreamUpdate

        @inlinable
        public init(browserIdentifier: String, clientToken: String? = UpdateBrowserStreamRequest.idempotencyToken(), sessionId: String, streamUpdate: StreamUpdate) {
            self.browserIdentifier = browserIdentifier
            self.clientToken = clientToken
            self.sessionId = sessionId
            self.streamUpdate = streamUpdate
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.browserIdentifier, key: "browserIdentifier")
            try container.encodeIfPresent(self.clientToken, forKey: .clientToken)
            request.encodeQuery(self.sessionId, key: "sessionId")
            try container.encode(self.streamUpdate, forKey: .streamUpdate)
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 256)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 33)
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "^[a-zA-Z0-9](-*[a-zA-Z0-9]){0,256}$")
            try self.validate(self.sessionId, name: "sessionId", parent: name, pattern: "^[0-9a-zA-Z]{1,40}$")
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "clientToken"
            case streamUpdate = "streamUpdate"
        }
    }

    public struct UpdateBrowserStreamResponse: AWSDecodableShape {
        /// The identifier of the browser.
        public let browserIdentifier: String
        /// The identifier of the browser session.
        public let sessionId: String
        public let streams: BrowserSessionStream
        /// The time at which the browser stream was updated.
        @CustomCoding<ISO8601DateCoder>
        public var updatedAt: Date

        @inlinable
        public init(browserIdentifier: String, sessionId: String, streams: BrowserSessionStream, updatedAt: Date) {
            self.browserIdentifier = browserIdentifier
            self.sessionId = sessionId
            self.streams = streams
            self.updatedAt = updatedAt
        }

        private enum CodingKeys: String, CodingKey {
            case browserIdentifier = "browserIdentifier"
            case sessionId = "sessionId"
            case streams = "streams"
            case updatedAt = "updatedAt"
        }
    }

    public struct ValidationException: AWSErrorShape {
        public let fieldList: [ValidationExceptionField]?
        public let message: String
        public let reason: ValidationExceptionReason

        @inlinable
        public init(fieldList: [ValidationExceptionField]? = nil, message: String, reason: ValidationExceptionReason) {
            self.fieldList = fieldList
            self.message = message
            self.reason = reason
        }

        private enum CodingKeys: String, CodingKey {
            case fieldList = "fieldList"
            case message = "message"
            case reason = "reason"
        }
    }

    public struct ValidationExceptionField: AWSDecodableShape {
        /// A message describing why this field failed validation.
        public let message: String
        /// The name of the field.
        public let name: String

        @inlinable
        public init(message: String, name: String) {
            self.message = message
            self.name = name
        }

        private enum CodingKeys: String, CodingKey {
            case message = "message"
            case name = "name"
        }
    }

    public struct ViewPort: AWSEncodableShape & AWSDecodableShape {
        /// The height of the viewport in pixels. This value determines the vertical dimension of the visible area. Valid values range from 600 to 1080 pixels.
        public let height: Int
        /// The width of the viewport in pixels. This value determines the horizontal dimension of the visible area. Valid values range from 800 to 1920 pixels.
        public let width: Int

        @inlinable
        public init(height: Int, width: Int) {
            self.height = height
            self.width = width
        }

        public func validate(name: String) throws {
            try self.validate(self.height, name: "height", parent: name, max: 2160)
            try self.validate(self.height, name: "height", parent: name, min: 240)
            try self.validate(self.width, name: "width", parent: name, max: 3840)
            try self.validate(self.width, name: "width", parent: name, min: 320)
        }

        private enum CodingKeys: String, CodingKey {
            case height = "height"
            case width = "width"
        }
    }

    public struct Content: AWSEncodableShape & AWSDecodableShape {
        /// The text content of the memory item.
        public let text: String?

        @inlinable
        public init(text: String? = nil) {
            self.text = text
        }

        private enum CodingKeys: String, CodingKey {
            case text = "text"
        }
    }

    public struct Context: AWSDecodableShape {
        ///  The span context information that uniquely identifies the trace and span being evaluated, including session ID, trace ID, and span ID for precise targeting within the agent's execution flow.
        public let spanContext: SpanContext?

        @inlinable
        public init(spanContext: SpanContext? = nil) {
            self.spanContext = spanContext
        }

        private enum CodingKeys: String, CodingKey {
            case spanContext = "spanContext"
        }
    }

    public struct EvaluationInput: AWSEncodableShape {
        ///  The collection of spans representing agent execution traces within a session. Each span contains detailed information about tool calls, model interactions, and other agent activities that can be evaluated for quality and performance.
        public let sessionSpans: [AWSDocument]?

        @inlinable
        public init(sessionSpans: [AWSDocument]? = nil) {
            self.sessionSpans = sessionSpans
        }

        public func validate(name: String) throws {
            try self.validate(self.sessionSpans, name: "sessionSpans", parent: name, max: 1000)
            try self.validate(self.sessionSpans, name: "sessionSpans", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case sessionSpans = "sessionSpans"
        }
    }

    public struct ExtractionJobMessages: AWSDecodableShape {
        /// The list of messages that compose this extraction job.
        public let messagesList: [MessageMetadata]?

        @inlinable
        public init(messagesList: [MessageMetadata]? = nil) {
            self.messagesList = messagesList
        }

        private enum CodingKeys: String, CodingKey {
            case messagesList = "messagesList"
        }
    }

    public struct LeftExpression: AWSEncodableShape {
        /// Key associated with the metadata in an event.
        public let metadataKey: String?

        @inlinable
        public init(metadataKey: String? = nil) {
            self.metadataKey = metadataKey
        }

        public func validate(name: String) throws {
            try self.validate(self.metadataKey, name: "metadataKey", parent: name, max: 128)
            try self.validate(self.metadataKey, name: "metadataKey", parent: name, min: 1)
            try self.validate(self.metadataKey, name: "metadataKey", parent: name, pattern: "^[a-zA-Z0-9\\s._:/=+@-]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case metadataKey = "metadataKey"
        }
    }

    public struct MemoryContent: AWSEncodableShape & AWSDecodableShape {
        /// The text content of the memory record.
        public let text: String?

        @inlinable
        public init(text: String? = nil) {
            self.text = text
        }

        private enum CodingKeys: String, CodingKey {
            case text = "text"
        }
    }

    public struct MetadataValue: AWSEncodableShape & AWSDecodableShape {
        /// Value associated with the eventMetadata key.
        public let stringValue: String?

        @inlinable
        public init(stringValue: String? = nil) {
            self.stringValue = stringValue
        }

        private enum CodingKeys: String, CodingKey {
            case stringValue = "stringValue"
        }
    }

    public struct RightExpression: AWSEncodableShape {
        /// Value associated with the key in eventMetadata.
        public let metadataValue: MetadataValue?

        @inlinable
        public init(metadataValue: MetadataValue? = nil) {
            self.metadataValue = metadataValue
        }

        private enum CodingKeys: String, CodingKey {
            case metadataValue = "metadataValue"
        }
    }

    public struct StreamUpdate: AWSEncodableShape {
        /// The update to an automation stream.
        public let automationStreamUpdate: AutomationStreamUpdate?

        @inlinable
        public init(automationStreamUpdate: AutomationStreamUpdate? = nil) {
            self.automationStreamUpdate = automationStreamUpdate
        }

        private enum CodingKeys: String, CodingKey {
            case automationStreamUpdate = "automationStreamUpdate"
        }
    }
}

// MARK: - Errors

/// Error enum for BedrockAgentCore
public struct BedrockAgentCoreErrorType: AWSErrorType {
    enum Code: String {
        case accessDeniedException = "AccessDeniedException"
        case conflictException = "ConflictException"
        case duplicateIdException = "DuplicateIdException"
        case internalServerException = "InternalServerException"
        case invalidInputException = "InvalidInputException"
        case resourceNotFoundException = "ResourceNotFoundException"
        case runtimeClientError = "RuntimeClientError"
        case serviceException = "ServiceException"
        case serviceQuotaExceededException = "ServiceQuotaExceededException"
        case throttledException = "ThrottledException"
        case throttlingException = "ThrottlingException"
        case unauthorizedException = "UnauthorizedException"
        case validationException = "ValidationException"
    }

    private let error: Code
    public let context: AWSErrorContext?

    /// initialize BedrockAgentCore
    public init?(errorCode: String, context: AWSErrorContext) {
        guard let error = Code(rawValue: errorCode) else { return nil }
        self.error = error
        self.context = context
    }

    internal init(_ error: Code) {
        self.error = error
        self.context = nil
    }

    /// return error code string
    public var errorCode: String { self.error.rawValue }

    /// The exception that occurs when you do not have sufficient permissions to perform an action. Verify that your IAM policy includes the necessary permissions for the operation you are trying to perform.
    public static var accessDeniedException: Self { .init(.accessDeniedException) }
    /// The exception that occurs when the request conflicts with the current state of the resource. This can happen when trying to modify a resource that is currently being modified by another request, or when trying to create a resource that already exists.
    public static var conflictException: Self { .init(.conflictException) }
    ///  An exception thrown when attempting to create a resource with an identifier that already exists.
    public static var duplicateIdException: Self { .init(.duplicateIdException) }
    /// The exception that occurs when the service encounters an unexpected internal error. This is a temporary condition that will resolve itself with retries. We recommend implementing exponential backoff retry logic in your application.
    public static var internalServerException: Self { .init(.internalServerException) }
    /// The input fails to satisfy the constraints specified by AgentCore. Check your input values and try again.
    public static var invalidInputException: Self { .init(.invalidInputException) }
    /// The exception that occurs when the specified resource does not exist. This can happen when using an invalid identifier or when trying to access a resource that has been deleted.
    public static var resourceNotFoundException: Self { .init(.resourceNotFoundException) }
    /// The exception that occurs when there is an error in the runtime client. This can happen due to network issues, invalid configuration, or other client-side problems. Check the error message for specific details about the error.
    public static var runtimeClientError: Self { .init(.runtimeClientError) }
    /// The service encountered an internal error. Try your request again later.
    public static var serviceException: Self { .init(.serviceException) }
    /// The exception that occurs when the request would cause a service quota to be exceeded. Review your service quotas and either reduce your request rate or request a quota increase.
    public static var serviceQuotaExceededException: Self { .init(.serviceQuotaExceededException) }
    /// The request was denied due to request throttling. Reduce the frequency of requests and try again.
    public static var throttledException: Self { .init(.throttledException) }
    /// The exception that occurs when the request was denied due to request throttling. This happens when you exceed the allowed request rate for an operation. Reduce the frequency of requests or implement exponential backoff retry logic in your application.
    public static var throttlingException: Self { .init(.throttlingException) }
    /// This exception is thrown when the JWT bearer token is invalid or not found for OAuth bearer token based access
    public static var unauthorizedException: Self { .init(.unauthorizedException) }
    /// The exception that occurs when the input fails to satisfy the constraints specified by the service. Check the error message for details about which input parameter is invalid and correct your request.
    public static var validationException: Self { .init(.validationException) }
}

extension BedrockAgentCoreErrorType: AWSServiceErrorType {
    public static let errorCodeMap: [String: AWSErrorShape.Type] = [
        "ValidationException": BedrockAgentCore.ValidationException.self
    ]
}

extension BedrockAgentCoreErrorType: Equatable {
    public static func == (lhs: BedrockAgentCoreErrorType, rhs: BedrockAgentCoreErrorType) -> Bool {
        lhs.error == rhs.error
    }
}

extension BedrockAgentCoreErrorType: CustomStringConvertible {
    public var description: String {
        return "\(self.error.rawValue): \(self.message ?? "")"
    }
}
