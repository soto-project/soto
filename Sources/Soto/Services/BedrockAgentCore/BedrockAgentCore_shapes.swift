//===----------------------------------------------------------------------===//
//
// This source file is part of the Soto for AWS open source project
//
// Copyright (c) 2017-2024 the Soto project authors
// Licensed under Apache License v2.0
//
// See LICENSE.txt for license information
// See CONTRIBUTORS.txt for the list of Soto project authors
//
// SPDX-License-Identifier: Apache-2.0
//
//===----------------------------------------------------------------------===//

// THIS FILE IS AUTOMATICALLY GENERATED by https://github.com/soto-project/soto-codegenerator.
// DO NOT EDIT.

#if canImport(FoundationEssentials)
import FoundationEssentials
#else
import Foundation
#endif
@_spi(SotoInternal) import SotoCore

extension BedrockAgentCore {
    // MARK: Enums

    public enum AutomationStreamStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case disabled = "DISABLED"
        case enabled = "ENABLED"
        public var description: String { return self.rawValue }
    }

    public enum BrowserSessionStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case ready = "READY"
        case terminated = "TERMINATED"
        public var description: String { return self.rawValue }
    }

    public enum CodeInterpreterSessionStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case ready = "READY"
        case terminated = "TERMINATED"
        public var description: String { return self.rawValue }
    }

    public enum ContentBlockType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case embeddedResource = "resource"
        case image = "image"
        case resourceLink = "resource_link"
        case text = "text"
        public var description: String { return self.rawValue }
    }

    public enum Oauth2FlowType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case m2m = "M2M"
        case userFederation = "USER_FEDERATION"
        public var description: String { return self.rawValue }
    }

    public enum ProgrammingLanguage: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case javascript = "javascript"
        case python = "python"
        case typescript = "typescript"
        public var description: String { return self.rawValue }
    }

    public enum ResourceContentType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case blob = "blob"
        case text = "text"
        public var description: String { return self.rawValue }
    }

    public enum Role: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case assistant = "ASSISTANT"
        case other = "OTHER"
        case tool = "TOOL"
        case user = "USER"
        public var description: String { return self.rawValue }
    }

    public enum TaskStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case canceled = "canceled"
        case completed = "completed"
        case failed = "failed"
        case submitted = "submitted"
        case working = "working"
        public var description: String { return self.rawValue }
    }

    public enum ToolName: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case executeCode = "executeCode"
        case executeCommand = "executeCommand"
        case getTask = "getTask"
        case listFiles = "listFiles"
        case readFiles = "readFiles"
        case removeFiles = "removeFiles"
        case startCommandExecution = "startCommandExecution"
        case stopTask = "stopTask"
        case writeFiles = "writeFiles"
        public var description: String { return self.rawValue }
    }

    public enum ValidationExceptionReason: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case cannotParse = "CannotParse"
        case fieldValidationFailed = "FieldValidationFailed"
        case idempotentParameterMismatchException = "IdempotentParameterMismatchException"
        case resourceConflict = "ResourceConflict"
        case rootEventInOtherSession = "EventInOtherSession"
        public var description: String { return self.rawValue }
    }

    public enum CodeInterpreterStreamOutput: AWSDecodableShape, Sendable {
        case accessDeniedException(AccessDeniedException)
        case conflictException(ConflictException)
        case internalServerException(InternalServerException)
        case resourceNotFoundException(ResourceNotFoundException)
        case result(CodeInterpreterResult)
        case serviceQuotaExceededException(ServiceQuotaExceededException)
        case throttlingException(ThrottlingException)
        case validationException(ValidationException)

        public init(from decoder: Decoder) throws {
            let container = try decoder.container(keyedBy: CodingKeys.self)
            guard container.allKeys.count == 1, let key = container.allKeys.first else {
                let context = DecodingError.Context(
                    codingPath: container.codingPath,
                    debugDescription: "Expected exactly one key, but got \(container.allKeys.count)"
                )
                throw DecodingError.dataCorrupted(context)
            }
            switch key {
            case .accessDeniedException:
                let value = try container.decode(AccessDeniedException.self, forKey: .accessDeniedException)
                self = .accessDeniedException(value)
            case .conflictException:
                let value = try container.decode(ConflictException.self, forKey: .conflictException)
                self = .conflictException(value)
            case .internalServerException:
                let value = try container.decode(InternalServerException.self, forKey: .internalServerException)
                self = .internalServerException(value)
            case .resourceNotFoundException:
                let value = try container.decode(ResourceNotFoundException.self, forKey: .resourceNotFoundException)
                self = .resourceNotFoundException(value)
            case .result:
                let value = try container.decode(CodeInterpreterResult.self, forKey: .result)
                self = .result(value)
            case .serviceQuotaExceededException:
                let value = try container.decode(ServiceQuotaExceededException.self, forKey: .serviceQuotaExceededException)
                self = .serviceQuotaExceededException(value)
            case .throttlingException:
                let value = try container.decode(ThrottlingException.self, forKey: .throttlingException)
                self = .throttlingException(value)
            case .validationException:
                let value = try container.decode(ValidationException.self, forKey: .validationException)
                self = .validationException(value)
            }
        }

        private enum CodingKeys: String, CodingKey {
            case accessDeniedException = "accessDeniedException"
            case conflictException = "conflictException"
            case internalServerException = "internalServerException"
            case resourceNotFoundException = "resourceNotFoundException"
            case result = "result"
            case serviceQuotaExceededException = "serviceQuotaExceededException"
            case throttlingException = "throttlingException"
            case validationException = "validationException"
        }
    }

    public enum PayloadType: AWSEncodableShape & AWSDecodableShape, Sendable {
        /// The binary content of the payload.
        case blob(AWSDocument)
        /// The conversational content of the payload.
        case conversational(Conversational)

        public init(from decoder: Decoder) throws {
            let container = try decoder.container(keyedBy: CodingKeys.self)
            guard container.allKeys.count == 1, let key = container.allKeys.first else {
                let context = DecodingError.Context(
                    codingPath: container.codingPath,
                    debugDescription: "Expected exactly one key, but got \(container.allKeys.count)"
                )
                throw DecodingError.dataCorrupted(context)
            }
            switch key {
            case .blob:
                let value = try container.decode(AWSDocument.self, forKey: .blob)
                self = .blob(value)
            case .conversational:
                let value = try container.decode(Conversational.self, forKey: .conversational)
                self = .conversational(value)
            }
        }

        public func encode(to encoder: Encoder) throws {
            var container = encoder.container(keyedBy: CodingKeys.self)
            switch self {
            case .blob(let value):
                try container.encode(value, forKey: .blob)
            case .conversational(let value):
                try container.encode(value, forKey: .conversational)
            }
        }

        private enum CodingKeys: String, CodingKey {
            case blob = "blob"
            case conversational = "conversational"
        }
    }

    // MARK: Shapes

    public struct AccessDeniedException: AWSDecodableShape {
        public let message: String?

        @inlinable
        public init(message: String? = nil) {
            self.message = message
        }

        private enum CodingKeys: String, CodingKey {
            case message = "message"
        }
    }

    public struct ActorSummary: AWSDecodableShape {
        /// The unique identifier of the actor.
        public let actorId: String

        @inlinable
        public init(actorId: String) {
            self.actorId = actorId
        }

        private enum CodingKeys: String, CodingKey {
            case actorId = "actorId"
        }
    }

    public struct AutomationStream: AWSDecodableShape {
        /// The endpoint URL for the automation stream. This URL is used to establish a WebSocket connection to the stream for sending commands and receiving responses.
        public let streamEndpoint: String
        /// The current status of the automation stream. This indicates whether the stream is available for use. Possible values include ACTIVE, CONNECTING, and DISCONNECTED.
        public let streamStatus: AutomationStreamStatus

        @inlinable
        public init(streamEndpoint: String, streamStatus: AutomationStreamStatus) {
            self.streamEndpoint = streamEndpoint
            self.streamStatus = streamStatus
        }

        private enum CodingKeys: String, CodingKey {
            case streamEndpoint = "streamEndpoint"
            case streamStatus = "streamStatus"
        }
    }

    public struct AutomationStreamUpdate: AWSEncodableShape {
        /// The status of the automation stream.
        public let streamStatus: AutomationStreamStatus?

        @inlinable
        public init(streamStatus: AutomationStreamStatus? = nil) {
            self.streamStatus = streamStatus
        }

        private enum CodingKeys: String, CodingKey {
            case streamStatus = "streamStatus"
        }
    }

    public struct Branch: AWSEncodableShape & AWSDecodableShape {
        /// The name of the branch.
        public let name: String
        /// The identifier of the root event for this branch.
        public let rootEventId: String?

        @inlinable
        public init(name: String, rootEventId: String? = nil) {
            self.name = name
            self.rootEventId = rootEventId
        }

        public func validate(name: String) throws {
            try self.validate(self.name, name: "name", parent: name, max: 100)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[a-zA-Z0-9][a-zA-Z0-9-_]*$")
            try self.validate(self.rootEventId, name: "rootEventId", parent: name, pattern: "^[0-9]+#[a-fA-F0-9]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case name = "name"
            case rootEventId = "rootEventId"
        }
    }

    public struct BranchFilter: AWSEncodableShape {
        /// Specifies whether to include parent branches in the results. Set to true to include parent branches, or false to exclude them.
        public let includeParentBranches: Bool?
        /// The name of the branch to filter by.
        public let name: String

        @inlinable
        public init(includeParentBranches: Bool? = nil, name: String) {
            self.includeParentBranches = includeParentBranches
            self.name = name
        }

        public func validate(name: String) throws {
            try self.validate(self.name, name: "name", parent: name, max: 100)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[a-zA-Z0-9][a-zA-Z0-9-_]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case includeParentBranches = "includeParentBranches"
            case name = "name"
        }
    }

    public struct BrowserSessionStream: AWSDecodableShape {
        /// The stream that enables programmatic control of the browser. This stream allows agents to perform actions such as navigating to URLs, clicking elements, and filling forms.
        public let automationStream: AutomationStream
        /// The stream that provides a visual representation of the browser content. This stream allows agents to observe the current state of the browser, including rendered web pages and visual elements.
        public let liveViewStream: LiveViewStream?

        @inlinable
        public init(automationStream: AutomationStream, liveViewStream: LiveViewStream? = nil) {
            self.automationStream = automationStream
            self.liveViewStream = liveViewStream
        }

        private enum CodingKeys: String, CodingKey {
            case automationStream = "automationStream"
            case liveViewStream = "liveViewStream"
        }
    }

    public struct BrowserSessionSummary: AWSDecodableShape {
        /// The unique identifier of the browser associated with the session. This identifier specifies which browser environment is used for the session.
        public let browserIdentifier: String
        /// The timestamp when the browser session was created. This value is in ISO 8601 format.
        @CustomCoding<ISO8601DateCoder>
        public var createdAt: Date
        /// The timestamp when the browser session was last updated. This value is in ISO 8601 format.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var lastUpdatedAt: Date?
        /// The name of the browser session. This name helps identify and manage the session.
        public let name: String?
        /// The unique identifier of the browser session. This identifier is used in operations that interact with the session.
        public let sessionId: String
        /// The current status of the browser session. Possible values include ACTIVE, STOPPING, and STOPPED.
        public let status: BrowserSessionStatus

        @inlinable
        public init(browserIdentifier: String, createdAt: Date, lastUpdatedAt: Date? = nil, name: String? = nil, sessionId: String, status: BrowserSessionStatus) {
            self.browserIdentifier = browserIdentifier
            self.createdAt = createdAt
            self.lastUpdatedAt = lastUpdatedAt
            self.name = name
            self.sessionId = sessionId
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case browserIdentifier = "browserIdentifier"
            case createdAt = "createdAt"
            case lastUpdatedAt = "lastUpdatedAt"
            case name = "name"
            case sessionId = "sessionId"
            case status = "status"
        }
    }

    public struct CodeInterpreterResult: AWSDecodableShape {
        /// The textual content of the execution result. This includes standard output from the code execution, such as print statements, console output, and text representations of results.
        public let content: [ContentBlock]
        /// Indicates whether the result represents an error. If true, the content contains error messages or exception information. If false, the content contains successful execution results.
        public let isError: Bool?
        /// The structured content of the execution result. This includes additional metadata about the execution, such as execution time, memory usage, and structured representations of output data. The format depends on the specific code interpreter and execution context.
        public let structuredContent: ToolResultStructuredContent?

        @inlinable
        public init(content: [ContentBlock], isError: Bool? = nil, structuredContent: ToolResultStructuredContent? = nil) {
            self.content = content
            self.isError = isError
            self.structuredContent = structuredContent
        }

        private enum CodingKeys: String, CodingKey {
            case content = "content"
            case isError = "isError"
            case structuredContent = "structuredContent"
        }
    }

    public struct CodeInterpreterSessionSummary: AWSDecodableShape {
        /// The unique identifier of the code interpreter associated with the session. This identifier specifies which code interpreter environment is used for the session.
        public let codeInterpreterIdentifier: String
        /// The timestamp when the code interpreter session was created. This value is in ISO 8601 format.
        @CustomCoding<ISO8601DateCoder>
        public var createdAt: Date
        /// The timestamp when the code interpreter session was last updated. This value is in ISO 8601 format.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var lastUpdatedAt: Date?
        /// The name of the code interpreter session. This name helps identify and manage the session.
        public let name: String?
        /// The unique identifier of the code interpreter session. This identifier is used in operations that interact with the session.
        public let sessionId: String
        /// The current status of the code interpreter session. Possible values include ACTIVE, STOPPING, and STOPPED.
        public let status: CodeInterpreterSessionStatus

        @inlinable
        public init(codeInterpreterIdentifier: String, createdAt: Date, lastUpdatedAt: Date? = nil, name: String? = nil, sessionId: String, status: CodeInterpreterSessionStatus) {
            self.codeInterpreterIdentifier = codeInterpreterIdentifier
            self.createdAt = createdAt
            self.lastUpdatedAt = lastUpdatedAt
            self.name = name
            self.sessionId = sessionId
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case codeInterpreterIdentifier = "codeInterpreterIdentifier"
            case createdAt = "createdAt"
            case lastUpdatedAt = "lastUpdatedAt"
            case name = "name"
            case sessionId = "sessionId"
            case status = "status"
        }
    }

    public struct ConflictException: AWSDecodableShape {
        public let message: String?

        @inlinable
        public init(message: String? = nil) {
            self.message = message
        }

        private enum CodingKeys: String, CodingKey {
            case message = "message"
        }
    }

    public struct ContentBlock: AWSDecodableShape {
        /// The binary data content of the block.
        public let data: AWSBase64Data?
        /// The description of the content block.
        public let description: String?
        /// The MIME type of the content.
        public let mimeType: String?
        /// The name of the content block.
        public let name: String?
        /// The resource associated with the content block.
        public let resource: ResourceContent?
        /// The size of the content in bytes.
        public let size: Int64?
        /// The text content of the block.
        public let text: String?
        /// The type of content in the block.
        public let type: ContentBlockType
        /// The URI of the content.
        public let uri: String?

        @inlinable
        public init(data: AWSBase64Data? = nil, description: String? = nil, mimeType: String? = nil, name: String? = nil, resource: ResourceContent? = nil, size: Int64? = nil, text: String? = nil, type: ContentBlockType, uri: String? = nil) {
            self.data = data
            self.description = description
            self.mimeType = mimeType
            self.name = name
            self.resource = resource
            self.size = size
            self.text = text
            self.type = type
            self.uri = uri
        }

        private enum CodingKeys: String, CodingKey {
            case data = "data"
            case description = "description"
            case mimeType = "mimeType"
            case name = "name"
            case resource = "resource"
            case size = "size"
            case text = "text"
            case type = "type"
            case uri = "uri"
        }
    }

    public struct Conversational: AWSEncodableShape & AWSDecodableShape {
        /// The content of the conversation message.
        public let content: Content
        /// The role of the participant in the conversation (for example, "user" or "assistant").
        public let role: Role

        @inlinable
        public init(content: Content, role: Role) {
            self.content = content
            self.role = role
        }

        private enum CodingKeys: String, CodingKey {
            case content = "content"
            case role = "role"
        }
    }

    public struct CreateEventInput: AWSEncodableShape {
        /// The identifier of the actor associated with this event. An actor represents an entity that participates in sessions and generates events.
        public let actorId: String
        /// The branch information for this event. Branches allow for organizing events into different conversation threads or paths.
        public let branch: Branch?
        /// A unique, case-sensitive identifier to ensure that the operation completes no more than one time. If this token matches a previous request, AgentCore ignores the request, but does not return an error.
        public let clientToken: String?
        /// The timestamp when the event occurred. If not specified, the current time is used.
        public let eventTimestamp: Date
        /// The identifier of the memory store in which to create the event.
        public let memoryId: String
        /// The content payload of the event. This can include conversational data or binary content.
        public let payload: [PayloadType]
        /// The identifier of the session in which this event occurs. A session represents a sequence of related events.
        public let sessionId: String?

        @inlinable
        public init(actorId: String, branch: Branch? = nil, clientToken: String? = CreateEventInput.idempotencyToken(), eventTimestamp: Date, memoryId: String, payload: [PayloadType], sessionId: String? = nil) {
            self.actorId = actorId
            self.branch = branch
            self.clientToken = clientToken
            self.eventTimestamp = eventTimestamp
            self.memoryId = memoryId
            self.payload = payload
            self.sessionId = sessionId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encode(self.actorId, forKey: .actorId)
            try container.encodeIfPresent(self.branch, forKey: .branch)
            try container.encodeIfPresent(self.clientToken, forKey: .clientToken)
            try container.encode(self.eventTimestamp, forKey: .eventTimestamp)
            request.encodePath(self.memoryId, key: "memoryId")
            try container.encode(self.payload, forKey: .payload)
            try container.encodeIfPresent(self.sessionId, forKey: .sessionId)
        }

        public func validate(name: String) throws {
            try self.validate(self.actorId, name: "actorId", parent: name, max: 255)
            try self.validate(self.actorId, name: "actorId", parent: name, min: 1)
            try self.validate(self.actorId, name: "actorId", parent: name, pattern: "^[a-zA-Z0-9][a-zA-Z0-9-_/]*$")
            try self.branch?.validate(name: "\(name).branch")
            try self.validate(self.memoryId, name: "memoryId", parent: name, min: 12)
            try self.validate(self.memoryId, name: "memoryId", parent: name, pattern: "^[a-zA-Z][a-zA-Z0-9-_]{0,99}-[a-zA-Z0-9]{10}$")
            try self.validate(self.payload, name: "payload", parent: name, max: 100)
            try self.validate(self.sessionId, name: "sessionId", parent: name, max: 100)
            try self.validate(self.sessionId, name: "sessionId", parent: name, min: 1)
            try self.validate(self.sessionId, name: "sessionId", parent: name, pattern: "^[a-zA-Z0-9][a-zA-Z0-9-_]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case actorId = "actorId"
            case branch = "branch"
            case clientToken = "clientToken"
            case eventTimestamp = "eventTimestamp"
            case payload = "payload"
            case sessionId = "sessionId"
        }
    }

    public struct CreateEventOutput: AWSDecodableShape {
        /// The event that was created.
        public let event: Event

        @inlinable
        public init(event: Event) {
            self.event = event
        }

        private enum CodingKeys: String, CodingKey {
            case event = "event"
        }
    }

    public struct DeleteEventInput: AWSEncodableShape {
        /// The identifier of the actor associated with the event to delete.
        public let actorId: String
        /// The identifier of the event to delete.
        public let eventId: String
        /// The identifier of the memory store from which to delete the event.
        public let memoryId: String
        /// The identifier of the session containing the event to delete.
        public let sessionId: String

        @inlinable
        public init(actorId: String, eventId: String, memoryId: String, sessionId: String) {
            self.actorId = actorId
            self.eventId = eventId
            self.memoryId = memoryId
            self.sessionId = sessionId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.actorId, key: "actorId")
            request.encodePath(self.eventId, key: "eventId")
            request.encodePath(self.memoryId, key: "memoryId")
            request.encodePath(self.sessionId, key: "sessionId")
        }

        public func validate(name: String) throws {
            try self.validate(self.actorId, name: "actorId", parent: name, max: 255)
            try self.validate(self.actorId, name: "actorId", parent: name, min: 1)
            try self.validate(self.actorId, name: "actorId", parent: name, pattern: "^[a-zA-Z0-9][a-zA-Z0-9-_/]*$")
            try self.validate(self.eventId, name: "eventId", parent: name, pattern: "^[0-9]+#[a-fA-F0-9]+$")
            try self.validate(self.memoryId, name: "memoryId", parent: name, min: 12)
            try self.validate(self.memoryId, name: "memoryId", parent: name, pattern: "^[a-zA-Z][a-zA-Z0-9-_]{0,99}-[a-zA-Z0-9]{10}$")
            try self.validate(self.sessionId, name: "sessionId", parent: name, max: 100)
            try self.validate(self.sessionId, name: "sessionId", parent: name, min: 1)
            try self.validate(self.sessionId, name: "sessionId", parent: name, pattern: "^[a-zA-Z0-9][a-zA-Z0-9-_]*$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteEventOutput: AWSDecodableShape {
        /// The identifier of the event that was deleted.
        public let eventId: String

        @inlinable
        public init(eventId: String) {
            self.eventId = eventId
        }

        private enum CodingKeys: String, CodingKey {
            case eventId = "eventId"
        }
    }

    public struct DeleteMemoryRecordInput: AWSEncodableShape {
        /// The identifier of the memory store from which to delete the memory record.
        public let memoryId: String
        /// The identifier of the memory record to delete.
        public let memoryRecordId: String

        @inlinable
        public init(memoryId: String, memoryRecordId: String) {
            self.memoryId = memoryId
            self.memoryRecordId = memoryRecordId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.memoryId, key: "memoryId")
            request.encodePath(self.memoryRecordId, key: "memoryRecordId")
        }

        public func validate(name: String) throws {
            try self.validate(self.memoryId, name: "memoryId", parent: name, min: 12)
            try self.validate(self.memoryId, name: "memoryId", parent: name, pattern: "^[a-zA-Z][a-zA-Z0-9-_]{0,99}-[a-zA-Z0-9]{10}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteMemoryRecordOutput: AWSDecodableShape {
        /// The identifier of the memory record that was deleted.
        public let memoryRecordId: String

        @inlinable
        public init(memoryRecordId: String) {
            self.memoryRecordId = memoryRecordId
        }

        private enum CodingKeys: String, CodingKey {
            case memoryRecordId = "memoryRecordId"
        }
    }

    public struct Event: AWSDecodableShape {
        /// The identifier of the actor associated with the event.
        public let actorId: String
        /// The branch information for the event.
        public let branch: Branch?
        /// The unique identifier of the event.
        public let eventId: String
        /// The timestamp when the event occurred.
        public let eventTimestamp: Date
        /// The identifier of the memory store containing the event.
        public let memoryId: String
        /// The content payload of the event.
        public let payload: [PayloadType]
        /// The identifier of the session containing the event.
        public let sessionId: String

        @inlinable
        public init(actorId: String, branch: Branch? = nil, eventId: String, eventTimestamp: Date, memoryId: String, payload: [PayloadType], sessionId: String) {
            self.actorId = actorId
            self.branch = branch
            self.eventId = eventId
            self.eventTimestamp = eventTimestamp
            self.memoryId = memoryId
            self.payload = payload
            self.sessionId = sessionId
        }

        private enum CodingKeys: String, CodingKey {
            case actorId = "actorId"
            case branch = "branch"
            case eventId = "eventId"
            case eventTimestamp = "eventTimestamp"
            case memoryId = "memoryId"
            case payload = "payload"
            case sessionId = "sessionId"
        }
    }

    public struct FilterInput: AWSEncodableShape {
        /// The branch filter criteria to apply when listing events.
        public let branch: BranchFilter?

        @inlinable
        public init(branch: BranchFilter? = nil) {
            self.branch = branch
        }

        public func validate(name: String) throws {
            try self.branch?.validate(name: "\(name).branch")
        }

        private enum CodingKeys: String, CodingKey {
            case branch = "branch"
        }
    }

    public struct GetBrowserSessionRequest: AWSEncodableShape {
        /// The unique identifier of the browser associated with the session.
        public let browserIdentifier: String
        /// The unique identifier of the browser session to retrieve.
        public let sessionId: String

        @inlinable
        public init(browserIdentifier: String, sessionId: String) {
            self.browserIdentifier = browserIdentifier
            self.sessionId = sessionId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.browserIdentifier, key: "browserIdentifier")
            request.encodeQuery(self.sessionId, key: "sessionId")
        }

        public func validate(name: String) throws {
            try self.validate(self.sessionId, name: "sessionId", parent: name, pattern: "^[0-9a-zA-Z]{1,40}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetBrowserSessionResponse: AWSDecodableShape {
        /// The identifier of the browser.
        public let browserIdentifier: String
        /// The time at which the browser session was created.
        @CustomCoding<ISO8601DateCoder>
        public var createdAt: Date
        /// The time at which the browser session was last updated.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var lastUpdatedAt: Date?
        /// The name of the browser session.
        public let name: String?
        /// The identifier of the browser session.
        public let sessionId: String
        /// The artifact containing the session replay information.
        public let sessionReplayArtifact: String?
        /// The timeout period for the browser session in seconds.
        public let sessionTimeoutSeconds: Int?
        /// The current status of the browser session. Possible values include ACTIVE, STOPPING, and STOPPED.
        public let status: BrowserSessionStatus?
        /// The streams associated with this browser session. These include the automation stream and live view stream.
        public let streams: BrowserSessionStream?
        public let viewPort: ViewPort?

        @inlinable
        public init(browserIdentifier: String, createdAt: Date, lastUpdatedAt: Date? = nil, name: String? = nil, sessionId: String, sessionReplayArtifact: String? = nil, sessionTimeoutSeconds: Int? = nil, status: BrowserSessionStatus? = nil, streams: BrowserSessionStream? = nil, viewPort: ViewPort? = nil) {
            self.browserIdentifier = browserIdentifier
            self.createdAt = createdAt
            self.lastUpdatedAt = lastUpdatedAt
            self.name = name
            self.sessionId = sessionId
            self.sessionReplayArtifact = sessionReplayArtifact
            self.sessionTimeoutSeconds = sessionTimeoutSeconds
            self.status = status
            self.streams = streams
            self.viewPort = viewPort
        }

        private enum CodingKeys: String, CodingKey {
            case browserIdentifier = "browserIdentifier"
            case createdAt = "createdAt"
            case lastUpdatedAt = "lastUpdatedAt"
            case name = "name"
            case sessionId = "sessionId"
            case sessionReplayArtifact = "sessionReplayArtifact"
            case sessionTimeoutSeconds = "sessionTimeoutSeconds"
            case status = "status"
            case streams = "streams"
            case viewPort = "viewPort"
        }
    }

    public struct GetCodeInterpreterSessionRequest: AWSEncodableShape {
        /// The unique identifier of the code interpreter associated with the session.
        public let codeInterpreterIdentifier: String
        /// The unique identifier of the code interpreter session to retrieve.
        public let sessionId: String

        @inlinable
        public init(codeInterpreterIdentifier: String, sessionId: String) {
            self.codeInterpreterIdentifier = codeInterpreterIdentifier
            self.sessionId = sessionId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.codeInterpreterIdentifier, key: "codeInterpreterIdentifier")
            request.encodeQuery(self.sessionId, key: "sessionId")
        }

        public func validate(name: String) throws {
            try self.validate(self.sessionId, name: "sessionId", parent: name, pattern: "^[0-9a-zA-Z]{1,40}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetCodeInterpreterSessionResponse: AWSDecodableShape {
        /// The identifier of the code interpreter.
        public let codeInterpreterIdentifier: String
        /// The time at which the code interpreter session was created.
        @CustomCoding<ISO8601DateCoder>
        public var createdAt: Date
        /// The name of the code interpreter session.
        public let name: String?
        /// The identifier of the code interpreter session.
        public let sessionId: String
        /// The timeout period for the code interpreter session in seconds.
        public let sessionTimeoutSeconds: Int?
        /// The current status of the code interpreter session. Possible values include ACTIVE, STOPPING, and STOPPED.
        public let status: CodeInterpreterSessionStatus?

        @inlinable
        public init(codeInterpreterIdentifier: String, createdAt: Date, name: String? = nil, sessionId: String, sessionTimeoutSeconds: Int? = nil, status: CodeInterpreterSessionStatus? = nil) {
            self.codeInterpreterIdentifier = codeInterpreterIdentifier
            self.createdAt = createdAt
            self.name = name
            self.sessionId = sessionId
            self.sessionTimeoutSeconds = sessionTimeoutSeconds
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case codeInterpreterIdentifier = "codeInterpreterIdentifier"
            case createdAt = "createdAt"
            case name = "name"
            case sessionId = "sessionId"
            case sessionTimeoutSeconds = "sessionTimeoutSeconds"
            case status = "status"
        }
    }

    public struct GetEventInput: AWSEncodableShape {
        /// The identifier of the actor associated with the event.
        public let actorId: String
        /// The identifier of the event to retrieve.
        public let eventId: String
        /// The identifier of the memory store containing the event.
        public let memoryId: String
        /// The identifier of the session containing the event.
        public let sessionId: String

        @inlinable
        public init(actorId: String, eventId: String, memoryId: String, sessionId: String) {
            self.actorId = actorId
            self.eventId = eventId
            self.memoryId = memoryId
            self.sessionId = sessionId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.actorId, key: "actorId")
            request.encodePath(self.eventId, key: "eventId")
            request.encodePath(self.memoryId, key: "memoryId")
            request.encodePath(self.sessionId, key: "sessionId")
        }

        public func validate(name: String) throws {
            try self.validate(self.actorId, name: "actorId", parent: name, max: 255)
            try self.validate(self.actorId, name: "actorId", parent: name, min: 1)
            try self.validate(self.actorId, name: "actorId", parent: name, pattern: "^[a-zA-Z0-9][a-zA-Z0-9-_/]*$")
            try self.validate(self.eventId, name: "eventId", parent: name, pattern: "^[0-9]+#[a-fA-F0-9]+$")
            try self.validate(self.memoryId, name: "memoryId", parent: name, min: 12)
            try self.validate(self.memoryId, name: "memoryId", parent: name, pattern: "^[a-zA-Z][a-zA-Z0-9-_]{0,99}-[a-zA-Z0-9]{10}$")
            try self.validate(self.sessionId, name: "sessionId", parent: name, max: 100)
            try self.validate(self.sessionId, name: "sessionId", parent: name, min: 1)
            try self.validate(self.sessionId, name: "sessionId", parent: name, pattern: "^[a-zA-Z0-9][a-zA-Z0-9-_]*$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetEventOutput: AWSDecodableShape {
        /// The requested event information.
        public let event: Event

        @inlinable
        public init(event: Event) {
            self.event = event
        }

        private enum CodingKeys: String, CodingKey {
            case event = "event"
        }
    }

    public struct GetMemoryRecordInput: AWSEncodableShape {
        /// The identifier of the memory store containing the memory record.
        public let memoryId: String
        /// The identifier of the memory record to retrieve.
        public let memoryRecordId: String

        @inlinable
        public init(memoryId: String, memoryRecordId: String) {
            self.memoryId = memoryId
            self.memoryRecordId = memoryRecordId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.memoryId, key: "memoryId")
            request.encodePath(self.memoryRecordId, key: "memoryRecordId")
        }

        public func validate(name: String) throws {
            try self.validate(self.memoryId, name: "memoryId", parent: name, min: 12)
            try self.validate(self.memoryId, name: "memoryId", parent: name, pattern: "^[a-zA-Z][a-zA-Z0-9-_]{0,99}-[a-zA-Z0-9]{10}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetMemoryRecordOutput: AWSDecodableShape {
        /// The requested memory record.
        public let memoryRecord: MemoryRecord

        @inlinable
        public init(memoryRecord: MemoryRecord) {
            self.memoryRecord = memoryRecord
        }

        private enum CodingKeys: String, CodingKey {
            case memoryRecord = "memoryRecord"
        }
    }

    public struct GetResourceApiKeyRequest: AWSEncodableShape {
        /// The credential provider name of the resource you are retrieving the API Key of.
        public let resourceCredentialProviderName: String
        /// The identity token of the workload you want to get the API Key of.
        public let workloadIdentityToken: String

        @inlinable
        public init(resourceCredentialProviderName: String, workloadIdentityToken: String) {
            self.resourceCredentialProviderName = resourceCredentialProviderName
            self.workloadIdentityToken = workloadIdentityToken
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceCredentialProviderName, name: "resourceCredentialProviderName", parent: name, max: 128)
            try self.validate(self.resourceCredentialProviderName, name: "resourceCredentialProviderName", parent: name, min: 1)
            try self.validate(self.resourceCredentialProviderName, name: "resourceCredentialProviderName", parent: name, pattern: "^[a-zA-Z0-9\\-_]+$")
            try self.validate(self.workloadIdentityToken, name: "workloadIdentityToken", parent: name, max: 131072)
            try self.validate(self.workloadIdentityToken, name: "workloadIdentityToken", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case resourceCredentialProviderName = "resourceCredentialProviderName"
            case workloadIdentityToken = "workloadIdentityToken"
        }
    }

    public struct GetResourceApiKeyResponse: AWSDecodableShape {
        /// The API Key associated with the resource requested.
        public let apiKey: String

        @inlinable
        public init(apiKey: String) {
            self.apiKey = apiKey
        }

        private enum CodingKeys: String, CodingKey {
            case apiKey = "apiKey"
        }
    }

    public struct GetResourceOauth2TokenRequest: AWSEncodableShape {
        /// Gives the ability to send extra/custom parameters to the resource credentials provider during the authorization process. Standard OAuth2 flow parameters will not be overriden.
        public let customParameters: [String: String]?
        /// If true, always initiate a new 3LO flow
        public let forceAuthentication: Bool?
        /// The type of flow to be performed
        public let oauth2Flow: Oauth2FlowType
        /// Reference to the credential provider
        public let resourceCredentialProviderName: String
        /// Callback url to redirect after token retrieval completes. Should be one of the provideded urls during WorkloadIdentity creation
        public let resourceOauth2ReturnUrl: String?
        /// The OAuth scopes requested
        public let scopes: [String]
        /// The user ID of the user you're retrieving the token on behalf of.
        public let userId: String?
        /// The identity token of the workload you want to retrive the Oauth2 Token of.
        public let workloadIdentityToken: String

        @inlinable
        public init(customParameters: [String: String]? = nil, forceAuthentication: Bool? = nil, oauth2Flow: Oauth2FlowType, resourceCredentialProviderName: String, resourceOauth2ReturnUrl: String? = nil, scopes: [String], userId: String? = nil, workloadIdentityToken: String) {
            self.customParameters = customParameters
            self.forceAuthentication = forceAuthentication
            self.oauth2Flow = oauth2Flow
            self.resourceCredentialProviderName = resourceCredentialProviderName
            self.resourceOauth2ReturnUrl = resourceOauth2ReturnUrl
            self.scopes = scopes
            self.userId = userId
            self.workloadIdentityToken = workloadIdentityToken
        }

        public func validate(name: String) throws {
            try self.customParameters?.forEach {
                try validate($0.key, name: "customParameters.key", parent: name, max: 256)
                try validate($0.key, name: "customParameters.key", parent: name, min: 1)
                try validate($0.key, name: "customParameters.key", parent: name, pattern: "^[a-zA-Z0-9\\-_\\.]+$")
                try validate($0.value, name: "customParameters[\"\($0.key)\"]", parent: name, max: 2048)
                try validate($0.value, name: "customParameters[\"\($0.key)\"]", parent: name, min: 1)
            }
            try self.validate(self.resourceCredentialProviderName, name: "resourceCredentialProviderName", parent: name, max: 128)
            try self.validate(self.resourceCredentialProviderName, name: "resourceCredentialProviderName", parent: name, min: 1)
            try self.validate(self.resourceCredentialProviderName, name: "resourceCredentialProviderName", parent: name, pattern: "^[a-zA-Z0-9\\-_]+$")
            try self.validate(self.resourceOauth2ReturnUrl, name: "resourceOauth2ReturnUrl", parent: name, max: 2048)
            try self.validate(self.resourceOauth2ReturnUrl, name: "resourceOauth2ReturnUrl", parent: name, min: 1)
            try self.validate(self.resourceOauth2ReturnUrl, name: "resourceOauth2ReturnUrl", parent: name, pattern: "^\\w+:(\\/?\\/?)[^\\s]+$")
            try self.scopes.forEach {
                try validate($0, name: "scopes[]", parent: name, max: 128)
                try validate($0, name: "scopes[]", parent: name, min: 1)
            }
            try self.validate(self.userId, name: "userId", parent: name, max: 128)
            try self.validate(self.userId, name: "userId", parent: name, min: 1)
            try self.validate(self.workloadIdentityToken, name: "workloadIdentityToken", parent: name, max: 131072)
            try self.validate(self.workloadIdentityToken, name: "workloadIdentityToken", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case customParameters = "customParameters"
            case forceAuthentication = "forceAuthentication"
            case oauth2Flow = "oauth2Flow"
            case resourceCredentialProviderName = "resourceCredentialProviderName"
            case resourceOauth2ReturnUrl = "resourceOauth2ReturnUrl"
            case scopes = "scopes"
            case userId = "userId"
            case workloadIdentityToken = "workloadIdentityToken"
        }
    }

    public struct GetResourceOauth2TokenResponse: AWSDecodableShape {
        /// OAuth2 token ready for use
        public let accessToken: String?
        /// The URL for the authorization process, provided if the Access token requires user Authorization.
        public let authorizationUrl: String?

        @inlinable
        public init(accessToken: String? = nil, authorizationUrl: String? = nil) {
            self.accessToken = accessToken
            self.authorizationUrl = authorizationUrl
        }

        private enum CodingKeys: String, CodingKey {
            case accessToken = "accessToken"
            case authorizationUrl = "authorizationUrl"
        }
    }

    public struct GetWorkloadAccessTokenForJWTRequest: AWSEncodableShape {
        /// OAuth2 token issued by the user's identity provider
        public let userToken: String
        /// Unique identifier for the registered agent
        public let workloadName: String

        @inlinable
        public init(userToken: String, workloadName: String) {
            self.userToken = userToken
            self.workloadName = workloadName
        }

        public func validate(name: String) throws {
            try self.validate(self.userToken, name: "userToken", parent: name, max: 131072)
            try self.validate(self.userToken, name: "userToken", parent: name, min: 1)
            try self.validate(self.userToken, name: "userToken", parent: name, pattern: "^[A-Za-z0-9-_=]+.[A-Za-z0-9-_=]+.[A-Za-z0-9-_=]+$")
            try self.validate(self.workloadName, name: "workloadName", parent: name, max: 255)
            try self.validate(self.workloadName, name: "workloadName", parent: name, min: 3)
            try self.validate(self.workloadName, name: "workloadName", parent: name, pattern: "^[A-Za-z0-9_.-]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case userToken = "userToken"
            case workloadName = "workloadName"
        }
    }

    public struct GetWorkloadAccessTokenForJWTResponse: AWSDecodableShape {
        /// Opaque token representing both agent and user identity
        public let workloadAccessToken: String

        @inlinable
        public init(workloadAccessToken: String) {
            self.workloadAccessToken = workloadAccessToken
        }

        private enum CodingKeys: String, CodingKey {
            case workloadAccessToken = "workloadAccessToken"
        }
    }

    public struct GetWorkloadAccessTokenForUserIdRequest: AWSEncodableShape {
        /// The user id of the user you are retrieving the access token for.
        public let userId: String
        /// The name of the worklaod you want to get the access token of.
        public let workloadName: String

        @inlinable
        public init(userId: String, workloadName: String) {
            self.userId = userId
            self.workloadName = workloadName
        }

        public func validate(name: String) throws {
            try self.validate(self.userId, name: "userId", parent: name, max: 128)
            try self.validate(self.userId, name: "userId", parent: name, min: 1)
            try self.validate(self.workloadName, name: "workloadName", parent: name, max: 255)
            try self.validate(self.workloadName, name: "workloadName", parent: name, min: 3)
            try self.validate(self.workloadName, name: "workloadName", parent: name, pattern: "^[A-Za-z0-9_.-]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case userId = "userId"
            case workloadName = "workloadName"
        }
    }

    public struct GetWorkloadAccessTokenForUserIdResponse: AWSDecodableShape {
        /// The workload access token of the named workload.
        public let workloadAccessToken: String

        @inlinable
        public init(workloadAccessToken: String) {
            self.workloadAccessToken = workloadAccessToken
        }

        private enum CodingKeys: String, CodingKey {
            case workloadAccessToken = "workloadAccessToken"
        }
    }

    public struct GetWorkloadAccessTokenRequest: AWSEncodableShape {
        /// Unique identifier for the registered agent
        public let workloadName: String

        @inlinable
        public init(workloadName: String) {
            self.workloadName = workloadName
        }

        public func validate(name: String) throws {
            try self.validate(self.workloadName, name: "workloadName", parent: name, max: 255)
            try self.validate(self.workloadName, name: "workloadName", parent: name, min: 3)
            try self.validate(self.workloadName, name: "workloadName", parent: name, pattern: "^[A-Za-z0-9_.-]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case workloadName = "workloadName"
        }
    }

    public struct GetWorkloadAccessTokenResponse: AWSDecodableShape {
        /// Opaque token representing both agent and user identity
        public let workloadAccessToken: String

        @inlinable
        public init(workloadAccessToken: String) {
            self.workloadAccessToken = workloadAccessToken
        }

        private enum CodingKeys: String, CodingKey {
            case workloadAccessToken = "workloadAccessToken"
        }
    }

    public struct InputContentBlock: AWSEncodableShape {
        /// The binary input content.
        public let blob: AWSBase64Data?
        /// The path to the input content.
        public let path: String
        /// The text input content.
        public let text: String?

        @inlinable
        public init(blob: AWSBase64Data? = nil, path: String, text: String? = nil) {
            self.blob = blob
            self.path = path
            self.text = text
        }

        public func validate(name: String) throws {
            try self.validate(self.blob, name: "blob", parent: name, max: 100000000)
            try self.validate(self.path, name: "path", parent: name, max: 100000000)
            try self.validate(self.text, name: "text", parent: name, max: 100000000)
        }

        private enum CodingKeys: String, CodingKey {
            case blob = "blob"
            case path = "path"
            case text = "text"
        }
    }

    public struct InternalServerException: AWSDecodableShape {
        public let message: String?

        @inlinable
        public init(message: String? = nil) {
            self.message = message
        }

        private enum CodingKeys: String, CodingKey {
            case message = "message"
        }
    }

    public struct InvokeAgentRuntimeRequest: AWSEncodableShape {
        /// The desired MIME type for the response from the agent runtime. This tells the agent runtime what format to use for the response data. Common values include application/json for JSON data.
        public let accept: String?
        /// The Amazon Web Services Resource Name (ARN) of the agent runtime to invoke. The ARN uniquely identifies the agent runtime resource in Amazon Bedrock.
        public let agentRuntimeArn: String
        /// Additional context information for distributed tracing.
        public let baggage: String?
        /// The MIME type of the input data in the payload. This tells the agent runtime how to interpret the payload data. Common values include application/json for JSON data.
        public let contentType: String?
        /// The version of the MCP protocol being used.
        public let mcpProtocolVersion: String?
        /// The identifier of the MCP session.
        public let mcpSessionId: String?
        /// The input data to send to the agent runtime. The format of this data depends on the specific agent configuration and must match the specified content type. For most agents, this is a JSON object containing the user's request.
        public let payload: AWSHTTPBody
        /// The qualifier to use for the agent runtime. This can be a version number or an alias name that points to a specific version. If not specified, Amazon Bedrock uses the default version of the agent runtime.
        public let qualifier: String?
        /// The identifier of the runtime session.
        public let runtimeSessionId: String?
        /// The identifier of the runtime user.
        public let runtimeUserId: String?
        /// The trace identifier for request tracking.
        public let traceId: String?
        /// The parent trace information for distributed tracing.
        public let traceParent: String?
        /// The trace state information for distributed tracing.
        public let traceState: String?

        @inlinable
        public init(accept: String? = nil, agentRuntimeArn: String, baggage: String? = nil, contentType: String? = nil, mcpProtocolVersion: String? = nil, mcpSessionId: String? = nil, payload: AWSHTTPBody, qualifier: String? = nil, runtimeSessionId: String? = InvokeAgentRuntimeRequest.idempotencyToken(), runtimeUserId: String? = nil, traceId: String? = nil, traceParent: String? = nil, traceState: String? = nil) {
            self.accept = accept
            self.agentRuntimeArn = agentRuntimeArn
            self.baggage = baggage
            self.contentType = contentType
            self.mcpProtocolVersion = mcpProtocolVersion
            self.mcpSessionId = mcpSessionId
            self.payload = payload
            self.qualifier = qualifier
            self.runtimeSessionId = runtimeSessionId
            self.runtimeUserId = runtimeUserId
            self.traceId = traceId
            self.traceParent = traceParent
            self.traceState = traceState
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.singleValueContainer()
            request.encodeHeader(self.accept, key: "Accept")
            request.encodePath(self.agentRuntimeArn, key: "agentRuntimeArn")
            request.encodeHeader(self.baggage, key: "baggage")
            request.encodeHeader(self.contentType, key: "Content-Type")
            request.encodeHeader(self.mcpProtocolVersion, key: "Mcp-Protocol-Version")
            request.encodeHeader(self.mcpSessionId, key: "Mcp-Session-Id")
            try container.encode(self.payload)
            request.encodeQuery(self.qualifier, key: "qualifier")
            request.encodeHeader(self.runtimeSessionId, key: "X-Amzn-Bedrock-AgentCore-Runtime-Session-Id")
            request.encodeHeader(self.runtimeUserId, key: "X-Amzn-Bedrock-AgentCore-Runtime-User-Id")
            request.encodeHeader(self.traceId, key: "X-Amzn-Trace-Id")
            request.encodeHeader(self.traceParent, key: "traceparent")
            request.encodeHeader(self.traceState, key: "tracestate")
        }

        public func validate(name: String) throws {
            try self.validate(self.accept, name: "accept", parent: name, max: 256)
            try self.validate(self.accept, name: "accept", parent: name, min: 1)
            try self.validate(self.contentType, name: "contentType", parent: name, max: 256)
            try self.validate(self.contentType, name: "contentType", parent: name, min: 1)
            try self.validate(self.mcpProtocolVersion, name: "mcpProtocolVersion", parent: name, max: 1024)
            try self.validate(self.mcpProtocolVersion, name: "mcpProtocolVersion", parent: name, min: 1)
            try self.validate(self.mcpSessionId, name: "mcpSessionId", parent: name, max: 1024)
            try self.validate(self.mcpSessionId, name: "mcpSessionId", parent: name, min: 1)
            try self.validate(self.payload, name: "payload", parent: name, max: 100000000)
            try self.validate(self.runtimeSessionId, name: "runtimeSessionId", parent: name, max: 256)
            try self.validate(self.runtimeSessionId, name: "runtimeSessionId", parent: name, min: 33)
            try self.validate(self.runtimeUserId, name: "runtimeUserId", parent: name, max: 1024)
            try self.validate(self.runtimeUserId, name: "runtimeUserId", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct InvokeAgentRuntimeResponse: AWSDecodableShape {
        public static let _options: AWSShapeOptions = [.rawPayload]
        /// Additional context information for distributed tracing.
        public let baggage: String?
        /// The MIME type of the response data. This indicates how to interpret the response data. Common values include application/json for JSON data.
        public let contentType: String
        /// The version of the MCP protocol being used.
        public let mcpProtocolVersion: String?
        /// The identifier of the MCP session.
        public let mcpSessionId: String?
        /// The response data from the agent runtime. The format of this data depends on the specific agent configuration and the requested accept type. For most agents, this is a JSON object containing the agent's response to the user's request.
        public let response: AWSHTTPBody
        /// The identifier of the runtime session.
        public let runtimeSessionId: String?
        /// The HTTP status code of the response. A status code of 200 indicates a successful operation. Other status codes indicate various error conditions.
        public let statusCode: Int?
        /// The trace identifier for request tracking.
        public let traceId: String?
        /// The parent trace information for distributed tracing.
        public let traceParent: String?
        /// The trace state information for distributed tracing.
        public let traceState: String?

        @inlinable
        public init(baggage: String? = nil, contentType: String, mcpProtocolVersion: String? = nil, mcpSessionId: String? = nil, response: AWSHTTPBody, runtimeSessionId: String? = nil, statusCode: Int? = nil, traceId: String? = nil, traceParent: String? = nil, traceState: String? = nil) {
            self.baggage = baggage
            self.contentType = contentType
            self.mcpProtocolVersion = mcpProtocolVersion
            self.mcpSessionId = mcpSessionId
            self.response = response
            self.runtimeSessionId = runtimeSessionId
            self.statusCode = statusCode
            self.traceId = traceId
            self.traceParent = traceParent
            self.traceState = traceState
        }

        public init(from decoder: Decoder) throws {
            let response = decoder.userInfo[.awsResponse]! as! ResponseDecodingContainer
            let container = try decoder.singleValueContainer()
            self.baggage = try response.decodeHeaderIfPresent(String.self, key: "baggage")
            self.contentType = try response.decodeHeader(String.self, key: "Content-Type")
            self.mcpProtocolVersion = try response.decodeHeaderIfPresent(String.self, key: "Mcp-Protocol-Version")
            self.mcpSessionId = try response.decodeHeaderIfPresent(String.self, key: "Mcp-Session-Id")
            self.response = try container.decode(AWSHTTPBody.self)
            self.runtimeSessionId = try response.decodeHeaderIfPresent(String.self, key: "X-Amzn-Bedrock-AgentCore-Runtime-Session-Id")
            self.statusCode = response.decodeStatus()
            self.traceId = try response.decodeHeaderIfPresent(String.self, key: "X-Amzn-Trace-Id")
            self.traceParent = try response.decodeHeaderIfPresent(String.self, key: "traceparent")
            self.traceState = try response.decodeHeaderIfPresent(String.self, key: "tracestate")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct InvokeCodeInterpreterRequest: AWSEncodableShape {
        /// The arguments for the code interpreter. This includes the code to execute and any additional parameters such as the programming language, whether to clear the execution context, and other execution options. The structure of this parameter depends on the specific code interpreter being used.
        public let arguments: ToolArguments?
        /// The unique identifier of the code interpreter associated with the session. This must match the identifier used when creating the session with StartCodeInterpreterSession.
        public let codeInterpreterIdentifier: String
        /// The name of the code interpreter to invoke.
        public let name: ToolName
        /// The unique identifier of the code interpreter session to use. This must be an active session created with StartCodeInterpreterSession. If the session has expired or been stopped, the request will fail.
        public let sessionId: String?

        @inlinable
        public init(arguments: ToolArguments? = nil, codeInterpreterIdentifier: String, name: ToolName, sessionId: String? = nil) {
            self.arguments = arguments
            self.codeInterpreterIdentifier = codeInterpreterIdentifier
            self.name = name
            self.sessionId = sessionId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.arguments, forKey: .arguments)
            request.encodePath(self.codeInterpreterIdentifier, key: "codeInterpreterIdentifier")
            try container.encode(self.name, forKey: .name)
            request.encodeHeader(self.sessionId, key: "x-amzn-code-interpreter-session-id")
        }

        public func validate(name: String) throws {
            try self.arguments?.validate(name: "\(name).arguments")
            try self.validate(self.sessionId, name: "sessionId", parent: name, pattern: "^[0-9a-zA-Z]{1,40}$")
        }

        private enum CodingKeys: String, CodingKey {
            case arguments = "arguments"
            case name = "name"
        }
    }

    public struct InvokeCodeInterpreterResponse: AWSDecodableShape {
        public static let _options: AWSShapeOptions = [.rawPayload]
        /// The identifier of the code interpreter session.
        public let sessionId: String?
        /// The stream containing the results of the code execution. This includes output, errors, and execution status.
        public let stream: AWSEventStream<CodeInterpreterStreamOutput>

        @inlinable
        public init(sessionId: String? = nil, stream: AWSEventStream<CodeInterpreterStreamOutput>) {
            self.sessionId = sessionId
            self.stream = stream
        }

        public init(from decoder: Decoder) throws {
            let response = decoder.userInfo[.awsResponse]! as! ResponseDecodingContainer
            let container = try decoder.singleValueContainer()
            self.sessionId = try response.decodeHeaderIfPresent(String.self, key: "x-amzn-code-interpreter-session-id")
            self.stream = try container.decode(AWSEventStream<CodeInterpreterStreamOutput>.self)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListActorsInput: AWSEncodableShape {
        /// The maximum number of results to return in a single call. Minimum value of 1, maximum value of 100. Default is 20.
        public let maxResults: Int?
        /// The identifier of the memory store for which to list actors.
        public let memoryId: String
        /// The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.
        public let nextToken: String?

        @inlinable
        public init(maxResults: Int? = nil, memoryId: String, nextToken: String? = nil) {
            self.maxResults = maxResults
            self.memoryId = memoryId
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.maxResults, forKey: .maxResults)
            request.encodePath(self.memoryId, key: "memoryId")
            try container.encodeIfPresent(self.nextToken, forKey: .nextToken)
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.memoryId, name: "memoryId", parent: name, min: 12)
            try self.validate(self.memoryId, name: "memoryId", parent: name, pattern: "^[a-zA-Z][a-zA-Z0-9-_]{0,99}-[a-zA-Z0-9]{10}$")
        }

        private enum CodingKeys: String, CodingKey {
            case maxResults = "maxResults"
            case nextToken = "nextToken"
        }
    }

    public struct ListActorsOutput: AWSDecodableShape {
        /// The list of actor summaries.
        public let actorSummaries: [ActorSummary]
        /// The token to use in a subsequent request to get the next set of results. This value is null when there are no more results to return.
        public let nextToken: String?

        @inlinable
        public init(actorSummaries: [ActorSummary], nextToken: String? = nil) {
            self.actorSummaries = actorSummaries
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case actorSummaries = "actorSummaries"
            case nextToken = "nextToken"
        }
    }

    public struct ListBrowserSessionsRequest: AWSEncodableShape {
        /// The unique identifier of the browser to list sessions for. If specified, only sessions for this browser are returned. If not specified, sessions for all browsers are returned.
        public let browserIdentifier: String
        /// The maximum number of results to return in a single call. The default value is 10. Valid values range from 1 to 100. To retrieve the remaining results, make another call with the returned nextToken value.
        public let maxResults: Int?
        /// The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results. If not specified, Amazon Bedrock returns the first page of results.
        public let nextToken: String?
        /// The status of the browser sessions to list. Valid values include ACTIVE, STOPPING, and STOPPED. If not specified, sessions with any status are returned.
        public let status: BrowserSessionStatus?

        @inlinable
        public init(browserIdentifier: String, maxResults: Int? = nil, nextToken: String? = nil, status: BrowserSessionStatus? = nil) {
            self.browserIdentifier = browserIdentifier
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.status = status
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.browserIdentifier, key: "browserIdentifier")
            try container.encodeIfPresent(self.maxResults, forKey: .maxResults)
            try container.encodeIfPresent(self.nextToken, forKey: .nextToken)
            try container.encodeIfPresent(self.status, forKey: .status)
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 2048)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^\\S*$")
        }

        private enum CodingKeys: String, CodingKey {
            case maxResults = "maxResults"
            case nextToken = "nextToken"
            case status = "status"
        }
    }

    public struct ListBrowserSessionsResponse: AWSDecodableShape {
        /// The list of browser sessions that match the specified criteria.
        public let items: [BrowserSessionSummary]
        /// The token to use in a subsequent ListBrowserSessions request to get the next set of results.
        public let nextToken: String?

        @inlinable
        public init(items: [BrowserSessionSummary], nextToken: String? = nil) {
            self.items = items
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case items = "items"
            case nextToken = "nextToken"
        }
    }

    public struct ListCodeInterpreterSessionsRequest: AWSEncodableShape {
        /// The unique identifier of the code interpreter to list sessions for. If specified, only sessions for this code interpreter are returned. If not specified, sessions for all code interpreters are returned.
        public let codeInterpreterIdentifier: String
        /// The maximum number of results to return in a single call. The default value is 10. Valid values range from 1 to 100. To retrieve the remaining results, make another call with the returned nextToken value.
        public let maxResults: Int?
        /// The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results. If not specified, Amazon Bedrock returns the first page of results.
        public let nextToken: String?
        /// The status of the code interpreter sessions to list. Valid values include ACTIVE, STOPPING, and STOPPED. If not specified, sessions with any status are returned.
        public let status: CodeInterpreterSessionStatus?

        @inlinable
        public init(codeInterpreterIdentifier: String, maxResults: Int? = nil, nextToken: String? = nil, status: CodeInterpreterSessionStatus? = nil) {
            self.codeInterpreterIdentifier = codeInterpreterIdentifier
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.status = status
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.codeInterpreterIdentifier, key: "codeInterpreterIdentifier")
            try container.encodeIfPresent(self.maxResults, forKey: .maxResults)
            try container.encodeIfPresent(self.nextToken, forKey: .nextToken)
            try container.encodeIfPresent(self.status, forKey: .status)
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 2048)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^\\S*$")
        }

        private enum CodingKeys: String, CodingKey {
            case maxResults = "maxResults"
            case nextToken = "nextToken"
            case status = "status"
        }
    }

    public struct ListCodeInterpreterSessionsResponse: AWSDecodableShape {
        /// The list of code interpreter sessions that match the specified criteria.
        public let items: [CodeInterpreterSessionSummary]
        /// The token to use in a subsequent ListCodeInterpreterSessions request to get the next set of results.
        public let nextToken: String?

        @inlinable
        public init(items: [CodeInterpreterSessionSummary], nextToken: String? = nil) {
            self.items = items
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case items = "items"
            case nextToken = "nextToken"
        }
    }

    public struct ListEventsInput: AWSEncodableShape {
        /// The identifier of the actor for which to list events. If specified, only events from this actor are returned.
        public let actorId: String
        /// Filter criteria to apply when listing events.
        public let filter: FilterInput?
        /// Specifies whether to include event payloads in the response. Set to true to include payloads, or false to exclude them.
        public let includePayloads: Bool?
        /// The maximum number of results to return in a single call. Minimum value of 1, maximum value of 100. Default is 20.
        public let maxResults: Int?
        /// The identifier of the memory store for which to list events.
        public let memoryId: String
        /// The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.
        public let nextToken: String?
        /// The identifier of the session for which to list events. If specified, only events from this session are returned.
        public let sessionId: String

        @inlinable
        public init(actorId: String, filter: FilterInput? = nil, includePayloads: Bool? = nil, maxResults: Int? = nil, memoryId: String, nextToken: String? = nil, sessionId: String) {
            self.actorId = actorId
            self.filter = filter
            self.includePayloads = includePayloads
            self.maxResults = maxResults
            self.memoryId = memoryId
            self.nextToken = nextToken
            self.sessionId = sessionId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.actorId, key: "actorId")
            try container.encodeIfPresent(self.filter, forKey: .filter)
            try container.encodeIfPresent(self.includePayloads, forKey: .includePayloads)
            try container.encodeIfPresent(self.maxResults, forKey: .maxResults)
            request.encodePath(self.memoryId, key: "memoryId")
            try container.encodeIfPresent(self.nextToken, forKey: .nextToken)
            request.encodePath(self.sessionId, key: "sessionId")
        }

        public func validate(name: String) throws {
            try self.validate(self.actorId, name: "actorId", parent: name, max: 255)
            try self.validate(self.actorId, name: "actorId", parent: name, min: 1)
            try self.validate(self.actorId, name: "actorId", parent: name, pattern: "^[a-zA-Z0-9][a-zA-Z0-9-_/]*$")
            try self.filter?.validate(name: "\(name).filter")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.memoryId, name: "memoryId", parent: name, min: 12)
            try self.validate(self.memoryId, name: "memoryId", parent: name, pattern: "^[a-zA-Z][a-zA-Z0-9-_]{0,99}-[a-zA-Z0-9]{10}$")
            try self.validate(self.sessionId, name: "sessionId", parent: name, max: 100)
            try self.validate(self.sessionId, name: "sessionId", parent: name, min: 1)
            try self.validate(self.sessionId, name: "sessionId", parent: name, pattern: "^[a-zA-Z0-9][a-zA-Z0-9-_]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case filter = "filter"
            case includePayloads = "includePayloads"
            case maxResults = "maxResults"
            case nextToken = "nextToken"
        }
    }

    public struct ListEventsOutput: AWSDecodableShape {
        /// The list of events that match the specified criteria.
        public let events: [Event]
        /// The token to use in a subsequent request to get the next set of results. This value is null when there are no more results to return.
        public let nextToken: String?

        @inlinable
        public init(events: [Event], nextToken: String? = nil) {
            self.events = events
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case events = "events"
            case nextToken = "nextToken"
        }
    }

    public struct ListMemoryRecordsInput: AWSEncodableShape {
        /// The maximum number of results to return in a single call. Minimum value of 1, maximum value of 100. Default is 20.
        public let maxResults: Int?
        /// The identifier of the memory store for which to list memory records.
        public let memoryId: String
        /// The memory strategy identifier to filter memory records by. If specified, only memory records with this strategy ID are returned.
        public let memoryStrategyId: String?
        /// The namespace to filter memory records by. If specified, only memory records in this namespace are returned.
        public let namespace: String
        /// The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.
        public let nextToken: String?

        @inlinable
        public init(maxResults: Int? = nil, memoryId: String, memoryStrategyId: String? = nil, namespace: String, nextToken: String? = nil) {
            self.maxResults = maxResults
            self.memoryId = memoryId
            self.memoryStrategyId = memoryStrategyId
            self.namespace = namespace
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.maxResults, forKey: .maxResults)
            request.encodePath(self.memoryId, key: "memoryId")
            try container.encodeIfPresent(self.memoryStrategyId, forKey: .memoryStrategyId)
            try container.encode(self.namespace, forKey: .namespace)
            try container.encodeIfPresent(self.nextToken, forKey: .nextToken)
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.memoryId, name: "memoryId", parent: name, min: 12)
            try self.validate(self.memoryId, name: "memoryId", parent: name, pattern: "^[a-zA-Z][a-zA-Z0-9-_]{0,99}-[a-zA-Z0-9]{10}$")
            try self.validate(self.memoryStrategyId, name: "memoryStrategyId", parent: name, max: 100)
            try self.validate(self.memoryStrategyId, name: "memoryStrategyId", parent: name, min: 1)
            try self.validate(self.memoryStrategyId, name: "memoryStrategyId", parent: name, pattern: "^[a-zA-Z0-9][a-zA-Z0-9-_]*$")
            try self.validate(self.namespace, name: "namespace", parent: name, max: 1024)
            try self.validate(self.namespace, name: "namespace", parent: name, min: 1)
            try self.validate(self.namespace, name: "namespace", parent: name, pattern: "^[a-zA-Z0-9/*][a-zA-Z0-9-_/*]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case maxResults = "maxResults"
            case memoryStrategyId = "memoryStrategyId"
            case namespace = "namespace"
            case nextToken = "nextToken"
        }
    }

    public struct ListMemoryRecordsOutput: AWSDecodableShape {
        /// The list of memory record summaries that match the specified criteria.
        public let memoryRecordSummaries: [MemoryRecordSummary]
        /// The token to use in a subsequent request to get the next set of results. This value is null when there are no more results to return.
        public let nextToken: String?

        @inlinable
        public init(memoryRecordSummaries: [MemoryRecordSummary], nextToken: String? = nil) {
            self.memoryRecordSummaries = memoryRecordSummaries
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case memoryRecordSummaries = "memoryRecordSummaries"
            case nextToken = "nextToken"
        }
    }

    public struct ListSessionsInput: AWSEncodableShape {
        /// The identifier of the actor for which to list sessions. If specified, only sessions involving this actor are returned.
        public let actorId: String
        /// The maximum number of results to return in a single call. Minimum value of 1, maximum value of 100. Default is 20.
        public let maxResults: Int?
        /// The identifier of the memory store for which to list sessions.
        public let memoryId: String
        /// The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.
        public let nextToken: String?

        @inlinable
        public init(actorId: String, maxResults: Int? = nil, memoryId: String, nextToken: String? = nil) {
            self.actorId = actorId
            self.maxResults = maxResults
            self.memoryId = memoryId
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.actorId, key: "actorId")
            try container.encodeIfPresent(self.maxResults, forKey: .maxResults)
            request.encodePath(self.memoryId, key: "memoryId")
            try container.encodeIfPresent(self.nextToken, forKey: .nextToken)
        }

        public func validate(name: String) throws {
            try self.validate(self.actorId, name: "actorId", parent: name, max: 255)
            try self.validate(self.actorId, name: "actorId", parent: name, min: 1)
            try self.validate(self.actorId, name: "actorId", parent: name, pattern: "^[a-zA-Z0-9][a-zA-Z0-9-_/]*$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.memoryId, name: "memoryId", parent: name, min: 12)
            try self.validate(self.memoryId, name: "memoryId", parent: name, pattern: "^[a-zA-Z][a-zA-Z0-9-_]{0,99}-[a-zA-Z0-9]{10}$")
        }

        private enum CodingKeys: String, CodingKey {
            case maxResults = "maxResults"
            case nextToken = "nextToken"
        }
    }

    public struct ListSessionsOutput: AWSDecodableShape {
        /// The token to use in a subsequent request to get the next set of results. This value is null when there are no more results to return.
        public let nextToken: String?
        /// The list of session summaries that match the specified criteria.
        public let sessionSummaries: [SessionSummary]

        @inlinable
        public init(nextToken: String? = nil, sessionSummaries: [SessionSummary]) {
            self.nextToken = nextToken
            self.sessionSummaries = sessionSummaries
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "nextToken"
            case sessionSummaries = "sessionSummaries"
        }
    }

    public struct LiveViewStream: AWSDecodableShape {
        /// The endpoint URL for the live view stream. This URL is used to establish a connection to receive visual updates from the browser session.
        public let streamEndpoint: String?

        @inlinable
        public init(streamEndpoint: String? = nil) {
            self.streamEndpoint = streamEndpoint
        }

        private enum CodingKeys: String, CodingKey {
            case streamEndpoint = "streamEndpoint"
        }
    }

    public struct MemoryRecord: AWSDecodableShape {
        /// The content of the memory record.
        public let content: MemoryContent
        /// The timestamp when the memory record was created.
        public let createdAt: Date
        /// The unique identifier of the memory record.
        public let memoryRecordId: String
        /// The identifier of the memory strategy associated with this record.
        public let memoryStrategyId: String
        /// The namespaces associated with this memory record. Namespaces help organize and categorize memory records.
        public let namespaces: [String]

        @inlinable
        public init(content: MemoryContent, createdAt: Date, memoryRecordId: String, memoryStrategyId: String, namespaces: [String]) {
            self.content = content
            self.createdAt = createdAt
            self.memoryRecordId = memoryRecordId
            self.memoryStrategyId = memoryStrategyId
            self.namespaces = namespaces
        }

        private enum CodingKeys: String, CodingKey {
            case content = "content"
            case createdAt = "createdAt"
            case memoryRecordId = "memoryRecordId"
            case memoryStrategyId = "memoryStrategyId"
            case namespaces = "namespaces"
        }
    }

    public struct MemoryRecordSummary: AWSDecodableShape {
        /// The content of the memory record.
        public let content: MemoryContent
        /// The timestamp when the memory record was created.
        public let createdAt: Date
        /// The unique identifier of the memory record.
        public let memoryRecordId: String
        /// The identifier of the memory strategy associated with this record.
        public let memoryStrategyId: String
        /// The namespaces associated with this memory record.
        public let namespaces: [String]
        /// The relevance score of the memory record when returned as part of a search result. Higher values indicate greater relevance to the search query.
        public let score: Double?

        @inlinable
        public init(content: MemoryContent, createdAt: Date, memoryRecordId: String, memoryStrategyId: String, namespaces: [String], score: Double? = nil) {
            self.content = content
            self.createdAt = createdAt
            self.memoryRecordId = memoryRecordId
            self.memoryStrategyId = memoryStrategyId
            self.namespaces = namespaces
            self.score = score
        }

        private enum CodingKeys: String, CodingKey {
            case content = "content"
            case createdAt = "createdAt"
            case memoryRecordId = "memoryRecordId"
            case memoryStrategyId = "memoryStrategyId"
            case namespaces = "namespaces"
            case score = "score"
        }
    }

    public struct ResourceContent: AWSDecodableShape {
        /// The binary resource content.
        public let blob: AWSBase64Data?
        /// The MIME type of the resource content.
        public let mimeType: String?
        /// The text resource content.
        public let text: String?
        /// The type of resource content.
        public let type: ResourceContentType
        /// The URI of the resource content.
        public let uri: String?

        @inlinable
        public init(blob: AWSBase64Data? = nil, mimeType: String? = nil, text: String? = nil, type: ResourceContentType, uri: String? = nil) {
            self.blob = blob
            self.mimeType = mimeType
            self.text = text
            self.type = type
            self.uri = uri
        }

        private enum CodingKeys: String, CodingKey {
            case blob = "blob"
            case mimeType = "mimeType"
            case text = "text"
            case type = "type"
            case uri = "uri"
        }
    }

    public struct ResourceNotFoundException: AWSDecodableShape {
        public let message: String?

        @inlinable
        public init(message: String? = nil) {
            self.message = message
        }

        private enum CodingKeys: String, CodingKey {
            case message = "message"
        }
    }

    public struct RetrieveMemoryRecordsInput: AWSEncodableShape {
        /// The maximum number of results to return in a single call. Minimum value of 1, maximum value of 100. Default is 20.
        public let maxResults: Int?
        /// The identifier of the memory store from which to retrieve memory records.
        public let memoryId: String
        /// The namespace to filter memory records by. If specified, only memory records in this namespace are searched.
        public let namespace: String
        /// The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.
        public let nextToken: String?
        /// The search criteria to use for finding relevant memory records. This includes the search query, memory strategy ID, and other search parameters.
        public let searchCriteria: SearchCriteria

        @inlinable
        public init(maxResults: Int? = nil, memoryId: String, namespace: String, nextToken: String? = nil, searchCriteria: SearchCriteria) {
            self.maxResults = maxResults
            self.memoryId = memoryId
            self.namespace = namespace
            self.nextToken = nextToken
            self.searchCriteria = searchCriteria
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.maxResults, forKey: .maxResults)
            request.encodePath(self.memoryId, key: "memoryId")
            try container.encode(self.namespace, forKey: .namespace)
            try container.encodeIfPresent(self.nextToken, forKey: .nextToken)
            try container.encode(self.searchCriteria, forKey: .searchCriteria)
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.memoryId, name: "memoryId", parent: name, min: 12)
            try self.validate(self.memoryId, name: "memoryId", parent: name, pattern: "^[a-zA-Z][a-zA-Z0-9-_]{0,99}-[a-zA-Z0-9]{10}$")
            try self.validate(self.namespace, name: "namespace", parent: name, max: 1024)
            try self.validate(self.namespace, name: "namespace", parent: name, min: 1)
            try self.validate(self.namespace, name: "namespace", parent: name, pattern: "^[a-zA-Z0-9/*][a-zA-Z0-9-_/*]*$")
            try self.searchCriteria.validate(name: "\(name).searchCriteria")
        }

        private enum CodingKeys: String, CodingKey {
            case maxResults = "maxResults"
            case namespace = "namespace"
            case nextToken = "nextToken"
            case searchCriteria = "searchCriteria"
        }
    }

    public struct RetrieveMemoryRecordsOutput: AWSDecodableShape {
        /// The list of memory record summaries that match the search criteria, ordered by relevance.
        public let memoryRecordSummaries: [MemoryRecordSummary]
        /// The token to use in a subsequent request to get the next set of results. This value is null when there are no more results to return.
        public let nextToken: String?

        @inlinable
        public init(memoryRecordSummaries: [MemoryRecordSummary], nextToken: String? = nil) {
            self.memoryRecordSummaries = memoryRecordSummaries
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case memoryRecordSummaries = "memoryRecordSummaries"
            case nextToken = "nextToken"
        }
    }

    public struct SearchCriteria: AWSEncodableShape {
        /// The memory strategy identifier to filter memory records by.
        public let memoryStrategyId: String?
        /// The search query to use for finding relevant memory records.
        public let searchQuery: String
        /// The maximum number of top-scoring memory records to return. This value is used for semantic search ranking.
        public let topK: Int?

        @inlinable
        public init(memoryStrategyId: String? = nil, searchQuery: String, topK: Int? = nil) {
            self.memoryStrategyId = memoryStrategyId
            self.searchQuery = searchQuery
            self.topK = topK
        }

        public func validate(name: String) throws {
            try self.validate(self.memoryStrategyId, name: "memoryStrategyId", parent: name, max: 100)
            try self.validate(self.memoryStrategyId, name: "memoryStrategyId", parent: name, min: 1)
            try self.validate(self.memoryStrategyId, name: "memoryStrategyId", parent: name, pattern: "^[a-zA-Z0-9][a-zA-Z0-9-_]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case memoryStrategyId = "memoryStrategyId"
            case searchQuery = "searchQuery"
            case topK = "topK"
        }
    }

    public struct ServiceQuotaExceededException: AWSDecodableShape {
        public let message: String?

        @inlinable
        public init(message: String? = nil) {
            self.message = message
        }

        private enum CodingKeys: String, CodingKey {
            case message = "message"
        }
    }

    public struct SessionSummary: AWSDecodableShape {
        /// The identifier of the actor associated with the session.
        public let actorId: String
        /// The timestamp when the session was created.
        public let createdAt: Date
        /// The unique identifier of the session.
        public let sessionId: String

        @inlinable
        public init(actorId: String, createdAt: Date, sessionId: String) {
            self.actorId = actorId
            self.createdAt = createdAt
            self.sessionId = sessionId
        }

        private enum CodingKeys: String, CodingKey {
            case actorId = "actorId"
            case createdAt = "createdAt"
            case sessionId = "sessionId"
        }
    }

    public struct StartBrowserSessionRequest: AWSEncodableShape {
        /// The unique identifier of the browser to use for this session. This identifier specifies which browser environment to initialize for the session.
        public let browserIdentifier: String
        /// A unique, case-sensitive identifier to ensure that the API request completes no more than one time. If this token matches a previous request, Amazon Bedrock ignores the request, but does not return an error. This parameter helps prevent the creation of duplicate sessions if there are temporary network issues.
        public let clientToken: String?
        /// The name of the browser session. This name helps you identify and manage the session. The name does not need to be unique.
        public let name: String?
        /// The time in seconds after which the session automatically terminates if there is no activity. The default value is 3600 seconds (1 hour). The minimum allowed value is 60 seconds, and the maximum allowed value is 28800 seconds (8 hours).
        public let sessionTimeoutSeconds: Int?
        /// The dimensions of the browser viewport for this session. This determines the visible area of the web content and affects how web pages are rendered. If not specified, Amazon Bedrock uses a default viewport size.
        public let viewPort: ViewPort?

        @inlinable
        public init(browserIdentifier: String, clientToken: String? = StartBrowserSessionRequest.idempotencyToken(), name: String? = nil, sessionTimeoutSeconds: Int? = nil, viewPort: ViewPort? = nil) {
            self.browserIdentifier = browserIdentifier
            self.clientToken = clientToken
            self.name = name
            self.sessionTimeoutSeconds = sessionTimeoutSeconds
            self.viewPort = viewPort
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.browserIdentifier, key: "browserIdentifier")
            try container.encodeIfPresent(self.clientToken, forKey: .clientToken)
            try container.encodeIfPresent(self.name, forKey: .name)
            try container.encodeIfPresent(self.sessionTimeoutSeconds, forKey: .sessionTimeoutSeconds)
            try container.encodeIfPresent(self.viewPort, forKey: .viewPort)
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 256)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 33)
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "^[a-zA-Z0-9](-*[a-zA-Z0-9]){0,256}$")
            try self.validate(self.name, name: "name", parent: name, max: 100)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.sessionTimeoutSeconds, name: "sessionTimeoutSeconds", parent: name, max: 28800)
            try self.validate(self.sessionTimeoutSeconds, name: "sessionTimeoutSeconds", parent: name, min: 1)
            try self.viewPort?.validate(name: "\(name).viewPort")
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "clientToken"
            case name = "name"
            case sessionTimeoutSeconds = "sessionTimeoutSeconds"
            case viewPort = "viewPort"
        }
    }

    public struct StartBrowserSessionResponse: AWSDecodableShape {
        /// The identifier of the browser.
        public let browserIdentifier: String
        /// The timestamp when the browser session was created.
        @CustomCoding<ISO8601DateCoder>
        public var createdAt: Date
        /// The unique identifier of the created browser session.
        public let sessionId: String
        /// The streams associated with this browser session. These include the automation stream and live view stream.
        public let streams: BrowserSessionStream?

        @inlinable
        public init(browserIdentifier: String, createdAt: Date, sessionId: String, streams: BrowserSessionStream? = nil) {
            self.browserIdentifier = browserIdentifier
            self.createdAt = createdAt
            self.sessionId = sessionId
            self.streams = streams
        }

        private enum CodingKeys: String, CodingKey {
            case browserIdentifier = "browserIdentifier"
            case createdAt = "createdAt"
            case sessionId = "sessionId"
            case streams = "streams"
        }
    }

    public struct StartCodeInterpreterSessionRequest: AWSEncodableShape {
        /// A unique, case-sensitive identifier to ensure that the API request completes no more than one time. If this token matches a previous request, Amazon Bedrock ignores the request, but does not return an error. This parameter helps prevent the creation of duplicate sessions if there are temporary network issues.
        public let clientToken: String?
        /// The unique identifier of the code interpreter to use for this session. This identifier specifies which code interpreter environment to initialize for the session.
        public let codeInterpreterIdentifier: String
        /// The name of the code interpreter session. This name helps you identify and manage the session. The name does not need to be unique.
        public let name: String?
        /// The time in seconds after which the session automatically terminates if there is no activity. The default value is 3600 seconds (1 hour). The minimum allowed value is 60 seconds, and the maximum allowed value is 28800 seconds (8 hours).
        public let sessionTimeoutSeconds: Int?

        @inlinable
        public init(clientToken: String? = StartCodeInterpreterSessionRequest.idempotencyToken(), codeInterpreterIdentifier: String, name: String? = nil, sessionTimeoutSeconds: Int? = nil) {
            self.clientToken = clientToken
            self.codeInterpreterIdentifier = codeInterpreterIdentifier
            self.name = name
            self.sessionTimeoutSeconds = sessionTimeoutSeconds
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.clientToken, forKey: .clientToken)
            request.encodePath(self.codeInterpreterIdentifier, key: "codeInterpreterIdentifier")
            try container.encodeIfPresent(self.name, forKey: .name)
            try container.encodeIfPresent(self.sessionTimeoutSeconds, forKey: .sessionTimeoutSeconds)
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 256)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 33)
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "^[a-zA-Z0-9](-*[a-zA-Z0-9]){0,256}$")
            try self.validate(self.name, name: "name", parent: name, max: 100)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.sessionTimeoutSeconds, name: "sessionTimeoutSeconds", parent: name, max: 28800)
            try self.validate(self.sessionTimeoutSeconds, name: "sessionTimeoutSeconds", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "clientToken"
            case name = "name"
            case sessionTimeoutSeconds = "sessionTimeoutSeconds"
        }
    }

    public struct StartCodeInterpreterSessionResponse: AWSDecodableShape {
        /// The identifier of the code interpreter.
        public let codeInterpreterIdentifier: String
        /// The time at which the code interpreter session was created.
        @CustomCoding<ISO8601DateCoder>
        public var createdAt: Date
        /// The unique identifier of the created code interpreter session.
        public let sessionId: String

        @inlinable
        public init(codeInterpreterIdentifier: String, createdAt: Date, sessionId: String) {
            self.codeInterpreterIdentifier = codeInterpreterIdentifier
            self.createdAt = createdAt
            self.sessionId = sessionId
        }

        private enum CodingKeys: String, CodingKey {
            case codeInterpreterIdentifier = "codeInterpreterIdentifier"
            case createdAt = "createdAt"
            case sessionId = "sessionId"
        }
    }

    public struct StopBrowserSessionRequest: AWSEncodableShape {
        /// The unique identifier of the browser associated with the session.
        public let browserIdentifier: String
        /// A unique, case-sensitive identifier to ensure that the API request completes no more than one time. If this token matches a previous request, Amazon Bedrock ignores the request, but does not return an error.
        public let clientToken: String?
        /// The unique identifier of the browser session to stop.
        public let sessionId: String

        @inlinable
        public init(browserIdentifier: String, clientToken: String? = StopBrowserSessionRequest.idempotencyToken(), sessionId: String) {
            self.browserIdentifier = browserIdentifier
            self.clientToken = clientToken
            self.sessionId = sessionId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.browserIdentifier, key: "browserIdentifier")
            try container.encodeIfPresent(self.clientToken, forKey: .clientToken)
            request.encodeQuery(self.sessionId, key: "sessionId")
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 256)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 33)
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "^[a-zA-Z0-9](-*[a-zA-Z0-9]){0,256}$")
            try self.validate(self.sessionId, name: "sessionId", parent: name, pattern: "^[0-9a-zA-Z]{1,40}$")
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "clientToken"
        }
    }

    public struct StopBrowserSessionResponse: AWSDecodableShape {
        /// The identifier of the browser.
        public let browserIdentifier: String
        /// The time at which the browser session was last updated.
        @CustomCoding<ISO8601DateCoder>
        public var lastUpdatedAt: Date
        /// The identifier of the browser session.
        public let sessionId: String

        @inlinable
        public init(browserIdentifier: String, lastUpdatedAt: Date, sessionId: String) {
            self.browserIdentifier = browserIdentifier
            self.lastUpdatedAt = lastUpdatedAt
            self.sessionId = sessionId
        }

        private enum CodingKeys: String, CodingKey {
            case browserIdentifier = "browserIdentifier"
            case lastUpdatedAt = "lastUpdatedAt"
            case sessionId = "sessionId"
        }
    }

    public struct StopCodeInterpreterSessionRequest: AWSEncodableShape {
        /// A unique, case-sensitive identifier to ensure that the API request completes no more than one time. If this token matches a previous request, Amazon Bedrock ignores the request, but does not return an error.
        public let clientToken: String?
        /// The unique identifier of the code interpreter associated with the session.
        public let codeInterpreterIdentifier: String
        /// The unique identifier of the code interpreter session to stop.
        public let sessionId: String

        @inlinable
        public init(clientToken: String? = StopCodeInterpreterSessionRequest.idempotencyToken(), codeInterpreterIdentifier: String, sessionId: String) {
            self.clientToken = clientToken
            self.codeInterpreterIdentifier = codeInterpreterIdentifier
            self.sessionId = sessionId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.clientToken, forKey: .clientToken)
            request.encodePath(self.codeInterpreterIdentifier, key: "codeInterpreterIdentifier")
            request.encodeQuery(self.sessionId, key: "sessionId")
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 256)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 33)
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "^[a-zA-Z0-9](-*[a-zA-Z0-9]){0,256}$")
            try self.validate(self.sessionId, name: "sessionId", parent: name, pattern: "^[0-9a-zA-Z]{1,40}$")
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "clientToken"
        }
    }

    public struct StopCodeInterpreterSessionResponse: AWSDecodableShape {
        /// The identifier of the code interpreter.
        public let codeInterpreterIdentifier: String
        /// The timestamp when the code interpreter session was last updated.
        @CustomCoding<ISO8601DateCoder>
        public var lastUpdatedAt: Date
        /// The identifier of the code interpreter session.
        public let sessionId: String

        @inlinable
        public init(codeInterpreterIdentifier: String, lastUpdatedAt: Date, sessionId: String) {
            self.codeInterpreterIdentifier = codeInterpreterIdentifier
            self.lastUpdatedAt = lastUpdatedAt
            self.sessionId = sessionId
        }

        private enum CodingKeys: String, CodingKey {
            case codeInterpreterIdentifier = "codeInterpreterIdentifier"
            case lastUpdatedAt = "lastUpdatedAt"
            case sessionId = "sessionId"
        }
    }

    public struct ThrottlingException: AWSDecodableShape {
        public let message: String?

        @inlinable
        public init(message: String? = nil) {
            self.message = message
        }

        private enum CodingKeys: String, CodingKey {
            case message = "message"
        }
    }

    public struct ToolArguments: AWSEncodableShape {
        /// Whether to clear the context for the tool.
        public let clearContext: Bool?
        /// The code to execute in a code interpreter session. This is the source code in the specified programming language that will be executed by the code interpreter.
        public let code: String?
        /// The command to execute with the tool.
        public let command: String?
        /// The content for the tool operation.
        public let content: [InputContentBlock]?
        /// The directory path for the tool operation.
        public let directoryPath: String?
        /// The programming language of the code to execute. This tells the code interpreter which language runtime to use for execution. Common values include 'python', 'javascript', and 'r'.
        public let language: ProgrammingLanguage?
        /// The path for the tool operation.
        public let path: String?
        /// The paths for the tool operation.
        public let paths: [String]?
        /// The identifier of the task for the tool operation.
        public let taskId: String?

        @inlinable
        public init(clearContext: Bool? = nil, code: String? = nil, command: String? = nil, content: [InputContentBlock]? = nil, directoryPath: String? = nil, language: ProgrammingLanguage? = nil, path: String? = nil, paths: [String]? = nil, taskId: String? = nil) {
            self.clearContext = clearContext
            self.code = code
            self.command = command
            self.content = content
            self.directoryPath = directoryPath
            self.language = language
            self.path = path
            self.paths = paths
            self.taskId = taskId
        }

        public func validate(name: String) throws {
            try self.validate(self.code, name: "code", parent: name, max: 100000000)
            try self.validate(self.command, name: "command", parent: name, max: 100000000)
            try self.content?.forEach {
                try $0.validate(name: "\(name).content[]")
            }
            try self.validate(self.directoryPath, name: "directoryPath", parent: name, max: 100000000)
            try self.validate(self.path, name: "path", parent: name, max: 100000000)
            try self.paths?.forEach {
                try validate($0, name: "paths[]", parent: name, max: 100000000)
            }
            try self.validate(self.taskId, name: "taskId", parent: name, max: 100000000)
        }

        private enum CodingKeys: String, CodingKey {
            case clearContext = "clearContext"
            case code = "code"
            case command = "command"
            case content = "content"
            case directoryPath = "directoryPath"
            case language = "language"
            case path = "path"
            case paths = "paths"
            case taskId = "taskId"
        }
    }

    public struct ToolResultStructuredContent: AWSDecodableShape {
        /// The execution time of the tool operation in milliseconds.
        public let executionTime: Double?
        /// The exit code from the tool execution.
        public let exitCode: Int?
        /// The standard error output from the tool execution.
        public let stderr: String?
        /// The standard output from the tool execution.
        public let stdout: String?
        /// The identifier of the task that produced the result.
        public let taskId: String?
        /// The status of the task that produced the result.
        public let taskStatus: TaskStatus?

        @inlinable
        public init(executionTime: Double? = nil, exitCode: Int? = nil, stderr: String? = nil, stdout: String? = nil, taskId: String? = nil, taskStatus: TaskStatus? = nil) {
            self.executionTime = executionTime
            self.exitCode = exitCode
            self.stderr = stderr
            self.stdout = stdout
            self.taskId = taskId
            self.taskStatus = taskStatus
        }

        private enum CodingKeys: String, CodingKey {
            case executionTime = "executionTime"
            case exitCode = "exitCode"
            case stderr = "stderr"
            case stdout = "stdout"
            case taskId = "taskId"
            case taskStatus = "taskStatus"
        }
    }

    public struct UpdateBrowserStreamRequest: AWSEncodableShape {
        /// The identifier of the browser.
        public let browserIdentifier: String
        /// A unique, case-sensitive identifier to ensure that the operation completes no more than one time. If this token matches a previous request, Amazon Bedrock ignores the request, but does not return an error.
        public let clientToken: String?
        /// The identifier of the browser session.
        public let sessionId: String
        /// The update to apply to the browser stream.
        public let streamUpdate: StreamUpdate

        @inlinable
        public init(browserIdentifier: String, clientToken: String? = UpdateBrowserStreamRequest.idempotencyToken(), sessionId: String, streamUpdate: StreamUpdate) {
            self.browserIdentifier = browserIdentifier
            self.clientToken = clientToken
            self.sessionId = sessionId
            self.streamUpdate = streamUpdate
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.browserIdentifier, key: "browserIdentifier")
            try container.encodeIfPresent(self.clientToken, forKey: .clientToken)
            request.encodeQuery(self.sessionId, key: "sessionId")
            try container.encode(self.streamUpdate, forKey: .streamUpdate)
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 256)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 33)
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "^[a-zA-Z0-9](-*[a-zA-Z0-9]){0,256}$")
            try self.validate(self.sessionId, name: "sessionId", parent: name, pattern: "^[0-9a-zA-Z]{1,40}$")
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "clientToken"
            case streamUpdate = "streamUpdate"
        }
    }

    public struct UpdateBrowserStreamResponse: AWSDecodableShape {
        /// The identifier of the browser.
        public let browserIdentifier: String
        /// The identifier of the browser session.
        public let sessionId: String
        public let streams: BrowserSessionStream
        /// The time at which the browser stream was updated.
        @CustomCoding<ISO8601DateCoder>
        public var updatedAt: Date

        @inlinable
        public init(browserIdentifier: String, sessionId: String, streams: BrowserSessionStream, updatedAt: Date) {
            self.browserIdentifier = browserIdentifier
            self.sessionId = sessionId
            self.streams = streams
            self.updatedAt = updatedAt
        }

        private enum CodingKeys: String, CodingKey {
            case browserIdentifier = "browserIdentifier"
            case sessionId = "sessionId"
            case streams = "streams"
            case updatedAt = "updatedAt"
        }
    }

    public struct ValidationException: AWSErrorShape {
        public let fieldList: [ValidationExceptionField]?
        public let message: String
        public let reason: ValidationExceptionReason

        @inlinable
        public init(fieldList: [ValidationExceptionField]? = nil, message: String, reason: ValidationExceptionReason) {
            self.fieldList = fieldList
            self.message = message
            self.reason = reason
        }

        private enum CodingKeys: String, CodingKey {
            case fieldList = "fieldList"
            case message = "message"
            case reason = "reason"
        }
    }

    public struct ValidationExceptionField: AWSDecodableShape {
        /// A message describing why this field failed validation.
        public let message: String
        /// The name of the field.
        public let name: String

        @inlinable
        public init(message: String, name: String) {
            self.message = message
            self.name = name
        }

        private enum CodingKeys: String, CodingKey {
            case message = "message"
            case name = "name"
        }
    }

    public struct ViewPort: AWSEncodableShape & AWSDecodableShape {
        /// The height of the viewport in pixels. This value determines the vertical dimension of the visible area. Valid values range from 600 to 1080 pixels.
        public let height: Int
        /// The width of the viewport in pixels. This value determines the horizontal dimension of the visible area. Valid values range from 800 to 1920 pixels.
        public let width: Int

        @inlinable
        public init(height: Int, width: Int) {
            self.height = height
            self.width = width
        }

        public func validate(name: String) throws {
            try self.validate(self.height, name: "height", parent: name, max: 2160)
            try self.validate(self.height, name: "height", parent: name, min: 240)
            try self.validate(self.width, name: "width", parent: name, max: 3840)
            try self.validate(self.width, name: "width", parent: name, min: 320)
        }

        private enum CodingKeys: String, CodingKey {
            case height = "height"
            case width = "width"
        }
    }

    public struct Content: AWSEncodableShape & AWSDecodableShape {
        /// The text content of the memory item.
        public let text: String?

        @inlinable
        public init(text: String? = nil) {
            self.text = text
        }

        private enum CodingKeys: String, CodingKey {
            case text = "text"
        }
    }

    public struct MemoryContent: AWSDecodableShape {
        /// The text content of the memory record.
        public let text: String?

        @inlinable
        public init(text: String? = nil) {
            self.text = text
        }

        private enum CodingKeys: String, CodingKey {
            case text = "text"
        }
    }

    public struct StreamUpdate: AWSEncodableShape {
        /// The update to an automation stream.
        public let automationStreamUpdate: AutomationStreamUpdate?

        @inlinable
        public init(automationStreamUpdate: AutomationStreamUpdate? = nil) {
            self.automationStreamUpdate = automationStreamUpdate
        }

        private enum CodingKeys: String, CodingKey {
            case automationStreamUpdate = "automationStreamUpdate"
        }
    }
}

// MARK: - Errors

/// Error enum for BedrockAgentCore
public struct BedrockAgentCoreErrorType: AWSErrorType {
    enum Code: String {
        case accessDeniedException = "AccessDeniedException"
        case conflictException = "ConflictException"
        case internalServerException = "InternalServerException"
        case invalidInputException = "InvalidInputException"
        case resourceNotFoundException = "ResourceNotFoundException"
        case runtimeClientError = "RuntimeClientError"
        case serviceException = "ServiceException"
        case serviceQuotaExceededException = "ServiceQuotaExceededException"
        case throttledException = "ThrottledException"
        case throttlingException = "ThrottlingException"
        case unauthorizedException = "UnauthorizedException"
        case validationException = "ValidationException"
    }

    private let error: Code
    public let context: AWSErrorContext?

    /// initialize BedrockAgentCore
    public init?(errorCode: String, context: AWSErrorContext) {
        guard let error = Code(rawValue: errorCode) else { return nil }
        self.error = error
        self.context = context
    }

    internal init(_ error: Code) {
        self.error = error
        self.context = nil
    }

    /// return error code string
    public var errorCode: String { self.error.rawValue }

    /// The exception that occurs when you do not have sufficient permissions to perform an action. Verify that your IAM policy includes the necessary permissions for the operation you are trying to perform.
    public static var accessDeniedException: Self { .init(.accessDeniedException) }
    /// The exception that occurs when the request conflicts with the current state of the resource. This can happen when trying to modify a resource that is currently being modified by another request, or when trying to create a resource that already exists.
    public static var conflictException: Self { .init(.conflictException) }
    /// The exception that occurs when the service encounters an unexpected internal error. This is a temporary condition that will resolve itself with retries. We recommend implementing exponential backoff retry logic in your application.
    public static var internalServerException: Self { .init(.internalServerException) }
    /// The input fails to satisfy the constraints specified by AgentCore. Check your input values and try again.
    public static var invalidInputException: Self { .init(.invalidInputException) }
    /// The exception that occurs when the specified resource does not exist. This can happen when using an invalid identifier or when trying to access a resource that has been deleted.
    public static var resourceNotFoundException: Self { .init(.resourceNotFoundException) }
    /// The exception that occurs when there is an error in the runtime client. This can happen due to network issues, invalid configuration, or other client-side problems. Check the error message for specific details about the error.
    public static var runtimeClientError: Self { .init(.runtimeClientError) }
    /// The service encountered an internal error. Try your request again later.
    public static var serviceException: Self { .init(.serviceException) }
    /// The exception that occurs when the request would cause a service quota to be exceeded. Review your service quotas and either reduce your request rate or request a quota increase.
    public static var serviceQuotaExceededException: Self { .init(.serviceQuotaExceededException) }
    /// The request was denied due to request throttling. Reduce the frequency of requests and try again.
    public static var throttledException: Self { .init(.throttledException) }
    /// The exception that occurs when the request was denied due to request throttling. This happens when you exceed the allowed request rate for an operation. Reduce the frequency of requests or implement exponential backoff retry logic in your application.
    public static var throttlingException: Self { .init(.throttlingException) }
    /// This exception is thrown when the JWT bearer token is invalid or not found for OAuth bearer token based access
    public static var unauthorizedException: Self { .init(.unauthorizedException) }
    /// The exception that occurs when the input fails to satisfy the constraints specified by the service. Check the error message for details about which input parameter is invalid and correct your request.
    public static var validationException: Self { .init(.validationException) }
}

extension BedrockAgentCoreErrorType: AWSServiceErrorType {
    public static let errorCodeMap: [String: AWSErrorShape.Type] = [
        "ValidationException": BedrockAgentCore.ValidationException.self
    ]
}

extension BedrockAgentCoreErrorType: Equatable {
    public static func == (lhs: BedrockAgentCoreErrorType, rhs: BedrockAgentCoreErrorType) -> Bool {
        lhs.error == rhs.error
    }
}

extension BedrockAgentCoreErrorType: CustomStringConvertible {
    public var description: String {
        return "\(self.error.rawValue): \(self.message ?? "")"
    }
}
