//===----------------------------------------------------------------------===//
//
// This source file is part of the Soto for AWS open source project
//
// Copyright (c) 2017-2024 the Soto project authors
// Licensed under Apache License v2.0
//
// See LICENSE.txt for license information
// See CONTRIBUTORS.txt for the list of Soto project authors
//
// SPDX-License-Identifier: Apache-2.0
//
//===----------------------------------------------------------------------===//

// THIS FILE IS AUTOMATICALLY GENERATED by https://github.com/soto-project/soto-codegenerator.
// DO NOT EDIT.

#if canImport(FoundationEssentials)
import FoundationEssentials
#else
import Foundation
#endif
@_exported import SotoCore

/// Service object for interacting with AWS BedrockAgentCore service.
///
///  Amazon Bedrock AgentCore is in preview release and is subject to change.  Data plane operations for Amazon Bedrock AgentCore.
public struct BedrockAgentCore: AWSService {
    // MARK: Member variables

    /// Client used for communication with AWS
    public let client: AWSClient
    /// Service configuration
    public let config: AWSServiceConfig

    // MARK: Initialization

    /// Initialize the BedrockAgentCore client
    /// - parameters:
    ///     - client: AWSClient used to process requests
    ///     - region: Region of server you want to communicate with. This will override the partition parameter.
    ///     - partition: AWS partition where service resides, standard (.aws), china (.awscn), government (.awsusgov).
    ///     - endpoint: Custom endpoint URL to use instead of standard AWS servers
    ///     - middleware: Middleware chain used to edit requests before they are sent and responses before they are decoded 
    ///     - timeout: Timeout value for HTTP requests
    ///     - byteBufferAllocator: Allocator for ByteBuffers
    ///     - options: Service options
    public init(
        client: AWSClient,
        region: SotoCore.Region? = nil,
        partition: AWSPartition = .aws,
        endpoint: String? = nil,
        middleware: AWSMiddlewareProtocol? = nil,
        timeout: TimeAmount? = nil,
        byteBufferAllocator: ByteBufferAllocator = ByteBufferAllocator(),
        options: AWSServiceConfig.Options = []
    ) {
        self.client = client
        self.config = AWSServiceConfig(
            region: region,
            partition: region?.partition ?? partition,
            serviceName: "BedrockAgentCore",
            serviceIdentifier: "bedrock-agentcore",
            serviceProtocol: .restjson,
            apiVersion: "2024-02-28",
            endpoint: endpoint,
            errorType: BedrockAgentCoreErrorType.self,
            middleware: middleware,
            timeout: timeout,
            byteBufferAllocator: byteBufferAllocator,
            options: options
        )
    }





    // MARK: API Calls

    /// Creates an event in a memory store. Events represent interactions or activities that occur within a session and are associated with specific actors. To use this operation, you must have the genesismemory:CreateEvent permission. This operation is subject to request rate limiting.
    @Sendable
    @inlinable
    public func createEvent(_ input: CreateEventInput, logger: Logger = AWSClient.loggingDisabled) async throws -> CreateEventOutput {
        try await self.client.execute(
            operation: "CreateEvent", 
            path: "/memories/{memoryId}/events", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Creates an event in a memory store. Events represent interactions or activities that occur within a session and are associated with specific actors. To use this operation, you must have the genesismemory:CreateEvent permission. This operation is subject to request rate limiting.
    ///
    /// Parameters:
    ///   - actorId: The identifier of the actor associated with this event. An actor represents an entity that participates in sessions and generates events.
    ///   - branch: The branch information for this event. Branches allow for organizing events into different conversation threads or paths.
    ///   - clientToken: A unique, case-sensitive identifier to ensure that the operation completes no more than one time. If this token matches a previous request, AgentCore ignores the request, but does not return an error.
    ///   - eventTimestamp: The timestamp when the event occurred. If not specified, the current time is used.
    ///   - memoryId: The identifier of the memory store in which to create the event.
    ///   - payload: The content payload of the event. This can include conversational data or binary content.
    ///   - sessionId: The identifier of the session in which this event occurs. A session represents a sequence of related events.
    ///   - logger: Logger use during operation
    @inlinable
    public func createEvent(
        actorId: String,
        branch: Branch? = nil,
        clientToken: String? = CreateEventInput.idempotencyToken(),
        eventTimestamp: Date,
        memoryId: String,
        payload: [PayloadType],
        sessionId: String? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> CreateEventOutput {
        let input = CreateEventInput(
            actorId: actorId, 
            branch: branch, 
            clientToken: clientToken, 
            eventTimestamp: eventTimestamp, 
            memoryId: memoryId, 
            payload: payload, 
            sessionId: sessionId
        )
        return try await self.createEvent(input, logger: logger)
    }

    /// Deletes an event from a memory store. When you delete an event, it is permanently removed. To use this operation, you must have the genesismemory:DeleteEvent permission.
    @Sendable
    @inlinable
    public func deleteEvent(_ input: DeleteEventInput, logger: Logger = AWSClient.loggingDisabled) async throws -> DeleteEventOutput {
        try await self.client.execute(
            operation: "DeleteEvent", 
            path: "/memories/{memoryId}/actor/{actorId}/sessions/{sessionId}/events/{eventId}", 
            httpMethod: .DELETE, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Deletes an event from a memory store. When you delete an event, it is permanently removed. To use this operation, you must have the genesismemory:DeleteEvent permission.
    ///
    /// Parameters:
    ///   - actorId: The identifier of the actor associated with the event to delete.
    ///   - eventId: The identifier of the event to delete.
    ///   - memoryId: The identifier of the memory store from which to delete the event.
    ///   - sessionId: The identifier of the session containing the event to delete.
    ///   - logger: Logger use during operation
    @inlinable
    public func deleteEvent(
        actorId: String,
        eventId: String,
        memoryId: String,
        sessionId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> DeleteEventOutput {
        let input = DeleteEventInput(
            actorId: actorId, 
            eventId: eventId, 
            memoryId: memoryId, 
            sessionId: sessionId
        )
        return try await self.deleteEvent(input, logger: logger)
    }

    /// Deletes a memory record from a memory store. When you delete a memory record, it is permanently removed. To use this operation, you must have the genesismemory:DeleteMemoryRecord permission.
    @Sendable
    @inlinable
    public func deleteMemoryRecord(_ input: DeleteMemoryRecordInput, logger: Logger = AWSClient.loggingDisabled) async throws -> DeleteMemoryRecordOutput {
        try await self.client.execute(
            operation: "DeleteMemoryRecord", 
            path: "/memories/{memoryId}/memoryRecords/{memoryRecordId}", 
            httpMethod: .DELETE, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Deletes a memory record from a memory store. When you delete a memory record, it is permanently removed. To use this operation, you must have the genesismemory:DeleteMemoryRecord permission.
    ///
    /// Parameters:
    ///   - memoryId: The identifier of the memory store from which to delete the memory record.
    ///   - memoryRecordId: The identifier of the memory record to delete.
    ///   - logger: Logger use during operation
    @inlinable
    public func deleteMemoryRecord(
        memoryId: String,
        memoryRecordId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> DeleteMemoryRecordOutput {
        let input = DeleteMemoryRecordInput(
            memoryId: memoryId, 
            memoryRecordId: memoryRecordId
        )
        return try await self.deleteMemoryRecord(input, logger: logger)
    }

    /// Retrieves detailed information about a specific browser session in Amazon Bedrock. This operation returns the session's configuration, current status, associated streams, and metadata. To get a browser session, you must specify both the browser identifier and the session ID. The response includes information about the session's viewport configuration, timeout settings, and stream endpoints. The following operations are related to GetBrowserSession:    StartBrowserSession     ListBrowserSessions     StopBrowserSession
    @Sendable
    @inlinable
    public func getBrowserSession(_ input: GetBrowserSessionRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> GetBrowserSessionResponse {
        try await self.client.execute(
            operation: "GetBrowserSession", 
            path: "/browsers/{browserIdentifier}/sessions/get", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Retrieves detailed information about a specific browser session in Amazon Bedrock. This operation returns the session's configuration, current status, associated streams, and metadata. To get a browser session, you must specify both the browser identifier and the session ID. The response includes information about the session's viewport configuration, timeout settings, and stream endpoints. The following operations are related to GetBrowserSession:    StartBrowserSession     ListBrowserSessions     StopBrowserSession
    ///
    /// Parameters:
    ///   - browserIdentifier: The unique identifier of the browser associated with the session.
    ///   - sessionId: The unique identifier of the browser session to retrieve.
    ///   - logger: Logger use during operation
    @inlinable
    public func getBrowserSession(
        browserIdentifier: String,
        sessionId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> GetBrowserSessionResponse {
        let input = GetBrowserSessionRequest(
            browserIdentifier: browserIdentifier, 
            sessionId: sessionId
        )
        return try await self.getBrowserSession(input, logger: logger)
    }

    /// Retrieves detailed information about a specific code interpreter session in Amazon Bedrock. This operation returns the session's configuration, current status, and metadata. To get a code interpreter session, you must specify both the code interpreter identifier and the session ID. The response includes information about the session's timeout settings and current status. The following operations are related to GetCodeInterpreterSession:    StartCodeInterpreterSession     ListCodeInterpreterSessions     StopCodeInterpreterSession
    @Sendable
    @inlinable
    public func getCodeInterpreterSession(_ input: GetCodeInterpreterSessionRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> GetCodeInterpreterSessionResponse {
        try await self.client.execute(
            operation: "GetCodeInterpreterSession", 
            path: "/code-interpreters/{codeInterpreterIdentifier}/sessions/get", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Retrieves detailed information about a specific code interpreter session in Amazon Bedrock. This operation returns the session's configuration, current status, and metadata. To get a code interpreter session, you must specify both the code interpreter identifier and the session ID. The response includes information about the session's timeout settings and current status. The following operations are related to GetCodeInterpreterSession:    StartCodeInterpreterSession     ListCodeInterpreterSessions     StopCodeInterpreterSession
    ///
    /// Parameters:
    ///   - codeInterpreterIdentifier: The unique identifier of the code interpreter associated with the session.
    ///   - sessionId: The unique identifier of the code interpreter session to retrieve.
    ///   - logger: Logger use during operation
    @inlinable
    public func getCodeInterpreterSession(
        codeInterpreterIdentifier: String,
        sessionId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> GetCodeInterpreterSessionResponse {
        let input = GetCodeInterpreterSessionRequest(
            codeInterpreterIdentifier: codeInterpreterIdentifier, 
            sessionId: sessionId
        )
        return try await self.getCodeInterpreterSession(input, logger: logger)
    }

    /// Retrieves information about a specific event in a memory store. To use this operation, you must have the genesismemory:GetEvent permission.
    @Sendable
    @inlinable
    public func getEvent(_ input: GetEventInput, logger: Logger = AWSClient.loggingDisabled) async throws -> GetEventOutput {
        try await self.client.execute(
            operation: "GetEvent", 
            path: "/memories/{memoryId}/actor/{actorId}/sessions/{sessionId}/events/{eventId}", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Retrieves information about a specific event in a memory store. To use this operation, you must have the genesismemory:GetEvent permission.
    ///
    /// Parameters:
    ///   - actorId: The identifier of the actor associated with the event.
    ///   - eventId: The identifier of the event to retrieve.
    ///   - memoryId: The identifier of the memory store containing the event.
    ///   - sessionId: The identifier of the session containing the event.
    ///   - logger: Logger use during operation
    @inlinable
    public func getEvent(
        actorId: String,
        eventId: String,
        memoryId: String,
        sessionId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> GetEventOutput {
        let input = GetEventInput(
            actorId: actorId, 
            eventId: eventId, 
            memoryId: memoryId, 
            sessionId: sessionId
        )
        return try await self.getEvent(input, logger: logger)
    }

    /// Retrieves a specific memory record from a memory store. To use this operation, you must have the genesismemory:GetMemoryRecord permission.
    @Sendable
    @inlinable
    public func getMemoryRecord(_ input: GetMemoryRecordInput, logger: Logger = AWSClient.loggingDisabled) async throws -> GetMemoryRecordOutput {
        try await self.client.execute(
            operation: "GetMemoryRecord", 
            path: "/memories/{memoryId}/memoryRecord/{memoryRecordId}", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Retrieves a specific memory record from a memory store. To use this operation, you must have the genesismemory:GetMemoryRecord permission.
    ///
    /// Parameters:
    ///   - memoryId: The identifier of the memory store containing the memory record.
    ///   - memoryRecordId: The identifier of the memory record to retrieve.
    ///   - logger: Logger use during operation
    @inlinable
    public func getMemoryRecord(
        memoryId: String,
        memoryRecordId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> GetMemoryRecordOutput {
        let input = GetMemoryRecordInput(
            memoryId: memoryId, 
            memoryRecordId: memoryRecordId
        )
        return try await self.getMemoryRecord(input, logger: logger)
    }

    /// Retrieves an API Key associated with an API Key Credential Provider
    @Sendable
    @inlinable
    public func getResourceApiKey(_ input: GetResourceApiKeyRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> GetResourceApiKeyResponse {
        try await self.client.execute(
            operation: "GetResourceApiKey", 
            path: "/identities/api-key", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Retrieves an API Key associated with an API Key Credential Provider
    ///
    /// Parameters:
    ///   - resourceCredentialProviderName: The credential provider name of the resource you are retrieving the API Key of.
    ///   - workloadIdentityToken: The identity token of the workload you want to get the API Key of.
    ///   - logger: Logger use during operation
    @inlinable
    public func getResourceApiKey(
        resourceCredentialProviderName: String,
        workloadIdentityToken: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> GetResourceApiKeyResponse {
        let input = GetResourceApiKeyRequest(
            resourceCredentialProviderName: resourceCredentialProviderName, 
            workloadIdentityToken: workloadIdentityToken
        )
        return try await self.getResourceApiKey(input, logger: logger)
    }

    /// Reaturns the Oauth2Token of the provided resource
    @Sendable
    @inlinable
    public func getResourceOauth2Token(_ input: GetResourceOauth2TokenRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> GetResourceOauth2TokenResponse {
        try await self.client.execute(
            operation: "GetResourceOauth2Token", 
            path: "/identities/oauth2/token", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Reaturns the Oauth2Token of the provided resource
    ///
    /// Parameters:
    ///   - customParameters: Gives the ability to send extra/custom parameters to the resource credentials provider during the authorization process. Standard OAuth2 flow parameters will not be overriden.
    ///   - forceAuthentication: If true, always initiate a new 3LO flow
    ///   - oauth2Flow: The type of flow to be performed
    ///   - resourceCredentialProviderName: Reference to the credential provider
    ///   - resourceOauth2ReturnUrl: Callback url to redirect after token retrieval completes. Should be one of the provideded urls during WorkloadIdentity creation
    ///   - scopes: The OAuth scopes requested
    ///   - userId: The user ID of the user you're retrieving the token on behalf of.
    ///   - workloadIdentityToken: The identity token of the workload you want to retrive the Oauth2 Token of.
    ///   - logger: Logger use during operation
    @inlinable
    public func getResourceOauth2Token(
        customParameters: [String: String]? = nil,
        forceAuthentication: Bool? = nil,
        oauth2Flow: Oauth2FlowType,
        resourceCredentialProviderName: String,
        resourceOauth2ReturnUrl: String? = nil,
        scopes: [String],
        userId: String? = nil,
        workloadIdentityToken: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> GetResourceOauth2TokenResponse {
        let input = GetResourceOauth2TokenRequest(
            customParameters: customParameters, 
            forceAuthentication: forceAuthentication, 
            oauth2Flow: oauth2Flow, 
            resourceCredentialProviderName: resourceCredentialProviderName, 
            resourceOauth2ReturnUrl: resourceOauth2ReturnUrl, 
            scopes: scopes, 
            userId: userId, 
            workloadIdentityToken: workloadIdentityToken
        )
        return try await self.getResourceOauth2Token(input, logger: logger)
    }

    /// Obtains an Workload access token for agentic workloads not acting on behalf of user.
    @Sendable
    @inlinable
    public func getWorkloadAccessToken(_ input: GetWorkloadAccessTokenRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> GetWorkloadAccessTokenResponse {
        try await self.client.execute(
            operation: "GetWorkloadAccessToken", 
            path: "/identities/GetWorkloadAccessToken", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Obtains an Workload access token for agentic workloads not acting on behalf of user.
    ///
    /// Parameters:
    ///   - workloadName: Unique identifier for the registered agent
    ///   - logger: Logger use during operation
    @inlinable
    public func getWorkloadAccessToken(
        workloadName: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> GetWorkloadAccessTokenResponse {
        let input = GetWorkloadAccessTokenRequest(
            workloadName: workloadName
        )
        return try await self.getWorkloadAccessToken(input, logger: logger)
    }

    /// Obtains an Workload access token for agentic workloads acting on behalf of user with JWT token
    @Sendable
    @inlinable
    public func getWorkloadAccessTokenForJWT(_ input: GetWorkloadAccessTokenForJWTRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> GetWorkloadAccessTokenForJWTResponse {
        try await self.client.execute(
            operation: "GetWorkloadAccessTokenForJWT", 
            path: "/identities/GetWorkloadAccessTokenForJWT", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Obtains an Workload access token for agentic workloads acting on behalf of user with JWT token
    ///
    /// Parameters:
    ///   - userToken: OAuth2 token issued by the user's identity provider
    ///   - workloadName: Unique identifier for the registered agent
    ///   - logger: Logger use during operation
    @inlinable
    public func getWorkloadAccessTokenForJWT(
        userToken: String,
        workloadName: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> GetWorkloadAccessTokenForJWTResponse {
        let input = GetWorkloadAccessTokenForJWTRequest(
            userToken: userToken, 
            workloadName: workloadName
        )
        return try await self.getWorkloadAccessTokenForJWT(input, logger: logger)
    }

    /// Obtains an Workload access token for agentic workloads acting on behalf of user with User Id.
    @Sendable
    @inlinable
    public func getWorkloadAccessTokenForUserId(_ input: GetWorkloadAccessTokenForUserIdRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> GetWorkloadAccessTokenForUserIdResponse {
        try await self.client.execute(
            operation: "GetWorkloadAccessTokenForUserId", 
            path: "/identities/GetWorkloadAccessTokenForUserId", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Obtains an Workload access token for agentic workloads acting on behalf of user with User Id.
    ///
    /// Parameters:
    ///   - userId: The user id of the user you are retrieving the access token for.
    ///   - workloadName: The name of the worklaod you want to get the access token of.
    ///   - logger: Logger use during operation
    @inlinable
    public func getWorkloadAccessTokenForUserId(
        userId: String,
        workloadName: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> GetWorkloadAccessTokenForUserIdResponse {
        let input = GetWorkloadAccessTokenForUserIdRequest(
            userId: userId, 
            workloadName: workloadName
        )
        return try await self.getWorkloadAccessTokenForUserId(input, logger: logger)
    }

    /// Sends a request to an agent runtime in Amazon Bedrock and receives responses in real-time. The agent processes the request using the configured foundation model and any associated knowledge bases or action groups. To invoke an agent runtime, you must specify the agent runtime ARN and provide a payload containing your request. You can optionally specify a qualifier to target a specific version or alias of the agent. This operation supports streaming responses, allowing you to receive partial responses as they become available. We recommend using pagination to ensure that the operation returns quickly and successfully when processing large responses.
    @Sendable
    @inlinable
    public func invokeAgentRuntime(_ input: InvokeAgentRuntimeRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> InvokeAgentRuntimeResponse {
        try await self.client.execute(
            operation: "InvokeAgentRuntime", 
            path: "/runtimes/{agentRuntimeArn}/invocations", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Sends a request to an agent runtime in Amazon Bedrock and receives responses in real-time. The agent processes the request using the configured foundation model and any associated knowledge bases or action groups. To invoke an agent runtime, you must specify the agent runtime ARN and provide a payload containing your request. You can optionally specify a qualifier to target a specific version or alias of the agent. This operation supports streaming responses, allowing you to receive partial responses as they become available. We recommend using pagination to ensure that the operation returns quickly and successfully when processing large responses.
    ///
    /// Parameters:
    ///   - accept: The desired MIME type for the response from the agent runtime. This tells the agent runtime what format to use for the response data. Common values include application/json for JSON data.
    ///   - agentRuntimeArn: The Amazon Web Services Resource Name (ARN) of the agent runtime to invoke. The ARN uniquely identifies the agent runtime resource in Amazon Bedrock.
    ///   - baggage: Additional context information for distributed tracing.
    ///   - contentType: The MIME type of the input data in the payload. This tells the agent runtime how to interpret the payload data. Common values include application/json for JSON data.
    ///   - mcpProtocolVersion: The version of the MCP protocol being used.
    ///   - mcpSessionId: The identifier of the MCP session.
    ///   - payload: The input data to send to the agent runtime. The format of this data depends on the specific agent configuration and must match the specified content type. For most agents, this is a JSON object containing the user's request.
    ///   - qualifier: The qualifier to use for the agent runtime. This can be a version number or an alias name that points to a specific version. If not specified, Amazon Bedrock uses the default version of the agent runtime.
    ///   - runtimeSessionId: The identifier of the runtime session.
    ///   - runtimeUserId: The identifier of the runtime user.
    ///   - traceId: The trace identifier for request tracking.
    ///   - traceParent: The parent trace information for distributed tracing.
    ///   - traceState: The trace state information for distributed tracing.
    ///   - logger: Logger use during operation
    @inlinable
    public func invokeAgentRuntime(
        accept: String? = nil,
        agentRuntimeArn: String,
        baggage: String? = nil,
        contentType: String? = nil,
        mcpProtocolVersion: String? = nil,
        mcpSessionId: String? = nil,
        payload: AWSHTTPBody,
        qualifier: String? = nil,
        runtimeSessionId: String? = InvokeAgentRuntimeRequest.idempotencyToken(),
        runtimeUserId: String? = nil,
        traceId: String? = nil,
        traceParent: String? = nil,
        traceState: String? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> InvokeAgentRuntimeResponse {
        let input = InvokeAgentRuntimeRequest(
            accept: accept, 
            agentRuntimeArn: agentRuntimeArn, 
            baggage: baggage, 
            contentType: contentType, 
            mcpProtocolVersion: mcpProtocolVersion, 
            mcpSessionId: mcpSessionId, 
            payload: payload, 
            qualifier: qualifier, 
            runtimeSessionId: runtimeSessionId, 
            runtimeUserId: runtimeUserId, 
            traceId: traceId, 
            traceParent: traceParent, 
            traceState: traceState
        )
        return try await self.invokeAgentRuntime(input, logger: logger)
    }

    /// Executes code within an active code interpreter session in Amazon Bedrock. This operation processes the provided code, runs it in a secure environment, and returns the execution results including output, errors, and generated visualizations. To execute code, you must specify the code interpreter identifier, session ID, and the code to run in the arguments parameter. The operation returns a stream containing the execution results, which can include text output, error messages, and data visualizations. This operation is subject to request rate limiting based on your account's service quotas. The following operations are related to InvokeCodeInterpreter:    StartCodeInterpreterSession     GetCodeInterpreterSession
    @Sendable
    @inlinable
    public func invokeCodeInterpreter(_ input: InvokeCodeInterpreterRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> InvokeCodeInterpreterResponse {
        try await self.client.execute(
            operation: "InvokeCodeInterpreter", 
            path: "/code-interpreters/{codeInterpreterIdentifier}/tools/invoke", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Executes code within an active code interpreter session in Amazon Bedrock. This operation processes the provided code, runs it in a secure environment, and returns the execution results including output, errors, and generated visualizations. To execute code, you must specify the code interpreter identifier, session ID, and the code to run in the arguments parameter. The operation returns a stream containing the execution results, which can include text output, error messages, and data visualizations. This operation is subject to request rate limiting based on your account's service quotas. The following operations are related to InvokeCodeInterpreter:    StartCodeInterpreterSession     GetCodeInterpreterSession
    ///
    /// Parameters:
    ///   - arguments: The arguments for the code interpreter. This includes the code to execute and any additional parameters such as the programming language, whether to clear the execution context, and other execution options. The structure of this parameter depends on the specific code interpreter being used.
    ///   - codeInterpreterIdentifier: The unique identifier of the code interpreter associated with the session. This must match the identifier used when creating the session with StartCodeInterpreterSession.
    ///   - name: The name of the code interpreter to invoke.
    ///   - sessionId: The unique identifier of the code interpreter session to use. This must be an active session created with StartCodeInterpreterSession. If the session has expired or been stopped, the request will fail.
    ///   - logger: Logger use during operation
    @inlinable
    public func invokeCodeInterpreter(
        arguments: ToolArguments? = nil,
        codeInterpreterIdentifier: String,
        name: ToolName,
        sessionId: String? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> InvokeCodeInterpreterResponse {
        let input = InvokeCodeInterpreterRequest(
            arguments: arguments, 
            codeInterpreterIdentifier: codeInterpreterIdentifier, 
            name: name, 
            sessionId: sessionId
        )
        return try await self.invokeCodeInterpreter(input, logger: logger)
    }

    /// Lists all actors in a memory store. We recommend using pagination to ensure that the operation returns quickly and successfully. To use this operation, you must have the genesismemory:ListActors permission.
    @Sendable
    @inlinable
    public func listActors(_ input: ListActorsInput, logger: Logger = AWSClient.loggingDisabled) async throws -> ListActorsOutput {
        try await self.client.execute(
            operation: "ListActors", 
            path: "/memories/{memoryId}/actors", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Lists all actors in a memory store. We recommend using pagination to ensure that the operation returns quickly and successfully. To use this operation, you must have the genesismemory:ListActors permission.
    ///
    /// Parameters:
    ///   - maxResults: The maximum number of results to return in a single call. Minimum value of 1, maximum value of 100. Default is 20.
    ///   - memoryId: The identifier of the memory store for which to list actors.
    ///   - nextToken: The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.
    ///   - logger: Logger use during operation
    @inlinable
    public func listActors(
        maxResults: Int? = nil,
        memoryId: String,
        nextToken: String? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ListActorsOutput {
        let input = ListActorsInput(
            maxResults: maxResults, 
            memoryId: memoryId, 
            nextToken: nextToken
        )
        return try await self.listActors(input, logger: logger)
    }

    /// Retrieves a list of browser sessions in Amazon Bedrock that match the specified criteria. This operation returns summary information about each session, including identifiers, status, and timestamps. You can filter the results by browser identifier and session status. The operation supports pagination to handle large result sets efficiently. We recommend using pagination to ensure that the operation returns quickly and successfully when retrieving large numbers of sessions. The following operations are related to ListBrowserSessions:    StartBrowserSession     GetBrowserSession
    @Sendable
    @inlinable
    public func listBrowserSessions(_ input: ListBrowserSessionsRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> ListBrowserSessionsResponse {
        try await self.client.execute(
            operation: "ListBrowserSessions", 
            path: "/browsers/{browserIdentifier}/sessions/list", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Retrieves a list of browser sessions in Amazon Bedrock that match the specified criteria. This operation returns summary information about each session, including identifiers, status, and timestamps. You can filter the results by browser identifier and session status. The operation supports pagination to handle large result sets efficiently. We recommend using pagination to ensure that the operation returns quickly and successfully when retrieving large numbers of sessions. The following operations are related to ListBrowserSessions:    StartBrowserSession     GetBrowserSession
    ///
    /// Parameters:
    ///   - browserIdentifier: The unique identifier of the browser to list sessions for. If specified, only sessions for this browser are returned. If not specified, sessions for all browsers are returned.
    ///   - maxResults: The maximum number of results to return in a single call. The default value is 10. Valid values range from 1 to 100. To retrieve the remaining results, make another call with the returned nextToken value.
    ///   - nextToken: The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results. If not specified, Amazon Bedrock returns the first page of results.
    ///   - status: The status of the browser sessions to list. Valid values include ACTIVE, STOPPING, and STOPPED. If not specified, sessions with any status are returned.
    ///   - logger: Logger use during operation
    @inlinable
    public func listBrowserSessions(
        browserIdentifier: String,
        maxResults: Int? = nil,
        nextToken: String? = nil,
        status: BrowserSessionStatus? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ListBrowserSessionsResponse {
        let input = ListBrowserSessionsRequest(
            browserIdentifier: browserIdentifier, 
            maxResults: maxResults, 
            nextToken: nextToken, 
            status: status
        )
        return try await self.listBrowserSessions(input, logger: logger)
    }

    /// Retrieves a list of code interpreter sessions in Amazon Bedrock that match the specified criteria. This operation returns summary information about each session, including identifiers, status, and timestamps. You can filter the results by code interpreter identifier and session status. The operation supports pagination to handle large result sets efficiently. We recommend using pagination to ensure that the operation returns quickly and successfully when retrieving large numbers of sessions. The following operations are related to ListCodeInterpreterSessions:    StartCodeInterpreterSession     GetCodeInterpreterSession
    @Sendable
    @inlinable
    public func listCodeInterpreterSessions(_ input: ListCodeInterpreterSessionsRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> ListCodeInterpreterSessionsResponse {
        try await self.client.execute(
            operation: "ListCodeInterpreterSessions", 
            path: "/code-interpreters/{codeInterpreterIdentifier}/sessions/list", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Retrieves a list of code interpreter sessions in Amazon Bedrock that match the specified criteria. This operation returns summary information about each session, including identifiers, status, and timestamps. You can filter the results by code interpreter identifier and session status. The operation supports pagination to handle large result sets efficiently. We recommend using pagination to ensure that the operation returns quickly and successfully when retrieving large numbers of sessions. The following operations are related to ListCodeInterpreterSessions:    StartCodeInterpreterSession     GetCodeInterpreterSession
    ///
    /// Parameters:
    ///   - codeInterpreterIdentifier: The unique identifier of the code interpreter to list sessions for. If specified, only sessions for this code interpreter are returned. If not specified, sessions for all code interpreters are returned.
    ///   - maxResults: The maximum number of results to return in a single call. The default value is 10. Valid values range from 1 to 100. To retrieve the remaining results, make another call with the returned nextToken value.
    ///   - nextToken: The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results. If not specified, Amazon Bedrock returns the first page of results.
    ///   - status: The status of the code interpreter sessions to list. Valid values include ACTIVE, STOPPING, and STOPPED. If not specified, sessions with any status are returned.
    ///   - logger: Logger use during operation
    @inlinable
    public func listCodeInterpreterSessions(
        codeInterpreterIdentifier: String,
        maxResults: Int? = nil,
        nextToken: String? = nil,
        status: CodeInterpreterSessionStatus? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ListCodeInterpreterSessionsResponse {
        let input = ListCodeInterpreterSessionsRequest(
            codeInterpreterIdentifier: codeInterpreterIdentifier, 
            maxResults: maxResults, 
            nextToken: nextToken, 
            status: status
        )
        return try await self.listCodeInterpreterSessions(input, logger: logger)
    }

    /// Lists events in a memory store based on specified criteria. We recommend using pagination to ensure that the operation returns quickly and successfully. To use this operation, you must have the genesismemory:ListEvents permission.
    @Sendable
    @inlinable
    public func listEvents(_ input: ListEventsInput, logger: Logger = AWSClient.loggingDisabled) async throws -> ListEventsOutput {
        try await self.client.execute(
            operation: "ListEvents", 
            path: "/memories/{memoryId}/actor/{actorId}/sessions/{sessionId}", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Lists events in a memory store based on specified criteria. We recommend using pagination to ensure that the operation returns quickly and successfully. To use this operation, you must have the genesismemory:ListEvents permission.
    ///
    /// Parameters:
    ///   - actorId: The identifier of the actor for which to list events. If specified, only events from this actor are returned.
    ///   - filter: Filter criteria to apply when listing events.
    ///   - includePayloads: Specifies whether to include event payloads in the response. Set to true to include payloads, or false to exclude them.
    ///   - maxResults: The maximum number of results to return in a single call. Minimum value of 1, maximum value of 100. Default is 20.
    ///   - memoryId: The identifier of the memory store for which to list events.
    ///   - nextToken: The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.
    ///   - sessionId: The identifier of the session for which to list events. If specified, only events from this session are returned.
    ///   - logger: Logger use during operation
    @inlinable
    public func listEvents(
        actorId: String,
        filter: FilterInput? = nil,
        includePayloads: Bool? = nil,
        maxResults: Int? = nil,
        memoryId: String,
        nextToken: String? = nil,
        sessionId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ListEventsOutput {
        let input = ListEventsInput(
            actorId: actorId, 
            filter: filter, 
            includePayloads: includePayloads, 
            maxResults: maxResults, 
            memoryId: memoryId, 
            nextToken: nextToken, 
            sessionId: sessionId
        )
        return try await self.listEvents(input, logger: logger)
    }

    /// Lists memory records in a memory store based on specified criteria. We recommend using pagination to ensure that the operation returns quickly and successfully. To use this operation, you must have the genesismemory:ListMemoryRecords permission.
    @Sendable
    @inlinable
    public func listMemoryRecords(_ input: ListMemoryRecordsInput, logger: Logger = AWSClient.loggingDisabled) async throws -> ListMemoryRecordsOutput {
        try await self.client.execute(
            operation: "ListMemoryRecords", 
            path: "/memories/{memoryId}/memoryRecords", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Lists memory records in a memory store based on specified criteria. We recommend using pagination to ensure that the operation returns quickly and successfully. To use this operation, you must have the genesismemory:ListMemoryRecords permission.
    ///
    /// Parameters:
    ///   - maxResults: The maximum number of results to return in a single call. Minimum value of 1, maximum value of 100. Default is 20.
    ///   - memoryId: The identifier of the memory store for which to list memory records.
    ///   - memoryStrategyId: The memory strategy identifier to filter memory records by. If specified, only memory records with this strategy ID are returned.
    ///   - namespace: The namespace to filter memory records by. If specified, only memory records in this namespace are returned.
    ///   - nextToken: The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.
    ///   - logger: Logger use during operation
    @inlinable
    public func listMemoryRecords(
        maxResults: Int? = nil,
        memoryId: String,
        memoryStrategyId: String? = nil,
        namespace: String,
        nextToken: String? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ListMemoryRecordsOutput {
        let input = ListMemoryRecordsInput(
            maxResults: maxResults, 
            memoryId: memoryId, 
            memoryStrategyId: memoryStrategyId, 
            namespace: namespace, 
            nextToken: nextToken
        )
        return try await self.listMemoryRecords(input, logger: logger)
    }

    /// Lists sessions in a memory store based on specified criteria. We recommend using pagination to ensure that the operation returns quickly and successfully. To use this operation, you must have the genesismemory:ListSessions permission.
    @Sendable
    @inlinable
    public func listSessions(_ input: ListSessionsInput, logger: Logger = AWSClient.loggingDisabled) async throws -> ListSessionsOutput {
        try await self.client.execute(
            operation: "ListSessions", 
            path: "/memories/{memoryId}/actor/{actorId}/sessions", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Lists sessions in a memory store based on specified criteria. We recommend using pagination to ensure that the operation returns quickly and successfully. To use this operation, you must have the genesismemory:ListSessions permission.
    ///
    /// Parameters:
    ///   - actorId: The identifier of the actor for which to list sessions. If specified, only sessions involving this actor are returned.
    ///   - maxResults: The maximum number of results to return in a single call. Minimum value of 1, maximum value of 100. Default is 20.
    ///   - memoryId: The identifier of the memory store for which to list sessions.
    ///   - nextToken: The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.
    ///   - logger: Logger use during operation
    @inlinable
    public func listSessions(
        actorId: String,
        maxResults: Int? = nil,
        memoryId: String,
        nextToken: String? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ListSessionsOutput {
        let input = ListSessionsInput(
            actorId: actorId, 
            maxResults: maxResults, 
            memoryId: memoryId, 
            nextToken: nextToken
        )
        return try await self.listSessions(input, logger: logger)
    }

    /// Searches for and retrieves memory records from a memory store based on specified search criteria. We recommend using pagination to ensure that the operation returns quickly and successfully. To use this operation, you must have the genesismemory:RetrieveMemoryRecords permission.
    @Sendable
    @inlinable
    public func retrieveMemoryRecords(_ input: RetrieveMemoryRecordsInput, logger: Logger = AWSClient.loggingDisabled) async throws -> RetrieveMemoryRecordsOutput {
        try await self.client.execute(
            operation: "RetrieveMemoryRecords", 
            path: "/memories/{memoryId}/retrieve", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Searches for and retrieves memory records from a memory store based on specified search criteria. We recommend using pagination to ensure that the operation returns quickly and successfully. To use this operation, you must have the genesismemory:RetrieveMemoryRecords permission.
    ///
    /// Parameters:
    ///   - maxResults: The maximum number of results to return in a single call. Minimum value of 1, maximum value of 100. Default is 20.
    ///   - memoryId: The identifier of the memory store from which to retrieve memory records.
    ///   - namespace: The namespace to filter memory records by. If specified, only memory records in this namespace are searched.
    ///   - nextToken: The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.
    ///   - searchCriteria: The search criteria to use for finding relevant memory records. This includes the search query, memory strategy ID, and other search parameters.
    ///   - logger: Logger use during operation
    @inlinable
    public func retrieveMemoryRecords(
        maxResults: Int? = nil,
        memoryId: String,
        namespace: String,
        nextToken: String? = nil,
        searchCriteria: SearchCriteria,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> RetrieveMemoryRecordsOutput {
        let input = RetrieveMemoryRecordsInput(
            maxResults: maxResults, 
            memoryId: memoryId, 
            namespace: namespace, 
            nextToken: nextToken, 
            searchCriteria: searchCriteria
        )
        return try await self.retrieveMemoryRecords(input, logger: logger)
    }

    /// Creates and initializes a browser session in Amazon Bedrock. The session enables agents to navigate and interact with web content, extract information from websites, and perform web-based tasks as part of their response generation. To create a session, you must specify a browser identifier and a name. You can also configure the viewport dimensions to control the visible area of web content. The session remains active until it times out or you explicitly stop it using the StopBrowserSession operation. The following operations are related to StartBrowserSession:    GetBrowserSession     UpdateBrowserStream     StopBrowserSession
    @Sendable
    @inlinable
    public func startBrowserSession(_ input: StartBrowserSessionRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> StartBrowserSessionResponse {
        try await self.client.execute(
            operation: "StartBrowserSession", 
            path: "/browsers/{browserIdentifier}/sessions/start", 
            httpMethod: .PUT, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Creates and initializes a browser session in Amazon Bedrock. The session enables agents to navigate and interact with web content, extract information from websites, and perform web-based tasks as part of their response generation. To create a session, you must specify a browser identifier and a name. You can also configure the viewport dimensions to control the visible area of web content. The session remains active until it times out or you explicitly stop it using the StopBrowserSession operation. The following operations are related to StartBrowserSession:    GetBrowserSession     UpdateBrowserStream     StopBrowserSession
    ///
    /// Parameters:
    ///   - browserIdentifier: The unique identifier of the browser to use for this session. This identifier specifies which browser environment to initialize for the session.
    ///   - clientToken: A unique, case-sensitive identifier to ensure that the API request completes no more than one time. If this token matches a previous request, Amazon Bedrock ignores the request, but does not return an error. This parameter helps prevent the creation of duplicate sessions if there are temporary network issues.
    ///   - name: The name of the browser session. This name helps you identify and manage the session. The name does not need to be unique.
    ///   - sessionTimeoutSeconds: The time in seconds after which the session automatically terminates if there is no activity. The default value is 3600 seconds (1 hour). The minimum allowed value is 60 seconds, and the maximum allowed value is 28800 seconds (8 hours).
    ///   - viewPort: The dimensions of the browser viewport for this session. This determines the visible area of the web content and affects how web pages are rendered. If not specified, Amazon Bedrock uses a default viewport size.
    ///   - logger: Logger use during operation
    @inlinable
    public func startBrowserSession(
        browserIdentifier: String,
        clientToken: String? = StartBrowserSessionRequest.idempotencyToken(),
        name: String? = nil,
        sessionTimeoutSeconds: Int? = nil,
        viewPort: ViewPort? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> StartBrowserSessionResponse {
        let input = StartBrowserSessionRequest(
            browserIdentifier: browserIdentifier, 
            clientToken: clientToken, 
            name: name, 
            sessionTimeoutSeconds: sessionTimeoutSeconds, 
            viewPort: viewPort
        )
        return try await self.startBrowserSession(input, logger: logger)
    }

    /// Creates and initializes a code interpreter session in Amazon Bedrock. The session enables agents to execute code as part of their response generation, supporting programming languages such as Python for data analysis, visualization, and computation tasks. To create a session, you must specify a code interpreter identifier and a name. The session remains active until it times out or you explicitly stop it using the StopCodeInterpreterSession operation. The following operations are related to StartCodeInterpreterSession:    InvokeCodeInterpreter     GetCodeInterpreterSession     StopCodeInterpreterSession
    @Sendable
    @inlinable
    public func startCodeInterpreterSession(_ input: StartCodeInterpreterSessionRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> StartCodeInterpreterSessionResponse {
        try await self.client.execute(
            operation: "StartCodeInterpreterSession", 
            path: "/code-interpreters/{codeInterpreterIdentifier}/sessions/start", 
            httpMethod: .PUT, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Creates and initializes a code interpreter session in Amazon Bedrock. The session enables agents to execute code as part of their response generation, supporting programming languages such as Python for data analysis, visualization, and computation tasks. To create a session, you must specify a code interpreter identifier and a name. The session remains active until it times out or you explicitly stop it using the StopCodeInterpreterSession operation. The following operations are related to StartCodeInterpreterSession:    InvokeCodeInterpreter     GetCodeInterpreterSession     StopCodeInterpreterSession
    ///
    /// Parameters:
    ///   - clientToken: A unique, case-sensitive identifier to ensure that the API request completes no more than one time. If this token matches a previous request, Amazon Bedrock ignores the request, but does not return an error. This parameter helps prevent the creation of duplicate sessions if there are temporary network issues.
    ///   - codeInterpreterIdentifier: The unique identifier of the code interpreter to use for this session. This identifier specifies which code interpreter environment to initialize for the session.
    ///   - name: The name of the code interpreter session. This name helps you identify and manage the session. The name does not need to be unique.
    ///   - sessionTimeoutSeconds: The time in seconds after which the session automatically terminates if there is no activity. The default value is 3600 seconds (1 hour). The minimum allowed value is 60 seconds, and the maximum allowed value is 28800 seconds (8 hours).
    ///   - logger: Logger use during operation
    @inlinable
    public func startCodeInterpreterSession(
        clientToken: String? = StartCodeInterpreterSessionRequest.idempotencyToken(),
        codeInterpreterIdentifier: String,
        name: String? = nil,
        sessionTimeoutSeconds: Int? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> StartCodeInterpreterSessionResponse {
        let input = StartCodeInterpreterSessionRequest(
            clientToken: clientToken, 
            codeInterpreterIdentifier: codeInterpreterIdentifier, 
            name: name, 
            sessionTimeoutSeconds: sessionTimeoutSeconds
        )
        return try await self.startCodeInterpreterSession(input, logger: logger)
    }

    /// Terminates an active browser session in Amazon Bedrock. This operation stops the session, releases associated resources, and makes the session unavailable for further use. To stop a browser session, you must specify both the browser identifier and the session ID. Once stopped, a session cannot be restarted; you must create a new session using StartBrowserSession. The following operations are related to StopBrowserSession:    StartBrowserSession     GetBrowserSession
    @Sendable
    @inlinable
    public func stopBrowserSession(_ input: StopBrowserSessionRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> StopBrowserSessionResponse {
        try await self.client.execute(
            operation: "StopBrowserSession", 
            path: "/browsers/{browserIdentifier}/sessions/stop", 
            httpMethod: .PUT, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Terminates an active browser session in Amazon Bedrock. This operation stops the session, releases associated resources, and makes the session unavailable for further use. To stop a browser session, you must specify both the browser identifier and the session ID. Once stopped, a session cannot be restarted; you must create a new session using StartBrowserSession. The following operations are related to StopBrowserSession:    StartBrowserSession     GetBrowserSession
    ///
    /// Parameters:
    ///   - browserIdentifier: The unique identifier of the browser associated with the session.
    ///   - clientToken: A unique, case-sensitive identifier to ensure that the API request completes no more than one time. If this token matches a previous request, Amazon Bedrock ignores the request, but does not return an error.
    ///   - sessionId: The unique identifier of the browser session to stop.
    ///   - logger: Logger use during operation
    @inlinable
    public func stopBrowserSession(
        browserIdentifier: String,
        clientToken: String? = StopBrowserSessionRequest.idempotencyToken(),
        sessionId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> StopBrowserSessionResponse {
        let input = StopBrowserSessionRequest(
            browserIdentifier: browserIdentifier, 
            clientToken: clientToken, 
            sessionId: sessionId
        )
        return try await self.stopBrowserSession(input, logger: logger)
    }

    /// Terminates an active code interpreter session in Amazon Bedrock. This operation stops the session, releases associated resources, and makes the session unavailable for further use. To stop a code interpreter session, you must specify both the code interpreter identifier and the session ID. Once stopped, a session cannot be restarted; you must create a new session using StartCodeInterpreterSession. The following operations are related to StopCodeInterpreterSession:    StartCodeInterpreterSession     GetCodeInterpreterSession
    @Sendable
    @inlinable
    public func stopCodeInterpreterSession(_ input: StopCodeInterpreterSessionRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> StopCodeInterpreterSessionResponse {
        try await self.client.execute(
            operation: "StopCodeInterpreterSession", 
            path: "/code-interpreters/{codeInterpreterIdentifier}/sessions/stop", 
            httpMethod: .PUT, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Terminates an active code interpreter session in Amazon Bedrock. This operation stops the session, releases associated resources, and makes the session unavailable for further use. To stop a code interpreter session, you must specify both the code interpreter identifier and the session ID. Once stopped, a session cannot be restarted; you must create a new session using StartCodeInterpreterSession. The following operations are related to StopCodeInterpreterSession:    StartCodeInterpreterSession     GetCodeInterpreterSession
    ///
    /// Parameters:
    ///   - clientToken: A unique, case-sensitive identifier to ensure that the API request completes no more than one time. If this token matches a previous request, Amazon Bedrock ignores the request, but does not return an error.
    ///   - codeInterpreterIdentifier: The unique identifier of the code interpreter associated with the session.
    ///   - sessionId: The unique identifier of the code interpreter session to stop.
    ///   - logger: Logger use during operation
    @inlinable
    public func stopCodeInterpreterSession(
        clientToken: String? = StopCodeInterpreterSessionRequest.idempotencyToken(),
        codeInterpreterIdentifier: String,
        sessionId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> StopCodeInterpreterSessionResponse {
        let input = StopCodeInterpreterSessionRequest(
            clientToken: clientToken, 
            codeInterpreterIdentifier: codeInterpreterIdentifier, 
            sessionId: sessionId
        )
        return try await self.stopCodeInterpreterSession(input, logger: logger)
    }

    /// Updates a browser stream. To use this operation, you must have permissions to perform the bedrock:UpdateBrowserStream action.
    @Sendable
    @inlinable
    public func updateBrowserStream(_ input: UpdateBrowserStreamRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> UpdateBrowserStreamResponse {
        try await self.client.execute(
            operation: "UpdateBrowserStream", 
            path: "/browsers/{browserIdentifier}/sessions/streams/update", 
            httpMethod: .PUT, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Updates a browser stream. To use this operation, you must have permissions to perform the bedrock:UpdateBrowserStream action.
    ///
    /// Parameters:
    ///   - browserIdentifier: The identifier of the browser.
    ///   - clientToken: A unique, case-sensitive identifier to ensure that the operation completes no more than one time. If this token matches a previous request, Amazon Bedrock ignores the request, but does not return an error.
    ///   - sessionId: The identifier of the browser session.
    ///   - streamUpdate: The update to apply to the browser stream.
    ///   - logger: Logger use during operation
    @inlinable
    public func updateBrowserStream(
        browserIdentifier: String,
        clientToken: String? = UpdateBrowserStreamRequest.idempotencyToken(),
        sessionId: String,
        streamUpdate: StreamUpdate,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> UpdateBrowserStreamResponse {
        let input = UpdateBrowserStreamRequest(
            browserIdentifier: browserIdentifier, 
            clientToken: clientToken, 
            sessionId: sessionId, 
            streamUpdate: streamUpdate
        )
        return try await self.updateBrowserStream(input, logger: logger)
    }
}

extension BedrockAgentCore {
    /// Initializer required by `AWSService.with(middlewares:timeout:byteBufferAllocator:options)`. You are not able to use this initializer directly as there are not public
    /// initializers for `AWSServiceConfig.Patch`. Please use `AWSService.with(middlewares:timeout:byteBufferAllocator:options)` instead.
    public init(from: BedrockAgentCore, patch: AWSServiceConfig.Patch) {
        self.client = from.client
        self.config = from.config.with(patch: patch)
    }
}

// MARK: Paginators

@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension BedrockAgentCore {
    /// Return PaginatorSequence for operation ``listActors(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func listActorsPaginator(
        _ input: ListActorsInput,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<ListActorsInput, ListActorsOutput> {
        return .init(
            input: input,
            command: self.listActors,
            inputKey: \ListActorsInput.nextToken,
            outputKey: \ListActorsOutput.nextToken,
            logger: logger
        )
    }
    /// Return PaginatorSequence for operation ``listActors(_:logger:)``.
    ///
    /// - Parameters:
    ///   - maxResults: The maximum number of results to return in a single call. Minimum value of 1, maximum value of 100. Default is 20.
    ///   - memoryId: The identifier of the memory store for which to list actors.
    ///   - logger: Logger used for logging
    @inlinable
    public func listActorsPaginator(
        maxResults: Int? = nil,
        memoryId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) -> AWSClient.PaginatorSequence<ListActorsInput, ListActorsOutput> {
        let input = ListActorsInput(
            maxResults: maxResults, 
            memoryId: memoryId
        )
        return self.listActorsPaginator(input, logger: logger)
    }

    /// Return PaginatorSequence for operation ``listEvents(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func listEventsPaginator(
        _ input: ListEventsInput,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<ListEventsInput, ListEventsOutput> {
        return .init(
            input: input,
            command: self.listEvents,
            inputKey: \ListEventsInput.nextToken,
            outputKey: \ListEventsOutput.nextToken,
            logger: logger
        )
    }
    /// Return PaginatorSequence for operation ``listEvents(_:logger:)``.
    ///
    /// - Parameters:
    ///   - actorId: The identifier of the actor for which to list events. If specified, only events from this actor are returned.
    ///   - filter: Filter criteria to apply when listing events.
    ///   - includePayloads: Specifies whether to include event payloads in the response. Set to true to include payloads, or false to exclude them.
    ///   - maxResults: The maximum number of results to return in a single call. Minimum value of 1, maximum value of 100. Default is 20.
    ///   - memoryId: The identifier of the memory store for which to list events.
    ///   - sessionId: The identifier of the session for which to list events. If specified, only events from this session are returned.
    ///   - logger: Logger used for logging
    @inlinable
    public func listEventsPaginator(
        actorId: String,
        filter: FilterInput? = nil,
        includePayloads: Bool? = nil,
        maxResults: Int? = nil,
        memoryId: String,
        sessionId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) -> AWSClient.PaginatorSequence<ListEventsInput, ListEventsOutput> {
        let input = ListEventsInput(
            actorId: actorId, 
            filter: filter, 
            includePayloads: includePayloads, 
            maxResults: maxResults, 
            memoryId: memoryId, 
            sessionId: sessionId
        )
        return self.listEventsPaginator(input, logger: logger)
    }

    /// Return PaginatorSequence for operation ``listMemoryRecords(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func listMemoryRecordsPaginator(
        _ input: ListMemoryRecordsInput,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<ListMemoryRecordsInput, ListMemoryRecordsOutput> {
        return .init(
            input: input,
            command: self.listMemoryRecords,
            inputKey: \ListMemoryRecordsInput.nextToken,
            outputKey: \ListMemoryRecordsOutput.nextToken,
            logger: logger
        )
    }
    /// Return PaginatorSequence for operation ``listMemoryRecords(_:logger:)``.
    ///
    /// - Parameters:
    ///   - maxResults: The maximum number of results to return in a single call. Minimum value of 1, maximum value of 100. Default is 20.
    ///   - memoryId: The identifier of the memory store for which to list memory records.
    ///   - memoryStrategyId: The memory strategy identifier to filter memory records by. If specified, only memory records with this strategy ID are returned.
    ///   - namespace: The namespace to filter memory records by. If specified, only memory records in this namespace are returned.
    ///   - logger: Logger used for logging
    @inlinable
    public func listMemoryRecordsPaginator(
        maxResults: Int? = nil,
        memoryId: String,
        memoryStrategyId: String? = nil,
        namespace: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) -> AWSClient.PaginatorSequence<ListMemoryRecordsInput, ListMemoryRecordsOutput> {
        let input = ListMemoryRecordsInput(
            maxResults: maxResults, 
            memoryId: memoryId, 
            memoryStrategyId: memoryStrategyId, 
            namespace: namespace
        )
        return self.listMemoryRecordsPaginator(input, logger: logger)
    }

    /// Return PaginatorSequence for operation ``listSessions(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func listSessionsPaginator(
        _ input: ListSessionsInput,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<ListSessionsInput, ListSessionsOutput> {
        return .init(
            input: input,
            command: self.listSessions,
            inputKey: \ListSessionsInput.nextToken,
            outputKey: \ListSessionsOutput.nextToken,
            logger: logger
        )
    }
    /// Return PaginatorSequence for operation ``listSessions(_:logger:)``.
    ///
    /// - Parameters:
    ///   - actorId: The identifier of the actor for which to list sessions. If specified, only sessions involving this actor are returned.
    ///   - maxResults: The maximum number of results to return in a single call. Minimum value of 1, maximum value of 100. Default is 20.
    ///   - memoryId: The identifier of the memory store for which to list sessions.
    ///   - logger: Logger used for logging
    @inlinable
    public func listSessionsPaginator(
        actorId: String,
        maxResults: Int? = nil,
        memoryId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) -> AWSClient.PaginatorSequence<ListSessionsInput, ListSessionsOutput> {
        let input = ListSessionsInput(
            actorId: actorId, 
            maxResults: maxResults, 
            memoryId: memoryId
        )
        return self.listSessionsPaginator(input, logger: logger)
    }

    /// Return PaginatorSequence for operation ``retrieveMemoryRecords(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func retrieveMemoryRecordsPaginator(
        _ input: RetrieveMemoryRecordsInput,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<RetrieveMemoryRecordsInput, RetrieveMemoryRecordsOutput> {
        return .init(
            input: input,
            command: self.retrieveMemoryRecords,
            inputKey: \RetrieveMemoryRecordsInput.nextToken,
            outputKey: \RetrieveMemoryRecordsOutput.nextToken,
            logger: logger
        )
    }
    /// Return PaginatorSequence for operation ``retrieveMemoryRecords(_:logger:)``.
    ///
    /// - Parameters:
    ///   - maxResults: The maximum number of results to return in a single call. Minimum value of 1, maximum value of 100. Default is 20.
    ///   - memoryId: The identifier of the memory store from which to retrieve memory records.
    ///   - namespace: The namespace to filter memory records by. If specified, only memory records in this namespace are searched.
    ///   - searchCriteria: The search criteria to use for finding relevant memory records. This includes the search query, memory strategy ID, and other search parameters.
    ///   - logger: Logger used for logging
    @inlinable
    public func retrieveMemoryRecordsPaginator(
        maxResults: Int? = nil,
        memoryId: String,
        namespace: String,
        searchCriteria: SearchCriteria,
        logger: Logger = AWSClient.loggingDisabled        
    ) -> AWSClient.PaginatorSequence<RetrieveMemoryRecordsInput, RetrieveMemoryRecordsOutput> {
        let input = RetrieveMemoryRecordsInput(
            maxResults: maxResults, 
            memoryId: memoryId, 
            namespace: namespace, 
            searchCriteria: searchCriteria
        )
        return self.retrieveMemoryRecordsPaginator(input, logger: logger)
    }
}

extension BedrockAgentCore.ListActorsInput: AWSPaginateToken {
    @inlinable
    public func usingPaginationToken(_ token: String) -> BedrockAgentCore.ListActorsInput {
        return .init(
            maxResults: self.maxResults,
            memoryId: self.memoryId,
            nextToken: token
        )
    }
}

extension BedrockAgentCore.ListEventsInput: AWSPaginateToken {
    @inlinable
    public func usingPaginationToken(_ token: String) -> BedrockAgentCore.ListEventsInput {
        return .init(
            actorId: self.actorId,
            filter: self.filter,
            includePayloads: self.includePayloads,
            maxResults: self.maxResults,
            memoryId: self.memoryId,
            nextToken: token,
            sessionId: self.sessionId
        )
    }
}

extension BedrockAgentCore.ListMemoryRecordsInput: AWSPaginateToken {
    @inlinable
    public func usingPaginationToken(_ token: String) -> BedrockAgentCore.ListMemoryRecordsInput {
        return .init(
            maxResults: self.maxResults,
            memoryId: self.memoryId,
            memoryStrategyId: self.memoryStrategyId,
            namespace: self.namespace,
            nextToken: token
        )
    }
}

extension BedrockAgentCore.ListSessionsInput: AWSPaginateToken {
    @inlinable
    public func usingPaginationToken(_ token: String) -> BedrockAgentCore.ListSessionsInput {
        return .init(
            actorId: self.actorId,
            maxResults: self.maxResults,
            memoryId: self.memoryId,
            nextToken: token
        )
    }
}

extension BedrockAgentCore.RetrieveMemoryRecordsInput: AWSPaginateToken {
    @inlinable
    public func usingPaginationToken(_ token: String) -> BedrockAgentCore.RetrieveMemoryRecordsInput {
        return .init(
            maxResults: self.maxResults,
            memoryId: self.memoryId,
            namespace: self.namespace,
            nextToken: token,
            searchCriteria: self.searchCriteria
        )
    }
}
