//===----------------------------------------------------------------------===//
//
// This source file is part of the Soto for AWS open source project
//
// Copyright (c) 2017-2024 the Soto project authors
// Licensed under Apache License v2.0
//
// See LICENSE.txt for license information
// See CONTRIBUTORS.txt for the list of Soto project authors
//
// SPDX-License-Identifier: Apache-2.0
//
//===----------------------------------------------------------------------===//

// THIS FILE IS AUTOMATICALLY GENERATED by https://github.com/soto-project/soto-codegenerator.
// DO NOT EDIT.

#if canImport(FoundationEssentials)
import FoundationEssentials
#else
import Foundation
#endif
@_spi(SotoInternal) import SotoCore

extension Glacier {
    // MARK: Enums

    public enum ActionCode: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case archiveRetrieval = "ArchiveRetrieval"
        case inventoryRetrieval = "InventoryRetrieval"
        case select = "Select"
        public var description: String { return self.rawValue }
    }

    public enum CannedACL: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case `private` = "private"
        case authenticatedRead = "authenticated-read"
        case awsExecRead = "aws-exec-read"
        case bucketOwnerFullControl = "bucket-owner-full-control"
        case bucketOwnerRead = "bucket-owner-read"
        case publicRead = "public-read"
        case publicReadWrite = "public-read-write"
        public var description: String { return self.rawValue }
    }

    public enum EncryptionType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case kms = "aws:kms"
        case s3 = "AES256"
        public var description: String { return self.rawValue }
    }

    public enum ExpressionType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case sql = "SQL"
        public var description: String { return self.rawValue }
    }

    public enum FileHeaderInfo: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case ignore = "IGNORE"
        case none = "NONE"
        case use = "USE"
        public var description: String { return self.rawValue }
    }

    public enum Permission: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case fullControl = "FULL_CONTROL"
        case read = "READ"
        case readAcp = "READ_ACP"
        case write = "WRITE"
        case writeAcp = "WRITE_ACP"
        public var description: String { return self.rawValue }
    }

    public enum QuoteFields: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case always = "ALWAYS"
        case asNeeded = "ASNEEDED"
        public var description: String { return self.rawValue }
    }

    public enum StatusCode: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case failed = "Failed"
        case inProgress = "InProgress"
        case succeeded = "Succeeded"
        public var description: String { return self.rawValue }
    }

    public enum StorageClass: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case reducedRedundancy = "REDUCED_REDUNDANCY"
        case standard = "STANDARD"
        case standardInfrequentAccess = "STANDARD_IA"
        public var description: String { return self.rawValue }
    }

    public enum `Type`: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case amazonCustomerByEmail = "AmazonCustomerByEmail"
        case canonicalUser = "CanonicalUser"
        case group = "Group"
        public var description: String { return self.rawValue }
    }

    // MARK: Shapes

    public struct AbortMultipartUploadInput: AWSEncodableShape {
        /// The AccountId value is the AWS account ID of the account that owns the vault. You can either specify an AWS account ID or optionally a single '-' (hyphen), in which case Amazon S3 Glacier uses the AWS account ID associated with the credentials used to sign the request. If you use an account ID, do not include any hyphens ('-') in the ID.
        public let accountId: String
        /// The upload ID of the multipart upload to delete.
        public let uploadId: String
        /// The name of the vault.
        public let vaultName: String

        @inlinable
        public init(accountId: String, uploadId: String, vaultName: String) {
            self.accountId = accountId
            self.uploadId = uploadId
            self.vaultName = vaultName
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.accountId, key: "accountId")
            request.encodePath(self.uploadId, key: "uploadId")
            request.encodePath(self.vaultName, key: "vaultName")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct AbortVaultLockInput: AWSEncodableShape {
        /// The AccountId value is the AWS account ID. This value must match the AWS account ID associated with the credentials used to sign the request. You can either specify an AWS account ID or optionally a single '-' (hyphen), in which case Amazon Glacier uses the AWS account ID associated with the credentials used to sign the request. If you specify your account ID, do not include any hyphens ('-') in the ID.
        public let accountId: String
        /// The name of the vault.
        public let vaultName: String

        @inlinable
        public init(accountId: String, vaultName: String) {
            self.accountId = accountId
            self.vaultName = vaultName
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.accountId, key: "accountId")
            request.encodePath(self.vaultName, key: "vaultName")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct AddTagsToVaultInput: AWSEncodableShape {
        /// The AccountId value is the AWS account ID of the account that owns the vault. You can either specify an AWS account ID or optionally a single '-' (hyphen), in which case Amazon S3 Glacier uses the AWS account ID associated with the credentials used to sign the request. If you use an account ID, do not include any hyphens ('-') in the ID.
        public let accountId: String
        /// The tags to add to the vault. Each tag is composed of a key and a value. The value can be an empty string.
        public let tags: [String: String]?
        /// The name of the vault.
        public let vaultName: String

        @inlinable
        public init(accountId: String, tags: [String: String]? = nil, vaultName: String) {
            self.accountId = accountId
            self.tags = tags
            self.vaultName = vaultName
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.accountId, key: "accountId")
            try container.encodeIfPresent(self.tags, forKey: .tags)
            request.encodePath(self.vaultName, key: "vaultName")
        }

        private enum CodingKeys: String, CodingKey {
            case tags = "Tags"
        }
    }

    public struct ArchiveCreationOutput: AWSDecodableShape {
        /// The ID of the archive. This value is also included as part of the location.
        public let archiveId: String?
        /// The checksum of the archive computed by Amazon S3 Glacier.
        public let checksum: String?
        /// The relative URI path of the newly added archive resource.
        public let location: String?

        @inlinable
        public init(archiveId: String? = nil, checksum: String? = nil, location: String? = nil) {
            self.archiveId = archiveId
            self.checksum = checksum
            self.location = location
        }

        public init(from decoder: Decoder) throws {
            let response = decoder.userInfo[.awsResponse]! as! ResponseDecodingContainer
            self.archiveId = try response.decodeHeaderIfPresent(String.self, key: "x-amz-archive-id")
            self.checksum = try response.decodeHeaderIfPresent(String.self, key: "x-amz-sha256-tree-hash")
            self.location = try response.decodeHeaderIfPresent(String.self, key: "Location")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct CSVInput: AWSEncodableShape & AWSDecodableShape {
        /// A single character used to indicate that a row should be ignored when the character is present at the start of that row.
        public let comments: String?
        /// A value used to separate individual fields from each other within a record.
        public let fieldDelimiter: String?
        /// Describes the first line of input. Valid values are None, Ignore, and Use.
        public let fileHeaderInfo: FileHeaderInfo?
        /// A value used as an escape character where the field delimiter is part of the value.
        public let quoteCharacter: String?
        /// A single character used for escaping the quotation-mark character inside an already escaped value.
        public let quoteEscapeCharacter: String?
        /// A value used to separate individual records from each other.
        public let recordDelimiter: String?

        @inlinable
        public init(comments: String? = nil, fieldDelimiter: String? = nil, fileHeaderInfo: FileHeaderInfo? = nil, quoteCharacter: String? = nil, quoteEscapeCharacter: String? = nil, recordDelimiter: String? = nil) {
            self.comments = comments
            self.fieldDelimiter = fieldDelimiter
            self.fileHeaderInfo = fileHeaderInfo
            self.quoteCharacter = quoteCharacter
            self.quoteEscapeCharacter = quoteEscapeCharacter
            self.recordDelimiter = recordDelimiter
        }

        private enum CodingKeys: String, CodingKey {
            case comments = "Comments"
            case fieldDelimiter = "FieldDelimiter"
            case fileHeaderInfo = "FileHeaderInfo"
            case quoteCharacter = "QuoteCharacter"
            case quoteEscapeCharacter = "QuoteEscapeCharacter"
            case recordDelimiter = "RecordDelimiter"
        }
    }

    public struct CSVOutput: AWSEncodableShape & AWSDecodableShape {
        /// A value used to separate individual fields from each other within a record.
        public let fieldDelimiter: String?
        /// A value used as an escape character where the field delimiter is part of the value.
        public let quoteCharacter: String?
        /// A single character used for escaping the quotation-mark character inside an already escaped value.
        public let quoteEscapeCharacter: String?
        /// A value that indicates whether all output fields should be contained within quotation marks.
        public let quoteFields: QuoteFields?
        /// A value used to separate individual records from each other.
        public let recordDelimiter: String?

        @inlinable
        public init(fieldDelimiter: String? = nil, quoteCharacter: String? = nil, quoteEscapeCharacter: String? = nil, quoteFields: QuoteFields? = nil, recordDelimiter: String? = nil) {
            self.fieldDelimiter = fieldDelimiter
            self.quoteCharacter = quoteCharacter
            self.quoteEscapeCharacter = quoteEscapeCharacter
            self.quoteFields = quoteFields
            self.recordDelimiter = recordDelimiter
        }

        private enum CodingKeys: String, CodingKey {
            case fieldDelimiter = "FieldDelimiter"
            case quoteCharacter = "QuoteCharacter"
            case quoteEscapeCharacter = "QuoteEscapeCharacter"
            case quoteFields = "QuoteFields"
            case recordDelimiter = "RecordDelimiter"
        }
    }

    public struct CompleteMultipartUploadInput: AWSEncodableShape {
        /// The AccountId value is the AWS account ID of the account that owns the vault. You can either specify an AWS account ID or optionally a single '-' (hyphen), in which case Amazon S3 Glacier uses the AWS account ID associated with the credentials used to sign the request. If you use an account ID, do not include any hyphens ('-') in the ID.
        public let accountId: String
        /// The total size, in bytes, of the entire archive. This value should be the sum of all the sizes of the individual parts that you uploaded.
        public let archiveSize: String?
        /// The SHA256 tree hash of the entire archive. It is the tree hash of SHA256 tree hash of the individual parts. If the value you specify in the request does not match the SHA256 tree hash of the final assembled archive as computed by Amazon S3 Glacier (Glacier),  Glacier returns an error and the request fails.
        public let checksum: String?
        /// The upload ID of the multipart upload.
        public let uploadId: String
        /// The name of the vault.
        public let vaultName: String

        @inlinable
        public init(accountId: String, archiveSize: String? = nil, checksum: String? = nil, uploadId: String, vaultName: String) {
            self.accountId = accountId
            self.archiveSize = archiveSize
            self.checksum = checksum
            self.uploadId = uploadId
            self.vaultName = vaultName
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.accountId, key: "accountId")
            request.encodeHeader(self.archiveSize, key: "x-amz-archive-size")
            request.encodeHeader(self.checksum, key: "x-amz-sha256-tree-hash")
            request.encodePath(self.uploadId, key: "uploadId")
            request.encodePath(self.vaultName, key: "vaultName")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct CompleteVaultLockInput: AWSEncodableShape {
        /// The AccountId value is the AWS account ID. This value must match the AWS account ID associated with the credentials used to sign the request. You can either specify an AWS account ID or optionally a single '-' (hyphen), in which case Amazon Glacier uses the AWS account ID associated with the credentials used to sign the request. If you specify your account ID, do not include any hyphens ('-') in the ID.
        public let accountId: String
        /// The lockId value is the lock ID obtained from a InitiateVaultLock request.
        public let lockId: String
        /// The name of the vault.
        public let vaultName: String

        @inlinable
        public init(accountId: String, lockId: String, vaultName: String) {
            self.accountId = accountId
            self.lockId = lockId
            self.vaultName = vaultName
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.accountId, key: "accountId")
            request.encodePath(self.lockId, key: "lockId")
            request.encodePath(self.vaultName, key: "vaultName")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct CreateVaultInput: AWSEncodableShape {
        /// The AccountId value is the AWS account ID. This value must match the AWS account ID associated with the credentials used to sign the request. You can either specify an AWS account ID or optionally a single '-' (hyphen), in which case Amazon S3 Glacier uses the AWS account ID associated with the credentials used to sign the request. If you specify your account ID, do not include any hyphens ('-') in the ID.
        public let accountId: String
        /// The name of the vault.
        public let vaultName: String

        @inlinable
        public init(accountId: String, vaultName: String) {
            self.accountId = accountId
            self.vaultName = vaultName
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.accountId, key: "accountId")
            request.encodePath(self.vaultName, key: "vaultName")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct CreateVaultOutput: AWSDecodableShape {
        /// The URI of the vault that was created.
        public let location: String?

        @inlinable
        public init(location: String? = nil) {
            self.location = location
        }

        public init(from decoder: Decoder) throws {
            let response = decoder.userInfo[.awsResponse]! as! ResponseDecodingContainer
            self.location = try response.decodeHeaderIfPresent(String.self, key: "Location")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DataRetrievalPolicy: AWSEncodableShape & AWSDecodableShape {
        /// The policy rule. Although this is a list type, currently there must be only one rule, which contains a Strategy field and optionally a BytesPerHour field.
        public let rules: [DataRetrievalRule]?

        @inlinable
        public init(rules: [DataRetrievalRule]? = nil) {
            self.rules = rules
        }

        private enum CodingKeys: String, CodingKey {
            case rules = "Rules"
        }
    }

    public struct DataRetrievalRule: AWSEncodableShape & AWSDecodableShape {
        /// The maximum number of bytes that can be retrieved in an hour. This field is required only if the value of the Strategy field is BytesPerHour. Your PUT operation will be rejected if the Strategy field is not set to BytesPerHour and you set this field.
        public let bytesPerHour: Int64?
        /// The type of data retrieval policy to set. Valid values: BytesPerHour|FreeTier|None
        public let strategy: String?

        @inlinable
        public init(bytesPerHour: Int64? = nil, strategy: String? = nil) {
            self.bytesPerHour = bytesPerHour
            self.strategy = strategy
        }

        private enum CodingKeys: String, CodingKey {
            case bytesPerHour = "BytesPerHour"
            case strategy = "Strategy"
        }
    }

    public struct DeleteArchiveInput: AWSEncodableShape {
        /// The AccountId value is the AWS account ID of the account that owns the vault. You can either specify an AWS account ID or optionally a single '-' (hyphen), in which case Amazon S3 Glacier uses the AWS account ID associated with the credentials used to sign the request. If you use an account ID, do not include any hyphens ('-') in the ID.
        public let accountId: String
        /// The ID of the archive to delete.
        public let archiveId: String
        /// The name of the vault.
        public let vaultName: String

        @inlinable
        public init(accountId: String, archiveId: String, vaultName: String) {
            self.accountId = accountId
            self.archiveId = archiveId
            self.vaultName = vaultName
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.accountId, key: "accountId")
            request.encodePath(self.archiveId, key: "archiveId")
            request.encodePath(self.vaultName, key: "vaultName")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteVaultAccessPolicyInput: AWSEncodableShape {
        /// The AccountId value is the AWS account ID of the account that owns the vault. You can either specify an AWS account ID or optionally a single '-' (hyphen), in which case Amazon S3 Glacier uses the AWS account ID associated with the credentials used to sign the request. If you use an account ID, do not include any hyphens ('-') in the ID.
        public let accountId: String
        /// The name of the vault.
        public let vaultName: String

        @inlinable
        public init(accountId: String, vaultName: String) {
            self.accountId = accountId
            self.vaultName = vaultName
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.accountId, key: "accountId")
            request.encodePath(self.vaultName, key: "vaultName")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteVaultInput: AWSEncodableShape {
        /// The AccountId value is the AWS account ID of the account that owns the vault. You can either specify an AWS account ID or optionally a single '-' (hyphen), in which case Amazon S3 Glacier uses the AWS account ID associated with the credentials used to sign the request. If you use an account ID, do not include any hyphens ('-') in the ID.
        public let accountId: String
        /// The name of the vault.
        public let vaultName: String

        @inlinable
        public init(accountId: String, vaultName: String) {
            self.accountId = accountId
            self.vaultName = vaultName
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.accountId, key: "accountId")
            request.encodePath(self.vaultName, key: "vaultName")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteVaultNotificationsInput: AWSEncodableShape {
        /// The AccountId value is the AWS account ID of the account that owns the vault. You can either specify an AWS account ID or optionally a single '-' (hyphen), in which case Amazon S3 Glacier uses the AWS account ID associated with the credentials used to sign the request. If you use an account ID, do not include any hyphens ('-') in the ID.
        public let accountId: String
        /// The name of the vault.
        public let vaultName: String

        @inlinable
        public init(accountId: String, vaultName: String) {
            self.accountId = accountId
            self.vaultName = vaultName
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.accountId, key: "accountId")
            request.encodePath(self.vaultName, key: "vaultName")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DescribeJobInput: AWSEncodableShape {
        /// The AccountId value is the AWS account ID of the account that owns the vault. You can either specify an AWS account ID or optionally a single '-' (hyphen), in which case Amazon S3 Glacier uses the AWS account ID associated with the credentials used to sign the request. If you use an account ID, do not include any hyphens ('-') in the ID.
        public let accountId: String
        /// The ID of the job to describe.
        public let jobId: String
        /// The name of the vault.
        public let vaultName: String

        @inlinable
        public init(accountId: String, jobId: String, vaultName: String) {
            self.accountId = accountId
            self.jobId = jobId
            self.vaultName = vaultName
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.accountId, key: "accountId")
            request.encodePath(self.jobId, key: "jobId")
            request.encodePath(self.vaultName, key: "vaultName")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DescribeVaultInput: AWSEncodableShape {
        /// The AccountId value is the AWS account ID of the account that owns the vault. You can either specify an AWS account ID or optionally a single '-' (hyphen), in which case Amazon S3 Glacier uses the AWS account ID associated with the credentials used to sign the request. If you use an account ID, do not include any hyphens ('-') in the ID.
        public let accountId: String
        /// The name of the vault.
        public let vaultName: String

        @inlinable
        public init(accountId: String, vaultName: String) {
            self.accountId = accountId
            self.vaultName = vaultName
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.accountId, key: "accountId")
            request.encodePath(self.vaultName, key: "vaultName")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DescribeVaultOutput: AWSDecodableShape {
        /// The Universal Coordinated Time (UTC) date when the vault was created. This value should be a string in the ISO 8601 date format, for example 2012-03-20T17:03:43.221Z.
        public let creationDate: String?
        /// The Universal Coordinated Time (UTC) date when Amazon S3 Glacier completed the last vault inventory.  This value should be a string in the ISO 8601 date format, for example 2012-03-20T17:03:43.221Z.
        public let lastInventoryDate: String?
        /// The number of archives in the vault as of the last inventory date. This field will return null if an inventory has not yet run on the vault, for example if you just created the vault.
        public let numberOfArchives: Int64?
        /// Total size, in bytes, of the archives in the vault as of the last inventory date. This field will return null if an inventory has not yet run on the vault, for example if you just created the vault.
        public let sizeInBytes: Int64?
        /// The Amazon Resource Name (ARN) of the vault.
        public let vaultARN: String?
        /// The name of the vault.
        public let vaultName: String?

        @inlinable
        public init(creationDate: String? = nil, lastInventoryDate: String? = nil, numberOfArchives: Int64? = nil, sizeInBytes: Int64? = nil, vaultARN: String? = nil, vaultName: String? = nil) {
            self.creationDate = creationDate
            self.lastInventoryDate = lastInventoryDate
            self.numberOfArchives = numberOfArchives
            self.sizeInBytes = sizeInBytes
            self.vaultARN = vaultARN
            self.vaultName = vaultName
        }

        private enum CodingKeys: String, CodingKey {
            case creationDate = "CreationDate"
            case lastInventoryDate = "LastInventoryDate"
            case numberOfArchives = "NumberOfArchives"
            case sizeInBytes = "SizeInBytes"
            case vaultARN = "VaultARN"
            case vaultName = "VaultName"
        }
    }

    public struct Encryption: AWSEncodableShape & AWSDecodableShape {
        /// The server-side encryption algorithm used when storing job results in Amazon S3, for example AES256 or aws:kms.
        public let encryptionType: EncryptionType?
        /// Optional. If the encryption type is aws:kms, you can use this value to specify the encryption context for the job results.
        public let kmsContext: String?
        /// The AWS KMS key ID to use for object encryption. All GET and PUT requests for an object protected by AWS KMS fail if not made by using Secure Sockets Layer (SSL) or Signature Version 4.
        public let kmsKeyId: String?

        @inlinable
        public init(encryptionType: EncryptionType? = nil, kmsContext: String? = nil, kmsKeyId: String? = nil) {
            self.encryptionType = encryptionType
            self.kmsContext = kmsContext
            self.kmsKeyId = kmsKeyId
        }

        private enum CodingKeys: String, CodingKey {
            case encryptionType = "EncryptionType"
            case kmsContext = "KMSContext"
            case kmsKeyId = "KMSKeyId"
        }
    }

    public struct GetDataRetrievalPolicyInput: AWSEncodableShape {
        /// The AccountId value is the AWS account ID. This value must match the AWS account ID associated with the credentials used to sign the request. You can either specify an AWS account ID or optionally a single '-' (hyphen), in which case Amazon Glacier uses the AWS account ID associated with the credentials used to sign the request. If you specify your account ID, do not include any hyphens ('-') in the ID.
        public let accountId: String

        @inlinable
        public init(accountId: String) {
            self.accountId = accountId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.accountId, key: "accountId")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetDataRetrievalPolicyOutput: AWSDecodableShape {
        /// Contains the returned data retrieval policy in JSON format.
        public let policy: DataRetrievalPolicy?

        @inlinable
        public init(policy: DataRetrievalPolicy? = nil) {
            self.policy = policy
        }

        private enum CodingKeys: String, CodingKey {
            case policy = "Policy"
        }
    }

    public struct GetJobOutputInput: AWSEncodableShape {
        /// The AccountId value is the AWS account ID of the account that owns the vault. You can either specify an AWS account ID or optionally a single '-' (hyphen), in which case Amazon S3 Glacier uses the AWS account ID associated with the credentials used to sign the request. If you use an account ID, do not include any hyphens ('-') in the ID.
        public let accountId: String
        /// The job ID whose data is downloaded.
        public let jobId: String
        /// The range of bytes to retrieve from the output. For example, if you want to download the first 1,048,576 bytes, specify the range as bytes=0-1048575. By default, this operation downloads the entire output.  If the job output is large, then you can use a range to retrieve a portion of the output. This allows you to download the entire output in smaller chunks of bytes. For example, suppose you have 1 GB of job output you want to download and you decide to download 128 MB chunks of data at a time, which is a total of eight Get Job Output requests. You use the following process to download the job output:    Download a 128 MB chunk of output by specifying the appropriate byte range. Verify that all 128 MB of data was received.   Along with the data, the response includes a SHA256 tree hash of the payload. You compute the checksum of the payload on the client and compare it with the checksum you received in the response to ensure you received all the expected data.   Repeat steps 1 and 2 for all the eight 128 MB chunks of output data, each time specifying the appropriate byte range.   After downloading all the parts of the job output, you have a list of eight checksum values. Compute the tree hash of these values to find the checksum of the entire output. Using the DescribeJob API, obtain job information of the job that provided you the output. The response includes the checksum of the entire archive stored in Amazon S3 Glacier. You compare this value with the checksum you computed to ensure you have downloaded the entire archive content with no errors.
        public let range: String?
        /// The name of the vault.
        public let vaultName: String

        @inlinable
        public init(accountId: String, jobId: String, range: String? = nil, vaultName: String) {
            self.accountId = accountId
            self.jobId = jobId
            self.range = range
            self.vaultName = vaultName
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.accountId, key: "accountId")
            request.encodePath(self.jobId, key: "jobId")
            request.encodeHeader(self.range, key: "Range")
            request.encodePath(self.vaultName, key: "vaultName")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetJobOutputOutput: AWSDecodableShape {
        public static let _options: AWSShapeOptions = [.rawPayload]
        /// Indicates the range units accepted. For more information, see RFC2616.
        public let acceptRanges: String?
        /// The description of an archive.
        public let archiveDescription: String?
        /// The job data, either archive data or inventory data.
        public let body: AWSHTTPBody
        /// The checksum of the data in the response. This header is returned only when retrieving the output for an archive retrieval job. Furthermore, this header appears only under the following conditions:   You get the entire range of the archive.   You request a range to return of the archive that starts and ends on a multiple of 1 MB. For example, if you have an 3.1 MB archive and you specify a range to return that starts at 1 MB and ends at 2 MB, then the x-amz-sha256-tree-hash is returned as a response header.   You request a range of the archive to return that starts on a multiple of 1 MB and goes to the end of the archive. For example, if you have a 3.1 MB archive and you specify a range that starts at 2 MB and ends at 3.1 MB (the end of the archive), then the x-amz-sha256-tree-hash is returned as a response header.
        public let checksum: String?
        /// The range of bytes returned by Amazon S3 Glacier. If only partial output is downloaded, the response provides the range of bytes Amazon S3 Glacier returned. For example, bytes 0-1048575/8388608 returns the first 1 MB from 8 MB.
        public let contentRange: String?
        /// The Content-Type depends on whether the job output is an archive or a vault inventory. For archive data, the Content-Type is application/octet-stream. For vault inventory, if you requested CSV format when you initiated the job, the Content-Type is text/csv. Otherwise, by default, vault inventory is returned as JSON, and the Content-Type is application/json.
        public let contentType: String?
        /// The HTTP response code for a job output request. The value depends on whether a range was specified in the request.
        public let status: Int?

        @inlinable
        public init(acceptRanges: String? = nil, archiveDescription: String? = nil, body: AWSHTTPBody, checksum: String? = nil, contentRange: String? = nil, contentType: String? = nil, status: Int? = nil) {
            self.acceptRanges = acceptRanges
            self.archiveDescription = archiveDescription
            self.body = body
            self.checksum = checksum
            self.contentRange = contentRange
            self.contentType = contentType
            self.status = status
        }

        public init(from decoder: Decoder) throws {
            let response = decoder.userInfo[.awsResponse]! as! ResponseDecodingContainer
            let container = try decoder.singleValueContainer()
            self.acceptRanges = try response.decodeHeaderIfPresent(String.self, key: "Accept-Ranges")
            self.archiveDescription = try response.decodeHeaderIfPresent(String.self, key: "x-amz-archive-description")
            self.body = try container.decode(AWSHTTPBody.self)
            self.checksum = try response.decodeHeaderIfPresent(String.self, key: "x-amz-sha256-tree-hash")
            self.contentRange = try response.decodeHeaderIfPresent(String.self, key: "Content-Range")
            self.contentType = try response.decodeHeaderIfPresent(String.self, key: "Content-Type")
            self.status = response.decodeStatus()
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetVaultAccessPolicyInput: AWSEncodableShape {
        /// The AccountId value is the AWS account ID of the account that owns the vault. You can either specify an AWS account ID or optionally a single '-' (hyphen), in which case Amazon S3 Glacier uses the AWS account ID associated with the credentials used to sign the request. If you use an account ID, do not include any hyphens ('-') in the ID.
        public let accountId: String
        /// The name of the vault.
        public let vaultName: String

        @inlinable
        public init(accountId: String, vaultName: String) {
            self.accountId = accountId
            self.vaultName = vaultName
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.accountId, key: "accountId")
            request.encodePath(self.vaultName, key: "vaultName")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetVaultAccessPolicyOutput: AWSDecodableShape {
        /// Contains the returned vault access policy as a JSON string.
        public let policy: VaultAccessPolicy

        @inlinable
        public init(policy: VaultAccessPolicy) {
            self.policy = policy
        }

        public init(from decoder: Decoder) throws {
            let container = try decoder.singleValueContainer()
            self.policy = try container.decode(VaultAccessPolicy.self)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetVaultLockInput: AWSEncodableShape {
        /// The AccountId value is the AWS account ID of the account that owns the vault. You can either specify an AWS account ID or optionally a single '-' (hyphen), in which case Amazon S3 Glacier uses the AWS account ID associated with the credentials used to sign the request. If you use an account ID, do not include any hyphens ('-') in the ID.
        public let accountId: String
        /// The name of the vault.
        public let vaultName: String

        @inlinable
        public init(accountId: String, vaultName: String) {
            self.accountId = accountId
            self.vaultName = vaultName
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.accountId, key: "accountId")
            request.encodePath(self.vaultName, key: "vaultName")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetVaultLockOutput: AWSDecodableShape {
        /// The UTC date and time at which the vault lock was put into the InProgress state.
        public let creationDate: String?
        /// The UTC date and time at which the lock ID expires. This value can be null if the vault lock is in a Locked state.
        public let expirationDate: String?
        /// The vault lock policy as a JSON string, which uses "\" as an escape character.
        public let policy: String?
        /// The state of the vault lock. InProgress or Locked.
        public let state: String?

        @inlinable
        public init(creationDate: String? = nil, expirationDate: String? = nil, policy: String? = nil, state: String? = nil) {
            self.creationDate = creationDate
            self.expirationDate = expirationDate
            self.policy = policy
            self.state = state
        }

        private enum CodingKeys: String, CodingKey {
            case creationDate = "CreationDate"
            case expirationDate = "ExpirationDate"
            case policy = "Policy"
            case state = "State"
        }
    }

    public struct GetVaultNotificationsInput: AWSEncodableShape {
        /// The AccountId value is the AWS account ID of the account that owns the vault. You can either specify an AWS account ID or optionally a single '-' (hyphen), in which case Amazon S3 Glacier uses the AWS account ID associated with the credentials used to sign the request. If you use an account ID, do not include any hyphens ('-') in the ID.
        public let accountId: String
        /// The name of the vault.
        public let vaultName: String

        @inlinable
        public init(accountId: String, vaultName: String) {
            self.accountId = accountId
            self.vaultName = vaultName
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.accountId, key: "accountId")
            request.encodePath(self.vaultName, key: "vaultName")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetVaultNotificationsOutput: AWSDecodableShape {
        /// Returns the notification configuration set on the vault.
        public let vaultNotificationConfig: VaultNotificationConfig

        @inlinable
        public init(vaultNotificationConfig: VaultNotificationConfig) {
            self.vaultNotificationConfig = vaultNotificationConfig
        }

        public init(from decoder: Decoder) throws {
            let container = try decoder.singleValueContainer()
            self.vaultNotificationConfig = try container.decode(VaultNotificationConfig.self)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GlacierJobDescription: AWSDecodableShape {
        /// The job type. This value is either ArchiveRetrieval, InventoryRetrieval, or Select.
        public let action: ActionCode?
        /// The archive ID requested for a select job or archive retrieval. Otherwise, this field is null.
        public let archiveId: String?
        /// The SHA256 tree hash of the entire archive for an archive retrieval. For inventory retrieval or select jobs, this field is null.
        public let archiveSHA256TreeHash: String?
        /// For an archive retrieval job, this value is the size in bytes of the archive being requested for download. For an inventory retrieval or select job, this value is null.
        public let archiveSizeInBytes: Int64?
        /// The job status. When a job is completed, you get the job's output using Get Job Output (GET output).
        public let completed: Bool?
        /// The UTC time that the job request completed. While the job is in progress, the value is null.
        public let completionDate: String?
        /// The UTC date when the job was created. This value is a string representation of ISO 8601 date format, for example "2012-03-20T17:03:43.221Z".
        public let creationDate: String?
        /// Parameters used for range inventory retrieval.
        public let inventoryRetrievalParameters: InventoryRetrievalJobDescription?
        /// For an inventory retrieval job, this value is the size in bytes of the inventory requested for download. For an archive retrieval or select job, this value is null.
        public let inventorySizeInBytes: Int64?
        /// The job description provided when initiating the job.
        public let jobDescription: String?
        /// An opaque string that identifies an Amazon S3 Glacier job.
        public let jobId: String?
        /// Contains the job output location.
        public let jobOutputPath: String?
        /// Contains the location where the data from the select job is stored.
        public let outputLocation: OutputLocation?
        /// The retrieved byte range for archive retrieval jobs in the form StartByteValue-EndByteValue. If no range was specified in the archive retrieval, then the whole archive is retrieved. In this case, StartByteValue equals 0 and EndByteValue equals the size of the archive minus 1. For inventory retrieval or select jobs, this field is null.
        public let retrievalByteRange: String?
        /// Contains the parameters used for a select.
        public let selectParameters: SelectParameters?
        /// For an archive retrieval job, this value is the checksum of the archive. Otherwise, this value is null. The SHA256 tree hash value for the requested range of an archive. If the InitiateJob request for an archive specified a tree-hash aligned range, then this field returns a value. If the whole archive is retrieved, this value is the same as the ArchiveSHA256TreeHash value. This field is null for the following:   Archive retrieval jobs that specify a range that is not tree-hash aligned     Archival jobs that specify a range that is equal to the whole archive, when the job status is InProgress      Inventory jobs   Select jobs
        public let sha256TreeHash: String?
        /// An Amazon SNS topic that receives notification.
        public let snsTopic: String?
        /// The status code can be InProgress, Succeeded, or Failed, and indicates the status of the job.
        public let statusCode: StatusCode?
        /// A friendly message that describes the job status.
        public let statusMessage: String?
        /// The tier to use for a select or an archive retrieval. Valid values are Expedited, Standard, or Bulk. Standard is the default.
        public let tier: String?
        /// The Amazon Resource Name (ARN) of the vault from which an archive retrieval was requested.
        public let vaultARN: String?

        @inlinable
        public init(action: ActionCode? = nil, archiveId: String? = nil, archiveSHA256TreeHash: String? = nil, archiveSizeInBytes: Int64? = nil, completed: Bool? = nil, completionDate: String? = nil, creationDate: String? = nil, inventoryRetrievalParameters: InventoryRetrievalJobDescription? = nil, inventorySizeInBytes: Int64? = nil, jobDescription: String? = nil, jobId: String? = nil, jobOutputPath: String? = nil, outputLocation: OutputLocation? = nil, retrievalByteRange: String? = nil, selectParameters: SelectParameters? = nil, sha256TreeHash: String? = nil, snsTopic: String? = nil, statusCode: StatusCode? = nil, statusMessage: String? = nil, tier: String? = nil, vaultARN: String? = nil) {
            self.action = action
            self.archiveId = archiveId
            self.archiveSHA256TreeHash = archiveSHA256TreeHash
            self.archiveSizeInBytes = archiveSizeInBytes
            self.completed = completed
            self.completionDate = completionDate
            self.creationDate = creationDate
            self.inventoryRetrievalParameters = inventoryRetrievalParameters
            self.inventorySizeInBytes = inventorySizeInBytes
            self.jobDescription = jobDescription
            self.jobId = jobId
            self.jobOutputPath = jobOutputPath
            self.outputLocation = outputLocation
            self.retrievalByteRange = retrievalByteRange
            self.selectParameters = selectParameters
            self.sha256TreeHash = sha256TreeHash
            self.snsTopic = snsTopic
            self.statusCode = statusCode
            self.statusMessage = statusMessage
            self.tier = tier
            self.vaultARN = vaultARN
        }

        private enum CodingKeys: String, CodingKey {
            case action = "Action"
            case archiveId = "ArchiveId"
            case archiveSHA256TreeHash = "ArchiveSHA256TreeHash"
            case archiveSizeInBytes = "ArchiveSizeInBytes"
            case completed = "Completed"
            case completionDate = "CompletionDate"
            case creationDate = "CreationDate"
            case inventoryRetrievalParameters = "InventoryRetrievalParameters"
            case inventorySizeInBytes = "InventorySizeInBytes"
            case jobDescription = "JobDescription"
            case jobId = "JobId"
            case jobOutputPath = "JobOutputPath"
            case outputLocation = "OutputLocation"
            case retrievalByteRange = "RetrievalByteRange"
            case selectParameters = "SelectParameters"
            case sha256TreeHash = "SHA256TreeHash"
            case snsTopic = "SNSTopic"
            case statusCode = "StatusCode"
            case statusMessage = "StatusMessage"
            case tier = "Tier"
            case vaultARN = "VaultARN"
        }
    }

    public struct Grant: AWSEncodableShape & AWSDecodableShape {
        /// The grantee.
        public let grantee: Grantee?
        /// Specifies the permission given to the grantee.
        public let permission: Permission?

        @inlinable
        public init(grantee: Grantee? = nil, permission: Permission? = nil) {
            self.grantee = grantee
            self.permission = permission
        }

        private enum CodingKeys: String, CodingKey {
            case grantee = "Grantee"
            case permission = "Permission"
        }
    }

    public struct Grantee: AWSEncodableShape & AWSDecodableShape {
        /// Screen name of the grantee.
        public let displayName: String?
        /// Email address of the grantee.
        public let emailAddress: String?
        /// The canonical user ID of the grantee.
        public let id: String?
        /// Type of grantee
        public let type: `Type`
        /// URI of the grantee group.
        public let uri: String?

        @inlinable
        public init(displayName: String? = nil, emailAddress: String? = nil, id: String? = nil, type: `Type`, uri: String? = nil) {
            self.displayName = displayName
            self.emailAddress = emailAddress
            self.id = id
            self.type = type
            self.uri = uri
        }

        private enum CodingKeys: String, CodingKey {
            case displayName = "DisplayName"
            case emailAddress = "EmailAddress"
            case id = "ID"
            case type = "Type"
            case uri = "URI"
        }
    }

    public struct InitiateJobInput: AWSEncodableShape {
        /// The AccountId value is the AWS account ID of the account that owns the vault. You can either specify an AWS account ID or optionally a single '-' (hyphen), in which case Amazon S3 Glacier uses the AWS account ID associated with the credentials used to sign the request. If you use an account ID, do not include any hyphens ('-') in the ID.
        public let accountId: String
        /// Provides options for specifying job information.
        public let jobParameters: JobParameters?
        /// The name of the vault.
        public let vaultName: String

        @inlinable
        public init(accountId: String, jobParameters: JobParameters? = nil, vaultName: String) {
            self.accountId = accountId
            self.jobParameters = jobParameters
            self.vaultName = vaultName
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.singleValueContainer()
            request.encodePath(self.accountId, key: "accountId")
            try container.encode(self.jobParameters)
            request.encodePath(self.vaultName, key: "vaultName")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct InitiateJobOutput: AWSDecodableShape {
        /// The ID of the job.
        public let jobId: String?
        /// The path to the location of where the select results are stored.
        public let jobOutputPath: String?
        /// The relative URI path of the job.
        public let location: String?

        @inlinable
        public init(jobId: String? = nil, jobOutputPath: String? = nil, location: String? = nil) {
            self.jobId = jobId
            self.jobOutputPath = jobOutputPath
            self.location = location
        }

        public init(from decoder: Decoder) throws {
            let response = decoder.userInfo[.awsResponse]! as! ResponseDecodingContainer
            self.jobId = try response.decodeHeaderIfPresent(String.self, key: "x-amz-job-id")
            self.jobOutputPath = try response.decodeHeaderIfPresent(String.self, key: "x-amz-job-output-path")
            self.location = try response.decodeHeaderIfPresent(String.self, key: "Location")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct InitiateMultipartUploadInput: AWSEncodableShape {
        /// The AccountId value is the AWS account ID of the account that owns the vault. You can either specify an AWS account ID or optionally a single '-' (hyphen), in which case Amazon S3 Glacier uses the AWS account ID associated with the credentials used to sign the request. If you use an account ID, do not include any hyphens ('-') in the ID.
        public let accountId: String
        /// The archive description that you are uploading in parts. The part size must be a megabyte (1024 KB) multiplied by a power of 2, for example 1048576 (1 MB), 2097152 (2 MB), 4194304 (4 MB), 8388608 (8 MB), and so on. The minimum allowable part size is 1 MB, and the maximum is 4 GB (4096 MB).
        public let archiveDescription: String?
        /// The size of each part except the last, in bytes. The last part can be smaller than this part size.
        public let partSize: String?
        /// The name of the vault.
        public let vaultName: String

        @inlinable
        public init(accountId: String, archiveDescription: String? = nil, partSize: String? = nil, vaultName: String) {
            self.accountId = accountId
            self.archiveDescription = archiveDescription
            self.partSize = partSize
            self.vaultName = vaultName
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.accountId, key: "accountId")
            request.encodeHeader(self.archiveDescription, key: "x-amz-archive-description")
            request.encodeHeader(self.partSize, key: "x-amz-part-size")
            request.encodePath(self.vaultName, key: "vaultName")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct InitiateMultipartUploadOutput: AWSDecodableShape {
        /// The relative URI path of the multipart upload ID Amazon S3 Glacier created.
        public let location: String?
        /// The ID of the multipart upload. This value is also included as part of the location.
        public let uploadId: String?

        @inlinable
        public init(location: String? = nil, uploadId: String? = nil) {
            self.location = location
            self.uploadId = uploadId
        }

        public init(from decoder: Decoder) throws {
            let response = decoder.userInfo[.awsResponse]! as! ResponseDecodingContainer
            self.location = try response.decodeHeaderIfPresent(String.self, key: "Location")
            self.uploadId = try response.decodeHeaderIfPresent(String.self, key: "x-amz-multipart-upload-id")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct InitiateVaultLockInput: AWSEncodableShape {
        /// The AccountId value is the AWS account ID. This value must match the AWS account ID associated with the credentials used to sign the request. You can either specify an AWS account ID or optionally a single '-' (hyphen), in which case Amazon Glacier uses the AWS account ID associated with the credentials used to sign the request. If you specify your account ID, do not include any hyphens ('-') in the ID.
        public let accountId: String
        /// The vault lock policy as a JSON string, which uses "\" as an escape character.
        public let policy: VaultLockPolicy?
        /// The name of the vault.
        public let vaultName: String

        @inlinable
        public init(accountId: String, policy: VaultLockPolicy? = nil, vaultName: String) {
            self.accountId = accountId
            self.policy = policy
            self.vaultName = vaultName
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.singleValueContainer()
            request.encodePath(self.accountId, key: "accountId")
            try container.encode(self.policy)
            request.encodePath(self.vaultName, key: "vaultName")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct InitiateVaultLockOutput: AWSDecodableShape {
        /// The lock ID, which is used to complete the vault locking process.
        public let lockId: String?

        @inlinable
        public init(lockId: String? = nil) {
            self.lockId = lockId
        }

        public init(from decoder: Decoder) throws {
            let response = decoder.userInfo[.awsResponse]! as! ResponseDecodingContainer
            self.lockId = try response.decodeHeaderIfPresent(String.self, key: "x-amz-lock-id")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct InputSerialization: AWSEncodableShape & AWSDecodableShape {
        /// Describes the serialization of a CSV-encoded object.
        public let csv: CSVInput?

        @inlinable
        public init(csv: CSVInput? = nil) {
            self.csv = csv
        }

        private enum CodingKeys: String, CodingKey {
            case csv = "csv"
        }
    }

    public struct InsufficientCapacityException: AWSErrorShape {
        public let code: String?
        public let message: String?
        public let type: String?

        @inlinable
        public init(code: String? = nil, message: String? = nil, type: String? = nil) {
            self.code = code
            self.message = message
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case code = "code"
            case message = "message"
            case type = "type"
        }
    }

    public struct InvalidParameterValueException: AWSErrorShape {
        /// 400 Bad Request
        public let code: String?
        /// Returned if a parameter of the request is incorrectly specified.
        public let message: String?
        /// Client
        public let type: String?

        @inlinable
        public init(code: String? = nil, message: String? = nil, type: String? = nil) {
            self.code = code
            self.message = message
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case code = "code"
            case message = "message"
            case type = "type"
        }
    }

    public struct InventoryRetrievalJobDescription: AWSDecodableShape {
        /// The end of the date range in UTC for vault inventory retrieval that includes archives created before this date. This value should be a string in the ISO 8601 date format, for example 2013-03-20T17:03:43Z.
        public let endDate: String?
        /// The output format for the vault inventory list, which is set by the InitiateJob request when initiating a job to retrieve a vault inventory. Valid values are CSV and JSON.
        public let format: String?
        /// The maximum number of inventory items returned per vault inventory retrieval request. This limit is set when initiating the job with the a InitiateJob request.
        public let limit: String?
        /// An opaque string that represents where to continue pagination of the vault inventory retrieval results. You use the marker in a new InitiateJob request to obtain additional inventory items. If there are no more inventory items, this value is null. For more information, see Range Inventory Retrieval.
        public let marker: String?
        /// The start of the date range in Universal Coordinated Time (UTC) for vault inventory retrieval that includes archives created on or after this date. This value should be a string in the ISO 8601 date format, for example 2013-03-20T17:03:43Z.
        public let startDate: String?

        @inlinable
        public init(endDate: String? = nil, format: String? = nil, limit: String? = nil, marker: String? = nil, startDate: String? = nil) {
            self.endDate = endDate
            self.format = format
            self.limit = limit
            self.marker = marker
            self.startDate = startDate
        }

        private enum CodingKeys: String, CodingKey {
            case endDate = "EndDate"
            case format = "Format"
            case limit = "Limit"
            case marker = "Marker"
            case startDate = "StartDate"
        }
    }

    public struct InventoryRetrievalJobInput: AWSEncodableShape {
        /// The end of the date range in UTC for vault inventory retrieval that includes archives created before this date. This value should be a string in the ISO 8601 date format, for example 2013-03-20T17:03:43Z.
        public let endDate: String?
        /// Specifies the maximum number of inventory items returned per vault inventory retrieval request. Valid values are greater than or equal to 1.
        public let limit: String?
        /// An opaque string that represents where to continue pagination of the vault inventory retrieval results. You use the marker in a new InitiateJob request to obtain additional inventory items. If there are no more inventory items, this value is null.
        public let marker: String?
        /// The start of the date range in UTC for vault inventory retrieval that includes archives created on or after this date. This value should be a string in the ISO 8601 date format, for example 2013-03-20T17:03:43Z.
        public let startDate: String?

        @inlinable
        public init(endDate: String? = nil, limit: String? = nil, marker: String? = nil, startDate: String? = nil) {
            self.endDate = endDate
            self.limit = limit
            self.marker = marker
            self.startDate = startDate
        }

        private enum CodingKeys: String, CodingKey {
            case endDate = "EndDate"
            case limit = "Limit"
            case marker = "Marker"
            case startDate = "StartDate"
        }
    }

    public struct JobParameters: AWSEncodableShape {
        /// The ID of the archive that you want to retrieve. This field is required only if Type is set to select or archive-retrievalcode>.  An error occurs if you specify this request parameter for an inventory retrieval job request.
        public let archiveId: String?
        /// The optional description for the job. The description must be less than or equal to 1,024 bytes. The allowable characters are 7-bit ASCII without control codes-specifically, ASCII values 32-126 decimal or 0x20-0x7E hexadecimal.
        public let description: String?
        /// When initiating a job to retrieve a vault inventory, you can optionally add this parameter to your request to specify the output format. If you are initiating an inventory job and do not specify a Format field, JSON is the default format. Valid values are "CSV" and "JSON".
        public let format: String?
        /// Input parameters used for range inventory retrieval.
        public let inventoryRetrievalParameters: InventoryRetrievalJobInput?
        /// Contains information about the location where the select job results are stored.
        public let outputLocation: OutputLocation?
        /// The byte range to retrieve for an archive retrieval. in the form "StartByteValue-EndByteValue" If not specified, the whole archive is retrieved. If specified, the byte range must be megabyte (1024*1024) aligned which means that StartByteValue must be divisible by 1 MB and EndByteValue plus 1 must be divisible by 1 MB or be the end of the archive specified as the archive byte size value minus 1. If RetrievalByteRange is not megabyte aligned, this operation returns a 400 response.  An error occurs if you specify this field for an inventory retrieval job request.
        public let retrievalByteRange: String?
        /// Contains the parameters that define a job.
        public let selectParameters: SelectParameters?
        /// The Amazon SNS topic ARN to which Amazon S3 Glacier sends a notification when the job is completed and the output is ready for you to download. The specified topic publishes the notification to its subscribers. The SNS topic must exist.
        public let snsTopic: String?
        /// The tier to use for a select or an archive retrieval job. Valid values are Expedited, Standard, or Bulk. Standard is the default.
        public let tier: String?
        /// The job type. You can initiate a job to perform a select query on an archive,  retrieve an archive, or get an inventory of a vault.  Valid values are "select", "archive-retrieval" and "inventory-retrieval".
        public let type: String?

        @inlinable
        public init(archiveId: String? = nil, description: String? = nil, format: String? = nil, inventoryRetrievalParameters: InventoryRetrievalJobInput? = nil, outputLocation: OutputLocation? = nil, retrievalByteRange: String? = nil, selectParameters: SelectParameters? = nil, snsTopic: String? = nil, tier: String? = nil, type: String? = nil) {
            self.archiveId = archiveId
            self.description = description
            self.format = format
            self.inventoryRetrievalParameters = inventoryRetrievalParameters
            self.outputLocation = outputLocation
            self.retrievalByteRange = retrievalByteRange
            self.selectParameters = selectParameters
            self.snsTopic = snsTopic
            self.tier = tier
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case archiveId = "ArchiveId"
            case description = "Description"
            case format = "Format"
            case inventoryRetrievalParameters = "InventoryRetrievalParameters"
            case outputLocation = "OutputLocation"
            case retrievalByteRange = "RetrievalByteRange"
            case selectParameters = "SelectParameters"
            case snsTopic = "SNSTopic"
            case tier = "Tier"
            case type = "Type"
        }
    }

    public struct LimitExceededException: AWSErrorShape {
        /// 400 Bad Request
        public let code: String?
        /// Returned if the request results in a vault limit or tags limit being exceeded.
        public let message: String?
        /// Client
        public let type: String?

        @inlinable
        public init(code: String? = nil, message: String? = nil, type: String? = nil) {
            self.code = code
            self.message = message
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case code = "code"
            case message = "message"
            case type = "type"
        }
    }

    public struct ListJobsInput: AWSEncodableShape {
        /// The AccountId value is the AWS account ID of the account that owns the vault. You can either specify an AWS account ID or optionally a single '-' (hyphen), in which case Amazon S3 Glacier uses the AWS account ID associated with the credentials used to sign the request. If you use an account ID, do not include any hyphens ('-') in the ID.
        public let accountId: String
        /// The state of the jobs to return. You can specify true or false.
        public let completed: String?
        /// The maximum number of jobs to be returned. The default limit is 50. The number of jobs returned might be fewer than the specified limit, but the number of returned jobs never exceeds the limit.
        public let limit: Int?
        /// An opaque string used for pagination. This value specifies the job at which the listing of jobs should begin. Get the marker value from a previous List Jobs response. You only need to include the marker if you are continuing the pagination of results started in a previous List Jobs request.
        public let marker: String?
        /// The type of job status to return. You can specify the following values: InProgress, Succeeded, or Failed.
        public let statuscode: String?
        /// The name of the vault.
        public let vaultName: String

        @inlinable
        public init(accountId: String, completed: String? = nil, limit: Int? = nil, marker: String? = nil, statuscode: String? = nil, vaultName: String) {
            self.accountId = accountId
            self.completed = completed
            self.limit = limit
            self.marker = marker
            self.statuscode = statuscode
            self.vaultName = vaultName
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.accountId, key: "accountId")
            request.encodeQuery(self.completed, key: "completed")
            request.encodeQuery(self.limit, key: "limit")
            request.encodeQuery(self.marker, key: "marker")
            request.encodeQuery(self.statuscode, key: "statuscode")
            request.encodePath(self.vaultName, key: "vaultName")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListJobsOutput: AWSDecodableShape {
        /// A list of job objects. Each job object contains metadata describing the job.
        public let jobList: [GlacierJobDescription]?
        /// 	 An opaque string used for pagination that specifies the job at which the listing of jobs should begin.  You get the marker value from a previous List Jobs response. You only need to include the marker if you are continuing the pagination of the results started in a  previous List Jobs request.
        public let marker: String?

        @inlinable
        public init(jobList: [GlacierJobDescription]? = nil, marker: String? = nil) {
            self.jobList = jobList
            self.marker = marker
        }

        private enum CodingKeys: String, CodingKey {
            case jobList = "JobList"
            case marker = "Marker"
        }
    }

    public struct ListMultipartUploadsInput: AWSEncodableShape {
        /// The AccountId value is the AWS account ID of the account that owns the vault. You can either specify an AWS account ID or optionally a single '-' (hyphen), in which case Amazon S3 Glacier uses the AWS account ID associated with the credentials used to sign the request. If you use an account ID, do not include any hyphens ('-') in the ID.
        public let accountId: String
        /// Specifies the maximum number of uploads returned in the response body. If this value is not specified, the List Uploads operation returns up to 50 uploads.
        public let limit: Int?
        /// An opaque string used for pagination. This value specifies the upload at which the listing of uploads should begin. Get the marker value from a previous List Uploads response. You need only include the marker if you are continuing the pagination of results started in a previous List Uploads request.
        public let marker: String?
        /// The name of the vault.
        public let vaultName: String

        @inlinable
        public init(accountId: String, limit: Int? = nil, marker: String? = nil, vaultName: String) {
            self.accountId = accountId
            self.limit = limit
            self.marker = marker
            self.vaultName = vaultName
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.accountId, key: "accountId")
            request.encodeQuery(self.limit, key: "limit")
            request.encodeQuery(self.marker, key: "marker")
            request.encodePath(self.vaultName, key: "vaultName")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListMultipartUploadsOutput: AWSDecodableShape {
        /// An opaque string that represents where to continue pagination of the results. You use the marker in a new List Multipart Uploads request to obtain more uploads in the list. If there are no more uploads, this value is null.
        public let marker: String?
        /// A list of in-progress multipart uploads.
        public let uploadsList: [UploadListElement]?

        @inlinable
        public init(marker: String? = nil, uploadsList: [UploadListElement]? = nil) {
            self.marker = marker
            self.uploadsList = uploadsList
        }

        private enum CodingKeys: String, CodingKey {
            case marker = "Marker"
            case uploadsList = "UploadsList"
        }
    }

    public struct ListPartsInput: AWSEncodableShape {
        /// The AccountId value is the AWS account ID of the account that owns the vault. You can either specify an AWS account ID or optionally a single '-' (hyphen), in which case Amazon S3 Glacier uses the AWS account ID associated with the credentials used to sign the request. If you use an account ID, do not include any hyphens ('-') in the ID.
        public let accountId: String
        /// The maximum number of parts to be returned. The default limit is 50. The number of parts returned might be fewer than the specified limit, but the number of returned parts never exceeds the limit.
        public let limit: Int?
        /// An opaque string used for pagination. This value specifies the part at which the listing of parts should begin. Get the marker value from the response of a previous List Parts response. You need only include the marker if you are continuing the pagination of results started in a previous List Parts request.
        public let marker: String?
        /// The upload ID of the multipart upload.
        public let uploadId: String
        /// The name of the vault.
        public let vaultName: String

        @inlinable
        public init(accountId: String, limit: Int? = nil, marker: String? = nil, uploadId: String, vaultName: String) {
            self.accountId = accountId
            self.limit = limit
            self.marker = marker
            self.uploadId = uploadId
            self.vaultName = vaultName
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.accountId, key: "accountId")
            request.encodeQuery(self.limit, key: "limit")
            request.encodeQuery(self.marker, key: "marker")
            request.encodePath(self.uploadId, key: "uploadId")
            request.encodePath(self.vaultName, key: "vaultName")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListPartsOutput: AWSDecodableShape {
        /// The description of the archive that was specified in the Initiate Multipart Upload request.
        public let archiveDescription: String?
        /// The UTC time at which the multipart upload was initiated.
        public let creationDate: String?
        /// An opaque string that represents where to continue pagination of the results. You use the marker in a new List Parts request to obtain more jobs in the list. If there are no more parts, this value is null.
        public let marker: String?
        /// The ID of the upload to which the parts are associated.
        public let multipartUploadId: String?
        /// A list of the part sizes of the multipart upload. Each object in the array contains a RangeBytes and sha256-tree-hash name/value pair.
        public let parts: [PartListElement]?
        /// The part size in bytes. This is the same value that you specified in the Initiate Multipart Upload request.
        public let partSizeInBytes: Int64?
        /// The Amazon Resource Name (ARN) of the vault to which the multipart upload was initiated.
        public let vaultARN: String?

        @inlinable
        public init(archiveDescription: String? = nil, creationDate: String? = nil, marker: String? = nil, multipartUploadId: String? = nil, parts: [PartListElement]? = nil, partSizeInBytes: Int64? = nil, vaultARN: String? = nil) {
            self.archiveDescription = archiveDescription
            self.creationDate = creationDate
            self.marker = marker
            self.multipartUploadId = multipartUploadId
            self.parts = parts
            self.partSizeInBytes = partSizeInBytes
            self.vaultARN = vaultARN
        }

        private enum CodingKeys: String, CodingKey {
            case archiveDescription = "ArchiveDescription"
            case creationDate = "CreationDate"
            case marker = "Marker"
            case multipartUploadId = "MultipartUploadId"
            case parts = "Parts"
            case partSizeInBytes = "PartSizeInBytes"
            case vaultARN = "VaultARN"
        }
    }

    public struct ListProvisionedCapacityInput: AWSEncodableShape {
        /// The AWS account ID of the account that owns the vault. You can either specify an AWS account ID or optionally a single '-' (hyphen), in which case Amazon S3 Glacier uses the AWS account ID associated with the credentials used to sign the request. If you use an account ID, don't include any hyphens ('-') in the ID.
        public let accountId: String

        @inlinable
        public init(accountId: String) {
            self.accountId = accountId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.accountId, key: "accountId")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListProvisionedCapacityOutput: AWSDecodableShape {
        /// The response body contains the following JSON fields.
        public let provisionedCapacityList: [ProvisionedCapacityDescription]?

        @inlinable
        public init(provisionedCapacityList: [ProvisionedCapacityDescription]? = nil) {
            self.provisionedCapacityList = provisionedCapacityList
        }

        private enum CodingKeys: String, CodingKey {
            case provisionedCapacityList = "ProvisionedCapacityList"
        }
    }

    public struct ListTagsForVaultInput: AWSEncodableShape {
        /// The AccountId value is the AWS account ID of the account that owns the vault. You can either specify an AWS account ID or optionally a single '-' (hyphen), in which case Amazon S3 Glacier uses the AWS account ID associated with the credentials used to sign the request. If you use an account ID, do not include any hyphens ('-') in the ID.
        public let accountId: String
        /// The name of the vault.
        public let vaultName: String

        @inlinable
        public init(accountId: String, vaultName: String) {
            self.accountId = accountId
            self.vaultName = vaultName
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.accountId, key: "accountId")
            request.encodePath(self.vaultName, key: "vaultName")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListTagsForVaultOutput: AWSDecodableShape {
        /// The tags attached to the vault. Each tag is composed of a key and a value.
        public let tags: [String: String]?

        @inlinable
        public init(tags: [String: String]? = nil) {
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case tags = "Tags"
        }
    }

    public struct ListVaultsInput: AWSEncodableShape {
        /// The AccountId value is the AWS account ID. This value must match the AWS account ID associated with the credentials used to sign the request. You can either specify an AWS account ID or optionally a single '-' (hyphen), in which case Amazon Glacier uses the AWS account ID associated with the credentials used to sign the request. If you specify your account ID, do not include any hyphens ('-') in the ID.
        public let accountId: String
        /// The maximum number of vaults to be returned. The default limit is 10. The number of vaults returned might be fewer than the specified limit, but the number of returned vaults never exceeds the limit.
        public let limit: Int?
        /// A string used for pagination. The marker specifies the vault ARN after which the listing of vaults should begin.
        public let marker: String?

        @inlinable
        public init(accountId: String, limit: Int? = nil, marker: String? = nil) {
            self.accountId = accountId
            self.limit = limit
            self.marker = marker
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.accountId, key: "accountId")
            request.encodeQuery(self.limit, key: "limit")
            request.encodeQuery(self.marker, key: "marker")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListVaultsOutput: AWSDecodableShape {
        /// The vault ARN at which to continue pagination of the results. You use the marker in another List Vaults request to obtain more vaults in the list.
        public let marker: String?
        /// List of vaults.
        public let vaultList: [DescribeVaultOutput]?

        @inlinable
        public init(marker: String? = nil, vaultList: [DescribeVaultOutput]? = nil) {
            self.marker = marker
            self.vaultList = vaultList
        }

        private enum CodingKeys: String, CodingKey {
            case marker = "Marker"
            case vaultList = "VaultList"
        }
    }

    public struct MissingParameterValueException: AWSErrorShape {
        /// 400 Bad Request
        public let code: String?
        /// Returned if no authentication data is found for the request.
        public let message: String?
        /// Client.
        public let type: String?

        @inlinable
        public init(code: String? = nil, message: String? = nil, type: String? = nil) {
            self.code = code
            self.message = message
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case code = "code"
            case message = "message"
            case type = "type"
        }
    }

    public struct OutputLocation: AWSEncodableShape & AWSDecodableShape {
        /// Describes an S3 location that will receive the results of the job request.
        public let s3: S3Location?

        @inlinable
        public init(s3: S3Location? = nil) {
            self.s3 = s3
        }

        private enum CodingKeys: String, CodingKey {
            case s3 = "S3"
        }
    }

    public struct OutputSerialization: AWSEncodableShape & AWSDecodableShape {
        /// Describes the serialization of CSV-encoded query results.
        public let csv: CSVOutput?

        @inlinable
        public init(csv: CSVOutput? = nil) {
            self.csv = csv
        }

        private enum CodingKeys: String, CodingKey {
            case csv = "csv"
        }
    }

    public struct PartListElement: AWSDecodableShape {
        /// The byte range of a part, inclusive of the upper value of the range.
        public let rangeInBytes: String?
        /// The SHA256 tree hash value that Amazon S3 Glacier calculated for the part. This field is never null.
        public let sha256TreeHash: String?

        @inlinable
        public init(rangeInBytes: String? = nil, sha256TreeHash: String? = nil) {
            self.rangeInBytes = rangeInBytes
            self.sha256TreeHash = sha256TreeHash
        }

        private enum CodingKeys: String, CodingKey {
            case rangeInBytes = "RangeInBytes"
            case sha256TreeHash = "SHA256TreeHash"
        }
    }

    public struct PolicyEnforcedException: AWSErrorShape {
        /// PolicyEnforcedException
        public let code: String?
        /// InitiateJob request denied by current data retrieval policy.
        public let message: String?
        /// Client
        public let type: String?

        @inlinable
        public init(code: String? = nil, message: String? = nil, type: String? = nil) {
            self.code = code
            self.message = message
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case code = "code"
            case message = "message"
            case type = "type"
        }
    }

    public struct ProvisionedCapacityDescription: AWSDecodableShape {
        /// The ID that identifies the provisioned capacity unit.
        public let capacityId: String?
        /// The date that the provisioned capacity unit expires, in Universal Coordinated Time (UTC).
        public let expirationDate: String?
        /// The date that the provisioned capacity unit was purchased, in Universal Coordinated Time (UTC).
        public let startDate: String?

        @inlinable
        public init(capacityId: String? = nil, expirationDate: String? = nil, startDate: String? = nil) {
            self.capacityId = capacityId
            self.expirationDate = expirationDate
            self.startDate = startDate
        }

        private enum CodingKeys: String, CodingKey {
            case capacityId = "CapacityId"
            case expirationDate = "ExpirationDate"
            case startDate = "StartDate"
        }
    }

    public struct PurchaseProvisionedCapacityInput: AWSEncodableShape {
        /// The AWS account ID of the account that owns the vault. You can either specify an AWS account ID or optionally a single '-' (hyphen), in which case Amazon S3 Glacier uses the AWS account ID associated with the credentials used to sign the request. If you use an account ID, don't include any hyphens ('-') in the ID.
        public let accountId: String

        @inlinable
        public init(accountId: String) {
            self.accountId = accountId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.accountId, key: "accountId")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct PurchaseProvisionedCapacityOutput: AWSDecodableShape {
        /// The ID that identifies the provisioned capacity unit.
        public let capacityId: String?

        @inlinable
        public init(capacityId: String? = nil) {
            self.capacityId = capacityId
        }

        public init(from decoder: Decoder) throws {
            let response = decoder.userInfo[.awsResponse]! as! ResponseDecodingContainer
            self.capacityId = try response.decodeHeaderIfPresent(String.self, key: "x-amz-capacity-id")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct RemoveTagsFromVaultInput: AWSEncodableShape {
        /// The AccountId value is the AWS account ID of the account that owns the vault. You can either specify an AWS account ID or optionally a single '-' (hyphen), in which case Amazon S3 Glacier uses the AWS account ID associated with the credentials used to sign the request. If you use an account ID, do not include any hyphens ('-') in the ID.
        public let accountId: String
        /// A list of tag keys. Each corresponding tag is removed from the vault.
        public let tagKeys: [String]?
        /// The name of the vault.
        public let vaultName: String

        @inlinable
        public init(accountId: String, tagKeys: [String]? = nil, vaultName: String) {
            self.accountId = accountId
            self.tagKeys = tagKeys
            self.vaultName = vaultName
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.accountId, key: "accountId")
            try container.encodeIfPresent(self.tagKeys, forKey: .tagKeys)
            request.encodePath(self.vaultName, key: "vaultName")
        }

        private enum CodingKeys: String, CodingKey {
            case tagKeys = "TagKeys"
        }
    }

    public struct RequestTimeoutException: AWSErrorShape {
        /// 408 Request Timeout
        public let code: String?
        /// Returned if, when uploading an archive, Amazon S3 Glacier times out while receiving the upload.
        public let message: String?
        /// Client
        public let type: String?

        @inlinable
        public init(code: String? = nil, message: String? = nil, type: String? = nil) {
            self.code = code
            self.message = message
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case code = "code"
            case message = "message"
            case type = "type"
        }
    }

    public struct ResourceNotFoundException: AWSErrorShape {
        /// 404 Not Found
        public let code: String?
        /// Returned if the specified resource (such as a vault, upload ID, or job ID) doesn't exist.
        public let message: String?
        /// Client
        public let type: String?

        @inlinable
        public init(code: String? = nil, message: String? = nil, type: String? = nil) {
            self.code = code
            self.message = message
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case code = "code"
            case message = "message"
            case type = "type"
        }
    }

    public struct S3Location: AWSEncodableShape & AWSDecodableShape {
        /// A list of grants that control access to the staged results.
        public let accessControlList: [Grant]?
        /// The name of the Amazon S3 bucket where the job results are stored.
        public let bucketName: String?
        /// The canned access control list (ACL) to apply to the job results.
        public let cannedACL: CannedACL?
        /// Contains information about the encryption used to store the job results in Amazon S3.
        public let encryption: Encryption?
        /// The prefix that is prepended to the results for this request.
        public let prefix: String?
        /// The storage class used to store the job results.
        public let storageClass: StorageClass?
        /// The tag-set that is applied to the job results.
        public let tagging: [String: String]?
        /// A map of metadata to store with the job results in Amazon S3.
        public let userMetadata: [String: String]?

        @inlinable
        public init(accessControlList: [Grant]? = nil, bucketName: String? = nil, cannedACL: CannedACL? = nil, encryption: Encryption? = nil, prefix: String? = nil, storageClass: StorageClass? = nil, tagging: [String: String]? = nil, userMetadata: [String: String]? = nil) {
            self.accessControlList = accessControlList
            self.bucketName = bucketName
            self.cannedACL = cannedACL
            self.encryption = encryption
            self.prefix = prefix
            self.storageClass = storageClass
            self.tagging = tagging
            self.userMetadata = userMetadata
        }

        private enum CodingKeys: String, CodingKey {
            case accessControlList = "AccessControlList"
            case bucketName = "BucketName"
            case cannedACL = "CannedACL"
            case encryption = "Encryption"
            case prefix = "Prefix"
            case storageClass = "StorageClass"
            case tagging = "Tagging"
            case userMetadata = "UserMetadata"
        }
    }

    public struct SelectParameters: AWSEncodableShape & AWSDecodableShape {
        /// The expression that is used to select the object.
        public let expression: String?
        /// The type of the provided expression, for example SQL.
        public let expressionType: ExpressionType?
        /// Describes the serialization format of the object.
        public let inputSerialization: InputSerialization?
        /// Describes how the results of the select job are serialized.
        public let outputSerialization: OutputSerialization?

        @inlinable
        public init(expression: String? = nil, expressionType: ExpressionType? = nil, inputSerialization: InputSerialization? = nil, outputSerialization: OutputSerialization? = nil) {
            self.expression = expression
            self.expressionType = expressionType
            self.inputSerialization = inputSerialization
            self.outputSerialization = outputSerialization
        }

        private enum CodingKeys: String, CodingKey {
            case expression = "Expression"
            case expressionType = "ExpressionType"
            case inputSerialization = "InputSerialization"
            case outputSerialization = "OutputSerialization"
        }
    }

    public struct ServiceUnavailableException: AWSErrorShape {
        /// 500 Internal Server Error
        public let code: String?
        /// Returned if the service cannot complete the request.
        public let message: String?
        /// Server
        public let type: String?

        @inlinable
        public init(code: String? = nil, message: String? = nil, type: String? = nil) {
            self.code = code
            self.message = message
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case code = "code"
            case message = "message"
            case type = "type"
        }
    }

    public struct SetDataRetrievalPolicyInput: AWSEncodableShape {
        /// The AccountId value is the AWS account ID. This value must match the AWS account ID associated with the credentials used to sign the request. You can either specify an AWS account ID or optionally a single '-' (hyphen), in which case Amazon Glacier uses the AWS account ID associated with the credentials used to sign the request. If you specify your account ID, do not include any hyphens ('-') in the ID.
        public let accountId: String
        /// The data retrieval policy in JSON format.
        public let policy: DataRetrievalPolicy?

        @inlinable
        public init(accountId: String, policy: DataRetrievalPolicy? = nil) {
            self.accountId = accountId
            self.policy = policy
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.accountId, key: "accountId")
            try container.encodeIfPresent(self.policy, forKey: .policy)
        }

        private enum CodingKeys: String, CodingKey {
            case policy = "Policy"
        }
    }

    public struct SetVaultAccessPolicyInput: AWSEncodableShape {
        /// The AccountId value is the AWS account ID of the account that owns the vault. You can either specify an AWS account ID or optionally a single '-' (hyphen), in which case Amazon S3 Glacier uses the AWS account ID associated with the credentials used to sign the request. If you use an account ID, do not include any hyphens ('-') in the ID.
        public let accountId: String
        /// The vault access policy as a JSON string.
        public let policy: VaultAccessPolicy?
        /// The name of the vault.
        public let vaultName: String

        @inlinable
        public init(accountId: String, policy: VaultAccessPolicy? = nil, vaultName: String) {
            self.accountId = accountId
            self.policy = policy
            self.vaultName = vaultName
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.singleValueContainer()
            request.encodePath(self.accountId, key: "accountId")
            try container.encode(self.policy)
            request.encodePath(self.vaultName, key: "vaultName")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct SetVaultNotificationsInput: AWSEncodableShape {
        /// The AccountId value is the AWS account ID of the account that owns the vault. You can either specify an AWS account ID or optionally a single '-' (hyphen), in which case Amazon S3 Glacier uses the AWS account ID associated with the credentials used to sign the request. If you use an account ID, do not include any hyphens ('-') in the ID.
        public let accountId: String
        /// The name of the vault.
        public let vaultName: String
        /// Provides options for specifying notification configuration.
        public let vaultNotificationConfig: VaultNotificationConfig?

        @inlinable
        public init(accountId: String, vaultName: String, vaultNotificationConfig: VaultNotificationConfig? = nil) {
            self.accountId = accountId
            self.vaultName = vaultName
            self.vaultNotificationConfig = vaultNotificationConfig
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.singleValueContainer()
            request.encodePath(self.accountId, key: "accountId")
            request.encodePath(self.vaultName, key: "vaultName")
            try container.encode(self.vaultNotificationConfig)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct UploadArchiveInput: AWSEncodableShape {
        public static let _options: AWSShapeOptions = [.allowStreaming]
        /// The AccountId value is the AWS account ID of the account that owns the vault. You can either specify an AWS account ID or optionally a single '-' (hyphen), in which case Amazon S3 Glacier uses the AWS account ID associated with the credentials used to sign the request. If you use an account ID, do not include any hyphens ('-') in the ID.
        public let accountId: String
        /// The optional description of the archive you are uploading.
        public let archiveDescription: String?
        /// The data to upload.
        public let body: AWSHTTPBody?
        /// The SHA256 tree hash of the data being uploaded.
        public let checksum: String?
        /// The name of the vault.
        public let vaultName: String

        @inlinable
        public init(accountId: String, archiveDescription: String? = nil, body: AWSHTTPBody? = nil, checksum: String? = nil, vaultName: String) {
            self.accountId = accountId
            self.archiveDescription = archiveDescription
            self.body = body
            self.checksum = checksum
            self.vaultName = vaultName
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.singleValueContainer()
            request.encodePath(self.accountId, key: "accountId")
            request.encodeHeader(self.archiveDescription, key: "x-amz-archive-description")
            try container.encode(self.body)
            request.encodeHeader(self.checksum, key: "x-amz-sha256-tree-hash")
            request.encodePath(self.vaultName, key: "vaultName")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct UploadListElement: AWSDecodableShape {
        /// The description of the archive that was specified in the Initiate Multipart Upload request.
        public let archiveDescription: String?
        /// The UTC time at which the multipart upload was initiated.
        public let creationDate: String?
        /// The ID of a multipart upload.
        public let multipartUploadId: String?
        /// The part size, in bytes, specified in the Initiate Multipart Upload request. This is the size of all the parts in the upload except the last part, which may be smaller than this size.
        public let partSizeInBytes: Int64?
        /// The Amazon Resource Name (ARN) of the vault that contains the archive.
        public let vaultARN: String?

        @inlinable
        public init(archiveDescription: String? = nil, creationDate: String? = nil, multipartUploadId: String? = nil, partSizeInBytes: Int64? = nil, vaultARN: String? = nil) {
            self.archiveDescription = archiveDescription
            self.creationDate = creationDate
            self.multipartUploadId = multipartUploadId
            self.partSizeInBytes = partSizeInBytes
            self.vaultARN = vaultARN
        }

        private enum CodingKeys: String, CodingKey {
            case archiveDescription = "ArchiveDescription"
            case creationDate = "CreationDate"
            case multipartUploadId = "MultipartUploadId"
            case partSizeInBytes = "PartSizeInBytes"
            case vaultARN = "VaultARN"
        }
    }

    public struct UploadMultipartPartInput: AWSEncodableShape {
        public static let _options: AWSShapeOptions = [.allowStreaming]
        /// The AccountId value is the AWS account ID of the account that owns the vault. You can either specify an AWS account ID or optionally a single '-' (hyphen), in which case Amazon S3 Glacier uses the AWS account ID associated with the credentials used to sign the request. If you use an account ID, do not include any hyphens ('-') in the ID.
        public let accountId: String
        /// The data to upload.
        public let body: AWSHTTPBody?
        /// The SHA256 tree hash of the data being uploaded.
        public let checksum: String?
        /// Identifies the range of bytes in the assembled archive that will be uploaded in this part. Amazon S3 Glacier uses this information to assemble the archive in the proper sequence. The format of this header follows RFC 2616. An example header is Content-Range:bytes 0-4194303/*.
        public let range: String?
        /// The upload ID of the multipart upload.
        public let uploadId: String
        /// The name of the vault.
        public let vaultName: String

        @inlinable
        public init(accountId: String, body: AWSHTTPBody? = nil, checksum: String? = nil, range: String? = nil, uploadId: String, vaultName: String) {
            self.accountId = accountId
            self.body = body
            self.checksum = checksum
            self.range = range
            self.uploadId = uploadId
            self.vaultName = vaultName
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.singleValueContainer()
            request.encodePath(self.accountId, key: "accountId")
            try container.encode(self.body)
            request.encodeHeader(self.checksum, key: "x-amz-sha256-tree-hash")
            request.encodeHeader(self.range, key: "Content-Range")
            request.encodePath(self.uploadId, key: "uploadId")
            request.encodePath(self.vaultName, key: "vaultName")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct UploadMultipartPartOutput: AWSDecodableShape {
        /// The SHA256 tree hash that Amazon S3 Glacier computed for the uploaded part.
        public let checksum: String?

        @inlinable
        public init(checksum: String? = nil) {
            self.checksum = checksum
        }

        public init(from decoder: Decoder) throws {
            let response = decoder.userInfo[.awsResponse]! as! ResponseDecodingContainer
            self.checksum = try response.decodeHeaderIfPresent(String.self, key: "x-amz-sha256-tree-hash")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct VaultAccessPolicy: AWSEncodableShape & AWSDecodableShape {
        /// The vault access policy.
        public let policy: String?

        @inlinable
        public init(policy: String? = nil) {
            self.policy = policy
        }

        private enum CodingKeys: String, CodingKey {
            case policy = "Policy"
        }
    }

    public struct VaultLockPolicy: AWSEncodableShape {
        /// The vault lock policy.
        public let policy: String?

        @inlinable
        public init(policy: String? = nil) {
            self.policy = policy
        }

        private enum CodingKeys: String, CodingKey {
            case policy = "Policy"
        }
    }

    public struct VaultNotificationConfig: AWSEncodableShape & AWSDecodableShape {
        /// A list of one or more events for which Amazon S3 Glacier will send a notification to the specified Amazon SNS topic.
        public let events: [String]?
        /// The Amazon Simple Notification Service (Amazon SNS) topic Amazon Resource Name (ARN).
        public let snsTopic: String?

        @inlinable
        public init(events: [String]? = nil, snsTopic: String? = nil) {
            self.events = events
            self.snsTopic = snsTopic
        }

        private enum CodingKeys: String, CodingKey {
            case events = "Events"
            case snsTopic = "SNSTopic"
        }
    }
}

// MARK: - Errors

/// Error enum for Glacier
public struct GlacierErrorType: AWSErrorType {
    enum Code: String {
        case insufficientCapacityException = "InsufficientCapacityException"
        case invalidParameterValueException = "InvalidParameterValueException"
        case limitExceededException = "LimitExceededException"
        case missingParameterValueException = "MissingParameterValueException"
        case policyEnforcedException = "PolicyEnforcedException"
        case requestTimeoutException = "RequestTimeoutException"
        case resourceNotFoundException = "ResourceNotFoundException"
        case serviceUnavailableException = "ServiceUnavailableException"
    }

    private let error: Code
    public let context: AWSErrorContext?

    /// initialize Glacier
    public init?(errorCode: String, context: AWSErrorContext) {
        guard let error = Code(rawValue: errorCode) else { return nil }
        self.error = error
        self.context = context
    }

    internal init(_ error: Code) {
        self.error = error
        self.context = nil
    }

    /// return error code string
    public var errorCode: String { self.error.rawValue }

    /// Returned if there is insufficient capacity to process this expedited request. This error only applies to expedited retrievals and not to standard or bulk retrievals.
    public static var insufficientCapacityException: Self { .init(.insufficientCapacityException) }
    /// Returned if a parameter of the request is incorrectly specified.
    public static var invalidParameterValueException: Self { .init(.invalidParameterValueException) }
    /// Returned if the request results in a vault or account limit being exceeded.
    public static var limitExceededException: Self { .init(.limitExceededException) }
    /// Returned if a required header or parameter is missing from the request.
    public static var missingParameterValueException: Self { .init(.missingParameterValueException) }
    /// Returned if a retrieval job would exceed the current data policy's retrieval rate limit. For more information about data retrieval policies,
    public static var policyEnforcedException: Self { .init(.policyEnforcedException) }
    /// Returned if, when uploading an archive, Amazon S3 Glacier times out while receiving the upload.
    public static var requestTimeoutException: Self { .init(.requestTimeoutException) }
    /// Returned if the specified resource (such as a vault, upload ID, or job ID) doesn't exist.
    public static var resourceNotFoundException: Self { .init(.resourceNotFoundException) }
    /// Returned if the service cannot complete the request.
    public static var serviceUnavailableException: Self { .init(.serviceUnavailableException) }
}

extension GlacierErrorType: AWSServiceErrorType {
    public static let errorCodeMap: [String: AWSErrorShape.Type] = [
        "InsufficientCapacityException": Glacier.InsufficientCapacityException.self,
        "InvalidParameterValueException": Glacier.InvalidParameterValueException.self,
        "LimitExceededException": Glacier.LimitExceededException.self,
        "MissingParameterValueException": Glacier.MissingParameterValueException.self,
        "PolicyEnforcedException": Glacier.PolicyEnforcedException.self,
        "RequestTimeoutException": Glacier.RequestTimeoutException.self,
        "ResourceNotFoundException": Glacier.ResourceNotFoundException.self,
        "ServiceUnavailableException": Glacier.ServiceUnavailableException.self
    ]
}

extension GlacierErrorType: Equatable {
    public static func == (lhs: GlacierErrorType, rhs: GlacierErrorType) -> Bool {
        lhs.error == rhs.error
    }
}

extension GlacierErrorType: CustomStringConvertible {
    public var description: String {
        return "\(self.error.rawValue): \(self.message ?? "")"
    }
}
