//===----------------------------------------------------------------------===//
//
// This source file is part of the Soto for AWS open source project
//
// Copyright (c) 2017-2024 the Soto project authors
// Licensed under Apache License v2.0
//
// See LICENSE.txt for license information
// See CONTRIBUTORS.txt for the list of Soto project authors
//
// SPDX-License-Identifier: Apache-2.0
//
//===----------------------------------------------------------------------===//

// THIS FILE IS AUTOMATICALLY GENERATED by https://github.com/soto-project/soto-codegenerator.
// DO NOT EDIT.

#if canImport(FoundationEssentials)
import FoundationEssentials
#else
import Foundation
#endif
@_spi(SotoInternal) import SotoCore

extension AppTest {
    // MARK: Enums

    public enum CaptureTool: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case awsDms = "AWS DMS"
        case precisely = "Precisely"
        public var description: String { return self.rawValue }
    }

    public enum CloudFormationActionType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case create = "Create"
        case delete = "Delete"
        public var description: String { return self.rawValue }
    }

    public enum ComparisonStatusEnum: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case different = "Different"
        case equal = "Equal"
        case equivalent = "Equivalent"
        public var description: String { return self.rawValue }
    }

    public enum DataSetType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case ps = "PS"
        public var description: String { return self.rawValue }
    }

    public enum Format: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case fixed = "FIXED"
        case lineSequential = "LINE_SEQUENTIAL"
        case variable = "VARIABLE"
        public var description: String { return self.rawValue }
    }

    public enum M2ManagedActionType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case configure = "Configure"
        case deconfigure = "Deconfigure"
        public var description: String { return self.rawValue }
    }

    public enum M2ManagedRuntime: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case microfocus = "MicroFocus"
        public var description: String { return self.rawValue }
    }

    public enum M2NonManagedActionType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case configure = "Configure"
        case deconfigure = "Deconfigure"
        public var description: String { return self.rawValue }
    }

    public enum M2NonManagedRuntime: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case bluage = "BluAge"
        public var description: String { return self.rawValue }
    }

    public enum ScriptType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case selenium = "Selenium"
        public var description: String { return self.rawValue }
    }

    public enum SourceDatabase: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case zOsDb2 = "z/OS-DB2"
        public var description: String { return self.rawValue }
    }

    public enum StepRunStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case failed = "Failed"
        case running = "Running"
        case success = "Success"
        public var description: String { return self.rawValue }
    }

    public enum TargetDatabase: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case postgresql = "PostgreSQL"
        public var description: String { return self.rawValue }
    }

    public enum TestCaseLifecycle: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case active = "Active"
        case deleting = "Deleting"
        public var description: String { return self.rawValue }
    }

    public enum TestCaseRunStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case failed = "Failed"
        case running = "Running"
        case success = "Success"
        public var description: String { return self.rawValue }
    }

    public enum TestConfigurationLifecycle: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case active = "Active"
        case deleting = "Deleting"
        public var description: String { return self.rawValue }
    }

    public enum TestRunStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case deleting = "Deleting"
        case failed = "Failed"
        case running = "Running"
        case success = "Success"
        public var description: String { return self.rawValue }
    }

    public enum TestSuiteLifecycle: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case active = "Active"
        case creating = "Creating"
        case deleting = "Deleting"
        case failed = "Failed"
        case updating = "Updating"
        public var description: String { return self.rawValue }
    }

    public enum ValidationExceptionReason: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case cannotParse = "cannotParse"
        case fieldValidationFailed = "fieldValidationFailed"
        case other = "other"
        case unknownOperation = "unknownOperation"
        public var description: String { return self.rawValue }
    }

    public enum CloudFormationStepSummary: AWSDecodableShape, Sendable {
        /// Creates the CloudFormation summary of the step.
        case createCloudformation(CreateCloudFormationSummary)
        /// Deletes the CloudFormation summary of the CloudFormation step summary.
        case deleteCloudformation(DeleteCloudFormationSummary)

        public init(from decoder: Decoder) throws {
            let container = try decoder.container(keyedBy: CodingKeys.self)
            guard container.allKeys.count == 1, let key = container.allKeys.first else {
                let context = DecodingError.Context(
                    codingPath: container.codingPath,
                    debugDescription: "Expected exactly one key, but got \(container.allKeys.count)"
                )
                throw DecodingError.dataCorrupted(context)
            }
            switch key {
            case .createCloudformation:
                let value = try container.decode(CreateCloudFormationSummary.self, forKey: .createCloudformation)
                self = .createCloudformation(value)
            case .deleteCloudformation:
                let value = try container.decode(DeleteCloudFormationSummary.self, forKey: .deleteCloudformation)
                self = .deleteCloudformation(value)
            }
        }

        private enum CodingKeys: String, CodingKey {
            case createCloudformation = "createCloudformation"
            case deleteCloudformation = "deleteCloudformation"
        }
    }

    public enum CompareFileType: AWSDecodableShape, Sendable {
        /// The database CDC of the compare file type.
        case databaseCDC(CompareDatabaseCDCSummary)
        /// The data sets in the compare file type.
        case datasets(CompareDataSetsSummary)

        public init(from decoder: Decoder) throws {
            let container = try decoder.container(keyedBy: CodingKeys.self)
            guard container.allKeys.count == 1, let key = container.allKeys.first else {
                let context = DecodingError.Context(
                    codingPath: container.codingPath,
                    debugDescription: "Expected exactly one key, but got \(container.allKeys.count)"
                )
                throw DecodingError.dataCorrupted(context)
            }
            switch key {
            case .databaseCDC:
                let value = try container.decode(CompareDatabaseCDCSummary.self, forKey: .databaseCDC)
                self = .databaseCDC(value)
            case .datasets:
                let value = try container.decode(CompareDataSetsSummary.self, forKey: .datasets)
                self = .datasets(value)
            }
        }

        private enum CodingKeys: String, CodingKey {
            case databaseCDC = "databaseCDC"
            case datasets = "datasets"
        }
    }

    public enum FileMetadata: AWSEncodableShape & AWSDecodableShape, Sendable {
        /// The database CDC of the file metadata.
        case databaseCDC(DatabaseCDC)
        /// The data sets of the file metadata.
        case dataSets([DataSet])

        public init(from decoder: Decoder) throws {
            let container = try decoder.container(keyedBy: CodingKeys.self)
            guard container.allKeys.count == 1, let key = container.allKeys.first else {
                let context = DecodingError.Context(
                    codingPath: container.codingPath,
                    debugDescription: "Expected exactly one key, but got \(container.allKeys.count)"
                )
                throw DecodingError.dataCorrupted(context)
            }
            switch key {
            case .databaseCDC:
                let value = try container.decode(DatabaseCDC.self, forKey: .databaseCDC)
                self = .databaseCDC(value)
            case .dataSets:
                let value = try container.decode([DataSet].self, forKey: .dataSets)
                self = .dataSets(value)
            }
        }

        public func encode(to encoder: Encoder) throws {
            var container = encoder.container(keyedBy: CodingKeys.self)
            switch self {
            case .databaseCDC(let value):
                try container.encode(value, forKey: .databaseCDC)
            case .dataSets(let value):
                try container.encode(value, forKey: .dataSets)
            }
        }

        public func validate(name: String) throws {
            switch self {
            case .dataSets(let value):
                try value.forEach {
                    try $0.validate(name: "\(name).dataSets[]")
                }
            default:
                break
            }
        }

        private enum CodingKeys: String, CodingKey {
            case databaseCDC = "databaseCDC"
            case dataSets = "dataSets"
        }
    }

    public enum MainframeActionSummary: AWSDecodableShape, Sendable {
        /// The batch of the mainframe action summary.
        case batch(BatchSummary)
        /// The tn3270 port of the mainframe action summary.
        case tn3270(TN3270Summary)

        public init(from decoder: Decoder) throws {
            let container = try decoder.container(keyedBy: CodingKeys.self)
            guard container.allKeys.count == 1, let key = container.allKeys.first else {
                let context = DecodingError.Context(
                    codingPath: container.codingPath,
                    debugDescription: "Expected exactly one key, but got \(container.allKeys.count)"
                )
                throw DecodingError.dataCorrupted(context)
            }
            switch key {
            case .batch:
                let value = try container.decode(BatchSummary.self, forKey: .batch)
                self = .batch(value)
            case .tn3270:
                let value = try container.decode(TN3270Summary.self, forKey: .tn3270)
                self = .tn3270(value)
            }
        }

        private enum CodingKeys: String, CodingKey {
            case batch = "batch"
            case tn3270 = "tn3270"
        }
    }

    public enum MainframeActionType: AWSEncodableShape & AWSDecodableShape, Sendable {
        /// The batch of the mainframe action type.
        case batch(Batch)
        /// The tn3270 port of the mainframe action type.
        case tn3270(TN3270)

        public init(from decoder: Decoder) throws {
            let container = try decoder.container(keyedBy: CodingKeys.self)
            guard container.allKeys.count == 1, let key = container.allKeys.first else {
                let context = DecodingError.Context(
                    codingPath: container.codingPath,
                    debugDescription: "Expected exactly one key, but got \(container.allKeys.count)"
                )
                throw DecodingError.dataCorrupted(context)
            }
            switch key {
            case .batch:
                let value = try container.decode(Batch.self, forKey: .batch)
                self = .batch(value)
            case .tn3270:
                let value = try container.decode(TN3270.self, forKey: .tn3270)
                self = .tn3270(value)
            }
        }

        public func encode(to encoder: Encoder) throws {
            var container = encoder.container(keyedBy: CodingKeys.self)
            switch self {
            case .batch(let value):
                try container.encode(value, forKey: .batch)
            case .tn3270(let value):
                try container.encode(value, forKey: .tn3270)
            }
        }

        public func validate(name: String) throws {
            switch self {
            case .batch(let value):
                try value.validate(name: "\(name).batch")
            case .tn3270(let value):
                try value.validate(name: "\(name).tn3270")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case batch = "batch"
            case tn3270 = "tn3270"
        }
    }

    public enum MainframeResourceSummary: AWSDecodableShape, Sendable {
        /// The AWS Mainframe Modernization managed application in the mainframe resource summary.
        case m2ManagedApplication(M2ManagedApplicationSummary)
        /// The AWS Mainframe Modernization non-managed application in the mainframe resource summary.
        case m2NonManagedApplication(M2NonManagedApplicationSummary)

        public init(from decoder: Decoder) throws {
            let container = try decoder.container(keyedBy: CodingKeys.self)
            guard container.allKeys.count == 1, let key = container.allKeys.first else {
                let context = DecodingError.Context(
                    codingPath: container.codingPath,
                    debugDescription: "Expected exactly one key, but got \(container.allKeys.count)"
                )
                throw DecodingError.dataCorrupted(context)
            }
            switch key {
            case .m2ManagedApplication:
                let value = try container.decode(M2ManagedApplicationSummary.self, forKey: .m2ManagedApplication)
                self = .m2ManagedApplication(value)
            case .m2NonManagedApplication:
                let value = try container.decode(M2NonManagedApplicationSummary.self, forKey: .m2NonManagedApplication)
                self = .m2NonManagedApplication(value)
            }
        }

        private enum CodingKeys: String, CodingKey {
            case m2ManagedApplication = "m2ManagedApplication"
            case m2NonManagedApplication = "m2NonManagedApplication"
        }
    }

    public enum ResourceAction: AWSEncodableShape & AWSDecodableShape, Sendable {
        /// The CloudFormation action of the resource action.
        case cloudFormationAction(CloudFormationAction)
        /// The AWS Mainframe Modernization managed application action of the resource action.
        case m2ManagedApplicationAction(M2ManagedApplicationAction)
        /// The AWS Mainframe Modernization non-managed application action of the resource action.
        case m2NonManagedApplicationAction(M2NonManagedApplicationAction)

        public init(from decoder: Decoder) throws {
            let container = try decoder.container(keyedBy: CodingKeys.self)
            guard container.allKeys.count == 1, let key = container.allKeys.first else {
                let context = DecodingError.Context(
                    codingPath: container.codingPath,
                    debugDescription: "Expected exactly one key, but got \(container.allKeys.count)"
                )
                throw DecodingError.dataCorrupted(context)
            }
            switch key {
            case .cloudFormationAction:
                let value = try container.decode(CloudFormationAction.self, forKey: .cloudFormationAction)
                self = .cloudFormationAction(value)
            case .m2ManagedApplicationAction:
                let value = try container.decode(M2ManagedApplicationAction.self, forKey: .m2ManagedApplicationAction)
                self = .m2ManagedApplicationAction(value)
            case .m2NonManagedApplicationAction:
                let value = try container.decode(M2NonManagedApplicationAction.self, forKey: .m2NonManagedApplicationAction)
                self = .m2NonManagedApplicationAction(value)
            }
        }

        public func encode(to encoder: Encoder) throws {
            var container = encoder.container(keyedBy: CodingKeys.self)
            switch self {
            case .cloudFormationAction(let value):
                try container.encode(value, forKey: .cloudFormationAction)
            case .m2ManagedApplicationAction(let value):
                try container.encode(value, forKey: .m2ManagedApplicationAction)
            case .m2NonManagedApplicationAction(let value):
                try container.encode(value, forKey: .m2NonManagedApplicationAction)
            }
        }

        public func validate(name: String) throws {
            switch self {
            case .cloudFormationAction(let value):
                try value.validate(name: "\(name).cloudFormationAction")
            case .m2ManagedApplicationAction(let value):
                try value.validate(name: "\(name).m2ManagedApplicationAction")
            case .m2NonManagedApplicationAction(let value):
                try value.validate(name: "\(name).m2NonManagedApplicationAction")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case cloudFormationAction = "cloudFormationAction"
            case m2ManagedApplicationAction = "m2ManagedApplicationAction"
            case m2NonManagedApplicationAction = "m2NonManagedApplicationAction"
        }
    }

    public enum ResourceActionSummary: AWSDecodableShape, Sendable {
        /// The CloudFormation template of the resource action summary.
        case cloudFormation(CloudFormationStepSummary)
        /// The AWS Mainframe Modernization managed application of the resource action summary.
        case m2ManagedApplication(M2ManagedApplicationStepSummary)
        /// The AWS Mainframe Modernization non-managed application of the resource action summary.
        case m2NonManagedApplication(M2NonManagedApplicationStepSummary)

        public init(from decoder: Decoder) throws {
            let container = try decoder.container(keyedBy: CodingKeys.self)
            guard container.allKeys.count == 1, let key = container.allKeys.first else {
                let context = DecodingError.Context(
                    codingPath: container.codingPath,
                    debugDescription: "Expected exactly one key, but got \(container.allKeys.count)"
                )
                throw DecodingError.dataCorrupted(context)
            }
            switch key {
            case .cloudFormation:
                let value = try container.decode(CloudFormationStepSummary.self, forKey: .cloudFormation)
                self = .cloudFormation(value)
            case .m2ManagedApplication:
                let value = try container.decode(M2ManagedApplicationStepSummary.self, forKey: .m2ManagedApplication)
                self = .m2ManagedApplication(value)
            case .m2NonManagedApplication:
                let value = try container.decode(M2NonManagedApplicationStepSummary.self, forKey: .m2NonManagedApplication)
                self = .m2NonManagedApplication(value)
            }
        }

        private enum CodingKeys: String, CodingKey {
            case cloudFormation = "cloudFormation"
            case m2ManagedApplication = "m2ManagedApplication"
            case m2NonManagedApplication = "m2NonManagedApplication"
        }
    }

    public enum ResourceType: AWSEncodableShape & AWSDecodableShape, Sendable {
        /// The CloudFormation template of the resource type.
        case cloudFormation(CloudFormation)
        /// The AWS Mainframe Modernization managed application of the resource type.
        case m2ManagedApplication(M2ManagedApplication)
        /// The AWS Mainframe Modernization non-managed application of the resource type.
        case m2NonManagedApplication(M2NonManagedApplication)

        public init(from decoder: Decoder) throws {
            let container = try decoder.container(keyedBy: CodingKeys.self)
            guard container.allKeys.count == 1, let key = container.allKeys.first else {
                let context = DecodingError.Context(
                    codingPath: container.codingPath,
                    debugDescription: "Expected exactly one key, but got \(container.allKeys.count)"
                )
                throw DecodingError.dataCorrupted(context)
            }
            switch key {
            case .cloudFormation:
                let value = try container.decode(CloudFormation.self, forKey: .cloudFormation)
                self = .cloudFormation(value)
            case .m2ManagedApplication:
                let value = try container.decode(M2ManagedApplication.self, forKey: .m2ManagedApplication)
                self = .m2ManagedApplication(value)
            case .m2NonManagedApplication:
                let value = try container.decode(M2NonManagedApplication.self, forKey: .m2NonManagedApplication)
                self = .m2NonManagedApplication(value)
            }
        }

        public func encode(to encoder: Encoder) throws {
            var container = encoder.container(keyedBy: CodingKeys.self)
            switch self {
            case .cloudFormation(let value):
                try container.encode(value, forKey: .cloudFormation)
            case .m2ManagedApplication(let value):
                try container.encode(value, forKey: .m2ManagedApplication)
            case .m2NonManagedApplication(let value):
                try container.encode(value, forKey: .m2NonManagedApplication)
            }
        }

        public func validate(name: String) throws {
            switch self {
            case .cloudFormation(let value):
                try value.validate(name: "\(name).cloudFormation")
            case .m2ManagedApplication(let value):
                try value.validate(name: "\(name).m2ManagedApplication")
            case .m2NonManagedApplication(let value):
                try value.validate(name: "\(name).m2NonManagedApplication")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case cloudFormation = "cloudFormation"
            case m2ManagedApplication = "m2ManagedApplication"
            case m2NonManagedApplication = "m2NonManagedApplication"
        }
    }

    public enum StepAction: AWSEncodableShape & AWSDecodableShape, Sendable {
        /// The compare action of the step action.
        case compareAction(CompareAction)
        /// The mainframe action of the step action.
        case mainframeAction(MainframeAction)
        /// The resource action of the step action.
        case resourceAction(ResourceAction)

        public init(from decoder: Decoder) throws {
            let container = try decoder.container(keyedBy: CodingKeys.self)
            guard container.allKeys.count == 1, let key = container.allKeys.first else {
                let context = DecodingError.Context(
                    codingPath: container.codingPath,
                    debugDescription: "Expected exactly one key, but got \(container.allKeys.count)"
                )
                throw DecodingError.dataCorrupted(context)
            }
            switch key {
            case .compareAction:
                let value = try container.decode(CompareAction.self, forKey: .compareAction)
                self = .compareAction(value)
            case .mainframeAction:
                let value = try container.decode(MainframeAction.self, forKey: .mainframeAction)
                self = .mainframeAction(value)
            case .resourceAction:
                let value = try container.decode(ResourceAction.self, forKey: .resourceAction)
                self = .resourceAction(value)
            }
        }

        public func encode(to encoder: Encoder) throws {
            var container = encoder.container(keyedBy: CodingKeys.self)
            switch self {
            case .compareAction(let value):
                try container.encode(value, forKey: .compareAction)
            case .mainframeAction(let value):
                try container.encode(value, forKey: .mainframeAction)
            case .resourceAction(let value):
                try container.encode(value, forKey: .resourceAction)
            }
        }

        public func validate(name: String) throws {
            switch self {
            case .compareAction(let value):
                try value.validate(name: "\(name).compareAction")
            case .mainframeAction(let value):
                try value.validate(name: "\(name).mainframeAction")
            case .resourceAction(let value):
                try value.validate(name: "\(name).resourceAction")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case compareAction = "compareAction"
            case mainframeAction = "mainframeAction"
            case resourceAction = "resourceAction"
        }
    }

    public enum StepRunSummary: AWSDecodableShape, Sendable {
        /// The compare action of the step run summary.
        case compareAction(CompareActionSummary)
        /// The mainframe action of the step run summary.
        case mainframeAction(MainframeActionSummary)
        /// The resource action of the step run summary.
        case resourceAction(ResourceActionSummary)

        public init(from decoder: Decoder) throws {
            let container = try decoder.container(keyedBy: CodingKeys.self)
            guard container.allKeys.count == 1, let key = container.allKeys.first else {
                let context = DecodingError.Context(
                    codingPath: container.codingPath,
                    debugDescription: "Expected exactly one key, but got \(container.allKeys.count)"
                )
                throw DecodingError.dataCorrupted(context)
            }
            switch key {
            case .compareAction:
                let value = try container.decode(CompareActionSummary.self, forKey: .compareAction)
                self = .compareAction(value)
            case .mainframeAction:
                let value = try container.decode(MainframeActionSummary.self, forKey: .mainframeAction)
                self = .mainframeAction(value)
            case .resourceAction:
                let value = try container.decode(ResourceActionSummary.self, forKey: .resourceAction)
                self = .resourceAction(value)
            }
        }

        private enum CodingKeys: String, CodingKey {
            case compareAction = "compareAction"
            case mainframeAction = "mainframeAction"
            case resourceAction = "resourceAction"
        }
    }

    // MARK: Shapes

    public struct Batch: AWSEncodableShape & AWSDecodableShape {
        /// The job name of the batch.
        public let batchJobName: String
        /// The batch job parameters of the batch.
        public let batchJobParameters: [String: String]?
        /// The export data set names of the batch.
        public let exportDataSetNames: [String]?

        @inlinable
        public init(batchJobName: String, batchJobParameters: [String: String]? = nil, exportDataSetNames: [String]? = nil) {
            self.batchJobName = batchJobName
            self.batchJobParameters = batchJobParameters
            self.exportDataSetNames = exportDataSetNames
        }

        public func validate(name: String) throws {
            try self.validate(self.batchJobName, name: "batchJobName", parent: name, pattern: "^\\S{1,1000}$")
            try self.exportDataSetNames?.forEach {
                try validate($0, name: "exportDataSetNames[]", parent: name, pattern: "^\\S{1,100}$")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case batchJobName = "batchJobName"
            case batchJobParameters = "batchJobParameters"
            case exportDataSetNames = "exportDataSetNames"
        }
    }

    public struct BatchStepInput: AWSDecodableShape {
        /// The batch job name of the batch step input.
        public let batchJobName: String
        /// The batch job parameters of the batch step input.
        public let batchJobParameters: [String: String]?
        /// The export data set names of the batch step input.
        public let exportDataSetNames: [String]?
        /// The properties of the batch step input.
        public let properties: MainframeActionProperties?
        /// The resource of the batch step input.
        public let resource: MainframeResourceSummary

        @inlinable
        public init(batchJobName: String, batchJobParameters: [String: String]? = nil, exportDataSetNames: [String]? = nil, properties: MainframeActionProperties? = nil, resource: MainframeResourceSummary) {
            self.batchJobName = batchJobName
            self.batchJobParameters = batchJobParameters
            self.exportDataSetNames = exportDataSetNames
            self.properties = properties
            self.resource = resource
        }

        private enum CodingKeys: String, CodingKey {
            case batchJobName = "batchJobName"
            case batchJobParameters = "batchJobParameters"
            case exportDataSetNames = "exportDataSetNames"
            case properties = "properties"
            case resource = "resource"
        }
    }

    public struct BatchStepOutput: AWSDecodableShape {
        /// The data set details of the batch step output.
        public let dataSetDetails: [DataSet]?
        /// The data set export location of the batch step output.
        public let dataSetExportLocation: String?
        /// The Database Migration Service (DMS) output location of the batch step output.
        public let dmsOutputLocation: String?

        @inlinable
        public init(dataSetDetails: [DataSet]? = nil, dataSetExportLocation: String? = nil, dmsOutputLocation: String? = nil) {
            self.dataSetDetails = dataSetDetails
            self.dataSetExportLocation = dataSetExportLocation
            self.dmsOutputLocation = dmsOutputLocation
        }

        private enum CodingKeys: String, CodingKey {
            case dataSetDetails = "dataSetDetails"
            case dataSetExportLocation = "dataSetExportLocation"
            case dmsOutputLocation = "dmsOutputLocation"
        }
    }

    public struct BatchSummary: AWSDecodableShape {
        /// The step input of the batch summary.
        public let stepInput: BatchStepInput
        /// The step output of the batch summary.
        public let stepOutput: BatchStepOutput?

        @inlinable
        public init(stepInput: BatchStepInput, stepOutput: BatchStepOutput? = nil) {
            self.stepInput = stepInput
            self.stepOutput = stepOutput
        }

        private enum CodingKeys: String, CodingKey {
            case stepInput = "stepInput"
            case stepOutput = "stepOutput"
        }
    }

    public struct CloudFormation: AWSEncodableShape & AWSDecodableShape {
        /// The CloudFormation properties in the CloudFormation template.
        public let parameters: [String: String]?
        /// The template location of the CloudFormation template.
        public let templateLocation: String

        @inlinable
        public init(parameters: [String: String]? = nil, templateLocation: String) {
            self.parameters = parameters
            self.templateLocation = templateLocation
        }

        public func validate(name: String) throws {
            try self.validate(self.templateLocation, name: "templateLocation", parent: name, max: 1024)
        }

        private enum CodingKeys: String, CodingKey {
            case parameters = "parameters"
            case templateLocation = "templateLocation"
        }
    }

    public struct CloudFormationAction: AWSEncodableShape & AWSDecodableShape {
        /// The action type of the CloudFormation action.
        public let actionType: CloudFormationActionType?
        /// The resource of the CloudFormation action.
        public let resource: String

        @inlinable
        public init(actionType: CloudFormationActionType? = nil, resource: String) {
            self.actionType = actionType
            self.resource = resource
        }

        public func validate(name: String) throws {
            try self.validate(self.resource, name: "resource", parent: name, pattern: "^\\S{1,1000}$")
        }

        private enum CodingKeys: String, CodingKey {
            case actionType = "actionType"
            case resource = "resource"
        }
    }

    public struct CompareAction: AWSEncodableShape & AWSDecodableShape {
        /// The input of the compare action.
        public let input: Input
        /// The output of the compare action.
        public let output: Output?

        @inlinable
        public init(input: Input, output: Output? = nil) {
            self.input = input
            self.output = output
        }

        public func validate(name: String) throws {
            try self.input.validate(name: "\(name).input")
            try self.output?.validate(name: "\(name).output")
        }

        private enum CodingKeys: String, CodingKey {
            case input = "input"
            case output = "output"
        }
    }

    public struct CompareActionSummary: AWSDecodableShape {
        /// The type of the compare action summary.
        public let type: File

        @inlinable
        public init(type: File) {
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case type = "type"
        }
    }

    public struct CompareDataSetsStepInput: AWSDecodableShape {
        /// The source data sets of the compare data sets step input location.
        public let sourceDataSets: [DataSet]
        /// The source location of the compare data sets step input location.
        public let sourceLocation: String
        /// The target data sets of the compare data sets step input location.
        public let targetDataSets: [DataSet]
        /// The target location of the compare data sets step input location.
        public let targetLocation: String

        @inlinable
        public init(sourceDataSets: [DataSet], sourceLocation: String, targetDataSets: [DataSet], targetLocation: String) {
            self.sourceDataSets = sourceDataSets
            self.sourceLocation = sourceLocation
            self.targetDataSets = targetDataSets
            self.targetLocation = targetLocation
        }

        private enum CodingKeys: String, CodingKey {
            case sourceDataSets = "sourceDataSets"
            case sourceLocation = "sourceLocation"
            case targetDataSets = "targetDataSets"
            case targetLocation = "targetLocation"
        }
    }

    public struct CompareDataSetsStepOutput: AWSDecodableShape {
        /// The comparison output location of the compare data sets step output.
        public let comparisonOutputLocation: String
        /// The comparison status of the compare data sets step output.
        public let comparisonStatus: ComparisonStatusEnum

        @inlinable
        public init(comparisonOutputLocation: String, comparisonStatus: ComparisonStatusEnum) {
            self.comparisonOutputLocation = comparisonOutputLocation
            self.comparisonStatus = comparisonStatus
        }

        private enum CodingKeys: String, CodingKey {
            case comparisonOutputLocation = "comparisonOutputLocation"
            case comparisonStatus = "comparisonStatus"
        }
    }

    public struct CompareDataSetsSummary: AWSDecodableShape {
        /// The step input of the compare data sets summary.
        public let stepInput: CompareDataSetsStepInput
        /// The step output of the compare data sets summary.
        public let stepOutput: CompareDataSetsStepOutput?

        @inlinable
        public init(stepInput: CompareDataSetsStepInput, stepOutput: CompareDataSetsStepOutput? = nil) {
            self.stepInput = stepInput
            self.stepOutput = stepOutput
        }

        private enum CodingKeys: String, CodingKey {
            case stepInput = "stepInput"
            case stepOutput = "stepOutput"
        }
    }

    public struct CompareDatabaseCDCStepInput: AWSDecodableShape {
        /// The output location of the compare database CDC step input.
        public let outputLocation: String?
        /// The source location of the compare database CDC step input.
        public let sourceLocation: String
        /// The source metadata of the compare database CDC step input.
        public let sourceMetadata: SourceDatabaseMetadata
        /// The target location of the compare database CDC step input.
        public let targetLocation: String
        /// The target metadata location of the compare database CDC step input.
        public let targetMetadata: TargetDatabaseMetadata

        @inlinable
        public init(outputLocation: String? = nil, sourceLocation: String, sourceMetadata: SourceDatabaseMetadata, targetLocation: String, targetMetadata: TargetDatabaseMetadata) {
            self.outputLocation = outputLocation
            self.sourceLocation = sourceLocation
            self.sourceMetadata = sourceMetadata
            self.targetLocation = targetLocation
            self.targetMetadata = targetMetadata
        }

        private enum CodingKeys: String, CodingKey {
            case outputLocation = "outputLocation"
            case sourceLocation = "sourceLocation"
            case sourceMetadata = "sourceMetadata"
            case targetLocation = "targetLocation"
            case targetMetadata = "targetMetadata"
        }
    }

    public struct CompareDatabaseCDCStepOutput: AWSDecodableShape {
        /// The comparison output of the compare database CDC step output.
        public let comparisonOutputLocation: String
        /// The comparison status of the compare database CDC step output.
        public let comparisonStatus: ComparisonStatusEnum

        @inlinable
        public init(comparisonOutputLocation: String, comparisonStatus: ComparisonStatusEnum) {
            self.comparisonOutputLocation = comparisonOutputLocation
            self.comparisonStatus = comparisonStatus
        }

        private enum CodingKeys: String, CodingKey {
            case comparisonOutputLocation = "comparisonOutputLocation"
            case comparisonStatus = "comparisonStatus"
        }
    }

    public struct CompareDatabaseCDCSummary: AWSDecodableShape {
        /// The step input of the compare database CDC summary.
        public let stepInput: CompareDatabaseCDCStepInput
        /// The step output of the compare database CDC summary.
        public let stepOutput: CompareDatabaseCDCStepOutput?

        @inlinable
        public init(stepInput: CompareDatabaseCDCStepInput, stepOutput: CompareDatabaseCDCStepOutput? = nil) {
            self.stepInput = stepInput
            self.stepOutput = stepOutput
        }

        private enum CodingKeys: String, CodingKey {
            case stepInput = "stepInput"
            case stepOutput = "stepOutput"
        }
    }

    public struct ConflictException: AWSErrorShape {
        public let message: String
        /// The resource ID of the conflicts with existing resources.
        public let resourceId: String?
        /// The resource type of the conflicts with existing resources.
        public let resourceType: String?

        @inlinable
        public init(message: String, resourceId: String? = nil, resourceType: String? = nil) {
            self.message = message
            self.resourceId = resourceId
            self.resourceType = resourceType
        }

        private enum CodingKeys: String, CodingKey {
            case message = "message"
            case resourceId = "resourceId"
            case resourceType = "resourceType"
        }
    }

    public struct CreateCloudFormationStepInput: AWSDecodableShape {
        /// The CloudFormation properties of the CloudFormation step input.
        public let parameters: [String: String]?
        /// The template location of the CloudFormation step input.
        public let templateLocation: String

        @inlinable
        public init(parameters: [String: String]? = nil, templateLocation: String) {
            self.parameters = parameters
            self.templateLocation = templateLocation
        }

        private enum CodingKeys: String, CodingKey {
            case parameters = "parameters"
            case templateLocation = "templateLocation"
        }
    }

    public struct CreateCloudFormationStepOutput: AWSDecodableShape {
        /// The exports of the CloudFormation step output.
        public let exports: [String: String]?
        /// The stack ID of the CloudFormation step output.
        public let stackId: String

        @inlinable
        public init(exports: [String: String]? = nil, stackId: String) {
            self.exports = exports
            self.stackId = stackId
        }

        private enum CodingKeys: String, CodingKey {
            case exports = "exports"
            case stackId = "stackId"
        }
    }

    public struct CreateCloudFormationSummary: AWSDecodableShape {
        /// The step input of the CloudFormation summary.
        public let stepInput: CreateCloudFormationStepInput
        /// The step output of the CloudFormation summary.
        public let stepOutput: CreateCloudFormationStepOutput?

        @inlinable
        public init(stepInput: CreateCloudFormationStepInput, stepOutput: CreateCloudFormationStepOutput? = nil) {
            self.stepInput = stepInput
            self.stepOutput = stepOutput
        }

        private enum CodingKeys: String, CodingKey {
            case stepInput = "stepInput"
            case stepOutput = "stepOutput"
        }
    }

    public struct CreateTestCaseRequest: AWSEncodableShape {
        /// The client token of the test case.
        public let clientToken: String?
        /// The description of the test case.
        public let description: String?
        /// The name of the test case.
        public let name: String
        /// The steps in the test case.
        public let steps: [Step]
        /// The specified tags of the test case.
        public let tags: [String: String]?

        @inlinable
        public init(clientToken: String? = CreateTestCaseRequest.idempotencyToken(), description: String? = nil, name: String, steps: [Step], tags: [String: String]? = nil) {
            self.clientToken = clientToken
            self.description = description
            self.name = name
            self.steps = steps
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "^[A-Za-z0-9\\-]{1,64}$")
            try self.validate(self.description, name: "description", parent: name, max: 1000)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[A-Za-z][A-Za-z0-9_\\-]{1,59}$")
            try self.steps.forEach {
                try $0.validate(name: "\(name).steps[]")
            }
            try self.validate(self.steps, name: "steps", parent: name, max: 20)
            try self.validate(self.steps, name: "steps", parent: name, min: 1)
            try self.tags?.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.key, name: "tags.key", parent: name, pattern: "^(?!aws:).+$")
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 200)
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "clientToken"
            case description = "description"
            case name = "name"
            case steps = "steps"
            case tags = "tags"
        }
    }

    public struct CreateTestCaseResponse: AWSDecodableShape {
        /// The test case ID of the test case.
        public let testCaseId: String
        /// The test case version of the test case.
        public let testCaseVersion: Int

        @inlinable
        public init(testCaseId: String, testCaseVersion: Int) {
            self.testCaseId = testCaseId
            self.testCaseVersion = testCaseVersion
        }

        private enum CodingKeys: String, CodingKey {
            case testCaseId = "testCaseId"
            case testCaseVersion = "testCaseVersion"
        }
    }

    public struct CreateTestConfigurationRequest: AWSEncodableShape {
        /// The client token of the test configuration.
        public let clientToken: String?
        /// The description of the test configuration.
        public let description: String?
        /// The name of the test configuration.
        public let name: String
        /// The properties of the test configuration.
        public let properties: [String: String]?
        /// The defined resources of the test configuration.
        public let resources: [Resource]
        /// The service settings of the test configuration.
        public let serviceSettings: ServiceSettings?
        /// The tags of the test configuration.
        public let tags: [String: String]?

        @inlinable
        public init(clientToken: String? = CreateTestConfigurationRequest.idempotencyToken(), description: String? = nil, name: String, properties: [String: String]? = nil, resources: [Resource], serviceSettings: ServiceSettings? = nil, tags: [String: String]? = nil) {
            self.clientToken = clientToken
            self.description = description
            self.name = name
            self.properties = properties
            self.resources = resources
            self.serviceSettings = serviceSettings
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "^[A-Za-z0-9\\-]{1,64}$")
            try self.validate(self.description, name: "description", parent: name, max: 1000)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[A-Za-z][A-Za-z0-9_\\-]{1,59}$")
            try self.resources.forEach {
                try $0.validate(name: "\(name).resources[]")
            }
            try self.validate(self.resources, name: "resources", parent: name, max: 20)
            try self.validate(self.resources, name: "resources", parent: name, min: 1)
            try self.tags?.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.key, name: "tags.key", parent: name, pattern: "^(?!aws:).+$")
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 200)
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "clientToken"
            case description = "description"
            case name = "name"
            case properties = "properties"
            case resources = "resources"
            case serviceSettings = "serviceSettings"
            case tags = "tags"
        }
    }

    public struct CreateTestConfigurationResponse: AWSDecodableShape {
        /// The test configuration ID.
        public let testConfigurationId: String
        /// The test configuration version.
        public let testConfigurationVersion: Int

        @inlinable
        public init(testConfigurationId: String, testConfigurationVersion: Int) {
            self.testConfigurationId = testConfigurationId
            self.testConfigurationVersion = testConfigurationVersion
        }

        private enum CodingKeys: String, CodingKey {
            case testConfigurationId = "testConfigurationId"
            case testConfigurationVersion = "testConfigurationVersion"
        }
    }

    public struct CreateTestSuiteRequest: AWSEncodableShape {
        /// The after steps of the test suite.
        public let afterSteps: [Step]?
        /// The before steps of the test suite.
        public let beforeSteps: [Step]?
        /// The client token of the test suite.
        public let clientToken: String?
        /// The description of the test suite.
        public let description: String?
        /// The name of the test suite.
        public let name: String
        /// The tags of the test suite.
        public let tags: [String: String]?
        /// The test cases in the test suite.
        public let testCases: TestCases

        @inlinable
        public init(afterSteps: [Step]? = nil, beforeSteps: [Step]? = nil, clientToken: String? = CreateTestSuiteRequest.idempotencyToken(), description: String? = nil, name: String, tags: [String: String]? = nil, testCases: TestCases) {
            self.afterSteps = afterSteps
            self.beforeSteps = beforeSteps
            self.clientToken = clientToken
            self.description = description
            self.name = name
            self.tags = tags
            self.testCases = testCases
        }

        public func validate(name: String) throws {
            try self.afterSteps?.forEach {
                try $0.validate(name: "\(name).afterSteps[]")
            }
            try self.validate(self.afterSteps, name: "afterSteps", parent: name, max: 20)
            try self.validate(self.afterSteps, name: "afterSteps", parent: name, min: 1)
            try self.beforeSteps?.forEach {
                try $0.validate(name: "\(name).beforeSteps[]")
            }
            try self.validate(self.beforeSteps, name: "beforeSteps", parent: name, max: 20)
            try self.validate(self.beforeSteps, name: "beforeSteps", parent: name, min: 1)
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "^[A-Za-z0-9\\-]{1,64}$")
            try self.validate(self.description, name: "description", parent: name, max: 1000)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[A-Za-z][A-Za-z0-9_\\-]{1,59}$")
            try self.tags?.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.key, name: "tags.key", parent: name, pattern: "^(?!aws:).+$")
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 200)
            try self.testCases.validate(name: "\(name).testCases")
        }

        private enum CodingKeys: String, CodingKey {
            case afterSteps = "afterSteps"
            case beforeSteps = "beforeSteps"
            case clientToken = "clientToken"
            case description = "description"
            case name = "name"
            case tags = "tags"
            case testCases = "testCases"
        }
    }

    public struct CreateTestSuiteResponse: AWSDecodableShape {
        /// The suite ID of the test suite.
        public let testSuiteId: String
        /// The suite version of the test suite.
        public let testSuiteVersion: Int

        @inlinable
        public init(testSuiteId: String, testSuiteVersion: Int) {
            self.testSuiteId = testSuiteId
            self.testSuiteVersion = testSuiteVersion
        }

        private enum CodingKeys: String, CodingKey {
            case testSuiteId = "testSuiteId"
            case testSuiteVersion = "testSuiteVersion"
        }
    }

    public struct DataSet: AWSEncodableShape & AWSDecodableShape {
        /// The CCSID of the data set.
        public let ccsid: String
        /// The format of the data set.
        public let format: Format
        /// The length of the data set.
        public let length: Int
        /// The name of the data set.
        public let name: String
        /// The type of the data set.
        public let type: DataSetType

        @inlinable
        public init(ccsid: String, format: Format, length: Int, name: String, type: DataSetType) {
            self.ccsid = ccsid
            self.format = format
            self.length = length
            self.name = name
            self.type = type
        }

        public func validate(name: String) throws {
            try self.validate(self.ccsid, name: "ccsid", parent: name, pattern: "^\\S{1,50}$")
            try self.validate(self.name, name: "name", parent: name, pattern: "^\\S{1,100}$")
        }

        private enum CodingKeys: String, CodingKey {
            case ccsid = "ccsid"
            case format = "format"
            case length = "length"
            case name = "name"
            case type = "type"
        }
    }

    public struct DatabaseCDC: AWSEncodableShape & AWSDecodableShape {
        /// The source metadata of the database CDC.
        public let sourceMetadata: SourceDatabaseMetadata
        /// The target metadata of the database CDC.
        public let targetMetadata: TargetDatabaseMetadata

        @inlinable
        public init(sourceMetadata: SourceDatabaseMetadata, targetMetadata: TargetDatabaseMetadata) {
            self.sourceMetadata = sourceMetadata
            self.targetMetadata = targetMetadata
        }

        private enum CodingKeys: String, CodingKey {
            case sourceMetadata = "sourceMetadata"
            case targetMetadata = "targetMetadata"
        }
    }

    public struct DeleteCloudFormationStepInput: AWSDecodableShape {
        /// The stack ID of the deleted CloudFormation step input.
        public let stackId: String

        @inlinable
        public init(stackId: String) {
            self.stackId = stackId
        }

        private enum CodingKeys: String, CodingKey {
            case stackId = "stackId"
        }
    }

    public struct DeleteCloudFormationStepOutput: AWSDecodableShape {
        public init() {}
    }

    public struct DeleteCloudFormationSummary: AWSDecodableShape {
        /// The step input of the deleted CloudFormation summary.
        public let stepInput: DeleteCloudFormationStepInput
        /// The step output of the deleted CloudFormation summary.
        public let stepOutput: DeleteCloudFormationStepOutput?

        @inlinable
        public init(stepInput: DeleteCloudFormationStepInput, stepOutput: DeleteCloudFormationStepOutput? = nil) {
            self.stepInput = stepInput
            self.stepOutput = stepOutput
        }

        private enum CodingKeys: String, CodingKey {
            case stepInput = "stepInput"
            case stepOutput = "stepOutput"
        }
    }

    public struct DeleteTestCaseRequest: AWSEncodableShape {
        /// The test case ID of the test case.
        public let testCaseId: String

        @inlinable
        public init(testCaseId: String) {
            self.testCaseId = testCaseId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.testCaseId, key: "testCaseId")
        }

        public func validate(name: String) throws {
            try self.validate(self.testCaseId, name: "testCaseId", parent: name, pattern: "^[A-Za-z0-9:/\\-]{1,100}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteTestCaseResponse: AWSDecodableShape {
        public init() {}
    }

    public struct DeleteTestConfigurationRequest: AWSEncodableShape {
        /// The test ID of the test configuration.
        public let testConfigurationId: String

        @inlinable
        public init(testConfigurationId: String) {
            self.testConfigurationId = testConfigurationId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.testConfigurationId, key: "testConfigurationId")
        }

        public func validate(name: String) throws {
            try self.validate(self.testConfigurationId, name: "testConfigurationId", parent: name, pattern: "^[A-Za-z0-9:/\\-]{1,100}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteTestConfigurationResponse: AWSDecodableShape {
        public init() {}
    }

    public struct DeleteTestRunRequest: AWSEncodableShape {
        /// The run ID of the test run.
        public let testRunId: String

        @inlinable
        public init(testRunId: String) {
            self.testRunId = testRunId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.testRunId, key: "testRunId")
        }

        public func validate(name: String) throws {
            try self.validate(self.testRunId, name: "testRunId", parent: name, pattern: "^[A-Za-z0-9:/\\-]{1,100}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteTestRunResponse: AWSDecodableShape {
        public init() {}
    }

    public struct DeleteTestSuiteRequest: AWSEncodableShape {
        /// The test ID of the test suite.
        public let testSuiteId: String

        @inlinable
        public init(testSuiteId: String) {
            self.testSuiteId = testSuiteId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.testSuiteId, key: "testSuiteId")
        }

        public func validate(name: String) throws {
            try self.validate(self.testSuiteId, name: "testSuiteId", parent: name, pattern: "^[A-Za-z0-9:/\\-]{1,100}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteTestSuiteResponse: AWSDecodableShape {
        public init() {}
    }

    public struct GetTestCaseRequest: AWSEncodableShape {
        /// The request test ID of the test case.
        public let testCaseId: String
        /// The test case version of the test case.
        public let testCaseVersion: Int?

        @inlinable
        public init(testCaseId: String, testCaseVersion: Int? = nil) {
            self.testCaseId = testCaseId
            self.testCaseVersion = testCaseVersion
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.testCaseId, key: "testCaseId")
            request.encodeQuery(self.testCaseVersion, key: "testCaseVersion")
        }

        public func validate(name: String) throws {
            try self.validate(self.testCaseId, name: "testCaseId", parent: name, pattern: "^[A-Za-z0-9:/\\-]{1,100}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetTestCaseResponse: AWSDecodableShape {
        /// The creation time of the test case.
        public let creationTime: Date
        /// The description of the test case.
        public let description: String?
        /// The last update time of the test case.
        public let lastUpdateTime: Date
        /// The latest version of the test case.
        public let latestVersion: TestCaseLatestVersion
        /// The name of the test case.
        public let name: String
        /// The status of the test case.
        public let status: TestCaseLifecycle
        /// The status reason of the test case.
        public let statusReason: String?
        /// The steps of the test case.
        public let steps: [Step]
        /// The tags of the test case.
        public let tags: [String: String]?
        /// The Amazon Resource Name (ARN) of the test case.
        public let testCaseArn: String
        /// The response test ID of the test case.
        public let testCaseId: String
        /// The case version of the test case.
        public let testCaseVersion: Int

        @inlinable
        public init(creationTime: Date, description: String? = nil, lastUpdateTime: Date, latestVersion: TestCaseLatestVersion, name: String, status: TestCaseLifecycle, statusReason: String? = nil, steps: [Step], tags: [String: String]? = nil, testCaseArn: String, testCaseId: String, testCaseVersion: Int) {
            self.creationTime = creationTime
            self.description = description
            self.lastUpdateTime = lastUpdateTime
            self.latestVersion = latestVersion
            self.name = name
            self.status = status
            self.statusReason = statusReason
            self.steps = steps
            self.tags = tags
            self.testCaseArn = testCaseArn
            self.testCaseId = testCaseId
            self.testCaseVersion = testCaseVersion
        }

        private enum CodingKeys: String, CodingKey {
            case creationTime = "creationTime"
            case description = "description"
            case lastUpdateTime = "lastUpdateTime"
            case latestVersion = "latestVersion"
            case name = "name"
            case status = "status"
            case statusReason = "statusReason"
            case steps = "steps"
            case tags = "tags"
            case testCaseArn = "testCaseArn"
            case testCaseId = "testCaseId"
            case testCaseVersion = "testCaseVersion"
        }
    }

    public struct GetTestConfigurationRequest: AWSEncodableShape {
        /// The request test configuration ID.
        public let testConfigurationId: String
        /// The test configuration version.
        public let testConfigurationVersion: Int?

        @inlinable
        public init(testConfigurationId: String, testConfigurationVersion: Int? = nil) {
            self.testConfigurationId = testConfigurationId
            self.testConfigurationVersion = testConfigurationVersion
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.testConfigurationId, key: "testConfigurationId")
            request.encodeQuery(self.testConfigurationVersion, key: "testConfigurationVersion")
        }

        public func validate(name: String) throws {
            try self.validate(self.testConfigurationId, name: "testConfigurationId", parent: name, pattern: "^[A-Za-z0-9:/\\-]{1,100}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetTestConfigurationResponse: AWSDecodableShape {
        /// The creation time of the test configuration.
        public let creationTime: Date
        /// The description of the test configuration.
        public let description: String?
        /// The last update time of the test configuration.
        public let lastUpdateTime: Date
        /// The latest version of the test configuration.
        public let latestVersion: TestConfigurationLatestVersion
        /// The test configuration name
        public let name: String
        /// The properties of the test configuration.
        public let properties: [String: String]
        /// The resources of the test configuration.
        public let resources: [Resource]
        /// The service settings of the test configuration.
        public let serviceSettings: ServiceSettings?
        /// The status of the test configuration.
        public let status: TestConfigurationLifecycle
        /// The status reason of the test configuration.
        public let statusReason: String?
        /// The tags of the test configuration.
        public let tags: [String: String]?
        /// The test configuration Amazon Resource Name (ARN).
        public let testConfigurationArn: String
        /// The response test configuration ID.
        public let testConfigurationId: String
        /// The test configuration version.
        public let testConfigurationVersion: Int

        @inlinable
        public init(creationTime: Date, description: String? = nil, lastUpdateTime: Date, latestVersion: TestConfigurationLatestVersion, name: String, properties: [String: String], resources: [Resource], serviceSettings: ServiceSettings? = nil, status: TestConfigurationLifecycle, statusReason: String? = nil, tags: [String: String]? = nil, testConfigurationArn: String, testConfigurationId: String, testConfigurationVersion: Int) {
            self.creationTime = creationTime
            self.description = description
            self.lastUpdateTime = lastUpdateTime
            self.latestVersion = latestVersion
            self.name = name
            self.properties = properties
            self.resources = resources
            self.serviceSettings = serviceSettings
            self.status = status
            self.statusReason = statusReason
            self.tags = tags
            self.testConfigurationArn = testConfigurationArn
            self.testConfigurationId = testConfigurationId
            self.testConfigurationVersion = testConfigurationVersion
        }

        private enum CodingKeys: String, CodingKey {
            case creationTime = "creationTime"
            case description = "description"
            case lastUpdateTime = "lastUpdateTime"
            case latestVersion = "latestVersion"
            case name = "name"
            case properties = "properties"
            case resources = "resources"
            case serviceSettings = "serviceSettings"
            case status = "status"
            case statusReason = "statusReason"
            case tags = "tags"
            case testConfigurationArn = "testConfigurationArn"
            case testConfigurationId = "testConfigurationId"
            case testConfigurationVersion = "testConfigurationVersion"
        }
    }

    public struct GetTestRunStepRequest: AWSEncodableShape {
        /// The step name of the test run step.
        public let stepName: String
        /// The test case ID of a test run step.
        public let testCaseId: String?
        /// The test run ID of the test run step.
        public let testRunId: String
        /// The test suite ID of a test run step.
        public let testSuiteId: String?

        @inlinable
        public init(stepName: String, testCaseId: String? = nil, testRunId: String, testSuiteId: String? = nil) {
            self.stepName = stepName
            self.testCaseId = testCaseId
            self.testRunId = testRunId
            self.testSuiteId = testSuiteId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.stepName, key: "stepName")
            request.encodeQuery(self.testCaseId, key: "testCaseId")
            request.encodePath(self.testRunId, key: "testRunId")
            request.encodeQuery(self.testSuiteId, key: "testSuiteId")
        }

        public func validate(name: String) throws {
            try self.validate(self.stepName, name: "stepName", parent: name, pattern: "^[A-Za-z][A-Za-z0-9_\\-]{1,59}$")
            try self.validate(self.testCaseId, name: "testCaseId", parent: name, pattern: "^[A-Za-z0-9:/\\-]{1,100}$")
            try self.validate(self.testRunId, name: "testRunId", parent: name, pattern: "^[A-Za-z0-9:/\\-]{1,100}$")
            try self.validate(self.testSuiteId, name: "testSuiteId", parent: name, pattern: "^[A-Za-z0-9:/\\-]{1,100}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetTestRunStepResponse: AWSDecodableShape {
        /// The after steps of the test run step.
        public let afterStep: Bool?
        /// The before steps of the test run step.
        public let beforeStep: Bool?
        /// The run end time of the test run step.
        public let runEndTime: Date?
        /// The run start time of the test run step.
        public let runStartTime: Date
        /// The status of the test run step.
        public let status: StepRunStatus
        /// The status reason of the test run step.
        public let statusReason: String?
        /// The step name of the test run step.
        public let stepName: String
        /// The step run summary of the test run step.
        public let stepRunSummary: StepRunSummary?
        /// The test case ID of the test run step.
        public let testCaseId: String?
        /// The test case version of the test run step.
        public let testCaseVersion: Int?
        /// The test run ID of the test run step.
        public let testRunId: String
        /// The test suite ID of the test run step.
        public let testSuiteId: String?
        /// The test suite version of the test run step.
        public let testSuiteVersion: Int?

        @inlinable
        public init(afterStep: Bool? = nil, beforeStep: Bool? = nil, runEndTime: Date? = nil, runStartTime: Date, status: StepRunStatus, statusReason: String? = nil, stepName: String, stepRunSummary: StepRunSummary? = nil, testCaseId: String? = nil, testCaseVersion: Int? = nil, testRunId: String, testSuiteId: String? = nil, testSuiteVersion: Int? = nil) {
            self.afterStep = afterStep
            self.beforeStep = beforeStep
            self.runEndTime = runEndTime
            self.runStartTime = runStartTime
            self.status = status
            self.statusReason = statusReason
            self.stepName = stepName
            self.stepRunSummary = stepRunSummary
            self.testCaseId = testCaseId
            self.testCaseVersion = testCaseVersion
            self.testRunId = testRunId
            self.testSuiteId = testSuiteId
            self.testSuiteVersion = testSuiteVersion
        }

        private enum CodingKeys: String, CodingKey {
            case afterStep = "afterStep"
            case beforeStep = "beforeStep"
            case runEndTime = "runEndTime"
            case runStartTime = "runStartTime"
            case status = "status"
            case statusReason = "statusReason"
            case stepName = "stepName"
            case stepRunSummary = "stepRunSummary"
            case testCaseId = "testCaseId"
            case testCaseVersion = "testCaseVersion"
            case testRunId = "testRunId"
            case testSuiteId = "testSuiteId"
            case testSuiteVersion = "testSuiteVersion"
        }
    }

    public struct GetTestSuiteRequest: AWSEncodableShape {
        /// The ID of the test suite.
        public let testSuiteId: String
        /// The version of the test suite.
        public let testSuiteVersion: Int?

        @inlinable
        public init(testSuiteId: String, testSuiteVersion: Int? = nil) {
            self.testSuiteId = testSuiteId
            self.testSuiteVersion = testSuiteVersion
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.testSuiteId, key: "testSuiteId")
            request.encodeQuery(self.testSuiteVersion, key: "testSuiteVersion")
        }

        public func validate(name: String) throws {
            try self.validate(self.testSuiteId, name: "testSuiteId", parent: name, pattern: "^[A-Za-z0-9:/\\-]{1,100}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetTestSuiteResponse: AWSDecodableShape {
        /// The after steps of the test suite.
        public let afterSteps: [Step]
        /// The before steps of the test suite.
        public let beforeSteps: [Step]
        /// The creation time of the test suite.
        public let creationTime: Date
        /// The description of the test suite.
        public let description: String?
        /// The last update time of the test suite.
        public let lastUpdateTime: Date
        /// The latest version of the test suite.
        public let latestVersion: TestSuiteLatestVersion
        /// The name of the test suite.
        public let name: String
        /// The status of the test suite.
        public let status: TestSuiteLifecycle?
        /// The status reason of the test suite.
        public let statusReason: String?
        /// The tags of the test suite.
        public let tags: [String: String]?
        /// The test cases of the test suite.
        public let testCases: TestCases
        /// The test suite Amazon Resource Name (ARN).
        public let testSuiteArn: String
        /// The response ID of the test suite.
        public let testSuiteId: String
        /// The version of the test suite.
        public let testSuiteVersion: Int

        @inlinable
        public init(afterSteps: [Step], beforeSteps: [Step], creationTime: Date, description: String? = nil, lastUpdateTime: Date, latestVersion: TestSuiteLatestVersion, name: String, status: TestSuiteLifecycle? = nil, statusReason: String? = nil, tags: [String: String]? = nil, testCases: TestCases, testSuiteArn: String, testSuiteId: String, testSuiteVersion: Int) {
            self.afterSteps = afterSteps
            self.beforeSteps = beforeSteps
            self.creationTime = creationTime
            self.description = description
            self.lastUpdateTime = lastUpdateTime
            self.latestVersion = latestVersion
            self.name = name
            self.status = status
            self.statusReason = statusReason
            self.tags = tags
            self.testCases = testCases
            self.testSuiteArn = testSuiteArn
            self.testSuiteId = testSuiteId
            self.testSuiteVersion = testSuiteVersion
        }

        private enum CodingKeys: String, CodingKey {
            case afterSteps = "afterSteps"
            case beforeSteps = "beforeSteps"
            case creationTime = "creationTime"
            case description = "description"
            case lastUpdateTime = "lastUpdateTime"
            case latestVersion = "latestVersion"
            case name = "name"
            case status = "status"
            case statusReason = "statusReason"
            case tags = "tags"
            case testCases = "testCases"
            case testSuiteArn = "testSuiteArn"
            case testSuiteId = "testSuiteId"
            case testSuiteVersion = "testSuiteVersion"
        }
    }

    public struct InputFile: AWSEncodableShape & AWSDecodableShape {
        /// The file metadata of the input file.
        public let fileMetadata: FileMetadata
        /// The source location of the input file.
        public let sourceLocation: String
        /// The target location of the input file.
        public let targetLocation: String

        @inlinable
        public init(fileMetadata: FileMetadata, sourceLocation: String, targetLocation: String) {
            self.fileMetadata = fileMetadata
            self.sourceLocation = sourceLocation
            self.targetLocation = targetLocation
        }

        public func validate(name: String) throws {
            try self.fileMetadata.validate(name: "\(name).fileMetadata")
            try self.validate(self.sourceLocation, name: "sourceLocation", parent: name, pattern: "^\\S{1,1000}$")
            try self.validate(self.targetLocation, name: "targetLocation", parent: name, pattern: "^\\S{1,1000}$")
        }

        private enum CodingKeys: String, CodingKey {
            case fileMetadata = "fileMetadata"
            case sourceLocation = "sourceLocation"
            case targetLocation = "targetLocation"
        }
    }

    public struct InternalServerException: AWSErrorShape {
        public let message: String
        /// The number of seconds to retry the query.
        public let retryAfterSeconds: Int?

        @inlinable
        public init(message: String, retryAfterSeconds: Int? = nil) {
            self.message = message
            self.retryAfterSeconds = retryAfterSeconds
        }

        public init(from decoder: Decoder) throws {
            let response = decoder.userInfo[.awsResponse]! as! ResponseDecodingContainer
            let container = try decoder.container(keyedBy: CodingKeys.self)
            self.message = try container.decode(String.self, forKey: .message)
            self.retryAfterSeconds = try response.decodeHeaderIfPresent(Int.self, key: "Retry-After")
        }

        private enum CodingKeys: String, CodingKey {
            case message = "message"
        }
    }

    public struct ListTagsForResourceRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the resource.
        public let resourceArn: String

        @inlinable
        public init(resourceArn: String) {
            self.resourceArn = resourceArn
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.resourceArn, key: "resourceArn")
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, pattern: "^arn:(aws|aws-cn|aws-iso|aws-iso-[a-z]{1}|aws-us-gov):[A-Za-z0-9][A-Za-z0-9_/.-]{0,62}:([a-z]{2}-((iso[a-z]{0,1}-)|(gov-)){0,1}[a-z]+-[0-9]):[0-9]{12}:[A-Za-z0-9/][A-Za-z0-9:_/+=,@.-]{0,1023}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListTagsForResourceResponse: AWSDecodableShape {
        /// The tags of the resource.
        public let tags: [String: String]

        @inlinable
        public init(tags: [String: String]) {
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case tags = "tags"
        }
    }

    public struct ListTestCasesRequest: AWSEncodableShape {
        /// The maximum results of the test case.
        public let maxResults: Int?
        /// The next token of the test cases.
        public let nextToken: String?
        /// The IDs of the test cases.
        public let testCaseIds: [String]?

        @inlinable
        public init(maxResults: Int? = nil, nextToken: String? = nil, testCaseIds: [String]? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.testCaseIds = testCaseIds
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
            request.encodeQuery(self.testCaseIds, key: "testCaseIds")
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^\\S{1,2000}$")
            try self.testCaseIds?.forEach {
                try validate($0, name: "testCaseIds[]", parent: name, pattern: "^[A-Za-z0-9:/\\-]{1,100}$")
            }
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListTestCasesResponse: AWSDecodableShape {
        /// The next token in test cases.
        public let nextToken: String?
        /// The test cases in an application.
        public let testCases: [TestCaseSummary]

        @inlinable
        public init(nextToken: String? = nil, testCases: [TestCaseSummary]) {
            self.nextToken = nextToken
            self.testCases = testCases
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "nextToken"
            case testCases = "testCases"
        }
    }

    public struct ListTestConfigurationsRequest: AWSEncodableShape {
        /// The maximum results of the test configuration.
        public let maxResults: Int?
        /// The next token for the test configurations.
        public let nextToken: String?
        /// The configuration IDs of the test configurations.
        public let testConfigurationIds: [String]?

        @inlinable
        public init(maxResults: Int? = nil, nextToken: String? = nil, testConfigurationIds: [String]? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.testConfigurationIds = testConfigurationIds
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
            request.encodeQuery(self.testConfigurationIds, key: "testConfigurationIds")
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^\\S{1,2000}$")
            try self.testConfigurationIds?.forEach {
                try validate($0, name: "testConfigurationIds[]", parent: name, pattern: "^[A-Za-z0-9:/\\-]{1,100}$")
            }
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListTestConfigurationsResponse: AWSDecodableShape {
        /// The next token in the test configurations.
        public let nextToken: String?
        /// The test configurations.
        public let testConfigurations: [TestConfigurationSummary]

        @inlinable
        public init(nextToken: String? = nil, testConfigurations: [TestConfigurationSummary]) {
            self.nextToken = nextToken
            self.testConfigurations = testConfigurations
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "nextToken"
            case testConfigurations = "testConfigurations"
        }
    }

    public struct ListTestRunStepsRequest: AWSEncodableShape {
        /// The maximum number of test run steps to return in one page of results.
        public let maxResults: Int?
        /// The token from a previous step to retrieve the next page of results.
        public let nextToken: String?
        /// The test case ID of the test run steps.
        public let testCaseId: String?
        /// The test run ID of the test run steps.
        public let testRunId: String
        /// The test suite ID of the test run steps.
        public let testSuiteId: String?

        @inlinable
        public init(maxResults: Int? = nil, nextToken: String? = nil, testCaseId: String? = nil, testRunId: String, testSuiteId: String? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.testCaseId = testCaseId
            self.testRunId = testRunId
            self.testSuiteId = testSuiteId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
            request.encodeQuery(self.testCaseId, key: "testCaseId")
            request.encodePath(self.testRunId, key: "testRunId")
            request.encodeQuery(self.testSuiteId, key: "testSuiteId")
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^\\S{1,2000}$")
            try self.validate(self.testCaseId, name: "testCaseId", parent: name, pattern: "^[A-Za-z0-9:/\\-]{1,100}$")
            try self.validate(self.testRunId, name: "testRunId", parent: name, pattern: "^[A-Za-z0-9:/\\-]{1,100}$")
            try self.validate(self.testSuiteId, name: "testSuiteId", parent: name, pattern: "^[A-Za-z0-9:/\\-]{1,100}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListTestRunStepsResponse: AWSDecodableShape {
        /// The token from a previous request to retrieve the next page of results.
        public let nextToken: String?
        /// The test run steps of the response query.
        public let testRunSteps: [TestRunStepSummary]

        @inlinable
        public init(nextToken: String? = nil, testRunSteps: [TestRunStepSummary]) {
            self.nextToken = nextToken
            self.testRunSteps = testRunSteps
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "nextToken"
            case testRunSteps = "testRunSteps"
        }
    }

    public struct ListTestRunTestCasesRequest: AWSEncodableShape {
        /// The maximum number of test run test cases to return in one page of results.
        public let maxResults: Int?
        /// The token from a previous request to retrieve the next page of results.
        public let nextToken: String?
        /// The test run ID of the test cases.
        public let testRunId: String

        @inlinable
        public init(maxResults: Int? = nil, nextToken: String? = nil, testRunId: String) {
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.testRunId = testRunId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
            request.encodePath(self.testRunId, key: "testRunId")
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^\\S{1,2000}$")
            try self.validate(self.testRunId, name: "testRunId", parent: name, pattern: "^[A-Za-z0-9:/\\-]{1,100}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListTestRunTestCasesResponse: AWSDecodableShape {
        /// The token from a previous request to retrieve the next page of results.
        public let nextToken: String?
        /// The test run of the test cases.
        public let testRunTestCases: [TestCaseRunSummary]

        @inlinable
        public init(nextToken: String? = nil, testRunTestCases: [TestCaseRunSummary]) {
            self.nextToken = nextToken
            self.testRunTestCases = testRunTestCases
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "nextToken"
            case testRunTestCases = "testRunTestCases"
        }
    }

    public struct ListTestRunsRequest: AWSEncodableShape {
        /// The maximum number of test runs to return in one page of results.
        public let maxResults: Int?
        /// The token from the previous request to retrieve the next page of test run results.
        public let nextToken: String?
        /// The test run IDs of the test runs.
        public let testRunIds: [String]?
        /// The test suite ID of the test runs.
        public let testSuiteId: String?

        @inlinable
        public init(maxResults: Int? = nil, nextToken: String? = nil, testRunIds: [String]? = nil, testSuiteId: String? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.testRunIds = testRunIds
            self.testSuiteId = testSuiteId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
            request.encodeQuery(self.testRunIds, key: "testrunIds")
            request.encodeQuery(self.testSuiteId, key: "testSuiteId")
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^\\S{1,2000}$")
            try self.testRunIds?.forEach {
                try validate($0, name: "testRunIds[]", parent: name, pattern: "^[A-Za-z0-9:/\\-]{1,100}$")
            }
            try self.validate(self.testSuiteId, name: "testSuiteId", parent: name, pattern: "^[A-Za-z0-9:/\\-]{1,100}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListTestRunsResponse: AWSDecodableShape {
        /// The token from the previous request to retrieve the next page of results.
        public let nextToken: String?
        /// The test runs of the response query.
        public let testRuns: [TestRunSummary]

        @inlinable
        public init(nextToken: String? = nil, testRuns: [TestRunSummary]) {
            self.nextToken = nextToken
            self.testRuns = testRuns
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "nextToken"
            case testRuns = "testRuns"
        }
    }

    public struct ListTestSuitesRequest: AWSEncodableShape {
        /// The maximum number of test suites to return in one page of results.
        public let maxResults: Int?
        /// The token from a previous request to retrieve the next page of results.
        public let nextToken: String?
        /// The suite ID of the test suites.
        public let testSuiteIds: [String]?

        @inlinable
        public init(maxResults: Int? = nil, nextToken: String? = nil, testSuiteIds: [String]? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.testSuiteIds = testSuiteIds
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
            request.encodeQuery(self.testSuiteIds, key: "testSuiteIds")
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^\\S{1,2000}$")
            try self.testSuiteIds?.forEach {
                try validate($0, name: "testSuiteIds[]", parent: name, pattern: "^[A-Za-z0-9:/\\-]{1,100}$")
            }
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListTestSuitesResponse: AWSDecodableShape {
        /// The token from a previous request to retrieve the next page of test suites results.
        public let nextToken: String?
        /// The test suites returned with the response query.
        public let testSuites: [TestSuiteSummary]

        @inlinable
        public init(nextToken: String? = nil, testSuites: [TestSuiteSummary]) {
            self.nextToken = nextToken
            self.testSuites = testSuites
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "nextToken"
            case testSuites = "testSuites"
        }
    }

    public struct M2ManagedActionProperties: AWSEncodableShape & AWSDecodableShape {
        /// Force stops the AWS Mainframe Modernization managed action properties.
        public let forceStop: Bool?
        /// The import data set location of the AWS Mainframe Modernization managed action properties.
        public let importDataSetLocation: String?

        @inlinable
        public init(forceStop: Bool? = nil, importDataSetLocation: String? = nil) {
            self.forceStop = forceStop
            self.importDataSetLocation = importDataSetLocation
        }

        public func validate(name: String) throws {
            try self.validate(self.importDataSetLocation, name: "importDataSetLocation", parent: name, pattern: "^\\S{1,1000}$")
        }

        private enum CodingKeys: String, CodingKey {
            case forceStop = "forceStop"
            case importDataSetLocation = "importDataSetLocation"
        }
    }

    public struct M2ManagedApplication: AWSEncodableShape & AWSDecodableShape {
        /// The application ID of the AWS Mainframe Modernization managed application.
        public let applicationId: String
        /// The listener port of the AWS Mainframe Modernization managed application.
        public let listenerPort: String?
        /// The runtime of the AWS Mainframe Modernization managed application.
        public let runtime: M2ManagedRuntime
        /// The VPC endpoint service name of the AWS Mainframe Modernization managed application.
        public let vpcEndpointServiceName: String?

        @inlinable
        public init(applicationId: String, listenerPort: String? = nil, runtime: M2ManagedRuntime, vpcEndpointServiceName: String? = nil) {
            self.applicationId = applicationId
            self.listenerPort = listenerPort
            self.runtime = runtime
            self.vpcEndpointServiceName = vpcEndpointServiceName
        }

        public func validate(name: String) throws {
            try self.validate(self.applicationId, name: "applicationId", parent: name, pattern: "^\\S{1,1000}$")
            try self.validate(self.listenerPort, name: "listenerPort", parent: name, pattern: "^\\S{1,1000}$")
            try self.validate(self.vpcEndpointServiceName, name: "vpcEndpointServiceName", parent: name, pattern: "^\\S{1,1000}$")
        }

        private enum CodingKeys: String, CodingKey {
            case applicationId = "applicationId"
            case listenerPort = "listenerPort"
            case runtime = "runtime"
            case vpcEndpointServiceName = "vpcEndpointServiceName"
        }
    }

    public struct M2ManagedApplicationAction: AWSEncodableShape & AWSDecodableShape {
        /// The action type of the AWS Mainframe Modernization managed application action.
        public let actionType: M2ManagedActionType
        /// The properties of the AWS Mainframe Modernization managed application action.
        public let properties: M2ManagedActionProperties?
        /// The resource of the AWS Mainframe Modernization managed application action.
        public let resource: String

        @inlinable
        public init(actionType: M2ManagedActionType, properties: M2ManagedActionProperties? = nil, resource: String) {
            self.actionType = actionType
            self.properties = properties
            self.resource = resource
        }

        public func validate(name: String) throws {
            try self.properties?.validate(name: "\(name).properties")
            try self.validate(self.resource, name: "resource", parent: name, pattern: "^\\S{1,1000}$")
        }

        private enum CodingKeys: String, CodingKey {
            case actionType = "actionType"
            case properties = "properties"
            case resource = "resource"
        }
    }

    public struct M2ManagedApplicationStepInput: AWSDecodableShape {
        /// The action type of the AWS Mainframe Modernization managed application step input.
        public let actionType: M2ManagedActionType
        /// The application ID of the AWS Mainframe Modernization managed application step input.
        public let applicationId: String
        /// The listener port of the AWS Mainframe Modernization managed application step input.
        public let listenerPort: Int?
        /// The properties of the AWS Mainframe Modernization managed application step input.
        public let properties: M2ManagedActionProperties?
        /// The runtime of the AWS Mainframe Modernization managed application step input.
        public let runtime: String
        /// The VPC endpoint service name of the AWS Mainframe Modernization managed application step input.
        public let vpcEndpointServiceName: String?

        @inlinable
        public init(actionType: M2ManagedActionType, applicationId: String, listenerPort: Int? = nil, properties: M2ManagedActionProperties? = nil, runtime: String, vpcEndpointServiceName: String? = nil) {
            self.actionType = actionType
            self.applicationId = applicationId
            self.listenerPort = listenerPort
            self.properties = properties
            self.runtime = runtime
            self.vpcEndpointServiceName = vpcEndpointServiceName
        }

        private enum CodingKeys: String, CodingKey {
            case actionType = "actionType"
            case applicationId = "applicationId"
            case listenerPort = "listenerPort"
            case properties = "properties"
            case runtime = "runtime"
            case vpcEndpointServiceName = "vpcEndpointServiceName"
        }
    }

    public struct M2ManagedApplicationStepOutput: AWSDecodableShape {
        /// The import data set summary of the AWS Mainframe Modernization managed application step output.
        public let importDataSetSummary: [String: String]?

        @inlinable
        public init(importDataSetSummary: [String: String]? = nil) {
            self.importDataSetSummary = importDataSetSummary
        }

        private enum CodingKeys: String, CodingKey {
            case importDataSetSummary = "importDataSetSummary"
        }
    }

    public struct M2ManagedApplicationStepSummary: AWSDecodableShape {
        /// The step input of the AWS Mainframe Modernization managed application step summary.
        public let stepInput: M2ManagedApplicationStepInput
        /// The step output of the AWS Mainframe Modernization managed application step summary.
        public let stepOutput: M2ManagedApplicationStepOutput?

        @inlinable
        public init(stepInput: M2ManagedApplicationStepInput, stepOutput: M2ManagedApplicationStepOutput? = nil) {
            self.stepInput = stepInput
            self.stepOutput = stepOutput
        }

        private enum CodingKeys: String, CodingKey {
            case stepInput = "stepInput"
            case stepOutput = "stepOutput"
        }
    }

    public struct M2ManagedApplicationSummary: AWSDecodableShape {
        /// The application ID of the AWS Mainframe Modernization managed application summary.
        public let applicationId: String
        /// The listener port of the AWS Mainframe Modernization managed application summary.
        public let listenerPort: Int?
        /// The runtime of the AWS Mainframe Modernization managed application summary.
        public let runtime: M2ManagedRuntime

        @inlinable
        public init(applicationId: String, listenerPort: Int? = nil, runtime: M2ManagedRuntime) {
            self.applicationId = applicationId
            self.listenerPort = listenerPort
            self.runtime = runtime
        }

        private enum CodingKeys: String, CodingKey {
            case applicationId = "applicationId"
            case listenerPort = "listenerPort"
            case runtime = "runtime"
        }
    }

    public struct M2NonManagedApplication: AWSEncodableShape & AWSDecodableShape {
        /// The listener port of the AWS Mainframe Modernization non-managed application.
        public let listenerPort: String
        /// The runtime of the AWS Mainframe Modernization non-managed application.
        public let runtime: M2NonManagedRuntime
        /// The VPC endpoint service name of the AWS Mainframe Modernization non-managed application.
        public let vpcEndpointServiceName: String
        /// The web application name of the AWS Mainframe Modernization non-managed application.
        public let webAppName: String?

        @inlinable
        public init(listenerPort: String, runtime: M2NonManagedRuntime, vpcEndpointServiceName: String, webAppName: String? = nil) {
            self.listenerPort = listenerPort
            self.runtime = runtime
            self.vpcEndpointServiceName = vpcEndpointServiceName
            self.webAppName = webAppName
        }

        public func validate(name: String) throws {
            try self.validate(self.listenerPort, name: "listenerPort", parent: name, pattern: "^\\S{1,1000}$")
            try self.validate(self.vpcEndpointServiceName, name: "vpcEndpointServiceName", parent: name, pattern: "^\\S{1,1000}$")
            try self.validate(self.webAppName, name: "webAppName", parent: name, pattern: "^\\S{1,1000}$")
        }

        private enum CodingKeys: String, CodingKey {
            case listenerPort = "listenerPort"
            case runtime = "runtime"
            case vpcEndpointServiceName = "vpcEndpointServiceName"
            case webAppName = "webAppName"
        }
    }

    public struct M2NonManagedApplicationAction: AWSEncodableShape & AWSDecodableShape {
        /// The action type of the AWS Mainframe Modernization non-managed application action.
        public let actionType: M2NonManagedActionType
        /// The resource of the AWS Mainframe Modernization non-managed application action.
        public let resource: String

        @inlinable
        public init(actionType: M2NonManagedActionType, resource: String) {
            self.actionType = actionType
            self.resource = resource
        }

        public func validate(name: String) throws {
            try self.validate(self.resource, name: "resource", parent: name, pattern: "^\\S{1,1000}$")
        }

        private enum CodingKeys: String, CodingKey {
            case actionType = "actionType"
            case resource = "resource"
        }
    }

    public struct M2NonManagedApplicationStepInput: AWSDecodableShape {
        /// The action type of the AWS Mainframe Modernization non-managed application step input.
        public let actionType: M2NonManagedActionType
        /// The listener port of the AWS Mainframe Modernization non-managed application step input.
        public let listenerPort: Int
        /// The runtime of the AWS Mainframe Modernization non-managed application step input.
        public let runtime: M2NonManagedRuntime
        /// The VPC endpoint service name of the AWS Mainframe Modernization non-managed application step input.
        public let vpcEndpointServiceName: String
        /// The web app name of the AWS Mainframe Modernization non-managed application step input.
        public let webAppName: String?

        @inlinable
        public init(actionType: M2NonManagedActionType, listenerPort: Int, runtime: M2NonManagedRuntime, vpcEndpointServiceName: String, webAppName: String? = nil) {
            self.actionType = actionType
            self.listenerPort = listenerPort
            self.runtime = runtime
            self.vpcEndpointServiceName = vpcEndpointServiceName
            self.webAppName = webAppName
        }

        private enum CodingKeys: String, CodingKey {
            case actionType = "actionType"
            case listenerPort = "listenerPort"
            case runtime = "runtime"
            case vpcEndpointServiceName = "vpcEndpointServiceName"
            case webAppName = "webAppName"
        }
    }

    public struct M2NonManagedApplicationStepOutput: AWSDecodableShape {
        public init() {}
    }

    public struct M2NonManagedApplicationStepSummary: AWSDecodableShape {
        /// The step input of the AWS Mainframe Modernization non-managed application step summary.
        public let stepInput: M2NonManagedApplicationStepInput
        /// The step output of the AWS Mainframe Modernization non-managed application step summary.
        public let stepOutput: M2NonManagedApplicationStepOutput?

        @inlinable
        public init(stepInput: M2NonManagedApplicationStepInput, stepOutput: M2NonManagedApplicationStepOutput? = nil) {
            self.stepInput = stepInput
            self.stepOutput = stepOutput
        }

        private enum CodingKeys: String, CodingKey {
            case stepInput = "stepInput"
            case stepOutput = "stepOutput"
        }
    }

    public struct M2NonManagedApplicationSummary: AWSDecodableShape {
        /// The listener port of the AWS Mainframe Modernization non-managed application summary.
        public let listenerPort: Int
        /// The runtime of the AWS Mainframe Modernization non-managed application summary.
        public let runtime: M2NonManagedRuntime
        /// The VPC endpoint service name of the AWS Mainframe Modernization non-managed application summary.
        public let vpcEndpointServiceName: String
        /// The web application name of the AWS Mainframe Modernization non-managed application summary.
        public let webAppName: String?

        @inlinable
        public init(listenerPort: Int, runtime: M2NonManagedRuntime, vpcEndpointServiceName: String, webAppName: String? = nil) {
            self.listenerPort = listenerPort
            self.runtime = runtime
            self.vpcEndpointServiceName = vpcEndpointServiceName
            self.webAppName = webAppName
        }

        private enum CodingKeys: String, CodingKey {
            case listenerPort = "listenerPort"
            case runtime = "runtime"
            case vpcEndpointServiceName = "vpcEndpointServiceName"
            case webAppName = "webAppName"
        }
    }

    public struct MainframeAction: AWSEncodableShape & AWSDecodableShape {
        /// The action type of the mainframe action.
        public let actionType: MainframeActionType
        /// The properties of the mainframe action.
        public let properties: MainframeActionProperties?
        /// The resource of the mainframe action.
        public let resource: String

        @inlinable
        public init(actionType: MainframeActionType, properties: MainframeActionProperties? = nil, resource: String) {
            self.actionType = actionType
            self.properties = properties
            self.resource = resource
        }

        public func validate(name: String) throws {
            try self.actionType.validate(name: "\(name).actionType")
            try self.properties?.validate(name: "\(name).properties")
            try self.validate(self.resource, name: "resource", parent: name, pattern: "^\\S{1,1000}$")
        }

        private enum CodingKeys: String, CodingKey {
            case actionType = "actionType"
            case properties = "properties"
            case resource = "resource"
        }
    }

    public struct MainframeActionProperties: AWSEncodableShape & AWSDecodableShape {
        /// The DMS task ARN of the mainframe action properties.
        public let dmsTaskArn: String?

        @inlinable
        public init(dmsTaskArn: String? = nil) {
            self.dmsTaskArn = dmsTaskArn
        }

        public func validate(name: String) throws {
            try self.validate(self.dmsTaskArn, name: "dmsTaskArn", parent: name, pattern: "^\\S{1,1000}$")
        }

        private enum CodingKeys: String, CodingKey {
            case dmsTaskArn = "dmsTaskArn"
        }
    }

    public struct OutputFile: AWSEncodableShape & AWSDecodableShape {
        /// The file location of the output file.
        public let fileLocation: String?

        @inlinable
        public init(fileLocation: String? = nil) {
            self.fileLocation = fileLocation
        }

        public func validate(name: String) throws {
            try self.validate(self.fileLocation, name: "fileLocation", parent: name, max: 1024)
        }

        private enum CodingKeys: String, CodingKey {
            case fileLocation = "fileLocation"
        }
    }

    public struct Resource: AWSEncodableShape & AWSDecodableShape {
        /// The name of the resource.
        public let name: String
        /// The type of the resource.
        public let type: ResourceType

        @inlinable
        public init(name: String, type: ResourceType) {
            self.name = name
            self.type = type
        }

        public func validate(name: String) throws {
            try self.validate(self.name, name: "name", parent: name, pattern: "^[A-Za-z][A-Za-z0-9_\\-]{1,59}$")
            try self.type.validate(name: "\(name).type")
        }

        private enum CodingKeys: String, CodingKey {
            case name = "name"
            case type = "type"
        }
    }

    public struct ResourceNotFoundException: AWSErrorShape {
        public let message: String
        /// The resource ID of the resource not found.
        public let resourceId: String?
        /// The resource type of the resource not found.
        public let resourceType: String?

        @inlinable
        public init(message: String, resourceId: String? = nil, resourceType: String? = nil) {
            self.message = message
            self.resourceId = resourceId
            self.resourceType = resourceType
        }

        private enum CodingKeys: String, CodingKey {
            case message = "message"
            case resourceId = "resourceId"
            case resourceType = "resourceType"
        }
    }

    public struct Script: AWSEncodableShape & AWSDecodableShape {
        /// The script location of the scripts.
        public let scriptLocation: String
        /// The type of the scripts.
        public let type: ScriptType

        @inlinable
        public init(scriptLocation: String, type: ScriptType) {
            self.scriptLocation = scriptLocation
            self.type = type
        }

        public func validate(name: String) throws {
            try self.validate(self.scriptLocation, name: "scriptLocation", parent: name, max: 1024)
        }

        private enum CodingKeys: String, CodingKey {
            case scriptLocation = "scriptLocation"
            case type = "type"
        }
    }

    public struct ScriptSummary: AWSDecodableShape {
        /// The script location of the script summary.
        public let scriptLocation: String
        /// The type of the script summary.
        public let type: ScriptType

        @inlinable
        public init(scriptLocation: String, type: ScriptType) {
            self.scriptLocation = scriptLocation
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case scriptLocation = "scriptLocation"
            case type = "type"
        }
    }

    public struct ServiceQuotaExceededException: AWSErrorShape {
        public let message: String
        /// The quote codes of AWS Application Testing that exceeded the limit.
        public let quotaCode: String?
        /// The resource ID of AWS Application Testing that exceeded the limit.
        public let resourceId: String?
        /// The resource type of AWS Application Testing that exceeded the limit.
        public let resourceType: String?
        /// The service code of AWS Application Testing that exceeded the limit.
        public let serviceCode: String?

        @inlinable
        public init(message: String, quotaCode: String? = nil, resourceId: String? = nil, resourceType: String? = nil, serviceCode: String? = nil) {
            self.message = message
            self.quotaCode = quotaCode
            self.resourceId = resourceId
            self.resourceType = resourceType
            self.serviceCode = serviceCode
        }

        private enum CodingKeys: String, CodingKey {
            case message = "message"
            case quotaCode = "quotaCode"
            case resourceId = "resourceId"
            case resourceType = "resourceType"
            case serviceCode = "serviceCode"
        }
    }

    public struct ServiceSettings: AWSEncodableShape & AWSDecodableShape {
        /// The KMS key ID of the service settings.
        public let kmsKeyId: String?

        @inlinable
        public init(kmsKeyId: String? = nil) {
            self.kmsKeyId = kmsKeyId
        }

        private enum CodingKeys: String, CodingKey {
            case kmsKeyId = "kmsKeyId"
        }
    }

    public struct SourceDatabaseMetadata: AWSEncodableShape & AWSDecodableShape {
        /// The capture tool of the source database metadata.
        public let captureTool: CaptureTool
        /// The type of the source database metadata.
        public let type: SourceDatabase

        @inlinable
        public init(captureTool: CaptureTool, type: SourceDatabase) {
            self.captureTool = captureTool
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case captureTool = "captureTool"
            case type = "type"
        }
    }

    public struct StartTestRunRequest: AWSEncodableShape {
        /// The client token of the test run.
        public let clientToken: String?
        /// The tags of the test run.
        public let tags: [String: String]?
        /// The configuration ID of the test run.
        public let testConfigurationId: String?
        /// The test suite ID of the test run.
        public let testSuiteId: String

        @inlinable
        public init(clientToken: String? = StartTestRunRequest.idempotencyToken(), tags: [String: String]? = nil, testConfigurationId: String? = nil, testSuiteId: String) {
            self.clientToken = clientToken
            self.tags = tags
            self.testConfigurationId = testConfigurationId
            self.testSuiteId = testSuiteId
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "^[A-Za-z0-9\\-]{1,64}$")
            try self.tags?.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.key, name: "tags.key", parent: name, pattern: "^(?!aws:).+$")
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 200)
            try self.validate(self.testConfigurationId, name: "testConfigurationId", parent: name, pattern: "^[A-Za-z0-9:/\\-]{1,100}$")
            try self.validate(self.testSuiteId, name: "testSuiteId", parent: name, pattern: "^[A-Za-z0-9:/\\-]{1,100}$")
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "clientToken"
            case tags = "tags"
            case testConfigurationId = "testConfigurationId"
            case testSuiteId = "testSuiteId"
        }
    }

    public struct StartTestRunResponse: AWSDecodableShape {
        /// The test run ID of the test run.
        public let testRunId: String
        /// The test run status of the test run.
        public let testRunStatus: TestRunStatus

        @inlinable
        public init(testRunId: String, testRunStatus: TestRunStatus) {
            self.testRunId = testRunId
            self.testRunStatus = testRunStatus
        }

        private enum CodingKeys: String, CodingKey {
            case testRunId = "testRunId"
            case testRunStatus = "testRunStatus"
        }
    }

    public struct Step: AWSEncodableShape & AWSDecodableShape {
        /// The action of the step.
        public let action: StepAction
        /// The description of the step.
        public let description: String?
        /// The name of the step.
        public let name: String

        @inlinable
        public init(action: StepAction, description: String? = nil, name: String) {
            self.action = action
            self.description = description
            self.name = name
        }

        public func validate(name: String) throws {
            try self.action.validate(name: "\(name).action")
            try self.validate(self.description, name: "description", parent: name, max: 1000)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[A-Za-z][A-Za-z0-9_\\-]{1,59}$")
        }

        private enum CodingKeys: String, CodingKey {
            case action = "action"
            case description = "description"
            case name = "name"
        }
    }

    public struct TN3270: AWSEncodableShape & AWSDecodableShape {
        /// The data set names of the TN3270 protocol.
        public let exportDataSetNames: [String]?
        /// The script of the TN3270 protocol.
        public let script: Script

        @inlinable
        public init(exportDataSetNames: [String]? = nil, script: Script) {
            self.exportDataSetNames = exportDataSetNames
            self.script = script
        }

        public func validate(name: String) throws {
            try self.exportDataSetNames?.forEach {
                try validate($0, name: "exportDataSetNames[]", parent: name, pattern: "^\\S{1,100}$")
            }
            try self.script.validate(name: "\(name).script")
        }

        private enum CodingKeys: String, CodingKey {
            case exportDataSetNames = "exportDataSetNames"
            case script = "script"
        }
    }

    public struct TN3270StepInput: AWSDecodableShape {
        /// The export data set names of the TN3270 step input.
        public let exportDataSetNames: [String]?
        /// The properties of the TN3270 step input.
        public let properties: MainframeActionProperties?
        /// The resource of the TN3270 step input.
        public let resource: MainframeResourceSummary
        /// The script of the TN3270 step input.
        public let script: ScriptSummary

        @inlinable
        public init(exportDataSetNames: [String]? = nil, properties: MainframeActionProperties? = nil, resource: MainframeResourceSummary, script: ScriptSummary) {
            self.exportDataSetNames = exportDataSetNames
            self.properties = properties
            self.resource = resource
            self.script = script
        }

        private enum CodingKeys: String, CodingKey {
            case exportDataSetNames = "exportDataSetNames"
            case properties = "properties"
            case resource = "resource"
            case script = "script"
        }
    }

    public struct TN3270StepOutput: AWSDecodableShape {
        /// The data set details of the TN3270 step output.
        public let dataSetDetails: [DataSet]?
        /// The data set export location of the TN3270 step output.
        public let dataSetExportLocation: String?
        /// The output location of the TN3270 step output.
        public let dmsOutputLocation: String?
        /// The script output location of the TN3270 step output.
        public let scriptOutputLocation: String

        @inlinable
        public init(dataSetDetails: [DataSet]? = nil, dataSetExportLocation: String? = nil, dmsOutputLocation: String? = nil, scriptOutputLocation: String) {
            self.dataSetDetails = dataSetDetails
            self.dataSetExportLocation = dataSetExportLocation
            self.dmsOutputLocation = dmsOutputLocation
            self.scriptOutputLocation = scriptOutputLocation
        }

        private enum CodingKeys: String, CodingKey {
            case dataSetDetails = "dataSetDetails"
            case dataSetExportLocation = "dataSetExportLocation"
            case dmsOutputLocation = "dmsOutputLocation"
            case scriptOutputLocation = "scriptOutputLocation"
        }
    }

    public struct TN3270Summary: AWSDecodableShape {
        /// The step input of the TN3270 summary.
        public let stepInput: TN3270StepInput
        /// The step output of the TN3270 summary.
        public let stepOutput: TN3270StepOutput?

        @inlinable
        public init(stepInput: TN3270StepInput, stepOutput: TN3270StepOutput? = nil) {
            self.stepInput = stepInput
            self.stepOutput = stepOutput
        }

        private enum CodingKeys: String, CodingKey {
            case stepInput = "stepInput"
            case stepOutput = "stepOutput"
        }
    }

    public struct TagResourceRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the tag resource.
        public let resourceArn: String
        /// The tags of the resource.
        public let tags: [String: String]

        @inlinable
        public init(resourceArn: String, tags: [String: String]) {
            self.resourceArn = resourceArn
            self.tags = tags
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.resourceArn, key: "resourceArn")
            try container.encode(self.tags, forKey: .tags)
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, pattern: "^arn:(aws|aws-cn|aws-iso|aws-iso-[a-z]{1}|aws-us-gov):[A-Za-z0-9][A-Za-z0-9_/.-]{0,62}:([a-z]{2}-((iso[a-z]{0,1}-)|(gov-)){0,1}[a-z]+-[0-9]):[0-9]{12}:[A-Za-z0-9/][A-Za-z0-9:_/+=,@.-]{0,1023}$")
            try self.tags.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.key, name: "tags.key", parent: name, pattern: "^(?!aws:).+$")
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 200)
        }

        private enum CodingKeys: String, CodingKey {
            case tags = "tags"
        }
    }

    public struct TagResourceResponse: AWSDecodableShape {
        public init() {}
    }

    public struct TargetDatabaseMetadata: AWSEncodableShape & AWSDecodableShape {
        /// The capture tool of the target database metadata.
        public let captureTool: CaptureTool
        /// The type of the target database metadata.
        public let type: TargetDatabase

        @inlinable
        public init(captureTool: CaptureTool, type: TargetDatabase) {
            self.captureTool = captureTool
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case captureTool = "captureTool"
            case type = "type"
        }
    }

    public struct TestCaseLatestVersion: AWSDecodableShape {
        /// The status of the test case latest version.
        public let status: TestCaseLifecycle
        /// The status reason of the test case latest version.
        public let statusReason: String?
        /// The version of the test case latest version.
        public let version: Int

        @inlinable
        public init(status: TestCaseLifecycle, statusReason: String? = nil, version: Int) {
            self.status = status
            self.statusReason = statusReason
            self.version = version
        }

        private enum CodingKeys: String, CodingKey {
            case status = "status"
            case statusReason = "statusReason"
            case version = "version"
        }
    }

    public struct TestCaseRunSummary: AWSDecodableShape {
        /// The run end time of the test case run summary.
        public let runEndTime: Date?
        /// The run start time of the test case run summary.
        public let runStartTime: Date
        /// The status of the test case run summary.
        public let status: TestCaseRunStatus
        /// The status reason of the test case run summary.
        public let statusReason: String?
        /// The test case id of the test case run summary.
        public let testCaseId: String
        /// The test case version of the test case run summary.
        public let testCaseVersion: Int
        /// The test run id of the test case run summary.
        public let testRunId: String

        @inlinable
        public init(runEndTime: Date? = nil, runStartTime: Date, status: TestCaseRunStatus, statusReason: String? = nil, testCaseId: String, testCaseVersion: Int, testRunId: String) {
            self.runEndTime = runEndTime
            self.runStartTime = runStartTime
            self.status = status
            self.statusReason = statusReason
            self.testCaseId = testCaseId
            self.testCaseVersion = testCaseVersion
            self.testRunId = testRunId
        }

        private enum CodingKeys: String, CodingKey {
            case runEndTime = "runEndTime"
            case runStartTime = "runStartTime"
            case status = "status"
            case statusReason = "statusReason"
            case testCaseId = "testCaseId"
            case testCaseVersion = "testCaseVersion"
            case testRunId = "testRunId"
        }
    }

    public struct TestCaseSummary: AWSDecodableShape {
        /// The creation time of the test case summary.
        public let creationTime: Date
        /// The last update time of the test case summary.
        public let lastUpdateTime: Date
        /// The latest version of the test case summary.
        public let latestVersion: Int
        /// The name of the test case summary.
        public let name: String
        /// The status of the test case summary.
        public let status: TestCaseLifecycle
        /// The status reason of the test case summary.
        public let statusReason: String?
        /// The test case Amazon Resource Name (ARN) of the test case summary.
        public let testCaseArn: String
        /// The test case ID of the test case summary.
        public let testCaseId: String

        @inlinable
        public init(creationTime: Date, lastUpdateTime: Date, latestVersion: Int, name: String, status: TestCaseLifecycle, statusReason: String? = nil, testCaseArn: String, testCaseId: String) {
            self.creationTime = creationTime
            self.lastUpdateTime = lastUpdateTime
            self.latestVersion = latestVersion
            self.name = name
            self.status = status
            self.statusReason = statusReason
            self.testCaseArn = testCaseArn
            self.testCaseId = testCaseId
        }

        private enum CodingKeys: String, CodingKey {
            case creationTime = "creationTime"
            case lastUpdateTime = "lastUpdateTime"
            case latestVersion = "latestVersion"
            case name = "name"
            case status = "status"
            case statusReason = "statusReason"
            case testCaseArn = "testCaseArn"
            case testCaseId = "testCaseId"
        }
    }

    public struct TestConfigurationLatestVersion: AWSDecodableShape {
        /// The status of the test configuration latest version.
        public let status: TestConfigurationLifecycle
        /// The status reason of the test configuration latest version.
        public let statusReason: String?
        /// The version of the test configuration latest version.
        public let version: Int

        @inlinable
        public init(status: TestConfigurationLifecycle, statusReason: String? = nil, version: Int) {
            self.status = status
            self.statusReason = statusReason
            self.version = version
        }

        private enum CodingKeys: String, CodingKey {
            case status = "status"
            case statusReason = "statusReason"
            case version = "version"
        }
    }

    public struct TestConfigurationSummary: AWSDecodableShape {
        /// The creation time of the test configuration summary.
        public let creationTime: Date
        /// The last update time of the test configuration summary.
        public let lastUpdateTime: Date
        /// The latest version of the test configuration summary.
        public let latestVersion: Int
        /// The name of the test configuration summary.
        public let name: String
        /// The status of the test configuration summary.
        public let status: TestConfigurationLifecycle
        /// The status reason of the test configuration summary.
        public let statusReason: String?
        /// The test configuration ARN of the test configuration summary.
        public let testConfigurationArn: String
        /// The test configuration ID of the test configuration summary.
        public let testConfigurationId: String

        @inlinable
        public init(creationTime: Date, lastUpdateTime: Date, latestVersion: Int, name: String, status: TestConfigurationLifecycle, statusReason: String? = nil, testConfigurationArn: String, testConfigurationId: String) {
            self.creationTime = creationTime
            self.lastUpdateTime = lastUpdateTime
            self.latestVersion = latestVersion
            self.name = name
            self.status = status
            self.statusReason = statusReason
            self.testConfigurationArn = testConfigurationArn
            self.testConfigurationId = testConfigurationId
        }

        private enum CodingKeys: String, CodingKey {
            case creationTime = "creationTime"
            case lastUpdateTime = "lastUpdateTime"
            case latestVersion = "latestVersion"
            case name = "name"
            case status = "status"
            case statusReason = "statusReason"
            case testConfigurationArn = "testConfigurationArn"
            case testConfigurationId = "testConfigurationId"
        }
    }

    public struct TestRunStepSummary: AWSDecodableShape {
        /// The after step of the test run step summary.
        public let afterStep: Bool?
        /// The before step of the test run step summary.
        public let beforeStep: Bool?
        /// The run end time of the test run step summary.
        public let runEndTime: Date?
        /// The run start time of the test run step summary.
        public let runStartTime: Date
        /// The status of the test run step summary.
        public let status: StepRunStatus
        /// The status reason of the test run step summary.
        public let statusReason: String?
        /// The step name of the test run step summary.
        public let stepName: String
        /// The test case ID of the test run step summary.
        public let testCaseId: String?
        /// The test case version of the test run step summary.
        public let testCaseVersion: Int?
        /// The test run ID of the test run step summary.
        public let testRunId: String
        /// The test suite ID of the test run step summary.
        public let testSuiteId: String?
        /// The test suite version of the test run step summary.
        public let testSuiteVersion: Int?

        @inlinable
        public init(afterStep: Bool? = nil, beforeStep: Bool? = nil, runEndTime: Date? = nil, runStartTime: Date, status: StepRunStatus, statusReason: String? = nil, stepName: String, testCaseId: String? = nil, testCaseVersion: Int? = nil, testRunId: String, testSuiteId: String? = nil, testSuiteVersion: Int? = nil) {
            self.afterStep = afterStep
            self.beforeStep = beforeStep
            self.runEndTime = runEndTime
            self.runStartTime = runStartTime
            self.status = status
            self.statusReason = statusReason
            self.stepName = stepName
            self.testCaseId = testCaseId
            self.testCaseVersion = testCaseVersion
            self.testRunId = testRunId
            self.testSuiteId = testSuiteId
            self.testSuiteVersion = testSuiteVersion
        }

        private enum CodingKeys: String, CodingKey {
            case afterStep = "afterStep"
            case beforeStep = "beforeStep"
            case runEndTime = "runEndTime"
            case runStartTime = "runStartTime"
            case status = "status"
            case statusReason = "statusReason"
            case stepName = "stepName"
            case testCaseId = "testCaseId"
            case testCaseVersion = "testCaseVersion"
            case testRunId = "testRunId"
            case testSuiteId = "testSuiteId"
            case testSuiteVersion = "testSuiteVersion"
        }
    }

    public struct TestRunSummary: AWSDecodableShape {
        /// The run end time of the test run summary.
        public let runEndTime: Date?
        /// The run start time of the test run summary.
        public let runStartTime: Date
        /// The status of the test run summary.
        public let status: TestRunStatus
        /// The status reason of the test run summary.
        public let statusReason: String?
        /// The test configuration ID of the test run summary.
        public let testConfigurationId: String?
        /// The test configuration version of the test run summary.
        public let testConfigurationVersion: Int?
        /// The test run ARN of the test run summary.
        public let testRunArn: String
        /// The test run ID of the test run summary.
        public let testRunId: String
        /// The test suite ID of the test run summary.
        public let testSuiteId: String
        /// The test suite version of the test run summary.
        public let testSuiteVersion: Int

        @inlinable
        public init(runEndTime: Date? = nil, runStartTime: Date, status: TestRunStatus, statusReason: String? = nil, testConfigurationId: String? = nil, testConfigurationVersion: Int? = nil, testRunArn: String, testRunId: String, testSuiteId: String, testSuiteVersion: Int) {
            self.runEndTime = runEndTime
            self.runStartTime = runStartTime
            self.status = status
            self.statusReason = statusReason
            self.testConfigurationId = testConfigurationId
            self.testConfigurationVersion = testConfigurationVersion
            self.testRunArn = testRunArn
            self.testRunId = testRunId
            self.testSuiteId = testSuiteId
            self.testSuiteVersion = testSuiteVersion
        }

        private enum CodingKeys: String, CodingKey {
            case runEndTime = "runEndTime"
            case runStartTime = "runStartTime"
            case status = "status"
            case statusReason = "statusReason"
            case testConfigurationId = "testConfigurationId"
            case testConfigurationVersion = "testConfigurationVersion"
            case testRunArn = "testRunArn"
            case testRunId = "testRunId"
            case testSuiteId = "testSuiteId"
            case testSuiteVersion = "testSuiteVersion"
        }
    }

    public struct TestSuiteLatestVersion: AWSDecodableShape {
        /// The status of the test suite latest version.
        public let status: TestSuiteLifecycle
        /// The status reason of the test suite latest version.
        public let statusReason: String?
        /// The version of the test suite latest version.
        public let version: Int

        @inlinable
        public init(status: TestSuiteLifecycle, statusReason: String? = nil, version: Int) {
            self.status = status
            self.statusReason = statusReason
            self.version = version
        }

        private enum CodingKeys: String, CodingKey {
            case status = "status"
            case statusReason = "statusReason"
            case version = "version"
        }
    }

    public struct TestSuiteSummary: AWSDecodableShape {
        /// The creation time of the test suite summary.
        public let creationTime: Date
        /// The last update time of the test suite summary.
        public let lastUpdateTime: Date
        /// The latest version of the test suite summary.
        public let latestVersion: Int
        /// The name of the test suite summary.
        public let name: String
        /// The status of the test suite summary.
        public let status: TestSuiteLifecycle
        /// The status reason of the test suite summary.
        public let statusReason: String?
        /// The test suite Amazon Resource Name (ARN) of the test suite summary.
        public let testSuiteArn: String
        /// The test suite ID of the test suite summary.
        public let testSuiteId: String

        @inlinable
        public init(creationTime: Date, lastUpdateTime: Date, latestVersion: Int, name: String, status: TestSuiteLifecycle, statusReason: String? = nil, testSuiteArn: String, testSuiteId: String) {
            self.creationTime = creationTime
            self.lastUpdateTime = lastUpdateTime
            self.latestVersion = latestVersion
            self.name = name
            self.status = status
            self.statusReason = statusReason
            self.testSuiteArn = testSuiteArn
            self.testSuiteId = testSuiteId
        }

        private enum CodingKeys: String, CodingKey {
            case creationTime = "creationTime"
            case lastUpdateTime = "lastUpdateTime"
            case latestVersion = "latestVersion"
            case name = "name"
            case status = "status"
            case statusReason = "statusReason"
            case testSuiteArn = "testSuiteArn"
            case testSuiteId = "testSuiteId"
        }
    }

    public struct ThrottlingException: AWSErrorShape {
        public let message: String
        /// The quota code of requests that exceed the limit.
        public let quotaCode: String?
        /// The number of seconds to retry after for requests that exceed the limit.
        public let retryAfterSeconds: Int?
        /// The service code of requests that exceed the limit.
        public let serviceCode: String?

        @inlinable
        public init(message: String, quotaCode: String? = nil, retryAfterSeconds: Int? = nil, serviceCode: String? = nil) {
            self.message = message
            self.quotaCode = quotaCode
            self.retryAfterSeconds = retryAfterSeconds
            self.serviceCode = serviceCode
        }

        public init(from decoder: Decoder) throws {
            let response = decoder.userInfo[.awsResponse]! as! ResponseDecodingContainer
            let container = try decoder.container(keyedBy: CodingKeys.self)
            self.message = try container.decode(String.self, forKey: .message)
            self.quotaCode = try container.decodeIfPresent(String.self, forKey: .quotaCode)
            self.retryAfterSeconds = try response.decodeHeaderIfPresent(Int.self, key: "Retry-After")
            self.serviceCode = try container.decodeIfPresent(String.self, forKey: .serviceCode)
        }

        private enum CodingKeys: String, CodingKey {
            case message = "message"
            case quotaCode = "quotaCode"
            case serviceCode = "serviceCode"
        }
    }

    public struct UntagResourceRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the resource.
        public let resourceArn: String
        /// The tag keys of the resource.
        public let tagKeys: [String]

        @inlinable
        public init(resourceArn: String, tagKeys: [String]) {
            self.resourceArn = resourceArn
            self.tagKeys = tagKeys
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.resourceArn, key: "resourceArn")
            request.encodeQuery(self.tagKeys, key: "tagKeys")
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, pattern: "^arn:(aws|aws-cn|aws-iso|aws-iso-[a-z]{1}|aws-us-gov):[A-Za-z0-9][A-Za-z0-9_/.-]{0,62}:([a-z]{2}-((iso[a-z]{0,1}-)|(gov-)){0,1}[a-z]+-[0-9]):[0-9]{12}:[A-Za-z0-9/][A-Za-z0-9:_/+=,@.-]{0,1023}$")
            try self.tagKeys.forEach {
                try validate($0, name: "tagKeys[]", parent: name, max: 128)
                try validate($0, name: "tagKeys[]", parent: name, min: 1)
                try validate($0, name: "tagKeys[]", parent: name, pattern: "^(?!aws:).+$")
            }
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct UntagResourceResponse: AWSDecodableShape {
        public init() {}
    }

    public struct UpdateTestCaseRequest: AWSEncodableShape {
        /// The description of the test case.
        public let description: String?
        /// The steps of the test case.
        public let steps: [Step]?
        /// The test case ID of the test case.
        public let testCaseId: String

        @inlinable
        public init(description: String? = nil, steps: [Step]? = nil, testCaseId: String) {
            self.description = description
            self.steps = steps
            self.testCaseId = testCaseId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.description, forKey: .description)
            try container.encodeIfPresent(self.steps, forKey: .steps)
            request.encodePath(self.testCaseId, key: "testCaseId")
        }

        public func validate(name: String) throws {
            try self.validate(self.description, name: "description", parent: name, max: 1000)
            try self.steps?.forEach {
                try $0.validate(name: "\(name).steps[]")
            }
            try self.validate(self.steps, name: "steps", parent: name, max: 20)
            try self.validate(self.steps, name: "steps", parent: name, min: 1)
            try self.validate(self.testCaseId, name: "testCaseId", parent: name, pattern: "^[A-Za-z0-9:/\\-]{1,100}$")
        }

        private enum CodingKeys: String, CodingKey {
            case description = "description"
            case steps = "steps"
        }
    }

    public struct UpdateTestCaseResponse: AWSDecodableShape {
        /// The test case ID of the test case.
        public let testCaseId: String
        /// The test case version of the test case.
        public let testCaseVersion: Int

        @inlinable
        public init(testCaseId: String, testCaseVersion: Int) {
            self.testCaseId = testCaseId
            self.testCaseVersion = testCaseVersion
        }

        private enum CodingKeys: String, CodingKey {
            case testCaseId = "testCaseId"
            case testCaseVersion = "testCaseVersion"
        }
    }

    public struct UpdateTestConfigurationRequest: AWSEncodableShape {
        /// The description of the test configuration.
        public let description: String?
        /// The properties of the test configuration.
        public let properties: [String: String]?
        /// The resources of the test configuration.
        public let resources: [Resource]?
        /// The service settings of the test configuration.
        public let serviceSettings: ServiceSettings?
        /// The test configuration ID of the test configuration.
        public let testConfigurationId: String

        @inlinable
        public init(description: String? = nil, properties: [String: String]? = nil, resources: [Resource]? = nil, serviceSettings: ServiceSettings? = nil, testConfigurationId: String) {
            self.description = description
            self.properties = properties
            self.resources = resources
            self.serviceSettings = serviceSettings
            self.testConfigurationId = testConfigurationId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.description, forKey: .description)
            try container.encodeIfPresent(self.properties, forKey: .properties)
            try container.encodeIfPresent(self.resources, forKey: .resources)
            try container.encodeIfPresent(self.serviceSettings, forKey: .serviceSettings)
            request.encodePath(self.testConfigurationId, key: "testConfigurationId")
        }

        public func validate(name: String) throws {
            try self.validate(self.description, name: "description", parent: name, max: 1000)
            try self.resources?.forEach {
                try $0.validate(name: "\(name).resources[]")
            }
            try self.validate(self.resources, name: "resources", parent: name, max: 20)
            try self.validate(self.resources, name: "resources", parent: name, min: 1)
            try self.validate(self.testConfigurationId, name: "testConfigurationId", parent: name, pattern: "^[A-Za-z0-9:/\\-]{1,100}$")
        }

        private enum CodingKeys: String, CodingKey {
            case description = "description"
            case properties = "properties"
            case resources = "resources"
            case serviceSettings = "serviceSettings"
        }
    }

    public struct UpdateTestConfigurationResponse: AWSDecodableShape {
        /// The configuration ID of the test configuration.
        public let testConfigurationId: String
        /// The configuration version of the test configuration.
        public let testConfigurationVersion: Int

        @inlinable
        public init(testConfigurationId: String, testConfigurationVersion: Int) {
            self.testConfigurationId = testConfigurationId
            self.testConfigurationVersion = testConfigurationVersion
        }

        private enum CodingKeys: String, CodingKey {
            case testConfigurationId = "testConfigurationId"
            case testConfigurationVersion = "testConfigurationVersion"
        }
    }

    public struct UpdateTestSuiteRequest: AWSEncodableShape {
        /// The after steps of the test suite.
        public let afterSteps: [Step]?
        /// The before steps for the test suite.
        public let beforeSteps: [Step]?
        /// The description of the test suite.
        public let description: String?
        /// The test cases in the test suite.
        public let testCases: TestCases?
        /// The test suite ID of the test suite.
        public let testSuiteId: String

        @inlinable
        public init(afterSteps: [Step]? = nil, beforeSteps: [Step]? = nil, description: String? = nil, testCases: TestCases? = nil, testSuiteId: String) {
            self.afterSteps = afterSteps
            self.beforeSteps = beforeSteps
            self.description = description
            self.testCases = testCases
            self.testSuiteId = testSuiteId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.afterSteps, forKey: .afterSteps)
            try container.encodeIfPresent(self.beforeSteps, forKey: .beforeSteps)
            try container.encodeIfPresent(self.description, forKey: .description)
            try container.encodeIfPresent(self.testCases, forKey: .testCases)
            request.encodePath(self.testSuiteId, key: "testSuiteId")
        }

        public func validate(name: String) throws {
            try self.afterSteps?.forEach {
                try $0.validate(name: "\(name).afterSteps[]")
            }
            try self.validate(self.afterSteps, name: "afterSteps", parent: name, max: 20)
            try self.validate(self.afterSteps, name: "afterSteps", parent: name, min: 1)
            try self.beforeSteps?.forEach {
                try $0.validate(name: "\(name).beforeSteps[]")
            }
            try self.validate(self.beforeSteps, name: "beforeSteps", parent: name, max: 20)
            try self.validate(self.beforeSteps, name: "beforeSteps", parent: name, min: 1)
            try self.validate(self.description, name: "description", parent: name, max: 1000)
            try self.testCases?.validate(name: "\(name).testCases")
            try self.validate(self.testSuiteId, name: "testSuiteId", parent: name, pattern: "^[A-Za-z0-9:/\\-]{1,100}$")
        }

        private enum CodingKeys: String, CodingKey {
            case afterSteps = "afterSteps"
            case beforeSteps = "beforeSteps"
            case description = "description"
            case testCases = "testCases"
        }
    }

    public struct UpdateTestSuiteResponse: AWSDecodableShape {
        /// The test suite ID of the test suite.
        public let testSuiteId: String
        /// The test suite version of the test suite.
        public let testSuiteVersion: Int?

        @inlinable
        public init(testSuiteId: String, testSuiteVersion: Int? = nil) {
            self.testSuiteId = testSuiteId
            self.testSuiteVersion = testSuiteVersion
        }

        private enum CodingKeys: String, CodingKey {
            case testSuiteId = "testSuiteId"
            case testSuiteVersion = "testSuiteVersion"
        }
    }

    public struct ValidationException: AWSErrorShape {
        /// The field list of the validation exception.
        public let fieldList: [ValidationExceptionField]?
        public let message: String
        /// The reason for the validation exception.
        public let reason: ValidationExceptionReason?

        @inlinable
        public init(fieldList: [ValidationExceptionField]? = nil, message: String, reason: ValidationExceptionReason? = nil) {
            self.fieldList = fieldList
            self.message = message
            self.reason = reason
        }

        private enum CodingKeys: String, CodingKey {
            case fieldList = "fieldList"
            case message = "message"
            case reason = "reason"
        }
    }

    public struct ValidationExceptionField: AWSDecodableShape {
        /// The message stating reason for why service validation failed.
        public let message: String
        /// The name of the validation exception field.
        public let name: String

        @inlinable
        public init(message: String, name: String) {
            self.message = message
            self.name = name
        }

        private enum CodingKeys: String, CodingKey {
            case message = "message"
            case name = "name"
        }
    }

    public struct File: AWSDecodableShape {
        /// The file type of the file.
        public let fileType: CompareFileType?

        @inlinable
        public init(fileType: CompareFileType? = nil) {
            self.fileType = fileType
        }

        private enum CodingKeys: String, CodingKey {
            case fileType = "fileType"
        }
    }

    public struct Input: AWSEncodableShape & AWSDecodableShape {
        /// The file in the input.
        public let file: InputFile?

        @inlinable
        public init(file: InputFile? = nil) {
            self.file = file
        }

        public func validate(name: String) throws {
            try self.file?.validate(name: "\(name).file")
        }

        private enum CodingKeys: String, CodingKey {
            case file = "file"
        }
    }

    public struct Output: AWSEncodableShape & AWSDecodableShape {
        /// The file of the output.
        public let file: OutputFile?

        @inlinable
        public init(file: OutputFile? = nil) {
            self.file = file
        }

        public func validate(name: String) throws {
            try self.file?.validate(name: "\(name).file")
        }

        private enum CodingKeys: String, CodingKey {
            case file = "file"
        }
    }

    public struct TestCases: AWSEncodableShape & AWSDecodableShape {
        /// The sequential of the test case.
        public let sequential: [String]?

        @inlinable
        public init(sequential: [String]? = nil) {
            self.sequential = sequential
        }

        public func validate(name: String) throws {
            try self.sequential?.forEach {
                try validate($0, name: "sequential[]", parent: name, pattern: "^[A-Za-z0-9:/\\-]{1,100}$")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case sequential = "sequential"
        }
    }
}

// MARK: - Errors

/// Error enum for AppTest
public struct AppTestErrorType: AWSErrorType {
    enum Code: String {
        case accessDeniedException = "AccessDeniedException"
        case conflictException = "ConflictException"
        case internalServerException = "InternalServerException"
        case resourceNotFoundException = "ResourceNotFoundException"
        case serviceQuotaExceededException = "ServiceQuotaExceededException"
        case throttlingException = "ThrottlingException"
        case validationException = "ValidationException"
    }

    private let error: Code
    public let context: AWSErrorContext?

    /// initialize AppTest
    public init?(errorCode: String, context: AWSErrorContext) {
        guard let error = Code(rawValue: errorCode) else { return nil }
        self.error = error
        self.context = context
    }

    internal init(_ error: Code) {
        self.error = error
        self.context = nil
    }

    /// return error code string
    public var errorCode: String { self.error.rawValue }

    /// The account or role doesn't have the right permissions to make the request.
    public static var accessDeniedException: Self { .init(.accessDeniedException) }
    /// The parameters provided in the request conflict with existing resources.
    public static var conflictException: Self { .init(.conflictException) }
    /// An unexpected error occurred during the processing of the request.
    public static var internalServerException: Self { .init(.internalServerException) }
    /// The specified resource was not found.
    public static var resourceNotFoundException: Self { .init(.resourceNotFoundException) }
    /// One or more quotas for AWS Application Testing exceeds the limit.
    public static var serviceQuotaExceededException: Self { .init(.serviceQuotaExceededException) }
    /// The number of requests made exceeds the limit.
    public static var throttlingException: Self { .init(.throttlingException) }
    /// One or more parameter provided in the request is not valid.
    public static var validationException: Self { .init(.validationException) }
}

extension AppTestErrorType: AWSServiceErrorType {
    public static let errorCodeMap: [String: AWSErrorShape.Type] = [
        "ConflictException": AppTest.ConflictException.self,
        "InternalServerException": AppTest.InternalServerException.self,
        "ResourceNotFoundException": AppTest.ResourceNotFoundException.self,
        "ServiceQuotaExceededException": AppTest.ServiceQuotaExceededException.self,
        "ThrottlingException": AppTest.ThrottlingException.self,
        "ValidationException": AppTest.ValidationException.self
    ]
}

extension AppTestErrorType: Equatable {
    public static func == (lhs: AppTestErrorType, rhs: AppTestErrorType) -> Bool {
        lhs.error == rhs.error
    }
}

extension AppTestErrorType: CustomStringConvertible {
    public var description: String {
        return "\(self.error.rawValue): \(self.message ?? "")"
    }
}
