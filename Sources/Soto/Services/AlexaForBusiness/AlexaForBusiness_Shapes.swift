//===----------------------------------------------------------------------===//
//
// This source file is part of the Soto for AWS open source project
//
// Copyright (c) 2017-2021 the Soto project authors
// Licensed under Apache License v2.0
//
// See LICENSE.txt for license information
// See CONTRIBUTORS.txt for the list of Soto project authors
//
// SPDX-License-Identifier: Apache-2.0
//
//===----------------------------------------------------------------------===//

// THIS FILE IS AUTOMATICALLY GENERATED by https://github.com/soto-project/soto/tree/main/CodeGenerator. DO NOT EDIT.

import Foundation
import SotoCore

extension AlexaForBusiness {
    // MARK: Enums

    public enum BusinessReportFailureCode: String, CustomStringConvertible, Codable {
        case accessDenied = "ACCESS_DENIED"
        case internalFailure = "INTERNAL_FAILURE"
        case noSuchBucket = "NO_SUCH_BUCKET"
        public var description: String { return self.rawValue }
    }

    public enum BusinessReportFormat: String, CustomStringConvertible, Codable {
        case csv = "CSV"
        case csvZip = "CSV_ZIP"
        public var description: String { return self.rawValue }
    }

    public enum BusinessReportInterval: String, CustomStringConvertible, Codable {
        case oneDay = "ONE_DAY"
        case oneWeek = "ONE_WEEK"
        case thirtyDays = "THIRTY_DAYS"
        public var description: String { return self.rawValue }
    }

    public enum BusinessReportStatus: String, CustomStringConvertible, Codable {
        case failed = "FAILED"
        case running = "RUNNING"
        case succeeded = "SUCCEEDED"
        public var description: String { return self.rawValue }
    }

    public enum CommsProtocol: String, CustomStringConvertible, Codable {
        case h323 = "H323"
        case sip = "SIP"
        case sips = "SIPS"
        public var description: String { return self.rawValue }
    }

    public enum ConferenceProviderType: String, CustomStringConvertible, Codable {
        case bluejeans = "BLUEJEANS"
        case chime = "CHIME"
        case custom = "CUSTOM"
        case fuze = "FUZE"
        case googleHangouts = "GOOGLE_HANGOUTS"
        case polycom = "POLYCOM"
        case ringcentral = "RINGCENTRAL"
        case skypeForBusiness = "SKYPE_FOR_BUSINESS"
        case webex = "WEBEX"
        case zoom = "ZOOM"
        public var description: String { return self.rawValue }
    }

    public enum ConnectionStatus: String, CustomStringConvertible, Codable {
        case offline = "OFFLINE"
        case online = "ONLINE"
        public var description: String { return self.rawValue }
    }

    public enum DeviceEventType: String, CustomStringConvertible, Codable {
        case connectionStatus = "CONNECTION_STATUS"
        case deviceStatus = "DEVICE_STATUS"
        public var description: String { return self.rawValue }
    }

    public enum DeviceStatus: String, CustomStringConvertible, Codable {
        case deregistered = "DEREGISTERED"
        case failed = "FAILED"
        case pending = "PENDING"
        case ready = "READY"
        case wasOffline = "WAS_OFFLINE"
        public var description: String { return self.rawValue }
    }

    public enum DeviceStatusDetailCode: String, CustomStringConvertible, Codable {
        case associationRejection = "ASSOCIATION_REJECTION"
        case authenticationFailure = "AUTHENTICATION_FAILURE"
        case certificateAuthorityAccessDenied = "CERTIFICATE_AUTHORITY_ACCESS_DENIED"
        case certificateIssuingLimitExceeded = "CERTIFICATE_ISSUING_LIMIT_EXCEEDED"
        case credentialsAccessFailure = "CREDENTIALS_ACCESS_FAILURE"
        case deviceSoftwareUpdateNeeded = "DEVICE_SOFTWARE_UPDATE_NEEDED"
        case deviceWasOffline = "DEVICE_WAS_OFFLINE"
        case dhcpFailure = "DHCP_FAILURE"
        case dnsFailure = "DNS_FAILURE"
        case internetUnavailable = "INTERNET_UNAVAILABLE"
        case invalidCertificateAuthority = "INVALID_CERTIFICATE_AUTHORITY"
        case invalidPasswordState = "INVALID_PASSWORD_STATE"
        case networkProfileNotFound = "NETWORK_PROFILE_NOT_FOUND"
        case passwordManagerAccessDenied = "PASSWORD_MANAGER_ACCESS_DENIED"
        case passwordNotFound = "PASSWORD_NOT_FOUND"
        case tlsVersionMismatch = "TLS_VERSION_MISMATCH"
        case unknownFailure = "UNKNOWN_FAILURE"
        public var description: String { return self.rawValue }
    }

    public enum DeviceUsageType: String, CustomStringConvertible, Codable {
        case voice = "VOICE"
        public var description: String { return self.rawValue }
    }

    public enum DistanceUnit: String, CustomStringConvertible, Codable {
        case imperial = "IMPERIAL"
        case metric = "METRIC"
        public var description: String { return self.rawValue }
    }

    public enum EnablementType: String, CustomStringConvertible, Codable {
        case enabled = "ENABLED"
        case pending = "PENDING"
        public var description: String { return self.rawValue }
    }

    public enum EnablementTypeFilter: String, CustomStringConvertible, Codable {
        case enabled = "ENABLED"
        case pending = "PENDING"
        public var description: String { return self.rawValue }
    }

    public enum EndOfMeetingReminderType: String, CustomStringConvertible, Codable {
        case announcementTimeCheck = "ANNOUNCEMENT_TIME_CHECK"
        case announcementVariableTimeLeft = "ANNOUNCEMENT_VARIABLE_TIME_LEFT"
        case chime = "CHIME"
        case knock = "KNOCK"
        public var description: String { return self.rawValue }
    }

    public enum EnrollmentStatus: String, CustomStringConvertible, Codable {
        case deregistering = "DEREGISTERING"
        case disassociating = "DISASSOCIATING"
        case initialized = "INITIALIZED"
        case pending = "PENDING"
        case registered = "REGISTERED"
        public var description: String { return self.rawValue }
    }

    public enum Feature: String, CustomStringConvertible, Codable {
        case all = "ALL"
        case bluetooth = "BLUETOOTH"
        case lists = "LISTS"
        case networkProfile = "NETWORK_PROFILE"
        case notifications = "NOTIFICATIONS"
        case settings = "SETTINGS"
        case skills = "SKILLS"
        case volume = "VOLUME"
        public var description: String { return self.rawValue }
    }

    public enum Locale: String, CustomStringConvertible, Codable {
        case enUs = "en-US"
        public var description: String { return self.rawValue }
    }

    public enum NetworkEapMethod: String, CustomStringConvertible, Codable {
        case eapTls = "EAP_TLS"
        public var description: String { return self.rawValue }
    }

    public enum NetworkSecurityType: String, CustomStringConvertible, Codable {
        case open = "OPEN"
        case wep = "WEP"
        case wpa2Enterprise = "WPA2_ENTERPRISE"
        case wpa2Psk = "WPA2_PSK"
        case wpaPsk = "WPA_PSK"
        public var description: String { return self.rawValue }
    }

    public enum PhoneNumberType: String, CustomStringConvertible, Codable {
        case home = "HOME"
        case mobile = "MOBILE"
        case work = "WORK"
        public var description: String { return self.rawValue }
    }

    public enum RequirePin: String, CustomStringConvertible, Codable {
        case no = "NO"
        case optional = "OPTIONAL"
        case yes = "YES"
        public var description: String { return self.rawValue }
    }

    public enum SipType: String, CustomStringConvertible, Codable {
        case work = "WORK"
        public var description: String { return self.rawValue }
    }

    public enum SkillType: String, CustomStringConvertible, Codable {
        case `private` = "PRIVATE"
        case `public` = "PUBLIC"
        public var description: String { return self.rawValue }
    }

    public enum SkillTypeFilter: String, CustomStringConvertible, Codable {
        case all = "ALL"
        case `private` = "PRIVATE"
        case `public` = "PUBLIC"
        public var description: String { return self.rawValue }
    }

    public enum SortValue: String, CustomStringConvertible, Codable {
        case asc = "ASC"
        case desc = "DESC"
        public var description: String { return self.rawValue }
    }

    public enum TemperatureUnit: String, CustomStringConvertible, Codable {
        case celsius = "CELSIUS"
        case fahrenheit = "FAHRENHEIT"
        public var description: String { return self.rawValue }
    }

    public enum WakeWord: String, CustomStringConvertible, Codable {
        case alexa = "ALEXA"
        case amazon = "AMAZON"
        case computer = "COMPUTER"
        case echo = "ECHO"
        public var description: String { return self.rawValue }
    }

    // MARK: Shapes

    public struct AddressBook: AWSDecodableShape {
        /// The ARN of the address book.
        public let addressBookArn: String?
        /// The description of the address book.
        public let description: String?
        /// The name of the address book.
        public let name: String?

        public init(addressBookArn: String? = nil, description: String? = nil, name: String? = nil) {
            self.addressBookArn = addressBookArn
            self.description = description
            self.name = name
        }

        private enum CodingKeys: String, CodingKey {
            case addressBookArn = "AddressBookArn"
            case description = "Description"
            case name = "Name"
        }
    }

    public struct AddressBookData: AWSDecodableShape {
        /// The ARN of the address book.
        public let addressBookArn: String?
        /// The description of the address book.
        public let description: String?
        /// The name of the address book.
        public let name: String?

        public init(addressBookArn: String? = nil, description: String? = nil, name: String? = nil) {
            self.addressBookArn = addressBookArn
            self.description = description
            self.name = name
        }

        private enum CodingKeys: String, CodingKey {
            case addressBookArn = "AddressBookArn"
            case description = "Description"
            case name = "Name"
        }
    }

    public struct ApproveSkillRequest: AWSEncodableShape {
        /// The unique identifier of the skill.
        public let skillId: String

        public init(skillId: String) {
            self.skillId = skillId
        }

        public func validate(name: String) throws {
            try self.validate(self.skillId, name: "skillId", parent: name, pattern: "(^amzn1\\.ask\\.skill\\.[0-9a-f\\-]{1,200})|(^amzn1\\.echo-sdk-ams\\.app\\.[0-9a-f\\-]{1,200})")
        }

        private enum CodingKeys: String, CodingKey {
            case skillId = "SkillId"
        }
    }

    public struct ApproveSkillResponse: AWSDecodableShape {
        public init() {}
    }

    public struct AssociateContactWithAddressBookRequest: AWSEncodableShape {
        /// The ARN of the address book with which to associate the contact.
        public let addressBookArn: String
        /// The ARN of the contact to associate with an address book.
        public let contactArn: String

        public init(addressBookArn: String, contactArn: String) {
            self.addressBookArn = addressBookArn
            self.contactArn = contactArn
        }

        public func validate(name: String) throws {
            try self.validate(self.addressBookArn, name: "addressBookArn", parent: name, pattern: "arn:[a-z0-9-\\.]{1,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[^/].{0,1023}")
            try self.validate(self.contactArn, name: "contactArn", parent: name, pattern: "arn:[a-z0-9-\\.]{1,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[^/].{0,1023}")
        }

        private enum CodingKeys: String, CodingKey {
            case addressBookArn = "AddressBookArn"
            case contactArn = "ContactArn"
        }
    }

    public struct AssociateContactWithAddressBookResponse: AWSDecodableShape {
        public init() {}
    }

    public struct AssociateDeviceWithNetworkProfileRequest: AWSEncodableShape {
        /// The device ARN.
        public let deviceArn: String
        /// The ARN of the network profile to associate with a device.
        public let networkProfileArn: String

        public init(deviceArn: String, networkProfileArn: String) {
            self.deviceArn = deviceArn
            self.networkProfileArn = networkProfileArn
        }

        public func validate(name: String) throws {
            try self.validate(self.deviceArn, name: "deviceArn", parent: name, pattern: "arn:[a-z0-9-\\.]{1,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[^/].{0,1023}")
            try self.validate(self.networkProfileArn, name: "networkProfileArn", parent: name, pattern: "arn:[a-z0-9-\\.]{1,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[^/].{0,1023}")
        }

        private enum CodingKeys: String, CodingKey {
            case deviceArn = "DeviceArn"
            case networkProfileArn = "NetworkProfileArn"
        }
    }

    public struct AssociateDeviceWithNetworkProfileResponse: AWSDecodableShape {
        public init() {}
    }

    public struct AssociateDeviceWithRoomRequest: AWSEncodableShape {
        /// The ARN of the device to associate to a room. Required.
        public let deviceArn: String?
        /// The ARN of the room with which to associate the device. Required.
        public let roomArn: String?

        public init(deviceArn: String? = nil, roomArn: String? = nil) {
            self.deviceArn = deviceArn
            self.roomArn = roomArn
        }

        public func validate(name: String) throws {
            try self.validate(self.deviceArn, name: "deviceArn", parent: name, pattern: "arn:[a-z0-9-\\.]{1,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[^/].{0,1023}")
            try self.validate(self.roomArn, name: "roomArn", parent: name, pattern: "arn:[a-z0-9-\\.]{1,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[^/].{0,1023}")
        }

        private enum CodingKeys: String, CodingKey {
            case deviceArn = "DeviceArn"
            case roomArn = "RoomArn"
        }
    }

    public struct AssociateDeviceWithRoomResponse: AWSDecodableShape {
        public init() {}
    }

    public struct AssociateSkillGroupWithRoomRequest: AWSEncodableShape {
        /// The ARN of the room with which to associate the skill group. Required.
        public let roomArn: String?
        /// The ARN of the skill group to associate with a room. Required.
        public let skillGroupArn: String?

        public init(roomArn: String? = nil, skillGroupArn: String? = nil) {
            self.roomArn = roomArn
            self.skillGroupArn = skillGroupArn
        }

        public func validate(name: String) throws {
            try self.validate(self.roomArn, name: "roomArn", parent: name, pattern: "arn:[a-z0-9-\\.]{1,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[^/].{0,1023}")
            try self.validate(self.skillGroupArn, name: "skillGroupArn", parent: name, pattern: "arn:[a-z0-9-\\.]{1,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[^/].{0,1023}")
        }

        private enum CodingKeys: String, CodingKey {
            case roomArn = "RoomArn"
            case skillGroupArn = "SkillGroupArn"
        }
    }

    public struct AssociateSkillGroupWithRoomResponse: AWSDecodableShape {
        public init() {}
    }

    public struct AssociateSkillWithSkillGroupRequest: AWSEncodableShape {
        /// The ARN of the skill group to associate the skill to. Required.
        public let skillGroupArn: String?
        /// The unique identifier of the skill.
        public let skillId: String

        public init(skillGroupArn: String? = nil, skillId: String) {
            self.skillGroupArn = skillGroupArn
            self.skillId = skillId
        }

        public func validate(name: String) throws {
            try self.validate(self.skillGroupArn, name: "skillGroupArn", parent: name, pattern: "arn:[a-z0-9-\\.]{1,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[^/].{0,1023}")
            try self.validate(self.skillId, name: "skillId", parent: name, pattern: "(^amzn1\\.ask\\.skill\\.[0-9a-f\\-]{1,200})|(^amzn1\\.echo-sdk-ams\\.app\\.[0-9a-f\\-]{1,200})")
        }

        private enum CodingKeys: String, CodingKey {
            case skillGroupArn = "SkillGroupArn"
            case skillId = "SkillId"
        }
    }

    public struct AssociateSkillWithSkillGroupResponse: AWSDecodableShape {
        public init() {}
    }

    public struct AssociateSkillWithUsersRequest: AWSEncodableShape {
        /// The private skill ID you want to make available to enrolled users.
        public let skillId: String

        public init(skillId: String) {
            self.skillId = skillId
        }

        public func validate(name: String) throws {
            try self.validate(self.skillId, name: "skillId", parent: name, pattern: "(^amzn1\\.ask\\.skill\\.[0-9a-f\\-]{1,200})|(^amzn1\\.echo-sdk-ams\\.app\\.[0-9a-f\\-]{1,200})")
        }

        private enum CodingKeys: String, CodingKey {
            case skillId = "SkillId"
        }
    }

    public struct AssociateSkillWithUsersResponse: AWSDecodableShape {
        public init() {}
    }

    public struct Audio: AWSEncodableShape {
        /// The locale of the audio message. Currently, en-US is supported.
        public let locale: Locale
        /// The location of the audio file. Currently, S3 URLs are supported. Only S3 locations comprised of safe characters are valid. For more information, see Safe Characters.
        public let location: String

        public init(locale: Locale, location: String) {
            self.locale = locale
            self.location = location
        }

        public func validate(name: String) throws {
            try self.validate(self.location, name: "location", parent: name, max: 1200)
            try self.validate(self.location, name: "location", parent: name, min: 0)
            try self.validate(self.location, name: "location", parent: name, pattern: "https://([A-Za-z0-9_.-]+)?(s3-[A-Za-z0-9-]+|s3\\.([A-Za-z0-9-])+|s3|s3.dualstack\\.([A-Za-z0-9-])+)+.amazonaws.com/.*")
        }

        private enum CodingKeys: String, CodingKey {
            case locale = "Locale"
            case location = "Location"
        }
    }

    public struct BusinessReport: AWSDecodableShape {
        /// The time of report delivery.
        public let deliveryTime: Date?
        /// The download link where a user can download the report.
        public let downloadUrl: String?
        /// The failure code.
        public let failureCode: BusinessReportFailureCode?
        /// The S3 location of the output reports.
        public let s3Location: BusinessReportS3Location?
        /// The status of the report generation execution (RUNNING, SUCCEEDED, or FAILED).
        public let status: BusinessReportStatus?

        public init(deliveryTime: Date? = nil, downloadUrl: String? = nil, failureCode: BusinessReportFailureCode? = nil, s3Location: BusinessReportS3Location? = nil, status: BusinessReportStatus? = nil) {
            self.deliveryTime = deliveryTime
            self.downloadUrl = downloadUrl
            self.failureCode = failureCode
            self.s3Location = s3Location
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case deliveryTime = "DeliveryTime"
            case downloadUrl = "DownloadUrl"
            case failureCode = "FailureCode"
            case s3Location = "S3Location"
            case status = "Status"
        }
    }

    public struct BusinessReportContentRange: AWSEncodableShape & AWSDecodableShape {
        /// The interval of the content range.
        public let interval: BusinessReportInterval

        public init(interval: BusinessReportInterval) {
            self.interval = interval
        }

        private enum CodingKeys: String, CodingKey {
            case interval = "Interval"
        }
    }

    public struct BusinessReportRecurrence: AWSEncodableShape & AWSDecodableShape {
        /// The start date.
        public let startDate: String?

        public init(startDate: String? = nil) {
            self.startDate = startDate
        }

        public func validate(name: String) throws {
            try self.validate(self.startDate, name: "startDate", parent: name, pattern: "^\\d{4}\\-(0?[1-9]|1[012])\\-(0?[1-9]|[12][0-9]|3[01])$")
        }

        private enum CodingKeys: String, CodingKey {
            case startDate = "StartDate"
        }
    }

    public struct BusinessReportS3Location: AWSDecodableShape {
        /// The S3 bucket name of the output reports.
        public let bucketName: String?
        /// The path of the business report.
        public let path: String?

        public init(bucketName: String? = nil, path: String? = nil) {
            self.bucketName = bucketName
            self.path = path
        }

        private enum CodingKeys: String, CodingKey {
            case bucketName = "BucketName"
            case path = "Path"
        }
    }

    public struct BusinessReportSchedule: AWSDecodableShape {
        /// The content range of the reports.
        public let contentRange: BusinessReportContentRange?
        /// The format of the generated report (individual CSV files or zipped files of individual files).
        public let format: BusinessReportFormat?
        /// The details of the last business report delivery for a specified time interval.
        public let lastBusinessReport: BusinessReport?
        /// The recurrence of the reports.
        public let recurrence: BusinessReportRecurrence?
        /// The S3 bucket name of the output reports.
        public let s3BucketName: String?
        /// The S3 key where the report is delivered.
        public let s3KeyPrefix: String?
        /// The ARN of the business report schedule.
        public let scheduleArn: String?
        /// The name identifier of the schedule.
        public let scheduleName: String?

        public init(contentRange: BusinessReportContentRange? = nil, format: BusinessReportFormat? = nil, lastBusinessReport: BusinessReport? = nil, recurrence: BusinessReportRecurrence? = nil, s3BucketName: String? = nil, s3KeyPrefix: String? = nil, scheduleArn: String? = nil, scheduleName: String? = nil) {
            self.contentRange = contentRange
            self.format = format
            self.lastBusinessReport = lastBusinessReport
            self.recurrence = recurrence
            self.s3BucketName = s3BucketName
            self.s3KeyPrefix = s3KeyPrefix
            self.scheduleArn = scheduleArn
            self.scheduleName = scheduleName
        }

        private enum CodingKeys: String, CodingKey {
            case contentRange = "ContentRange"
            case format = "Format"
            case lastBusinessReport = "LastBusinessReport"
            case recurrence = "Recurrence"
            case s3BucketName = "S3BucketName"
            case s3KeyPrefix = "S3KeyPrefix"
            case scheduleArn = "ScheduleArn"
            case scheduleName = "ScheduleName"
        }
    }

    public struct Category: AWSDecodableShape {
        /// The ID of the skill store category.
        public let categoryId: Int64?
        /// The name of the skill store category.
        public let categoryName: String?

        public init(categoryId: Int64? = nil, categoryName: String? = nil) {
            self.categoryId = categoryId
            self.categoryName = categoryName
        }

        private enum CodingKeys: String, CodingKey {
            case categoryId = "CategoryId"
            case categoryName = "CategoryName"
        }
    }

    public struct ConferencePreference: AWSEncodableShape & AWSDecodableShape {
        /// The ARN of the default conference provider.
        public let defaultConferenceProviderArn: String?

        public init(defaultConferenceProviderArn: String? = nil) {
            self.defaultConferenceProviderArn = defaultConferenceProviderArn
        }

        public func validate(name: String) throws {
            try self.validate(self.defaultConferenceProviderArn, name: "defaultConferenceProviderArn", parent: name, pattern: "arn:[a-z0-9-\\.]{1,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[^/].{0,1023}")
        }

        private enum CodingKeys: String, CodingKey {
            case defaultConferenceProviderArn = "DefaultConferenceProviderArn"
        }
    }

    public struct ConferenceProvider: AWSDecodableShape {
        /// The ARN of the newly created conference provider.
        public let arn: String?
        /// The IP endpoint and protocol for calling.
        public let iPDialIn: IPDialIn?
        /// The meeting settings for the conference provider.
        public let meetingSetting: MeetingSetting?
        /// The name of the conference provider.
        public let name: String?
        /// The information for PSTN conferencing.
        public let pSTNDialIn: PSTNDialIn?
        /// The type of conference providers.
        public let type: ConferenceProviderType?

        public init(arn: String? = nil, iPDialIn: IPDialIn? = nil, meetingSetting: MeetingSetting? = nil, name: String? = nil, pSTNDialIn: PSTNDialIn? = nil, type: ConferenceProviderType? = nil) {
            self.arn = arn
            self.iPDialIn = iPDialIn
            self.meetingSetting = meetingSetting
            self.name = name
            self.pSTNDialIn = pSTNDialIn
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case iPDialIn = "IPDialIn"
            case meetingSetting = "MeetingSetting"
            case name = "Name"
            case pSTNDialIn = "PSTNDialIn"
            case type = "Type"
        }
    }

    public struct Contact: AWSDecodableShape {
        /// The ARN of the contact.
        public let contactArn: String?
        /// The name of the contact to display on the console.
        public let displayName: String?
        /// The first name of the contact, used to call the contact on the device.
        public let firstName: String?
        /// The last name of the contact, used to call the contact on the device.
        public let lastName: String?
        /// The phone number of the contact. The phone number type defaults to WORK. You can either specify PhoneNumber or PhoneNumbers. We recommend that you use PhoneNumbers, which lets you specify the phone number type and multiple numbers.
        public let phoneNumber: String?
        /// The list of phone numbers for the contact.
        public let phoneNumbers: [PhoneNumber]?
        /// The list of SIP addresses for the contact.
        public let sipAddresses: [SipAddress]?

        public init(contactArn: String? = nil, displayName: String? = nil, firstName: String? = nil, lastName: String? = nil, phoneNumber: String? = nil, phoneNumbers: [PhoneNumber]? = nil, sipAddresses: [SipAddress]? = nil) {
            self.contactArn = contactArn
            self.displayName = displayName
            self.firstName = firstName
            self.lastName = lastName
            self.phoneNumber = phoneNumber
            self.phoneNumbers = phoneNumbers
            self.sipAddresses = sipAddresses
        }

        private enum CodingKeys: String, CodingKey {
            case contactArn = "ContactArn"
            case displayName = "DisplayName"
            case firstName = "FirstName"
            case lastName = "LastName"
            case phoneNumber = "PhoneNumber"
            case phoneNumbers = "PhoneNumbers"
            case sipAddresses = "SipAddresses"
        }
    }

    public struct ContactData: AWSDecodableShape {
        /// The ARN of the contact.
        public let contactArn: String?
        /// The name of the contact to display on the console.
        public let displayName: String?
        /// The first name of the contact, used to call the contact on the device.
        public let firstName: String?
        /// The last name of the contact, used to call the contact on the device.
        public let lastName: String?
        /// The phone number of the contact. The phone number type defaults to WORK. You can specify PhoneNumber or PhoneNumbers. We recommend that you use PhoneNumbers, which lets you specify the phone number type and multiple numbers.
        public let phoneNumber: String?
        /// The list of phone numbers for the contact.
        public let phoneNumbers: [PhoneNumber]?
        /// The list of SIP addresses for the contact.
        public let sipAddresses: [SipAddress]?

        public init(contactArn: String? = nil, displayName: String? = nil, firstName: String? = nil, lastName: String? = nil, phoneNumber: String? = nil, phoneNumbers: [PhoneNumber]? = nil, sipAddresses: [SipAddress]? = nil) {
            self.contactArn = contactArn
            self.displayName = displayName
            self.firstName = firstName
            self.lastName = lastName
            self.phoneNumber = phoneNumber
            self.phoneNumbers = phoneNumbers
            self.sipAddresses = sipAddresses
        }

        private enum CodingKeys: String, CodingKey {
            case contactArn = "ContactArn"
            case displayName = "DisplayName"
            case firstName = "FirstName"
            case lastName = "LastName"
            case phoneNumber = "PhoneNumber"
            case phoneNumbers = "PhoneNumbers"
            case sipAddresses = "SipAddresses"
        }
    }

    public struct Content: AWSEncodableShape {
        /// The list of audio messages.
        public let audioList: [Audio]?
        /// The list of SSML messages.
        public let ssmlList: [Ssml]?
        /// The list of text messages.
        public let textList: [Text]?

        public init(audioList: [Audio]? = nil, ssmlList: [Ssml]? = nil, textList: [Text]? = nil) {
            self.audioList = audioList
            self.ssmlList = ssmlList
            self.textList = textList
        }

        public func validate(name: String) throws {
            try self.audioList?.forEach {
                try $0.validate(name: "\(name).audioList[]")
            }
            try self.validate(self.audioList, name: "audioList", parent: name, max: 1)
            try self.ssmlList?.forEach {
                try $0.validate(name: "\(name).ssmlList[]")
            }
            try self.validate(self.ssmlList, name: "ssmlList", parent: name, max: 1)
            try self.textList?.forEach {
                try $0.validate(name: "\(name).textList[]")
            }
            try self.validate(self.textList, name: "textList", parent: name, max: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case audioList = "AudioList"
            case ssmlList = "SsmlList"
            case textList = "TextList"
        }
    }

    public struct CreateAddressBookRequest: AWSEncodableShape {
        /// A unique, user-specified identifier for the request that ensures idempotency.
        public let clientRequestToken: String?
        /// The description of the address book.
        public let description: String?
        /// The name of the address book.
        public let name: String
        /// The tags to be added to the specified resource. Do not provide system tags.
        public let tags: [Tag]?

        public init(clientRequestToken: String? = CreateAddressBookRequest.idempotencyToken(), description: String? = nil, name: String, tags: [Tag]? = nil) {
            self.clientRequestToken = clientRequestToken
            self.description = description
            self.name = name
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.validate(self.clientRequestToken, name: "clientRequestToken", parent: name, max: 150)
            try self.validate(self.clientRequestToken, name: "clientRequestToken", parent: name, min: 10)
            try self.validate(self.clientRequestToken, name: "clientRequestToken", parent: name, pattern: "[a-zA-Z0-9][a-zA-Z0-9_-]*")
            try self.validate(self.description, name: "description", parent: name, max: 200)
            try self.validate(self.description, name: "description", parent: name, min: 1)
            try self.validate(self.description, name: "description", parent: name, pattern: "[\\u0009\\u000A\\u000D\\u0020-\\u007E\\u0085\\u00A0-\\uD7FF\\uE000-\\uFFFD\\u10000-\\u10FFFF]*")
            try self.validate(self.name, name: "name", parent: name, max: 100)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "[\\u0009\\u000A\\u000D\\u0020-\\u007E\\u0085\\u00A0-\\uD7FF\\uE000-\\uFFFD\\u10000-\\u10FFFF]*")
            try self.tags?.forEach {
                try $0.validate(name: "\(name).tags[]")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case clientRequestToken = "ClientRequestToken"
            case description = "Description"
            case name = "Name"
            case tags = "Tags"
        }
    }

    public struct CreateAddressBookResponse: AWSDecodableShape {
        /// The ARN of the newly created address book.
        public let addressBookArn: String?

        public init(addressBookArn: String? = nil) {
            self.addressBookArn = addressBookArn
        }

        private enum CodingKeys: String, CodingKey {
            case addressBookArn = "AddressBookArn"
        }
    }

    public struct CreateBusinessReportScheduleRequest: AWSEncodableShape {
        /// The client request token.
        public let clientRequestToken: String?
        /// The content range of the reports.
        public let contentRange: BusinessReportContentRange
        /// The format of the generated report (individual CSV files or zipped files of individual files).
        public let format: BusinessReportFormat
        /// The recurrence of the reports. If this isn't specified, the report will only be delivered one time when the API is called.
        public let recurrence: BusinessReportRecurrence?
        /// The S3 bucket name of the output reports. If this isn't specified, the report can be retrieved from a download link by calling ListBusinessReportSchedule.
        public let s3BucketName: String?
        /// The S3 key where the report is delivered.
        public let s3KeyPrefix: String?
        /// The name identifier of the schedule.
        public let scheduleName: String?
        /// The tags for the business report schedule.
        public let tags: [Tag]?

        public init(clientRequestToken: String? = CreateBusinessReportScheduleRequest.idempotencyToken(), contentRange: BusinessReportContentRange, format: BusinessReportFormat, recurrence: BusinessReportRecurrence? = nil, s3BucketName: String? = nil, s3KeyPrefix: String? = nil, scheduleName: String? = nil, tags: [Tag]? = nil) {
            self.clientRequestToken = clientRequestToken
            self.contentRange = contentRange
            self.format = format
            self.recurrence = recurrence
            self.s3BucketName = s3BucketName
            self.s3KeyPrefix = s3KeyPrefix
            self.scheduleName = scheduleName
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.validate(self.clientRequestToken, name: "clientRequestToken", parent: name, max: 150)
            try self.validate(self.clientRequestToken, name: "clientRequestToken", parent: name, min: 10)
            try self.validate(self.clientRequestToken, name: "clientRequestToken", parent: name, pattern: "[a-zA-Z0-9][a-zA-Z0-9_-]*")
            try self.recurrence?.validate(name: "\(name).recurrence")
            try self.validate(self.s3BucketName, name: "s3BucketName", parent: name, pattern: "[a-z0-9-\\.]{3,63}")
            try self.validate(self.s3KeyPrefix, name: "s3KeyPrefix", parent: name, max: 100)
            try self.validate(self.s3KeyPrefix, name: "s3KeyPrefix", parent: name, min: 0)
            try self.validate(self.s3KeyPrefix, name: "s3KeyPrefix", parent: name, pattern: "[A-Za-z0-9!_\\-\\.\\*'()/]*")
            try self.validate(self.scheduleName, name: "scheduleName", parent: name, max: 64)
            try self.validate(self.scheduleName, name: "scheduleName", parent: name, min: 0)
            try self.validate(self.scheduleName, name: "scheduleName", parent: name, pattern: "[\\u0009\\u000A\\u000D\\u0020-\\u007E\\u0085\\u00A0-\\uD7FF\\uE000-\\uFFFD\\u10000-\\u10FFFF]*")
            try self.tags?.forEach {
                try $0.validate(name: "\(name).tags[]")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case clientRequestToken = "ClientRequestToken"
            case contentRange = "ContentRange"
            case format = "Format"
            case recurrence = "Recurrence"
            case s3BucketName = "S3BucketName"
            case s3KeyPrefix = "S3KeyPrefix"
            case scheduleName = "ScheduleName"
            case tags = "Tags"
        }
    }

    public struct CreateBusinessReportScheduleResponse: AWSDecodableShape {
        /// The ARN of the business report schedule.
        public let scheduleArn: String?

        public init(scheduleArn: String? = nil) {
            self.scheduleArn = scheduleArn
        }

        private enum CodingKeys: String, CodingKey {
            case scheduleArn = "ScheduleArn"
        }
    }

    public struct CreateConferenceProviderRequest: AWSEncodableShape {
        /// The request token of the client.
        public let clientRequestToken: String?
        /// The name of the conference provider.
        public let conferenceProviderName: String
        /// Represents a type within a list of predefined types.
        public let conferenceProviderType: ConferenceProviderType
        /// The IP endpoint and protocol for calling.
        public let iPDialIn: IPDialIn?
        /// The meeting settings for the conference provider.
        public let meetingSetting: MeetingSetting
        /// The information for PSTN conferencing.
        public let pSTNDialIn: PSTNDialIn?
        /// The tags to be added to the specified resource. Do not provide system tags.
        public let tags: [Tag]?

        public init(clientRequestToken: String? = CreateConferenceProviderRequest.idempotencyToken(), conferenceProviderName: String, conferenceProviderType: ConferenceProviderType, iPDialIn: IPDialIn? = nil, meetingSetting: MeetingSetting, pSTNDialIn: PSTNDialIn? = nil, tags: [Tag]? = nil) {
            self.clientRequestToken = clientRequestToken
            self.conferenceProviderName = conferenceProviderName
            self.conferenceProviderType = conferenceProviderType
            self.iPDialIn = iPDialIn
            self.meetingSetting = meetingSetting
            self.pSTNDialIn = pSTNDialIn
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.validate(self.clientRequestToken, name: "clientRequestToken", parent: name, max: 150)
            try self.validate(self.clientRequestToken, name: "clientRequestToken", parent: name, min: 10)
            try self.validate(self.clientRequestToken, name: "clientRequestToken", parent: name, pattern: "[a-zA-Z0-9][a-zA-Z0-9_-]*")
            try self.validate(self.conferenceProviderName, name: "conferenceProviderName", parent: name, max: 50)
            try self.validate(self.conferenceProviderName, name: "conferenceProviderName", parent: name, min: 1)
            try self.validate(self.conferenceProviderName, name: "conferenceProviderName", parent: name, pattern: "[\\u0009\\u000A\\u000D\\u0020-\\u007E\\u0085\\u00A0-\\uD7FF\\uE000-\\uFFFD\\u10000-\\u10FFFF]*")
            try self.iPDialIn?.validate(name: "\(name).iPDialIn")
            try self.pSTNDialIn?.validate(name: "\(name).pSTNDialIn")
            try self.tags?.forEach {
                try $0.validate(name: "\(name).tags[]")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case clientRequestToken = "ClientRequestToken"
            case conferenceProviderName = "ConferenceProviderName"
            case conferenceProviderType = "ConferenceProviderType"
            case iPDialIn = "IPDialIn"
            case meetingSetting = "MeetingSetting"
            case pSTNDialIn = "PSTNDialIn"
            case tags = "Tags"
        }
    }

    public struct CreateConferenceProviderResponse: AWSDecodableShape {
        /// The ARN of the newly-created conference provider.
        public let conferenceProviderArn: String?

        public init(conferenceProviderArn: String? = nil) {
            self.conferenceProviderArn = conferenceProviderArn
        }

        private enum CodingKeys: String, CodingKey {
            case conferenceProviderArn = "ConferenceProviderArn"
        }
    }

    public struct CreateContactRequest: AWSEncodableShape {
        /// A unique, user-specified identifier for this request that ensures idempotency.
        public let clientRequestToken: String?
        /// The name of the contact to display on the console.
        public let displayName: String?
        /// The first name of the contact that is used to call the contact on the device.
        public let firstName: String
        /// The last name of the contact that is used to call the contact on the device.
        public let lastName: String?
        /// The phone number of the contact in E.164 format. The phone number type defaults to WORK. You can specify PhoneNumber or PhoneNumbers. We recommend that you use PhoneNumbers, which lets you specify the phone number type and multiple numbers.
        public let phoneNumber: String?
        /// The list of phone numbers for the contact.
        public let phoneNumbers: [PhoneNumber]?
        /// The list of SIP addresses for the contact.
        public let sipAddresses: [SipAddress]?
        /// The tags to be added to the specified resource. Do not provide system tags.
        public let tags: [Tag]?

        public init(clientRequestToken: String? = CreateContactRequest.idempotencyToken(), displayName: String? = nil, firstName: String, lastName: String? = nil, phoneNumber: String? = nil, phoneNumbers: [PhoneNumber]? = nil, sipAddresses: [SipAddress]? = nil, tags: [Tag]? = nil) {
            self.clientRequestToken = clientRequestToken
            self.displayName = displayName
            self.firstName = firstName
            self.lastName = lastName
            self.phoneNumber = phoneNumber
            self.phoneNumbers = phoneNumbers
            self.sipAddresses = sipAddresses
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.validate(self.clientRequestToken, name: "clientRequestToken", parent: name, max: 150)
            try self.validate(self.clientRequestToken, name: "clientRequestToken", parent: name, min: 10)
            try self.validate(self.clientRequestToken, name: "clientRequestToken", parent: name, pattern: "[a-zA-Z0-9][a-zA-Z0-9_-]*")
            try self.validate(self.displayName, name: "displayName", parent: name, max: 100)
            try self.validate(self.displayName, name: "displayName", parent: name, min: 1)
            try self.validate(self.displayName, name: "displayName", parent: name, pattern: "[\\u0009\\u000A\\u000D\\u0020-\\u007E\\u0085\\u00A0-\\uD7FF\\uE000-\\uFFFD\\u10000-\\u10FFFF]*")
            try self.validate(self.firstName, name: "firstName", parent: name, max: 100)
            try self.validate(self.firstName, name: "firstName", parent: name, min: 1)
            try self.validate(self.firstName, name: "firstName", parent: name, pattern: "[\\u0009\\u000A\\u000D\\u0020-\\u007E\\u0085\\u00A0-\\uD7FF\\uE000-\\uFFFD\\u10000-\\u10FFFF]*")
            try self.validate(self.lastName, name: "lastName", parent: name, max: 100)
            try self.validate(self.lastName, name: "lastName", parent: name, min: 1)
            try self.validate(self.lastName, name: "lastName", parent: name, pattern: "[\\u0009\\u000A\\u000D\\u0020-\\u007E\\u0085\\u00A0-\\uD7FF\\uE000-\\uFFFD\\u10000-\\u10FFFF]*")
            try self.validate(self.phoneNumber, name: "phoneNumber", parent: name, max: 50)
            try self.validate(self.phoneNumber, name: "phoneNumber", parent: name, min: 0)
            try self.validate(self.phoneNumber, name: "phoneNumber", parent: name, pattern: "^[\\+0-9\\#\\,\\(][\\+0-9\\-\\.\\/\\(\\)\\,\\#\\s]+$")
            try self.phoneNumbers?.forEach {
                try $0.validate(name: "\(name).phoneNumbers[]")
            }
            try self.validate(self.phoneNumbers, name: "phoneNumbers", parent: name, max: 3)
            try self.validate(self.phoneNumbers, name: "phoneNumbers", parent: name, min: 0)
            try self.sipAddresses?.forEach {
                try $0.validate(name: "\(name).sipAddresses[]")
            }
            try self.validate(self.sipAddresses, name: "sipAddresses", parent: name, max: 1)
            try self.validate(self.sipAddresses, name: "sipAddresses", parent: name, min: 0)
            try self.tags?.forEach {
                try $0.validate(name: "\(name).tags[]")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case clientRequestToken = "ClientRequestToken"
            case displayName = "DisplayName"
            case firstName = "FirstName"
            case lastName = "LastName"
            case phoneNumber = "PhoneNumber"
            case phoneNumbers = "PhoneNumbers"
            case sipAddresses = "SipAddresses"
            case tags = "Tags"
        }
    }

    public struct CreateContactResponse: AWSDecodableShape {
        /// The ARN of the newly created address book.
        public let contactArn: String?

        public init(contactArn: String? = nil) {
            self.contactArn = contactArn
        }

        private enum CodingKeys: String, CodingKey {
            case contactArn = "ContactArn"
        }
    }

    public struct CreateEndOfMeetingReminder: AWSEncodableShape {
        /// Whether an end of meeting reminder is enabled or not.
        public let enabled: Bool
        ///  A range of 3 to 15 minutes that determines when the reminder begins.
        public let reminderAtMinutes: [Int]
        /// The type of sound that users hear during the end of meeting reminder.
        public let reminderType: EndOfMeetingReminderType

        public init(enabled: Bool, reminderAtMinutes: [Int], reminderType: EndOfMeetingReminderType) {
            self.enabled = enabled
            self.reminderAtMinutes = reminderAtMinutes
            self.reminderType = reminderType
        }

        public func validate(name: String) throws {
            try self.validate(self.reminderAtMinutes, name: "reminderAtMinutes", parent: name, max: 1)
            try self.validate(self.reminderAtMinutes, name: "reminderAtMinutes", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case enabled = "Enabled"
            case reminderAtMinutes = "ReminderAtMinutes"
            case reminderType = "ReminderType"
        }
    }

    public struct CreateGatewayGroupRequest: AWSEncodableShape {
        ///  A unique, user-specified identifier for the request that ensures idempotency.
        public let clientRequestToken: String
        /// The description of the gateway group.
        public let description: String?
        /// The name of the gateway group.
        public let name: String
        /// The tags to be added to the specified resource. Do not provide system tags.
        public let tags: [Tag]?

        public init(clientRequestToken: String = CreateGatewayGroupRequest.idempotencyToken(), description: String? = nil, name: String, tags: [Tag]? = nil) {
            self.clientRequestToken = clientRequestToken
            self.description = description
            self.name = name
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.validate(self.clientRequestToken, name: "clientRequestToken", parent: name, max: 150)
            try self.validate(self.clientRequestToken, name: "clientRequestToken", parent: name, min: 10)
            try self.validate(self.clientRequestToken, name: "clientRequestToken", parent: name, pattern: "[a-zA-Z0-9][a-zA-Z0-9_-]*")
            try self.validate(self.description, name: "description", parent: name, max: 200)
            try self.validate(self.description, name: "description", parent: name, min: 0)
            try self.validate(self.name, name: "name", parent: name, max: 100)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "[\\u0009\\u000A\\u000D\\u0020-\\u007E\\u0085\\u00A0-\\uD7FF\\uE000-\\uFFFD\\u10000-\\u10FFFF]*")
            try self.tags?.forEach {
                try $0.validate(name: "\(name).tags[]")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case clientRequestToken = "ClientRequestToken"
            case description = "Description"
            case name = "Name"
            case tags = "Tags"
        }
    }

    public struct CreateGatewayGroupResponse: AWSDecodableShape {
        /// The ARN of the created gateway group.
        public let gatewayGroupArn: String?

        public init(gatewayGroupArn: String? = nil) {
            self.gatewayGroupArn = gatewayGroupArn
        }

        private enum CodingKeys: String, CodingKey {
            case gatewayGroupArn = "GatewayGroupArn"
        }
    }

    public struct CreateInstantBooking: AWSEncodableShape {
        /// Duration between 15 and 240 minutes at increments of 15 that determines how long to book an available room when a meeting is started with Alexa.
        public let durationInMinutes: Int
        /// Whether instant booking is enabled or not.
        public let enabled: Bool

        public init(durationInMinutes: Int, enabled: Bool) {
            self.durationInMinutes = durationInMinutes
            self.enabled = enabled
        }

        private enum CodingKeys: String, CodingKey {
            case durationInMinutes = "DurationInMinutes"
            case enabled = "Enabled"
        }
    }

    public struct CreateMeetingRoomConfiguration: AWSEncodableShape {
        public let endOfMeetingReminder: CreateEndOfMeetingReminder?
        /// Settings to automatically book a room for a configured duration if it's free when joining a meeting with Alexa.
        public let instantBooking: CreateInstantBooking?
        /// Settings for requiring a check in when a room is reserved. Alexa can cancel a room reservation if it's not checked into to make the room available for others. Users can check in by joining the meeting with Alexa or an AVS device, or by saying Alexa, check in.
        public let requireCheckIn: CreateRequireCheckIn?
        /// Whether room utilization metrics are enabled or not.
        public let roomUtilizationMetricsEnabled: Bool?

        public init(endOfMeetingReminder: CreateEndOfMeetingReminder? = nil, instantBooking: CreateInstantBooking? = nil, requireCheckIn: CreateRequireCheckIn? = nil, roomUtilizationMetricsEnabled: Bool? = nil) {
            self.endOfMeetingReminder = endOfMeetingReminder
            self.instantBooking = instantBooking
            self.requireCheckIn = requireCheckIn
            self.roomUtilizationMetricsEnabled = roomUtilizationMetricsEnabled
        }

        public func validate(name: String) throws {
            try self.endOfMeetingReminder?.validate(name: "\(name).endOfMeetingReminder")
        }

        private enum CodingKeys: String, CodingKey {
            case endOfMeetingReminder = "EndOfMeetingReminder"
            case instantBooking = "InstantBooking"
            case requireCheckIn = "RequireCheckIn"
            case roomUtilizationMetricsEnabled = "RoomUtilizationMetricsEnabled"
        }
    }

    public struct CreateNetworkProfileRequest: AWSEncodableShape {
        /// The ARN of the Private Certificate Authority (PCA) created in AWS Certificate Manager (ACM). This is used to issue certificates to the devices.
        public let certificateAuthorityArn: String?
        public let clientRequestToken: String
        /// The current password of the Wi-Fi network.
        public let currentPassword: String?
        /// Detailed information about a device's network profile.
        public let description: String?
        /// The authentication standard that is used in the EAP framework. Currently, EAP_TLS is supported.
        public let eapMethod: NetworkEapMethod?
        /// The name of the network profile associated with a device.
        public let networkProfileName: String
        /// The next, or subsequent, password of the Wi-Fi network. This password is asynchronously transmitted to the device and is used when the password of the network changes to NextPassword.
        public let nextPassword: String?
        /// The security type of the Wi-Fi network. This can be WPA2_ENTERPRISE, WPA2_PSK, WPA_PSK, WEP, or OPEN.
        public let securityType: NetworkSecurityType
        /// The SSID of the Wi-Fi network.
        public let ssid: String
        /// The tags to be added to the specified resource. Do not provide system tags.
        public let tags: [Tag]?
        /// The root certificates of your authentication server that is installed on your devices and used to trust your authentication server during EAP negotiation.
        public let trustAnchors: [String]?

        public init(certificateAuthorityArn: String? = nil, clientRequestToken: String = CreateNetworkProfileRequest.idempotencyToken(), currentPassword: String? = nil, description: String? = nil, eapMethod: NetworkEapMethod? = nil, networkProfileName: String, nextPassword: String? = nil, securityType: NetworkSecurityType, ssid: String, tags: [Tag]? = nil, trustAnchors: [String]? = nil) {
            self.certificateAuthorityArn = certificateAuthorityArn
            self.clientRequestToken = clientRequestToken
            self.currentPassword = currentPassword
            self.description = description
            self.eapMethod = eapMethod
            self.networkProfileName = networkProfileName
            self.nextPassword = nextPassword
            self.securityType = securityType
            self.ssid = ssid
            self.tags = tags
            self.trustAnchors = trustAnchors
        }

        public func validate(name: String) throws {
            try self.validate(self.certificateAuthorityArn, name: "certificateAuthorityArn", parent: name, pattern: "arn:[a-z0-9-\\.]{1,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[^/].{0,1023}")
            try self.validate(self.clientRequestToken, name: "clientRequestToken", parent: name, max: 150)
            try self.validate(self.clientRequestToken, name: "clientRequestToken", parent: name, min: 10)
            try self.validate(self.clientRequestToken, name: "clientRequestToken", parent: name, pattern: "[a-zA-Z0-9][a-zA-Z0-9_-]*")
            try self.validate(self.currentPassword, name: "currentPassword", parent: name, max: 128)
            try self.validate(self.currentPassword, name: "currentPassword", parent: name, min: 5)
            try self.validate(self.currentPassword, name: "currentPassword", parent: name, pattern: "[\\x00-\\x7F]*")
            try self.validate(self.description, name: "description", parent: name, max: 200)
            try self.validate(self.description, name: "description", parent: name, min: 0)
            try self.validate(self.description, name: "description", parent: name, pattern: "[\\u0009\\u000A\\u000D\\u0020-\\u007E\\u0085\\u00A0-\\uD7FF\\uE000-\\uFFFD\\u10000-\\u10FFFF]*")
            try self.validate(self.networkProfileName, name: "networkProfileName", parent: name, max: 100)
            try self.validate(self.networkProfileName, name: "networkProfileName", parent: name, min: 1)
            try self.validate(self.networkProfileName, name: "networkProfileName", parent: name, pattern: "[\\u0009\\u000A\\u000D\\u0020-\\u007E\\u0085\\u00A0-\\uD7FF\\uE000-\\uFFFD\\u10000-\\u10FFFF]*")
            try self.validate(self.nextPassword, name: "nextPassword", parent: name, max: 128)
            try self.validate(self.nextPassword, name: "nextPassword", parent: name, min: 0)
            try self.validate(self.nextPassword, name: "nextPassword", parent: name, pattern: "(^$)|([\\x00-\\x7F]{5,})")
            try self.validate(self.ssid, name: "ssid", parent: name, max: 32)
            try self.validate(self.ssid, name: "ssid", parent: name, min: 1)
            try self.validate(self.ssid, name: "ssid", parent: name, pattern: "[\\u0009\\u000A\\u000D\\u0020-\\u007E\\u0085\\u00A0-\\uD7FF\\uE000-\\uFFFD\\u10000-\\u10FFFF]*")
            try self.tags?.forEach {
                try $0.validate(name: "\(name).tags[]")
            }
            try self.trustAnchors?.forEach {
                try validate($0, name: "trustAnchors[]", parent: name, pattern: "-{5}BEGIN CERTIFICATE-{5}\\u000D?\\u000A([A-Za-z0-9/+]{64}\\u000D?\\u000A)*[A-Za-z0-9/+]{1,64}={0,2}\\u000D?\\u000A-{5}END CERTIFICATE-{5}(\\u000D?\\u000A)?")
            }
            try self.validate(self.trustAnchors, name: "trustAnchors", parent: name, max: 5)
            try self.validate(self.trustAnchors, name: "trustAnchors", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case certificateAuthorityArn = "CertificateAuthorityArn"
            case clientRequestToken = "ClientRequestToken"
            case currentPassword = "CurrentPassword"
            case description = "Description"
            case eapMethod = "EapMethod"
            case networkProfileName = "NetworkProfileName"
            case nextPassword = "NextPassword"
            case securityType = "SecurityType"
            case ssid = "Ssid"
            case tags = "Tags"
            case trustAnchors = "TrustAnchors"
        }
    }

    public struct CreateNetworkProfileResponse: AWSDecodableShape {
        /// The ARN of the network profile associated with a device.
        public let networkProfileArn: String?

        public init(networkProfileArn: String? = nil) {
            self.networkProfileArn = networkProfileArn
        }

        private enum CodingKeys: String, CodingKey {
            case networkProfileArn = "NetworkProfileArn"
        }
    }

    public struct CreateProfileRequest: AWSEncodableShape {
        /// The valid address for the room.
        public let address: String
        /// The user-specified token that is used during the creation of a profile.
        public let clientRequestToken: String?
        /// Whether data retention of the profile is enabled.
        public let dataRetentionOptIn: Bool?
        /// The distance unit to be used by devices in the profile.
        public let distanceUnit: DistanceUnit
        /// The locale of the room profile. (This is currently only available to a limited preview audience.)
        public let locale: String?
        /// The maximum volume limit for a room profile.
        public let maxVolumeLimit: Int?
        /// The meeting room settings of a room profile.
        public let meetingRoomConfiguration: CreateMeetingRoomConfiguration?
        /// The name of a room profile.
        public let profileName: String
        /// Whether PSTN calling is enabled.
        public let pSTNEnabled: Bool?
        /// Whether room profile setup is enabled.
        public let setupModeDisabled: Bool?
        /// The tags for the profile.
        public let tags: [Tag]?
        /// The temperature unit to be used by devices in the profile.
        public let temperatureUnit: TemperatureUnit
        /// The time zone used by a room profile.
        public let timezone: String
        /// A wake word for Alexa, Echo, Amazon, or a computer.
        public let wakeWord: WakeWord

        public init(address: String, clientRequestToken: String? = CreateProfileRequest.idempotencyToken(), dataRetentionOptIn: Bool? = nil, distanceUnit: DistanceUnit, locale: String? = nil, maxVolumeLimit: Int? = nil, meetingRoomConfiguration: CreateMeetingRoomConfiguration? = nil, profileName: String, pSTNEnabled: Bool? = nil, setupModeDisabled: Bool? = nil, tags: [Tag]? = nil, temperatureUnit: TemperatureUnit, timezone: String, wakeWord: WakeWord) {
            self.address = address
            self.clientRequestToken = clientRequestToken
            self.dataRetentionOptIn = dataRetentionOptIn
            self.distanceUnit = distanceUnit
            self.locale = locale
            self.maxVolumeLimit = maxVolumeLimit
            self.meetingRoomConfiguration = meetingRoomConfiguration
            self.profileName = profileName
            self.pSTNEnabled = pSTNEnabled
            self.setupModeDisabled = setupModeDisabled
            self.tags = tags
            self.temperatureUnit = temperatureUnit
            self.timezone = timezone
            self.wakeWord = wakeWord
        }

        public func validate(name: String) throws {
            try self.validate(self.address, name: "address", parent: name, max: 500)
            try self.validate(self.address, name: "address", parent: name, min: 1)
            try self.validate(self.clientRequestToken, name: "clientRequestToken", parent: name, max: 150)
            try self.validate(self.clientRequestToken, name: "clientRequestToken", parent: name, min: 10)
            try self.validate(self.clientRequestToken, name: "clientRequestToken", parent: name, pattern: "[a-zA-Z0-9][a-zA-Z0-9_-]*")
            try self.validate(self.locale, name: "locale", parent: name, max: 256)
            try self.validate(self.locale, name: "locale", parent: name, min: 1)
            try self.meetingRoomConfiguration?.validate(name: "\(name).meetingRoomConfiguration")
            try self.validate(self.profileName, name: "profileName", parent: name, max: 100)
            try self.validate(self.profileName, name: "profileName", parent: name, min: 1)
            try self.validate(self.profileName, name: "profileName", parent: name, pattern: "[\\u0009\\u000A\\u000D\\u0020-\\u007E\\u0085\\u00A0-\\uD7FF\\uE000-\\uFFFD\\u10000-\\u10FFFF]*")
            try self.tags?.forEach {
                try $0.validate(name: "\(name).tags[]")
            }
            try self.validate(self.timezone, name: "timezone", parent: name, max: 100)
            try self.validate(self.timezone, name: "timezone", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case address = "Address"
            case clientRequestToken = "ClientRequestToken"
            case dataRetentionOptIn = "DataRetentionOptIn"
            case distanceUnit = "DistanceUnit"
            case locale = "Locale"
            case maxVolumeLimit = "MaxVolumeLimit"
            case meetingRoomConfiguration = "MeetingRoomConfiguration"
            case profileName = "ProfileName"
            case pSTNEnabled = "PSTNEnabled"
            case setupModeDisabled = "SetupModeDisabled"
            case tags = "Tags"
            case temperatureUnit = "TemperatureUnit"
            case timezone = "Timezone"
            case wakeWord = "WakeWord"
        }
    }

    public struct CreateProfileResponse: AWSDecodableShape {
        /// The ARN of the newly created room profile in the response.
        public let profileArn: String?

        public init(profileArn: String? = nil) {
            self.profileArn = profileArn
        }

        private enum CodingKeys: String, CodingKey {
            case profileArn = "ProfileArn"
        }
    }

    public struct CreateRequireCheckIn: AWSEncodableShape {
        /// Whether require check in is enabled or not.
        public let enabled: Bool
        /// Duration between 5 and 20 minutes to determine when to release the room if it's not checked into.
        public let releaseAfterMinutes: Int

        public init(enabled: Bool, releaseAfterMinutes: Int) {
            self.enabled = enabled
            self.releaseAfterMinutes = releaseAfterMinutes
        }

        private enum CodingKeys: String, CodingKey {
            case enabled = "Enabled"
            case releaseAfterMinutes = "ReleaseAfterMinutes"
        }
    }

    public struct CreateRoomRequest: AWSEncodableShape {
        /// A unique, user-specified identifier for this request that ensures idempotency.
        public let clientRequestToken: String?
        /// The description for the room.
        public let description: String?
        /// The profile ARN for the room. This is required.
        public let profileArn: String?
        /// The calendar ARN for the room.
        public let providerCalendarId: String?
        /// The name for the room.
        public let roomName: String
        /// The tags for the room.
        public let tags: [Tag]?

        public init(clientRequestToken: String? = CreateRoomRequest.idempotencyToken(), description: String? = nil, profileArn: String? = nil, providerCalendarId: String? = nil, roomName: String, tags: [Tag]? = nil) {
            self.clientRequestToken = clientRequestToken
            self.description = description
            self.profileArn = profileArn
            self.providerCalendarId = providerCalendarId
            self.roomName = roomName
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.validate(self.clientRequestToken, name: "clientRequestToken", parent: name, max: 150)
            try self.validate(self.clientRequestToken, name: "clientRequestToken", parent: name, min: 10)
            try self.validate(self.clientRequestToken, name: "clientRequestToken", parent: name, pattern: "[a-zA-Z0-9][a-zA-Z0-9_-]*")
            try self.validate(self.description, name: "description", parent: name, max: 200)
            try self.validate(self.description, name: "description", parent: name, min: 1)
            try self.validate(self.description, name: "description", parent: name, pattern: "[\\u0009\\u000A\\u000D\\u0020-\\u007E\\u0085\\u00A0-\\uD7FF\\uE000-\\uFFFD\\u10000-\\u10FFFF]*")
            try self.validate(self.profileArn, name: "profileArn", parent: name, pattern: "arn:[a-z0-9-\\.]{1,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[^/].{0,1023}")
            try self.validate(self.providerCalendarId, name: "providerCalendarId", parent: name, max: 100)
            try self.validate(self.providerCalendarId, name: "providerCalendarId", parent: name, min: 0)
            try self.validate(self.roomName, name: "roomName", parent: name, max: 100)
            try self.validate(self.roomName, name: "roomName", parent: name, min: 1)
            try self.validate(self.roomName, name: "roomName", parent: name, pattern: "[\\u0009\\u000A\\u000D\\u0020-\\u007E\\u0085\\u00A0-\\uD7FF\\uE000-\\uFFFD\\u10000-\\u10FFFF]*")
            try self.tags?.forEach {
                try $0.validate(name: "\(name).tags[]")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case clientRequestToken = "ClientRequestToken"
            case description = "Description"
            case profileArn = "ProfileArn"
            case providerCalendarId = "ProviderCalendarId"
            case roomName = "RoomName"
            case tags = "Tags"
        }
    }

    public struct CreateRoomResponse: AWSDecodableShape {
        /// The ARN of the newly created room in the response.
        public let roomArn: String?

        public init(roomArn: String? = nil) {
            self.roomArn = roomArn
        }

        private enum CodingKeys: String, CodingKey {
            case roomArn = "RoomArn"
        }
    }

    public struct CreateSkillGroupRequest: AWSEncodableShape {
        /// A unique, user-specified identifier for this request that ensures idempotency.
        public let clientRequestToken: String?
        /// The description for the skill group.
        public let description: String?
        /// The name for the skill group.
        public let skillGroupName: String
        /// The tags for the skill group.
        public let tags: [Tag]?

        public init(clientRequestToken: String? = CreateSkillGroupRequest.idempotencyToken(), description: String? = nil, skillGroupName: String, tags: [Tag]? = nil) {
            self.clientRequestToken = clientRequestToken
            self.description = description
            self.skillGroupName = skillGroupName
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.validate(self.clientRequestToken, name: "clientRequestToken", parent: name, max: 150)
            try self.validate(self.clientRequestToken, name: "clientRequestToken", parent: name, min: 10)
            try self.validate(self.clientRequestToken, name: "clientRequestToken", parent: name, pattern: "[a-zA-Z0-9][a-zA-Z0-9_-]*")
            try self.validate(self.description, name: "description", parent: name, max: 200)
            try self.validate(self.description, name: "description", parent: name, min: 1)
            try self.validate(self.description, name: "description", parent: name, pattern: "[\\u0009\\u000A\\u000D\\u0020-\\u007E\\u0085\\u00A0-\\uD7FF\\uE000-\\uFFFD\\u10000-\\u10FFFF]*")
            try self.validate(self.skillGroupName, name: "skillGroupName", parent: name, max: 100)
            try self.validate(self.skillGroupName, name: "skillGroupName", parent: name, min: 1)
            try self.validate(self.skillGroupName, name: "skillGroupName", parent: name, pattern: "[\\u0009\\u000A\\u000D\\u0020-\\u007E\\u0085\\u00A0-\\uD7FF\\uE000-\\uFFFD\\u10000-\\u10FFFF]*")
            try self.tags?.forEach {
                try $0.validate(name: "\(name).tags[]")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case clientRequestToken = "ClientRequestToken"
            case description = "Description"
            case skillGroupName = "SkillGroupName"
            case tags = "Tags"
        }
    }

    public struct CreateSkillGroupResponse: AWSDecodableShape {
        /// The ARN of the newly created skill group in the response.
        public let skillGroupArn: String?

        public init(skillGroupArn: String? = nil) {
            self.skillGroupArn = skillGroupArn
        }

        private enum CodingKeys: String, CodingKey {
            case skillGroupArn = "SkillGroupArn"
        }
    }

    public struct CreateUserRequest: AWSEncodableShape {
        /// A unique, user-specified identifier for this request that ensures idempotency.
        public let clientRequestToken: String?
        /// The email address for the user.
        public let email: String?
        /// The first name for the user.
        public let firstName: String?
        /// The last name for the user.
        public let lastName: String?
        /// The tags for the user.
        public let tags: [Tag]?
        /// The ARN for the user.
        public let userId: String

        public init(clientRequestToken: String? = CreateUserRequest.idempotencyToken(), email: String? = nil, firstName: String? = nil, lastName: String? = nil, tags: [Tag]? = nil, userId: String) {
            self.clientRequestToken = clientRequestToken
            self.email = email
            self.firstName = firstName
            self.lastName = lastName
            self.tags = tags
            self.userId = userId
        }

        public func validate(name: String) throws {
            try self.validate(self.clientRequestToken, name: "clientRequestToken", parent: name, max: 150)
            try self.validate(self.clientRequestToken, name: "clientRequestToken", parent: name, min: 10)
            try self.validate(self.clientRequestToken, name: "clientRequestToken", parent: name, pattern: "[a-zA-Z0-9][a-zA-Z0-9_-]*")
            try self.validate(self.email, name: "email", parent: name, max: 128)
            try self.validate(self.email, name: "email", parent: name, min: 1)
            try self.validate(self.email, name: "email", parent: name, pattern: "([0-9a-zA-Z]([+-.\\w]*[0-9a-zA-Z])*@([0-9a-zA-Z]([-\\w]*[0-9a-zA-Z]+)*\\.)+[a-zA-Z]{2,9})")
            try self.validate(self.firstName, name: "firstName", parent: name, max: 30)
            try self.validate(self.firstName, name: "firstName", parent: name, min: 0)
            try self.validate(self.firstName, name: "firstName", parent: name, pattern: "([A-Za-z\\-' 0-9._]|\\p{IsLetter})*")
            try self.validate(self.lastName, name: "lastName", parent: name, max: 30)
            try self.validate(self.lastName, name: "lastName", parent: name, min: 0)
            try self.validate(self.lastName, name: "lastName", parent: name, pattern: "([A-Za-z\\-' 0-9._]|\\p{IsLetter})*")
            try self.tags?.forEach {
                try $0.validate(name: "\(name).tags[]")
            }
            try self.validate(self.userId, name: "userId", parent: name, max: 128)
            try self.validate(self.userId, name: "userId", parent: name, min: 1)
            try self.validate(self.userId, name: "userId", parent: name, pattern: "[a-zA-Z0-9@_+.-]*")
        }

        private enum CodingKeys: String, CodingKey {
            case clientRequestToken = "ClientRequestToken"
            case email = "Email"
            case firstName = "FirstName"
            case lastName = "LastName"
            case tags = "Tags"
            case userId = "UserId"
        }
    }

    public struct CreateUserResponse: AWSDecodableShape {
        /// The ARN of the newly created user in the response.
        public let userArn: String?

        public init(userArn: String? = nil) {
            self.userArn = userArn
        }

        private enum CodingKeys: String, CodingKey {
            case userArn = "UserArn"
        }
    }

    public struct DeleteAddressBookRequest: AWSEncodableShape {
        /// The ARN of the address book to delete.
        public let addressBookArn: String

        public init(addressBookArn: String) {
            self.addressBookArn = addressBookArn
        }

        public func validate(name: String) throws {
            try self.validate(self.addressBookArn, name: "addressBookArn", parent: name, pattern: "arn:[a-z0-9-\\.]{1,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[^/].{0,1023}")
        }

        private enum CodingKeys: String, CodingKey {
            case addressBookArn = "AddressBookArn"
        }
    }

    public struct DeleteAddressBookResponse: AWSDecodableShape {
        public init() {}
    }

    public struct DeleteBusinessReportScheduleRequest: AWSEncodableShape {
        /// The ARN of the business report schedule.
        public let scheduleArn: String

        public init(scheduleArn: String) {
            self.scheduleArn = scheduleArn
        }

        public func validate(name: String) throws {
            try self.validate(self.scheduleArn, name: "scheduleArn", parent: name, pattern: "arn:[a-z0-9-\\.]{1,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[^/].{0,1023}")
        }

        private enum CodingKeys: String, CodingKey {
            case scheduleArn = "ScheduleArn"
        }
    }

    public struct DeleteBusinessReportScheduleResponse: AWSDecodableShape {
        public init() {}
    }

    public struct DeleteConferenceProviderRequest: AWSEncodableShape {
        /// The ARN of the conference provider.
        public let conferenceProviderArn: String

        public init(conferenceProviderArn: String) {
            self.conferenceProviderArn = conferenceProviderArn
        }

        public func validate(name: String) throws {
            try self.validate(self.conferenceProviderArn, name: "conferenceProviderArn", parent: name, pattern: "arn:[a-z0-9-\\.]{1,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[^/].{0,1023}")
        }

        private enum CodingKeys: String, CodingKey {
            case conferenceProviderArn = "ConferenceProviderArn"
        }
    }

    public struct DeleteConferenceProviderResponse: AWSDecodableShape {
        public init() {}
    }

    public struct DeleteContactRequest: AWSEncodableShape {
        /// The ARN of the contact to delete.
        public let contactArn: String

        public init(contactArn: String) {
            self.contactArn = contactArn
        }

        public func validate(name: String) throws {
            try self.validate(self.contactArn, name: "contactArn", parent: name, pattern: "arn:[a-z0-9-\\.]{1,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[^/].{0,1023}")
        }

        private enum CodingKeys: String, CodingKey {
            case contactArn = "ContactArn"
        }
    }

    public struct DeleteContactResponse: AWSDecodableShape {
        public init() {}
    }

    public struct DeleteDeviceRequest: AWSEncodableShape {
        /// The ARN of the device for which to request details.
        public let deviceArn: String

        public init(deviceArn: String) {
            self.deviceArn = deviceArn
        }

        public func validate(name: String) throws {
            try self.validate(self.deviceArn, name: "deviceArn", parent: name, pattern: "arn:[a-z0-9-\\.]{1,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[^/].{0,1023}")
        }

        private enum CodingKeys: String, CodingKey {
            case deviceArn = "DeviceArn"
        }
    }

    public struct DeleteDeviceResponse: AWSDecodableShape {
        public init() {}
    }

    public struct DeleteDeviceUsageDataRequest: AWSEncodableShape {
        /// The ARN of the device.
        public let deviceArn: String
        /// The type of usage data to delete.
        public let deviceUsageType: DeviceUsageType

        public init(deviceArn: String, deviceUsageType: DeviceUsageType) {
            self.deviceArn = deviceArn
            self.deviceUsageType = deviceUsageType
        }

        public func validate(name: String) throws {
            try self.validate(self.deviceArn, name: "deviceArn", parent: name, pattern: "arn:[a-z0-9-\\.]{1,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[^/].{0,1023}")
        }

        private enum CodingKeys: String, CodingKey {
            case deviceArn = "DeviceArn"
            case deviceUsageType = "DeviceUsageType"
        }
    }

    public struct DeleteDeviceUsageDataResponse: AWSDecodableShape {
        public init() {}
    }

    public struct DeleteGatewayGroupRequest: AWSEncodableShape {
        /// The ARN of the gateway group to delete.
        public let gatewayGroupArn: String

        public init(gatewayGroupArn: String) {
            self.gatewayGroupArn = gatewayGroupArn
        }

        public func validate(name: String) throws {
            try self.validate(self.gatewayGroupArn, name: "gatewayGroupArn", parent: name, pattern: "arn:[a-z0-9-\\.]{1,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[^/].{0,1023}")
        }

        private enum CodingKeys: String, CodingKey {
            case gatewayGroupArn = "GatewayGroupArn"
        }
    }

    public struct DeleteGatewayGroupResponse: AWSDecodableShape {
        public init() {}
    }

    public struct DeleteNetworkProfileRequest: AWSEncodableShape {
        /// The ARN of the network profile associated with a device.
        public let networkProfileArn: String

        public init(networkProfileArn: String) {
            self.networkProfileArn = networkProfileArn
        }

        public func validate(name: String) throws {
            try self.validate(self.networkProfileArn, name: "networkProfileArn", parent: name, pattern: "arn:[a-z0-9-\\.]{1,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[^/].{0,1023}")
        }

        private enum CodingKeys: String, CodingKey {
            case networkProfileArn = "NetworkProfileArn"
        }
    }

    public struct DeleteNetworkProfileResponse: AWSDecodableShape {
        public init() {}
    }

    public struct DeleteProfileRequest: AWSEncodableShape {
        /// The ARN of the room profile to delete. Required.
        public let profileArn: String?

        public init(profileArn: String? = nil) {
            self.profileArn = profileArn
        }

        public func validate(name: String) throws {
            try self.validate(self.profileArn, name: "profileArn", parent: name, pattern: "arn:[a-z0-9-\\.]{1,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[^/].{0,1023}")
        }

        private enum CodingKeys: String, CodingKey {
            case profileArn = "ProfileArn"
        }
    }

    public struct DeleteProfileResponse: AWSDecodableShape {
        public init() {}
    }

    public struct DeleteRoomRequest: AWSEncodableShape {
        /// The ARN of the room to delete. Required.
        public let roomArn: String?

        public init(roomArn: String? = nil) {
            self.roomArn = roomArn
        }

        public func validate(name: String) throws {
            try self.validate(self.roomArn, name: "roomArn", parent: name, pattern: "arn:[a-z0-9-\\.]{1,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[^/].{0,1023}")
        }

        private enum CodingKeys: String, CodingKey {
            case roomArn = "RoomArn"
        }
    }

    public struct DeleteRoomResponse: AWSDecodableShape {
        public init() {}
    }

    public struct DeleteRoomSkillParameterRequest: AWSEncodableShape {
        /// The room skill parameter key for which to remove details.
        public let parameterKey: String
        /// The ARN of the room from which to remove the room skill parameter details.
        public let roomArn: String?
        /// The ID of the skill from which to remove the room skill parameter details.
        public let skillId: String

        public init(parameterKey: String, roomArn: String? = nil, skillId: String) {
            self.parameterKey = parameterKey
            self.roomArn = roomArn
            self.skillId = skillId
        }

        public func validate(name: String) throws {
            try self.validate(self.parameterKey, name: "parameterKey", parent: name, max: 256)
            try self.validate(self.parameterKey, name: "parameterKey", parent: name, min: 1)
            try self.validate(self.roomArn, name: "roomArn", parent: name, pattern: "arn:[a-z0-9-\\.]{1,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[^/].{0,1023}")
            try self.validate(self.skillId, name: "skillId", parent: name, pattern: "(^amzn1\\.ask\\.skill\\.[0-9a-f\\-]{1,200})|(^amzn1\\.echo-sdk-ams\\.app\\.[0-9a-f\\-]{1,200})")
        }

        private enum CodingKeys: String, CodingKey {
            case parameterKey = "ParameterKey"
            case roomArn = "RoomArn"
            case skillId = "SkillId"
        }
    }

    public struct DeleteRoomSkillParameterResponse: AWSDecodableShape {
        public init() {}
    }

    public struct DeleteSkillAuthorizationRequest: AWSEncodableShape {
        /// The room that the skill is authorized for.
        public let roomArn: String?
        /// The unique identifier of a skill.
        public let skillId: String

        public init(roomArn: String? = nil, skillId: String) {
            self.roomArn = roomArn
            self.skillId = skillId
        }

        public func validate(name: String) throws {
            try self.validate(self.roomArn, name: "roomArn", parent: name, pattern: "arn:[a-z0-9-\\.]{1,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[^/].{0,1023}")
            try self.validate(self.skillId, name: "skillId", parent: name, pattern: "(^amzn1\\.ask\\.skill\\.[0-9a-f\\-]{1,200})|(^amzn1\\.echo-sdk-ams\\.app\\.[0-9a-f\\-]{1,200})")
        }

        private enum CodingKeys: String, CodingKey {
            case roomArn = "RoomArn"
            case skillId = "SkillId"
        }
    }

    public struct DeleteSkillAuthorizationResponse: AWSDecodableShape {
        public init() {}
    }

    public struct DeleteSkillGroupRequest: AWSEncodableShape {
        /// The ARN of the skill group to delete. Required.
        public let skillGroupArn: String?

        public init(skillGroupArn: String? = nil) {
            self.skillGroupArn = skillGroupArn
        }

        public func validate(name: String) throws {
            try self.validate(self.skillGroupArn, name: "skillGroupArn", parent: name, pattern: "arn:[a-z0-9-\\.]{1,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[^/].{0,1023}")
        }

        private enum CodingKeys: String, CodingKey {
            case skillGroupArn = "SkillGroupArn"
        }
    }

    public struct DeleteSkillGroupResponse: AWSDecodableShape {
        public init() {}
    }

    public struct DeleteUserRequest: AWSEncodableShape {
        /// The ARN of the user's enrollment in the organization. Required.
        public let enrollmentId: String
        /// The ARN of the user to delete in the organization. Required.
        public let userArn: String?

        public init(enrollmentId: String, userArn: String? = nil) {
            self.enrollmentId = enrollmentId
            self.userArn = userArn
        }

        public func validate(name: String) throws {
            try self.validate(self.enrollmentId, name: "enrollmentId", parent: name, max: 128)
            try self.validate(self.enrollmentId, name: "enrollmentId", parent: name, min: 0)
            try self.validate(self.userArn, name: "userArn", parent: name, pattern: "arn:[a-z0-9-\\.]{1,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[^/].{0,1023}")
        }

        private enum CodingKeys: String, CodingKey {
            case enrollmentId = "EnrollmentId"
            case userArn = "UserArn"
        }
    }

    public struct DeleteUserResponse: AWSDecodableShape {
        public init() {}
    }

    public struct DeveloperInfo: AWSDecodableShape {
        /// The name of the developer.
        public let developerName: String?
        /// The email of the developer.
        public let email: String?
        /// The URL of the privacy policy.
        public let privacyPolicy: String?
        /// The website of the developer.
        public let url: String?

        public init(developerName: String? = nil, email: String? = nil, privacyPolicy: String? = nil, url: String? = nil) {
            self.developerName = developerName
            self.email = email
            self.privacyPolicy = privacyPolicy
            self.url = url
        }

        private enum CodingKeys: String, CodingKey {
            case developerName = "DeveloperName"
            case email = "Email"
            case privacyPolicy = "PrivacyPolicy"
            case url = "Url"
        }
    }

    public struct Device: AWSDecodableShape {
        /// The ARN of a device.
        public let deviceArn: String?
        /// The name of a device.
        public let deviceName: String?
        /// The serial number of a device.
        public let deviceSerialNumber: String?
        /// The status of a device. If the status is not READY, check the DeviceStatusInfo value for details.
        public let deviceStatus: DeviceStatus?
        /// Detailed information about a device's status.
        public let deviceStatusInfo: DeviceStatusInfo?
        /// The type of a device.
        public let deviceType: String?
        /// The MAC address of a device.
        public let macAddress: String?
        /// Detailed information about a device's network profile.
        public let networkProfileInfo: DeviceNetworkProfileInfo?
        /// The room ARN of a device.
        public let roomArn: String?
        /// The software version of a device.
        public let softwareVersion: String?

        public init(deviceArn: String? = nil, deviceName: String? = nil, deviceSerialNumber: String? = nil, deviceStatus: DeviceStatus? = nil, deviceStatusInfo: DeviceStatusInfo? = nil, deviceType: String? = nil, macAddress: String? = nil, networkProfileInfo: DeviceNetworkProfileInfo? = nil, roomArn: String? = nil, softwareVersion: String? = nil) {
            self.deviceArn = deviceArn
            self.deviceName = deviceName
            self.deviceSerialNumber = deviceSerialNumber
            self.deviceStatus = deviceStatus
            self.deviceStatusInfo = deviceStatusInfo
            self.deviceType = deviceType
            self.macAddress = macAddress
            self.networkProfileInfo = networkProfileInfo
            self.roomArn = roomArn
            self.softwareVersion = softwareVersion
        }

        private enum CodingKeys: String, CodingKey {
            case deviceArn = "DeviceArn"
            case deviceName = "DeviceName"
            case deviceSerialNumber = "DeviceSerialNumber"
            case deviceStatus = "DeviceStatus"
            case deviceStatusInfo = "DeviceStatusInfo"
            case deviceType = "DeviceType"
            case macAddress = "MacAddress"
            case networkProfileInfo = "NetworkProfileInfo"
            case roomArn = "RoomArn"
            case softwareVersion = "SoftwareVersion"
        }
    }

    public struct DeviceData: AWSDecodableShape {
        /// The time (in epoch) when the device data was created.
        public let createdTime: Date?
        /// The ARN of a device.
        public let deviceArn: String?
        /// The name of a device.
        public let deviceName: String?
        /// The serial number of a device.
        public let deviceSerialNumber: String?
        /// The status of a device.
        public let deviceStatus: DeviceStatus?
        /// Detailed information about a device's status.
        public let deviceStatusInfo: DeviceStatusInfo?
        /// The type of a device.
        public let deviceType: String?
        /// The MAC address of a device.
        public let macAddress: String?
        /// The ARN of the network profile associated with a device.
        public let networkProfileArn: String?
        /// The name of the network profile associated with a device.
        public let networkProfileName: String?
        /// The room ARN associated with a device.
        public let roomArn: String?
        /// The name of the room associated with a device.
        public let roomName: String?
        /// The software version of a device.
        public let softwareVersion: String?

        public init(createdTime: Date? = nil, deviceArn: String? = nil, deviceName: String? = nil, deviceSerialNumber: String? = nil, deviceStatus: DeviceStatus? = nil, deviceStatusInfo: DeviceStatusInfo? = nil, deviceType: String? = nil, macAddress: String? = nil, networkProfileArn: String? = nil, networkProfileName: String? = nil, roomArn: String? = nil, roomName: String? = nil, softwareVersion: String? = nil) {
            self.createdTime = createdTime
            self.deviceArn = deviceArn
            self.deviceName = deviceName
            self.deviceSerialNumber = deviceSerialNumber
            self.deviceStatus = deviceStatus
            self.deviceStatusInfo = deviceStatusInfo
            self.deviceType = deviceType
            self.macAddress = macAddress
            self.networkProfileArn = networkProfileArn
            self.networkProfileName = networkProfileName
            self.roomArn = roomArn
            self.roomName = roomName
            self.softwareVersion = softwareVersion
        }

        private enum CodingKeys: String, CodingKey {
            case createdTime = "CreatedTime"
            case deviceArn = "DeviceArn"
            case deviceName = "DeviceName"
            case deviceSerialNumber = "DeviceSerialNumber"
            case deviceStatus = "DeviceStatus"
            case deviceStatusInfo = "DeviceStatusInfo"
            case deviceType = "DeviceType"
            case macAddress = "MacAddress"
            case networkProfileArn = "NetworkProfileArn"
            case networkProfileName = "NetworkProfileName"
            case roomArn = "RoomArn"
            case roomName = "RoomName"
            case softwareVersion = "SoftwareVersion"
        }
    }

    public struct DeviceEvent: AWSDecodableShape {
        /// The time (in epoch) when the event occurred.
        public let timestamp: Date?
        /// The type of device event.
        public let type: DeviceEventType?
        /// The value of the event.
        public let value: String?

        public init(timestamp: Date? = nil, type: DeviceEventType? = nil, value: String? = nil) {
            self.timestamp = timestamp
            self.type = type
            self.value = value
        }

        private enum CodingKeys: String, CodingKey {
            case timestamp = "Timestamp"
            case type = "Type"
            case value = "Value"
        }
    }

    public struct DeviceNetworkProfileInfo: AWSDecodableShape {
        /// The ARN of the certificate associated with a device.
        public let certificateArn: String?
        /// The time (in epoch) when the certificate expires.
        public let certificateExpirationTime: Date?
        /// The ARN of the network profile associated with a device.
        public let networkProfileArn: String?

        public init(certificateArn: String? = nil, certificateExpirationTime: Date? = nil, networkProfileArn: String? = nil) {
            self.certificateArn = certificateArn
            self.certificateExpirationTime = certificateExpirationTime
            self.networkProfileArn = networkProfileArn
        }

        private enum CodingKeys: String, CodingKey {
            case certificateArn = "CertificateArn"
            case certificateExpirationTime = "CertificateExpirationTime"
            case networkProfileArn = "NetworkProfileArn"
        }
    }

    public struct DeviceStatusDetail: AWSDecodableShape {
        /// The device status detail code.
        public let code: DeviceStatusDetailCode?
        /// The list of available features on the device.
        public let feature: Feature?

        public init(code: DeviceStatusDetailCode? = nil, feature: Feature? = nil) {
            self.code = code
            self.feature = feature
        }

        private enum CodingKeys: String, CodingKey {
            case code = "Code"
            case feature = "Feature"
        }
    }

    public struct DeviceStatusInfo: AWSDecodableShape {
        /// The latest available information about the connection status of a device.
        public let connectionStatus: ConnectionStatus?
        /// The time (in epoch) when the device connection status changed.
        public let connectionStatusUpdatedTime: Date?
        /// One or more device status detail descriptions.
        public let deviceStatusDetails: [DeviceStatusDetail]?

        public init(connectionStatus: ConnectionStatus? = nil, connectionStatusUpdatedTime: Date? = nil, deviceStatusDetails: [DeviceStatusDetail]? = nil) {
            self.connectionStatus = connectionStatus
            self.connectionStatusUpdatedTime = connectionStatusUpdatedTime
            self.deviceStatusDetails = deviceStatusDetails
        }

        private enum CodingKeys: String, CodingKey {
            case connectionStatus = "ConnectionStatus"
            case connectionStatusUpdatedTime = "ConnectionStatusUpdatedTime"
            case deviceStatusDetails = "DeviceStatusDetails"
        }
    }

    public struct DisassociateContactFromAddressBookRequest: AWSEncodableShape {
        /// The ARN of the address from which to disassociate the contact.
        public let addressBookArn: String
        /// The ARN of the contact to disassociate from an address book.
        public let contactArn: String

        public init(addressBookArn: String, contactArn: String) {
            self.addressBookArn = addressBookArn
            self.contactArn = contactArn
        }

        public func validate(name: String) throws {
            try self.validate(self.addressBookArn, name: "addressBookArn", parent: name, pattern: "arn:[a-z0-9-\\.]{1,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[^/].{0,1023}")
            try self.validate(self.contactArn, name: "contactArn", parent: name, pattern: "arn:[a-z0-9-\\.]{1,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[^/].{0,1023}")
        }

        private enum CodingKeys: String, CodingKey {
            case addressBookArn = "AddressBookArn"
            case contactArn = "ContactArn"
        }
    }

    public struct DisassociateContactFromAddressBookResponse: AWSDecodableShape {
        public init() {}
    }

    public struct DisassociateDeviceFromRoomRequest: AWSEncodableShape {
        /// The ARN of the device to disassociate from a room. Required.
        public let deviceArn: String?

        public init(deviceArn: String? = nil) {
            self.deviceArn = deviceArn
        }

        public func validate(name: String) throws {
            try self.validate(self.deviceArn, name: "deviceArn", parent: name, pattern: "arn:[a-z0-9-\\.]{1,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[^/].{0,1023}")
        }

        private enum CodingKeys: String, CodingKey {
            case deviceArn = "DeviceArn"
        }
    }

    public struct DisassociateDeviceFromRoomResponse: AWSDecodableShape {
        public init() {}
    }

    public struct DisassociateSkillFromSkillGroupRequest: AWSEncodableShape {
        /// The unique identifier of a skill. Required.
        public let skillGroupArn: String?
        /// The ARN of a skill group to associate to a skill.
        public let skillId: String

        public init(skillGroupArn: String? = nil, skillId: String) {
            self.skillGroupArn = skillGroupArn
            self.skillId = skillId
        }

        public func validate(name: String) throws {
            try self.validate(self.skillGroupArn, name: "skillGroupArn", parent: name, pattern: "arn:[a-z0-9-\\.]{1,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[^/].{0,1023}")
            try self.validate(self.skillId, name: "skillId", parent: name, pattern: "(^amzn1\\.ask\\.skill\\.[0-9a-f\\-]{1,200})|(^amzn1\\.echo-sdk-ams\\.app\\.[0-9a-f\\-]{1,200})")
        }

        private enum CodingKeys: String, CodingKey {
            case skillGroupArn = "SkillGroupArn"
            case skillId = "SkillId"
        }
    }

    public struct DisassociateSkillFromSkillGroupResponse: AWSDecodableShape {
        public init() {}
    }

    public struct DisassociateSkillFromUsersRequest: AWSEncodableShape {
        ///  The private skill ID you want to make unavailable for enrolled users.
        public let skillId: String

        public init(skillId: String) {
            self.skillId = skillId
        }

        public func validate(name: String) throws {
            try self.validate(self.skillId, name: "skillId", parent: name, pattern: "(^amzn1\\.ask\\.skill\\.[0-9a-f\\-]{1,200})|(^amzn1\\.echo-sdk-ams\\.app\\.[0-9a-f\\-]{1,200})")
        }

        private enum CodingKeys: String, CodingKey {
            case skillId = "SkillId"
        }
    }

    public struct DisassociateSkillFromUsersResponse: AWSDecodableShape {
        public init() {}
    }

    public struct DisassociateSkillGroupFromRoomRequest: AWSEncodableShape {
        /// The ARN of the room from which the skill group is to be disassociated. Required.
        public let roomArn: String?
        /// The ARN of the skill group to disassociate from a room. Required.
        public let skillGroupArn: String?

        public init(roomArn: String? = nil, skillGroupArn: String? = nil) {
            self.roomArn = roomArn
            self.skillGroupArn = skillGroupArn
        }

        public func validate(name: String) throws {
            try self.validate(self.roomArn, name: "roomArn", parent: name, pattern: "arn:[a-z0-9-\\.]{1,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[^/].{0,1023}")
            try self.validate(self.skillGroupArn, name: "skillGroupArn", parent: name, pattern: "arn:[a-z0-9-\\.]{1,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[^/].{0,1023}")
        }

        private enum CodingKeys: String, CodingKey {
            case roomArn = "RoomArn"
            case skillGroupArn = "SkillGroupArn"
        }
    }

    public struct DisassociateSkillGroupFromRoomResponse: AWSDecodableShape {
        public init() {}
    }

    public struct EndOfMeetingReminder: AWSDecodableShape {
        /// Whether an end of meeting reminder is enabled or not.
        public let enabled: Bool?
        /// A range of 3 to 15 minutes that determines when the reminder begins.
        public let reminderAtMinutes: [Int]?
        /// The type of sound that users hear during the end of meeting reminder.
        public let reminderType: EndOfMeetingReminderType?

        public init(enabled: Bool? = nil, reminderAtMinutes: [Int]? = nil, reminderType: EndOfMeetingReminderType? = nil) {
            self.enabled = enabled
            self.reminderAtMinutes = reminderAtMinutes
            self.reminderType = reminderType
        }

        private enum CodingKeys: String, CodingKey {
            case enabled = "Enabled"
            case reminderAtMinutes = "ReminderAtMinutes"
            case reminderType = "ReminderType"
        }
    }

    public struct Filter: AWSEncodableShape {
        /// The key of a filter.
        public let key: String
        /// The values of a filter.
        public let values: [String]

        public init(key: String, values: [String]) {
            self.key = key
            self.values = values
        }

        public func validate(name: String) throws {
            try self.validate(self.key, name: "key", parent: name, max: 500)
            try self.validate(self.key, name: "key", parent: name, min: 1)
            try self.values.forEach {
                try validate($0, name: "values[]", parent: name, max: 500)
                try validate($0, name: "values[]", parent: name, min: 1)
            }
            try self.validate(self.values, name: "values", parent: name, max: 50)
        }

        private enum CodingKeys: String, CodingKey {
            case key = "Key"
            case values = "Values"
        }
    }

    public struct ForgetSmartHomeAppliancesRequest: AWSEncodableShape {
        /// The room that the appliances are associated with.
        public let roomArn: String

        public init(roomArn: String) {
            self.roomArn = roomArn
        }

        public func validate(name: String) throws {
            try self.validate(self.roomArn, name: "roomArn", parent: name, pattern: "arn:[a-z0-9-\\.]{1,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[^/].{0,1023}")
        }

        private enum CodingKeys: String, CodingKey {
            case roomArn = "RoomArn"
        }
    }

    public struct ForgetSmartHomeAppliancesResponse: AWSDecodableShape {
        public init() {}
    }

    public struct Gateway: AWSDecodableShape {
        /// The ARN of the gateway.
        public let arn: String?
        /// The description of the gateway.
        public let description: String?
        /// The ARN of the gateway group that the gateway is associated to.
        public let gatewayGroupArn: String?
        /// The name of the gateway.
        public let name: String?
        /// The software version of the gateway. The gateway automatically updates its software version during normal operation.
        public let softwareVersion: String?

        public init(arn: String? = nil, description: String? = nil, gatewayGroupArn: String? = nil, name: String? = nil, softwareVersion: String? = nil) {
            self.arn = arn
            self.description = description
            self.gatewayGroupArn = gatewayGroupArn
            self.name = name
            self.softwareVersion = softwareVersion
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case description = "Description"
            case gatewayGroupArn = "GatewayGroupArn"
            case name = "Name"
            case softwareVersion = "SoftwareVersion"
        }
    }

    public struct GatewayGroup: AWSDecodableShape {
        /// The ARN of the gateway group.
        public let arn: String?
        /// The description of the gateway group.
        public let description: String?
        /// The name of the gateway group.
        public let name: String?

        public init(arn: String? = nil, description: String? = nil, name: String? = nil) {
            self.arn = arn
            self.description = description
            self.name = name
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case description = "Description"
            case name = "Name"
        }
    }

    public struct GatewayGroupSummary: AWSDecodableShape {
        /// The ARN of the gateway group.
        public let arn: String?
        /// The description of the gateway group.
        public let description: String?
        /// The name of the gateway group.
        public let name: String?

        public init(arn: String? = nil, description: String? = nil, name: String? = nil) {
            self.arn = arn
            self.description = description
            self.name = name
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case description = "Description"
            case name = "Name"
        }
    }

    public struct GatewaySummary: AWSDecodableShape {
        /// The ARN of the gateway.
        public let arn: String?
        /// The description of the gateway.
        public let description: String?
        /// The ARN of the gateway group that the gateway is associated to.
        public let gatewayGroupArn: String?
        /// The name of the gateway.
        public let name: String?
        /// The software version of the gateway. The gateway automatically updates its software version during normal operation.
        public let softwareVersion: String?

        public init(arn: String? = nil, description: String? = nil, gatewayGroupArn: String? = nil, name: String? = nil, softwareVersion: String? = nil) {
            self.arn = arn
            self.description = description
            self.gatewayGroupArn = gatewayGroupArn
            self.name = name
            self.softwareVersion = softwareVersion
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case description = "Description"
            case gatewayGroupArn = "GatewayGroupArn"
            case name = "Name"
            case softwareVersion = "SoftwareVersion"
        }
    }

    public struct GetAddressBookRequest: AWSEncodableShape {
        /// The ARN of the address book for which to request details.
        public let addressBookArn: String

        public init(addressBookArn: String) {
            self.addressBookArn = addressBookArn
        }

        public func validate(name: String) throws {
            try self.validate(self.addressBookArn, name: "addressBookArn", parent: name, pattern: "arn:[a-z0-9-\\.]{1,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[^/].{0,1023}")
        }

        private enum CodingKeys: String, CodingKey {
            case addressBookArn = "AddressBookArn"
        }
    }

    public struct GetAddressBookResponse: AWSDecodableShape {
        /// The details of the requested address book.
        public let addressBook: AddressBook?

        public init(addressBook: AddressBook? = nil) {
            self.addressBook = addressBook
        }

        private enum CodingKeys: String, CodingKey {
            case addressBook = "AddressBook"
        }
    }

    public struct GetConferencePreferenceRequest: AWSEncodableShape {
        public init() {}
    }

    public struct GetConferencePreferenceResponse: AWSDecodableShape {
        /// The conference preference.
        public let preference: ConferencePreference?

        public init(preference: ConferencePreference? = nil) {
            self.preference = preference
        }

        private enum CodingKeys: String, CodingKey {
            case preference = "Preference"
        }
    }

    public struct GetConferenceProviderRequest: AWSEncodableShape {
        /// The ARN of the newly created conference provider.
        public let conferenceProviderArn: String

        public init(conferenceProviderArn: String) {
            self.conferenceProviderArn = conferenceProviderArn
        }

        public func validate(name: String) throws {
            try self.validate(self.conferenceProviderArn, name: "conferenceProviderArn", parent: name, pattern: "arn:[a-z0-9-\\.]{1,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[^/].{0,1023}")
        }

        private enum CodingKeys: String, CodingKey {
            case conferenceProviderArn = "ConferenceProviderArn"
        }
    }

    public struct GetConferenceProviderResponse: AWSDecodableShape {
        /// The conference provider.
        public let conferenceProvider: ConferenceProvider?

        public init(conferenceProvider: ConferenceProvider? = nil) {
            self.conferenceProvider = conferenceProvider
        }

        private enum CodingKeys: String, CodingKey {
            case conferenceProvider = "ConferenceProvider"
        }
    }

    public struct GetContactRequest: AWSEncodableShape {
        /// The ARN of the contact for which to request details.
        public let contactArn: String

        public init(contactArn: String) {
            self.contactArn = contactArn
        }

        public func validate(name: String) throws {
            try self.validate(self.contactArn, name: "contactArn", parent: name, pattern: "arn:[a-z0-9-\\.]{1,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[^/].{0,1023}")
        }

        private enum CodingKeys: String, CodingKey {
            case contactArn = "ContactArn"
        }
    }

    public struct GetContactResponse: AWSDecodableShape {
        /// The details of the requested contact.
        public let contact: Contact?

        public init(contact: Contact? = nil) {
            self.contact = contact
        }

        private enum CodingKeys: String, CodingKey {
            case contact = "Contact"
        }
    }

    public struct GetDeviceRequest: AWSEncodableShape {
        /// The ARN of the device for which to request details. Required.
        public let deviceArn: String?

        public init(deviceArn: String? = nil) {
            self.deviceArn = deviceArn
        }

        public func validate(name: String) throws {
            try self.validate(self.deviceArn, name: "deviceArn", parent: name, pattern: "arn:[a-z0-9-\\.]{1,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[^/].{0,1023}")
        }

        private enum CodingKeys: String, CodingKey {
            case deviceArn = "DeviceArn"
        }
    }

    public struct GetDeviceResponse: AWSDecodableShape {
        /// The details of the device requested. Required.
        public let device: Device?

        public init(device: Device? = nil) {
            self.device = device
        }

        private enum CodingKeys: String, CodingKey {
            case device = "Device"
        }
    }

    public struct GetGatewayGroupRequest: AWSEncodableShape {
        /// The ARN of the gateway group to get.
        public let gatewayGroupArn: String

        public init(gatewayGroupArn: String) {
            self.gatewayGroupArn = gatewayGroupArn
        }

        public func validate(name: String) throws {
            try self.validate(self.gatewayGroupArn, name: "gatewayGroupArn", parent: name, pattern: "arn:[a-z0-9-\\.]{1,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[^/].{0,1023}")
        }

        private enum CodingKeys: String, CodingKey {
            case gatewayGroupArn = "GatewayGroupArn"
        }
    }

    public struct GetGatewayGroupResponse: AWSDecodableShape {
        public let gatewayGroup: GatewayGroup?

        public init(gatewayGroup: GatewayGroup? = nil) {
            self.gatewayGroup = gatewayGroup
        }

        private enum CodingKeys: String, CodingKey {
            case gatewayGroup = "GatewayGroup"
        }
    }

    public struct GetGatewayRequest: AWSEncodableShape {
        /// The ARN of the gateway to get.
        public let gatewayArn: String

        public init(gatewayArn: String) {
            self.gatewayArn = gatewayArn
        }

        public func validate(name: String) throws {
            try self.validate(self.gatewayArn, name: "gatewayArn", parent: name, pattern: "arn:[a-z0-9-\\.]{1,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[^/].{0,1023}")
        }

        private enum CodingKeys: String, CodingKey {
            case gatewayArn = "GatewayArn"
        }
    }

    public struct GetGatewayResponse: AWSDecodableShape {
        /// The details of the gateway.
        public let gateway: Gateway?

        public init(gateway: Gateway? = nil) {
            self.gateway = gateway
        }

        private enum CodingKeys: String, CodingKey {
            case gateway = "Gateway"
        }
    }

    public struct GetInvitationConfigurationRequest: AWSEncodableShape {
        public init() {}
    }

    public struct GetInvitationConfigurationResponse: AWSDecodableShape {
        /// The email ID of the organization or individual contact that the enrolled user can use.
        public let contactEmail: String?
        /// The name of the organization sending the enrollment invite to a user.
        public let organizationName: String?
        /// The list of private skill IDs that you want to recommend to the user to enable in the invitation.
        public let privateSkillIds: [String]?

        public init(contactEmail: String? = nil, organizationName: String? = nil, privateSkillIds: [String]? = nil) {
            self.contactEmail = contactEmail
            self.organizationName = organizationName
            self.privateSkillIds = privateSkillIds
        }

        private enum CodingKeys: String, CodingKey {
            case contactEmail = "ContactEmail"
            case organizationName = "OrganizationName"
            case privateSkillIds = "PrivateSkillIds"
        }
    }

    public struct GetNetworkProfileRequest: AWSEncodableShape {
        /// The ARN of the network profile associated with a device.
        public let networkProfileArn: String

        public init(networkProfileArn: String) {
            self.networkProfileArn = networkProfileArn
        }

        public func validate(name: String) throws {
            try self.validate(self.networkProfileArn, name: "networkProfileArn", parent: name, pattern: "arn:[a-z0-9-\\.]{1,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[^/].{0,1023}")
        }

        private enum CodingKeys: String, CodingKey {
            case networkProfileArn = "NetworkProfileArn"
        }
    }

    public struct GetNetworkProfileResponse: AWSDecodableShape {
        /// The network profile associated with a device.
        public let networkProfile: NetworkProfile?

        public init(networkProfile: NetworkProfile? = nil) {
            self.networkProfile = networkProfile
        }

        private enum CodingKeys: String, CodingKey {
            case networkProfile = "NetworkProfile"
        }
    }

    public struct GetProfileRequest: AWSEncodableShape {
        /// The ARN of the room profile for which to request details. Required.
        public let profileArn: String?

        public init(profileArn: String? = nil) {
            self.profileArn = profileArn
        }

        public func validate(name: String) throws {
            try self.validate(self.profileArn, name: "profileArn", parent: name, pattern: "arn:[a-z0-9-\\.]{1,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[^/].{0,1023}")
        }

        private enum CodingKeys: String, CodingKey {
            case profileArn = "ProfileArn"
        }
    }

    public struct GetProfileResponse: AWSDecodableShape {
        /// The details of the room profile requested. Required.
        public let profile: Profile?

        public init(profile: Profile? = nil) {
            self.profile = profile
        }

        private enum CodingKeys: String, CodingKey {
            case profile = "Profile"
        }
    }

    public struct GetRoomRequest: AWSEncodableShape {
        /// The ARN of the room for which to request details. Required.
        public let roomArn: String?

        public init(roomArn: String? = nil) {
            self.roomArn = roomArn
        }

        public func validate(name: String) throws {
            try self.validate(self.roomArn, name: "roomArn", parent: name, pattern: "arn:[a-z0-9-\\.]{1,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[^/].{0,1023}")
        }

        private enum CodingKeys: String, CodingKey {
            case roomArn = "RoomArn"
        }
    }

    public struct GetRoomResponse: AWSDecodableShape {
        /// The details of the room requested.
        public let room: Room?

        public init(room: Room? = nil) {
            self.room = room
        }

        private enum CodingKeys: String, CodingKey {
            case room = "Room"
        }
    }

    public struct GetRoomSkillParameterRequest: AWSEncodableShape {
        /// The room skill parameter key for which to get details. Required.
        public let parameterKey: String
        /// The ARN of the room from which to get the room skill parameter details.
        public let roomArn: String?
        /// The ARN of the skill from which to get the room skill parameter details. Required.
        public let skillId: String

        public init(parameterKey: String, roomArn: String? = nil, skillId: String) {
            self.parameterKey = parameterKey
            self.roomArn = roomArn
            self.skillId = skillId
        }

        public func validate(name: String) throws {
            try self.validate(self.parameterKey, name: "parameterKey", parent: name, max: 256)
            try self.validate(self.parameterKey, name: "parameterKey", parent: name, min: 1)
            try self.validate(self.roomArn, name: "roomArn", parent: name, pattern: "arn:[a-z0-9-\\.]{1,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[^/].{0,1023}")
            try self.validate(self.skillId, name: "skillId", parent: name, pattern: "(^amzn1\\.ask\\.skill\\.[0-9a-f\\-]{1,200})|(^amzn1\\.echo-sdk-ams\\.app\\.[0-9a-f\\-]{1,200})")
        }

        private enum CodingKeys: String, CodingKey {
            case parameterKey = "ParameterKey"
            case roomArn = "RoomArn"
            case skillId = "SkillId"
        }
    }

    public struct GetRoomSkillParameterResponse: AWSDecodableShape {
        /// The details of the room skill parameter requested. Required.
        public let roomSkillParameter: RoomSkillParameter?

        public init(roomSkillParameter: RoomSkillParameter? = nil) {
            self.roomSkillParameter = roomSkillParameter
        }

        private enum CodingKeys: String, CodingKey {
            case roomSkillParameter = "RoomSkillParameter"
        }
    }

    public struct GetSkillGroupRequest: AWSEncodableShape {
        /// The ARN of the skill group for which to get details. Required.
        public let skillGroupArn: String?

        public init(skillGroupArn: String? = nil) {
            self.skillGroupArn = skillGroupArn
        }

        public func validate(name: String) throws {
            try self.validate(self.skillGroupArn, name: "skillGroupArn", parent: name, pattern: "arn:[a-z0-9-\\.]{1,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[^/].{0,1023}")
        }

        private enum CodingKeys: String, CodingKey {
            case skillGroupArn = "SkillGroupArn"
        }
    }

    public struct GetSkillGroupResponse: AWSDecodableShape {
        /// The details of the skill group requested. Required.
        public let skillGroup: SkillGroup?

        public init(skillGroup: SkillGroup? = nil) {
            self.skillGroup = skillGroup
        }

        private enum CodingKeys: String, CodingKey {
            case skillGroup = "SkillGroup"
        }
    }

    public struct IPDialIn: AWSEncodableShape & AWSDecodableShape {
        /// The protocol, including SIP, SIPS, and H323.
        public let commsProtocol: CommsProtocol
        /// The IP address.
        public let endpoint: String

        public init(commsProtocol: CommsProtocol, endpoint: String) {
            self.commsProtocol = commsProtocol
            self.endpoint = endpoint
        }

        public func validate(name: String) throws {
            try self.validate(self.endpoint, name: "endpoint", parent: name, max: 256)
            try self.validate(self.endpoint, name: "endpoint", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case commsProtocol = "CommsProtocol"
            case endpoint = "Endpoint"
        }
    }

    public struct InstantBooking: AWSDecodableShape {
        /// Duration between 15 and 240 minutes at increments of 15 that determines how long to book an available room when a meeting is started with Alexa.
        public let durationInMinutes: Int?
        /// Whether instant booking is enabled or not.
        public let enabled: Bool?

        public init(durationInMinutes: Int? = nil, enabled: Bool? = nil) {
            self.durationInMinutes = durationInMinutes
            self.enabled = enabled
        }

        private enum CodingKeys: String, CodingKey {
            case durationInMinutes = "DurationInMinutes"
            case enabled = "Enabled"
        }
    }

    public struct ListBusinessReportSchedulesRequest: AWSEncodableShape {
        /// The maximum number of schedules listed in the call.
        public let maxResults: Int?
        /// The token used to list the remaining schedules from the previous API call.
        public let nextToken: String?

        public init(maxResults: Int? = nil, nextToken: String? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 50)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 1100)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case maxResults = "MaxResults"
            case nextToken = "NextToken"
        }
    }

    public struct ListBusinessReportSchedulesResponse: AWSDecodableShape {
        /// The schedule of the reports.
        public let businessReportSchedules: [BusinessReportSchedule]?
        /// The token used to list the remaining schedules from the previous API call.
        public let nextToken: String?

        public init(businessReportSchedules: [BusinessReportSchedule]? = nil, nextToken: String? = nil) {
            self.businessReportSchedules = businessReportSchedules
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case businessReportSchedules = "BusinessReportSchedules"
            case nextToken = "NextToken"
        }
    }

    public struct ListConferenceProvidersRequest: AWSEncodableShape {
        /// The maximum number of conference providers to be returned, per paginated calls.
        public let maxResults: Int?
        /// The tokens used for pagination.
        public let nextToken: String?

        public init(maxResults: Int? = nil, nextToken: String? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 50)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 1100)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case maxResults = "MaxResults"
            case nextToken = "NextToken"
        }
    }

    public struct ListConferenceProvidersResponse: AWSDecodableShape {
        /// The conference providers.
        public let conferenceProviders: [ConferenceProvider]?
        /// The tokens used for pagination.
        public let nextToken: String?

        public init(conferenceProviders: [ConferenceProvider]? = nil, nextToken: String? = nil) {
            self.conferenceProviders = conferenceProviders
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case conferenceProviders = "ConferenceProviders"
            case nextToken = "NextToken"
        }
    }

    public struct ListDeviceEventsRequest: AWSEncodableShape {
        /// The ARN of a device.
        public let deviceArn: String
        /// The event type to filter device events. If EventType isn't specified, this returns a list of all device events in reverse chronological order. If EventType is specified, this returns a list of device events for that EventType in reverse chronological order.
        public let eventType: DeviceEventType?
        /// The maximum number of results to include in the response. The default value is 50. If more results exist than the specified MaxResults value, a token is included in the response so that the remaining results can be retrieved.
        public let maxResults: Int?
        /// An optional token returned from a prior request. Use this token for pagination of results from this action. If this parameter is specified, the response only includes results beyond the token, up to the value specified by MaxResults. When the end of results is reached, the response has a value of null.
        public let nextToken: String?

        public init(deviceArn: String, eventType: DeviceEventType? = nil, maxResults: Int? = nil, nextToken: String? = nil) {
            self.deviceArn = deviceArn
            self.eventType = eventType
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.validate(self.deviceArn, name: "deviceArn", parent: name, pattern: "arn:[a-z0-9-\\.]{1,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[^/].{0,1023}")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 50)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 1100)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case deviceArn = "DeviceArn"
            case eventType = "EventType"
            case maxResults = "MaxResults"
            case nextToken = "NextToken"
        }
    }

    public struct ListDeviceEventsResponse: AWSDecodableShape {
        /// The device events requested for the device ARN.
        public let deviceEvents: [DeviceEvent]?
        /// The token returned to indicate that there is more data available.
        public let nextToken: String?

        public init(deviceEvents: [DeviceEvent]? = nil, nextToken: String? = nil) {
            self.deviceEvents = deviceEvents
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case deviceEvents = "DeviceEvents"
            case nextToken = "NextToken"
        }
    }

    public struct ListGatewayGroupsRequest: AWSEncodableShape {
        /// The maximum number of gateway group summaries to return. The default is 50.
        public let maxResults: Int?
        /// The token used to paginate though multiple pages of gateway group summaries.
        public let nextToken: String?

        public init(maxResults: Int? = nil, nextToken: String? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 50)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 1100)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case maxResults = "MaxResults"
            case nextToken = "NextToken"
        }
    }

    public struct ListGatewayGroupsResponse: AWSDecodableShape {
        /// The gateway groups in the list.
        public let gatewayGroups: [GatewayGroupSummary]?
        /// The token used to paginate though multiple pages of gateway group summaries.
        public let nextToken: String?

        public init(gatewayGroups: [GatewayGroupSummary]? = nil, nextToken: String? = nil) {
            self.gatewayGroups = gatewayGroups
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case gatewayGroups = "GatewayGroups"
            case nextToken = "NextToken"
        }
    }

    public struct ListGatewaysRequest: AWSEncodableShape {
        /// The gateway group ARN for which to list gateways.
        public let gatewayGroupArn: String?
        /// The maximum number of gateway summaries to return. The default is 50.
        public let maxResults: Int?
        /// The token used to paginate though multiple pages of gateway summaries.
        public let nextToken: String?

        public init(gatewayGroupArn: String? = nil, maxResults: Int? = nil, nextToken: String? = nil) {
            self.gatewayGroupArn = gatewayGroupArn
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.validate(self.gatewayGroupArn, name: "gatewayGroupArn", parent: name, pattern: "arn:[a-z0-9-\\.]{1,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[^/].{0,1023}")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 50)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 1100)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case gatewayGroupArn = "GatewayGroupArn"
            case maxResults = "MaxResults"
            case nextToken = "NextToken"
        }
    }

    public struct ListGatewaysResponse: AWSDecodableShape {
        /// The gateways in the list.
        public let gateways: [GatewaySummary]?
        /// The token used to paginate though multiple pages of gateway summaries.
        public let nextToken: String?

        public init(gateways: [GatewaySummary]? = nil, nextToken: String? = nil) {
            self.gateways = gateways
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case gateways = "Gateways"
            case nextToken = "NextToken"
        }
    }

    public struct ListSkillsRequest: AWSEncodableShape {
        /// Whether the skill is enabled under the user's account.
        public let enablementType: EnablementTypeFilter?
        /// The maximum number of results to include in the response. If more results exist than the specified MaxResults value, a token is included in the response so that the remaining results can be retrieved.
        public let maxResults: Int?
        /// An optional token returned from a prior request. Use this token for pagination of results from this action. If this parameter is specified, the response includes only results beyond the token, up to the value specified by MaxResults.
        public let nextToken: String?
        /// The ARN of the skill group for which to list enabled skills.
        public let skillGroupArn: String?
        /// Whether the skill is publicly available or is a private skill.
        public let skillType: SkillTypeFilter?

        public init(enablementType: EnablementTypeFilter? = nil, maxResults: Int? = nil, nextToken: String? = nil, skillGroupArn: String? = nil, skillType: SkillTypeFilter? = nil) {
            self.enablementType = enablementType
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.skillGroupArn = skillGroupArn
            self.skillType = skillType
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 10)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 1100)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.skillGroupArn, name: "skillGroupArn", parent: name, pattern: "arn:[a-z0-9-\\.]{1,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[^/].{0,1023}")
        }

        private enum CodingKeys: String, CodingKey {
            case enablementType = "EnablementType"
            case maxResults = "MaxResults"
            case nextToken = "NextToken"
            case skillGroupArn = "SkillGroupArn"
            case skillType = "SkillType"
        }
    }

    public struct ListSkillsResponse: AWSDecodableShape {
        /// The token returned to indicate that there is more data available.
        public let nextToken: String?
        /// The list of enabled skills requested. Required.
        public let skillSummaries: [SkillSummary]?

        public init(nextToken: String? = nil, skillSummaries: [SkillSummary]? = nil) {
            self.nextToken = nextToken
            self.skillSummaries = skillSummaries
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "NextToken"
            case skillSummaries = "SkillSummaries"
        }
    }

    public struct ListSkillsStoreCategoriesRequest: AWSEncodableShape {
        /// The maximum number of categories returned, per paginated calls.
        public let maxResults: Int?
        /// The tokens used for pagination.
        public let nextToken: String?

        public init(maxResults: Int? = nil, nextToken: String? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 50)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 1100)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case maxResults = "MaxResults"
            case nextToken = "NextToken"
        }
    }

    public struct ListSkillsStoreCategoriesResponse: AWSDecodableShape {
        /// The list of categories.
        public let categoryList: [Category]?
        /// The tokens used for pagination.
        public let nextToken: String?

        public init(categoryList: [Category]? = nil, nextToken: String? = nil) {
            self.categoryList = categoryList
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case categoryList = "CategoryList"
            case nextToken = "NextToken"
        }
    }

    public struct ListSkillsStoreSkillsByCategoryRequest: AWSEncodableShape {
        /// The category ID for which the skills are being retrieved from the skill store.
        public let categoryId: Int64
        /// The maximum number of skills returned per paginated calls.
        public let maxResults: Int?
        /// The tokens used for pagination.
        public let nextToken: String?

        public init(categoryId: Int64, maxResults: Int? = nil, nextToken: String? = nil) {
            self.categoryId = categoryId
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.validate(self.categoryId, name: "categoryId", parent: name, min: 1)
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 10)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 1100)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case categoryId = "CategoryId"
            case maxResults = "MaxResults"
            case nextToken = "NextToken"
        }
    }

    public struct ListSkillsStoreSkillsByCategoryResponse: AWSDecodableShape {
        /// The tokens used for pagination.
        public let nextToken: String?
        /// The skill store skills.
        public let skillsStoreSkills: [SkillsStoreSkill]?

        public init(nextToken: String? = nil, skillsStoreSkills: [SkillsStoreSkill]? = nil) {
            self.nextToken = nextToken
            self.skillsStoreSkills = skillsStoreSkills
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "NextToken"
            case skillsStoreSkills = "SkillsStoreSkills"
        }
    }

    public struct ListSmartHomeAppliancesRequest: AWSEncodableShape {
        /// The maximum number of appliances to be returned, per paginated calls.
        public let maxResults: Int?
        /// The tokens used for pagination.
        public let nextToken: String?
        /// The room that the appliances are associated with.
        public let roomArn: String

        public init(maxResults: Int? = nil, nextToken: String? = nil, roomArn: String) {
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.roomArn = roomArn
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 50)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 1100)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.roomArn, name: "roomArn", parent: name, pattern: "arn:[a-z0-9-\\.]{1,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[^/].{0,1023}")
        }

        private enum CodingKeys: String, CodingKey {
            case maxResults = "MaxResults"
            case nextToken = "NextToken"
            case roomArn = "RoomArn"
        }
    }

    public struct ListSmartHomeAppliancesResponse: AWSDecodableShape {
        /// The tokens used for pagination.
        public let nextToken: String?
        /// The smart home appliances.
        public let smartHomeAppliances: [SmartHomeAppliance]?

        public init(nextToken: String? = nil, smartHomeAppliances: [SmartHomeAppliance]? = nil) {
            self.nextToken = nextToken
            self.smartHomeAppliances = smartHomeAppliances
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "NextToken"
            case smartHomeAppliances = "SmartHomeAppliances"
        }
    }

    public struct ListTagsRequest: AWSEncodableShape {
        /// The ARN of the specified resource for which to list tags.
        public let arn: String
        /// The maximum number of results to include in the response. If more results exist than the specified MaxResults value, a token is included in the response so that the remaining results can be retrieved.
        public let maxResults: Int?
        /// An optional token returned from a prior request. Use this token for pagination of results from this action. If this parameter is specified, the response includes only results beyond the token, up to the value specified by MaxResults.
        public let nextToken: String?

        public init(arn: String, maxResults: Int? = nil, nextToken: String? = nil) {
            self.arn = arn
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.validate(self.arn, name: "arn", parent: name, pattern: "arn:[a-z0-9-\\.]{1,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[^/].{0,1023}")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 50)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 1100)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case maxResults = "MaxResults"
            case nextToken = "NextToken"
        }
    }

    public struct ListTagsResponse: AWSDecodableShape {
        /// The token returned to indicate that there is more data available.
        public let nextToken: String?
        /// The tags requested for the specified resource.
        public let tags: [Tag]?

        public init(nextToken: String? = nil, tags: [Tag]? = nil) {
            self.nextToken = nextToken
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "NextToken"
            case tags = "Tags"
        }
    }

    public struct MeetingRoomConfiguration: AWSDecodableShape {
        /// Settings for the end of meeting reminder feature that are applied to a room profile. The end of meeting reminder enables Alexa to remind users when a meeting is ending.
        public let endOfMeetingReminder: EndOfMeetingReminder?
        /// Settings to automatically book the room if available for a configured duration when joining a meeting with Alexa.
        public let instantBooking: InstantBooking?
        /// Settings for requiring a check in when a room is reserved. Alexa can cancel a room reservation if it's not checked into. This makes the room available for others. Users can check in by joining the meeting with Alexa or an AVS device, or by saying Alexa, check in.
        public let requireCheckIn: RequireCheckIn?
        /// Whether room utilization metrics are enabled or not.
        public let roomUtilizationMetricsEnabled: Bool?

        public init(endOfMeetingReminder: EndOfMeetingReminder? = nil, instantBooking: InstantBooking? = nil, requireCheckIn: RequireCheckIn? = nil, roomUtilizationMetricsEnabled: Bool? = nil) {
            self.endOfMeetingReminder = endOfMeetingReminder
            self.instantBooking = instantBooking
            self.requireCheckIn = requireCheckIn
            self.roomUtilizationMetricsEnabled = roomUtilizationMetricsEnabled
        }

        private enum CodingKeys: String, CodingKey {
            case endOfMeetingReminder = "EndOfMeetingReminder"
            case instantBooking = "InstantBooking"
            case requireCheckIn = "RequireCheckIn"
            case roomUtilizationMetricsEnabled = "RoomUtilizationMetricsEnabled"
        }
    }

    public struct MeetingSetting: AWSEncodableShape & AWSDecodableShape {
        /// The values that indicate whether the pin is always required.
        public let requirePin: RequirePin

        public init(requirePin: RequirePin) {
            self.requirePin = requirePin
        }

        private enum CodingKeys: String, CodingKey {
            case requirePin = "RequirePin"
        }
    }

    public struct NetworkProfile: AWSDecodableShape {
        /// The ARN of the Private Certificate Authority (PCA) created in AWS Certificate Manager (ACM). This is used to issue certificates to the devices.
        public let certificateAuthorityArn: String?
        /// The current password of the Wi-Fi network.
        public let currentPassword: String?
        /// Detailed information about a device's network profile.
        public let description: String?
        /// The authentication standard that is used in the EAP framework. Currently, EAP_TLS is supported.
        public let eapMethod: NetworkEapMethod?
        /// The ARN of the network profile associated with a device.
        public let networkProfileArn: String?
        /// The name of the network profile associated with a device.
        public let networkProfileName: String?
        /// The next, or subsequent, password of the Wi-Fi network. This password is asynchronously transmitted to the device and is used when the password of the network changes to NextPassword.
        public let nextPassword: String?
        /// The security type of the Wi-Fi network. This can be WPA2_ENTERPRISE, WPA2_PSK, WPA_PSK, WEP, or OPEN.
        public let securityType: NetworkSecurityType?
        /// The SSID of the Wi-Fi network.
        public let ssid: String?
        /// The root certificates of your authentication server, which is installed on your devices and used to trust your authentication server during EAP negotiation.
        public let trustAnchors: [String]?

        public init(certificateAuthorityArn: String? = nil, currentPassword: String? = nil, description: String? = nil, eapMethod: NetworkEapMethod? = nil, networkProfileArn: String? = nil, networkProfileName: String? = nil, nextPassword: String? = nil, securityType: NetworkSecurityType? = nil, ssid: String? = nil, trustAnchors: [String]? = nil) {
            self.certificateAuthorityArn = certificateAuthorityArn
            self.currentPassword = currentPassword
            self.description = description
            self.eapMethod = eapMethod
            self.networkProfileArn = networkProfileArn
            self.networkProfileName = networkProfileName
            self.nextPassword = nextPassword
            self.securityType = securityType
            self.ssid = ssid
            self.trustAnchors = trustAnchors
        }

        private enum CodingKeys: String, CodingKey {
            case certificateAuthorityArn = "CertificateAuthorityArn"
            case currentPassword = "CurrentPassword"
            case description = "Description"
            case eapMethod = "EapMethod"
            case networkProfileArn = "NetworkProfileArn"
            case networkProfileName = "NetworkProfileName"
            case nextPassword = "NextPassword"
            case securityType = "SecurityType"
            case ssid = "Ssid"
            case trustAnchors = "TrustAnchors"
        }
    }

    public struct NetworkProfileData: AWSDecodableShape {
        /// The ARN of the Private Certificate Authority (PCA) created in AWS Certificate Manager (ACM). This is used to issue certificates to the devices.
        public let certificateAuthorityArn: String?
        /// Detailed information about a device's network profile.
        public let description: String?
        /// The authentication standard that is used in the EAP framework. Currently, EAP_TLS is supported.
        public let eapMethod: NetworkEapMethod?
        /// The ARN of the network profile associated with a device.
        public let networkProfileArn: String?
        /// The name of the network profile associated with a device.
        public let networkProfileName: String?
        /// The security type of the Wi-Fi network. This can be WPA2_ENTERPRISE, WPA2_PSK, WPA_PSK, WEP, or OPEN.
        public let securityType: NetworkSecurityType?
        /// The SSID of the Wi-Fi network.
        public let ssid: String?

        public init(certificateAuthorityArn: String? = nil, description: String? = nil, eapMethod: NetworkEapMethod? = nil, networkProfileArn: String? = nil, networkProfileName: String? = nil, securityType: NetworkSecurityType? = nil, ssid: String? = nil) {
            self.certificateAuthorityArn = certificateAuthorityArn
            self.description = description
            self.eapMethod = eapMethod
            self.networkProfileArn = networkProfileArn
            self.networkProfileName = networkProfileName
            self.securityType = securityType
            self.ssid = ssid
        }

        private enum CodingKeys: String, CodingKey {
            case certificateAuthorityArn = "CertificateAuthorityArn"
            case description = "Description"
            case eapMethod = "EapMethod"
            case networkProfileArn = "NetworkProfileArn"
            case networkProfileName = "NetworkProfileName"
            case securityType = "SecurityType"
            case ssid = "Ssid"
        }
    }

    public struct PSTNDialIn: AWSEncodableShape & AWSDecodableShape {
        /// The zip code.
        public let countryCode: String
        /// The delay duration before Alexa enters the conference ID with dual-tone multi-frequency (DTMF). Each number on the dial pad corresponds to a DTMF tone, which is how we send data over the telephone network.
        public let oneClickIdDelay: String
        /// The delay duration before Alexa enters the conference pin with dual-tone multi-frequency (DTMF). Each number on the dial pad corresponds to a DTMF tone, which is how we send data over the telephone network.
        public let oneClickPinDelay: String
        /// The phone number to call to join the conference.
        public let phoneNumber: String

        public init(countryCode: String, oneClickIdDelay: String, oneClickPinDelay: String, phoneNumber: String) {
            self.countryCode = countryCode
            self.oneClickIdDelay = oneClickIdDelay
            self.oneClickPinDelay = oneClickPinDelay
            self.phoneNumber = phoneNumber
        }

        public func validate(name: String) throws {
            try self.validate(self.countryCode, name: "countryCode", parent: name, pattern: "\\d{1,3}")
            try self.validate(self.oneClickIdDelay, name: "oneClickIdDelay", parent: name, max: 2)
            try self.validate(self.oneClickIdDelay, name: "oneClickIdDelay", parent: name, min: 1)
            try self.validate(self.oneClickPinDelay, name: "oneClickPinDelay", parent: name, max: 2)
            try self.validate(self.oneClickPinDelay, name: "oneClickPinDelay", parent: name, min: 1)
            try self.validate(self.phoneNumber, name: "phoneNumber", parent: name, pattern: "\\d{10}")
        }

        private enum CodingKeys: String, CodingKey {
            case countryCode = "CountryCode"
            case oneClickIdDelay = "OneClickIdDelay"
            case oneClickPinDelay = "OneClickPinDelay"
            case phoneNumber = "PhoneNumber"
        }
    }

    public struct PhoneNumber: AWSEncodableShape & AWSDecodableShape {
        /// The raw value of the phone number.
        public let number: String
        /// The type of the phone number.
        public let type: PhoneNumberType

        public init(number: String, type: PhoneNumberType) {
            self.number = number
            self.type = type
        }

        public func validate(name: String) throws {
            try self.validate(self.number, name: "number", parent: name, max: 50)
            try self.validate(self.number, name: "number", parent: name, min: 0)
            try self.validate(self.number, name: "number", parent: name, pattern: "^[\\+0-9\\#\\,\\(][\\+0-9\\-\\.\\/\\(\\)\\,\\#\\s]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case number = "Number"
            case type = "Type"
        }
    }

    public struct Profile: AWSDecodableShape {
        /// The address of a room profile.
        public let address: String?
        /// The ARN of the address book.
        public let addressBookArn: String?
        /// Whether data retention of the profile is enabled.
        public let dataRetentionOptIn: Bool?
        /// The distance unit of a room profile.
        public let distanceUnit: DistanceUnit?
        /// Retrieves if the profile is default or not.
        public let isDefault: Bool?
        /// The locale of a room profile. (This is currently available only to a limited preview audience.)
        public let locale: String?
        /// The max volume limit of a room profile.
        public let maxVolumeLimit: Int?
        /// Meeting room settings of a room profile.
        public let meetingRoomConfiguration: MeetingRoomConfiguration?
        /// The ARN of a room profile.
        public let profileArn: String?
        /// The name of a room profile.
        public let profileName: String?
        /// The PSTN setting of a room profile.
        public let pSTNEnabled: Bool?
        /// The setup mode of a room profile.
        public let setupModeDisabled: Bool?
        /// The temperature unit of a room profile.
        public let temperatureUnit: TemperatureUnit?
        /// The time zone of a room profile.
        public let timezone: String?
        /// The wake word of a room profile.
        public let wakeWord: WakeWord?

        public init(address: String? = nil, addressBookArn: String? = nil, dataRetentionOptIn: Bool? = nil, distanceUnit: DistanceUnit? = nil, isDefault: Bool? = nil, locale: String? = nil, maxVolumeLimit: Int? = nil, meetingRoomConfiguration: MeetingRoomConfiguration? = nil, profileArn: String? = nil, profileName: String? = nil, pSTNEnabled: Bool? = nil, setupModeDisabled: Bool? = nil, temperatureUnit: TemperatureUnit? = nil, timezone: String? = nil, wakeWord: WakeWord? = nil) {
            self.address = address
            self.addressBookArn = addressBookArn
            self.dataRetentionOptIn = dataRetentionOptIn
            self.distanceUnit = distanceUnit
            self.isDefault = isDefault
            self.locale = locale
            self.maxVolumeLimit = maxVolumeLimit
            self.meetingRoomConfiguration = meetingRoomConfiguration
            self.profileArn = profileArn
            self.profileName = profileName
            self.pSTNEnabled = pSTNEnabled
            self.setupModeDisabled = setupModeDisabled
            self.temperatureUnit = temperatureUnit
            self.timezone = timezone
            self.wakeWord = wakeWord
        }

        private enum CodingKeys: String, CodingKey {
            case address = "Address"
            case addressBookArn = "AddressBookArn"
            case dataRetentionOptIn = "DataRetentionOptIn"
            case distanceUnit = "DistanceUnit"
            case isDefault = "IsDefault"
            case locale = "Locale"
            case maxVolumeLimit = "MaxVolumeLimit"
            case meetingRoomConfiguration = "MeetingRoomConfiguration"
            case profileArn = "ProfileArn"
            case profileName = "ProfileName"
            case pSTNEnabled = "PSTNEnabled"
            case setupModeDisabled = "SetupModeDisabled"
            case temperatureUnit = "TemperatureUnit"
            case timezone = "Timezone"
            case wakeWord = "WakeWord"
        }
    }

    public struct ProfileData: AWSDecodableShape {
        /// The address of a room profile.
        public let address: String?
        /// The distance unit of a room profile.
        public let distanceUnit: DistanceUnit?
        /// Retrieves if the profile data is default or not.
        public let isDefault: Bool?
        /// The locale of a room profile. (This is currently available only to a limited preview audience.)
        public let locale: String?
        /// The ARN of a room profile.
        public let profileArn: String?
        /// The name of a room profile.
        public let profileName: String?
        /// The temperature unit of a room profile.
        public let temperatureUnit: TemperatureUnit?
        /// The time zone of a room profile.
        public let timezone: String?
        /// The wake word of a room profile.
        public let wakeWord: WakeWord?

        public init(address: String? = nil, distanceUnit: DistanceUnit? = nil, isDefault: Bool? = nil, locale: String? = nil, profileArn: String? = nil, profileName: String? = nil, temperatureUnit: TemperatureUnit? = nil, timezone: String? = nil, wakeWord: WakeWord? = nil) {
            self.address = address
            self.distanceUnit = distanceUnit
            self.isDefault = isDefault
            self.locale = locale
            self.profileArn = profileArn
            self.profileName = profileName
            self.temperatureUnit = temperatureUnit
            self.timezone = timezone
            self.wakeWord = wakeWord
        }

        private enum CodingKeys: String, CodingKey {
            case address = "Address"
            case distanceUnit = "DistanceUnit"
            case isDefault = "IsDefault"
            case locale = "Locale"
            case profileArn = "ProfileArn"
            case profileName = "ProfileName"
            case temperatureUnit = "TemperatureUnit"
            case timezone = "Timezone"
            case wakeWord = "WakeWord"
        }
    }

    public struct PutConferencePreferenceRequest: AWSEncodableShape {
        /// The conference preference of a specific conference provider.
        public let conferencePreference: ConferencePreference

        public init(conferencePreference: ConferencePreference) {
            self.conferencePreference = conferencePreference
        }

        public func validate(name: String) throws {
            try self.conferencePreference.validate(name: "\(name).conferencePreference")
        }

        private enum CodingKeys: String, CodingKey {
            case conferencePreference = "ConferencePreference"
        }
    }

    public struct PutConferencePreferenceResponse: AWSDecodableShape {
        public init() {}
    }

    public struct PutInvitationConfigurationRequest: AWSEncodableShape {
        /// The email ID of the organization or individual contact that the enrolled user can use.
        public let contactEmail: String?
        /// The name of the organization sending the enrollment invite to a user.
        public let organizationName: String
        /// The list of private skill IDs that you want to recommend to the user to enable in the invitation.
        public let privateSkillIds: [String]?

        public init(contactEmail: String? = nil, organizationName: String, privateSkillIds: [String]? = nil) {
            self.contactEmail = contactEmail
            self.organizationName = organizationName
            self.privateSkillIds = privateSkillIds
        }

        public func validate(name: String) throws {
            try self.validate(self.contactEmail, name: "contactEmail", parent: name, max: 128)
            try self.validate(self.contactEmail, name: "contactEmail", parent: name, min: 1)
            try self.validate(self.contactEmail, name: "contactEmail", parent: name, pattern: "([0-9a-zA-Z]([+-.\\w]*[0-9a-zA-Z])*@([0-9a-zA-Z]([-\\w]*[0-9a-zA-Z]+)*\\.)+[a-zA-Z]{2,9})")
            try self.validate(self.organizationName, name: "organizationName", parent: name, max: 100)
            try self.validate(self.organizationName, name: "organizationName", parent: name, min: 1)
            try self.validate(self.organizationName, name: "organizationName", parent: name, pattern: "[\\u0009\\u000A\\u000D\\u0020-\\u007E\\u0085\\u00A0-\\uD7FF\\uE000-\\uFFFD\\u10000-\\u10FFFF]*")
            try self.privateSkillIds?.forEach {
                try validate($0, name: "privateSkillIds[]", parent: name, pattern: "(^amzn1\\.ask\\.skill\\.[0-9a-f\\-]{1,200})|(^amzn1\\.echo-sdk-ams\\.app\\.[0-9a-f\\-]{1,200})")
            }
            try self.validate(self.privateSkillIds, name: "privateSkillIds", parent: name, max: 3)
            try self.validate(self.privateSkillIds, name: "privateSkillIds", parent: name, min: 0)
        }

        private enum CodingKeys: String, CodingKey {
            case contactEmail = "ContactEmail"
            case organizationName = "OrganizationName"
            case privateSkillIds = "PrivateSkillIds"
        }
    }

    public struct PutInvitationConfigurationResponse: AWSDecodableShape {
        public init() {}
    }

    public struct PutRoomSkillParameterRequest: AWSEncodableShape {
        /// The ARN of the room associated with the room skill parameter. Required.
        public let roomArn: String?
        /// The updated room skill parameter. Required.
        public let roomSkillParameter: RoomSkillParameter
        /// The ARN of the skill associated with the room skill parameter. Required.
        public let skillId: String

        public init(roomArn: String? = nil, roomSkillParameter: RoomSkillParameter, skillId: String) {
            self.roomArn = roomArn
            self.roomSkillParameter = roomSkillParameter
            self.skillId = skillId
        }

        public func validate(name: String) throws {
            try self.validate(self.roomArn, name: "roomArn", parent: name, pattern: "arn:[a-z0-9-\\.]{1,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[^/].{0,1023}")
            try self.roomSkillParameter.validate(name: "\(name).roomSkillParameter")
            try self.validate(self.skillId, name: "skillId", parent: name, pattern: "(^amzn1\\.ask\\.skill\\.[0-9a-f\\-]{1,200})|(^amzn1\\.echo-sdk-ams\\.app\\.[0-9a-f\\-]{1,200})")
        }

        private enum CodingKeys: String, CodingKey {
            case roomArn = "RoomArn"
            case roomSkillParameter = "RoomSkillParameter"
            case skillId = "SkillId"
        }
    }

    public struct PutRoomSkillParameterResponse: AWSDecodableShape {
        public init() {}
    }

    public struct PutSkillAuthorizationRequest: AWSEncodableShape {
        /// The authorization result specific to OAUTH code grant output. "Code must be populated in the AuthorizationResult map to establish the authorization.
        public let authorizationResult: [String: String]
        /// The room that the skill is authorized for.
        public let roomArn: String?
        /// The unique identifier of a skill.
        public let skillId: String

        public init(authorizationResult: [String: String], roomArn: String? = nil, skillId: String) {
            self.authorizationResult = authorizationResult
            self.roomArn = roomArn
            self.skillId = skillId
        }

        public func validate(name: String) throws {
            try self.authorizationResult.forEach {
                try validate($0.key, name: "authorizationResult.key", parent: name, min: 1)
                try validate($0.value, name: "authorizationResult[\"\($0.key)\"]", parent: name, min: 1)
            }
            try self.validate(self.roomArn, name: "roomArn", parent: name, pattern: "arn:[a-z0-9-\\.]{1,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[^/].{0,1023}")
            try self.validate(self.skillId, name: "skillId", parent: name, pattern: "(^amzn1\\.ask\\.skill\\.[0-9a-f\\-]{1,200})|(^amzn1\\.echo-sdk-ams\\.app\\.[0-9a-f\\-]{1,200})")
        }

        private enum CodingKeys: String, CodingKey {
            case authorizationResult = "AuthorizationResult"
            case roomArn = "RoomArn"
            case skillId = "SkillId"
        }
    }

    public struct PutSkillAuthorizationResponse: AWSDecodableShape {
        public init() {}
    }

    public struct RegisterAVSDeviceRequest: AWSEncodableShape {
        /// The device type ID for your AVS device generated by Amazon when the OEM creates a new product on Amazon's Developer Console.
        public let amazonId: String
        /// The client ID of the OEM used for code-based linking authorization on an AVS device.
        public let clientId: String
        /// The key generated by the OEM that uniquely identifies a specified instance of your AVS device.
        public let deviceSerialNumber: String?
        /// The product ID used to identify your AVS device during authorization.
        public let productId: String
        /// The Amazon Resource Name (ARN) of the room with which to associate your AVS device.
        public let roomArn: String?
        /// The tags to be added to the specified resource. Do not provide system tags.
        public let tags: [Tag]?
        /// The code that is obtained after your AVS device has made a POST request to LWA as a part of the Device Authorization Request component of the OAuth code-based linking specification.
        public let userCode: String

        public init(amazonId: String, clientId: String, deviceSerialNumber: String? = nil, productId: String, roomArn: String? = nil, tags: [Tag]? = nil, userCode: String) {
            self.amazonId = amazonId
            self.clientId = clientId
            self.deviceSerialNumber = deviceSerialNumber
            self.productId = productId
            self.roomArn = roomArn
            self.tags = tags
            self.userCode = userCode
        }

        public func validate(name: String) throws {
            try self.validate(self.amazonId, name: "amazonId", parent: name, pattern: "[a-zA-Z0-9]{1,18}")
            try self.validate(self.clientId, name: "clientId", parent: name, pattern: "^\\S+{1,256}$")
            try self.validate(self.deviceSerialNumber, name: "deviceSerialNumber", parent: name, pattern: "^[a-zA-Z0-9]{1,50}$")
            try self.validate(self.productId, name: "productId", parent: name, pattern: "^[a-zA-Z0-9_]{1,256}$")
            try self.validate(self.roomArn, name: "roomArn", parent: name, pattern: "arn:[a-z0-9-\\.]{1,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[^/].{0,1023}")
            try self.tags?.forEach {
                try $0.validate(name: "\(name).tags[]")
            }
            try self.validate(self.userCode, name: "userCode", parent: name, max: 128)
            try self.validate(self.userCode, name: "userCode", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case amazonId = "AmazonId"
            case clientId = "ClientId"
            case deviceSerialNumber = "DeviceSerialNumber"
            case productId = "ProductId"
            case roomArn = "RoomArn"
            case tags = "Tags"
            case userCode = "UserCode"
        }
    }

    public struct RegisterAVSDeviceResponse: AWSDecodableShape {
        /// The ARN of the device.
        public let deviceArn: String?

        public init(deviceArn: String? = nil) {
            self.deviceArn = deviceArn
        }

        private enum CodingKeys: String, CodingKey {
            case deviceArn = "DeviceArn"
        }
    }

    public struct RejectSkillRequest: AWSEncodableShape {
        /// The unique identifier of the skill.
        public let skillId: String

        public init(skillId: String) {
            self.skillId = skillId
        }

        public func validate(name: String) throws {
            try self.validate(self.skillId, name: "skillId", parent: name, pattern: "(^amzn1\\.ask\\.skill\\.[0-9a-f\\-]{1,200})|(^amzn1\\.echo-sdk-ams\\.app\\.[0-9a-f\\-]{1,200})")
        }

        private enum CodingKeys: String, CodingKey {
            case skillId = "SkillId"
        }
    }

    public struct RejectSkillResponse: AWSDecodableShape {
        public init() {}
    }

    public struct RequireCheckIn: AWSDecodableShape {
        /// Whether require check in is enabled or not.
        public let enabled: Bool?
        /// Duration between 5 and 20 minutes to determine when to release the room if it's not checked into.
        public let releaseAfterMinutes: Int?

        public init(enabled: Bool? = nil, releaseAfterMinutes: Int? = nil) {
            self.enabled = enabled
            self.releaseAfterMinutes = releaseAfterMinutes
        }

        private enum CodingKeys: String, CodingKey {
            case enabled = "Enabled"
            case releaseAfterMinutes = "ReleaseAfterMinutes"
        }
    }

    public struct ResolveRoomRequest: AWSEncodableShape {
        /// The ARN of the skill that was requested. Required.
        public let skillId: String
        /// The ARN of the user. Required.
        public let userId: String

        public init(skillId: String, userId: String) {
            self.skillId = skillId
            self.userId = userId
        }

        public func validate(name: String) throws {
            try self.validate(self.skillId, name: "skillId", parent: name, pattern: "(^amzn1\\.ask\\.skill\\.[0-9a-f\\-]{1,200})|(^amzn1\\.echo-sdk-ams\\.app\\.[0-9a-f\\-]{1,200})")
            try self.validate(self.userId, name: "userId", parent: name, pattern: "amzn1\\.[A-Za-z0-9+-\\/=.]{1,300}")
        }

        private enum CodingKeys: String, CodingKey {
            case skillId = "SkillId"
            case userId = "UserId"
        }
    }

    public struct ResolveRoomResponse: AWSDecodableShape {
        /// The ARN of the room from which the skill request was invoked.
        public let roomArn: String?
        /// The name of the room from which the skill request was invoked.
        public let roomName: String?
        /// Response to get the room profile request. Required.
        public let roomSkillParameters: [RoomSkillParameter]?

        public init(roomArn: String? = nil, roomName: String? = nil, roomSkillParameters: [RoomSkillParameter]? = nil) {
            self.roomArn = roomArn
            self.roomName = roomName
            self.roomSkillParameters = roomSkillParameters
        }

        private enum CodingKeys: String, CodingKey {
            case roomArn = "RoomArn"
            case roomName = "RoomName"
            case roomSkillParameters = "RoomSkillParameters"
        }
    }

    public struct RevokeInvitationRequest: AWSEncodableShape {
        /// The ARN of the enrollment invitation to revoke. Required.
        public let enrollmentId: String?
        /// The ARN of the user for whom to revoke an enrollment invitation. Required.
        public let userArn: String?

        public init(enrollmentId: String? = nil, userArn: String? = nil) {
            self.enrollmentId = enrollmentId
            self.userArn = userArn
        }

        public func validate(name: String) throws {
            try self.validate(self.enrollmentId, name: "enrollmentId", parent: name, max: 128)
            try self.validate(self.enrollmentId, name: "enrollmentId", parent: name, min: 0)
            try self.validate(self.userArn, name: "userArn", parent: name, pattern: "arn:[a-z0-9-\\.]{1,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[^/].{0,1023}")
        }

        private enum CodingKeys: String, CodingKey {
            case enrollmentId = "EnrollmentId"
            case userArn = "UserArn"
        }
    }

    public struct RevokeInvitationResponse: AWSDecodableShape {
        public init() {}
    }

    public struct Room: AWSDecodableShape {
        /// The description of a room.
        public let description: String?
        /// The profile ARN of a room.
        public let profileArn: String?
        /// The provider calendar ARN of a room.
        public let providerCalendarId: String?
        /// The ARN of a room.
        public let roomArn: String?
        /// The name of a room.
        public let roomName: String?

        public init(description: String? = nil, profileArn: String? = nil, providerCalendarId: String? = nil, roomArn: String? = nil, roomName: String? = nil) {
            self.description = description
            self.profileArn = profileArn
            self.providerCalendarId = providerCalendarId
            self.roomArn = roomArn
            self.roomName = roomName
        }

        private enum CodingKeys: String, CodingKey {
            case description = "Description"
            case profileArn = "ProfileArn"
            case providerCalendarId = "ProviderCalendarId"
            case roomArn = "RoomArn"
            case roomName = "RoomName"
        }
    }

    public struct RoomData: AWSDecodableShape {
        /// The description of a room.
        public let description: String?
        /// The profile ARN of a room.
        public let profileArn: String?
        /// The profile name of a room.
        public let profileName: String?
        /// The provider calendar ARN of a room.
        public let providerCalendarId: String?
        /// The ARN of a room.
        public let roomArn: String?
        /// The name of a room.
        public let roomName: String?

        public init(description: String? = nil, profileArn: String? = nil, profileName: String? = nil, providerCalendarId: String? = nil, roomArn: String? = nil, roomName: String? = nil) {
            self.description = description
            self.profileArn = profileArn
            self.profileName = profileName
            self.providerCalendarId = providerCalendarId
            self.roomArn = roomArn
            self.roomName = roomName
        }

        private enum CodingKeys: String, CodingKey {
            case description = "Description"
            case profileArn = "ProfileArn"
            case profileName = "ProfileName"
            case providerCalendarId = "ProviderCalendarId"
            case roomArn = "RoomArn"
            case roomName = "RoomName"
        }
    }

    public struct RoomSkillParameter: AWSEncodableShape & AWSDecodableShape {
        /// The parameter key of a room skill parameter. ParameterKey is an enumerated type that only takes DEFAULT or SCOPE as valid values.
        public let parameterKey: String
        /// The parameter value of a room skill parameter.
        public let parameterValue: String

        public init(parameterKey: String, parameterValue: String) {
            self.parameterKey = parameterKey
            self.parameterValue = parameterValue
        }

        public func validate(name: String) throws {
            try self.validate(self.parameterKey, name: "parameterKey", parent: name, max: 256)
            try self.validate(self.parameterKey, name: "parameterKey", parent: name, min: 1)
            try self.validate(self.parameterValue, name: "parameterValue", parent: name, max: 512)
            try self.validate(self.parameterValue, name: "parameterValue", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case parameterKey = "ParameterKey"
            case parameterValue = "ParameterValue"
        }
    }

    public struct SearchAddressBooksRequest: AWSEncodableShape {
        /// The filters to use to list a specified set of address books. The supported filter key is AddressBookName.
        public let filters: [Filter]?
        /// The maximum number of results to include in the response. If more results exist than the specified MaxResults value, a token is included in the response so that the remaining results can be retrieved.
        public let maxResults: Int?
        /// An optional token returned from a prior request. Use this token for pagination of results from this action. If this parameter is specified, the response only includes results beyond the token, up to the value specified by MaxResults.
        public let nextToken: String?
        /// The sort order to use in listing the specified set of address books. The supported sort key is AddressBookName.
        public let sortCriteria: [Sort]?

        public init(filters: [Filter]? = nil, maxResults: Int? = nil, nextToken: String? = nil, sortCriteria: [Sort]? = nil) {
            self.filters = filters
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.sortCriteria = sortCriteria
        }

        public func validate(name: String) throws {
            try self.filters?.forEach {
                try $0.validate(name: "\(name).filters[]")
            }
            try self.validate(self.filters, name: "filters", parent: name, max: 25)
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 50)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 1100)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.sortCriteria?.forEach {
                try $0.validate(name: "\(name).sortCriteria[]")
            }
            try self.validate(self.sortCriteria, name: "sortCriteria", parent: name, max: 25)
        }

        private enum CodingKeys: String, CodingKey {
            case filters = "Filters"
            case maxResults = "MaxResults"
            case nextToken = "NextToken"
            case sortCriteria = "SortCriteria"
        }
    }

    public struct SearchAddressBooksResponse: AWSDecodableShape {
        /// The address books that meet the specified set of filter criteria, in sort order.
        public let addressBooks: [AddressBookData]?
        /// The token returned to indicate that there is more data available.
        public let nextToken: String?
        /// The total number of address books returned.
        public let totalCount: Int?

        public init(addressBooks: [AddressBookData]? = nil, nextToken: String? = nil, totalCount: Int? = nil) {
            self.addressBooks = addressBooks
            self.nextToken = nextToken
            self.totalCount = totalCount
        }

        private enum CodingKeys: String, CodingKey {
            case addressBooks = "AddressBooks"
            case nextToken = "NextToken"
            case totalCount = "TotalCount"
        }
    }

    public struct SearchContactsRequest: AWSEncodableShape {
        /// The filters to use to list a specified set of address books. The supported filter keys are DisplayName, FirstName, LastName, and AddressBookArns.
        public let filters: [Filter]?
        /// The maximum number of results to include in the response. If more results exist than the specified MaxResults value, a token is included in the response so that the remaining results can be retrieved.
        public let maxResults: Int?
        /// An optional token returned from a prior request. Use this token for pagination of results from this action. If this parameter is specified, the response only includes results beyond the token, up to the value specified by MaxResults.
        public let nextToken: String?
        /// The sort order to use in listing the specified set of contacts. The supported sort keys are DisplayName, FirstName, and LastName.
        public let sortCriteria: [Sort]?

        public init(filters: [Filter]? = nil, maxResults: Int? = nil, nextToken: String? = nil, sortCriteria: [Sort]? = nil) {
            self.filters = filters
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.sortCriteria = sortCriteria
        }

        public func validate(name: String) throws {
            try self.filters?.forEach {
                try $0.validate(name: "\(name).filters[]")
            }
            try self.validate(self.filters, name: "filters", parent: name, max: 25)
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 50)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 1100)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.sortCriteria?.forEach {
                try $0.validate(name: "\(name).sortCriteria[]")
            }
            try self.validate(self.sortCriteria, name: "sortCriteria", parent: name, max: 25)
        }

        private enum CodingKeys: String, CodingKey {
            case filters = "Filters"
            case maxResults = "MaxResults"
            case nextToken = "NextToken"
            case sortCriteria = "SortCriteria"
        }
    }

    public struct SearchContactsResponse: AWSDecodableShape {
        /// The contacts that meet the specified set of filter criteria, in sort order.
        public let contacts: [ContactData]?
        /// The token returned to indicate that there is more data available.
        public let nextToken: String?
        /// The total number of contacts returned.
        public let totalCount: Int?

        public init(contacts: [ContactData]? = nil, nextToken: String? = nil, totalCount: Int? = nil) {
            self.contacts = contacts
            self.nextToken = nextToken
            self.totalCount = totalCount
        }

        private enum CodingKeys: String, CodingKey {
            case contacts = "Contacts"
            case nextToken = "NextToken"
            case totalCount = "TotalCount"
        }
    }

    public struct SearchDevicesRequest: AWSEncodableShape {
        /// The filters to use to list a specified set of devices. Supported filter keys are DeviceName, DeviceStatus, DeviceStatusDetailCode, RoomName, DeviceType, DeviceSerialNumber, UnassociatedOnly, ConnectionStatus (ONLINE and OFFLINE), NetworkProfileName, NetworkProfileArn, Feature, and FailureCode.
        public let filters: [Filter]?
        /// The maximum number of results to include in the response. If more results exist than the specified MaxResults value, a token is included in the response so that the remaining results can be retrieved.
        public let maxResults: Int?
        /// An optional token returned from a prior request. Use this token for pagination of results from this action. If this parameter is specified, the response includes only results beyond the token, up to the value specified by MaxResults.
        public let nextToken: String?
        /// The sort order to use in listing the specified set of devices. Supported sort keys are DeviceName, DeviceStatus, RoomName, DeviceType, DeviceSerialNumber, ConnectionStatus, NetworkProfileName, NetworkProfileArn, Feature, and FailureCode.
        public let sortCriteria: [Sort]?

        public init(filters: [Filter]? = nil, maxResults: Int? = nil, nextToken: String? = nil, sortCriteria: [Sort]? = nil) {
            self.filters = filters
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.sortCriteria = sortCriteria
        }

        public func validate(name: String) throws {
            try self.filters?.forEach {
                try $0.validate(name: "\(name).filters[]")
            }
            try self.validate(self.filters, name: "filters", parent: name, max: 25)
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 50)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 1100)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.sortCriteria?.forEach {
                try $0.validate(name: "\(name).sortCriteria[]")
            }
            try self.validate(self.sortCriteria, name: "sortCriteria", parent: name, max: 25)
        }

        private enum CodingKeys: String, CodingKey {
            case filters = "Filters"
            case maxResults = "MaxResults"
            case nextToken = "NextToken"
            case sortCriteria = "SortCriteria"
        }
    }

    public struct SearchDevicesResponse: AWSDecodableShape {
        /// The devices that meet the specified set of filter criteria, in sort order.
        public let devices: [DeviceData]?
        /// The token returned to indicate that there is more data available.
        public let nextToken: String?
        /// The total number of devices returned.
        public let totalCount: Int?

        public init(devices: [DeviceData]? = nil, nextToken: String? = nil, totalCount: Int? = nil) {
            self.devices = devices
            self.nextToken = nextToken
            self.totalCount = totalCount
        }

        private enum CodingKeys: String, CodingKey {
            case devices = "Devices"
            case nextToken = "NextToken"
            case totalCount = "TotalCount"
        }
    }

    public struct SearchNetworkProfilesRequest: AWSEncodableShape {
        /// The filters to use to list a specified set of network profiles. Valid filters are NetworkProfileName, Ssid, and SecurityType.
        public let filters: [Filter]?
        /// The maximum number of results to include in the response. If more results exist than the specified MaxResults value, a token is included in the response so that the remaining results can be retrieved.
        public let maxResults: Int?
        /// An optional token returned from a prior request. Use this token for pagination of results from this action. If this parameter is specified, the response includes only results beyond the token, up to the value specified by MaxResults.
        public let nextToken: String?
        /// The sort order to use to list the specified set of network profiles. Valid sort criteria includes NetworkProfileName, Ssid, and SecurityType.
        public let sortCriteria: [Sort]?

        public init(filters: [Filter]? = nil, maxResults: Int? = nil, nextToken: String? = nil, sortCriteria: [Sort]? = nil) {
            self.filters = filters
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.sortCriteria = sortCriteria
        }

        public func validate(name: String) throws {
            try self.filters?.forEach {
                try $0.validate(name: "\(name).filters[]")
            }
            try self.validate(self.filters, name: "filters", parent: name, max: 25)
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 50)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 1100)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.sortCriteria?.forEach {
                try $0.validate(name: "\(name).sortCriteria[]")
            }
            try self.validate(self.sortCriteria, name: "sortCriteria", parent: name, max: 25)
        }

        private enum CodingKeys: String, CodingKey {
            case filters = "Filters"
            case maxResults = "MaxResults"
            case nextToken = "NextToken"
            case sortCriteria = "SortCriteria"
        }
    }

    public struct SearchNetworkProfilesResponse: AWSDecodableShape {
        /// The network profiles that meet the specified set of filter criteria, in sort order. It is a list of NetworkProfileData objects.
        public let networkProfiles: [NetworkProfileData]?
        /// An optional token returned from a prior request. Use this token for pagination of results from this action. If this parameter is specified, the response includes only results beyond the token, up to the value specified by MaxResults.
        public let nextToken: String?
        /// The total number of network profiles returned.
        public let totalCount: Int?

        public init(networkProfiles: [NetworkProfileData]? = nil, nextToken: String? = nil, totalCount: Int? = nil) {
            self.networkProfiles = networkProfiles
            self.nextToken = nextToken
            self.totalCount = totalCount
        }

        private enum CodingKeys: String, CodingKey {
            case networkProfiles = "NetworkProfiles"
            case nextToken = "NextToken"
            case totalCount = "TotalCount"
        }
    }

    public struct SearchProfilesRequest: AWSEncodableShape {
        /// The filters to use to list a specified set of room profiles. Supported filter keys are ProfileName and Address. Required.
        public let filters: [Filter]?
        /// The maximum number of results to include in the response. If more results exist than the specified MaxResults value, a token is included in the response so that the remaining results can be retrieved.
        public let maxResults: Int?
        /// An optional token returned from a prior request. Use this token for pagination of results from this action. If this parameter is specified, the response includes only results beyond the token, up to the value specified by MaxResults.
        public let nextToken: String?
        /// The sort order to use in listing the specified set of room profiles. Supported sort keys are ProfileName and Address.
        public let sortCriteria: [Sort]?

        public init(filters: [Filter]? = nil, maxResults: Int? = nil, nextToken: String? = nil, sortCriteria: [Sort]? = nil) {
            self.filters = filters
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.sortCriteria = sortCriteria
        }

        public func validate(name: String) throws {
            try self.filters?.forEach {
                try $0.validate(name: "\(name).filters[]")
            }
            try self.validate(self.filters, name: "filters", parent: name, max: 25)
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 50)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 1100)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.sortCriteria?.forEach {
                try $0.validate(name: "\(name).sortCriteria[]")
            }
            try self.validate(self.sortCriteria, name: "sortCriteria", parent: name, max: 25)
        }

        private enum CodingKeys: String, CodingKey {
            case filters = "Filters"
            case maxResults = "MaxResults"
            case nextToken = "NextToken"
            case sortCriteria = "SortCriteria"
        }
    }

    public struct SearchProfilesResponse: AWSDecodableShape {
        /// The token returned to indicate that there is more data available.
        public let nextToken: String?
        /// The profiles that meet the specified set of filter criteria, in sort order.
        public let profiles: [ProfileData]?
        /// The total number of room profiles returned.
        public let totalCount: Int?

        public init(nextToken: String? = nil, profiles: [ProfileData]? = nil, totalCount: Int? = nil) {
            self.nextToken = nextToken
            self.profiles = profiles
            self.totalCount = totalCount
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "NextToken"
            case profiles = "Profiles"
            case totalCount = "TotalCount"
        }
    }

    public struct SearchRoomsRequest: AWSEncodableShape {
        /// The filters to use to list a specified set of rooms. The supported filter keys are RoomName and ProfileName.
        public let filters: [Filter]?
        /// The maximum number of results to include in the response. If more results exist than the specified MaxResults value, a token is included in the response so that the remaining results can be retrieved.
        public let maxResults: Int?
        /// An optional token returned from a prior request. Use this token for pagination of results from this action. If this parameter is specified, the response includes only results beyond the token, up to the value specified by MaxResults.
        public let nextToken: String?
        /// The sort order to use in listing the specified set of rooms. The supported sort keys are RoomName and ProfileName.
        public let sortCriteria: [Sort]?

        public init(filters: [Filter]? = nil, maxResults: Int? = nil, nextToken: String? = nil, sortCriteria: [Sort]? = nil) {
            self.filters = filters
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.sortCriteria = sortCriteria
        }

        public func validate(name: String) throws {
            try self.filters?.forEach {
                try $0.validate(name: "\(name).filters[]")
            }
            try self.validate(self.filters, name: "filters", parent: name, max: 25)
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 50)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 1100)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.sortCriteria?.forEach {
                try $0.validate(name: "\(name).sortCriteria[]")
            }
            try self.validate(self.sortCriteria, name: "sortCriteria", parent: name, max: 25)
        }

        private enum CodingKeys: String, CodingKey {
            case filters = "Filters"
            case maxResults = "MaxResults"
            case nextToken = "NextToken"
            case sortCriteria = "SortCriteria"
        }
    }

    public struct SearchRoomsResponse: AWSDecodableShape {
        /// The token returned to indicate that there is more data available.
        public let nextToken: String?
        /// The rooms that meet the specified set of filter criteria, in sort order.
        public let rooms: [RoomData]?
        /// The total number of rooms returned.
        public let totalCount: Int?

        public init(nextToken: String? = nil, rooms: [RoomData]? = nil, totalCount: Int? = nil) {
            self.nextToken = nextToken
            self.rooms = rooms
            self.totalCount = totalCount
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "NextToken"
            case rooms = "Rooms"
            case totalCount = "TotalCount"
        }
    }

    public struct SearchSkillGroupsRequest: AWSEncodableShape {
        /// The filters to use to list a specified set of skill groups. The supported filter key is SkillGroupName.
        public let filters: [Filter]?
        /// The maximum number of results to include in the response. If more results exist than the specified MaxResults value, a token is included in the response so that the remaining results can be retrieved.
        public let maxResults: Int?
        /// An optional token returned from a prior request. Use this token for pagination of results from this action. If this parameter is specified, the response includes only results beyond the token, up to the value specified by MaxResults. Required.
        public let nextToken: String?
        /// The sort order to use in listing the specified set of skill groups. The supported sort key is SkillGroupName.
        public let sortCriteria: [Sort]?

        public init(filters: [Filter]? = nil, maxResults: Int? = nil, nextToken: String? = nil, sortCriteria: [Sort]? = nil) {
            self.filters = filters
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.sortCriteria = sortCriteria
        }

        public func validate(name: String) throws {
            try self.filters?.forEach {
                try $0.validate(name: "\(name).filters[]")
            }
            try self.validate(self.filters, name: "filters", parent: name, max: 25)
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 50)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 1100)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.sortCriteria?.forEach {
                try $0.validate(name: "\(name).sortCriteria[]")
            }
            try self.validate(self.sortCriteria, name: "sortCriteria", parent: name, max: 25)
        }

        private enum CodingKeys: String, CodingKey {
            case filters = "Filters"
            case maxResults = "MaxResults"
            case nextToken = "NextToken"
            case sortCriteria = "SortCriteria"
        }
    }

    public struct SearchSkillGroupsResponse: AWSDecodableShape {
        /// The token returned to indicate that there is more data available.
        public let nextToken: String?
        /// The skill groups that meet the filter criteria, in sort order.
        public let skillGroups: [SkillGroupData]?
        /// The total number of skill groups returned.
        public let totalCount: Int?

        public init(nextToken: String? = nil, skillGroups: [SkillGroupData]? = nil, totalCount: Int? = nil) {
            self.nextToken = nextToken
            self.skillGroups = skillGroups
            self.totalCount = totalCount
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "NextToken"
            case skillGroups = "SkillGroups"
            case totalCount = "TotalCount"
        }
    }

    public struct SearchUsersRequest: AWSEncodableShape {
        /// The filters to use for listing a specific set of users. Required. Supported filter keys are UserId, FirstName, LastName, Email, and EnrollmentStatus.
        public let filters: [Filter]?
        /// The maximum number of results to include in the response. If more results exist than the specified MaxResults value, a token is included in the response so that the remaining results can be retrieved. Required.
        public let maxResults: Int?
        /// An optional token returned from a prior request. Use this token for pagination of results from this action. If this parameter is specified, the response includes only results beyond the token, up to the value specified by MaxResults. Required.
        public let nextToken: String?
        /// The sort order to use in listing the filtered set of users. Required. Supported sort keys are UserId, FirstName, LastName, Email, and EnrollmentStatus.
        public let sortCriteria: [Sort]?

        public init(filters: [Filter]? = nil, maxResults: Int? = nil, nextToken: String? = nil, sortCriteria: [Sort]? = nil) {
            self.filters = filters
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.sortCriteria = sortCriteria
        }

        public func validate(name: String) throws {
            try self.filters?.forEach {
                try $0.validate(name: "\(name).filters[]")
            }
            try self.validate(self.filters, name: "filters", parent: name, max: 25)
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 50)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 1100)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.sortCriteria?.forEach {
                try $0.validate(name: "\(name).sortCriteria[]")
            }
            try self.validate(self.sortCriteria, name: "sortCriteria", parent: name, max: 25)
        }

        private enum CodingKeys: String, CodingKey {
            case filters = "Filters"
            case maxResults = "MaxResults"
            case nextToken = "NextToken"
            case sortCriteria = "SortCriteria"
        }
    }

    public struct SearchUsersResponse: AWSDecodableShape {
        /// The token returned to indicate that there is more data available.
        public let nextToken: String?
        /// The total number of users returned.
        public let totalCount: Int?
        /// The users that meet the specified set of filter criteria, in sort order.
        public let users: [UserData]?

        public init(nextToken: String? = nil, totalCount: Int? = nil, users: [UserData]? = nil) {
            self.nextToken = nextToken
            self.totalCount = totalCount
            self.users = users
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "NextToken"
            case totalCount = "TotalCount"
            case users = "Users"
        }
    }

    public struct SendAnnouncementRequest: AWSEncodableShape {
        /// The unique, user-specified identifier for the request that ensures idempotency.
        public let clientRequestToken: String
        /// The announcement content. This can contain only one of the three possible announcement types (text, SSML or audio).
        public let content: Content
        /// The filters to use to send an announcement to a specified list of rooms. The supported filter keys are RoomName, ProfileName, RoomArn, and ProfileArn. To send to all rooms, specify an empty RoomFilters list.
        public let roomFilters: [Filter]
        /// The time to live for an announcement. Default is 300. If delivery doesn't occur within this time, the announcement is not delivered.
        public let timeToLiveInSeconds: Int?

        public init(clientRequestToken: String = SendAnnouncementRequest.idempotencyToken(), content: Content, roomFilters: [Filter], timeToLiveInSeconds: Int? = nil) {
            self.clientRequestToken = clientRequestToken
            self.content = content
            self.roomFilters = roomFilters
            self.timeToLiveInSeconds = timeToLiveInSeconds
        }

        public func validate(name: String) throws {
            try self.validate(self.clientRequestToken, name: "clientRequestToken", parent: name, max: 150)
            try self.validate(self.clientRequestToken, name: "clientRequestToken", parent: name, min: 10)
            try self.validate(self.clientRequestToken, name: "clientRequestToken", parent: name, pattern: "[a-zA-Z0-9][a-zA-Z0-9_-]*")
            try self.content.validate(name: "\(name).content")
            try self.roomFilters.forEach {
                try $0.validate(name: "\(name).roomFilters[]")
            }
            try self.validate(self.roomFilters, name: "roomFilters", parent: name, max: 25)
            try self.validate(self.timeToLiveInSeconds, name: "timeToLiveInSeconds", parent: name, max: 3600)
            try self.validate(self.timeToLiveInSeconds, name: "timeToLiveInSeconds", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case clientRequestToken = "ClientRequestToken"
            case content = "Content"
            case roomFilters = "RoomFilters"
            case timeToLiveInSeconds = "TimeToLiveInSeconds"
        }
    }

    public struct SendAnnouncementResponse: AWSDecodableShape {
        /// The identifier of the announcement.
        public let announcementArn: String?

        public init(announcementArn: String? = nil) {
            self.announcementArn = announcementArn
        }

        private enum CodingKeys: String, CodingKey {
            case announcementArn = "AnnouncementArn"
        }
    }

    public struct SendInvitationRequest: AWSEncodableShape {
        /// The ARN of the user to whom to send an invitation. Required.
        public let userArn: String?

        public init(userArn: String? = nil) {
            self.userArn = userArn
        }

        public func validate(name: String) throws {
            try self.validate(self.userArn, name: "userArn", parent: name, pattern: "arn:[a-z0-9-\\.]{1,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[^/].{0,1023}")
        }

        private enum CodingKeys: String, CodingKey {
            case userArn = "UserArn"
        }
    }

    public struct SendInvitationResponse: AWSDecodableShape {
        public init() {}
    }

    public struct SipAddress: AWSEncodableShape & AWSDecodableShape {
        /// The type of the SIP address.
        public let type: SipType
        /// The URI for the SIP address.
        public let uri: String

        public init(type: SipType, uri: String) {
            self.type = type
            self.uri = uri
        }

        public func validate(name: String) throws {
            try self.validate(self.uri, name: "uri", parent: name, max: 256)
            try self.validate(self.uri, name: "uri", parent: name, min: 1)
            try self.validate(self.uri, name: "uri", parent: name, pattern: "^sip[s]?:([^@:]+)\\@([^@]+)$")
        }

        private enum CodingKeys: String, CodingKey {
            case type = "Type"
            case uri = "Uri"
        }
    }

    public struct SkillDetails: AWSDecodableShape {
        /// The details about what the skill supports organized as bullet points.
        public let bulletPoints: [String]?
        /// The details about the developer that published the skill.
        public let developerInfo: DeveloperInfo?
        /// The URL of the end user license agreement.
        public let endUserLicenseAgreement: String?
        /// The generic keywords associated with the skill that can be used to find a skill.
        public let genericKeywords: [String]?
        /// The phrase used to trigger the skill.
        public let invocationPhrase: String?
        /// The updates added in bullet points.
        public let newInThisVersionBulletPoints: [String]?
        /// The description of the product.
        public let productDescription: String?
        /// The date when the skill was released.
        public let releaseDate: String?
        ///  This member has been deprecated.  The list of reviews for the skill, including Key and Value pair.
        public let reviews: [String: String]?
        /// The types of skills.
        public let skillTypes: [String]?

        public init(bulletPoints: [String]? = nil, developerInfo: DeveloperInfo? = nil, endUserLicenseAgreement: String? = nil, genericKeywords: [String]? = nil, invocationPhrase: String? = nil, newInThisVersionBulletPoints: [String]? = nil, productDescription: String? = nil, releaseDate: String? = nil, reviews: [String: String]? = nil, skillTypes: [String]? = nil) {
            self.bulletPoints = bulletPoints
            self.developerInfo = developerInfo
            self.endUserLicenseAgreement = endUserLicenseAgreement
            self.genericKeywords = genericKeywords
            self.invocationPhrase = invocationPhrase
            self.newInThisVersionBulletPoints = newInThisVersionBulletPoints
            self.productDescription = productDescription
            self.releaseDate = releaseDate
            self.reviews = reviews
            self.skillTypes = skillTypes
        }

        private enum CodingKeys: String, CodingKey {
            case bulletPoints = "BulletPoints"
            case developerInfo = "DeveloperInfo"
            case endUserLicenseAgreement = "EndUserLicenseAgreement"
            case genericKeywords = "GenericKeywords"
            case invocationPhrase = "InvocationPhrase"
            case newInThisVersionBulletPoints = "NewInThisVersionBulletPoints"
            case productDescription = "ProductDescription"
            case releaseDate = "ReleaseDate"
            case reviews = "Reviews"
            case skillTypes = "SkillTypes"
        }
    }

    public struct SkillGroup: AWSDecodableShape {
        /// The description of a skill group.
        public let description: String?
        /// The ARN of a skill group.
        public let skillGroupArn: String?
        /// The name of a skill group.
        public let skillGroupName: String?

        public init(description: String? = nil, skillGroupArn: String? = nil, skillGroupName: String? = nil) {
            self.description = description
            self.skillGroupArn = skillGroupArn
            self.skillGroupName = skillGroupName
        }

        private enum CodingKeys: String, CodingKey {
            case description = "Description"
            case skillGroupArn = "SkillGroupArn"
            case skillGroupName = "SkillGroupName"
        }
    }

    public struct SkillGroupData: AWSDecodableShape {
        /// The description of a skill group.
        public let description: String?
        /// The skill group ARN of a skill group.
        public let skillGroupArn: String?
        /// The skill group name of a skill group.
        public let skillGroupName: String?

        public init(description: String? = nil, skillGroupArn: String? = nil, skillGroupName: String? = nil) {
            self.description = description
            self.skillGroupArn = skillGroupArn
            self.skillGroupName = skillGroupName
        }

        private enum CodingKeys: String, CodingKey {
            case description = "Description"
            case skillGroupArn = "SkillGroupArn"
            case skillGroupName = "SkillGroupName"
        }
    }

    public struct SkillSummary: AWSDecodableShape {
        /// Whether the skill is enabled under the user's account, or if it requires linking to be used.
        public let enablementType: EnablementType?
        /// The ARN of the skill summary.
        public let skillId: String?
        /// The name of the skill.
        public let skillName: String?
        /// Whether the skill is publicly available or is a private skill.
        public let skillType: SkillType?
        /// Linking support for a skill.
        public let supportsLinking: Bool?

        public init(enablementType: EnablementType? = nil, skillId: String? = nil, skillName: String? = nil, skillType: SkillType? = nil, supportsLinking: Bool? = nil) {
            self.enablementType = enablementType
            self.skillId = skillId
            self.skillName = skillName
            self.skillType = skillType
            self.supportsLinking = supportsLinking
        }

        private enum CodingKeys: String, CodingKey {
            case enablementType = "EnablementType"
            case skillId = "SkillId"
            case skillName = "SkillName"
            case skillType = "SkillType"
            case supportsLinking = "SupportsLinking"
        }
    }

    public struct SkillsStoreSkill: AWSDecodableShape {
        /// The URL where the skill icon resides.
        public let iconUrl: String?
        /// Sample utterances that interact with the skill.
        public let sampleUtterances: [String]?
        /// Short description about the skill.
        public let shortDescription: String?
        /// Information about the skill.
        public let skillDetails: SkillDetails?
        /// The ARN of the skill.
        public let skillId: String?
        /// The name of the skill.
        public let skillName: String?
        /// Linking support for a skill.
        public let supportsLinking: Bool?

        public init(iconUrl: String? = nil, sampleUtterances: [String]? = nil, shortDescription: String? = nil, skillDetails: SkillDetails? = nil, skillId: String? = nil, skillName: String? = nil, supportsLinking: Bool? = nil) {
            self.iconUrl = iconUrl
            self.sampleUtterances = sampleUtterances
            self.shortDescription = shortDescription
            self.skillDetails = skillDetails
            self.skillId = skillId
            self.skillName = skillName
            self.supportsLinking = supportsLinking
        }

        private enum CodingKeys: String, CodingKey {
            case iconUrl = "IconUrl"
            case sampleUtterances = "SampleUtterances"
            case shortDescription = "ShortDescription"
            case skillDetails = "SkillDetails"
            case skillId = "SkillId"
            case skillName = "SkillName"
            case supportsLinking = "SupportsLinking"
        }
    }

    public struct SmartHomeAppliance: AWSDecodableShape {
        /// The description of the smart home appliance.
        public let description: String?
        /// The friendly name of the smart home appliance.
        public let friendlyName: String?
        /// The name of the manufacturer of the smart home appliance.
        public let manufacturerName: String?

        public init(description: String? = nil, friendlyName: String? = nil, manufacturerName: String? = nil) {
            self.description = description
            self.friendlyName = friendlyName
            self.manufacturerName = manufacturerName
        }

        private enum CodingKeys: String, CodingKey {
            case description = "Description"
            case friendlyName = "FriendlyName"
            case manufacturerName = "ManufacturerName"
        }
    }

    public struct Sort: AWSEncodableShape {
        /// The sort key of a sort object.
        public let key: String
        /// The sort value of a sort object.
        public let value: SortValue

        public init(key: String, value: SortValue) {
            self.key = key
            self.value = value
        }

        public func validate(name: String) throws {
            try self.validate(self.key, name: "key", parent: name, max: 500)
            try self.validate(self.key, name: "key", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case key = "Key"
            case value = "Value"
        }
    }

    public struct Ssml: AWSEncodableShape {
        /// The locale of the SSML message. Currently, en-US is supported.
        public let locale: Locale
        /// The value of the SSML message in the correct SSML format. The audio tag is not supported.
        public let value: String

        public init(locale: Locale, value: String) {
            self.locale = locale
            self.value = value
        }

        public func validate(name: String) throws {
            try self.validate(self.value, name: "value", parent: name, max: 4096)
            try self.validate(self.value, name: "value", parent: name, min: 0)
            try self.validate(self.value, name: "value", parent: name, pattern: "[\\u0009\\u000A\\u000D\\u0020-\\u007E\\u0085\\u00A0-\\uD7FF\\uE000-\\uFFFD\\u10000-\\u10FFFF]*")
        }

        private enum CodingKeys: String, CodingKey {
            case locale = "Locale"
            case value = "Value"
        }
    }

    public struct StartDeviceSyncRequest: AWSEncodableShape {
        /// The ARN of the device to sync. Required.
        public let deviceArn: String?
        /// Request structure to start the device sync. Required.
        public let features: [Feature]
        /// The ARN of the room with which the device to sync is associated. Required.
        public let roomArn: String?

        public init(deviceArn: String? = nil, features: [Feature], roomArn: String? = nil) {
            self.deviceArn = deviceArn
            self.features = features
            self.roomArn = roomArn
        }

        public func validate(name: String) throws {
            try self.validate(self.deviceArn, name: "deviceArn", parent: name, pattern: "arn:[a-z0-9-\\.]{1,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[^/].{0,1023}")
            try self.validate(self.roomArn, name: "roomArn", parent: name, pattern: "arn:[a-z0-9-\\.]{1,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[^/].{0,1023}")
        }

        private enum CodingKeys: String, CodingKey {
            case deviceArn = "DeviceArn"
            case features = "Features"
            case roomArn = "RoomArn"
        }
    }

    public struct StartDeviceSyncResponse: AWSDecodableShape {
        public init() {}
    }

    public struct StartSmartHomeApplianceDiscoveryRequest: AWSEncodableShape {
        /// The room where smart home appliance discovery was initiated.
        public let roomArn: String

        public init(roomArn: String) {
            self.roomArn = roomArn
        }

        public func validate(name: String) throws {
            try self.validate(self.roomArn, name: "roomArn", parent: name, pattern: "arn:[a-z0-9-\\.]{1,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[^/].{0,1023}")
        }

        private enum CodingKeys: String, CodingKey {
            case roomArn = "RoomArn"
        }
    }

    public struct StartSmartHomeApplianceDiscoveryResponse: AWSDecodableShape {
        public init() {}
    }

    public struct Tag: AWSEncodableShape & AWSDecodableShape {
        /// The key of a tag. Tag keys are case-sensitive.
        public let key: String
        /// The value of a tag. Tag values are case sensitive and can be null.
        public let value: String

        public init(key: String, value: String) {
            self.key = key
            self.value = value
        }

        public func validate(name: String) throws {
            try self.validate(self.key, name: "key", parent: name, max: 128)
            try self.validate(self.key, name: "key", parent: name, min: 1)
            try self.validate(self.key, name: "key", parent: name, pattern: "^([\\p{L}\\p{Z}\\p{N}_.:/=+\\-@]*)$")
            try self.validate(self.value, name: "value", parent: name, max: 256)
            try self.validate(self.value, name: "value", parent: name, min: 0)
            try self.validate(self.value, name: "value", parent: name, pattern: "^([\\p{L}\\p{Z}\\p{N}_.:/=+\\-@]*)$")
        }

        private enum CodingKeys: String, CodingKey {
            case key = "Key"
            case value = "Value"
        }
    }

    public struct TagResourceRequest: AWSEncodableShape {
        /// The ARN of the resource to which to add metadata tags. Required.
        public let arn: String
        /// The tags to be added to the specified resource. Do not provide system tags. Required.
        public let tags: [Tag]

        public init(arn: String, tags: [Tag]) {
            self.arn = arn
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.validate(self.arn, name: "arn", parent: name, pattern: "arn:[a-z0-9-\\.]{1,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[^/].{0,1023}")
            try self.tags.forEach {
                try $0.validate(name: "\(name).tags[]")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case tags = "Tags"
        }
    }

    public struct TagResourceResponse: AWSDecodableShape {
        public init() {}
    }

    public struct Text: AWSEncodableShape {
        /// The locale of the text message. Currently, en-US is supported.
        public let locale: Locale
        /// The value of the text message.
        public let value: String

        public init(locale: Locale, value: String) {
            self.locale = locale
            self.value = value
        }

        public func validate(name: String) throws {
            try self.validate(self.value, name: "value", parent: name, max: 4096)
            try self.validate(self.value, name: "value", parent: name, min: 0)
            try self.validate(self.value, name: "value", parent: name, pattern: "[\\u0009\\u000A\\u000D\\u0020-\\u007E\\u0085\\u00A0-\\uD7FF\\uE000-\\uFFFD\\u10000-\\u10FFFF]*")
        }

        private enum CodingKeys: String, CodingKey {
            case locale = "Locale"
            case value = "Value"
        }
    }

    public struct UntagResourceRequest: AWSEncodableShape {
        /// The ARN of the resource from which to remove metadata tags. Required.
        public let arn: String
        /// The tags to be removed from the specified resource. Do not provide system tags. Required.
        public let tagKeys: [String]

        public init(arn: String, tagKeys: [String]) {
            self.arn = arn
            self.tagKeys = tagKeys
        }

        public func validate(name: String) throws {
            try self.validate(self.arn, name: "arn", parent: name, pattern: "arn:[a-z0-9-\\.]{1,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[^/].{0,1023}")
            try self.tagKeys.forEach {
                try validate($0, name: "tagKeys[]", parent: name, max: 128)
                try validate($0, name: "tagKeys[]", parent: name, min: 1)
                try validate($0, name: "tagKeys[]", parent: name, pattern: "^([\\p{L}\\p{Z}\\p{N}_.:/=+\\-@]*)$")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case tagKeys = "TagKeys"
        }
    }

    public struct UntagResourceResponse: AWSDecodableShape {
        public init() {}
    }

    public struct UpdateAddressBookRequest: AWSEncodableShape {
        /// The ARN of the room to update.
        public let addressBookArn: String
        /// The updated description of the room.
        public let description: String?
        /// The updated name of the room.
        public let name: String?

        public init(addressBookArn: String, description: String? = nil, name: String? = nil) {
            self.addressBookArn = addressBookArn
            self.description = description
            self.name = name
        }

        public func validate(name: String) throws {
            try self.validate(self.addressBookArn, name: "addressBookArn", parent: name, pattern: "arn:[a-z0-9-\\.]{1,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[^/].{0,1023}")
            try self.validate(self.description, name: "description", parent: name, max: 200)
            try self.validate(self.description, name: "description", parent: name, min: 1)
            try self.validate(self.description, name: "description", parent: name, pattern: "[\\u0009\\u000A\\u000D\\u0020-\\u007E\\u0085\\u00A0-\\uD7FF\\uE000-\\uFFFD\\u10000-\\u10FFFF]*")
            try self.validate(self.name, name: "name", parent: name, max: 100)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "[\\u0009\\u000A\\u000D\\u0020-\\u007E\\u0085\\u00A0-\\uD7FF\\uE000-\\uFFFD\\u10000-\\u10FFFF]*")
        }

        private enum CodingKeys: String, CodingKey {
            case addressBookArn = "AddressBookArn"
            case description = "Description"
            case name = "Name"
        }
    }

    public struct UpdateAddressBookResponse: AWSDecodableShape {
        public init() {}
    }

    public struct UpdateBusinessReportScheduleRequest: AWSEncodableShape {
        /// The format of the generated report (individual CSV files or zipped files of individual files).
        public let format: BusinessReportFormat?
        /// The recurrence of the reports.
        public let recurrence: BusinessReportRecurrence?
        /// The S3 location of the output reports.
        public let s3BucketName: String?
        /// The S3 key where the report is delivered.
        public let s3KeyPrefix: String?
        /// The ARN of the business report schedule.
        public let scheduleArn: String
        /// The name identifier of the schedule.
        public let scheduleName: String?

        public init(format: BusinessReportFormat? = nil, recurrence: BusinessReportRecurrence? = nil, s3BucketName: String? = nil, s3KeyPrefix: String? = nil, scheduleArn: String, scheduleName: String? = nil) {
            self.format = format
            self.recurrence = recurrence
            self.s3BucketName = s3BucketName
            self.s3KeyPrefix = s3KeyPrefix
            self.scheduleArn = scheduleArn
            self.scheduleName = scheduleName
        }

        public func validate(name: String) throws {
            try self.recurrence?.validate(name: "\(name).recurrence")
            try self.validate(self.s3BucketName, name: "s3BucketName", parent: name, pattern: "[a-z0-9-\\.]{3,63}")
            try self.validate(self.s3KeyPrefix, name: "s3KeyPrefix", parent: name, max: 100)
            try self.validate(self.s3KeyPrefix, name: "s3KeyPrefix", parent: name, min: 0)
            try self.validate(self.s3KeyPrefix, name: "s3KeyPrefix", parent: name, pattern: "[A-Za-z0-9!_\\-\\.\\*'()/]*")
            try self.validate(self.scheduleArn, name: "scheduleArn", parent: name, pattern: "arn:[a-z0-9-\\.]{1,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[^/].{0,1023}")
            try self.validate(self.scheduleName, name: "scheduleName", parent: name, max: 64)
            try self.validate(self.scheduleName, name: "scheduleName", parent: name, min: 0)
            try self.validate(self.scheduleName, name: "scheduleName", parent: name, pattern: "[\\u0009\\u000A\\u000D\\u0020-\\u007E\\u0085\\u00A0-\\uD7FF\\uE000-\\uFFFD\\u10000-\\u10FFFF]*")
        }

        private enum CodingKeys: String, CodingKey {
            case format = "Format"
            case recurrence = "Recurrence"
            case s3BucketName = "S3BucketName"
            case s3KeyPrefix = "S3KeyPrefix"
            case scheduleArn = "ScheduleArn"
            case scheduleName = "ScheduleName"
        }
    }

    public struct UpdateBusinessReportScheduleResponse: AWSDecodableShape {
        public init() {}
    }

    public struct UpdateConferenceProviderRequest: AWSEncodableShape {
        /// The ARN of the conference provider.
        public let conferenceProviderArn: String
        /// The type of the conference provider.
        public let conferenceProviderType: ConferenceProviderType
        /// The IP endpoint and protocol for calling.
        public let iPDialIn: IPDialIn?
        /// The meeting settings for the conference provider.
        public let meetingSetting: MeetingSetting
        /// The information for PSTN conferencing.
        public let pSTNDialIn: PSTNDialIn?

        public init(conferenceProviderArn: String, conferenceProviderType: ConferenceProviderType, iPDialIn: IPDialIn? = nil, meetingSetting: MeetingSetting, pSTNDialIn: PSTNDialIn? = nil) {
            self.conferenceProviderArn = conferenceProviderArn
            self.conferenceProviderType = conferenceProviderType
            self.iPDialIn = iPDialIn
            self.meetingSetting = meetingSetting
            self.pSTNDialIn = pSTNDialIn
        }

        public func validate(name: String) throws {
            try self.validate(self.conferenceProviderArn, name: "conferenceProviderArn", parent: name, pattern: "arn:[a-z0-9-\\.]{1,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[^/].{0,1023}")
            try self.iPDialIn?.validate(name: "\(name).iPDialIn")
            try self.pSTNDialIn?.validate(name: "\(name).pSTNDialIn")
        }

        private enum CodingKeys: String, CodingKey {
            case conferenceProviderArn = "ConferenceProviderArn"
            case conferenceProviderType = "ConferenceProviderType"
            case iPDialIn = "IPDialIn"
            case meetingSetting = "MeetingSetting"
            case pSTNDialIn = "PSTNDialIn"
        }
    }

    public struct UpdateConferenceProviderResponse: AWSDecodableShape {
        public init() {}
    }

    public struct UpdateContactRequest: AWSEncodableShape {
        /// The ARN of the contact to update.
        public let contactArn: String
        /// The updated display name of the contact.
        public let displayName: String?
        /// The updated first name of the contact.
        public let firstName: String?
        /// The updated last name of the contact.
        public let lastName: String?
        /// The updated phone number of the contact. The phone number type defaults to WORK. You can either specify PhoneNumber or PhoneNumbers. We recommend that you use PhoneNumbers, which lets you specify the phone number type and multiple numbers.
        public let phoneNumber: String?
        /// The list of phone numbers for the contact.
        public let phoneNumbers: [PhoneNumber]?
        /// The list of SIP addresses for the contact.
        public let sipAddresses: [SipAddress]?

        public init(contactArn: String, displayName: String? = nil, firstName: String? = nil, lastName: String? = nil, phoneNumber: String? = nil, phoneNumbers: [PhoneNumber]? = nil, sipAddresses: [SipAddress]? = nil) {
            self.contactArn = contactArn
            self.displayName = displayName
            self.firstName = firstName
            self.lastName = lastName
            self.phoneNumber = phoneNumber
            self.phoneNumbers = phoneNumbers
            self.sipAddresses = sipAddresses
        }

        public func validate(name: String) throws {
            try self.validate(self.contactArn, name: "contactArn", parent: name, pattern: "arn:[a-z0-9-\\.]{1,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[^/].{0,1023}")
            try self.validate(self.displayName, name: "displayName", parent: name, max: 100)
            try self.validate(self.displayName, name: "displayName", parent: name, min: 1)
            try self.validate(self.displayName, name: "displayName", parent: name, pattern: "[\\u0009\\u000A\\u000D\\u0020-\\u007E\\u0085\\u00A0-\\uD7FF\\uE000-\\uFFFD\\u10000-\\u10FFFF]*")
            try self.validate(self.firstName, name: "firstName", parent: name, max: 100)
            try self.validate(self.firstName, name: "firstName", parent: name, min: 1)
            try self.validate(self.firstName, name: "firstName", parent: name, pattern: "[\\u0009\\u000A\\u000D\\u0020-\\u007E\\u0085\\u00A0-\\uD7FF\\uE000-\\uFFFD\\u10000-\\u10FFFF]*")
            try self.validate(self.lastName, name: "lastName", parent: name, max: 100)
            try self.validate(self.lastName, name: "lastName", parent: name, min: 1)
            try self.validate(self.lastName, name: "lastName", parent: name, pattern: "[\\u0009\\u000A\\u000D\\u0020-\\u007E\\u0085\\u00A0-\\uD7FF\\uE000-\\uFFFD\\u10000-\\u10FFFF]*")
            try self.validate(self.phoneNumber, name: "phoneNumber", parent: name, max: 50)
            try self.validate(self.phoneNumber, name: "phoneNumber", parent: name, min: 0)
            try self.validate(self.phoneNumber, name: "phoneNumber", parent: name, pattern: "^[\\+0-9\\#\\,\\(][\\+0-9\\-\\.\\/\\(\\)\\,\\#\\s]+$")
            try self.phoneNumbers?.forEach {
                try $0.validate(name: "\(name).phoneNumbers[]")
            }
            try self.validate(self.phoneNumbers, name: "phoneNumbers", parent: name, max: 3)
            try self.validate(self.phoneNumbers, name: "phoneNumbers", parent: name, min: 0)
            try self.sipAddresses?.forEach {
                try $0.validate(name: "\(name).sipAddresses[]")
            }
            try self.validate(self.sipAddresses, name: "sipAddresses", parent: name, max: 1)
            try self.validate(self.sipAddresses, name: "sipAddresses", parent: name, min: 0)
        }

        private enum CodingKeys: String, CodingKey {
            case contactArn = "ContactArn"
            case displayName = "DisplayName"
            case firstName = "FirstName"
            case lastName = "LastName"
            case phoneNumber = "PhoneNumber"
            case phoneNumbers = "PhoneNumbers"
            case sipAddresses = "SipAddresses"
        }
    }

    public struct UpdateContactResponse: AWSDecodableShape {
        public init() {}
    }

    public struct UpdateDeviceRequest: AWSEncodableShape {
        /// The ARN of the device to update. Required.
        public let deviceArn: String?
        /// The updated device name. Required.
        public let deviceName: String?

        public init(deviceArn: String? = nil, deviceName: String? = nil) {
            self.deviceArn = deviceArn
            self.deviceName = deviceName
        }

        public func validate(name: String) throws {
            try self.validate(self.deviceArn, name: "deviceArn", parent: name, pattern: "arn:[a-z0-9-\\.]{1,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[^/].{0,1023}")
            try self.validate(self.deviceName, name: "deviceName", parent: name, max: 100)
            try self.validate(self.deviceName, name: "deviceName", parent: name, min: 2)
            try self.validate(self.deviceName, name: "deviceName", parent: name, pattern: "[\\u0009\\u000A\\u000D\\u0020-\\u007E\\u0085\\u00A0-\\uD7FF\\uE000-\\uFFFD\\u10000-\\u10FFFF]*")
        }

        private enum CodingKeys: String, CodingKey {
            case deviceArn = "DeviceArn"
            case deviceName = "DeviceName"
        }
    }

    public struct UpdateDeviceResponse: AWSDecodableShape {
        public init() {}
    }

    public struct UpdateEndOfMeetingReminder: AWSEncodableShape {
        /// Whether an end of meeting reminder is enabled or not.
        public let enabled: Bool?
        /// Updates settings for the end of meeting reminder feature that are applied to a room profile. The end of meeting reminder enables Alexa to remind users when a meeting is ending.
        public let reminderAtMinutes: [Int]?
        /// The type of sound that users hear during the end of meeting reminder.
        public let reminderType: EndOfMeetingReminderType?

        public init(enabled: Bool? = nil, reminderAtMinutes: [Int]? = nil, reminderType: EndOfMeetingReminderType? = nil) {
            self.enabled = enabled
            self.reminderAtMinutes = reminderAtMinutes
            self.reminderType = reminderType
        }

        public func validate(name: String) throws {
            try self.validate(self.reminderAtMinutes, name: "reminderAtMinutes", parent: name, max: 1)
            try self.validate(self.reminderAtMinutes, name: "reminderAtMinutes", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case enabled = "Enabled"
            case reminderAtMinutes = "ReminderAtMinutes"
            case reminderType = "ReminderType"
        }
    }

    public struct UpdateGatewayGroupRequest: AWSEncodableShape {
        /// The updated description of the gateway group.
        public let description: String?
        /// The ARN of the gateway group to update.
        public let gatewayGroupArn: String
        /// The updated name of the gateway group.
        public let name: String?

        public init(description: String? = nil, gatewayGroupArn: String, name: String? = nil) {
            self.description = description
            self.gatewayGroupArn = gatewayGroupArn
            self.name = name
        }

        public func validate(name: String) throws {
            try self.validate(self.description, name: "description", parent: name, max: 200)
            try self.validate(self.description, name: "description", parent: name, min: 0)
            try self.validate(self.gatewayGroupArn, name: "gatewayGroupArn", parent: name, pattern: "arn:[a-z0-9-\\.]{1,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[^/].{0,1023}")
            try self.validate(self.name, name: "name", parent: name, max: 100)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "[\\u0009\\u000A\\u000D\\u0020-\\u007E\\u0085\\u00A0-\\uD7FF\\uE000-\\uFFFD\\u10000-\\u10FFFF]*")
        }

        private enum CodingKeys: String, CodingKey {
            case description = "Description"
            case gatewayGroupArn = "GatewayGroupArn"
            case name = "Name"
        }
    }

    public struct UpdateGatewayGroupResponse: AWSDecodableShape {
        public init() {}
    }

    public struct UpdateGatewayRequest: AWSEncodableShape {
        /// The updated description of the gateway.
        public let description: String?
        /// The ARN of the gateway to update.
        public let gatewayArn: String
        /// The updated name of the gateway.
        public let name: String?
        /// The updated software version of the gateway. The gateway automatically updates its software version during normal operation.
        public let softwareVersion: String?

        public init(description: String? = nil, gatewayArn: String, name: String? = nil, softwareVersion: String? = nil) {
            self.description = description
            self.gatewayArn = gatewayArn
            self.name = name
            self.softwareVersion = softwareVersion
        }

        public func validate(name: String) throws {
            try self.validate(self.description, name: "description", parent: name, max: 200)
            try self.validate(self.description, name: "description", parent: name, min: 0)
            try self.validate(self.description, name: "description", parent: name, pattern: "[\\u0009\\u000A\\u000D\\u0020-\\u007E\\u0085\\u00A0-\\uD7FF\\uE000-\\uFFFD\\u10000-\\u10FFFF]*")
            try self.validate(self.gatewayArn, name: "gatewayArn", parent: name, pattern: "arn:[a-z0-9-\\.]{1,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[^/].{0,1023}")
            try self.validate(self.name, name: "name", parent: name, max: 253)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "[\\u0009\\u000A\\u000D\\u0020-\\u007E\\u0085\\u00A0-\\uD7FF\\uE000-\\uFFFD\\u10000-\\u10FFFF]*")
            try self.validate(self.softwareVersion, name: "softwareVersion", parent: name, max: 50)
            try self.validate(self.softwareVersion, name: "softwareVersion", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case description = "Description"
            case gatewayArn = "GatewayArn"
            case name = "Name"
            case softwareVersion = "SoftwareVersion"
        }
    }

    public struct UpdateGatewayResponse: AWSDecodableShape {
        public init() {}
    }

    public struct UpdateInstantBooking: AWSEncodableShape {
        /// Duration between 15 and 240 minutes at increments of 15 that determines how long to book an available room when a meeting is started with Alexa.
        public let durationInMinutes: Int?
        /// Whether instant booking is enabled or not.
        public let enabled: Bool?

        public init(durationInMinutes: Int? = nil, enabled: Bool? = nil) {
            self.durationInMinutes = durationInMinutes
            self.enabled = enabled
        }

        private enum CodingKeys: String, CodingKey {
            case durationInMinutes = "DurationInMinutes"
            case enabled = "Enabled"
        }
    }

    public struct UpdateMeetingRoomConfiguration: AWSEncodableShape {
        /// Settings for the end of meeting reminder feature that are applied to a room profile. The end of meeting reminder enables Alexa to remind users when a meeting is ending.
        public let endOfMeetingReminder: UpdateEndOfMeetingReminder?
        /// Settings to automatically book an available room available for a configured duration when joining a meeting with Alexa.
        public let instantBooking: UpdateInstantBooking?
        /// Settings for requiring a check in when a room is reserved. Alexa can cancel a room reservation if it's not checked into to make the room available for others. Users can check in by joining the meeting with Alexa or an AVS device, or by saying Alexa, check in.
        public let requireCheckIn: UpdateRequireCheckIn?
        /// Whether room utilization metrics are enabled or not.
        public let roomUtilizationMetricsEnabled: Bool?

        public init(endOfMeetingReminder: UpdateEndOfMeetingReminder? = nil, instantBooking: UpdateInstantBooking? = nil, requireCheckIn: UpdateRequireCheckIn? = nil, roomUtilizationMetricsEnabled: Bool? = nil) {
            self.endOfMeetingReminder = endOfMeetingReminder
            self.instantBooking = instantBooking
            self.requireCheckIn = requireCheckIn
            self.roomUtilizationMetricsEnabled = roomUtilizationMetricsEnabled
        }

        public func validate(name: String) throws {
            try self.endOfMeetingReminder?.validate(name: "\(name).endOfMeetingReminder")
        }

        private enum CodingKeys: String, CodingKey {
            case endOfMeetingReminder = "EndOfMeetingReminder"
            case instantBooking = "InstantBooking"
            case requireCheckIn = "RequireCheckIn"
            case roomUtilizationMetricsEnabled = "RoomUtilizationMetricsEnabled"
        }
    }

    public struct UpdateNetworkProfileRequest: AWSEncodableShape {
        /// The ARN of the Private Certificate Authority (PCA) created in AWS Certificate Manager (ACM). This is used to issue certificates to the devices.
        public let certificateAuthorityArn: String?
        /// The current password of the Wi-Fi network.
        public let currentPassword: String?
        /// Detailed information about a device's network profile.
        public let description: String?
        /// The ARN of the network profile associated with a device.
        public let networkProfileArn: String
        /// The name of the network profile associated with a device.
        public let networkProfileName: String?
        /// The next, or subsequent, password of the Wi-Fi network. This password is asynchronously transmitted to the device and is used when the password of the network changes to NextPassword.
        public let nextPassword: String?
        /// The root certificate(s) of your authentication server that will be installed on your devices and used to trust your authentication server during EAP negotiation.
        public let trustAnchors: [String]?

        public init(certificateAuthorityArn: String? = nil, currentPassword: String? = nil, description: String? = nil, networkProfileArn: String, networkProfileName: String? = nil, nextPassword: String? = nil, trustAnchors: [String]? = nil) {
            self.certificateAuthorityArn = certificateAuthorityArn
            self.currentPassword = currentPassword
            self.description = description
            self.networkProfileArn = networkProfileArn
            self.networkProfileName = networkProfileName
            self.nextPassword = nextPassword
            self.trustAnchors = trustAnchors
        }

        public func validate(name: String) throws {
            try self.validate(self.certificateAuthorityArn, name: "certificateAuthorityArn", parent: name, pattern: "arn:[a-z0-9-\\.]{1,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[^/].{0,1023}")
            try self.validate(self.currentPassword, name: "currentPassword", parent: name, max: 128)
            try self.validate(self.currentPassword, name: "currentPassword", parent: name, min: 5)
            try self.validate(self.currentPassword, name: "currentPassword", parent: name, pattern: "[\\x00-\\x7F]*")
            try self.validate(self.description, name: "description", parent: name, max: 200)
            try self.validate(self.description, name: "description", parent: name, min: 0)
            try self.validate(self.description, name: "description", parent: name, pattern: "[\\u0009\\u000A\\u000D\\u0020-\\u007E\\u0085\\u00A0-\\uD7FF\\uE000-\\uFFFD\\u10000-\\u10FFFF]*")
            try self.validate(self.networkProfileArn, name: "networkProfileArn", parent: name, pattern: "arn:[a-z0-9-\\.]{1,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[^/].{0,1023}")
            try self.validate(self.networkProfileName, name: "networkProfileName", parent: name, max: 100)
            try self.validate(self.networkProfileName, name: "networkProfileName", parent: name, min: 1)
            try self.validate(self.networkProfileName, name: "networkProfileName", parent: name, pattern: "[\\u0009\\u000A\\u000D\\u0020-\\u007E\\u0085\\u00A0-\\uD7FF\\uE000-\\uFFFD\\u10000-\\u10FFFF]*")
            try self.validate(self.nextPassword, name: "nextPassword", parent: name, max: 128)
            try self.validate(self.nextPassword, name: "nextPassword", parent: name, min: 0)
            try self.validate(self.nextPassword, name: "nextPassword", parent: name, pattern: "(^$)|([\\x00-\\x7F]{5,})")
            try self.trustAnchors?.forEach {
                try validate($0, name: "trustAnchors[]", parent: name, pattern: "-{5}BEGIN CERTIFICATE-{5}\\u000D?\\u000A([A-Za-z0-9/+]{64}\\u000D?\\u000A)*[A-Za-z0-9/+]{1,64}={0,2}\\u000D?\\u000A-{5}END CERTIFICATE-{5}(\\u000D?\\u000A)?")
            }
            try self.validate(self.trustAnchors, name: "trustAnchors", parent: name, max: 5)
            try self.validate(self.trustAnchors, name: "trustAnchors", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case certificateAuthorityArn = "CertificateAuthorityArn"
            case currentPassword = "CurrentPassword"
            case description = "Description"
            case networkProfileArn = "NetworkProfileArn"
            case networkProfileName = "NetworkProfileName"
            case nextPassword = "NextPassword"
            case trustAnchors = "TrustAnchors"
        }
    }

    public struct UpdateNetworkProfileResponse: AWSDecodableShape {
        public init() {}
    }

    public struct UpdateProfileRequest: AWSEncodableShape {
        /// The updated address for the room profile.
        public let address: String?
        /// Whether data retention of the profile is enabled.
        public let dataRetentionOptIn: Bool?
        /// The updated distance unit for the room profile.
        public let distanceUnit: DistanceUnit?
        /// Sets the profile as default if selected. If this is missing, no update is done to the default status.
        public let isDefault: Bool?
        /// The updated locale for the room profile. (This is currently only available to a limited preview audience.)
        public let locale: String?
        /// The updated maximum volume limit for the room profile.
        public let maxVolumeLimit: Int?
        /// The updated meeting room settings of a room profile.
        public let meetingRoomConfiguration: UpdateMeetingRoomConfiguration?
        /// The ARN of the room profile to update. Required.
        public let profileArn: String?
        /// The updated name for the room profile.
        public let profileName: String?
        /// Whether the PSTN setting of the room profile is enabled.
        public let pSTNEnabled: Bool?
        /// Whether the setup mode of the profile is enabled.
        public let setupModeDisabled: Bool?
        /// The updated temperature unit for the room profile.
        public let temperatureUnit: TemperatureUnit?
        /// The updated timezone for the room profile.
        public let timezone: String?
        /// The updated wake word for the room profile.
        public let wakeWord: WakeWord?

        public init(address: String? = nil, dataRetentionOptIn: Bool? = nil, distanceUnit: DistanceUnit? = nil, isDefault: Bool? = nil, locale: String? = nil, maxVolumeLimit: Int? = nil, meetingRoomConfiguration: UpdateMeetingRoomConfiguration? = nil, profileArn: String? = nil, profileName: String? = nil, pSTNEnabled: Bool? = nil, setupModeDisabled: Bool? = nil, temperatureUnit: TemperatureUnit? = nil, timezone: String? = nil, wakeWord: WakeWord? = nil) {
            self.address = address
            self.dataRetentionOptIn = dataRetentionOptIn
            self.distanceUnit = distanceUnit
            self.isDefault = isDefault
            self.locale = locale
            self.maxVolumeLimit = maxVolumeLimit
            self.meetingRoomConfiguration = meetingRoomConfiguration
            self.profileArn = profileArn
            self.profileName = profileName
            self.pSTNEnabled = pSTNEnabled
            self.setupModeDisabled = setupModeDisabled
            self.temperatureUnit = temperatureUnit
            self.timezone = timezone
            self.wakeWord = wakeWord
        }

        public func validate(name: String) throws {
            try self.validate(self.address, name: "address", parent: name, max: 500)
            try self.validate(self.address, name: "address", parent: name, min: 1)
            try self.validate(self.locale, name: "locale", parent: name, max: 256)
            try self.validate(self.locale, name: "locale", parent: name, min: 1)
            try self.meetingRoomConfiguration?.validate(name: "\(name).meetingRoomConfiguration")
            try self.validate(self.profileArn, name: "profileArn", parent: name, pattern: "arn:[a-z0-9-\\.]{1,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[^/].{0,1023}")
            try self.validate(self.profileName, name: "profileName", parent: name, max: 100)
            try self.validate(self.profileName, name: "profileName", parent: name, min: 1)
            try self.validate(self.profileName, name: "profileName", parent: name, pattern: "[\\u0009\\u000A\\u000D\\u0020-\\u007E\\u0085\\u00A0-\\uD7FF\\uE000-\\uFFFD\\u10000-\\u10FFFF]*")
            try self.validate(self.timezone, name: "timezone", parent: name, max: 100)
            try self.validate(self.timezone, name: "timezone", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case address = "Address"
            case dataRetentionOptIn = "DataRetentionOptIn"
            case distanceUnit = "DistanceUnit"
            case isDefault = "IsDefault"
            case locale = "Locale"
            case maxVolumeLimit = "MaxVolumeLimit"
            case meetingRoomConfiguration = "MeetingRoomConfiguration"
            case profileArn = "ProfileArn"
            case profileName = "ProfileName"
            case pSTNEnabled = "PSTNEnabled"
            case setupModeDisabled = "SetupModeDisabled"
            case temperatureUnit = "TemperatureUnit"
            case timezone = "Timezone"
            case wakeWord = "WakeWord"
        }
    }

    public struct UpdateProfileResponse: AWSDecodableShape {
        public init() {}
    }

    public struct UpdateRequireCheckIn: AWSEncodableShape {
        /// Whether require check in is enabled or not.
        public let enabled: Bool?
        /// Duration between 5 and 20 minutes to determine when to release the room if it's not checked into.
        public let releaseAfterMinutes: Int?

        public init(enabled: Bool? = nil, releaseAfterMinutes: Int? = nil) {
            self.enabled = enabled
            self.releaseAfterMinutes = releaseAfterMinutes
        }

        private enum CodingKeys: String, CodingKey {
            case enabled = "Enabled"
            case releaseAfterMinutes = "ReleaseAfterMinutes"
        }
    }

    public struct UpdateRoomRequest: AWSEncodableShape {
        /// The updated description for the room.
        public let description: String?
        /// The updated profile ARN for the room.
        public let profileArn: String?
        /// The updated provider calendar ARN for the room.
        public let providerCalendarId: String?
        /// The ARN of the room to update.
        public let roomArn: String?
        /// The updated name for the room.
        public let roomName: String?

        public init(description: String? = nil, profileArn: String? = nil, providerCalendarId: String? = nil, roomArn: String? = nil, roomName: String? = nil) {
            self.description = description
            self.profileArn = profileArn
            self.providerCalendarId = providerCalendarId
            self.roomArn = roomArn
            self.roomName = roomName
        }

        public func validate(name: String) throws {
            try self.validate(self.description, name: "description", parent: name, max: 200)
            try self.validate(self.description, name: "description", parent: name, min: 1)
            try self.validate(self.description, name: "description", parent: name, pattern: "[\\u0009\\u000A\\u000D\\u0020-\\u007E\\u0085\\u00A0-\\uD7FF\\uE000-\\uFFFD\\u10000-\\u10FFFF]*")
            try self.validate(self.profileArn, name: "profileArn", parent: name, pattern: "arn:[a-z0-9-\\.]{1,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[^/].{0,1023}")
            try self.validate(self.providerCalendarId, name: "providerCalendarId", parent: name, max: 100)
            try self.validate(self.providerCalendarId, name: "providerCalendarId", parent: name, min: 0)
            try self.validate(self.roomArn, name: "roomArn", parent: name, pattern: "arn:[a-z0-9-\\.]{1,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[^/].{0,1023}")
            try self.validate(self.roomName, name: "roomName", parent: name, max: 100)
            try self.validate(self.roomName, name: "roomName", parent: name, min: 1)
            try self.validate(self.roomName, name: "roomName", parent: name, pattern: "[\\u0009\\u000A\\u000D\\u0020-\\u007E\\u0085\\u00A0-\\uD7FF\\uE000-\\uFFFD\\u10000-\\u10FFFF]*")
        }

        private enum CodingKeys: String, CodingKey {
            case description = "Description"
            case profileArn = "ProfileArn"
            case providerCalendarId = "ProviderCalendarId"
            case roomArn = "RoomArn"
            case roomName = "RoomName"
        }
    }

    public struct UpdateRoomResponse: AWSDecodableShape {
        public init() {}
    }

    public struct UpdateSkillGroupRequest: AWSEncodableShape {
        /// The updated description for the skill group.
        public let description: String?
        /// The ARN of the skill group to update.
        public let skillGroupArn: String?
        /// The updated name for the skill group.
        public let skillGroupName: String?

        public init(description: String? = nil, skillGroupArn: String? = nil, skillGroupName: String? = nil) {
            self.description = description
            self.skillGroupArn = skillGroupArn
            self.skillGroupName = skillGroupName
        }

        public func validate(name: String) throws {
            try self.validate(self.description, name: "description", parent: name, max: 200)
            try self.validate(self.description, name: "description", parent: name, min: 1)
            try self.validate(self.description, name: "description", parent: name, pattern: "[\\u0009\\u000A\\u000D\\u0020-\\u007E\\u0085\\u00A0-\\uD7FF\\uE000-\\uFFFD\\u10000-\\u10FFFF]*")
            try self.validate(self.skillGroupArn, name: "skillGroupArn", parent: name, pattern: "arn:[a-z0-9-\\.]{1,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[^/].{0,1023}")
            try self.validate(self.skillGroupName, name: "skillGroupName", parent: name, max: 100)
            try self.validate(self.skillGroupName, name: "skillGroupName", parent: name, min: 1)
            try self.validate(self.skillGroupName, name: "skillGroupName", parent: name, pattern: "[\\u0009\\u000A\\u000D\\u0020-\\u007E\\u0085\\u00A0-\\uD7FF\\uE000-\\uFFFD\\u10000-\\u10FFFF]*")
        }

        private enum CodingKeys: String, CodingKey {
            case description = "Description"
            case skillGroupArn = "SkillGroupArn"
            case skillGroupName = "SkillGroupName"
        }
    }

    public struct UpdateSkillGroupResponse: AWSDecodableShape {
        public init() {}
    }

    public struct UserData: AWSDecodableShape {
        /// The email of a user.
        public let email: String?
        /// The enrollment ARN of a user.
        public let enrollmentId: String?
        /// The enrollment status of a user.
        public let enrollmentStatus: EnrollmentStatus?
        /// The first name of a user.
        public let firstName: String?
        /// The last name of a user.
        public let lastName: String?
        /// The ARN of a user.
        public let userArn: String?

        public init(email: String? = nil, enrollmentId: String? = nil, enrollmentStatus: EnrollmentStatus? = nil, firstName: String? = nil, lastName: String? = nil, userArn: String? = nil) {
            self.email = email
            self.enrollmentId = enrollmentId
            self.enrollmentStatus = enrollmentStatus
            self.firstName = firstName
            self.lastName = lastName
            self.userArn = userArn
        }

        private enum CodingKeys: String, CodingKey {
            case email = "Email"
            case enrollmentId = "EnrollmentId"
            case enrollmentStatus = "EnrollmentStatus"
            case firstName = "FirstName"
            case lastName = "LastName"
            case userArn = "UserArn"
        }
    }
}
