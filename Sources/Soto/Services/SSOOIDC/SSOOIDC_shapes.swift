//===----------------------------------------------------------------------===//
//
// This source file is part of the Soto for AWS open source project
//
// Copyright (c) 2017-2023 the Soto project authors
// Licensed under Apache License v2.0
//
// See LICENSE.txt for license information
// See CONTRIBUTORS.txt for the list of Soto project authors
//
// SPDX-License-Identifier: Apache-2.0
//
//===----------------------------------------------------------------------===//

// THIS FILE IS AUTOMATICALLY GENERATED by https://github.com/soto-project/soto-codegenerator.
// DO NOT EDIT.

#if os(Linux) && compiler(<5.10)
// swift-corelibs-foundation hasn't been updated with Sendable conformances
@preconcurrency import Foundation
#else
import Foundation
#endif
@_spi(SotoInternal) import SotoCore

extension SSOOIDC {
    // MARK: Enums

    // MARK: Shapes

    public struct CreateTokenRequest: AWSEncodableShape {
        /// The unique identifier string for the client or application. This value comes from the result of the RegisterClient API.
        public let clientId: String
        /// A secret string generated for the client. This value should come from the persisted result of the RegisterClient API.
        public let clientSecret: String
        /// Used only when calling this API for the Authorization Code grant type. The short-term code is used to identify this authorization request. This grant type is currently unsupported for the CreateToken API.
        public let code: String?
        /// Used only when calling this API for the Device Code grant type. This short-term code is used to identify this authorization request. This comes from the result of the StartDeviceAuthorization API.
        public let deviceCode: String?
        /// Supports the following OAuth grant types: Device Code and Refresh Token. Specify either of the following values, depending on the grant type that you want: * Device Code - urn:ietf:params:oauth:grant-type:device_code  * Refresh Token - refresh_token  For information about how to obtain the device code, see the StartDeviceAuthorization topic.
        public let grantType: String
        /// Used only when calling this API for the Authorization Code grant type. This value specifies the location of the client or application that has registered to receive the authorization code.
        public let redirectUri: String?
        /// Used only when calling this API for the Refresh Token grant type. This token is used to refresh short-term tokens, such as the access token, that might expire. For more information about the features and limitations of the current IAM Identity Center OIDC implementation, see Considerations for Using this Guide in the IAM Identity Center OIDC API Reference.
        public let refreshToken: String?
        /// The list of scopes for which authorization is requested. The access token that is issued is limited to the scopes that are granted. If this value is not specified, IAM Identity Center authorizes all scopes that are configured for the client during the call to RegisterClient.
        public let scope: [String]?

        public init(clientId: String, clientSecret: String, code: String? = nil, deviceCode: String? = nil, grantType: String, redirectUri: String? = nil, refreshToken: String? = nil, scope: [String]? = nil) {
            self.clientId = clientId
            self.clientSecret = clientSecret
            self.code = code
            self.deviceCode = deviceCode
            self.grantType = grantType
            self.redirectUri = redirectUri
            self.refreshToken = refreshToken
            self.scope = scope
        }

        private enum CodingKeys: String, CodingKey {
            case clientId = "clientId"
            case clientSecret = "clientSecret"
            case code = "code"
            case deviceCode = "deviceCode"
            case grantType = "grantType"
            case redirectUri = "redirectUri"
            case refreshToken = "refreshToken"
            case scope = "scope"
        }
    }

    public struct CreateTokenResponse: AWSDecodableShape {
        /// A bearer token to access AWS accounts and applications assigned to a user.
        public let accessToken: String?
        /// Indicates the time in seconds when an access token will expire.
        public let expiresIn: Int?
        /// The idToken is not implemented or supported. For more information about the features and limitations of the current IAM Identity Center OIDC implementation, see Considerations for Using this Guide in the IAM Identity Center OIDC API Reference. A JSON Web Token (JWT) that identifies who is associated with the issued access token.
        public let idToken: String?
        /// A token that, if present, can be used to refresh a previously issued access token that might have expired. For more information about the features and limitations of the current IAM Identity Center OIDC implementation, see Considerations for Using this Guide in the IAM Identity Center OIDC API Reference.
        public let refreshToken: String?
        /// Used to notify the client that the returned token is an access token. The supported token type is Bearer.
        public let tokenType: String?

        public init(accessToken: String? = nil, expiresIn: Int? = nil, idToken: String? = nil, refreshToken: String? = nil, tokenType: String? = nil) {
            self.accessToken = accessToken
            self.expiresIn = expiresIn
            self.idToken = idToken
            self.refreshToken = refreshToken
            self.tokenType = tokenType
        }

        private enum CodingKeys: String, CodingKey {
            case accessToken = "accessToken"
            case expiresIn = "expiresIn"
            case idToken = "idToken"
            case refreshToken = "refreshToken"
            case tokenType = "tokenType"
        }
    }

    public struct CreateTokenWithIAMRequest: AWSEncodableShape {
        /// Used only when calling this API for the JWT Bearer grant type. This value specifies the JSON Web Token (JWT) issued by a trusted token issuer. To authorize a trusted token issuer, configure the JWT Bearer GrantOptions for the application.
        public let assertion: String?
        /// The unique identifier string for the client or application. This value is an application ARN that has OAuth grants configured.
        public let clientId: String
        /// Used only when calling this API for the Authorization Code grant type. This short-term code is used to identify this authorization request. The code is obtained through a redirect from IAM Identity Center to a redirect URI persisted in the Authorization Code GrantOptions for the application.
        public let code: String?
        /// Supports the following OAuth grant types: Authorization Code, Refresh Token, JWT Bearer, and Token Exchange. Specify one of the following values, depending on the grant type that you want: * Authorization Code - authorization_code  * Refresh Token - refresh_token  * JWT Bearer - urn:ietf:params:oauth:grant-type:jwt-bearer  * Token Exchange - urn:ietf:params:oauth:grant-type:token-exchange
        public let grantType: String
        /// Used only when calling this API for the Authorization Code grant type. This value specifies the location of the client or application that has registered to receive the authorization code.
        public let redirectUri: String?
        /// Used only when calling this API for the Refresh Token grant type. This token is used to refresh short-term tokens, such as the access token, that might expire. For more information about the features and limitations of the current IAM Identity Center OIDC implementation, see Considerations for Using this Guide in the IAM Identity Center OIDC API Reference.
        public let refreshToken: String?
        /// Used only when calling this API for the Token Exchange grant type. This value specifies the type of token that the requester can receive. The following values are supported: * Access Token - urn:ietf:params:oauth:token-type:access_token  * Refresh Token - urn:ietf:params:oauth:token-type:refresh_token
        public let requestedTokenType: String?
        /// The list of scopes for which authorization is requested. The access token that is issued is limited to the scopes that are granted. If the value is not specified, IAM Identity Center authorizes all scopes configured for the application, including the following default scopes: openid, aws, sts:identity_context.
        public let scope: [String]?
        /// Used only when calling this API for the Token Exchange grant type. This value specifies the subject of the exchange. The value of the subject token must be an access token issued by IAM Identity Center to a different client or application. The access token must have authorized scopes that indicate the requested application as a target audience.
        public let subjectToken: String?
        /// Used only when calling this API for the Token Exchange grant type. This value specifies the type of token that is passed as the subject of the exchange. The following value is supported: * Access Token - urn:ietf:params:oauth:token-type:access_token
        public let subjectTokenType: String?

        public init(assertion: String? = nil, clientId: String, code: String? = nil, grantType: String, redirectUri: String? = nil, refreshToken: String? = nil, requestedTokenType: String? = nil, scope: [String]? = nil, subjectToken: String? = nil, subjectTokenType: String? = nil) {
            self.assertion = assertion
            self.clientId = clientId
            self.code = code
            self.grantType = grantType
            self.redirectUri = redirectUri
            self.refreshToken = refreshToken
            self.requestedTokenType = requestedTokenType
            self.scope = scope
            self.subjectToken = subjectToken
            self.subjectTokenType = subjectTokenType
        }

        private enum CodingKeys: String, CodingKey {
            case assertion = "assertion"
            case clientId = "clientId"
            case code = "code"
            case grantType = "grantType"
            case redirectUri = "redirectUri"
            case refreshToken = "refreshToken"
            case requestedTokenType = "requestedTokenType"
            case scope = "scope"
            case subjectToken = "subjectToken"
            case subjectTokenType = "subjectTokenType"
        }
    }

    public struct CreateTokenWithIAMResponse: AWSDecodableShape {
        /// A bearer token to access AWS accounts and applications assigned to a user.
        public let accessToken: String?
        /// Indicates the time in seconds when an access token will expire.
        public let expiresIn: Int?
        /// A JSON Web Token (JWT) that identifies the user associated with the issued access token.
        public let idToken: String?
        /// Indicates the type of tokens that are issued by IAM Identity Center. The following values are supported:  * Access Token - urn:ietf:params:oauth:token-type:access_token  * Refresh Token - urn:ietf:params:oauth:token-type:refresh_token
        public let issuedTokenType: String?
        /// A token that, if present, can be used to refresh a previously issued access token that might have expired. For more information about the features and limitations of the current IAM Identity Center OIDC implementation, see Considerations for Using this Guide in the IAM Identity Center OIDC API Reference.
        public let refreshToken: String?
        /// The list of scopes for which authorization is granted. The access token that is issued is limited to the scopes that are granted.
        public let scope: [String]?
        /// Used to notify the requester that the returned token is an access token. The supported token type is Bearer.
        public let tokenType: String?

        public init(accessToken: String? = nil, expiresIn: Int? = nil, idToken: String? = nil, issuedTokenType: String? = nil, refreshToken: String? = nil, scope: [String]? = nil, tokenType: String? = nil) {
            self.accessToken = accessToken
            self.expiresIn = expiresIn
            self.idToken = idToken
            self.issuedTokenType = issuedTokenType
            self.refreshToken = refreshToken
            self.scope = scope
            self.tokenType = tokenType
        }

        private enum CodingKeys: String, CodingKey {
            case accessToken = "accessToken"
            case expiresIn = "expiresIn"
            case idToken = "idToken"
            case issuedTokenType = "issuedTokenType"
            case refreshToken = "refreshToken"
            case scope = "scope"
            case tokenType = "tokenType"
        }
    }

    public struct RegisterClientRequest: AWSEncodableShape {
        /// The friendly name of the client.
        public let clientName: String
        /// The type of client. The service supports only public as a client type. Anything other than public will be rejected by the service.
        public let clientType: String
        /// The list of scopes that are defined by the client. Upon authorization, this list is used to restrict permissions when granting an access token.
        public let scopes: [String]?

        public init(clientName: String, clientType: String, scopes: [String]? = nil) {
            self.clientName = clientName
            self.clientType = clientType
            self.scopes = scopes
        }

        private enum CodingKeys: String, CodingKey {
            case clientName = "clientName"
            case clientType = "clientType"
            case scopes = "scopes"
        }
    }

    public struct RegisterClientResponse: AWSDecodableShape {
        /// An endpoint that the client can use to request authorization.
        public let authorizationEndpoint: String?
        /// The unique identifier string for each client. This client uses this identifier to get authenticated by the service in subsequent calls.
        public let clientId: String?
        /// Indicates the time at which the clientId and clientSecret were issued.
        public let clientIdIssuedAt: Int64?
        /// A secret string generated for the client. The client will use this string to get authenticated by the service in subsequent calls.
        public let clientSecret: String?
        /// Indicates the time at which the clientId and clientSecret will become invalid.
        public let clientSecretExpiresAt: Int64?
        /// An endpoint that the client can use to create tokens.
        public let tokenEndpoint: String?

        public init(authorizationEndpoint: String? = nil, clientId: String? = nil, clientIdIssuedAt: Int64? = nil, clientSecret: String? = nil, clientSecretExpiresAt: Int64? = nil, tokenEndpoint: String? = nil) {
            self.authorizationEndpoint = authorizationEndpoint
            self.clientId = clientId
            self.clientIdIssuedAt = clientIdIssuedAt
            self.clientSecret = clientSecret
            self.clientSecretExpiresAt = clientSecretExpiresAt
            self.tokenEndpoint = tokenEndpoint
        }

        private enum CodingKeys: String, CodingKey {
            case authorizationEndpoint = "authorizationEndpoint"
            case clientId = "clientId"
            case clientIdIssuedAt = "clientIdIssuedAt"
            case clientSecret = "clientSecret"
            case clientSecretExpiresAt = "clientSecretExpiresAt"
            case tokenEndpoint = "tokenEndpoint"
        }
    }

    public struct StartDeviceAuthorizationRequest: AWSEncodableShape {
        /// The unique identifier string for the client that is registered with IAM Identity Center. This value should come from the persisted result of the RegisterClient API operation.
        public let clientId: String
        /// A secret string that is generated for the client. This value should come from the persisted result of the RegisterClient API operation.
        public let clientSecret: String
        /// The URL for the Amazon Web Services access portal. For more information, see Using the Amazon Web Services access portal in the IAM Identity Center User Guide.
        public let startUrl: String

        public init(clientId: String, clientSecret: String, startUrl: String) {
            self.clientId = clientId
            self.clientSecret = clientSecret
            self.startUrl = startUrl
        }

        private enum CodingKeys: String, CodingKey {
            case clientId = "clientId"
            case clientSecret = "clientSecret"
            case startUrl = "startUrl"
        }
    }

    public struct StartDeviceAuthorizationResponse: AWSDecodableShape {
        /// The short-lived code that is used by the device when polling for a session token.
        public let deviceCode: String?
        /// Indicates the number of seconds in which the verification code will become invalid.
        public let expiresIn: Int?
        /// Indicates the number of seconds the client must wait between attempts when polling for a session.
        public let interval: Int?
        /// A one-time user verification code. This is needed to authorize an in-use device.
        public let userCode: String?
        /// The URI of the verification page that takes the userCode to authorize the device.
        public let verificationUri: String?
        /// An alternate URL that the client can use to automatically launch a browser. This process skips the manual step in which the user visits the verification page and enters their code.
        public let verificationUriComplete: String?

        public init(deviceCode: String? = nil, expiresIn: Int? = nil, interval: Int? = nil, userCode: String? = nil, verificationUri: String? = nil, verificationUriComplete: String? = nil) {
            self.deviceCode = deviceCode
            self.expiresIn = expiresIn
            self.interval = interval
            self.userCode = userCode
            self.verificationUri = verificationUri
            self.verificationUriComplete = verificationUriComplete
        }

        private enum CodingKeys: String, CodingKey {
            case deviceCode = "deviceCode"
            case expiresIn = "expiresIn"
            case interval = "interval"
            case userCode = "userCode"
            case verificationUri = "verificationUri"
            case verificationUriComplete = "verificationUriComplete"
        }
    }
}

// MARK: - Errors

/// Error enum for SSOOIDC
public struct SSOOIDCErrorType: AWSErrorType {
    enum Code: String {
        case accessDeniedException = "AccessDeniedException"
        case authorizationPendingException = "AuthorizationPendingException"
        case expiredTokenException = "ExpiredTokenException"
        case internalServerException = "InternalServerException"
        case invalidClientException = "InvalidClientException"
        case invalidClientMetadataException = "InvalidClientMetadataException"
        case invalidGrantException = "InvalidGrantException"
        case invalidRequestException = "InvalidRequestException"
        case invalidRequestRegionException = "InvalidRequestRegionException"
        case invalidScopeException = "InvalidScopeException"
        case slowDownException = "SlowDownException"
        case unauthorizedClientException = "UnauthorizedClientException"
        case unsupportedGrantTypeException = "UnsupportedGrantTypeException"
    }

    private let error: Code
    public let context: AWSErrorContext?

    /// initialize SSOOIDC
    public init?(errorCode: String, context: AWSErrorContext) {
        guard let error = Code(rawValue: errorCode) else { return nil }
        self.error = error
        self.context = context
    }

    internal init(_ error: Code) {
        self.error = error
        self.context = nil
    }

    /// return error code string
    public var errorCode: String { self.error.rawValue }

    /// You do not have sufficient access to perform this action.
    public static var accessDeniedException: Self { .init(.accessDeniedException) }
    /// Indicates that a request to authorize a client with an access user session token is pending.
    public static var authorizationPendingException: Self { .init(.authorizationPendingException) }
    /// Indicates that the token issued by the service is expired and is no longer valid.
    public static var expiredTokenException: Self { .init(.expiredTokenException) }
    /// Indicates that an error from the service occurred while trying to process a request.
    public static var internalServerException: Self { .init(.internalServerException) }
    /// Indicates that the clientId or clientSecret in the request is invalid. For example, this can occur when a client sends an incorrect clientId or an expired clientSecret.
    public static var invalidClientException: Self { .init(.invalidClientException) }
    /// Indicates that the client information sent in the request during registration is invalid.
    public static var invalidClientMetadataException: Self { .init(.invalidClientMetadataException) }
    /// Indicates that a request contains an invalid grant. This can occur if a client makes a CreateToken request with an invalid grant type.
    public static var invalidGrantException: Self { .init(.invalidGrantException) }
    /// Indicates that something is wrong with the input to the request. For example, a required parameter might be missing or out of range.
    public static var invalidRequestException: Self { .init(.invalidRequestException) }
    /// Indicates that a token provided as input to the request was issued by and is only usable by calling IAM Identity Center endpoints in another region.
    public static var invalidRequestRegionException: Self { .init(.invalidRequestRegionException) }
    /// Indicates that the scope provided in the request is invalid.
    public static var invalidScopeException: Self { .init(.invalidScopeException) }
    /// Indicates that the client is making the request too frequently and is more than the service can handle.
    public static var slowDownException: Self { .init(.slowDownException) }
    /// Indicates that the client is not currently authorized to make the request. This can happen when a clientId is not issued for a public client.
    public static var unauthorizedClientException: Self { .init(.unauthorizedClientException) }
    /// Indicates that the grant type in the request is not supported by the service.
    public static var unsupportedGrantTypeException: Self { .init(.unsupportedGrantTypeException) }
}

extension SSOOIDCErrorType: Equatable {
    public static func == (lhs: SSOOIDCErrorType, rhs: SSOOIDCErrorType) -> Bool {
        lhs.error == rhs.error
    }
}

extension SSOOIDCErrorType: CustomStringConvertible {
    public var description: String {
        return "\(self.error.rawValue): \(self.message ?? "")"
    }
}
