//===----------------------------------------------------------------------===//
//
// This source file is part of the Soto for AWS open source project
//
// Copyright (c) 2017-2024 the Soto project authors
// Licensed under Apache License v2.0
//
// See LICENSE.txt for license information
// See CONTRIBUTORS.txt for the list of Soto project authors
//
// SPDX-License-Identifier: Apache-2.0
//
//===----------------------------------------------------------------------===//

// THIS FILE IS AUTOMATICALLY GENERATED by https://github.com/soto-project/soto-codegenerator.
// DO NOT EDIT.

#if canImport(FoundationEssentials)
import FoundationEssentials
#else
import Foundation
#endif
@_exported import SotoCore

/// Service object for interacting with AWS LookoutEquipment service.
///
/// Amazon Lookout for Equipment is a machine learning service that uses advanced analytics to identify anomalies in machines from sensor data for use in predictive maintenance.
public struct LookoutEquipment: AWSService {
    // MARK: Member variables

    /// Client used for communication with AWS
    public let client: AWSClient
    /// Service configuration
    public let config: AWSServiceConfig

    // MARK: Initialization

    /// Initialize the LookoutEquipment client
    /// - parameters:
    ///     - client: AWSClient used to process requests
    ///     - region: Region of server you want to communicate with. This will override the partition parameter.
    ///     - partition: AWS partition where service resides, standard (.aws), china (.awscn), government (.awsusgov).
    ///     - endpoint: Custom endpoint URL to use instead of standard AWS servers
    ///     - middleware: Middleware chain used to edit requests before they are sent and responses before they are decoded 
    ///     - timeout: Timeout value for HTTP requests
    ///     - byteBufferAllocator: Allocator for ByteBuffers
    ///     - options: Service options
    public init(
        client: AWSClient,
        region: SotoCore.Region? = nil,
        partition: AWSPartition = .aws,
        endpoint: String? = nil,
        middleware: AWSMiddlewareProtocol? = nil,
        timeout: TimeAmount? = nil,
        byteBufferAllocator: ByteBufferAllocator = ByteBufferAllocator(),
        options: AWSServiceConfig.Options = []
    ) {
        self.client = client
        self.config = AWSServiceConfig(
            region: region,
            partition: region?.partition ?? partition,
            amzTarget: "AWSLookoutEquipmentFrontendService",
            serviceName: "LookoutEquipment",
            serviceIdentifier: "lookoutequipment",
            serviceProtocol: .json(version: "1.0"),
            apiVersion: "2020-12-15",
            endpoint: endpoint,
            errorType: LookoutEquipmentErrorType.self,
            middleware: middleware,
            timeout: timeout,
            byteBufferAllocator: byteBufferAllocator,
            options: options
        )
    }





    // MARK: API Calls

    /// Creates a container for a collection of data being ingested for analysis. The dataset contains the metadata describing where the data is and what the data actually looks like. For example, it contains the location of the data source, the data schema, and other information. A dataset also contains any tags associated with the ingested data.
    @Sendable
    @inlinable
    public func createDataset(_ input: CreateDatasetRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> CreateDatasetResponse {
        try await self.client.execute(
            operation: "CreateDataset", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Creates a container for a collection of data being ingested for analysis. The dataset contains the metadata describing where the data is and what the data actually looks like. For example, it contains the location of the data source, the data schema, and other information. A dataset also contains any tags associated with the ingested data.
    ///
    /// Parameters:
    ///   - clientToken:  A unique identifier for the request. If you do not set the client request token, Amazon Lookout for Equipment generates one.
    ///   - datasetName: The name of the dataset being created.
    ///   - datasetSchema: A JSON description of the data that is in each time series dataset, including names, column names, and data types.
    ///   - serverSideKmsKeyId: Provides the identifier of the KMS key used to encrypt dataset data by Amazon Lookout for Equipment.
    ///   - tags: Any tags associated with the ingested data described in the dataset.
    ///   - logger: Logger use during operation
    @inlinable
    public func createDataset(
        clientToken: String = CreateDatasetRequest.idempotencyToken(),
        datasetName: String,
        datasetSchema: DatasetSchema? = nil,
        serverSideKmsKeyId: String? = nil,
        tags: [Tag]? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> CreateDatasetResponse {
        let input = CreateDatasetRequest(
            clientToken: clientToken, 
            datasetName: datasetName, 
            datasetSchema: datasetSchema, 
            serverSideKmsKeyId: serverSideKmsKeyId, 
            tags: tags
        )
        return try await self.createDataset(input, logger: logger)
    }

    ///  Creates a scheduled inference. Scheduling an inference is setting up a continuous real-time inference plan to analyze new measurement data. When setting up the schedule, you provide an S3 bucket location for the input data, assign it a delimiter between separate entries in the data, set an offset delay if desired, and set the frequency of inferencing. You must also provide an S3 bucket location for the output data.
    @Sendable
    @inlinable
    public func createInferenceScheduler(_ input: CreateInferenceSchedulerRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> CreateInferenceSchedulerResponse {
        try await self.client.execute(
            operation: "CreateInferenceScheduler", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    ///  Creates a scheduled inference. Scheduling an inference is setting up a continuous real-time inference plan to analyze new measurement data. When setting up the schedule, you provide an S3 bucket location for the input data, assign it a delimiter between separate entries in the data, set an offset delay if desired, and set the frequency of inferencing. You must also provide an S3 bucket location for the output data.
    ///
    /// Parameters:
    ///   - clientToken:  A unique identifier for the request. If you do not set the client request token, Amazon Lookout for Equipment generates one.
    ///   - dataDelayOffsetInMinutes: The interval (in minutes) of planned delay at the start of each inference segment. For example, if inference is set to run every ten minutes, the delay is set to five minutes and the time is 09:08. The inference scheduler will wake up at the configured interval (which, without a delay configured, would be 09:10) plus the additional five minute delay time (so 09:15) to check your Amazon S3 bucket. The delay provides a buffer for you to upload data at the same frequency, so that you don't have to stop and restart the scheduler when uploading new data. For more information, see Understanding the inference process.
    ///   - dataInputConfiguration: Specifies configuration information for the input data for the inference scheduler, including delimiter, format, and dataset location.
    ///   - dataOutputConfiguration: Specifies configuration information for the output results for the inference scheduler, including the S3 location for the output.
    ///   - dataUploadFrequency:  How often data is uploaded to the source Amazon S3 bucket for the input data. The value chosen is the length of time between data uploads. For instance, if you select 5 minutes, Amazon Lookout for Equipment will upload the real-time data to the source bucket once every 5 minutes. This frequency also determines how often Amazon Lookout for Equipment runs inference on your data. For more information, see Understanding the inference process.
    ///   - inferenceSchedulerName: The name of the inference scheduler being created.
    ///   - modelName: The name of the previously trained machine learning model being used to create the inference scheduler.
    ///   - roleArn: The Amazon Resource Name (ARN) of a role with permission to access the data source being used for the inference.
    ///   - serverSideKmsKeyId: Provides the identifier of the KMS key used to encrypt inference scheduler data by Amazon Lookout for Equipment.
    ///   - tags: Any tags associated with the inference scheduler.
    ///   - logger: Logger use during operation
    @inlinable
    public func createInferenceScheduler(
        clientToken: String = CreateInferenceSchedulerRequest.idempotencyToken(),
        dataDelayOffsetInMinutes: Int64? = nil,
        dataInputConfiguration: InferenceInputConfiguration,
        dataOutputConfiguration: InferenceOutputConfiguration,
        dataUploadFrequency: DataUploadFrequency,
        inferenceSchedulerName: String,
        modelName: String,
        roleArn: String,
        serverSideKmsKeyId: String? = nil,
        tags: [Tag]? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> CreateInferenceSchedulerResponse {
        let input = CreateInferenceSchedulerRequest(
            clientToken: clientToken, 
            dataDelayOffsetInMinutes: dataDelayOffsetInMinutes, 
            dataInputConfiguration: dataInputConfiguration, 
            dataOutputConfiguration: dataOutputConfiguration, 
            dataUploadFrequency: dataUploadFrequency, 
            inferenceSchedulerName: inferenceSchedulerName, 
            modelName: modelName, 
            roleArn: roleArn, 
            serverSideKmsKeyId: serverSideKmsKeyId, 
            tags: tags
        )
        return try await self.createInferenceScheduler(input, logger: logger)
    }

    ///  Creates a label for an event.
    @Sendable
    @inlinable
    public func createLabel(_ input: CreateLabelRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> CreateLabelResponse {
        try await self.client.execute(
            operation: "CreateLabel", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    ///  Creates a label for an event.
    ///
    /// Parameters:
    ///   - clientToken:  A unique identifier for the request to create a label. If you do not set the client request token, Lookout for Equipment generates one.
    ///   - endTime:  The end time of the labeled event.
    ///   - equipment:  Indicates that a label pertains to a particular piece of equipment.  Data in this field will be retained for service usage. Follow best practices for the security of your data.
    ///   - faultCode:  Provides additional information about the label. The fault code must be defined in the FaultCodes attribute of the label group. Data in this field will be retained for service usage. Follow best practices for the security of your data.
    ///   - labelGroupName:  The name of a group of labels.  Data in this field will be retained for service usage. Follow best practices for the security of your data.
    ///   - notes:  Metadata providing additional information about the label.  Data in this field will be retained for service usage. Follow best practices for the security of your data.
    ///   - rating:  Indicates whether a labeled event represents an anomaly.
    ///   - startTime:  The start time of the labeled event.
    ///   - logger: Logger use during operation
    @inlinable
    public func createLabel(
        clientToken: String = CreateLabelRequest.idempotencyToken(),
        endTime: Date,
        equipment: String? = nil,
        faultCode: String? = nil,
        labelGroupName: String,
        notes: String? = nil,
        rating: LabelRating,
        startTime: Date,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> CreateLabelResponse {
        let input = CreateLabelRequest(
            clientToken: clientToken, 
            endTime: endTime, 
            equipment: equipment, 
            faultCode: faultCode, 
            labelGroupName: labelGroupName, 
            notes: notes, 
            rating: rating, 
            startTime: startTime
        )
        return try await self.createLabel(input, logger: logger)
    }

    ///  Creates a group of labels.
    @Sendable
    @inlinable
    public func createLabelGroup(_ input: CreateLabelGroupRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> CreateLabelGroupResponse {
        try await self.client.execute(
            operation: "CreateLabelGroup", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    ///  Creates a group of labels.
    ///
    /// Parameters:
    ///   - clientToken:  A unique identifier for the request to create a label group. If you do not set the client request token, Lookout for Equipment generates one.
    ///   - faultCodes:  The acceptable fault codes (indicating the type of anomaly associated with the label) that can be used with this label group. Data in this field will be retained for service usage. Follow best practices for the security of your data.
    ///   - labelGroupName:  Names a group of labels. Data in this field will be retained for service usage. Follow best practices for the security of your data.
    ///   - tags:  Tags that provide metadata about the label group you are creating.  Data in this field will be retained for service usage. Follow best practices for the security of your data.
    ///   - logger: Logger use during operation
    @inlinable
    public func createLabelGroup(
        clientToken: String = CreateLabelGroupRequest.idempotencyToken(),
        faultCodes: [String]? = nil,
        labelGroupName: String,
        tags: [Tag]? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> CreateLabelGroupResponse {
        let input = CreateLabelGroupRequest(
            clientToken: clientToken, 
            faultCodes: faultCodes, 
            labelGroupName: labelGroupName, 
            tags: tags
        )
        return try await self.createLabelGroup(input, logger: logger)
    }

    /// Creates a machine learning model for data inference.  A machine-learning (ML) model is a mathematical model that finds patterns in your data. In Amazon Lookout for Equipment, the model learns the patterns of normal behavior and detects abnormal behavior that could be potential equipment failure (or maintenance events). The models are made by analyzing normal data and abnormalities in machine behavior that have already occurred. Your model is trained using a portion of the data from your dataset and uses that data to learn patterns of normal behavior and abnormal patterns that lead to equipment failure. Another portion of the data is used to evaluate the model's accuracy.
    @Sendable
    @inlinable
    public func createModel(_ input: CreateModelRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> CreateModelResponse {
        try await self.client.execute(
            operation: "CreateModel", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Creates a machine learning model for data inference.  A machine-learning (ML) model is a mathematical model that finds patterns in your data. In Amazon Lookout for Equipment, the model learns the patterns of normal behavior and detects abnormal behavior that could be potential equipment failure (or maintenance events). The models are made by analyzing normal data and abnormalities in machine behavior that have already occurred. Your model is trained using a portion of the data from your dataset and uses that data to learn patterns of normal behavior and abnormal patterns that lead to equipment failure. Another portion of the data is used to evaluate the model's accuracy.
    ///
    /// Parameters:
    ///   - clientToken: A unique identifier for the request. If you do not set the client request token, Amazon Lookout for Equipment generates one.
    ///   - dataPreProcessingConfiguration: The configuration is the TargetSamplingRate, which is the sampling rate of the data after post processing by Amazon Lookout for Equipment. For example, if you provide data that has been collected at a 1 second level and you want the system to resample the data at a 1 minute rate before training, the TargetSamplingRate is 1 minute. When providing a value for the TargetSamplingRate, you must attach the prefix "PT" to the rate you want. The value for a 1 second rate is therefore PT1S, the value for a 15 minute rate is PT15M, and the value for a 1 hour rate is PT1H
    ///   - datasetName: The name of the dataset for the machine learning model being created.
    ///   - datasetSchema: The data schema for the machine learning model being created.
    ///   - evaluationDataEndTime:  Indicates the time reference in the dataset that should be used to end the subset of evaluation data for the machine learning model.
    ///   - evaluationDataStartTime: Indicates the time reference in the dataset that should be used to begin the subset of evaluation data for the machine learning model.
    ///   - labelsInputConfiguration: The input configuration for the labels being used for the machine learning model that's being created.
    ///   - modelDiagnosticsOutputConfiguration: The Amazon S3 location where you want Amazon Lookout for Equipment to save the pointwise model diagnostics.   You must also specify the RoleArn request parameter.
    ///   - modelName: The name for the machine learning model to be created.
    ///   - offCondition: Indicates that the asset associated with this sensor has been shut off. As long as this condition is met, Lookout for Equipment will not use data from this asset for training, evaluation, or inference.
    ///   - roleArn:  The Amazon Resource Name (ARN) of a role with permission to access the data source being used to create the machine learning model.
    ///   - serverSideKmsKeyId: Provides the identifier of the KMS key used to encrypt model data by Amazon Lookout for Equipment.
    ///   - tags:  Any tags associated with the machine learning model being created.
    ///   - trainingDataEndTime: Indicates the time reference in the dataset that should be used to end the subset of training data for the machine learning model.
    ///   - trainingDataStartTime: Indicates the time reference in the dataset that should be used to begin the subset of training data for the machine learning model.
    ///   - logger: Logger use during operation
    @inlinable
    public func createModel(
        clientToken: String = CreateModelRequest.idempotencyToken(),
        dataPreProcessingConfiguration: DataPreProcessingConfiguration? = nil,
        datasetName: String,
        datasetSchema: DatasetSchema? = nil,
        evaluationDataEndTime: Date? = nil,
        evaluationDataStartTime: Date? = nil,
        labelsInputConfiguration: LabelsInputConfiguration? = nil,
        modelDiagnosticsOutputConfiguration: ModelDiagnosticsOutputConfiguration? = nil,
        modelName: String,
        offCondition: String? = nil,
        roleArn: String? = nil,
        serverSideKmsKeyId: String? = nil,
        tags: [Tag]? = nil,
        trainingDataEndTime: Date? = nil,
        trainingDataStartTime: Date? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> CreateModelResponse {
        let input = CreateModelRequest(
            clientToken: clientToken, 
            dataPreProcessingConfiguration: dataPreProcessingConfiguration, 
            datasetName: datasetName, 
            datasetSchema: datasetSchema, 
            evaluationDataEndTime: evaluationDataEndTime, 
            evaluationDataStartTime: evaluationDataStartTime, 
            labelsInputConfiguration: labelsInputConfiguration, 
            modelDiagnosticsOutputConfiguration: modelDiagnosticsOutputConfiguration, 
            modelName: modelName, 
            offCondition: offCondition, 
            roleArn: roleArn, 
            serverSideKmsKeyId: serverSideKmsKeyId, 
            tags: tags, 
            trainingDataEndTime: trainingDataEndTime, 
            trainingDataStartTime: trainingDataStartTime
        )
        return try await self.createModel(input, logger: logger)
    }

    /// Creates a retraining scheduler on the specified model.
    @Sendable
    @inlinable
    public func createRetrainingScheduler(_ input: CreateRetrainingSchedulerRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> CreateRetrainingSchedulerResponse {
        try await self.client.execute(
            operation: "CreateRetrainingScheduler", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Creates a retraining scheduler on the specified model.
    ///
    /// Parameters:
    ///   - clientToken: A unique identifier for the request. If you do not set the client request token, Amazon Lookout for Equipment generates one.
    ///   - lookbackWindow: The number of past days of data that will be used for retraining.
    ///   - modelName: The name of the model to add the retraining scheduler to.
    ///   - promoteMode: Indicates how the service will use new models. In MANAGED mode, new models will automatically be used for inference if they have better performance than the current model. In MANUAL mode, the new models will not be used until they are manually activated.
    ///   - retrainingFrequency: This parameter uses the ISO 8601 standard to set the frequency at which you want retraining to occur in terms of Years, Months, and/or Days (note: other parameters like Time are not currently supported). The minimum value is 30 days (P30D) and the maximum value is 1 year (P1Y). For example, the following values are valid:   P3M15D – Every 3 months and 15 days   P2M – Every 2 months   P150D – Every 150 days
    ///   - retrainingStartDate: The start date for the retraining scheduler. Lookout for Equipment truncates the time you provide to the nearest UTC day.
    ///   - logger: Logger use during operation
    @inlinable
    public func createRetrainingScheduler(
        clientToken: String = CreateRetrainingSchedulerRequest.idempotencyToken(),
        lookbackWindow: String,
        modelName: String,
        promoteMode: ModelPromoteMode? = nil,
        retrainingFrequency: String,
        retrainingStartDate: Date? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> CreateRetrainingSchedulerResponse {
        let input = CreateRetrainingSchedulerRequest(
            clientToken: clientToken, 
            lookbackWindow: lookbackWindow, 
            modelName: modelName, 
            promoteMode: promoteMode, 
            retrainingFrequency: retrainingFrequency, 
            retrainingStartDate: retrainingStartDate
        )
        return try await self.createRetrainingScheduler(input, logger: logger)
    }

    ///  Deletes a dataset and associated artifacts. The operation will check to see if any inference scheduler or data ingestion job is currently using the dataset, and if there isn't, the dataset, its metadata, and any associated data stored in S3 will be deleted. This does not affect any models that used this dataset for training and evaluation, but does prevent it from being used in the future.
    @Sendable
    @inlinable
    public func deleteDataset(_ input: DeleteDatasetRequest, logger: Logger = AWSClient.loggingDisabled) async throws {
        try await self.client.execute(
            operation: "DeleteDataset", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    ///  Deletes a dataset and associated artifacts. The operation will check to see if any inference scheduler or data ingestion job is currently using the dataset, and if there isn't, the dataset, its metadata, and any associated data stored in S3 will be deleted. This does not affect any models that used this dataset for training and evaluation, but does prevent it from being used in the future.
    ///
    /// Parameters:
    ///   - datasetName: The name of the dataset to be deleted.
    ///   - logger: Logger use during operation
    @inlinable
    public func deleteDataset(
        datasetName: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws {
        let input = DeleteDatasetRequest(
            datasetName: datasetName
        )
        return try await self.deleteDataset(input, logger: logger)
    }

    /// Deletes an inference scheduler that has been set up. Prior inference results will not be deleted.
    @Sendable
    @inlinable
    public func deleteInferenceScheduler(_ input: DeleteInferenceSchedulerRequest, logger: Logger = AWSClient.loggingDisabled) async throws {
        try await self.client.execute(
            operation: "DeleteInferenceScheduler", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Deletes an inference scheduler that has been set up. Prior inference results will not be deleted.
    ///
    /// Parameters:
    ///   - inferenceSchedulerName: The name of the inference scheduler to be deleted.
    ///   - logger: Logger use during operation
    @inlinable
    public func deleteInferenceScheduler(
        inferenceSchedulerName: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws {
        let input = DeleteInferenceSchedulerRequest(
            inferenceSchedulerName: inferenceSchedulerName
        )
        return try await self.deleteInferenceScheduler(input, logger: logger)
    }

    ///  Deletes a label.
    @Sendable
    @inlinable
    public func deleteLabel(_ input: DeleteLabelRequest, logger: Logger = AWSClient.loggingDisabled) async throws {
        try await self.client.execute(
            operation: "DeleteLabel", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    ///  Deletes a label.
    ///
    /// Parameters:
    ///   - labelGroupName:  The name of the label group that contains the label that you want to delete. Data in this field will be retained for service usage. Follow best practices for the security of your data.
    ///   - labelId:  The ID of the label that you want to delete.
    ///   - logger: Logger use during operation
    @inlinable
    public func deleteLabel(
        labelGroupName: String,
        labelId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws {
        let input = DeleteLabelRequest(
            labelGroupName: labelGroupName, 
            labelId: labelId
        )
        return try await self.deleteLabel(input, logger: logger)
    }

    ///  Deletes a group of labels.
    @Sendable
    @inlinable
    public func deleteLabelGroup(_ input: DeleteLabelGroupRequest, logger: Logger = AWSClient.loggingDisabled) async throws {
        try await self.client.execute(
            operation: "DeleteLabelGroup", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    ///  Deletes a group of labels.
    ///
    /// Parameters:
    ///   - labelGroupName:  The name of the label group that you want to delete. Data in this field will be retained for service usage. Follow best practices for the security of your data.
    ///   - logger: Logger use during operation
    @inlinable
    public func deleteLabelGroup(
        labelGroupName: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws {
        let input = DeleteLabelGroupRequest(
            labelGroupName: labelGroupName
        )
        return try await self.deleteLabelGroup(input, logger: logger)
    }

    /// Deletes a machine learning model currently available for Amazon Lookout for Equipment. This will prevent it from being used with an inference scheduler, even one that is already set up.
    @Sendable
    @inlinable
    public func deleteModel(_ input: DeleteModelRequest, logger: Logger = AWSClient.loggingDisabled) async throws {
        try await self.client.execute(
            operation: "DeleteModel", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Deletes a machine learning model currently available for Amazon Lookout for Equipment. This will prevent it from being used with an inference scheduler, even one that is already set up.
    ///
    /// Parameters:
    ///   - modelName: The name of the machine learning model to be deleted.
    ///   - logger: Logger use during operation
    @inlinable
    public func deleteModel(
        modelName: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws {
        let input = DeleteModelRequest(
            modelName: modelName
        )
        return try await self.deleteModel(input, logger: logger)
    }

    /// Deletes the resource policy attached to the resource.
    @Sendable
    @inlinable
    public func deleteResourcePolicy(_ input: DeleteResourcePolicyRequest, logger: Logger = AWSClient.loggingDisabled) async throws {
        try await self.client.execute(
            operation: "DeleteResourcePolicy", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Deletes the resource policy attached to the resource.
    ///
    /// Parameters:
    ///   - resourceArn: The Amazon Resource Name (ARN) of the resource for which the resource policy should be deleted.
    ///   - logger: Logger use during operation
    @inlinable
    public func deleteResourcePolicy(
        resourceArn: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws {
        let input = DeleteResourcePolicyRequest(
            resourceArn: resourceArn
        )
        return try await self.deleteResourcePolicy(input, logger: logger)
    }

    /// Deletes a retraining scheduler from a model. The retraining scheduler must be in the STOPPED status.
    @Sendable
    @inlinable
    public func deleteRetrainingScheduler(_ input: DeleteRetrainingSchedulerRequest, logger: Logger = AWSClient.loggingDisabled) async throws {
        try await self.client.execute(
            operation: "DeleteRetrainingScheduler", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Deletes a retraining scheduler from a model. The retraining scheduler must be in the STOPPED status.
    ///
    /// Parameters:
    ///   - modelName: The name of the model whose retraining scheduler you want to delete.
    ///   - logger: Logger use during operation
    @inlinable
    public func deleteRetrainingScheduler(
        modelName: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws {
        let input = DeleteRetrainingSchedulerRequest(
            modelName: modelName
        )
        return try await self.deleteRetrainingScheduler(input, logger: logger)
    }

    /// Provides information on a specific data ingestion job such as creation time, dataset ARN, and status.
    @Sendable
    @inlinable
    public func describeDataIngestionJob(_ input: DescribeDataIngestionJobRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> DescribeDataIngestionJobResponse {
        try await self.client.execute(
            operation: "DescribeDataIngestionJob", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Provides information on a specific data ingestion job such as creation time, dataset ARN, and status.
    ///
    /// Parameters:
    ///   - jobId: The job ID of the data ingestion job.
    ///   - logger: Logger use during operation
    @inlinable
    public func describeDataIngestionJob(
        jobId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> DescribeDataIngestionJobResponse {
        let input = DescribeDataIngestionJobRequest(
            jobId: jobId
        )
        return try await self.describeDataIngestionJob(input, logger: logger)
    }

    /// Provides a JSON description of the data in each time series dataset, including names, column names, and data types.
    @Sendable
    @inlinable
    public func describeDataset(_ input: DescribeDatasetRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> DescribeDatasetResponse {
        try await self.client.execute(
            operation: "DescribeDataset", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Provides a JSON description of the data in each time series dataset, including names, column names, and data types.
    ///
    /// Parameters:
    ///   - datasetName: The name of the dataset to be described.
    ///   - logger: Logger use during operation
    @inlinable
    public func describeDataset(
        datasetName: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> DescribeDatasetResponse {
        let input = DescribeDatasetRequest(
            datasetName: datasetName
        )
        return try await self.describeDataset(input, logger: logger)
    }

    ///  Specifies information about the inference scheduler being used, including name, model, status, and associated metadata
    @Sendable
    @inlinable
    public func describeInferenceScheduler(_ input: DescribeInferenceSchedulerRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> DescribeInferenceSchedulerResponse {
        try await self.client.execute(
            operation: "DescribeInferenceScheduler", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    ///  Specifies information about the inference scheduler being used, including name, model, status, and associated metadata
    ///
    /// Parameters:
    ///   - inferenceSchedulerName: The name of the inference scheduler being described.
    ///   - logger: Logger use during operation
    @inlinable
    public func describeInferenceScheduler(
        inferenceSchedulerName: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> DescribeInferenceSchedulerResponse {
        let input = DescribeInferenceSchedulerRequest(
            inferenceSchedulerName: inferenceSchedulerName
        )
        return try await self.describeInferenceScheduler(input, logger: logger)
    }

    ///  Returns the name of the label.
    @Sendable
    @inlinable
    public func describeLabel(_ input: DescribeLabelRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> DescribeLabelResponse {
        try await self.client.execute(
            operation: "DescribeLabel", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    ///  Returns the name of the label.
    ///
    /// Parameters:
    ///   - labelGroupName:  Returns the name of the group containing the label.
    ///   - labelId:  Returns the ID of the label.
    ///   - logger: Logger use during operation
    @inlinable
    public func describeLabel(
        labelGroupName: String,
        labelId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> DescribeLabelResponse {
        let input = DescribeLabelRequest(
            labelGroupName: labelGroupName, 
            labelId: labelId
        )
        return try await self.describeLabel(input, logger: logger)
    }

    ///  Returns information about the label group.
    @Sendable
    @inlinable
    public func describeLabelGroup(_ input: DescribeLabelGroupRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> DescribeLabelGroupResponse {
        try await self.client.execute(
            operation: "DescribeLabelGroup", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    ///  Returns information about the label group.
    ///
    /// Parameters:
    ///   - labelGroupName:  Returns the name of the label group.
    ///   - logger: Logger use during operation
    @inlinable
    public func describeLabelGroup(
        labelGroupName: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> DescribeLabelGroupResponse {
        let input = DescribeLabelGroupRequest(
            labelGroupName: labelGroupName
        )
        return try await self.describeLabelGroup(input, logger: logger)
    }

    /// Provides a JSON containing the overall information about a specific machine learning model, including model name and ARN, dataset, training and evaluation information, status, and so on.
    @Sendable
    @inlinable
    public func describeModel(_ input: DescribeModelRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> DescribeModelResponse {
        try await self.client.execute(
            operation: "DescribeModel", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Provides a JSON containing the overall information about a specific machine learning model, including model name and ARN, dataset, training and evaluation information, status, and so on.
    ///
    /// Parameters:
    ///   - modelName: The name of the machine learning model to be described.
    ///   - logger: Logger use during operation
    @inlinable
    public func describeModel(
        modelName: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> DescribeModelResponse {
        let input = DescribeModelRequest(
            modelName: modelName
        )
        return try await self.describeModel(input, logger: logger)
    }

    /// Retrieves information about a specific machine learning model version.
    @Sendable
    @inlinable
    public func describeModelVersion(_ input: DescribeModelVersionRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> DescribeModelVersionResponse {
        try await self.client.execute(
            operation: "DescribeModelVersion", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Retrieves information about a specific machine learning model version.
    ///
    /// Parameters:
    ///   - modelName: The name of the machine learning model that this version belongs to.
    ///   - modelVersion: The version of the machine learning model.
    ///   - logger: Logger use during operation
    @inlinable
    public func describeModelVersion(
        modelName: String,
        modelVersion: Int64,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> DescribeModelVersionResponse {
        let input = DescribeModelVersionRequest(
            modelName: modelName, 
            modelVersion: modelVersion
        )
        return try await self.describeModelVersion(input, logger: logger)
    }

    /// Provides the details of a resource policy attached to a resource.
    @Sendable
    @inlinable
    public func describeResourcePolicy(_ input: DescribeResourcePolicyRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> DescribeResourcePolicyResponse {
        try await self.client.execute(
            operation: "DescribeResourcePolicy", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Provides the details of a resource policy attached to a resource.
    ///
    /// Parameters:
    ///   - resourceArn: The Amazon Resource Name (ARN) of the resource that is associated with the resource policy.
    ///   - logger: Logger use during operation
    @inlinable
    public func describeResourcePolicy(
        resourceArn: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> DescribeResourcePolicyResponse {
        let input = DescribeResourcePolicyRequest(
            resourceArn: resourceArn
        )
        return try await self.describeResourcePolicy(input, logger: logger)
    }

    /// Provides a description of the retraining scheduler, including information such as the model name and retraining parameters.
    @Sendable
    @inlinable
    public func describeRetrainingScheduler(_ input: DescribeRetrainingSchedulerRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> DescribeRetrainingSchedulerResponse {
        try await self.client.execute(
            operation: "DescribeRetrainingScheduler", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Provides a description of the retraining scheduler, including information such as the model name and retraining parameters.
    ///
    /// Parameters:
    ///   - modelName: The name of the model that the retraining scheduler is attached to.
    ///   - logger: Logger use during operation
    @inlinable
    public func describeRetrainingScheduler(
        modelName: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> DescribeRetrainingSchedulerResponse {
        let input = DescribeRetrainingSchedulerRequest(
            modelName: modelName
        )
        return try await self.describeRetrainingScheduler(input, logger: logger)
    }

    /// Imports a dataset.
    @Sendable
    @inlinable
    public func importDataset(_ input: ImportDatasetRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> ImportDatasetResponse {
        try await self.client.execute(
            operation: "ImportDataset", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Imports a dataset.
    ///
    /// Parameters:
    ///   - clientToken: A unique identifier for the request. If you do not set the client request token, Amazon Lookout for Equipment generates one.
    ///   - datasetName: The name of the machine learning dataset to be created. If the dataset already exists, Amazon Lookout for Equipment overwrites the existing dataset. If you don't specify this field, it is filled with the name of the source dataset.
    ///   - serverSideKmsKeyId: Provides the identifier of the KMS key key used to encrypt model data by Amazon Lookout for Equipment.
    ///   - sourceDatasetArn: The Amazon Resource Name (ARN) of the dataset to import.
    ///   - tags: Any tags associated with the dataset to be created.
    ///   - logger: Logger use during operation
    @inlinable
    public func importDataset(
        clientToken: String = ImportDatasetRequest.idempotencyToken(),
        datasetName: String? = nil,
        serverSideKmsKeyId: String? = nil,
        sourceDatasetArn: String,
        tags: [Tag]? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ImportDatasetResponse {
        let input = ImportDatasetRequest(
            clientToken: clientToken, 
            datasetName: datasetName, 
            serverSideKmsKeyId: serverSideKmsKeyId, 
            sourceDatasetArn: sourceDatasetArn, 
            tags: tags
        )
        return try await self.importDataset(input, logger: logger)
    }

    /// Imports a model that has been trained successfully.
    @Sendable
    @inlinable
    public func importModelVersion(_ input: ImportModelVersionRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> ImportModelVersionResponse {
        try await self.client.execute(
            operation: "ImportModelVersion", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Imports a model that has been trained successfully.
    ///
    /// Parameters:
    ///   - clientToken: A unique identifier for the request. If you do not set the client request token, Amazon Lookout for Equipment generates one.
    ///   - datasetName: The name of the dataset for the machine learning model being imported.
    ///   - inferenceDataImportStrategy: Indicates how to import the accumulated inference data when a model version is imported. The possible values are as follows:   NO_IMPORT – Don't import the data.   ADD_WHEN_EMPTY – Only import the data from the source model if there is no existing data in the target model.   OVERWRITE – Import the data from the source model and overwrite the existing data in the target model.
    ///   - labelsInputConfiguration: 
    ///   - modelName: The name for the machine learning model to be created. If the model already exists, Amazon Lookout for Equipment creates a new version. If you do not specify this field, it is filled with the name of the source model.
    ///   - roleArn: The Amazon Resource Name (ARN) of a role with permission to access the data source being used to create the machine learning model.
    ///   - serverSideKmsKeyId: Provides the identifier of the KMS key key used to encrypt model data by Amazon Lookout for Equipment.
    ///   - sourceModelVersionArn: The Amazon Resource Name (ARN) of the model version to import.
    ///   - tags: The tags associated with the machine learning model to be created.
    ///   - logger: Logger use during operation
    @inlinable
    public func importModelVersion(
        clientToken: String = ImportModelVersionRequest.idempotencyToken(),
        datasetName: String,
        inferenceDataImportStrategy: InferenceDataImportStrategy? = nil,
        labelsInputConfiguration: LabelsInputConfiguration? = nil,
        modelName: String? = nil,
        roleArn: String? = nil,
        serverSideKmsKeyId: String? = nil,
        sourceModelVersionArn: String,
        tags: [Tag]? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ImportModelVersionResponse {
        let input = ImportModelVersionRequest(
            clientToken: clientToken, 
            datasetName: datasetName, 
            inferenceDataImportStrategy: inferenceDataImportStrategy, 
            labelsInputConfiguration: labelsInputConfiguration, 
            modelName: modelName, 
            roleArn: roleArn, 
            serverSideKmsKeyId: serverSideKmsKeyId, 
            sourceModelVersionArn: sourceModelVersionArn, 
            tags: tags
        )
        return try await self.importModelVersion(input, logger: logger)
    }

    /// Provides a list of all data ingestion jobs, including dataset name and ARN, S3 location of the input data, status, and so on.
    @Sendable
    @inlinable
    public func listDataIngestionJobs(_ input: ListDataIngestionJobsRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> ListDataIngestionJobsResponse {
        try await self.client.execute(
            operation: "ListDataIngestionJobs", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Provides a list of all data ingestion jobs, including dataset name and ARN, S3 location of the input data, status, and so on.
    ///
    /// Parameters:
    ///   - datasetName: The name of the dataset being used for the data ingestion job.
    ///   - maxResults:  Specifies the maximum number of data ingestion jobs to list.
    ///   - nextToken: An opaque pagination token indicating where to continue the listing of data ingestion jobs.
    ///   - status: Indicates the status of the data ingestion job.
    ///   - logger: Logger use during operation
    @inlinable
    public func listDataIngestionJobs(
        datasetName: String? = nil,
        maxResults: Int? = nil,
        nextToken: String? = nil,
        status: IngestionJobStatus? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ListDataIngestionJobsResponse {
        let input = ListDataIngestionJobsRequest(
            datasetName: datasetName, 
            maxResults: maxResults, 
            nextToken: nextToken, 
            status: status
        )
        return try await self.listDataIngestionJobs(input, logger: logger)
    }

    /// Lists all datasets currently available in your account, filtering on the dataset name.
    @Sendable
    @inlinable
    public func listDatasets(_ input: ListDatasetsRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> ListDatasetsResponse {
        try await self.client.execute(
            operation: "ListDatasets", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Lists all datasets currently available in your account, filtering on the dataset name.
    ///
    /// Parameters:
    ///   - datasetNameBeginsWith: The beginning of the name of the datasets to be listed.
    ///   - maxResults:  Specifies the maximum number of datasets to list.
    ///   - nextToken:  An opaque pagination token indicating where to continue the listing of datasets.
    ///   - logger: Logger use during operation
    @inlinable
    public func listDatasets(
        datasetNameBeginsWith: String? = nil,
        maxResults: Int? = nil,
        nextToken: String? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ListDatasetsResponse {
        let input = ListDatasetsRequest(
            datasetNameBeginsWith: datasetNameBeginsWith, 
            maxResults: maxResults, 
            nextToken: nextToken
        )
        return try await self.listDatasets(input, logger: logger)
    }

    ///  Lists all inference events that have been found for the specified inference scheduler.
    @Sendable
    @inlinable
    public func listInferenceEvents(_ input: ListInferenceEventsRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> ListInferenceEventsResponse {
        try await self.client.execute(
            operation: "ListInferenceEvents", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    ///  Lists all inference events that have been found for the specified inference scheduler.
    ///
    /// Parameters:
    ///   - inferenceSchedulerName: The name of the inference scheduler for the inference events listed.
    ///   - intervalEndTime: Returns all the inference events with an end start time equal to or greater than less than the end time given.
    ///   - intervalStartTime:  Lookout for Equipment will return all the inference events with an end time equal to or greater than the start time given.
    ///   - maxResults: Specifies the maximum number of inference events to list.
    ///   - nextToken: An opaque pagination token indicating where to continue the listing of inference events.
    ///   - logger: Logger use during operation
    @inlinable
    public func listInferenceEvents(
        inferenceSchedulerName: String,
        intervalEndTime: Date,
        intervalStartTime: Date,
        maxResults: Int? = nil,
        nextToken: String? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ListInferenceEventsResponse {
        let input = ListInferenceEventsRequest(
            inferenceSchedulerName: inferenceSchedulerName, 
            intervalEndTime: intervalEndTime, 
            intervalStartTime: intervalStartTime, 
            maxResults: maxResults, 
            nextToken: nextToken
        )
        return try await self.listInferenceEvents(input, logger: logger)
    }

    ///  Lists all inference executions that have been performed by the specified inference scheduler.
    @Sendable
    @inlinable
    public func listInferenceExecutions(_ input: ListInferenceExecutionsRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> ListInferenceExecutionsResponse {
        try await self.client.execute(
            operation: "ListInferenceExecutions", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    ///  Lists all inference executions that have been performed by the specified inference scheduler.
    ///
    /// Parameters:
    ///   - dataEndTimeBefore: The time reference in the inferenced dataset before which Amazon Lookout for Equipment stopped the inference execution.
    ///   - dataStartTimeAfter: The time reference in the inferenced dataset after which Amazon Lookout for Equipment started the inference execution.
    ///   - inferenceSchedulerName: The name of the inference scheduler for the inference execution listed.
    ///   - maxResults: Specifies the maximum number of inference executions to list.
    ///   - nextToken: An opaque pagination token indicating where to continue the listing of inference executions.
    ///   - status: The status of the inference execution.
    ///   - logger: Logger use during operation
    @inlinable
    public func listInferenceExecutions(
        dataEndTimeBefore: Date? = nil,
        dataStartTimeAfter: Date? = nil,
        inferenceSchedulerName: String,
        maxResults: Int? = nil,
        nextToken: String? = nil,
        status: InferenceExecutionStatus? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ListInferenceExecutionsResponse {
        let input = ListInferenceExecutionsRequest(
            dataEndTimeBefore: dataEndTimeBefore, 
            dataStartTimeAfter: dataStartTimeAfter, 
            inferenceSchedulerName: inferenceSchedulerName, 
            maxResults: maxResults, 
            nextToken: nextToken, 
            status: status
        )
        return try await self.listInferenceExecutions(input, logger: logger)
    }

    /// Retrieves a list of all inference schedulers currently available for your account.
    @Sendable
    @inlinable
    public func listInferenceSchedulers(_ input: ListInferenceSchedulersRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> ListInferenceSchedulersResponse {
        try await self.client.execute(
            operation: "ListInferenceSchedulers", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Retrieves a list of all inference schedulers currently available for your account.
    ///
    /// Parameters:
    ///   - inferenceSchedulerNameBeginsWith: The beginning of the name of the inference schedulers to be listed.
    ///   - maxResults:  Specifies the maximum number of inference schedulers to list.
    ///   - modelName: The name of the machine learning model used by the inference scheduler to be listed.
    ///   - nextToken:  An opaque pagination token indicating where to continue the listing of inference schedulers.
    ///   - status: Specifies the current status of the inference schedulers.
    ///   - logger: Logger use during operation
    @inlinable
    public func listInferenceSchedulers(
        inferenceSchedulerNameBeginsWith: String? = nil,
        maxResults: Int? = nil,
        modelName: String? = nil,
        nextToken: String? = nil,
        status: InferenceSchedulerStatus? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ListInferenceSchedulersResponse {
        let input = ListInferenceSchedulersRequest(
            inferenceSchedulerNameBeginsWith: inferenceSchedulerNameBeginsWith, 
            maxResults: maxResults, 
            modelName: modelName, 
            nextToken: nextToken, 
            status: status
        )
        return try await self.listInferenceSchedulers(input, logger: logger)
    }

    ///  Returns a list of the label groups.
    @Sendable
    @inlinable
    public func listLabelGroups(_ input: ListLabelGroupsRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> ListLabelGroupsResponse {
        try await self.client.execute(
            operation: "ListLabelGroups", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    ///  Returns a list of the label groups.
    ///
    /// Parameters:
    ///   - labelGroupNameBeginsWith:  The beginning of the name of the label groups to be listed.
    ///   - maxResults:  Specifies the maximum number of label groups to list.
    ///   - nextToken:  An opaque pagination token indicating where to continue the listing of label groups.
    ///   - logger: Logger use during operation
    @inlinable
    public func listLabelGroups(
        labelGroupNameBeginsWith: String? = nil,
        maxResults: Int? = nil,
        nextToken: String? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ListLabelGroupsResponse {
        let input = ListLabelGroupsRequest(
            labelGroupNameBeginsWith: labelGroupNameBeginsWith, 
            maxResults: maxResults, 
            nextToken: nextToken
        )
        return try await self.listLabelGroups(input, logger: logger)
    }

    ///  Provides a list of labels.
    @Sendable
    @inlinable
    public func listLabels(_ input: ListLabelsRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> ListLabelsResponse {
        try await self.client.execute(
            operation: "ListLabels", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    ///  Provides a list of labels.
    ///
    /// Parameters:
    ///   - equipment:  Lists the labels that pertain to a particular piece of equipment.
    ///   - faultCode:  Returns labels with a particular fault code.
    ///   - intervalEndTime:  Returns all labels with a start time earlier than the end time given.
    ///   - intervalStartTime:  Returns all the labels with a end time equal to or later than the start time given.
    ///   - labelGroupName:  Returns the name of the label group.
    ///   - maxResults:  Specifies the maximum number of labels to list.
    ///   - nextToken:  An opaque pagination token indicating where to continue the listing of label groups.
    ///   - logger: Logger use during operation
    @inlinable
    public func listLabels(
        equipment: String? = nil,
        faultCode: String? = nil,
        intervalEndTime: Date? = nil,
        intervalStartTime: Date? = nil,
        labelGroupName: String,
        maxResults: Int? = nil,
        nextToken: String? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ListLabelsResponse {
        let input = ListLabelsRequest(
            equipment: equipment, 
            faultCode: faultCode, 
            intervalEndTime: intervalEndTime, 
            intervalStartTime: intervalStartTime, 
            labelGroupName: labelGroupName, 
            maxResults: maxResults, 
            nextToken: nextToken
        )
        return try await self.listLabels(input, logger: logger)
    }

    /// Generates a list of all model versions for a given model, including the model version, model version ARN, and status. To list a subset of versions, use the MaxModelVersion and MinModelVersion fields.
    @Sendable
    @inlinable
    public func listModelVersions(_ input: ListModelVersionsRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> ListModelVersionsResponse {
        try await self.client.execute(
            operation: "ListModelVersions", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Generates a list of all model versions for a given model, including the model version, model version ARN, and status. To list a subset of versions, use the MaxModelVersion and MinModelVersion fields.
    ///
    /// Parameters:
    ///   - createdAtEndTime: Filter results to return all the model versions created before this time.
    ///   - createdAtStartTime: Filter results to return all the model versions created after this time.
    ///   - maxModelVersion: Specifies the highest version of the model to return in the list.
    ///   - maxResults: Specifies the maximum number of machine learning model versions to list.
    ///   - minModelVersion: Specifies the lowest version of the model to return in the list.
    ///   - modelName: Then name of the machine learning model for which the model versions are to be listed.
    ///   - nextToken: If the total number of results exceeds the limit that the response can display, the response returns an opaque pagination token indicating where to continue the listing of machine learning model versions. Use this token in the NextToken field in the request to list the next page of results.
    ///   - sourceType: Filter the results based on the way the model version was generated.
    ///   - status: Filter the results based on the current status of the model version.
    ///   - logger: Logger use during operation
    @inlinable
    public func listModelVersions(
        createdAtEndTime: Date? = nil,
        createdAtStartTime: Date? = nil,
        maxModelVersion: Int64? = nil,
        maxResults: Int? = nil,
        minModelVersion: Int64? = nil,
        modelName: String,
        nextToken: String? = nil,
        sourceType: ModelVersionSourceType? = nil,
        status: ModelVersionStatus? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ListModelVersionsResponse {
        let input = ListModelVersionsRequest(
            createdAtEndTime: createdAtEndTime, 
            createdAtStartTime: createdAtStartTime, 
            maxModelVersion: maxModelVersion, 
            maxResults: maxResults, 
            minModelVersion: minModelVersion, 
            modelName: modelName, 
            nextToken: nextToken, 
            sourceType: sourceType, 
            status: status
        )
        return try await self.listModelVersions(input, logger: logger)
    }

    /// Generates a list of all models in the account, including model name and ARN, dataset, and status.
    @Sendable
    @inlinable
    public func listModels(_ input: ListModelsRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> ListModelsResponse {
        try await self.client.execute(
            operation: "ListModels", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Generates a list of all models in the account, including model name and ARN, dataset, and status.
    ///
    /// Parameters:
    ///   - datasetNameBeginsWith: The beginning of the name of the dataset of the machine learning models to be listed.
    ///   - maxResults:  Specifies the maximum number of machine learning models to list.
    ///   - modelNameBeginsWith: The beginning of the name of the machine learning models being listed.
    ///   - nextToken:  An opaque pagination token indicating where to continue the listing of machine learning models.
    ///   - status: The status of the machine learning model.
    ///   - logger: Logger use during operation
    @inlinable
    public func listModels(
        datasetNameBeginsWith: String? = nil,
        maxResults: Int? = nil,
        modelNameBeginsWith: String? = nil,
        nextToken: String? = nil,
        status: ModelStatus? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ListModelsResponse {
        let input = ListModelsRequest(
            datasetNameBeginsWith: datasetNameBeginsWith, 
            maxResults: maxResults, 
            modelNameBeginsWith: modelNameBeginsWith, 
            nextToken: nextToken, 
            status: status
        )
        return try await self.listModels(input, logger: logger)
    }

    /// Lists all retraining schedulers in your account, filtering by model name prefix and status.
    @Sendable
    @inlinable
    public func listRetrainingSchedulers(_ input: ListRetrainingSchedulersRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> ListRetrainingSchedulersResponse {
        try await self.client.execute(
            operation: "ListRetrainingSchedulers", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Lists all retraining schedulers in your account, filtering by model name prefix and status.
    ///
    /// Parameters:
    ///   - maxResults: Specifies the maximum number of retraining schedulers to list.
    ///   - modelNameBeginsWith: Specify this field to only list retraining schedulers whose machine learning models begin with the value you specify.
    ///   - nextToken: If the number of results exceeds the maximum, a pagination token is returned. Use the token in the request to show the next page of retraining schedulers.
    ///   - status: Specify this field to only list retraining schedulers whose status matches the value you specify.
    ///   - logger: Logger use during operation
    @inlinable
    public func listRetrainingSchedulers(
        maxResults: Int? = nil,
        modelNameBeginsWith: String? = nil,
        nextToken: String? = nil,
        status: RetrainingSchedulerStatus? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ListRetrainingSchedulersResponse {
        let input = ListRetrainingSchedulersRequest(
            maxResults: maxResults, 
            modelNameBeginsWith: modelNameBeginsWith, 
            nextToken: nextToken, 
            status: status
        )
        return try await self.listRetrainingSchedulers(input, logger: logger)
    }

    ///  Lists statistics about the data collected for each of the sensors that have been successfully ingested in the particular dataset. Can also be used to retreive Sensor Statistics for a previous ingestion job.
    @Sendable
    @inlinable
    public func listSensorStatistics(_ input: ListSensorStatisticsRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> ListSensorStatisticsResponse {
        try await self.client.execute(
            operation: "ListSensorStatistics", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    ///  Lists statistics about the data collected for each of the sensors that have been successfully ingested in the particular dataset. Can also be used to retreive Sensor Statistics for a previous ingestion job.
    ///
    /// Parameters:
    ///   - datasetName:  The name of the dataset associated with the list of Sensor Statistics.
    ///   - ingestionJobId:  The ingestion job id associated with the list of Sensor Statistics. To get sensor statistics for a particular ingestion job id, both dataset name and ingestion job id must be submitted as inputs.
    ///   - maxResults: Specifies the maximum number of sensors for which to retrieve statistics.
    ///   - nextToken: An opaque pagination token indicating where to continue the listing of sensor statistics.
    ///   - logger: Logger use during operation
    @inlinable
    public func listSensorStatistics(
        datasetName: String,
        ingestionJobId: String? = nil,
        maxResults: Int? = nil,
        nextToken: String? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ListSensorStatisticsResponse {
        let input = ListSensorStatisticsRequest(
            datasetName: datasetName, 
            ingestionJobId: ingestionJobId, 
            maxResults: maxResults, 
            nextToken: nextToken
        )
        return try await self.listSensorStatistics(input, logger: logger)
    }

    /// Lists all the tags for a specified resource, including key and value.
    @Sendable
    @inlinable
    public func listTagsForResource(_ input: ListTagsForResourceRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> ListTagsForResourceResponse {
        try await self.client.execute(
            operation: "ListTagsForResource", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Lists all the tags for a specified resource, including key and value.
    ///
    /// Parameters:
    ///   - resourceArn: The Amazon Resource Name (ARN) of the resource (such as the dataset or model) that is the focus of the ListTagsForResource operation.
    ///   - logger: Logger use during operation
    @inlinable
    public func listTagsForResource(
        resourceArn: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ListTagsForResourceResponse {
        let input = ListTagsForResourceRequest(
            resourceArn: resourceArn
        )
        return try await self.listTagsForResource(input, logger: logger)
    }

    /// Creates a resource control policy for a given resource.
    @Sendable
    @inlinable
    public func putResourcePolicy(_ input: PutResourcePolicyRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> PutResourcePolicyResponse {
        try await self.client.execute(
            operation: "PutResourcePolicy", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Creates a resource control policy for a given resource.
    ///
    /// Parameters:
    ///   - clientToken: A unique identifier for the request. If you do not set the client request token, Amazon Lookout for Equipment generates one.
    ///   - policyRevisionId: A unique identifier for a revision of the resource policy.
    ///   - resourceArn: The Amazon Resource Name (ARN) of the resource for which the policy is being created.
    ///   - resourcePolicy: The JSON-formatted resource policy to create.
    ///   - logger: Logger use during operation
    @inlinable
    public func putResourcePolicy(
        clientToken: String = PutResourcePolicyRequest.idempotencyToken(),
        policyRevisionId: String? = nil,
        resourceArn: String,
        resourcePolicy: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> PutResourcePolicyResponse {
        let input = PutResourcePolicyRequest(
            clientToken: clientToken, 
            policyRevisionId: policyRevisionId, 
            resourceArn: resourceArn, 
            resourcePolicy: resourcePolicy
        )
        return try await self.putResourcePolicy(input, logger: logger)
    }

    /// Starts a data ingestion job. Amazon Lookout for Equipment returns the job status.
    @Sendable
    @inlinable
    public func startDataIngestionJob(_ input: StartDataIngestionJobRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> StartDataIngestionJobResponse {
        try await self.client.execute(
            operation: "StartDataIngestionJob", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Starts a data ingestion job. Amazon Lookout for Equipment returns the job status.
    ///
    /// Parameters:
    ///   - clientToken:  A unique identifier for the request. If you do not set the client request token, Amazon Lookout for Equipment generates one.
    ///   - datasetName: The name of the dataset being used by the data ingestion job.
    ///   - ingestionInputConfiguration:  Specifies information for the input data for the data ingestion job, including dataset S3 location.
    ///   - roleArn:  The Amazon Resource Name (ARN) of a role with permission to access the data source for the data ingestion job.
    ///   - logger: Logger use during operation
    @inlinable
    public func startDataIngestionJob(
        clientToken: String = StartDataIngestionJobRequest.idempotencyToken(),
        datasetName: String,
        ingestionInputConfiguration: IngestionInputConfiguration,
        roleArn: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> StartDataIngestionJobResponse {
        let input = StartDataIngestionJobRequest(
            clientToken: clientToken, 
            datasetName: datasetName, 
            ingestionInputConfiguration: ingestionInputConfiguration, 
            roleArn: roleArn
        )
        return try await self.startDataIngestionJob(input, logger: logger)
    }

    /// Starts an inference scheduler.
    @Sendable
    @inlinable
    public func startInferenceScheduler(_ input: StartInferenceSchedulerRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> StartInferenceSchedulerResponse {
        try await self.client.execute(
            operation: "StartInferenceScheduler", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Starts an inference scheduler.
    ///
    /// Parameters:
    ///   - inferenceSchedulerName: The name of the inference scheduler to be started.
    ///   - logger: Logger use during operation
    @inlinable
    public func startInferenceScheduler(
        inferenceSchedulerName: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> StartInferenceSchedulerResponse {
        let input = StartInferenceSchedulerRequest(
            inferenceSchedulerName: inferenceSchedulerName
        )
        return try await self.startInferenceScheduler(input, logger: logger)
    }

    /// Starts a retraining scheduler.
    @Sendable
    @inlinable
    public func startRetrainingScheduler(_ input: StartRetrainingSchedulerRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> StartRetrainingSchedulerResponse {
        try await self.client.execute(
            operation: "StartRetrainingScheduler", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Starts a retraining scheduler.
    ///
    /// Parameters:
    ///   - modelName: The name of the model whose retraining scheduler you want to start.
    ///   - logger: Logger use during operation
    @inlinable
    public func startRetrainingScheduler(
        modelName: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> StartRetrainingSchedulerResponse {
        let input = StartRetrainingSchedulerRequest(
            modelName: modelName
        )
        return try await self.startRetrainingScheduler(input, logger: logger)
    }

    /// Stops an inference scheduler.
    @Sendable
    @inlinable
    public func stopInferenceScheduler(_ input: StopInferenceSchedulerRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> StopInferenceSchedulerResponse {
        try await self.client.execute(
            operation: "StopInferenceScheduler", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Stops an inference scheduler.
    ///
    /// Parameters:
    ///   - inferenceSchedulerName: The name of the inference scheduler to be stopped.
    ///   - logger: Logger use during operation
    @inlinable
    public func stopInferenceScheduler(
        inferenceSchedulerName: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> StopInferenceSchedulerResponse {
        let input = StopInferenceSchedulerRequest(
            inferenceSchedulerName: inferenceSchedulerName
        )
        return try await self.stopInferenceScheduler(input, logger: logger)
    }

    /// Stops a retraining scheduler.
    @Sendable
    @inlinable
    public func stopRetrainingScheduler(_ input: StopRetrainingSchedulerRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> StopRetrainingSchedulerResponse {
        try await self.client.execute(
            operation: "StopRetrainingScheduler", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Stops a retraining scheduler.
    ///
    /// Parameters:
    ///   - modelName: The name of the model whose retraining scheduler you want to stop.
    ///   - logger: Logger use during operation
    @inlinable
    public func stopRetrainingScheduler(
        modelName: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> StopRetrainingSchedulerResponse {
        let input = StopRetrainingSchedulerRequest(
            modelName: modelName
        )
        return try await self.stopRetrainingScheduler(input, logger: logger)
    }

    /// Associates a given tag to a resource in your account. A tag is a key-value pair which can be added to an Amazon Lookout for Equipment resource as metadata. Tags can be used for organizing your resources as well as helping you to search and filter by tag. Multiple tags can be added to a resource, either when you create it, or later. Up to 50 tags can be associated with each resource.
    @Sendable
    @inlinable
    public func tagResource(_ input: TagResourceRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> TagResourceResponse {
        try await self.client.execute(
            operation: "TagResource", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Associates a given tag to a resource in your account. A tag is a key-value pair which can be added to an Amazon Lookout for Equipment resource as metadata. Tags can be used for organizing your resources as well as helping you to search and filter by tag. Multiple tags can be added to a resource, either when you create it, or later. Up to 50 tags can be associated with each resource.
    ///
    /// Parameters:
    ///   - resourceArn: The Amazon Resource Name (ARN) of the specific resource to which the tag should be associated.
    ///   - tags: The tag or tags to be associated with a specific resource. Both the tag key and value are specified.
    ///   - logger: Logger use during operation
    @inlinable
    public func tagResource(
        resourceArn: String,
        tags: [Tag],
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> TagResourceResponse {
        let input = TagResourceRequest(
            resourceArn: resourceArn, 
            tags: tags
        )
        return try await self.tagResource(input, logger: logger)
    }

    /// Removes a specific tag from a given resource. The tag is specified by its key.
    @Sendable
    @inlinable
    public func untagResource(_ input: UntagResourceRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> UntagResourceResponse {
        try await self.client.execute(
            operation: "UntagResource", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Removes a specific tag from a given resource. The tag is specified by its key.
    ///
    /// Parameters:
    ///   - resourceArn: The Amazon Resource Name (ARN) of the resource to which the tag is currently associated.
    ///   - tagKeys: Specifies the key of the tag to be removed from a specified resource.
    ///   - logger: Logger use during operation
    @inlinable
    public func untagResource(
        resourceArn: String,
        tagKeys: [String],
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> UntagResourceResponse {
        let input = UntagResourceRequest(
            resourceArn: resourceArn, 
            tagKeys: tagKeys
        )
        return try await self.untagResource(input, logger: logger)
    }

    /// Sets the active model version for a given machine learning model.
    @Sendable
    @inlinable
    public func updateActiveModelVersion(_ input: UpdateActiveModelVersionRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> UpdateActiveModelVersionResponse {
        try await self.client.execute(
            operation: "UpdateActiveModelVersion", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Sets the active model version for a given machine learning model.
    ///
    /// Parameters:
    ///   - modelName: The name of the machine learning model for which the active model version is being set.
    ///   - modelVersion: The version of the machine learning model for which the active model version is being set.
    ///   - logger: Logger use during operation
    @inlinable
    public func updateActiveModelVersion(
        modelName: String,
        modelVersion: Int64,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> UpdateActiveModelVersionResponse {
        let input = UpdateActiveModelVersionRequest(
            modelName: modelName, 
            modelVersion: modelVersion
        )
        return try await self.updateActiveModelVersion(input, logger: logger)
    }

    /// Updates an inference scheduler.
    @Sendable
    @inlinable
    public func updateInferenceScheduler(_ input: UpdateInferenceSchedulerRequest, logger: Logger = AWSClient.loggingDisabled) async throws {
        try await self.client.execute(
            operation: "UpdateInferenceScheduler", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Updates an inference scheduler.
    ///
    /// Parameters:
    ///   - dataDelayOffsetInMinutes:  A period of time (in minutes) by which inference on the data is delayed after the data starts. For instance, if you select an offset delay time of five minutes, inference will not begin on the data until the first data measurement after the five minute mark. For example, if five minutes is selected, the inference scheduler will wake up at the configured frequency with the additional five minute delay time to check the customer S3 bucket. The customer can upload data at the same frequency and they don't need to stop and restart the scheduler when uploading new data.
    ///   - dataInputConfiguration:  Specifies information for the input data for the inference scheduler, including delimiter, format, and dataset location.
    ///   - dataOutputConfiguration:  Specifies information for the output results from the inference scheduler, including the output S3 location.
    ///   - dataUploadFrequency: How often data is uploaded to the source S3 bucket for the input data. The value chosen is the length of time between data uploads. For instance, if you select 5 minutes, Amazon Lookout for Equipment will upload the real-time data to the source bucket once every 5 minutes. This frequency also determines how often Amazon Lookout for Equipment starts a scheduled inference on your data. In this example, it starts once every 5 minutes.
    ///   - inferenceSchedulerName: The name of the inference scheduler to be updated.
    ///   - roleArn:  The Amazon Resource Name (ARN) of a role with permission to access the data source for the inference scheduler.
    ///   - logger: Logger use during operation
    @inlinable
    public func updateInferenceScheduler(
        dataDelayOffsetInMinutes: Int64? = nil,
        dataInputConfiguration: InferenceInputConfiguration? = nil,
        dataOutputConfiguration: InferenceOutputConfiguration? = nil,
        dataUploadFrequency: DataUploadFrequency? = nil,
        inferenceSchedulerName: String,
        roleArn: String? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws {
        let input = UpdateInferenceSchedulerRequest(
            dataDelayOffsetInMinutes: dataDelayOffsetInMinutes, 
            dataInputConfiguration: dataInputConfiguration, 
            dataOutputConfiguration: dataOutputConfiguration, 
            dataUploadFrequency: dataUploadFrequency, 
            inferenceSchedulerName: inferenceSchedulerName, 
            roleArn: roleArn
        )
        return try await self.updateInferenceScheduler(input, logger: logger)
    }

    ///  Updates the label group.
    @Sendable
    @inlinable
    public func updateLabelGroup(_ input: UpdateLabelGroupRequest, logger: Logger = AWSClient.loggingDisabled) async throws {
        try await self.client.execute(
            operation: "UpdateLabelGroup", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    ///  Updates the label group.
    ///
    /// Parameters:
    ///   - faultCodes:  Updates the code indicating the type of anomaly associated with the label.  Data in this field will be retained for service usage. Follow best practices for the security of your data.
    ///   - labelGroupName:  The name of the label group to be updated.
    ///   - logger: Logger use during operation
    @inlinable
    public func updateLabelGroup(
        faultCodes: [String]? = nil,
        labelGroupName: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws {
        let input = UpdateLabelGroupRequest(
            faultCodes: faultCodes, 
            labelGroupName: labelGroupName
        )
        return try await self.updateLabelGroup(input, logger: logger)
    }

    /// Updates a model in the account.
    @Sendable
    @inlinable
    public func updateModel(_ input: UpdateModelRequest, logger: Logger = AWSClient.loggingDisabled) async throws {
        try await self.client.execute(
            operation: "UpdateModel", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Updates a model in the account.
    ///
    /// Parameters:
    ///   - labelsInputConfiguration: 
    ///   - modelDiagnosticsOutputConfiguration: The Amazon S3 location where you want Amazon Lookout for Equipment to save the pointwise model diagnostics for the model. You must also specify the RoleArn request parameter.
    ///   - modelName: The name of the model to update.
    ///   - roleArn: The ARN of the model to update.
    ///   - logger: Logger use during operation
    @inlinable
    public func updateModel(
        labelsInputConfiguration: LabelsInputConfiguration? = nil,
        modelDiagnosticsOutputConfiguration: ModelDiagnosticsOutputConfiguration? = nil,
        modelName: String,
        roleArn: String? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws {
        let input = UpdateModelRequest(
            labelsInputConfiguration: labelsInputConfiguration, 
            modelDiagnosticsOutputConfiguration: modelDiagnosticsOutputConfiguration, 
            modelName: modelName, 
            roleArn: roleArn
        )
        return try await self.updateModel(input, logger: logger)
    }

    /// Updates a retraining scheduler.
    @Sendable
    @inlinable
    public func updateRetrainingScheduler(_ input: UpdateRetrainingSchedulerRequest, logger: Logger = AWSClient.loggingDisabled) async throws {
        try await self.client.execute(
            operation: "UpdateRetrainingScheduler", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Updates a retraining scheduler.
    ///
    /// Parameters:
    ///   - lookbackWindow: The number of past days of data that will be used for retraining.
    ///   - modelName: The name of the model whose retraining scheduler you want to update.
    ///   - promoteMode: Indicates how the service will use new models. In MANAGED mode, new models will automatically be used for inference if they have better performance than the current model. In MANUAL mode, the new models will not be used until they are manually activated.
    ///   - retrainingFrequency: This parameter uses the ISO 8601 standard to set the frequency at which you want retraining to occur in terms of Years, Months, and/or Days (note: other parameters like Time are not currently supported). The minimum value is 30 days (P30D) and the maximum value is 1 year (P1Y). For example, the following values are valid:   P3M15D – Every 3 months and 15 days   P2M – Every 2 months   P150D – Every 150 days
    ///   - retrainingStartDate: The start date for the retraining scheduler. Lookout for Equipment truncates the time you provide to the nearest UTC day.
    ///   - logger: Logger use during operation
    @inlinable
    public func updateRetrainingScheduler(
        lookbackWindow: String? = nil,
        modelName: String,
        promoteMode: ModelPromoteMode? = nil,
        retrainingFrequency: String? = nil,
        retrainingStartDate: Date? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws {
        let input = UpdateRetrainingSchedulerRequest(
            lookbackWindow: lookbackWindow, 
            modelName: modelName, 
            promoteMode: promoteMode, 
            retrainingFrequency: retrainingFrequency, 
            retrainingStartDate: retrainingStartDate
        )
        return try await self.updateRetrainingScheduler(input, logger: logger)
    }
}

extension LookoutEquipment {
    /// Initializer required by `AWSService.with(middlewares:timeout:byteBufferAllocator:options)`. You are not able to use this initializer directly as there are not public
    /// initializers for `AWSServiceConfig.Patch`. Please use `AWSService.with(middlewares:timeout:byteBufferAllocator:options)` instead.
    public init(from: LookoutEquipment, patch: AWSServiceConfig.Patch) {
        self.client = from.client
        self.config = from.config.with(patch: patch)
    }
}

// MARK: Paginators

@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension LookoutEquipment {
    /// Return PaginatorSequence for operation ``listDataIngestionJobs(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func listDataIngestionJobsPaginator(
        _ input: ListDataIngestionJobsRequest,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<ListDataIngestionJobsRequest, ListDataIngestionJobsResponse> {
        return .init(
            input: input,
            command: self.listDataIngestionJobs,
            inputKey: \ListDataIngestionJobsRequest.nextToken,
            outputKey: \ListDataIngestionJobsResponse.nextToken,
            logger: logger
        )
    }
    /// Return PaginatorSequence for operation ``listDataIngestionJobs(_:logger:)``.
    ///
    /// - Parameters:
    ///   - datasetName: The name of the dataset being used for the data ingestion job.
    ///   - maxResults:  Specifies the maximum number of data ingestion jobs to list.
    ///   - status: Indicates the status of the data ingestion job.
    ///   - logger: Logger used for logging
    @inlinable
    public func listDataIngestionJobsPaginator(
        datasetName: String? = nil,
        maxResults: Int? = nil,
        status: IngestionJobStatus? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) -> AWSClient.PaginatorSequence<ListDataIngestionJobsRequest, ListDataIngestionJobsResponse> {
        let input = ListDataIngestionJobsRequest(
            datasetName: datasetName, 
            maxResults: maxResults, 
            status: status
        )
        return self.listDataIngestionJobsPaginator(input, logger: logger)
    }

    /// Return PaginatorSequence for operation ``listDatasets(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func listDatasetsPaginator(
        _ input: ListDatasetsRequest,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<ListDatasetsRequest, ListDatasetsResponse> {
        return .init(
            input: input,
            command: self.listDatasets,
            inputKey: \ListDatasetsRequest.nextToken,
            outputKey: \ListDatasetsResponse.nextToken,
            logger: logger
        )
    }
    /// Return PaginatorSequence for operation ``listDatasets(_:logger:)``.
    ///
    /// - Parameters:
    ///   - datasetNameBeginsWith: The beginning of the name of the datasets to be listed.
    ///   - maxResults:  Specifies the maximum number of datasets to list.
    ///   - logger: Logger used for logging
    @inlinable
    public func listDatasetsPaginator(
        datasetNameBeginsWith: String? = nil,
        maxResults: Int? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) -> AWSClient.PaginatorSequence<ListDatasetsRequest, ListDatasetsResponse> {
        let input = ListDatasetsRequest(
            datasetNameBeginsWith: datasetNameBeginsWith, 
            maxResults: maxResults
        )
        return self.listDatasetsPaginator(input, logger: logger)
    }

    /// Return PaginatorSequence for operation ``listInferenceEvents(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func listInferenceEventsPaginator(
        _ input: ListInferenceEventsRequest,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<ListInferenceEventsRequest, ListInferenceEventsResponse> {
        return .init(
            input: input,
            command: self.listInferenceEvents,
            inputKey: \ListInferenceEventsRequest.nextToken,
            outputKey: \ListInferenceEventsResponse.nextToken,
            logger: logger
        )
    }
    /// Return PaginatorSequence for operation ``listInferenceEvents(_:logger:)``.
    ///
    /// - Parameters:
    ///   - inferenceSchedulerName: The name of the inference scheduler for the inference events listed.
    ///   - intervalEndTime: Returns all the inference events with an end start time equal to or greater than less than the end time given.
    ///   - intervalStartTime:  Lookout for Equipment will return all the inference events with an end time equal to or greater than the start time given.
    ///   - maxResults: Specifies the maximum number of inference events to list.
    ///   - logger: Logger used for logging
    @inlinable
    public func listInferenceEventsPaginator(
        inferenceSchedulerName: String,
        intervalEndTime: Date,
        intervalStartTime: Date,
        maxResults: Int? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) -> AWSClient.PaginatorSequence<ListInferenceEventsRequest, ListInferenceEventsResponse> {
        let input = ListInferenceEventsRequest(
            inferenceSchedulerName: inferenceSchedulerName, 
            intervalEndTime: intervalEndTime, 
            intervalStartTime: intervalStartTime, 
            maxResults: maxResults
        )
        return self.listInferenceEventsPaginator(input, logger: logger)
    }

    /// Return PaginatorSequence for operation ``listInferenceExecutions(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func listInferenceExecutionsPaginator(
        _ input: ListInferenceExecutionsRequest,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<ListInferenceExecutionsRequest, ListInferenceExecutionsResponse> {
        return .init(
            input: input,
            command: self.listInferenceExecutions,
            inputKey: \ListInferenceExecutionsRequest.nextToken,
            outputKey: \ListInferenceExecutionsResponse.nextToken,
            logger: logger
        )
    }
    /// Return PaginatorSequence for operation ``listInferenceExecutions(_:logger:)``.
    ///
    /// - Parameters:
    ///   - dataEndTimeBefore: The time reference in the inferenced dataset before which Amazon Lookout for Equipment stopped the inference execution.
    ///   - dataStartTimeAfter: The time reference in the inferenced dataset after which Amazon Lookout for Equipment started the inference execution.
    ///   - inferenceSchedulerName: The name of the inference scheduler for the inference execution listed.
    ///   - maxResults: Specifies the maximum number of inference executions to list.
    ///   - status: The status of the inference execution.
    ///   - logger: Logger used for logging
    @inlinable
    public func listInferenceExecutionsPaginator(
        dataEndTimeBefore: Date? = nil,
        dataStartTimeAfter: Date? = nil,
        inferenceSchedulerName: String,
        maxResults: Int? = nil,
        status: InferenceExecutionStatus? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) -> AWSClient.PaginatorSequence<ListInferenceExecutionsRequest, ListInferenceExecutionsResponse> {
        let input = ListInferenceExecutionsRequest(
            dataEndTimeBefore: dataEndTimeBefore, 
            dataStartTimeAfter: dataStartTimeAfter, 
            inferenceSchedulerName: inferenceSchedulerName, 
            maxResults: maxResults, 
            status: status
        )
        return self.listInferenceExecutionsPaginator(input, logger: logger)
    }

    /// Return PaginatorSequence for operation ``listInferenceSchedulers(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func listInferenceSchedulersPaginator(
        _ input: ListInferenceSchedulersRequest,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<ListInferenceSchedulersRequest, ListInferenceSchedulersResponse> {
        return .init(
            input: input,
            command: self.listInferenceSchedulers,
            inputKey: \ListInferenceSchedulersRequest.nextToken,
            outputKey: \ListInferenceSchedulersResponse.nextToken,
            logger: logger
        )
    }
    /// Return PaginatorSequence for operation ``listInferenceSchedulers(_:logger:)``.
    ///
    /// - Parameters:
    ///   - inferenceSchedulerNameBeginsWith: The beginning of the name of the inference schedulers to be listed.
    ///   - maxResults:  Specifies the maximum number of inference schedulers to list.
    ///   - modelName: The name of the machine learning model used by the inference scheduler to be listed.
    ///   - status: Specifies the current status of the inference schedulers.
    ///   - logger: Logger used for logging
    @inlinable
    public func listInferenceSchedulersPaginator(
        inferenceSchedulerNameBeginsWith: String? = nil,
        maxResults: Int? = nil,
        modelName: String? = nil,
        status: InferenceSchedulerStatus? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) -> AWSClient.PaginatorSequence<ListInferenceSchedulersRequest, ListInferenceSchedulersResponse> {
        let input = ListInferenceSchedulersRequest(
            inferenceSchedulerNameBeginsWith: inferenceSchedulerNameBeginsWith, 
            maxResults: maxResults, 
            modelName: modelName, 
            status: status
        )
        return self.listInferenceSchedulersPaginator(input, logger: logger)
    }

    /// Return PaginatorSequence for operation ``listLabelGroups(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func listLabelGroupsPaginator(
        _ input: ListLabelGroupsRequest,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<ListLabelGroupsRequest, ListLabelGroupsResponse> {
        return .init(
            input: input,
            command: self.listLabelGroups,
            inputKey: \ListLabelGroupsRequest.nextToken,
            outputKey: \ListLabelGroupsResponse.nextToken,
            logger: logger
        )
    }
    /// Return PaginatorSequence for operation ``listLabelGroups(_:logger:)``.
    ///
    /// - Parameters:
    ///   - labelGroupNameBeginsWith:  The beginning of the name of the label groups to be listed.
    ///   - maxResults:  Specifies the maximum number of label groups to list.
    ///   - logger: Logger used for logging
    @inlinable
    public func listLabelGroupsPaginator(
        labelGroupNameBeginsWith: String? = nil,
        maxResults: Int? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) -> AWSClient.PaginatorSequence<ListLabelGroupsRequest, ListLabelGroupsResponse> {
        let input = ListLabelGroupsRequest(
            labelGroupNameBeginsWith: labelGroupNameBeginsWith, 
            maxResults: maxResults
        )
        return self.listLabelGroupsPaginator(input, logger: logger)
    }

    /// Return PaginatorSequence for operation ``listLabels(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func listLabelsPaginator(
        _ input: ListLabelsRequest,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<ListLabelsRequest, ListLabelsResponse> {
        return .init(
            input: input,
            command: self.listLabels,
            inputKey: \ListLabelsRequest.nextToken,
            outputKey: \ListLabelsResponse.nextToken,
            logger: logger
        )
    }
    /// Return PaginatorSequence for operation ``listLabels(_:logger:)``.
    ///
    /// - Parameters:
    ///   - equipment:  Lists the labels that pertain to a particular piece of equipment.
    ///   - faultCode:  Returns labels with a particular fault code.
    ///   - intervalEndTime:  Returns all labels with a start time earlier than the end time given.
    ///   - intervalStartTime:  Returns all the labels with a end time equal to or later than the start time given.
    ///   - labelGroupName:  Returns the name of the label group.
    ///   - maxResults:  Specifies the maximum number of labels to list.
    ///   - logger: Logger used for logging
    @inlinable
    public func listLabelsPaginator(
        equipment: String? = nil,
        faultCode: String? = nil,
        intervalEndTime: Date? = nil,
        intervalStartTime: Date? = nil,
        labelGroupName: String,
        maxResults: Int? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) -> AWSClient.PaginatorSequence<ListLabelsRequest, ListLabelsResponse> {
        let input = ListLabelsRequest(
            equipment: equipment, 
            faultCode: faultCode, 
            intervalEndTime: intervalEndTime, 
            intervalStartTime: intervalStartTime, 
            labelGroupName: labelGroupName, 
            maxResults: maxResults
        )
        return self.listLabelsPaginator(input, logger: logger)
    }

    /// Return PaginatorSequence for operation ``listModelVersions(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func listModelVersionsPaginator(
        _ input: ListModelVersionsRequest,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<ListModelVersionsRequest, ListModelVersionsResponse> {
        return .init(
            input: input,
            command: self.listModelVersions,
            inputKey: \ListModelVersionsRequest.nextToken,
            outputKey: \ListModelVersionsResponse.nextToken,
            logger: logger
        )
    }
    /// Return PaginatorSequence for operation ``listModelVersions(_:logger:)``.
    ///
    /// - Parameters:
    ///   - createdAtEndTime: Filter results to return all the model versions created before this time.
    ///   - createdAtStartTime: Filter results to return all the model versions created after this time.
    ///   - maxModelVersion: Specifies the highest version of the model to return in the list.
    ///   - maxResults: Specifies the maximum number of machine learning model versions to list.
    ///   - minModelVersion: Specifies the lowest version of the model to return in the list.
    ///   - modelName: Then name of the machine learning model for which the model versions are to be listed.
    ///   - sourceType: Filter the results based on the way the model version was generated.
    ///   - status: Filter the results based on the current status of the model version.
    ///   - logger: Logger used for logging
    @inlinable
    public func listModelVersionsPaginator(
        createdAtEndTime: Date? = nil,
        createdAtStartTime: Date? = nil,
        maxModelVersion: Int64? = nil,
        maxResults: Int? = nil,
        minModelVersion: Int64? = nil,
        modelName: String,
        sourceType: ModelVersionSourceType? = nil,
        status: ModelVersionStatus? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) -> AWSClient.PaginatorSequence<ListModelVersionsRequest, ListModelVersionsResponse> {
        let input = ListModelVersionsRequest(
            createdAtEndTime: createdAtEndTime, 
            createdAtStartTime: createdAtStartTime, 
            maxModelVersion: maxModelVersion, 
            maxResults: maxResults, 
            minModelVersion: minModelVersion, 
            modelName: modelName, 
            sourceType: sourceType, 
            status: status
        )
        return self.listModelVersionsPaginator(input, logger: logger)
    }

    /// Return PaginatorSequence for operation ``listModels(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func listModelsPaginator(
        _ input: ListModelsRequest,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<ListModelsRequest, ListModelsResponse> {
        return .init(
            input: input,
            command: self.listModels,
            inputKey: \ListModelsRequest.nextToken,
            outputKey: \ListModelsResponse.nextToken,
            logger: logger
        )
    }
    /// Return PaginatorSequence for operation ``listModels(_:logger:)``.
    ///
    /// - Parameters:
    ///   - datasetNameBeginsWith: The beginning of the name of the dataset of the machine learning models to be listed.
    ///   - maxResults:  Specifies the maximum number of machine learning models to list.
    ///   - modelNameBeginsWith: The beginning of the name of the machine learning models being listed.
    ///   - status: The status of the machine learning model.
    ///   - logger: Logger used for logging
    @inlinable
    public func listModelsPaginator(
        datasetNameBeginsWith: String? = nil,
        maxResults: Int? = nil,
        modelNameBeginsWith: String? = nil,
        status: ModelStatus? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) -> AWSClient.PaginatorSequence<ListModelsRequest, ListModelsResponse> {
        let input = ListModelsRequest(
            datasetNameBeginsWith: datasetNameBeginsWith, 
            maxResults: maxResults, 
            modelNameBeginsWith: modelNameBeginsWith, 
            status: status
        )
        return self.listModelsPaginator(input, logger: logger)
    }

    /// Return PaginatorSequence for operation ``listRetrainingSchedulers(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func listRetrainingSchedulersPaginator(
        _ input: ListRetrainingSchedulersRequest,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<ListRetrainingSchedulersRequest, ListRetrainingSchedulersResponse> {
        return .init(
            input: input,
            command: self.listRetrainingSchedulers,
            inputKey: \ListRetrainingSchedulersRequest.nextToken,
            outputKey: \ListRetrainingSchedulersResponse.nextToken,
            logger: logger
        )
    }
    /// Return PaginatorSequence for operation ``listRetrainingSchedulers(_:logger:)``.
    ///
    /// - Parameters:
    ///   - maxResults: Specifies the maximum number of retraining schedulers to list.
    ///   - modelNameBeginsWith: Specify this field to only list retraining schedulers whose machine learning models begin with the value you specify.
    ///   - status: Specify this field to only list retraining schedulers whose status matches the value you specify.
    ///   - logger: Logger used for logging
    @inlinable
    public func listRetrainingSchedulersPaginator(
        maxResults: Int? = nil,
        modelNameBeginsWith: String? = nil,
        status: RetrainingSchedulerStatus? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) -> AWSClient.PaginatorSequence<ListRetrainingSchedulersRequest, ListRetrainingSchedulersResponse> {
        let input = ListRetrainingSchedulersRequest(
            maxResults: maxResults, 
            modelNameBeginsWith: modelNameBeginsWith, 
            status: status
        )
        return self.listRetrainingSchedulersPaginator(input, logger: logger)
    }

    /// Return PaginatorSequence for operation ``listSensorStatistics(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func listSensorStatisticsPaginator(
        _ input: ListSensorStatisticsRequest,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<ListSensorStatisticsRequest, ListSensorStatisticsResponse> {
        return .init(
            input: input,
            command: self.listSensorStatistics,
            inputKey: \ListSensorStatisticsRequest.nextToken,
            outputKey: \ListSensorStatisticsResponse.nextToken,
            logger: logger
        )
    }
    /// Return PaginatorSequence for operation ``listSensorStatistics(_:logger:)``.
    ///
    /// - Parameters:
    ///   - datasetName:  The name of the dataset associated with the list of Sensor Statistics.
    ///   - ingestionJobId:  The ingestion job id associated with the list of Sensor Statistics. To get sensor statistics for a particular ingestion job id, both dataset name and ingestion job id must be submitted as inputs.
    ///   - maxResults: Specifies the maximum number of sensors for which to retrieve statistics.
    ///   - logger: Logger used for logging
    @inlinable
    public func listSensorStatisticsPaginator(
        datasetName: String,
        ingestionJobId: String? = nil,
        maxResults: Int? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) -> AWSClient.PaginatorSequence<ListSensorStatisticsRequest, ListSensorStatisticsResponse> {
        let input = ListSensorStatisticsRequest(
            datasetName: datasetName, 
            ingestionJobId: ingestionJobId, 
            maxResults: maxResults
        )
        return self.listSensorStatisticsPaginator(input, logger: logger)
    }
}

extension LookoutEquipment.ListDataIngestionJobsRequest: AWSPaginateToken {
    @inlinable
    public func usingPaginationToken(_ token: String) -> LookoutEquipment.ListDataIngestionJobsRequest {
        return .init(
            datasetName: self.datasetName,
            maxResults: self.maxResults,
            nextToken: token,
            status: self.status
        )
    }
}

extension LookoutEquipment.ListDatasetsRequest: AWSPaginateToken {
    @inlinable
    public func usingPaginationToken(_ token: String) -> LookoutEquipment.ListDatasetsRequest {
        return .init(
            datasetNameBeginsWith: self.datasetNameBeginsWith,
            maxResults: self.maxResults,
            nextToken: token
        )
    }
}

extension LookoutEquipment.ListInferenceEventsRequest: AWSPaginateToken {
    @inlinable
    public func usingPaginationToken(_ token: String) -> LookoutEquipment.ListInferenceEventsRequest {
        return .init(
            inferenceSchedulerName: self.inferenceSchedulerName,
            intervalEndTime: self.intervalEndTime,
            intervalStartTime: self.intervalStartTime,
            maxResults: self.maxResults,
            nextToken: token
        )
    }
}

extension LookoutEquipment.ListInferenceExecutionsRequest: AWSPaginateToken {
    @inlinable
    public func usingPaginationToken(_ token: String) -> LookoutEquipment.ListInferenceExecutionsRequest {
        return .init(
            dataEndTimeBefore: self.dataEndTimeBefore,
            dataStartTimeAfter: self.dataStartTimeAfter,
            inferenceSchedulerName: self.inferenceSchedulerName,
            maxResults: self.maxResults,
            nextToken: token,
            status: self.status
        )
    }
}

extension LookoutEquipment.ListInferenceSchedulersRequest: AWSPaginateToken {
    @inlinable
    public func usingPaginationToken(_ token: String) -> LookoutEquipment.ListInferenceSchedulersRequest {
        return .init(
            inferenceSchedulerNameBeginsWith: self.inferenceSchedulerNameBeginsWith,
            maxResults: self.maxResults,
            modelName: self.modelName,
            nextToken: token,
            status: self.status
        )
    }
}

extension LookoutEquipment.ListLabelGroupsRequest: AWSPaginateToken {
    @inlinable
    public func usingPaginationToken(_ token: String) -> LookoutEquipment.ListLabelGroupsRequest {
        return .init(
            labelGroupNameBeginsWith: self.labelGroupNameBeginsWith,
            maxResults: self.maxResults,
            nextToken: token
        )
    }
}

extension LookoutEquipment.ListLabelsRequest: AWSPaginateToken {
    @inlinable
    public func usingPaginationToken(_ token: String) -> LookoutEquipment.ListLabelsRequest {
        return .init(
            equipment: self.equipment,
            faultCode: self.faultCode,
            intervalEndTime: self.intervalEndTime,
            intervalStartTime: self.intervalStartTime,
            labelGroupName: self.labelGroupName,
            maxResults: self.maxResults,
            nextToken: token
        )
    }
}

extension LookoutEquipment.ListModelVersionsRequest: AWSPaginateToken {
    @inlinable
    public func usingPaginationToken(_ token: String) -> LookoutEquipment.ListModelVersionsRequest {
        return .init(
            createdAtEndTime: self.createdAtEndTime,
            createdAtStartTime: self.createdAtStartTime,
            maxModelVersion: self.maxModelVersion,
            maxResults: self.maxResults,
            minModelVersion: self.minModelVersion,
            modelName: self.modelName,
            nextToken: token,
            sourceType: self.sourceType,
            status: self.status
        )
    }
}

extension LookoutEquipment.ListModelsRequest: AWSPaginateToken {
    @inlinable
    public func usingPaginationToken(_ token: String) -> LookoutEquipment.ListModelsRequest {
        return .init(
            datasetNameBeginsWith: self.datasetNameBeginsWith,
            maxResults: self.maxResults,
            modelNameBeginsWith: self.modelNameBeginsWith,
            nextToken: token,
            status: self.status
        )
    }
}

extension LookoutEquipment.ListRetrainingSchedulersRequest: AWSPaginateToken {
    @inlinable
    public func usingPaginationToken(_ token: String) -> LookoutEquipment.ListRetrainingSchedulersRequest {
        return .init(
            maxResults: self.maxResults,
            modelNameBeginsWith: self.modelNameBeginsWith,
            nextToken: token,
            status: self.status
        )
    }
}

extension LookoutEquipment.ListSensorStatisticsRequest: AWSPaginateToken {
    @inlinable
    public func usingPaginationToken(_ token: String) -> LookoutEquipment.ListSensorStatisticsRequest {
        return .init(
            datasetName: self.datasetName,
            ingestionJobId: self.ingestionJobId,
            maxResults: self.maxResults,
            nextToken: token
        )
    }
}
