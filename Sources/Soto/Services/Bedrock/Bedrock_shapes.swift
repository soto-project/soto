//===----------------------------------------------------------------------===//
//
// This source file is part of the Soto for AWS open source project
//
// Copyright (c) 2017-2024 the Soto project authors
// Licensed under Apache License v2.0
//
// See LICENSE.txt for license information
// See CONTRIBUTORS.txt for the list of Soto project authors
//
// SPDX-License-Identifier: Apache-2.0
//
//===----------------------------------------------------------------------===//

// THIS FILE IS AUTOMATICALLY GENERATED by https://github.com/soto-project/soto-codegenerator.
// DO NOT EDIT.

#if os(Linux) && compiler(<5.10)
// swift-corelibs-foundation hasn't been updated with Sendable conformances
@preconcurrency import Foundation
#else
import Foundation
#endif
@_spi(SotoInternal) import SotoCore

extension Bedrock {
    // MARK: Enums

    public enum ApplicationType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case modelEvaluation = "ModelEvaluation"
        case ragEvaluation = "RagEvaluation"
        public var description: String { return self.rawValue }
    }

    public enum CommitmentDuration: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case oneMonth = "OneMonth"
        case sixMonths = "SixMonths"
        public var description: String { return self.rawValue }
    }

    public enum CustomizationType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case continuedPreTraining = "CONTINUED_PRE_TRAINING"
        case distillation = "DISTILLATION"
        case fineTuning = "FINE_TUNING"
        public var description: String { return self.rawValue }
    }

    public enum EvaluationJobStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case completed = "Completed"
        case deleting = "Deleting"
        case failed = "Failed"
        case inProgress = "InProgress"
        case stopped = "Stopped"
        case stopping = "Stopping"
        public var description: String { return self.rawValue }
    }

    public enum EvaluationJobType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case automated = "Automated"
        case human = "Human"
        public var description: String { return self.rawValue }
    }

    public enum EvaluationTaskType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case classification = "Classification"
        case custom = "Custom"
        case generation = "Generation"
        case questionAndAnswer = "QuestionAndAnswer"
        case summarization = "Summarization"
        public var description: String { return self.rawValue }
    }

    public enum ExternalSourceType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case byteContent = "BYTE_CONTENT"
        case s3 = "S3"
        public var description: String { return self.rawValue }
    }

    public enum FineTuningJobStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case completed = "Completed"
        case failed = "Failed"
        case inProgress = "InProgress"
        case stopped = "Stopped"
        case stopping = "Stopping"
        public var description: String { return self.rawValue }
    }

    public enum FoundationModelLifecycleStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case active = "ACTIVE"
        case legacy = "LEGACY"
        public var description: String { return self.rawValue }
    }

    public enum GuardrailContentFilterType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case hate = "HATE"
        case insults = "INSULTS"
        case misconduct = "MISCONDUCT"
        case promptAttack = "PROMPT_ATTACK"
        case sexual = "SEXUAL"
        case violence = "VIOLENCE"
        public var description: String { return self.rawValue }
    }

    public enum GuardrailContextualGroundingFilterType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case grounding = "GROUNDING"
        case relevance = "RELEVANCE"
        public var description: String { return self.rawValue }
    }

    public enum GuardrailFilterStrength: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case high = "HIGH"
        case low = "LOW"
        case medium = "MEDIUM"
        case none = "NONE"
        public var description: String { return self.rawValue }
    }

    public enum GuardrailManagedWordsType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case profanity = "PROFANITY"
        public var description: String { return self.rawValue }
    }

    public enum GuardrailModality: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case image = "IMAGE"
        case text = "TEXT"
        public var description: String { return self.rawValue }
    }

    public enum GuardrailPiiEntityType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case address = "ADDRESS"
        case age = "AGE"
        case awsAccessKey = "AWS_ACCESS_KEY"
        case awsSecretKey = "AWS_SECRET_KEY"
        case caHealthNumber = "CA_HEALTH_NUMBER"
        case caSocialInsuranceNumber = "CA_SOCIAL_INSURANCE_NUMBER"
        case creditDebitCardCvv = "CREDIT_DEBIT_CARD_CVV"
        case creditDebitCardExpiry = "CREDIT_DEBIT_CARD_EXPIRY"
        case creditDebitCardNumber = "CREDIT_DEBIT_CARD_NUMBER"
        case driverId = "DRIVER_ID"
        case email = "EMAIL"
        case internationalBankAccountNumber = "INTERNATIONAL_BANK_ACCOUNT_NUMBER"
        case ipAddress = "IP_ADDRESS"
        case licensePlate = "LICENSE_PLATE"
        case macAddress = "MAC_ADDRESS"
        case name = "NAME"
        case password = "PASSWORD"
        case phone = "PHONE"
        case pin = "PIN"
        case swiftCode = "SWIFT_CODE"
        case ukNationalHealthServiceNumber = "UK_NATIONAL_HEALTH_SERVICE_NUMBER"
        case ukNationalInsuranceNumber = "UK_NATIONAL_INSURANCE_NUMBER"
        case ukUniqueTaxpayerReferenceNumber = "UK_UNIQUE_TAXPAYER_REFERENCE_NUMBER"
        case url = "URL"
        case usBankAccountNumber = "US_BANK_ACCOUNT_NUMBER"
        case usBankRoutingNumber = "US_BANK_ROUTING_NUMBER"
        case usIndividualTaxIdentificationNumber = "US_INDIVIDUAL_TAX_IDENTIFICATION_NUMBER"
        case usPassportNumber = "US_PASSPORT_NUMBER"
        case usSocialSecurityNumber = "US_SOCIAL_SECURITY_NUMBER"
        case username = "USERNAME"
        case vehicleIdentificationNumber = "VEHICLE_IDENTIFICATION_NUMBER"
        public var description: String { return self.rawValue }
    }

    public enum GuardrailSensitiveInformationAction: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case anonymize = "ANONYMIZE"
        case block = "BLOCK"
        public var description: String { return self.rawValue }
    }

    public enum GuardrailStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case creating = "CREATING"
        case deleting = "DELETING"
        case failed = "FAILED"
        case ready = "READY"
        case updating = "UPDATING"
        case versioning = "VERSIONING"
        public var description: String { return self.rawValue }
    }

    public enum GuardrailTopicType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case deny = "DENY"
        public var description: String { return self.rawValue }
    }

    public enum InferenceProfileStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case active = "ACTIVE"
        public var description: String { return self.rawValue }
    }

    public enum InferenceProfileType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case application = "APPLICATION"
        case systemDefined = "SYSTEM_DEFINED"
        public var description: String { return self.rawValue }
    }

    public enum InferenceType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case onDemand = "ON_DEMAND"
        case provisioned = "PROVISIONED"
        public var description: String { return self.rawValue }
    }

    public enum ModelCopyJobStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case completed = "Completed"
        case failed = "Failed"
        case inProgress = "InProgress"
        public var description: String { return self.rawValue }
    }

    public enum ModelCustomization: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case continuedPreTraining = "CONTINUED_PRE_TRAINING"
        case distillation = "DISTILLATION"
        case fineTuning = "FINE_TUNING"
        public var description: String { return self.rawValue }
    }

    public enum ModelCustomizationJobStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case completed = "Completed"
        case failed = "Failed"
        case inProgress = "InProgress"
        case stopped = "Stopped"
        case stopping = "Stopping"
        public var description: String { return self.rawValue }
    }

    public enum ModelImportJobStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case completed = "Completed"
        case failed = "Failed"
        case inProgress = "InProgress"
        public var description: String { return self.rawValue }
    }

    public enum ModelInvocationJobStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case completed = "Completed"
        case expired = "Expired"
        case failed = "Failed"
        case inProgress = "InProgress"
        case partiallyCompleted = "PartiallyCompleted"
        case scheduled = "Scheduled"
        case stopped = "Stopped"
        case stopping = "Stopping"
        case submitted = "Submitted"
        case validating = "Validating"
        public var description: String { return self.rawValue }
    }

    public enum ModelModality: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case embedding = "EMBEDDING"
        case image = "IMAGE"
        case text = "TEXT"
        public var description: String { return self.rawValue }
    }

    public enum PromptRouterStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case available = "AVAILABLE"
        public var description: String { return self.rawValue }
    }

    public enum PromptRouterType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case `default` = "default"
        case custom = "custom"
        public var description: String { return self.rawValue }
    }

    public enum ProvisionedModelStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case creating = "Creating"
        case failed = "Failed"
        case inService = "InService"
        case updating = "Updating"
        public var description: String { return self.rawValue }
    }

    public enum QueryTransformationType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case queryDecomposition = "QUERY_DECOMPOSITION"
        public var description: String { return self.rawValue }
    }

    public enum RetrieveAndGenerateType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case externalSources = "EXTERNAL_SOURCES"
        case knowledgeBase = "KNOWLEDGE_BASE"
        public var description: String { return self.rawValue }
    }

    public enum S3InputFormat: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case jsonl = "JSONL"
        public var description: String { return self.rawValue }
    }

    public enum SearchType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case hybrid = "HYBRID"
        case semantic = "SEMANTIC"
        public var description: String { return self.rawValue }
    }

    public enum SortByProvisionedModels: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case creationTime = "CreationTime"
        public var description: String { return self.rawValue }
    }

    public enum SortJobsBy: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case creationTime = "CreationTime"
        public var description: String { return self.rawValue }
    }

    public enum SortModelsBy: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case creationTime = "CreationTime"
        public var description: String { return self.rawValue }
    }

    public enum SortOrder: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case ascending = "Ascending"
        case descending = "Descending"
        public var description: String { return self.rawValue }
    }

    public enum Status: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case incompatibleEndpoint = "INCOMPATIBLE_ENDPOINT"
        case registered = "REGISTERED"
        public var description: String { return self.rawValue }
    }

    public enum EvaluationConfig: AWSEncodableShape & AWSDecodableShape, Sendable {
        /// Contains the configuration details of an automated evaluation job that computes metrics.
        case automated(AutomatedEvaluationConfig)
        /// Contains the configuration details of an evaluation job that uses human workers.
        case human(HumanEvaluationConfig)

        public init(from decoder: Decoder) throws {
            let container = try decoder.container(keyedBy: CodingKeys.self)
            guard container.allKeys.count == 1, let key = container.allKeys.first else {
                let context = DecodingError.Context(
                    codingPath: container.codingPath,
                    debugDescription: "Expected exactly one key, but got \(container.allKeys.count)"
                )
                throw DecodingError.dataCorrupted(context)
            }
            switch key {
            case .automated:
                let value = try container.decode(AutomatedEvaluationConfig.self, forKey: .automated)
                self = .automated(value)
            case .human:
                let value = try container.decode(HumanEvaluationConfig.self, forKey: .human)
                self = .human(value)
            }
        }

        public func encode(to encoder: Encoder) throws {
            var container = encoder.container(keyedBy: CodingKeys.self)
            switch self {
            case .automated(let value):
                try container.encode(value, forKey: .automated)
            case .human(let value):
                try container.encode(value, forKey: .human)
            }
        }

        public func validate(name: String) throws {
            switch self {
            case .automated(let value):
                try value.validate(name: "\(name).automated")
            case .human(let value):
                try value.validate(name: "\(name).human")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case automated = "automated"
            case human = "human"
        }
    }

    public enum EvaluationInferenceConfig: AWSEncodableShape & AWSDecodableShape, Sendable {
        /// Specifies the inference models.
        case models([EvaluationModelConfig])
        /// Contains the configuration details of the inference for a knowledge base evaluation  job, including either the retrieval only configuration or the retrieval with response  generation configuration.
        case ragConfigs([RAGConfig])

        public init(from decoder: Decoder) throws {
            let container = try decoder.container(keyedBy: CodingKeys.self)
            guard container.allKeys.count == 1, let key = container.allKeys.first else {
                let context = DecodingError.Context(
                    codingPath: container.codingPath,
                    debugDescription: "Expected exactly one key, but got \(container.allKeys.count)"
                )
                throw DecodingError.dataCorrupted(context)
            }
            switch key {
            case .models:
                let value = try container.decode([EvaluationModelConfig].self, forKey: .models)
                self = .models(value)
            case .ragConfigs:
                let value = try container.decode([RAGConfig].self, forKey: .ragConfigs)
                self = .ragConfigs(value)
            }
        }

        public func encode(to encoder: Encoder) throws {
            var container = encoder.container(keyedBy: CodingKeys.self)
            switch self {
            case .models(let value):
                try container.encode(value, forKey: .models)
            case .ragConfigs(let value):
                try container.encode(value, forKey: .ragConfigs)
            }
        }

        public func validate(name: String) throws {
            switch self {
            case .models(let value):
                try value.forEach {
                    try $0.validate(name: "\(name).models[]")
                }
                try self.validate(value, name: "models", parent: name, max: 2)
                try self.validate(value, name: "models", parent: name, min: 1)
            case .ragConfigs(let value):
                try value.forEach {
                    try $0.validate(name: "\(name).ragConfigs[]")
                }
                try self.validate(value, name: "ragConfigs", parent: name, max: 1)
                try self.validate(value, name: "ragConfigs", parent: name, min: 1)
            }
        }

        private enum CodingKeys: String, CodingKey {
            case models = "models"
            case ragConfigs = "ragConfigs"
        }
    }

    public enum KnowledgeBaseConfig: AWSEncodableShape & AWSDecodableShape, Sendable {
        /// Contains configuration details for retrieving information from a knowledge base and generating responses.
        case retrieveAndGenerateConfig(RetrieveAndGenerateConfiguration)
        /// Contains configuration details for retrieving information from a knowledge base.
        case retrieveConfig(RetrieveConfig)

        public init(from decoder: Decoder) throws {
            let container = try decoder.container(keyedBy: CodingKeys.self)
            guard container.allKeys.count == 1, let key = container.allKeys.first else {
                let context = DecodingError.Context(
                    codingPath: container.codingPath,
                    debugDescription: "Expected exactly one key, but got \(container.allKeys.count)"
                )
                throw DecodingError.dataCorrupted(context)
            }
            switch key {
            case .retrieveAndGenerateConfig:
                let value = try container.decode(RetrieveAndGenerateConfiguration.self, forKey: .retrieveAndGenerateConfig)
                self = .retrieveAndGenerateConfig(value)
            case .retrieveConfig:
                let value = try container.decode(RetrieveConfig.self, forKey: .retrieveConfig)
                self = .retrieveConfig(value)
            }
        }

        public func encode(to encoder: Encoder) throws {
            var container = encoder.container(keyedBy: CodingKeys.self)
            switch self {
            case .retrieveAndGenerateConfig(let value):
                try container.encode(value, forKey: .retrieveAndGenerateConfig)
            case .retrieveConfig(let value):
                try container.encode(value, forKey: .retrieveConfig)
            }
        }

        public func validate(name: String) throws {
            switch self {
            case .retrieveAndGenerateConfig(let value):
                try value.validate(name: "\(name).retrieveAndGenerateConfig")
            case .retrieveConfig(let value):
                try value.validate(name: "\(name).retrieveConfig")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case retrieveAndGenerateConfig = "retrieveAndGenerateConfig"
            case retrieveConfig = "retrieveConfig"
        }
    }

    public enum RequestMetadataFilters: AWSEncodableShape & AWSDecodableShape, Sendable {
        /// Include results where all of the based filters match.
        case andAll([RequestMetadataBaseFilters])
        /// Include results where the key equals the value.
        case equals([String: String])
        /// Include results where the key does not equal the value.
        case notEquals([String: String])
        /// Include results where any of the base filters match.
        case orAll([RequestMetadataBaseFilters])

        public init(from decoder: Decoder) throws {
            let container = try decoder.container(keyedBy: CodingKeys.self)
            guard container.allKeys.count == 1, let key = container.allKeys.first else {
                let context = DecodingError.Context(
                    codingPath: container.codingPath,
                    debugDescription: "Expected exactly one key, but got \(container.allKeys.count)"
                )
                throw DecodingError.dataCorrupted(context)
            }
            switch key {
            case .andAll:
                let value = try container.decode([RequestMetadataBaseFilters].self, forKey: .andAll)
                self = .andAll(value)
            case .equals:
                let value = try container.decode([String: String].self, forKey: .equals)
                self = .equals(value)
            case .notEquals:
                let value = try container.decode([String: String].self, forKey: .notEquals)
                self = .notEquals(value)
            case .orAll:
                let value = try container.decode([RequestMetadataBaseFilters].self, forKey: .orAll)
                self = .orAll(value)
            }
        }

        public func encode(to encoder: Encoder) throws {
            var container = encoder.container(keyedBy: CodingKeys.self)
            switch self {
            case .andAll(let value):
                try container.encode(value, forKey: .andAll)
            case .equals(let value):
                try container.encode(value, forKey: .equals)
            case .notEquals(let value):
                try container.encode(value, forKey: .notEquals)
            case .orAll(let value):
                try container.encode(value, forKey: .orAll)
            }
        }

        public func validate(name: String) throws {
            switch self {
            case .andAll(let value):
                try value.forEach {
                    try $0.validate(name: "\(name).andAll[]")
                }
                try self.validate(value, name: "andAll", parent: name, max: 16)
                try self.validate(value, name: "andAll", parent: name, min: 1)
            case .equals(let value):
                try self.validate(value, name: "equals", parent: name, max: 1)
                try self.validate(value, name: "equals", parent: name, min: 1)
            case .notEquals(let value):
                try self.validate(value, name: "notEquals", parent: name, max: 1)
                try self.validate(value, name: "notEquals", parent: name, min: 1)
            case .orAll(let value):
                try value.forEach {
                    try $0.validate(name: "\(name).orAll[]")
                }
                try self.validate(value, name: "orAll", parent: name, max: 16)
                try self.validate(value, name: "orAll", parent: name, min: 1)
            }
        }

        private enum CodingKeys: String, CodingKey {
            case andAll = "andAll"
            case equals = "equals"
            case notEquals = "notEquals"
            case orAll = "orAll"
        }
    }

    public enum RetrievalFilter: AWSEncodableShape & AWSDecodableShape, Sendable {
        /// Knowledge base data sources are returned if their metadata attributes fulfill all the  filter conditions inside this list.
        case andAll([RetrievalFilter])
        /// Knowledge base data sources are returned if they contain a metadata attribute whose  name matches the key and whose value matches the value in this object. The following example would return data sources with an animal attribute whose value is 'cat': "equals": { "key": "animal", "value": "cat" }
        case equals(FilterAttribute)
        /// Knowledge base data sources are returned if they contain a metadata attribute whose name  matches the key and whose value is greater than the value in this object. The following example would return data sources with an year attribute whose value is  greater than '1989': "greaterThan": { "key": "year", "value": 1989 }
        case greaterThan(FilterAttribute)
        /// Knowledge base data sources are returned if they contain a metadata attribute whose name  matches the key and whose value is greater than or equal to the value in this object. The following example would return data sources with an year attribute whose value is  greater than or equal to '1989': "greaterThanOrEquals": { "key": "year", "value": 1989 }
        case greaterThanOrEquals(FilterAttribute)
        /// Knowledge base data sources are returned if they contain a metadata attribute whose  name matches the key and whose value is in the list specified in the value in this object. The following example would return data sources with an animal attribute that is either 'cat' or 'dog': "in": { "key": "animal", "value": ["cat", "dog"] }
        case `in`(FilterAttribute)
        /// Knowledge base data sources are returned if they contain a metadata attribute whose name matches the  key and whose value is less than the value in this object. The following example would return data sources with an year attribute whose value is less than to '1989': "lessThan": { "key": "year", "value": 1989 }
        case lessThan(FilterAttribute)
        /// Knowledge base data sources are returned if they contain a metadata attribute whose name matches the key  and whose value is less than or equal to the value in this object. The following example would return data sources with an year attribute whose value is less than or equal  to '1989': "lessThanOrEquals": { "key": "year", "value": 1989 }
        case lessThanOrEquals(FilterAttribute)
        /// Knowledge base data sources are returned if they contain a metadata attribute whose name matches the key  and whose value is a list that contains the value as one of its members. The following example would return data sources with an animals attribute that is a list containing a cat  member (for example, ["dog", "cat"]): "listContains": { "key": "animals", "value": "cat" }
        case listContains(FilterAttribute)
        /// Knowledge base data sources that contain a metadata attribute whose name matches the key and whose value  doesn't match the value in this object are returned. The following example would return data sources that don't contain an animal attribute whose value is 'cat':  "notEquals": { "key": "animal", "value": "cat" }
        case notEquals(FilterAttribute)
        /// Knowledge base data sources are returned if they contain a metadata attribute whose name matches the key  and whose value isn't in the list specified in the value in this object. The following example would return data sources whose animal attribute is neither 'cat' nor 'dog': "notIn": { "key": "animal", "value": ["cat", "dog"] }
        case notIn(FilterAttribute)
        /// Knowledge base data sources are returned if their metadata attributes fulfill at least one of the filter  conditions inside this list.
        case orAll([RetrievalFilter])
        /// Knowledge base data sources are returned if they contain a metadata attribute whose name matches the key  and whose value starts with the value in this object. This filter is currently only supported for  Amazon OpenSearch Serverless vector stores. The following example would return data sources with an animal attribute starts with 'ca' (for example, 'cat' or 'camel'). "startsWith": { "key": "animal", "value": "ca" }
        case startsWith(FilterAttribute)
        /// Knowledge base data sources are returned if they contain a metadata attribute whose name matches the key  and whose value is one of the following: A string that contains the value as a substring. The following example would return data sources with an  animal attribute that contains the substring at (for example, 'cat'):  "stringContains": { "key": "animal", "value": "at" }  A list with a member that contains the value as a substring. The following example would return data  sources with an animals attribute that is a list containing a member that contains the substring at  (for example, ["dog", "cat"]): "stringContains": { "key": "animals", "value": "at" }
        case stringContains(FilterAttribute)

        public init(from decoder: Decoder) throws {
            let container = try decoder.container(keyedBy: CodingKeys.self)
            guard container.allKeys.count == 1, let key = container.allKeys.first else {
                let context = DecodingError.Context(
                    codingPath: container.codingPath,
                    debugDescription: "Expected exactly one key, but got \(container.allKeys.count)"
                )
                throw DecodingError.dataCorrupted(context)
            }
            switch key {
            case .andAll:
                let value = try container.decode([RetrievalFilter].self, forKey: .andAll)
                self = .andAll(value)
            case .equals:
                let value = try container.decode(FilterAttribute.self, forKey: .equals)
                self = .equals(value)
            case .greaterThan:
                let value = try container.decode(FilterAttribute.self, forKey: .greaterThan)
                self = .greaterThan(value)
            case .greaterThanOrEquals:
                let value = try container.decode(FilterAttribute.self, forKey: .greaterThanOrEquals)
                self = .greaterThanOrEquals(value)
            case .`in`:
                let value = try container.decode(FilterAttribute.self, forKey: .`in`)
                self = .`in`(value)
            case .lessThan:
                let value = try container.decode(FilterAttribute.self, forKey: .lessThan)
                self = .lessThan(value)
            case .lessThanOrEquals:
                let value = try container.decode(FilterAttribute.self, forKey: .lessThanOrEquals)
                self = .lessThanOrEquals(value)
            case .listContains:
                let value = try container.decode(FilterAttribute.self, forKey: .listContains)
                self = .listContains(value)
            case .notEquals:
                let value = try container.decode(FilterAttribute.self, forKey: .notEquals)
                self = .notEquals(value)
            case .notIn:
                let value = try container.decode(FilterAttribute.self, forKey: .notIn)
                self = .notIn(value)
            case .orAll:
                let value = try container.decode([RetrievalFilter].self, forKey: .orAll)
                self = .orAll(value)
            case .startsWith:
                let value = try container.decode(FilterAttribute.self, forKey: .startsWith)
                self = .startsWith(value)
            case .stringContains:
                let value = try container.decode(FilterAttribute.self, forKey: .stringContains)
                self = .stringContains(value)
            }
        }

        public func encode(to encoder: Encoder) throws {
            var container = encoder.container(keyedBy: CodingKeys.self)
            switch self {
            case .andAll(let value):
                try container.encode(value, forKey: .andAll)
            case .equals(let value):
                try container.encode(value, forKey: .equals)
            case .greaterThan(let value):
                try container.encode(value, forKey: .greaterThan)
            case .greaterThanOrEquals(let value):
                try container.encode(value, forKey: .greaterThanOrEquals)
            case .`in`(let value):
                try container.encode(value, forKey: .`in`)
            case .lessThan(let value):
                try container.encode(value, forKey: .lessThan)
            case .lessThanOrEquals(let value):
                try container.encode(value, forKey: .lessThanOrEquals)
            case .listContains(let value):
                try container.encode(value, forKey: .listContains)
            case .notEquals(let value):
                try container.encode(value, forKey: .notEquals)
            case .notIn(let value):
                try container.encode(value, forKey: .notIn)
            case .orAll(let value):
                try container.encode(value, forKey: .orAll)
            case .startsWith(let value):
                try container.encode(value, forKey: .startsWith)
            case .stringContains(let value):
                try container.encode(value, forKey: .stringContains)
            }
        }

        public func validate(name: String) throws {
            switch self {
            case .andAll(let value):
                try value.forEach {
                    try $0.validate(name: "\(name).andAll[]")
                }
                try self.validate(value, name: "andAll", parent: name, min: 2)
            case .equals(let value):
                try value.validate(name: "\(name).equals")
            case .greaterThan(let value):
                try value.validate(name: "\(name).greaterThan")
            case .greaterThanOrEquals(let value):
                try value.validate(name: "\(name).greaterThanOrEquals")
            case .`in`(let value):
                try value.validate(name: "\(name).`in`")
            case .lessThan(let value):
                try value.validate(name: "\(name).lessThan")
            case .lessThanOrEquals(let value):
                try value.validate(name: "\(name).lessThanOrEquals")
            case .listContains(let value):
                try value.validate(name: "\(name).listContains")
            case .notEquals(let value):
                try value.validate(name: "\(name).notEquals")
            case .notIn(let value):
                try value.validate(name: "\(name).notIn")
            case .orAll(let value):
                try value.forEach {
                    try $0.validate(name: "\(name).orAll[]")
                }
                try self.validate(value, name: "orAll", parent: name, min: 2)
            case .startsWith(let value):
                try value.validate(name: "\(name).startsWith")
            case .stringContains(let value):
                try value.validate(name: "\(name).stringContains")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case andAll = "andAll"
            case equals = "equals"
            case greaterThan = "greaterThan"
            case greaterThanOrEquals = "greaterThanOrEquals"
            case `in` = "in"
            case lessThan = "lessThan"
            case lessThanOrEquals = "lessThanOrEquals"
            case listContains = "listContains"
            case notEquals = "notEquals"
            case notIn = "notIn"
            case orAll = "orAll"
            case startsWith = "startsWith"
            case stringContains = "stringContains"
        }
    }

    // MARK: Shapes

    public struct AutomatedEvaluationConfig: AWSEncodableShape & AWSDecodableShape {
        /// Configuration details of the prompt datasets and metrics you want to use for your evaluation job.
        public let datasetMetricConfigs: [EvaluationDatasetMetricConfig]
        /// Contains the evaluator model configuration details. EvaluatorModelConfig is required for evaluation jobs that use a knowledge base or in model evaluation job that use a model as judge. This model computes all evaluation related metrics.
        public let evaluatorModelConfig: EvaluatorModelConfig?

        @inlinable
        public init(datasetMetricConfigs: [EvaluationDatasetMetricConfig], evaluatorModelConfig: EvaluatorModelConfig? = nil) {
            self.datasetMetricConfigs = datasetMetricConfigs
            self.evaluatorModelConfig = evaluatorModelConfig
        }

        public func validate(name: String) throws {
            try self.datasetMetricConfigs.forEach {
                try $0.validate(name: "\(name).datasetMetricConfigs[]")
            }
            try self.validate(self.datasetMetricConfigs, name: "datasetMetricConfigs", parent: name, max: 5)
            try self.validate(self.datasetMetricConfigs, name: "datasetMetricConfigs", parent: name, min: 1)
            try self.evaluatorModelConfig?.validate(name: "\(name).evaluatorModelConfig")
        }

        private enum CodingKeys: String, CodingKey {
            case datasetMetricConfigs = "datasetMetricConfigs"
            case evaluatorModelConfig = "evaluatorModelConfig"
        }
    }

    public struct BatchDeleteEvaluationJobError: AWSDecodableShape {
        /// A HTTP status code of the evaluation job being deleted.
        public let code: String
        /// The ARN of the evaluation job being deleted.
        public let jobIdentifier: String
        /// A status message about the evaluation job deletion.
        public let message: String?

        @inlinable
        public init(code: String, jobIdentifier: String, message: String? = nil) {
            self.code = code
            self.jobIdentifier = jobIdentifier
            self.message = message
        }

        private enum CodingKeys: String, CodingKey {
            case code = "code"
            case jobIdentifier = "jobIdentifier"
            case message = "message"
        }
    }

    public struct BatchDeleteEvaluationJobItem: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the evaluation job for deletion.
        public let jobIdentifier: String
        /// The status of the evaluation job for deletion.
        public let jobStatus: EvaluationJobStatus

        @inlinable
        public init(jobIdentifier: String, jobStatus: EvaluationJobStatus) {
            self.jobIdentifier = jobIdentifier
            self.jobStatus = jobStatus
        }

        private enum CodingKeys: String, CodingKey {
            case jobIdentifier = "jobIdentifier"
            case jobStatus = "jobStatus"
        }
    }

    public struct BatchDeleteEvaluationJobRequest: AWSEncodableShape {
        /// A list of one or more evaluation job Amazon Resource Names (ARNs) you want to delete.
        public let jobIdentifiers: [String]

        @inlinable
        public init(jobIdentifiers: [String]) {
            self.jobIdentifiers = jobIdentifiers
        }

        public func validate(name: String) throws {
            try self.jobIdentifiers.forEach {
                try validate($0, name: "jobIdentifiers[]", parent: name, max: 1011)
                try validate($0, name: "jobIdentifiers[]", parent: name, pattern: "^(arn:aws(-[^:]+)?:bedrock:[a-z0-9-]{1,20}:[0-9]{12}:evaluation-job/[a-z0-9]{12})$")
            }
            try self.validate(self.jobIdentifiers, name: "jobIdentifiers", parent: name, max: 25)
            try self.validate(self.jobIdentifiers, name: "jobIdentifiers", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case jobIdentifiers = "jobIdentifiers"
        }
    }

    public struct BatchDeleteEvaluationJobResponse: AWSDecodableShape {
        /// A JSON object containing the HTTP status codes and the ARNs of evaluation jobs that failed to be deleted.
        public let errors: [BatchDeleteEvaluationJobError]
        /// The list of evaluation jobs for deletion.
        public let evaluationJobs: [BatchDeleteEvaluationJobItem]

        @inlinable
        public init(errors: [BatchDeleteEvaluationJobError], evaluationJobs: [BatchDeleteEvaluationJobItem]) {
            self.errors = errors
            self.evaluationJobs = evaluationJobs
        }

        private enum CodingKeys: String, CodingKey {
            case errors = "errors"
            case evaluationJobs = "evaluationJobs"
        }
    }

    public struct BedrockEvaluatorModel: AWSEncodableShape & AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the evaluator model used used in knowledge base evaluation job or in model evaluation job that use a model as judge.
        public let modelIdentifier: String

        @inlinable
        public init(modelIdentifier: String) {
            self.modelIdentifier = modelIdentifier
        }

        public func validate(name: String) throws {
            try self.validate(self.modelIdentifier, name: "modelIdentifier", parent: name, max: 2048)
            try self.validate(self.modelIdentifier, name: "modelIdentifier", parent: name, min: 1)
            try self.validate(self.modelIdentifier, name: "modelIdentifier", parent: name, pattern: "^arn:aws(-[^:]+)?:bedrock:[a-z0-9-]{1,20}::foundation-model/[a-z0-9-]{1,63}[.]{1}([a-z0-9-]{1,63}[.]){0,2}[a-z0-9-]{1,63}([:][a-z0-9-]{1,63}){0,2}$|(^[a-z0-9-]+[.][a-z0-9-]+([.][a-z0-9-]+)*(:[a-z0-9-]+)?$)|^[a-z0-9-]{1,63}[.]{1}[a-z0-9-]{1,63}([a-z0-9-]{1,63}[.]){0,2}[a-z0-9-]{1,63}([:][a-z0-9-]{1,63}){0,2}(/[a-z0-9]{12}|)$")
        }

        private enum CodingKeys: String, CodingKey {
            case modelIdentifier = "modelIdentifier"
        }
    }

    public struct ByteContentDoc: AWSEncodableShape & AWSDecodableShape {
        /// The MIME type of the document contained in the wrapper object.
        public let contentType: String
        /// The byte value of the file to upload, encoded as a Base-64 string.
        public let data: AWSBase64Data
        /// The file name of the document contained in the wrapper object.
        public let identifier: String

        @inlinable
        public init(contentType: String, data: AWSBase64Data, identifier: String) {
            self.contentType = contentType
            self.data = data
            self.identifier = identifier
        }

        public func validate(name: String) throws {
            try self.validate(self.contentType, name: "contentType", parent: name, pattern: "[a-z]{1,20}/.{1,20}")
            try self.validate(self.data, name: "data", parent: name, max: 10485760)
            try self.validate(self.data, name: "data", parent: name, min: 1)
            try self.validate(self.identifier, name: "identifier", parent: name, max: 1024)
            try self.validate(self.identifier, name: "identifier", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case contentType = "contentType"
            case data = "data"
            case identifier = "identifier"
        }
    }

    public struct CloudWatchConfig: AWSEncodableShape & AWSDecodableShape {
        /// S3 configuration for delivering a large amount of data.
        public let largeDataDeliveryS3Config: S3Config?
        /// The log group name.
        public let logGroupName: String
        /// The role Amazon Resource Name (ARN).
        public let roleArn: String

        @inlinable
        public init(largeDataDeliveryS3Config: S3Config? = nil, logGroupName: String, roleArn: String) {
            self.largeDataDeliveryS3Config = largeDataDeliveryS3Config
            self.logGroupName = logGroupName
            self.roleArn = roleArn
        }

        public func validate(name: String) throws {
            try self.largeDataDeliveryS3Config?.validate(name: "\(name).largeDataDeliveryS3Config")
            try self.validate(self.logGroupName, name: "logGroupName", parent: name, max: 512)
            try self.validate(self.logGroupName, name: "logGroupName", parent: name, min: 1)
            try self.validate(self.roleArn, name: "roleArn", parent: name, max: 2048)
            try self.validate(self.roleArn, name: "roleArn", parent: name, pattern: "^arn:aws(-[^:]+)?:iam::([0-9]{12})?:role/.+$")
        }

        private enum CodingKeys: String, CodingKey {
            case largeDataDeliveryS3Config = "largeDataDeliveryS3Config"
            case logGroupName = "logGroupName"
            case roleArn = "roleArn"
        }
    }

    public struct CreateEvaluationJobRequest: AWSEncodableShape {
        /// Specifies whether the evaluation job is for evaluating a model or evaluating a knowledge base (retrieval and response generation).
        public let applicationType: ApplicationType?
        /// A unique, case-sensitive identifier to ensure that the API request completes no more than one time. If this token matches a previous request, Amazon Bedrock ignores the request, but does not return an error. For more information, see Ensuring idempotency.
        public let clientRequestToken: String?
        /// Specify your customer managed encryption key Amazon Resource Name (ARN) that will be used to encrypt your evaluation job.
        public let customerEncryptionKeyId: String?
        /// Contains the configuration details of either an automated or human-based evaluation job.
        public let evaluationConfig: EvaluationConfig
        /// Contains the configuration details of the inference model for the evaluation job. For model evaluation jobs, automated jobs support a single model or  inference profile, and jobs that use human workers support  two models or inference profiles.
        public let inferenceConfig: EvaluationInferenceConfig
        /// A description of the evaluation job.
        public let jobDescription: String?
        /// A name for the evaluation job. Names must unique with your Amazon Web Services account,  and your account's Amazon Web Services region.
        public let jobName: String
        /// Tags to attach to the model evaluation job.
        public let jobTags: [Tag]?
        /// Contains the configuration details of the Amazon S3 bucket for storing the results  of the evaluation job.
        public let outputDataConfig: EvaluationOutputDataConfig
        /// The Amazon Resource Name (ARN) of an IAM service role that Amazon Bedrock can  assume to perform tasks on your behalf. To learn more about the required permissions,  see Required  permissions for model evaluations.
        public let roleArn: String

        @inlinable
        public init(applicationType: ApplicationType? = nil, clientRequestToken: String? = CreateEvaluationJobRequest.idempotencyToken(), customerEncryptionKeyId: String? = nil, evaluationConfig: EvaluationConfig, inferenceConfig: EvaluationInferenceConfig, jobDescription: String? = nil, jobName: String, jobTags: [Tag]? = nil, outputDataConfig: EvaluationOutputDataConfig, roleArn: String) {
            self.applicationType = applicationType
            self.clientRequestToken = clientRequestToken
            self.customerEncryptionKeyId = customerEncryptionKeyId
            self.evaluationConfig = evaluationConfig
            self.inferenceConfig = inferenceConfig
            self.jobDescription = jobDescription
            self.jobName = jobName
            self.jobTags = jobTags
            self.outputDataConfig = outputDataConfig
            self.roleArn = roleArn
        }

        public func validate(name: String) throws {
            try self.validate(self.clientRequestToken, name: "clientRequestToken", parent: name, max: 256)
            try self.validate(self.clientRequestToken, name: "clientRequestToken", parent: name, min: 1)
            try self.validate(self.clientRequestToken, name: "clientRequestToken", parent: name, pattern: "^[a-zA-Z0-9](-*[a-zA-Z0-9])*$")
            try self.validate(self.customerEncryptionKeyId, name: "customerEncryptionKeyId", parent: name, max: 2048)
            try self.validate(self.customerEncryptionKeyId, name: "customerEncryptionKeyId", parent: name, min: 1)
            try self.validate(self.customerEncryptionKeyId, name: "customerEncryptionKeyId", parent: name, pattern: "^(arn:aws(-[^:]+)?:kms:[a-zA-Z0-9-]*:[0-9]{12}:((key/[a-zA-Z0-9-]{36})|(alias/[a-zA-Z0-9-_/]+)))|([a-zA-Z0-9-]{36})|(alias/[a-zA-Z0-9-_/]+)$")
            try self.evaluationConfig.validate(name: "\(name).evaluationConfig")
            try self.inferenceConfig.validate(name: "\(name).inferenceConfig")
            try self.validate(self.jobDescription, name: "jobDescription", parent: name, max: 200)
            try self.validate(self.jobDescription, name: "jobDescription", parent: name, min: 1)
            try self.validate(self.jobDescription, name: "jobDescription", parent: name, pattern: "^.+$")
            try self.validate(self.jobName, name: "jobName", parent: name, max: 63)
            try self.validate(self.jobName, name: "jobName", parent: name, min: 1)
            try self.validate(self.jobName, name: "jobName", parent: name, pattern: "^[a-z0-9](-*[a-z0-9]){0,62}$")
            try self.jobTags?.forEach {
                try $0.validate(name: "\(name).jobTags[]")
            }
            try self.validate(self.jobTags, name: "jobTags", parent: name, max: 200)
            try self.outputDataConfig.validate(name: "\(name).outputDataConfig")
            try self.validate(self.roleArn, name: "roleArn", parent: name, max: 2048)
            try self.validate(self.roleArn, name: "roleArn", parent: name, pattern: "^arn:aws(-[^:]+)?:iam::([0-9]{12})?:role/.+$")
        }

        private enum CodingKeys: String, CodingKey {
            case applicationType = "applicationType"
            case clientRequestToken = "clientRequestToken"
            case customerEncryptionKeyId = "customerEncryptionKeyId"
            case evaluationConfig = "evaluationConfig"
            case inferenceConfig = "inferenceConfig"
            case jobDescription = "jobDescription"
            case jobName = "jobName"
            case jobTags = "jobTags"
            case outputDataConfig = "outputDataConfig"
            case roleArn = "roleArn"
        }
    }

    public struct CreateEvaluationJobResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the evaluation job.
        public let jobArn: String

        @inlinable
        public init(jobArn: String) {
            self.jobArn = jobArn
        }

        private enum CodingKeys: String, CodingKey {
            case jobArn = "jobArn"
        }
    }

    public struct CreateGuardrailRequest: AWSEncodableShape {
        /// The message to return when the guardrail blocks a prompt.
        public let blockedInputMessaging: String
        /// The message to return when the guardrail blocks a model response.
        public let blockedOutputsMessaging: String
        /// A unique, case-sensitive identifier to ensure that the API request  completes no more than once. If this token matches a previous request,  Amazon Bedrock ignores the request, but does not return an error.  For more information, see Ensuring  idempotency in the Amazon S3 User Guide.
        public let clientRequestToken: String?
        /// The content filter policies to configure for the guardrail.
        public let contentPolicyConfig: GuardrailContentPolicyConfig?
        /// The contextual grounding policy configuration used to create a guardrail.
        public let contextualGroundingPolicyConfig: GuardrailContextualGroundingPolicyConfig?
        /// A description of the guardrail.
        public let description: String?
        /// The ARN of the KMS key that you use to encrypt the guardrail.
        public let kmsKeyId: String?
        /// The name to give the guardrail.
        public let name: String
        /// The sensitive information policy to configure for the guardrail.
        public let sensitiveInformationPolicyConfig: GuardrailSensitiveInformationPolicyConfig?
        /// The tags that you want to attach to the guardrail.
        public let tags: [Tag]?
        /// The topic policies to configure for the guardrail.
        public let topicPolicyConfig: GuardrailTopicPolicyConfig?
        /// The word policy you configure for the guardrail.
        public let wordPolicyConfig: GuardrailWordPolicyConfig?

        @inlinable
        public init(blockedInputMessaging: String, blockedOutputsMessaging: String, clientRequestToken: String? = CreateGuardrailRequest.idempotencyToken(), contentPolicyConfig: GuardrailContentPolicyConfig? = nil, contextualGroundingPolicyConfig: GuardrailContextualGroundingPolicyConfig? = nil, description: String? = nil, kmsKeyId: String? = nil, name: String, sensitiveInformationPolicyConfig: GuardrailSensitiveInformationPolicyConfig? = nil, tags: [Tag]? = nil, topicPolicyConfig: GuardrailTopicPolicyConfig? = nil, wordPolicyConfig: GuardrailWordPolicyConfig? = nil) {
            self.blockedInputMessaging = blockedInputMessaging
            self.blockedOutputsMessaging = blockedOutputsMessaging
            self.clientRequestToken = clientRequestToken
            self.contentPolicyConfig = contentPolicyConfig
            self.contextualGroundingPolicyConfig = contextualGroundingPolicyConfig
            self.description = description
            self.kmsKeyId = kmsKeyId
            self.name = name
            self.sensitiveInformationPolicyConfig = sensitiveInformationPolicyConfig
            self.tags = tags
            self.topicPolicyConfig = topicPolicyConfig
            self.wordPolicyConfig = wordPolicyConfig
        }

        public func validate(name: String) throws {
            try self.validate(self.blockedInputMessaging, name: "blockedInputMessaging", parent: name, max: 500)
            try self.validate(self.blockedInputMessaging, name: "blockedInputMessaging", parent: name, min: 1)
            try self.validate(self.blockedOutputsMessaging, name: "blockedOutputsMessaging", parent: name, max: 500)
            try self.validate(self.blockedOutputsMessaging, name: "blockedOutputsMessaging", parent: name, min: 1)
            try self.validate(self.clientRequestToken, name: "clientRequestToken", parent: name, max: 256)
            try self.validate(self.clientRequestToken, name: "clientRequestToken", parent: name, min: 1)
            try self.validate(self.clientRequestToken, name: "clientRequestToken", parent: name, pattern: "^[a-zA-Z0-9](-*[a-zA-Z0-9])*$")
            try self.contentPolicyConfig?.validate(name: "\(name).contentPolicyConfig")
            try self.contextualGroundingPolicyConfig?.validate(name: "\(name).contextualGroundingPolicyConfig")
            try self.validate(self.description, name: "description", parent: name, max: 200)
            try self.validate(self.description, name: "description", parent: name, min: 1)
            try self.validate(self.kmsKeyId, name: "kmsKeyId", parent: name, max: 2048)
            try self.validate(self.kmsKeyId, name: "kmsKeyId", parent: name, min: 1)
            try self.validate(self.kmsKeyId, name: "kmsKeyId", parent: name, pattern: "^(arn:aws(-[^:]+)?:kms:[a-zA-Z0-9-]*:[0-9]{12}:((key/[a-zA-Z0-9-]{36})|(alias/[a-zA-Z0-9-_/]+)))|([a-zA-Z0-9-]{36})|(alias/[a-zA-Z0-9-_/]+)$")
            try self.validate(self.name, name: "name", parent: name, max: 50)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[0-9a-zA-Z-_]+$")
            try self.sensitiveInformationPolicyConfig?.validate(name: "\(name).sensitiveInformationPolicyConfig")
            try self.tags?.forEach {
                try $0.validate(name: "\(name).tags[]")
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 200)
            try self.topicPolicyConfig?.validate(name: "\(name).topicPolicyConfig")
            try self.wordPolicyConfig?.validate(name: "\(name).wordPolicyConfig")
        }

        private enum CodingKeys: String, CodingKey {
            case blockedInputMessaging = "blockedInputMessaging"
            case blockedOutputsMessaging = "blockedOutputsMessaging"
            case clientRequestToken = "clientRequestToken"
            case contentPolicyConfig = "contentPolicyConfig"
            case contextualGroundingPolicyConfig = "contextualGroundingPolicyConfig"
            case description = "description"
            case kmsKeyId = "kmsKeyId"
            case name = "name"
            case sensitiveInformationPolicyConfig = "sensitiveInformationPolicyConfig"
            case tags = "tags"
            case topicPolicyConfig = "topicPolicyConfig"
            case wordPolicyConfig = "wordPolicyConfig"
        }
    }

    public struct CreateGuardrailResponse: AWSDecodableShape {
        /// The time at which the guardrail was created.
        @CustomCoding<ISO8601DateCoder>
        public var createdAt: Date
        /// The ARN of the guardrail.
        public let guardrailArn: String
        /// The unique identifier of the guardrail that was created.
        public let guardrailId: String
        /// The version of the guardrail that was created.  This value will always be DRAFT.
        public let version: String

        @inlinable
        public init(createdAt: Date, guardrailArn: String, guardrailId: String, version: String) {
            self.createdAt = createdAt
            self.guardrailArn = guardrailArn
            self.guardrailId = guardrailId
            self.version = version
        }

        private enum CodingKeys: String, CodingKey {
            case createdAt = "createdAt"
            case guardrailArn = "guardrailArn"
            case guardrailId = "guardrailId"
            case version = "version"
        }
    }

    public struct CreateGuardrailVersionRequest: AWSEncodableShape {
        /// A unique, case-sensitive identifier to ensure that the API request  completes no more than once. If this token matches a previous request,  Amazon Bedrock ignores the request, but does not return an error.  For more information, see Ensuring  idempotency in the Amazon S3 User Guide.
        public let clientRequestToken: String?
        /// A description of the guardrail version.
        public let description: String?
        /// The unique identifier of the guardrail. This can be an ID or the ARN.
        public let guardrailIdentifier: String

        @inlinable
        public init(clientRequestToken: String? = CreateGuardrailVersionRequest.idempotencyToken(), description: String? = nil, guardrailIdentifier: String) {
            self.clientRequestToken = clientRequestToken
            self.description = description
            self.guardrailIdentifier = guardrailIdentifier
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.clientRequestToken, forKey: .clientRequestToken)
            try container.encodeIfPresent(self.description, forKey: .description)
            request.encodePath(self.guardrailIdentifier, key: "guardrailIdentifier")
        }

        public func validate(name: String) throws {
            try self.validate(self.clientRequestToken, name: "clientRequestToken", parent: name, max: 256)
            try self.validate(self.clientRequestToken, name: "clientRequestToken", parent: name, min: 1)
            try self.validate(self.clientRequestToken, name: "clientRequestToken", parent: name, pattern: "^[a-zA-Z0-9](-*[a-zA-Z0-9])*$")
            try self.validate(self.description, name: "description", parent: name, max: 200)
            try self.validate(self.description, name: "description", parent: name, min: 1)
            try self.validate(self.guardrailIdentifier, name: "guardrailIdentifier", parent: name, max: 2048)
            try self.validate(self.guardrailIdentifier, name: "guardrailIdentifier", parent: name, pattern: "^(([a-z0-9]+)|(arn:aws(-[^:]+)?:bedrock:[a-z0-9-]{1,20}:[0-9]{12}:guardrail/[a-z0-9]+))$")
        }

        private enum CodingKeys: String, CodingKey {
            case clientRequestToken = "clientRequestToken"
            case description = "description"
        }
    }

    public struct CreateGuardrailVersionResponse: AWSDecodableShape {
        /// The unique identifier of the guardrail.
        public let guardrailId: String
        /// The number of the version of the guardrail.
        public let version: String

        @inlinable
        public init(guardrailId: String, version: String) {
            self.guardrailId = guardrailId
            self.version = version
        }

        private enum CodingKeys: String, CodingKey {
            case guardrailId = "guardrailId"
            case version = "version"
        }
    }

    public struct CreateInferenceProfileRequest: AWSEncodableShape {
        /// A unique, case-sensitive identifier to ensure that the API request completes no more than one time. If this token matches a previous request, Amazon Bedrock ignores the request, but does not return an error. For more information, see Ensuring idempotency.
        public let clientRequestToken: String?
        /// A description for the inference profile.
        public let description: String?
        /// A name for the inference profile.
        public let inferenceProfileName: String
        /// The foundation model or system-defined inference profile that the inference profile will track metrics and costs for.
        public let modelSource: InferenceProfileModelSource
        /// An array of objects, each of which contains a tag and its value. For more information, see  Tagging resources in the Amazon Bedrock User Guide.
        public let tags: [Tag]?

        @inlinable
        public init(clientRequestToken: String? = CreateInferenceProfileRequest.idempotencyToken(), description: String? = nil, inferenceProfileName: String, modelSource: InferenceProfileModelSource, tags: [Tag]? = nil) {
            self.clientRequestToken = clientRequestToken
            self.description = description
            self.inferenceProfileName = inferenceProfileName
            self.modelSource = modelSource
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.validate(self.clientRequestToken, name: "clientRequestToken", parent: name, max: 256)
            try self.validate(self.clientRequestToken, name: "clientRequestToken", parent: name, min: 1)
            try self.validate(self.clientRequestToken, name: "clientRequestToken", parent: name, pattern: "^[a-zA-Z0-9](-*[a-zA-Z0-9])*$")
            try self.validate(self.description, name: "description", parent: name, max: 200)
            try self.validate(self.description, name: "description", parent: name, min: 1)
            try self.validate(self.description, name: "description", parent: name, pattern: "^([0-9a-zA-Z:.][ _-]?)+$")
            try self.validate(self.inferenceProfileName, name: "inferenceProfileName", parent: name, max: 64)
            try self.validate(self.inferenceProfileName, name: "inferenceProfileName", parent: name, min: 1)
            try self.validate(self.inferenceProfileName, name: "inferenceProfileName", parent: name, pattern: "^([0-9a-zA-Z][ _-]?)+$")
            try self.modelSource.validate(name: "\(name).modelSource")
            try self.tags?.forEach {
                try $0.validate(name: "\(name).tags[]")
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 200)
        }

        private enum CodingKeys: String, CodingKey {
            case clientRequestToken = "clientRequestToken"
            case description = "description"
            case inferenceProfileName = "inferenceProfileName"
            case modelSource = "modelSource"
            case tags = "tags"
        }
    }

    public struct CreateInferenceProfileResponse: AWSDecodableShape {
        /// The ARN of the inference profile that you created.
        public let inferenceProfileArn: String
        /// The status of the inference profile. ACTIVE means that the inference profile is ready to be used.
        public let status: InferenceProfileStatus?

        @inlinable
        public init(inferenceProfileArn: String, status: InferenceProfileStatus? = nil) {
            self.inferenceProfileArn = inferenceProfileArn
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case inferenceProfileArn = "inferenceProfileArn"
            case status = "status"
        }
    }

    public struct CreateMarketplaceModelEndpointRequest: AWSEncodableShape {
        /// Indicates whether you accept the end-user license agreement (EULA) for the model. Set to true to accept the EULA.
        public let acceptEula: Bool?
        /// A unique, case-sensitive identifier that you provide to ensure the idempotency of the request. This token is listed as not required because Amazon Web Services SDKs automatically generate it for you and set this parameter. If you're not using the Amazon Web Services SDK or the CLI, you must provide this token or the action will fail.
        public let clientRequestToken: String?
        /// The configuration for the endpoint, including the number and type of instances to use.
        public let endpointConfig: EndpointConfig
        /// The name of the endpoint. This name must be unique within your Amazon Web Services account and region.
        public let endpointName: String
        /// The ARN of the model from Amazon Bedrock Marketplace that you want to deploy to the endpoint.
        public let modelSourceIdentifier: String
        /// An array of key-value pairs to apply to the underlying Amazon SageMaker endpoint. You can use these tags to organize and identify your Amazon Web Services resources.
        public let tags: [Tag]?

        @inlinable
        public init(acceptEula: Bool? = nil, clientRequestToken: String? = CreateMarketplaceModelEndpointRequest.idempotencyToken(), endpointConfig: EndpointConfig, endpointName: String, modelSourceIdentifier: String, tags: [Tag]? = nil) {
            self.acceptEula = acceptEula
            self.clientRequestToken = clientRequestToken
            self.endpointConfig = endpointConfig
            self.endpointName = endpointName
            self.modelSourceIdentifier = modelSourceIdentifier
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.validate(self.clientRequestToken, name: "clientRequestToken", parent: name, max: 256)
            try self.validate(self.clientRequestToken, name: "clientRequestToken", parent: name, min: 1)
            try self.validate(self.clientRequestToken, name: "clientRequestToken", parent: name, pattern: "^[a-zA-Z0-9](-*[a-zA-Z0-9])*$")
            try self.endpointConfig.validate(name: "\(name).endpointConfig")
            try self.validate(self.endpointName, name: "endpointName", parent: name, max: 30)
            try self.validate(self.endpointName, name: "endpointName", parent: name, min: 1)
            try self.validate(self.modelSourceIdentifier, name: "modelSourceIdentifier", parent: name, max: 2048)
            try self.validate(self.modelSourceIdentifier, name: "modelSourceIdentifier", parent: name, pattern: "arn:aws:sagemaker:.*:hub-content/SageMakerPublicHub/Model/.*")
            try self.tags?.forEach {
                try $0.validate(name: "\(name).tags[]")
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 200)
        }

        private enum CodingKeys: String, CodingKey {
            case acceptEula = "acceptEula"
            case clientRequestToken = "clientRequestToken"
            case endpointConfig = "endpointConfig"
            case endpointName = "endpointName"
            case modelSourceIdentifier = "modelSourceIdentifier"
            case tags = "tags"
        }
    }

    public struct CreateMarketplaceModelEndpointResponse: AWSDecodableShape {
        /// Details about the created endpoint.
        public let marketplaceModelEndpoint: MarketplaceModelEndpoint

        @inlinable
        public init(marketplaceModelEndpoint: MarketplaceModelEndpoint) {
            self.marketplaceModelEndpoint = marketplaceModelEndpoint
        }

        private enum CodingKeys: String, CodingKey {
            case marketplaceModelEndpoint = "marketplaceModelEndpoint"
        }
    }

    public struct CreateModelCopyJobRequest: AWSEncodableShape {
        /// A unique, case-sensitive identifier to ensure that the API request completes no more than one time. If this token matches a previous request, Amazon Bedrock ignores the request, but does not return an error. For more information, see Ensuring idempotency.
        public let clientRequestToken: String?
        /// The ARN of the KMS key that you use to encrypt the model copy.
        public let modelKmsKeyId: String?
        /// The Amazon Resource Name (ARN) of the model to be copied.
        public let sourceModelArn: String
        /// A name for the copied model.
        public let targetModelName: String
        /// Tags to associate with the target model. For more information, see Tag resources in the Amazon Bedrock User Guide.
        public let targetModelTags: [Tag]?

        @inlinable
        public init(clientRequestToken: String? = CreateModelCopyJobRequest.idempotencyToken(), modelKmsKeyId: String? = nil, sourceModelArn: String, targetModelName: String, targetModelTags: [Tag]? = nil) {
            self.clientRequestToken = clientRequestToken
            self.modelKmsKeyId = modelKmsKeyId
            self.sourceModelArn = sourceModelArn
            self.targetModelName = targetModelName
            self.targetModelTags = targetModelTags
        }

        public func validate(name: String) throws {
            try self.validate(self.clientRequestToken, name: "clientRequestToken", parent: name, max: 256)
            try self.validate(self.clientRequestToken, name: "clientRequestToken", parent: name, min: 1)
            try self.validate(self.clientRequestToken, name: "clientRequestToken", parent: name, pattern: "^[a-zA-Z0-9](-*[a-zA-Z0-9])*$")
            try self.validate(self.modelKmsKeyId, name: "modelKmsKeyId", parent: name, max: 2048)
            try self.validate(self.modelKmsKeyId, name: "modelKmsKeyId", parent: name, min: 1)
            try self.validate(self.modelKmsKeyId, name: "modelKmsKeyId", parent: name, pattern: "^(arn:aws(-[^:]+)?:kms:[a-zA-Z0-9-]*:[0-9]{12}:((key/[a-zA-Z0-9-]{36})|(alias/[a-zA-Z0-9-_/]+)))|([a-zA-Z0-9-]{36})|(alias/[a-zA-Z0-9-_/]+)$")
            try self.validate(self.sourceModelArn, name: "sourceModelArn", parent: name, max: 1011)
            try self.validate(self.sourceModelArn, name: "sourceModelArn", parent: name, min: 20)
            try self.validate(self.sourceModelArn, name: "sourceModelArn", parent: name, pattern: "^arn:aws(-[^:]+)?:bedrock:[a-z0-9-]{1,20}:(([0-9]{12}:custom-model/[a-z0-9-]{1,63}[.]{1}[a-z0-9-]{1,63}/[a-z0-9]{12})|(:foundation-model/[a-z0-9-]{1,63}[.]{1}([a-z0-9-]{1,63}[.]){0,2}[a-z0-9-]{1,63}([:][a-z0-9-]{1,63}){0,2}))$")
            try self.validate(self.targetModelName, name: "targetModelName", parent: name, max: 63)
            try self.validate(self.targetModelName, name: "targetModelName", parent: name, min: 1)
            try self.validate(self.targetModelName, name: "targetModelName", parent: name, pattern: "^([0-9a-zA-Z][_-]?){1,63}$")
            try self.targetModelTags?.forEach {
                try $0.validate(name: "\(name).targetModelTags[]")
            }
            try self.validate(self.targetModelTags, name: "targetModelTags", parent: name, max: 200)
        }

        private enum CodingKeys: String, CodingKey {
            case clientRequestToken = "clientRequestToken"
            case modelKmsKeyId = "modelKmsKeyId"
            case sourceModelArn = "sourceModelArn"
            case targetModelName = "targetModelName"
            case targetModelTags = "targetModelTags"
        }
    }

    public struct CreateModelCopyJobResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the model copy job.
        public let jobArn: String

        @inlinable
        public init(jobArn: String) {
            self.jobArn = jobArn
        }

        private enum CodingKeys: String, CodingKey {
            case jobArn = "jobArn"
        }
    }

    public struct CreateModelCustomizationJobRequest: AWSEncodableShape {
        /// Name of the base model.
        public let baseModelIdentifier: String
        /// A unique, case-sensitive identifier to ensure that the API request completes no more than one time. If this token matches a previous request, Amazon Bedrock ignores the request, but does not return an error. For more information, see Ensuring idempotency.
        public let clientRequestToken: String?
        /// The customization configuration for the model customization job.
        public let customizationConfig: CustomizationConfig?
        /// The customization type.
        public let customizationType: CustomizationType?
        /// The custom model is encrypted at rest using this key.
        public let customModelKmsKeyId: String?
        /// A name for the resulting custom model.
        public let customModelName: String
        /// Tags to attach to the resulting custom model.
        public let customModelTags: [Tag]?
        /// Parameters related to tuning the model. For details on the format for different models, see Custom model hyperparameters.
        public let hyperParameters: [String: String]?
        /// A name for the fine-tuning job.
        public let jobName: String
        /// Tags to attach to the job.
        public let jobTags: [Tag]?
        /// S3 location for the output data.
        public let outputDataConfig: OutputDataConfig
        /// The Amazon Resource Name (ARN) of an IAM service role that Amazon Bedrock can assume to perform tasks on your behalf. For example, during model training, Amazon Bedrock needs your permission to read input data from an S3 bucket, write model artifacts to an S3 bucket. To pass this role to Amazon Bedrock, the caller of this API must have the iam:PassRole permission.
        public let roleArn: String
        /// Information about the training dataset.
        public let trainingDataConfig: TrainingDataConfig
        /// Information about the validation dataset.
        public let validationDataConfig: ValidationDataConfig?
        /// The configuration of the Virtual Private Cloud (VPC) that contains the resources that you're using for this job. For more information, see Protect your model customization jobs using a VPC.
        public let vpcConfig: VpcConfig?

        @inlinable
        public init(baseModelIdentifier: String, clientRequestToken: String? = CreateModelCustomizationJobRequest.idempotencyToken(), customizationConfig: CustomizationConfig? = nil, customizationType: CustomizationType? = nil, customModelKmsKeyId: String? = nil, customModelName: String, customModelTags: [Tag]? = nil, hyperParameters: [String: String]? = nil, jobName: String, jobTags: [Tag]? = nil, outputDataConfig: OutputDataConfig, roleArn: String, trainingDataConfig: TrainingDataConfig, validationDataConfig: ValidationDataConfig? = nil, vpcConfig: VpcConfig? = nil) {
            self.baseModelIdentifier = baseModelIdentifier
            self.clientRequestToken = clientRequestToken
            self.customizationConfig = customizationConfig
            self.customizationType = customizationType
            self.customModelKmsKeyId = customModelKmsKeyId
            self.customModelName = customModelName
            self.customModelTags = customModelTags
            self.hyperParameters = hyperParameters
            self.jobName = jobName
            self.jobTags = jobTags
            self.outputDataConfig = outputDataConfig
            self.roleArn = roleArn
            self.trainingDataConfig = trainingDataConfig
            self.validationDataConfig = validationDataConfig
            self.vpcConfig = vpcConfig
        }

        public func validate(name: String) throws {
            try self.validate(self.baseModelIdentifier, name: "baseModelIdentifier", parent: name, max: 2048)
            try self.validate(self.baseModelIdentifier, name: "baseModelIdentifier", parent: name, min: 1)
            try self.validate(self.baseModelIdentifier, name: "baseModelIdentifier", parent: name, pattern: "^(arn:aws(-[^:]+)?:bedrock:[a-z0-9-]{1,20}:(([0-9]{12}:custom-model/([a-z0-9-]{1,63}[.]{1}[a-z0-9-]{1,63}([.]?[a-z0-9-]{1,63})([:][a-z0-9-]{1,63}){0,2})/[a-z0-9]{12})|(:foundation-model/[a-z0-9-]{1,63}[.]{1}[a-z0-9-]{1,63}([:][a-z0-9-]{1,63}){0,2})))|([a-z0-9-]{1,63}[.]{1}[a-z0-9-]{1,63}([.]?[a-z0-9-]{1,63})([:][a-z0-9-]{1,63}){0,2})|(([0-9a-zA-Z][_-]?)+)$")
            try self.validate(self.clientRequestToken, name: "clientRequestToken", parent: name, max: 256)
            try self.validate(self.clientRequestToken, name: "clientRequestToken", parent: name, min: 1)
            try self.validate(self.clientRequestToken, name: "clientRequestToken", parent: name, pattern: "^[a-zA-Z0-9](-*[a-zA-Z0-9])*$")
            try self.customizationConfig?.validate(name: "\(name).customizationConfig")
            try self.validate(self.customModelKmsKeyId, name: "customModelKmsKeyId", parent: name, max: 2048)
            try self.validate(self.customModelKmsKeyId, name: "customModelKmsKeyId", parent: name, min: 1)
            try self.validate(self.customModelKmsKeyId, name: "customModelKmsKeyId", parent: name, pattern: "^(arn:aws(-[^:]+)?:kms:[a-zA-Z0-9-]*:[0-9]{12}:((key/[a-zA-Z0-9-]{36})|(alias/[a-zA-Z0-9-_/]+)))|([a-zA-Z0-9-]{36})|(alias/[a-zA-Z0-9-_/]+)$")
            try self.validate(self.customModelName, name: "customModelName", parent: name, max: 63)
            try self.validate(self.customModelName, name: "customModelName", parent: name, min: 1)
            try self.validate(self.customModelName, name: "customModelName", parent: name, pattern: "^([0-9a-zA-Z][_-]?){1,63}$")
            try self.customModelTags?.forEach {
                try $0.validate(name: "\(name).customModelTags[]")
            }
            try self.validate(self.customModelTags, name: "customModelTags", parent: name, max: 200)
            try self.validate(self.jobName, name: "jobName", parent: name, max: 63)
            try self.validate(self.jobName, name: "jobName", parent: name, min: 1)
            try self.validate(self.jobName, name: "jobName", parent: name, pattern: "^[a-zA-Z0-9](-*[a-zA-Z0-9\\+\\-\\.])*$")
            try self.jobTags?.forEach {
                try $0.validate(name: "\(name).jobTags[]")
            }
            try self.validate(self.jobTags, name: "jobTags", parent: name, max: 200)
            try self.outputDataConfig.validate(name: "\(name).outputDataConfig")
            try self.validate(self.roleArn, name: "roleArn", parent: name, max: 2048)
            try self.validate(self.roleArn, name: "roleArn", parent: name, pattern: "^arn:aws(-[^:]+)?:iam::([0-9]{12})?:role/.+$")
            try self.trainingDataConfig.validate(name: "\(name).trainingDataConfig")
            try self.validationDataConfig?.validate(name: "\(name).validationDataConfig")
            try self.vpcConfig?.validate(name: "\(name).vpcConfig")
        }

        private enum CodingKeys: String, CodingKey {
            case baseModelIdentifier = "baseModelIdentifier"
            case clientRequestToken = "clientRequestToken"
            case customizationConfig = "customizationConfig"
            case customizationType = "customizationType"
            case customModelKmsKeyId = "customModelKmsKeyId"
            case customModelName = "customModelName"
            case customModelTags = "customModelTags"
            case hyperParameters = "hyperParameters"
            case jobName = "jobName"
            case jobTags = "jobTags"
            case outputDataConfig = "outputDataConfig"
            case roleArn = "roleArn"
            case trainingDataConfig = "trainingDataConfig"
            case validationDataConfig = "validationDataConfig"
            case vpcConfig = "vpcConfig"
        }
    }

    public struct CreateModelCustomizationJobResponse: AWSDecodableShape {
        /// Amazon Resource Name (ARN) of the fine tuning job
        public let jobArn: String

        @inlinable
        public init(jobArn: String) {
            self.jobArn = jobArn
        }

        private enum CodingKeys: String, CodingKey {
            case jobArn = "jobArn"
        }
    }

    public struct CreateModelImportJobRequest: AWSEncodableShape {
        /// A unique, case-sensitive identifier to ensure that the API request completes no more than one time. If this token matches a previous request, Amazon Bedrock ignores the request, but does not return an error. For more information,  see Ensuring idempotency.
        public let clientRequestToken: String?
        /// The imported model is encrypted at rest using this key.
        public let importedModelKmsKeyId: String?
        /// The name of the imported model.
        public let importedModelName: String
        /// Tags to attach to the imported model.
        public let importedModelTags: [Tag]?
        /// The name of the import job.
        public let jobName: String
        /// Tags to attach to this import job.
        public let jobTags: [Tag]?
        /// The data source for the imported model.
        public let modelDataSource: ModelDataSource
        /// The Amazon Resource Name (ARN) of the model import job.
        public let roleArn: String
        /// VPC configuration parameters for the private Virtual Private Cloud (VPC) that contains the resources you are using for the import job.
        public let vpcConfig: VpcConfig?

        @inlinable
        public init(clientRequestToken: String? = nil, importedModelKmsKeyId: String? = nil, importedModelName: String, importedModelTags: [Tag]? = nil, jobName: String, jobTags: [Tag]? = nil, modelDataSource: ModelDataSource, roleArn: String, vpcConfig: VpcConfig? = nil) {
            self.clientRequestToken = clientRequestToken
            self.importedModelKmsKeyId = importedModelKmsKeyId
            self.importedModelName = importedModelName
            self.importedModelTags = importedModelTags
            self.jobName = jobName
            self.jobTags = jobTags
            self.modelDataSource = modelDataSource
            self.roleArn = roleArn
            self.vpcConfig = vpcConfig
        }

        public func validate(name: String) throws {
            try self.validate(self.clientRequestToken, name: "clientRequestToken", parent: name, max: 256)
            try self.validate(self.clientRequestToken, name: "clientRequestToken", parent: name, min: 1)
            try self.validate(self.clientRequestToken, name: "clientRequestToken", parent: name, pattern: "^[a-zA-Z0-9](-*[a-zA-Z0-9])*$")
            try self.validate(self.importedModelKmsKeyId, name: "importedModelKmsKeyId", parent: name, max: 2048)
            try self.validate(self.importedModelKmsKeyId, name: "importedModelKmsKeyId", parent: name, min: 1)
            try self.validate(self.importedModelKmsKeyId, name: "importedModelKmsKeyId", parent: name, pattern: "^(arn:aws(-[^:]+)?:kms:[a-zA-Z0-9-]*:[0-9]{12}:((key/[a-zA-Z0-9-]{36})|(alias/[a-zA-Z0-9-_/]+)))|([a-zA-Z0-9-]{36})|(alias/[a-zA-Z0-9-_/]+)$")
            try self.validate(self.importedModelName, name: "importedModelName", parent: name, max: 63)
            try self.validate(self.importedModelName, name: "importedModelName", parent: name, min: 1)
            try self.validate(self.importedModelName, name: "importedModelName", parent: name, pattern: "^([0-9a-zA-Z][_-]?)+$")
            try self.importedModelTags?.forEach {
                try $0.validate(name: "\(name).importedModelTags[]")
            }
            try self.validate(self.importedModelTags, name: "importedModelTags", parent: name, max: 200)
            try self.validate(self.jobName, name: "jobName", parent: name, max: 63)
            try self.validate(self.jobName, name: "jobName", parent: name, min: 1)
            try self.validate(self.jobName, name: "jobName", parent: name, pattern: "^[a-zA-Z0-9](-*[a-zA-Z0-9\\+\\-\\.])*$")
            try self.jobTags?.forEach {
                try $0.validate(name: "\(name).jobTags[]")
            }
            try self.validate(self.jobTags, name: "jobTags", parent: name, max: 200)
            try self.modelDataSource.validate(name: "\(name).modelDataSource")
            try self.validate(self.roleArn, name: "roleArn", parent: name, max: 2048)
            try self.validate(self.roleArn, name: "roleArn", parent: name, pattern: "^arn:aws(-[^:]+)?:iam::([0-9]{12})?:role/.+$")
            try self.vpcConfig?.validate(name: "\(name).vpcConfig")
        }

        private enum CodingKeys: String, CodingKey {
            case clientRequestToken = "clientRequestToken"
            case importedModelKmsKeyId = "importedModelKmsKeyId"
            case importedModelName = "importedModelName"
            case importedModelTags = "importedModelTags"
            case jobName = "jobName"
            case jobTags = "jobTags"
            case modelDataSource = "modelDataSource"
            case roleArn = "roleArn"
            case vpcConfig = "vpcConfig"
        }
    }

    public struct CreateModelImportJobResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the model import job.
        public let jobArn: String

        @inlinable
        public init(jobArn: String) {
            self.jobArn = jobArn
        }

        private enum CodingKeys: String, CodingKey {
            case jobArn = "jobArn"
        }
    }

    public struct CreateModelInvocationJobRequest: AWSEncodableShape {
        /// A unique, case-sensitive identifier to ensure that the API request completes no more than one time. If this token matches a previous request, Amazon Bedrock ignores the request, but does not return an error. For more information, see Ensuring idempotency.
        public let clientRequestToken: String?
        /// Details about the location of the input to the batch inference job.
        public let inputDataConfig: ModelInvocationJobInputDataConfig
        /// A name to give the batch inference job.
        public let jobName: String
        /// The unique identifier of the foundation model to use for the batch inference job.
        public let modelId: String
        /// Details about the location of the output of the batch inference job.
        public let outputDataConfig: ModelInvocationJobOutputDataConfig
        /// The Amazon Resource Name (ARN) of the service role with permissions to carry out and manage batch inference. You can use the console to create a default service role or follow the steps at Create a service role for batch inference.
        public let roleArn: String
        /// Any tags to associate with the batch inference job. For more information, see Tagging Amazon Bedrock resources.
        public let tags: [Tag]?
        /// The number of hours after which to force the batch inference job to time out.
        public let timeoutDurationInHours: Int?
        /// The configuration of the Virtual Private Cloud (VPC) for the data in the batch inference job. For more information, see Protect batch inference jobs using a VPC.
        public let vpcConfig: VpcConfig?

        @inlinable
        public init(clientRequestToken: String? = CreateModelInvocationJobRequest.idempotencyToken(), inputDataConfig: ModelInvocationJobInputDataConfig, jobName: String, modelId: String, outputDataConfig: ModelInvocationJobOutputDataConfig, roleArn: String, tags: [Tag]? = nil, timeoutDurationInHours: Int? = nil, vpcConfig: VpcConfig? = nil) {
            self.clientRequestToken = clientRequestToken
            self.inputDataConfig = inputDataConfig
            self.jobName = jobName
            self.modelId = modelId
            self.outputDataConfig = outputDataConfig
            self.roleArn = roleArn
            self.tags = tags
            self.timeoutDurationInHours = timeoutDurationInHours
            self.vpcConfig = vpcConfig
        }

        public func validate(name: String) throws {
            try self.validate(self.clientRequestToken, name: "clientRequestToken", parent: name, max: 256)
            try self.validate(self.clientRequestToken, name: "clientRequestToken", parent: name, min: 1)
            try self.validate(self.clientRequestToken, name: "clientRequestToken", parent: name, pattern: "^[a-zA-Z0-9]{1,256}(-*[a-zA-Z0-9]){0,256}$")
            try self.inputDataConfig.validate(name: "\(name).inputDataConfig")
            try self.validate(self.jobName, name: "jobName", parent: name, max: 63)
            try self.validate(self.jobName, name: "jobName", parent: name, min: 1)
            try self.validate(self.jobName, name: "jobName", parent: name, pattern: "^[a-zA-Z0-9]{1,63}(-*[a-zA-Z0-9\\+\\-\\.]){0,63}$")
            try self.validate(self.modelId, name: "modelId", parent: name, max: 2048)
            try self.validate(self.modelId, name: "modelId", parent: name, min: 1)
            try self.validate(self.modelId, name: "modelId", parent: name, pattern: "^(arn:aws(-[^:]+)?:bedrock:[a-z0-9-]{1,20}:(([0-9]{12}:custom-model/[a-z0-9-]{1,63}[.]{1}[a-z0-9-:]{1,63}/[a-z0-9]{12}$)|(:foundation-model/[a-z0-9-]{1,63}[.]{1}[a-z0-9-]{1,63}$)))|([a-z0-9-]{1,63}[.]{1}[a-z0-9-]{1,63}([.]?[a-z0-9-]{1,63})([:][a-z0-9-]{1,63}){0,2})|(([0-9a-zA-Z][_-]?)+)$")
            try self.outputDataConfig.validate(name: "\(name).outputDataConfig")
            try self.validate(self.roleArn, name: "roleArn", parent: name, max: 2048)
            try self.validate(self.roleArn, name: "roleArn", parent: name, pattern: "^arn:aws(-[^:]+)?:iam::([0-9]{12})?:role/.+$")
            try self.tags?.forEach {
                try $0.validate(name: "\(name).tags[]")
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 200)
            try self.validate(self.timeoutDurationInHours, name: "timeoutDurationInHours", parent: name, max: 168)
            try self.validate(self.timeoutDurationInHours, name: "timeoutDurationInHours", parent: name, min: 24)
            try self.vpcConfig?.validate(name: "\(name).vpcConfig")
        }

        private enum CodingKeys: String, CodingKey {
            case clientRequestToken = "clientRequestToken"
            case inputDataConfig = "inputDataConfig"
            case jobName = "jobName"
            case modelId = "modelId"
            case outputDataConfig = "outputDataConfig"
            case roleArn = "roleArn"
            case tags = "tags"
            case timeoutDurationInHours = "timeoutDurationInHours"
            case vpcConfig = "vpcConfig"
        }
    }

    public struct CreateModelInvocationJobResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the batch inference job.
        public let jobArn: String

        @inlinable
        public init(jobArn: String) {
            self.jobArn = jobArn
        }

        private enum CodingKeys: String, CodingKey {
            case jobArn = "jobArn"
        }
    }

    public struct CreateProvisionedModelThroughputRequest: AWSEncodableShape {
        /// A unique, case-sensitive identifier to ensure that the API request completes no more than one time. If this token matches a previous request, Amazon Bedrock ignores the request, but does not return an error. For more information, see Ensuring idempotency in the Amazon S3 User Guide.
        public let clientRequestToken: String?
        /// The commitment duration requested for the Provisioned Throughput. Billing occurs hourly and is discounted for longer commitment terms. To request a no-commit Provisioned Throughput, omit this field. Custom models support all levels of commitment. To see which base models support no commitment, see Supported regions and models for Provisioned Throughput in the Amazon Bedrock User Guide
        public let commitmentDuration: CommitmentDuration?
        /// The Amazon Resource Name (ARN) or name of the model to associate with this Provisioned Throughput. For a list of models for which you can purchase Provisioned Throughput, see Amazon Bedrock model IDs for purchasing Provisioned Throughput in the Amazon Bedrock User Guide.
        public let modelId: String
        /// Number of model units to allocate. A model unit delivers a specific throughput level for the specified model. The throughput level of a model unit specifies the total number of input and output tokens that it can process and generate within a span of one minute. By default, your account has no model units for purchasing Provisioned Throughputs with commitment. You must first visit the Amazon Web Services support center to request MUs. For model unit quotas, see Provisioned Throughput quotas in the Amazon Bedrock User Guide. For more information about what an MU specifies, contact your Amazon Web Services account manager.
        public let modelUnits: Int
        /// The name for this Provisioned Throughput.
        public let provisionedModelName: String
        /// Tags to associate with this Provisioned Throughput.
        public let tags: [Tag]?

        @inlinable
        public init(clientRequestToken: String? = CreateProvisionedModelThroughputRequest.idempotencyToken(), commitmentDuration: CommitmentDuration? = nil, modelId: String, modelUnits: Int, provisionedModelName: String, tags: [Tag]? = nil) {
            self.clientRequestToken = clientRequestToken
            self.commitmentDuration = commitmentDuration
            self.modelId = modelId
            self.modelUnits = modelUnits
            self.provisionedModelName = provisionedModelName
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.validate(self.clientRequestToken, name: "clientRequestToken", parent: name, max: 256)
            try self.validate(self.clientRequestToken, name: "clientRequestToken", parent: name, min: 1)
            try self.validate(self.clientRequestToken, name: "clientRequestToken", parent: name, pattern: "^[a-zA-Z0-9](-*[a-zA-Z0-9])*$")
            try self.validate(self.modelId, name: "modelId", parent: name, max: 2048)
            try self.validate(self.modelId, name: "modelId", parent: name, min: 1)
            try self.validate(self.modelId, name: "modelId", parent: name, pattern: "^arn:aws(-[^:]+)?:bedrock:[a-z0-9-]{1,20}:(([0-9]{12}:custom-model/[a-z0-9-]{1,63}[.]{1}[a-z0-9-]{1,63}(([:][a-z0-9-]{1,63}){0,2})?/[a-z0-9]{12})|(:foundation-model/([a-z0-9-]{1,63}[.]{1}[a-z0-9-]{1,63}([.]?[a-z0-9-]{1,63})([:][a-z0-9-]{1,63}){0,2})))|(([a-z0-9-]{1,63}[.]{1}[a-z0-9-]{1,63}([.]?[a-z0-9-]{1,63})([:][a-z0-9-]{1,63}){0,2}))|(([0-9a-zA-Z][_-]?)+)$")
            try self.validate(self.modelUnits, name: "modelUnits", parent: name, min: 1)
            try self.validate(self.provisionedModelName, name: "provisionedModelName", parent: name, max: 63)
            try self.validate(self.provisionedModelName, name: "provisionedModelName", parent: name, min: 1)
            try self.validate(self.provisionedModelName, name: "provisionedModelName", parent: name, pattern: "^([0-9a-zA-Z][_-]?)+$")
            try self.tags?.forEach {
                try $0.validate(name: "\(name).tags[]")
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 200)
        }

        private enum CodingKeys: String, CodingKey {
            case clientRequestToken = "clientRequestToken"
            case commitmentDuration = "commitmentDuration"
            case modelId = "modelId"
            case modelUnits = "modelUnits"
            case provisionedModelName = "provisionedModelName"
            case tags = "tags"
        }
    }

    public struct CreateProvisionedModelThroughputResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) for this Provisioned Throughput.
        public let provisionedModelArn: String

        @inlinable
        public init(provisionedModelArn: String) {
            self.provisionedModelArn = provisionedModelArn
        }

        private enum CodingKeys: String, CodingKey {
            case provisionedModelArn = "provisionedModelArn"
        }
    }

    public struct CustomModelSummary: AWSDecodableShape {
        /// The base model Amazon Resource Name (ARN).
        public let baseModelArn: String
        /// The base model name.
        public let baseModelName: String
        /// Creation time of the model.
        @CustomCoding<ISO8601DateCoder>
        public var creationTime: Date
        /// Specifies whether to carry out continued pre-training of a model or whether to fine-tune it. For more information, see Custom models.
        public let customizationType: CustomizationType?
        /// The Amazon Resource Name (ARN) of the custom model.
        public let modelArn: String
        /// The name of the custom model.
        public let modelName: String
        /// The unique identifier of the account that owns the model.
        public let ownerAccountId: String?

        @inlinable
        public init(baseModelArn: String, baseModelName: String, creationTime: Date, customizationType: CustomizationType? = nil, modelArn: String, modelName: String, ownerAccountId: String? = nil) {
            self.baseModelArn = baseModelArn
            self.baseModelName = baseModelName
            self.creationTime = creationTime
            self.customizationType = customizationType
            self.modelArn = modelArn
            self.modelName = modelName
            self.ownerAccountId = ownerAccountId
        }

        private enum CodingKeys: String, CodingKey {
            case baseModelArn = "baseModelArn"
            case baseModelName = "baseModelName"
            case creationTime = "creationTime"
            case customizationType = "customizationType"
            case modelArn = "modelArn"
            case modelName = "modelName"
            case ownerAccountId = "ownerAccountId"
        }
    }

    public struct DeleteCustomModelRequest: AWSEncodableShape {
        /// Name of the model to delete.
        public let modelIdentifier: String

        @inlinable
        public init(modelIdentifier: String) {
            self.modelIdentifier = modelIdentifier
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.modelIdentifier, key: "modelIdentifier")
        }

        public func validate(name: String) throws {
            try self.validate(self.modelIdentifier, name: "modelIdentifier", parent: name, max: 2048)
            try self.validate(self.modelIdentifier, name: "modelIdentifier", parent: name, min: 1)
            try self.validate(self.modelIdentifier, name: "modelIdentifier", parent: name, pattern: "^arn:aws(-[^:]+)?:bedrock:[a-z0-9-]{1,20}:(([0-9]{12}:custom-model/[a-z0-9-]{1,63}[.]{1}[a-z0-9-]{1,63}(([:][a-z0-9-]{1,63}){0,2})?/[a-z0-9]{12})|(:foundation-model/([a-z0-9-]{1,63}[.]{1}[a-z0-9-]{1,63}([.]?[a-z0-9-]{1,63})([:][a-z0-9-]{1,63}){0,2})))|(([a-z0-9-]{1,63}[.]{1}[a-z0-9-]{1,63}([.]?[a-z0-9-]{1,63})([:][a-z0-9-]{1,63}){0,2}))|(([0-9a-zA-Z][_-]?)+)$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteCustomModelResponse: AWSDecodableShape {
        public init() {}
    }

    public struct DeleteGuardrailRequest: AWSEncodableShape {
        /// The unique identifier of the guardrail.  This can be an ID or the ARN.
        public let guardrailIdentifier: String
        /// The version of the guardrail.
        public let guardrailVersion: String?

        @inlinable
        public init(guardrailIdentifier: String, guardrailVersion: String? = nil) {
            self.guardrailIdentifier = guardrailIdentifier
            self.guardrailVersion = guardrailVersion
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.guardrailIdentifier, key: "guardrailIdentifier")
            request.encodeQuery(self.guardrailVersion, key: "guardrailVersion")
        }

        public func validate(name: String) throws {
            try self.validate(self.guardrailIdentifier, name: "guardrailIdentifier", parent: name, max: 2048)
            try self.validate(self.guardrailIdentifier, name: "guardrailIdentifier", parent: name, pattern: "^(([a-z0-9]+)|(arn:aws(-[^:]+)?:bedrock:[a-z0-9-]{1,20}:[0-9]{12}:guardrail/[a-z0-9]+))$")
            try self.validate(self.guardrailVersion, name: "guardrailVersion", parent: name, pattern: "^[1-9][0-9]{0,7}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteGuardrailResponse: AWSDecodableShape {
        public init() {}
    }

    public struct DeleteImportedModelRequest: AWSEncodableShape {
        /// Name of the imported model to delete.
        public let modelIdentifier: String

        @inlinable
        public init(modelIdentifier: String) {
            self.modelIdentifier = modelIdentifier
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.modelIdentifier, key: "modelIdentifier")
        }

        public func validate(name: String) throws {
            try self.validate(self.modelIdentifier, name: "modelIdentifier", parent: name, max: 1011)
            try self.validate(self.modelIdentifier, name: "modelIdentifier", parent: name, min: 1)
            try self.validate(self.modelIdentifier, name: "modelIdentifier", parent: name, pattern: "^(arn:aws(-[^:]+)?:bedrock:[a-z0-9-]{1,20}:[0-9]{12}:imported-model/[a-z0-9]{12})|(([0-9a-zA-Z][_-]?)+)$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteImportedModelResponse: AWSDecodableShape {
        public init() {}
    }

    public struct DeleteInferenceProfileRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) or ID of the application inference profile to delete.
        public let inferenceProfileIdentifier: String

        @inlinable
        public init(inferenceProfileIdentifier: String) {
            self.inferenceProfileIdentifier = inferenceProfileIdentifier
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.inferenceProfileIdentifier, key: "inferenceProfileIdentifier")
        }

        public func validate(name: String) throws {
            try self.validate(self.inferenceProfileIdentifier, name: "inferenceProfileIdentifier", parent: name, max: 2048)
            try self.validate(self.inferenceProfileIdentifier, name: "inferenceProfileIdentifier", parent: name, min: 1)
            try self.validate(self.inferenceProfileIdentifier, name: "inferenceProfileIdentifier", parent: name, pattern: "^(arn:aws(|-us-gov|-cn|-iso|-iso-b):bedrock:(|[0-9a-z-]{0,20}):(|[0-9]{12}):(inference-profile|application-inference-profile)/)?[a-zA-Z0-9-:.]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteInferenceProfileResponse: AWSDecodableShape {
        public init() {}
    }

    public struct DeleteMarketplaceModelEndpointRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the endpoint you want to delete.
        public let endpointArn: String

        @inlinable
        public init(endpointArn: String) {
            self.endpointArn = endpointArn
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.endpointArn, key: "endpointArn")
        }

        public func validate(name: String) throws {
            try self.validate(self.endpointArn, name: "endpointArn", parent: name, max: 2048)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteMarketplaceModelEndpointResponse: AWSDecodableShape {
        public init() {}
    }

    public struct DeleteModelInvocationLoggingConfigurationRequest: AWSEncodableShape {
        public init() {}
    }

    public struct DeleteModelInvocationLoggingConfigurationResponse: AWSDecodableShape {
        public init() {}
    }

    public struct DeleteProvisionedModelThroughputRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) or name of the Provisioned Throughput.
        public let provisionedModelId: String

        @inlinable
        public init(provisionedModelId: String) {
            self.provisionedModelId = provisionedModelId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.provisionedModelId, key: "provisionedModelId")
        }

        public func validate(name: String) throws {
            try self.validate(self.provisionedModelId, name: "provisionedModelId", parent: name, pattern: "^((([0-9a-zA-Z][_-]?)+)|(arn:aws(-[^:]+)?:bedrock:[a-z0-9-]{1,20}:[0-9]{12}:provisioned-model/[a-z0-9]{12}))$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteProvisionedModelThroughputResponse: AWSDecodableShape {
        public init() {}
    }

    public struct DeregisterMarketplaceModelEndpointRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the endpoint you want to deregister.
        public let endpointArn: String

        @inlinable
        public init(endpointArn: String) {
            self.endpointArn = endpointArn
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.endpointArn, key: "endpointArn")
        }

        public func validate(name: String) throws {
            try self.validate(self.endpointArn, name: "endpointArn", parent: name, max: 2048)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeregisterMarketplaceModelEndpointResponse: AWSDecodableShape {
        public init() {}
    }

    public struct DistillationConfig: AWSEncodableShape & AWSDecodableShape {
        /// The teacher model configuration.
        public let teacherModelConfig: TeacherModelConfig

        @inlinable
        public init(teacherModelConfig: TeacherModelConfig) {
            self.teacherModelConfig = teacherModelConfig
        }

        public func validate(name: String) throws {
            try self.teacherModelConfig.validate(name: "\(name).teacherModelConfig")
        }

        private enum CodingKeys: String, CodingKey {
            case teacherModelConfig = "teacherModelConfig"
        }
    }

    public struct EvaluationBedrockModel: AWSEncodableShape & AWSDecodableShape {
        /// Each Amazon Bedrock support different inference parameters that change how the model behaves during inference.
        public let inferenceParams: String?
        /// The ARN of the Amazon Bedrock model or inference profile specified.
        public let modelIdentifier: String

        @inlinable
        public init(inferenceParams: String? = nil, modelIdentifier: String) {
            self.inferenceParams = inferenceParams
            self.modelIdentifier = modelIdentifier
        }

        public func validate(name: String) throws {
            try self.validate(self.inferenceParams, name: "inferenceParams", parent: name, max: 1023)
            try self.validate(self.inferenceParams, name: "inferenceParams", parent: name, min: 1)
            try self.validate(self.modelIdentifier, name: "modelIdentifier", parent: name, max: 2048)
            try self.validate(self.modelIdentifier, name: "modelIdentifier", parent: name, min: 1)
            try self.validate(self.modelIdentifier, name: "modelIdentifier", parent: name, pattern: "^(arn:aws(-[^:]+)?:bedrock:[a-z0-9-]{1,20}:((:foundation-model/[a-z0-9-]{1,63}[.]{1}[a-z0-9-]{1,63}([.:]?[a-z0-9-]{1,63}))|([0-9]{12}:provisioned-model/[a-z0-9]{12})|([0-9]{12}:imported-model/[a-z0-9]{12})|([0-9]{12}:application-inference-profile/[a-z0-9]{12})|([0-9]{12}:inference-profile/(([a-z-]{2,8}.)[a-z0-9-]{1,63}[.]{1}[a-z0-9-]{1,63}([.:]?[a-z0-9-]{1,63})))|([0-9]{12}:default-prompt-router/[a-zA-Z0-9-:.]+)))|(([a-z]{2}[.]{1})([a-z0-9-]{1,63}[.]{1}[a-z0-9-]{1,63}([.:]?[a-z0-9-]{1,63})))|([a-z0-9-]{1,63}[.]{1}[a-z0-9-]{1,63}([.:]?[a-z0-9-]{1,63}))|arn:aws(-[^:]+)?:sagemaker:[a-z0-9-]{1,20}:[0-9]{12}:endpoint/[a-z0-9-]{1,63}$")
        }

        private enum CodingKeys: String, CodingKey {
            case inferenceParams = "inferenceParams"
            case modelIdentifier = "modelIdentifier"
        }
    }

    public struct EvaluationDataset: AWSEncodableShape & AWSDecodableShape {
        /// For custom prompt datasets, you must specify the location in Amazon S3 where the prompt dataset is saved.
        public let datasetLocation: EvaluationDatasetLocation?
        /// Used to specify supported built-in prompt datasets. Valid values are Builtin.Bold, Builtin.BoolQ, Builtin.NaturalQuestions, Builtin.Gigaword, Builtin.RealToxicityPrompts, Builtin.TriviaQA, Builtin.T-Rex, Builtin.WomensEcommerceClothingReviews and Builtin.Wikitext2.
        public let name: String

        @inlinable
        public init(datasetLocation: EvaluationDatasetLocation? = nil, name: String) {
            self.datasetLocation = datasetLocation
            self.name = name
        }

        public func validate(name: String) throws {
            try self.datasetLocation?.validate(name: "\(name).datasetLocation")
            try self.validate(self.name, name: "name", parent: name, max: 63)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[0-9a-zA-Z-_.]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case datasetLocation = "datasetLocation"
            case name = "name"
        }
    }

    public struct EvaluationDatasetMetricConfig: AWSEncodableShape & AWSDecodableShape {
        /// Specifies the prompt dataset.
        public let dataset: EvaluationDataset
        /// The names of the metrics you want to use for your evaluation job. For knowledge base evaluation jobs that evaluate retrieval only, valid values are   "Builtin.ContextRelevance", "Builtin.ContextConverage". For knowledge base evaluation jobs that evaluate retrieval with response generation,  valid values are  "Builtin.Correctness", "Builtin.Completeness",  "Builtin.Helpfulness", "Builtin.LogicalCoherence",  "Builtin.Faithfulness", "Builtin.Harmfulness",  "Builtin.Stereotyping", "Builtin.Refusal". For automated model evaluation jobs, valid values are "Builtin.Accuracy", "Builtin.Robustness", and "Builtin.Toxicity". In model evaluation jobs that use a LLM as judge you can specify "Builtin.Correctness", "Builtin.Completeness", "Builtin.Faithfulness", "Builtin.Helpfulness", "Builtin.Coherence", "Builtin.Relevance", "Builtin.FollowingInstructions", "Builtin.ProfessionalStyleAndTone", You can also specify the following responsible AI related metrics only for model evaluation job that use a LLM as judge "Builtin.Harmfulness", "Builtin.Stereotyping", and "Builtin.Refusal". For human-based model evaluation jobs, the list of strings must match the  name parameter specified in HumanEvaluationCustomMetric.
        public let metricNames: [String]
        /// The the type of task you want to evaluate for your evaluation job. This applies only  to model evaluation jobs and is ignored for knowledge base evaluation jobs.
        public let taskType: EvaluationTaskType

        @inlinable
        public init(dataset: EvaluationDataset, metricNames: [String], taskType: EvaluationTaskType) {
            self.dataset = dataset
            self.metricNames = metricNames
            self.taskType = taskType
        }

        public func validate(name: String) throws {
            try self.dataset.validate(name: "\(name).dataset")
            try self.metricNames.forEach {
                try validate($0, name: "metricNames[]", parent: name, max: 63)
                try validate($0, name: "metricNames[]", parent: name, min: 1)
                try validate($0, name: "metricNames[]", parent: name, pattern: "^[0-9a-zA-Z-_.]+$")
            }
            try self.validate(self.metricNames, name: "metricNames", parent: name, max: 15)
            try self.validate(self.metricNames, name: "metricNames", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case dataset = "dataset"
            case metricNames = "metricNames"
            case taskType = "taskType"
        }
    }

    public struct EvaluationOutputDataConfig: AWSEncodableShape & AWSDecodableShape {
        /// The Amazon S3 URI where the results of the evaluation job are saved.
        public let s3Uri: String

        @inlinable
        public init(s3Uri: String) {
            self.s3Uri = s3Uri
        }

        public func validate(name: String) throws {
            try self.validate(self.s3Uri, name: "s3Uri", parent: name, max: 1024)
            try self.validate(self.s3Uri, name: "s3Uri", parent: name, min: 1)
            try self.validate(self.s3Uri, name: "s3Uri", parent: name, pattern: "^s3://[a-z0-9][-.a-z0-9]{1,61}(?:/[-!_*'().a-z0-9A-Z]+(?:/[-!_*'().a-z0-9A-Z]+)*)?/?$")
        }

        private enum CodingKeys: String, CodingKey {
            case s3Uri = "s3Uri"
        }
    }

    public struct EvaluationSummary: AWSDecodableShape {
        /// Specifies whether the evaluation job is for evaluating a model or evaluating a knowledge base (retrieval and response generation).
        public let applicationType: ApplicationType?
        /// The time the evaluation job was created.
        @CustomCoding<ISO8601DateCoder>
        public var creationTime: Date
        /// The type of task for model evaluation.
        public let evaluationTaskTypes: [EvaluationTaskType]
        /// The Amazon Resource Names (ARNs) of the models used to compute the metrics for a knowledge base evaluation job.
        public let evaluatorModelIdentifiers: [String]?
        /// The Amazon Resource Name (ARN) of the evaluation job.
        public let jobArn: String
        /// The name for the evaluation job.
        public let jobName: String
        /// Specifies whether the evaluation job is automated or human-based.
        public let jobType: EvaluationJobType
        /// The Amazon Resource Names (ARNs) of the model(s) used for the evaluation job.
        public let modelIdentifiers: [String]?
        /// The Amazon Resource Names (ARNs) of the knowledge base resources used for a knowledge base evaluation job.
        public let ragIdentifiers: [String]?
        /// The current status of the evaluation job.
        public let status: EvaluationJobStatus

        @inlinable
        public init(applicationType: ApplicationType? = nil, creationTime: Date, evaluationTaskTypes: [EvaluationTaskType], evaluatorModelIdentifiers: [String]? = nil, jobArn: String, jobName: String, jobType: EvaluationJobType, modelIdentifiers: [String]? = nil, ragIdentifiers: [String]? = nil, status: EvaluationJobStatus) {
            self.applicationType = applicationType
            self.creationTime = creationTime
            self.evaluationTaskTypes = evaluationTaskTypes
            self.evaluatorModelIdentifiers = evaluatorModelIdentifiers
            self.jobArn = jobArn
            self.jobName = jobName
            self.jobType = jobType
            self.modelIdentifiers = modelIdentifiers
            self.ragIdentifiers = ragIdentifiers
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case applicationType = "applicationType"
            case creationTime = "creationTime"
            case evaluationTaskTypes = "evaluationTaskTypes"
            case evaluatorModelIdentifiers = "evaluatorModelIdentifiers"
            case jobArn = "jobArn"
            case jobName = "jobName"
            case jobType = "jobType"
            case modelIdentifiers = "modelIdentifiers"
            case ragIdentifiers = "ragIdentifiers"
            case status = "status"
        }
    }

    public struct ExternalSource: AWSEncodableShape & AWSDecodableShape {
        /// The identifier, content type, and data of the external source wrapper object.
        public let byteContent: ByteContentDoc?
        /// The S3 location of the external source wrapper object.
        public let s3Location: S3ObjectDoc?
        /// The source type of the external source wrapper object.
        public let sourceType: ExternalSourceType

        @inlinable
        public init(byteContent: ByteContentDoc? = nil, s3Location: S3ObjectDoc? = nil, sourceType: ExternalSourceType) {
            self.byteContent = byteContent
            self.s3Location = s3Location
            self.sourceType = sourceType
        }

        public func validate(name: String) throws {
            try self.byteContent?.validate(name: "\(name).byteContent")
            try self.s3Location?.validate(name: "\(name).s3Location")
        }

        private enum CodingKeys: String, CodingKey {
            case byteContent = "byteContent"
            case s3Location = "s3Location"
            case sourceType = "sourceType"
        }
    }

    public struct ExternalSourcesGenerationConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// Additional model parameters and their corresponding values not included in the  text inference configuration for an external source. Takes in custom model parameters  specific to the language model being used.
        public let additionalModelRequestFields: [String: String]?
        /// Configuration details for the guardrail.
        public let guardrailConfiguration: GuardrailConfiguration?
        /// Configuration details for inference when using RetrieveAndGenerate to generate  responses while using an external source.
        public let kbInferenceConfig: KbInferenceConfig?
        /// Contains the template for the prompt for the external source wrapper object.
        public let promptTemplate: PromptTemplate?

        @inlinable
        public init(additionalModelRequestFields: [String: String]? = nil, guardrailConfiguration: GuardrailConfiguration? = nil, kbInferenceConfig: KbInferenceConfig? = nil, promptTemplate: PromptTemplate? = nil) {
            self.additionalModelRequestFields = additionalModelRequestFields
            self.guardrailConfiguration = guardrailConfiguration
            self.kbInferenceConfig = kbInferenceConfig
            self.promptTemplate = promptTemplate
        }

        public func validate(name: String) throws {
            try self.additionalModelRequestFields?.forEach {
                try validate($0.key, name: "additionalModelRequestFields.key", parent: name, max: 100)
                try validate($0.key, name: "additionalModelRequestFields.key", parent: name, min: 1)
            }
            try self.kbInferenceConfig?.validate(name: "\(name).kbInferenceConfig")
            try self.promptTemplate?.validate(name: "\(name).promptTemplate")
        }

        private enum CodingKeys: String, CodingKey {
            case additionalModelRequestFields = "additionalModelRequestFields"
            case guardrailConfiguration = "guardrailConfiguration"
            case kbInferenceConfig = "kbInferenceConfig"
            case promptTemplate = "promptTemplate"
        }
    }

    public struct ExternalSourcesRetrieveAndGenerateConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// Contains configurations details for response generation based on retrieved text chunks.
        public let generationConfiguration: ExternalSourcesGenerationConfiguration?
        /// The Amazon Resource Name (ARN) of the foundation model or inference profile used to generate responses.
        public let modelArn: String
        /// The document for the external source wrapper object in the retrieveAndGenerate function.
        public let sources: [ExternalSource]

        @inlinable
        public init(generationConfiguration: ExternalSourcesGenerationConfiguration? = nil, modelArn: String, sources: [ExternalSource]) {
            self.generationConfiguration = generationConfiguration
            self.modelArn = modelArn
            self.sources = sources
        }

        public func validate(name: String) throws {
            try self.generationConfiguration?.validate(name: "\(name).generationConfiguration")
            try self.validate(self.modelArn, name: "modelArn", parent: name, max: 2048)
            try self.validate(self.modelArn, name: "modelArn", parent: name, min: 1)
            try self.validate(self.modelArn, name: "modelArn", parent: name, pattern: "^(arn:aws(-[^:]+)?:bedrock:[a-z0-9-]{1,20}:(([0-9]{12}:custom-model/[a-z0-9-]{1,63}[.]{1}[a-z0-9-]{1,63}/[a-z0-9]{12})|(:foundation-model/[a-z0-9-]{1,63}[.]{1}[a-z0-9-]{1,63}([.:]?[a-z0-9-]{1,63}))))|(arn:aws(|-us-gov|-cn|-iso|-iso-b):bedrock:(|[0-9a-z-]{1,20}):(|[0-9]{12}):inference-profile/[a-zA-Z0-9-:.]+)|([a-z0-9-]{1,63}[.]{1}[a-z0-9-]{1,63}([.:]?[a-z0-9-]{1,63}))|(([0-9a-zA-Z][_-]?)+)$")
            try self.sources.forEach {
                try $0.validate(name: "\(name).sources[]")
            }
            try self.validate(self.sources, name: "sources", parent: name, max: 1)
            try self.validate(self.sources, name: "sources", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case generationConfiguration = "generationConfiguration"
            case modelArn = "modelArn"
            case sources = "sources"
        }
    }

    public struct FilterAttribute: AWSEncodableShape & AWSDecodableShape {
        /// The name of metadata attribute/field, which must match the name in your  data source/document metadata.
        public let key: String
        /// The value of the metadata attribute/field.
        public let value: String

        @inlinable
        public init(key: String, value: String) {
            self.key = key
            self.value = value
        }

        public func validate(name: String) throws {
            try self.validate(self.key, name: "key", parent: name, max: 100)
            try self.validate(self.key, name: "key", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case key = "key"
            case value = "value"
        }
    }

    public struct FoundationModelDetails: AWSDecodableShape {
        /// The customization that the model supports.
        public let customizationsSupported: [ModelCustomization]?
        /// The inference types that the model supports.
        public let inferenceTypesSupported: [InferenceType]?
        /// The input modalities that the model supports.
        public let inputModalities: [ModelModality]?
        /// The model Amazon Resource Name (ARN).
        public let modelArn: String
        /// The model identifier.
        public let modelId: String
        /// Contains details about whether a model version is available or deprecated
        public let modelLifecycle: FoundationModelLifecycle?
        /// The model name.
        public let modelName: String?
        /// The output modalities that the model supports.
        public let outputModalities: [ModelModality]?
        /// The model's provider name.
        public let providerName: String?
        /// Indicates whether the model supports streaming.
        public let responseStreamingSupported: Bool?

        @inlinable
        public init(customizationsSupported: [ModelCustomization]? = nil, inferenceTypesSupported: [InferenceType]? = nil, inputModalities: [ModelModality]? = nil, modelArn: String, modelId: String, modelLifecycle: FoundationModelLifecycle? = nil, modelName: String? = nil, outputModalities: [ModelModality]? = nil, providerName: String? = nil, responseStreamingSupported: Bool? = nil) {
            self.customizationsSupported = customizationsSupported
            self.inferenceTypesSupported = inferenceTypesSupported
            self.inputModalities = inputModalities
            self.modelArn = modelArn
            self.modelId = modelId
            self.modelLifecycle = modelLifecycle
            self.modelName = modelName
            self.outputModalities = outputModalities
            self.providerName = providerName
            self.responseStreamingSupported = responseStreamingSupported
        }

        private enum CodingKeys: String, CodingKey {
            case customizationsSupported = "customizationsSupported"
            case inferenceTypesSupported = "inferenceTypesSupported"
            case inputModalities = "inputModalities"
            case modelArn = "modelArn"
            case modelId = "modelId"
            case modelLifecycle = "modelLifecycle"
            case modelName = "modelName"
            case outputModalities = "outputModalities"
            case providerName = "providerName"
            case responseStreamingSupported = "responseStreamingSupported"
        }
    }

    public struct FoundationModelLifecycle: AWSDecodableShape {
        /// Specifies whether a model version is available (ACTIVE) or deprecated (LEGACY.
        public let status: FoundationModelLifecycleStatus

        @inlinable
        public init(status: FoundationModelLifecycleStatus) {
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case status = "status"
        }
    }

    public struct FoundationModelSummary: AWSDecodableShape {
        /// Whether the model supports fine-tuning or continual pre-training.
        public let customizationsSupported: [ModelCustomization]?
        /// The inference types that the model supports.
        public let inferenceTypesSupported: [InferenceType]?
        /// The input modalities that the model supports.
        public let inputModalities: [ModelModality]?
        /// The Amazon Resource Name (ARN) of the foundation model.
        public let modelArn: String
        /// The model ID of the foundation model.
        public let modelId: String
        /// Contains details about whether a model version is available or deprecated.
        public let modelLifecycle: FoundationModelLifecycle?
        /// The name of the model.
        public let modelName: String?
        /// The output modalities that the model supports.
        public let outputModalities: [ModelModality]?
        /// The model's provider name.
        public let providerName: String?
        /// Indicates whether the model supports streaming.
        public let responseStreamingSupported: Bool?

        @inlinable
        public init(customizationsSupported: [ModelCustomization]? = nil, inferenceTypesSupported: [InferenceType]? = nil, inputModalities: [ModelModality]? = nil, modelArn: String, modelId: String, modelLifecycle: FoundationModelLifecycle? = nil, modelName: String? = nil, outputModalities: [ModelModality]? = nil, providerName: String? = nil, responseStreamingSupported: Bool? = nil) {
            self.customizationsSupported = customizationsSupported
            self.inferenceTypesSupported = inferenceTypesSupported
            self.inputModalities = inputModalities
            self.modelArn = modelArn
            self.modelId = modelId
            self.modelLifecycle = modelLifecycle
            self.modelName = modelName
            self.outputModalities = outputModalities
            self.providerName = providerName
            self.responseStreamingSupported = responseStreamingSupported
        }

        private enum CodingKeys: String, CodingKey {
            case customizationsSupported = "customizationsSupported"
            case inferenceTypesSupported = "inferenceTypesSupported"
            case inputModalities = "inputModalities"
            case modelArn = "modelArn"
            case modelId = "modelId"
            case modelLifecycle = "modelLifecycle"
            case modelName = "modelName"
            case outputModalities = "outputModalities"
            case providerName = "providerName"
            case responseStreamingSupported = "responseStreamingSupported"
        }
    }

    public struct GenerationConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// Additional model parameters and corresponding values not included in the  textInferenceConfig structure for a knowledge base. This allows  you to provide custom model parameters specific to the language model being  used.
        public let additionalModelRequestFields: [String: String]?
        /// Contains configuration details for the guardrail.
        public let guardrailConfiguration: GuardrailConfiguration?
        /// Contains configuration details for inference for knowledge base retrieval and response generation.
        public let kbInferenceConfig: KbInferenceConfig?
        /// Contains the template for the prompt that's sent to the model for response generation.
        public let promptTemplate: PromptTemplate?

        @inlinable
        public init(additionalModelRequestFields: [String: String]? = nil, guardrailConfiguration: GuardrailConfiguration? = nil, kbInferenceConfig: KbInferenceConfig? = nil, promptTemplate: PromptTemplate? = nil) {
            self.additionalModelRequestFields = additionalModelRequestFields
            self.guardrailConfiguration = guardrailConfiguration
            self.kbInferenceConfig = kbInferenceConfig
            self.promptTemplate = promptTemplate
        }

        public func validate(name: String) throws {
            try self.additionalModelRequestFields?.forEach {
                try validate($0.key, name: "additionalModelRequestFields.key", parent: name, max: 100)
                try validate($0.key, name: "additionalModelRequestFields.key", parent: name, min: 1)
            }
            try self.kbInferenceConfig?.validate(name: "\(name).kbInferenceConfig")
            try self.promptTemplate?.validate(name: "\(name).promptTemplate")
        }

        private enum CodingKeys: String, CodingKey {
            case additionalModelRequestFields = "additionalModelRequestFields"
            case guardrailConfiguration = "guardrailConfiguration"
            case kbInferenceConfig = "kbInferenceConfig"
            case promptTemplate = "promptTemplate"
        }
    }

    public struct GetCustomModelRequest: AWSEncodableShape {
        /// Name or Amazon Resource Name (ARN) of the custom model.
        public let modelIdentifier: String

        @inlinable
        public init(modelIdentifier: String) {
            self.modelIdentifier = modelIdentifier
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.modelIdentifier, key: "modelIdentifier")
        }

        public func validate(name: String) throws {
            try self.validate(self.modelIdentifier, name: "modelIdentifier", parent: name, max: 2048)
            try self.validate(self.modelIdentifier, name: "modelIdentifier", parent: name, min: 1)
            try self.validate(self.modelIdentifier, name: "modelIdentifier", parent: name, pattern: "^arn:aws(-[^:]+)?:bedrock:[a-z0-9-]{1,20}:(([0-9]{12}:custom-model/[a-z0-9-]{1,63}[.]{1}[a-z0-9-]{1,63}(([:][a-z0-9-]{1,63}){0,2})?/[a-z0-9]{12})|(:foundation-model/([a-z0-9-]{1,63}[.]{1}[a-z0-9-]{1,63}([.]?[a-z0-9-]{1,63})([:][a-z0-9-]{1,63}){0,2})))|(([a-z0-9-]{1,63}[.]{1}[a-z0-9-]{1,63}([.]?[a-z0-9-]{1,63})([:][a-z0-9-]{1,63}){0,2}))|(([0-9a-zA-Z][_-]?)+)$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetCustomModelResponse: AWSDecodableShape {
        /// Amazon Resource Name (ARN) of the base model.
        public let baseModelArn: String
        /// Creation time of the model.
        @CustomCoding<ISO8601DateCoder>
        public var creationTime: Date
        /// The customization configuration for the custom model.
        public let customizationConfig: CustomizationConfig?
        /// The type of model customization.
        public let customizationType: CustomizationType?
        /// Hyperparameter values associated with this model. For details on the format for different models, see Custom model hyperparameters.
        public let hyperParameters: [String: String]?
        /// Job Amazon Resource Name (ARN) associated with this model.
        public let jobArn: String
        /// Job name associated with this model.
        public let jobName: String?
        /// Amazon Resource Name (ARN) associated with this model.
        public let modelArn: String
        /// The custom model is encrypted at rest using this key.
        public let modelKmsKeyArn: String?
        /// Model name associated with this model.
        public let modelName: String
        /// Output data configuration associated with this custom model.
        public let outputDataConfig: OutputDataConfig
        /// Contains information about the training dataset.
        public let trainingDataConfig: TrainingDataConfig
        /// Contains training metrics from the job creation.
        public let trainingMetrics: TrainingMetrics?
        /// Contains information about the validation dataset.
        public let validationDataConfig: ValidationDataConfig?
        /// The validation metrics from the job creation.
        public let validationMetrics: [ValidatorMetric]?

        @inlinable
        public init(baseModelArn: String, creationTime: Date, customizationConfig: CustomizationConfig? = nil, customizationType: CustomizationType? = nil, hyperParameters: [String: String]? = nil, jobArn: String, jobName: String? = nil, modelArn: String, modelKmsKeyArn: String? = nil, modelName: String, outputDataConfig: OutputDataConfig, trainingDataConfig: TrainingDataConfig, trainingMetrics: TrainingMetrics? = nil, validationDataConfig: ValidationDataConfig? = nil, validationMetrics: [ValidatorMetric]? = nil) {
            self.baseModelArn = baseModelArn
            self.creationTime = creationTime
            self.customizationConfig = customizationConfig
            self.customizationType = customizationType
            self.hyperParameters = hyperParameters
            self.jobArn = jobArn
            self.jobName = jobName
            self.modelArn = modelArn
            self.modelKmsKeyArn = modelKmsKeyArn
            self.modelName = modelName
            self.outputDataConfig = outputDataConfig
            self.trainingDataConfig = trainingDataConfig
            self.trainingMetrics = trainingMetrics
            self.validationDataConfig = validationDataConfig
            self.validationMetrics = validationMetrics
        }

        private enum CodingKeys: String, CodingKey {
            case baseModelArn = "baseModelArn"
            case creationTime = "creationTime"
            case customizationConfig = "customizationConfig"
            case customizationType = "customizationType"
            case hyperParameters = "hyperParameters"
            case jobArn = "jobArn"
            case jobName = "jobName"
            case modelArn = "modelArn"
            case modelKmsKeyArn = "modelKmsKeyArn"
            case modelName = "modelName"
            case outputDataConfig = "outputDataConfig"
            case trainingDataConfig = "trainingDataConfig"
            case trainingMetrics = "trainingMetrics"
            case validationDataConfig = "validationDataConfig"
            case validationMetrics = "validationMetrics"
        }
    }

    public struct GetEvaluationJobRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the evaluation job you want get information on.
        public let jobIdentifier: String

        @inlinable
        public init(jobIdentifier: String) {
            self.jobIdentifier = jobIdentifier
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.jobIdentifier, key: "jobIdentifier")
        }

        public func validate(name: String) throws {
            try self.validate(self.jobIdentifier, name: "jobIdentifier", parent: name, max: 1011)
            try self.validate(self.jobIdentifier, name: "jobIdentifier", parent: name, pattern: "^(arn:aws(-[^:]+)?:bedrock:[a-z0-9-]{1,20}:[0-9]{12}:evaluation-job/[a-z0-9]{12})$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetEvaluationJobResponse: AWSDecodableShape {
        /// Specifies whether the evaluation job is for evaluating a model or evaluating a knowledge base (retrieval and response generation).
        public let applicationType: ApplicationType?
        /// The time the evaluation job was created.
        @CustomCoding<ISO8601DateCoder>
        public var creationTime: Date
        /// The Amazon Resource Name (ARN) of the customer managed encryption key specified when the evaluation job was created.
        public let customerEncryptionKeyId: String?
        /// Contains the configuration details of either an automated or human-based evaluation job.
        public let evaluationConfig: EvaluationConfig
        /// A list of strings that specify why the evaluation job failed to create.
        public let failureMessages: [String]?
        /// Contains the configuration details of the inference model used for the evaluation job.
        public let inferenceConfig: EvaluationInferenceConfig
        /// The Amazon Resource Name (ARN) of the evaluation job.
        public let jobArn: String
        /// The description of the evaluation job.
        public let jobDescription: String?
        /// The name for the evaluation job.
        public let jobName: String
        /// Specifies whether the evaluation job is automated or human-based.
        public let jobType: EvaluationJobType
        /// The time the evaluation job was last modified.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var lastModifiedTime: Date?
        /// Contains the configuration details of the Amazon S3 bucket for  storing the results of the evaluation job.
        public let outputDataConfig: EvaluationOutputDataConfig
        /// The Amazon Resource Name (ARN) of the IAM service role used in the evaluation job.
        public let roleArn: String
        /// The current status of the evaluation job.
        public let status: EvaluationJobStatus

        @inlinable
        public init(applicationType: ApplicationType? = nil, creationTime: Date, customerEncryptionKeyId: String? = nil, evaluationConfig: EvaluationConfig, failureMessages: [String]? = nil, inferenceConfig: EvaluationInferenceConfig, jobArn: String, jobDescription: String? = nil, jobName: String, jobType: EvaluationJobType, lastModifiedTime: Date? = nil, outputDataConfig: EvaluationOutputDataConfig, roleArn: String, status: EvaluationJobStatus) {
            self.applicationType = applicationType
            self.creationTime = creationTime
            self.customerEncryptionKeyId = customerEncryptionKeyId
            self.evaluationConfig = evaluationConfig
            self.failureMessages = failureMessages
            self.inferenceConfig = inferenceConfig
            self.jobArn = jobArn
            self.jobDescription = jobDescription
            self.jobName = jobName
            self.jobType = jobType
            self.lastModifiedTime = lastModifiedTime
            self.outputDataConfig = outputDataConfig
            self.roleArn = roleArn
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case applicationType = "applicationType"
            case creationTime = "creationTime"
            case customerEncryptionKeyId = "customerEncryptionKeyId"
            case evaluationConfig = "evaluationConfig"
            case failureMessages = "failureMessages"
            case inferenceConfig = "inferenceConfig"
            case jobArn = "jobArn"
            case jobDescription = "jobDescription"
            case jobName = "jobName"
            case jobType = "jobType"
            case lastModifiedTime = "lastModifiedTime"
            case outputDataConfig = "outputDataConfig"
            case roleArn = "roleArn"
            case status = "status"
        }
    }

    public struct GetFoundationModelRequest: AWSEncodableShape {
        /// The model identifier.
        public let modelIdentifier: String

        @inlinable
        public init(modelIdentifier: String) {
            self.modelIdentifier = modelIdentifier
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.modelIdentifier, key: "modelIdentifier")
        }

        public func validate(name: String) throws {
            try self.validate(self.modelIdentifier, name: "modelIdentifier", parent: name, max: 2048)
            try self.validate(self.modelIdentifier, name: "modelIdentifier", parent: name, min: 1)
            try self.validate(self.modelIdentifier, name: "modelIdentifier", parent: name, pattern: "^arn:aws(-[^:]+)?:bedrock:[a-z0-9-]{1,20}:(([0-9]{12}:custom-model/[a-z0-9-]{1,63}[.]{1}[a-z0-9-]{1,63}(([:][a-z0-9-]{1,63}){0,2})?/[a-z0-9]{12})|(:foundation-model/([a-z0-9-]{1,63}[.]{1}[a-z0-9-]{1,63}([.]?[a-z0-9-]{1,63})([:][a-z0-9-]{1,63}){0,2})))|(([a-z0-9-]{1,63}[.]{1}[a-z0-9-]{1,63}([.]?[a-z0-9-]{1,63})([:][a-z0-9-]{1,63}){0,2}))|(([0-9a-zA-Z][_-]?)+)$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetFoundationModelResponse: AWSDecodableShape {
        /// Information about the foundation model.
        public let modelDetails: FoundationModelDetails?

        @inlinable
        public init(modelDetails: FoundationModelDetails? = nil) {
            self.modelDetails = modelDetails
        }

        private enum CodingKeys: String, CodingKey {
            case modelDetails = "modelDetails"
        }
    }

    public struct GetGuardrailRequest: AWSEncodableShape {
        /// The unique identifier of the guardrail for which to get details.  This can be an ID or the ARN.
        public let guardrailIdentifier: String
        /// The version of the guardrail for which to get details. If you don't specify a version, the response returns details for the DRAFT version.
        public let guardrailVersion: String?

        @inlinable
        public init(guardrailIdentifier: String, guardrailVersion: String? = nil) {
            self.guardrailIdentifier = guardrailIdentifier
            self.guardrailVersion = guardrailVersion
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.guardrailIdentifier, key: "guardrailIdentifier")
            request.encodeQuery(self.guardrailVersion, key: "guardrailVersion")
        }

        public func validate(name: String) throws {
            try self.validate(self.guardrailIdentifier, name: "guardrailIdentifier", parent: name, max: 2048)
            try self.validate(self.guardrailIdentifier, name: "guardrailIdentifier", parent: name, pattern: "^(([a-z0-9]+)|(arn:aws(-[^:]+)?:bedrock:[a-z0-9-]{1,20}:[0-9]{12}:guardrail/[a-z0-9]+))$")
            try self.validate(self.guardrailVersion, name: "guardrailVersion", parent: name, pattern: "^(([1-9][0-9]{0,7})|(DRAFT))$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetGuardrailResponse: AWSDecodableShape {
        /// The message that the guardrail returns when it blocks a prompt.
        public let blockedInputMessaging: String
        /// The message that the guardrail returns when it blocks a model response.
        public let blockedOutputsMessaging: String
        /// The content policy that was configured for the guardrail.
        public let contentPolicy: GuardrailContentPolicy?
        /// The contextual grounding policy used in the guardrail.
        public let contextualGroundingPolicy: GuardrailContextualGroundingPolicy?
        /// The date and time at which the guardrail was created.
        @CustomCoding<ISO8601DateCoder>
        public var createdAt: Date
        /// The description of the guardrail.
        public let description: String?
        /// Appears if the status of the guardrail is FAILED. A list of recommendations to carry out before retrying the request.
        public let failureRecommendations: [String]?
        /// The ARN of the guardrail.
        public let guardrailArn: String
        /// The unique identifier of the guardrail.
        public let guardrailId: String
        /// The ARN of the KMS key that encrypts the guardrail.
        public let kmsKeyArn: String?
        /// The name of the guardrail.
        public let name: String
        /// The sensitive information policy that was configured for the guardrail.
        public let sensitiveInformationPolicy: GuardrailSensitiveInformationPolicy?
        /// The status of the guardrail.
        public let status: GuardrailStatus
        /// Appears if the status is FAILED. A list of reasons for why the guardrail failed to be created, updated, versioned, or deleted.
        public let statusReasons: [String]?
        /// The topic policy that was configured for the guardrail.
        public let topicPolicy: GuardrailTopicPolicy?
        /// The date and time at which the guardrail was updated.
        @CustomCoding<ISO8601DateCoder>
        public var updatedAt: Date
        /// The version of the guardrail.
        public let version: String
        /// The word policy that was configured for the guardrail.
        public let wordPolicy: GuardrailWordPolicy?

        @inlinable
        public init(blockedInputMessaging: String, blockedOutputsMessaging: String, contentPolicy: GuardrailContentPolicy? = nil, contextualGroundingPolicy: GuardrailContextualGroundingPolicy? = nil, createdAt: Date, description: String? = nil, failureRecommendations: [String]? = nil, guardrailArn: String, guardrailId: String, kmsKeyArn: String? = nil, name: String, sensitiveInformationPolicy: GuardrailSensitiveInformationPolicy? = nil, status: GuardrailStatus, statusReasons: [String]? = nil, topicPolicy: GuardrailTopicPolicy? = nil, updatedAt: Date, version: String, wordPolicy: GuardrailWordPolicy? = nil) {
            self.blockedInputMessaging = blockedInputMessaging
            self.blockedOutputsMessaging = blockedOutputsMessaging
            self.contentPolicy = contentPolicy
            self.contextualGroundingPolicy = contextualGroundingPolicy
            self.createdAt = createdAt
            self.description = description
            self.failureRecommendations = failureRecommendations
            self.guardrailArn = guardrailArn
            self.guardrailId = guardrailId
            self.kmsKeyArn = kmsKeyArn
            self.name = name
            self.sensitiveInformationPolicy = sensitiveInformationPolicy
            self.status = status
            self.statusReasons = statusReasons
            self.topicPolicy = topicPolicy
            self.updatedAt = updatedAt
            self.version = version
            self.wordPolicy = wordPolicy
        }

        private enum CodingKeys: String, CodingKey {
            case blockedInputMessaging = "blockedInputMessaging"
            case blockedOutputsMessaging = "blockedOutputsMessaging"
            case contentPolicy = "contentPolicy"
            case contextualGroundingPolicy = "contextualGroundingPolicy"
            case createdAt = "createdAt"
            case description = "description"
            case failureRecommendations = "failureRecommendations"
            case guardrailArn = "guardrailArn"
            case guardrailId = "guardrailId"
            case kmsKeyArn = "kmsKeyArn"
            case name = "name"
            case sensitiveInformationPolicy = "sensitiveInformationPolicy"
            case status = "status"
            case statusReasons = "statusReasons"
            case topicPolicy = "topicPolicy"
            case updatedAt = "updatedAt"
            case version = "version"
            case wordPolicy = "wordPolicy"
        }
    }

    public struct GetImportedModelRequest: AWSEncodableShape {
        /// Name or Amazon Resource Name (ARN) of the imported model.
        public let modelIdentifier: String

        @inlinable
        public init(modelIdentifier: String) {
            self.modelIdentifier = modelIdentifier
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.modelIdentifier, key: "modelIdentifier")
        }

        public func validate(name: String) throws {
            try self.validate(self.modelIdentifier, name: "modelIdentifier", parent: name, max: 1011)
            try self.validate(self.modelIdentifier, name: "modelIdentifier", parent: name, min: 1)
            try self.validate(self.modelIdentifier, name: "modelIdentifier", parent: name, pattern: "^(arn:aws(-[^:]+)?:bedrock:[a-z0-9-]{1,20}:[0-9]{12}:imported-model/[a-z0-9]{12})|(([0-9a-zA-Z][_-]?)+)$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetImportedModelResponse: AWSDecodableShape {
        /// Creation time of the imported model.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var creationTime: Date?
        /// Specifies if the imported model supports converse.
        public let instructSupported: Bool?
        /// Job Amazon Resource Name (ARN) associated with the imported model.
        public let jobArn: String?
        /// Job name associated with the imported model.
        public let jobName: String?
        /// The architecture of the imported model.
        public let modelArchitecture: String?
        /// The Amazon Resource Name (ARN) associated with this imported model.
        public let modelArn: String?
        /// The data source for this imported model.
        public let modelDataSource: ModelDataSource?
        /// The imported model is encrypted at rest using this key.
        public let modelKmsKeyArn: String?
        /// The name of the imported model.
        public let modelName: String?

        @inlinable
        public init(creationTime: Date? = nil, instructSupported: Bool? = nil, jobArn: String? = nil, jobName: String? = nil, modelArchitecture: String? = nil, modelArn: String? = nil, modelDataSource: ModelDataSource? = nil, modelKmsKeyArn: String? = nil, modelName: String? = nil) {
            self.creationTime = creationTime
            self.instructSupported = instructSupported
            self.jobArn = jobArn
            self.jobName = jobName
            self.modelArchitecture = modelArchitecture
            self.modelArn = modelArn
            self.modelDataSource = modelDataSource
            self.modelKmsKeyArn = modelKmsKeyArn
            self.modelName = modelName
        }

        private enum CodingKeys: String, CodingKey {
            case creationTime = "creationTime"
            case instructSupported = "instructSupported"
            case jobArn = "jobArn"
            case jobName = "jobName"
            case modelArchitecture = "modelArchitecture"
            case modelArn = "modelArn"
            case modelDataSource = "modelDataSource"
            case modelKmsKeyArn = "modelKmsKeyArn"
            case modelName = "modelName"
        }
    }

    public struct GetInferenceProfileRequest: AWSEncodableShape {
        /// The ID or Amazon Resource Name (ARN) of the inference profile.
        public let inferenceProfileIdentifier: String

        @inlinable
        public init(inferenceProfileIdentifier: String) {
            self.inferenceProfileIdentifier = inferenceProfileIdentifier
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.inferenceProfileIdentifier, key: "inferenceProfileIdentifier")
        }

        public func validate(name: String) throws {
            try self.validate(self.inferenceProfileIdentifier, name: "inferenceProfileIdentifier", parent: name, max: 2048)
            try self.validate(self.inferenceProfileIdentifier, name: "inferenceProfileIdentifier", parent: name, min: 1)
            try self.validate(self.inferenceProfileIdentifier, name: "inferenceProfileIdentifier", parent: name, pattern: "^(arn:aws(|-us-gov|-cn|-iso|-iso-b):bedrock:(|[0-9a-z-]{0,20}):(|[0-9]{12}):(inference-profile|application-inference-profile)/)?[a-zA-Z0-9-:.]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetInferenceProfileResponse: AWSDecodableShape {
        /// The time at which the inference profile was created.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var createdAt: Date?
        /// The description of the inference profile.
        public let description: String?
        /// The Amazon Resource Name (ARN) of the inference profile.
        public let inferenceProfileArn: String
        /// The unique identifier of the inference profile.
        public let inferenceProfileId: String
        /// The name of the inference profile.
        public let inferenceProfileName: String
        /// A list of information about each model in the inference profile.
        public let models: [InferenceProfileModel]
        /// The status of the inference profile. ACTIVE means that the inference profile is ready to be used.
        public let status: InferenceProfileStatus
        /// The type of the inference profile. The following types are possible:    SYSTEM_DEFINED – The inference profile is defined by Amazon Bedrock. You can route inference requests across regions with these inference profiles.    APPLICATION – The inference profile was created by a user. This type of inference profile can track metrics and costs when invoking the model in it. The inference profile may route requests to one or multiple regions.
        public let type: InferenceProfileType
        /// The time at which the inference profile was last updated.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var updatedAt: Date?

        @inlinable
        public init(createdAt: Date? = nil, description: String? = nil, inferenceProfileArn: String, inferenceProfileId: String, inferenceProfileName: String, models: [InferenceProfileModel], status: InferenceProfileStatus, type: InferenceProfileType, updatedAt: Date? = nil) {
            self.createdAt = createdAt
            self.description = description
            self.inferenceProfileArn = inferenceProfileArn
            self.inferenceProfileId = inferenceProfileId
            self.inferenceProfileName = inferenceProfileName
            self.models = models
            self.status = status
            self.type = type
            self.updatedAt = updatedAt
        }

        private enum CodingKeys: String, CodingKey {
            case createdAt = "createdAt"
            case description = "description"
            case inferenceProfileArn = "inferenceProfileArn"
            case inferenceProfileId = "inferenceProfileId"
            case inferenceProfileName = "inferenceProfileName"
            case models = "models"
            case status = "status"
            case type = "type"
            case updatedAt = "updatedAt"
        }
    }

    public struct GetMarketplaceModelEndpointRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the endpoint you want to get information about.
        public let endpointArn: String

        @inlinable
        public init(endpointArn: String) {
            self.endpointArn = endpointArn
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.endpointArn, key: "endpointArn")
        }

        public func validate(name: String) throws {
            try self.validate(self.endpointArn, name: "endpointArn", parent: name, max: 2048)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetMarketplaceModelEndpointResponse: AWSDecodableShape {
        /// Details about the requested endpoint.
        public let marketplaceModelEndpoint: MarketplaceModelEndpoint?

        @inlinable
        public init(marketplaceModelEndpoint: MarketplaceModelEndpoint? = nil) {
            self.marketplaceModelEndpoint = marketplaceModelEndpoint
        }

        private enum CodingKeys: String, CodingKey {
            case marketplaceModelEndpoint = "marketplaceModelEndpoint"
        }
    }

    public struct GetModelCopyJobRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the model copy job.
        public let jobArn: String

        @inlinable
        public init(jobArn: String) {
            self.jobArn = jobArn
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.jobArn, key: "jobArn")
        }

        public func validate(name: String) throws {
            try self.validate(self.jobArn, name: "jobArn", parent: name, max: 1011)
            try self.validate(self.jobArn, name: "jobArn", parent: name, pattern: "^arn:aws(-[^:]+)?:bedrock:[a-z0-9-]{1,20}:[0-9]{12}:model-copy-job/[a-z0-9]{12}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetModelCopyJobResponse: AWSDecodableShape {
        /// The time at which the model copy job was created.
        @CustomCoding<ISO8601DateCoder>
        public var creationTime: Date
        /// An error message for why the model copy job failed.
        public let failureMessage: String?
        /// The Amazon Resource Name (ARN) of the model copy job.
        public let jobArn: String
        /// The unique identifier of the account that the model being copied originated from.
        public let sourceAccountId: String
        /// The Amazon Resource Name (ARN) of the original model being copied.
        public let sourceModelArn: String
        /// The name of the original model being copied.
        public let sourceModelName: String?
        /// The status of the model copy job.
        public let status: ModelCopyJobStatus
        /// The Amazon Resource Name (ARN) of the copied model.
        public let targetModelArn: String
        /// The Amazon Resource Name (ARN) of the KMS key encrypting the copied model.
        public let targetModelKmsKeyArn: String?
        /// The name of the copied model.
        public let targetModelName: String?
        /// The tags associated with the copied model.
        public let targetModelTags: [Tag]?

        @inlinable
        public init(creationTime: Date, failureMessage: String? = nil, jobArn: String, sourceAccountId: String, sourceModelArn: String, sourceModelName: String? = nil, status: ModelCopyJobStatus, targetModelArn: String, targetModelKmsKeyArn: String? = nil, targetModelName: String? = nil, targetModelTags: [Tag]? = nil) {
            self.creationTime = creationTime
            self.failureMessage = failureMessage
            self.jobArn = jobArn
            self.sourceAccountId = sourceAccountId
            self.sourceModelArn = sourceModelArn
            self.sourceModelName = sourceModelName
            self.status = status
            self.targetModelArn = targetModelArn
            self.targetModelKmsKeyArn = targetModelKmsKeyArn
            self.targetModelName = targetModelName
            self.targetModelTags = targetModelTags
        }

        private enum CodingKeys: String, CodingKey {
            case creationTime = "creationTime"
            case failureMessage = "failureMessage"
            case jobArn = "jobArn"
            case sourceAccountId = "sourceAccountId"
            case sourceModelArn = "sourceModelArn"
            case sourceModelName = "sourceModelName"
            case status = "status"
            case targetModelArn = "targetModelArn"
            case targetModelKmsKeyArn = "targetModelKmsKeyArn"
            case targetModelName = "targetModelName"
            case targetModelTags = "targetModelTags"
        }
    }

    public struct GetModelCustomizationJobRequest: AWSEncodableShape {
        /// Identifier for the customization job.
        public let jobIdentifier: String

        @inlinable
        public init(jobIdentifier: String) {
            self.jobIdentifier = jobIdentifier
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.jobIdentifier, key: "jobIdentifier")
        }

        public func validate(name: String) throws {
            try self.validate(self.jobIdentifier, name: "jobIdentifier", parent: name, max: 1011)
            try self.validate(self.jobIdentifier, name: "jobIdentifier", parent: name, pattern: "^(arn:aws(-[^:]+)?:bedrock:[a-z0-9-]{1,20}:[0-9]{12}:model-customization-job/[a-z0-9-]{1,63}[.]{1}[a-z0-9-]{1,63}([a-z0-9-]{1,63}[.]){0,2}[a-z0-9-]{1,63}([:][a-z0-9-]{1,63}){0,2}/[a-z0-9]{12})|([a-zA-Z0-9](-*[a-zA-Z0-9\\+\\-\\.])*)$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetModelCustomizationJobResponse: AWSDecodableShape {
        /// Amazon Resource Name (ARN) of the base model.
        public let baseModelArn: String
        /// The token that you specified in the CreateCustomizationJob request.
        public let clientRequestToken: String?
        /// Time that the resource was created.
        @CustomCoding<ISO8601DateCoder>
        public var creationTime: Date
        /// The customization configuration for the model customization job.
        public let customizationConfig: CustomizationConfig?
        /// The type of model customization.
        public let customizationType: CustomizationType?
        /// Time that the resource transitioned to terminal state.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var endTime: Date?
        /// Information about why the job failed.
        public let failureMessage: String?
        /// The hyperparameter values for the job. For details on the format for different models, see Custom model hyperparameters.
        public let hyperParameters: [String: String]?
        /// The Amazon Resource Name (ARN) of the customization job.
        public let jobArn: String
        /// The name of the customization job.
        public let jobName: String
        /// Time that the resource was last modified.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var lastModifiedTime: Date?
        /// Output data configuration
        public let outputDataConfig: OutputDataConfig
        /// The Amazon Resource Name (ARN) of the output model.
        public let outputModelArn: String?
        /// The custom model is encrypted at rest using this key.
        public let outputModelKmsKeyArn: String?
        /// The name of the output model.
        public let outputModelName: String
        /// The Amazon Resource Name (ARN) of the IAM role.
        public let roleArn: String
        /// The status of the job. A successful job transitions from in-progress to completed when the output model is ready to use. If the job failed, the failure message contains information about why the job failed.
        public let status: ModelCustomizationJobStatus?
        /// Contains information about the training dataset.
        public let trainingDataConfig: TrainingDataConfig
        /// Contains training metrics from the job creation.
        public let trainingMetrics: TrainingMetrics?
        /// Contains information about the validation dataset.
        public let validationDataConfig: ValidationDataConfig
        /// The loss metric for each validator that you provided in the createjob request.
        public let validationMetrics: [ValidatorMetric]?
        /// VPC configuration for the custom model job.
        public let vpcConfig: VpcConfig?

        @inlinable
        public init(baseModelArn: String, clientRequestToken: String? = nil, creationTime: Date, customizationConfig: CustomizationConfig? = nil, customizationType: CustomizationType? = nil, endTime: Date? = nil, failureMessage: String? = nil, hyperParameters: [String: String]? = nil, jobArn: String, jobName: String, lastModifiedTime: Date? = nil, outputDataConfig: OutputDataConfig, outputModelArn: String? = nil, outputModelKmsKeyArn: String? = nil, outputModelName: String, roleArn: String, status: ModelCustomizationJobStatus? = nil, trainingDataConfig: TrainingDataConfig, trainingMetrics: TrainingMetrics? = nil, validationDataConfig: ValidationDataConfig, validationMetrics: [ValidatorMetric]? = nil, vpcConfig: VpcConfig? = nil) {
            self.baseModelArn = baseModelArn
            self.clientRequestToken = clientRequestToken
            self.creationTime = creationTime
            self.customizationConfig = customizationConfig
            self.customizationType = customizationType
            self.endTime = endTime
            self.failureMessage = failureMessage
            self.hyperParameters = hyperParameters
            self.jobArn = jobArn
            self.jobName = jobName
            self.lastModifiedTime = lastModifiedTime
            self.outputDataConfig = outputDataConfig
            self.outputModelArn = outputModelArn
            self.outputModelKmsKeyArn = outputModelKmsKeyArn
            self.outputModelName = outputModelName
            self.roleArn = roleArn
            self.status = status
            self.trainingDataConfig = trainingDataConfig
            self.trainingMetrics = trainingMetrics
            self.validationDataConfig = validationDataConfig
            self.validationMetrics = validationMetrics
            self.vpcConfig = vpcConfig
        }

        private enum CodingKeys: String, CodingKey {
            case baseModelArn = "baseModelArn"
            case clientRequestToken = "clientRequestToken"
            case creationTime = "creationTime"
            case customizationConfig = "customizationConfig"
            case customizationType = "customizationType"
            case endTime = "endTime"
            case failureMessage = "failureMessage"
            case hyperParameters = "hyperParameters"
            case jobArn = "jobArn"
            case jobName = "jobName"
            case lastModifiedTime = "lastModifiedTime"
            case outputDataConfig = "outputDataConfig"
            case outputModelArn = "outputModelArn"
            case outputModelKmsKeyArn = "outputModelKmsKeyArn"
            case outputModelName = "outputModelName"
            case roleArn = "roleArn"
            case status = "status"
            case trainingDataConfig = "trainingDataConfig"
            case trainingMetrics = "trainingMetrics"
            case validationDataConfig = "validationDataConfig"
            case validationMetrics = "validationMetrics"
            case vpcConfig = "vpcConfig"
        }
    }

    public struct GetModelImportJobRequest: AWSEncodableShape {
        /// The identifier of the import job.
        public let jobIdentifier: String

        @inlinable
        public init(jobIdentifier: String) {
            self.jobIdentifier = jobIdentifier
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.jobIdentifier, key: "jobIdentifier")
        }

        public func validate(name: String) throws {
            try self.validate(self.jobIdentifier, name: "jobIdentifier", parent: name, max: 1011)
            try self.validate(self.jobIdentifier, name: "jobIdentifier", parent: name, pattern: "^(arn:aws(-[^:]+)?:bedrock:[a-z0-9-]{1,20}:[0-9]{12}:model-import-job/[a-z0-9]{12})|([a-zA-Z0-9](-*[a-zA-Z0-9\\+\\-\\.])*)$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetModelImportJobResponse: AWSDecodableShape {
        /// The time the resource was created.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var creationTime: Date?
        /// Time that the resource transitioned to terminal state.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var endTime: Date?
        /// Information about why the import job failed.
        public let failureMessage: String?
        /// The Amazon Resource Name (ARN) of the imported model.
        public let importedModelArn: String?
        /// The imported model is encrypted at rest using this key.
        public let importedModelKmsKeyArn: String?
        /// The name of the imported model.
        public let importedModelName: String?
        /// The Amazon Resource Name (ARN) of the import job.
        public let jobArn: String?
        /// The name of the import job.
        public let jobName: String?
        /// Time the resource was last modified.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var lastModifiedTime: Date?
        /// The data source for the imported model.
        public let modelDataSource: ModelDataSource?
        /// The Amazon Resource Name (ARN) of the IAM role associated with this job.
        public let roleArn: String?
        /// The status of the job. A successful job transitions from in-progress to completed when the imported model is ready to use. If the job failed, the failure message contains information about why the job failed.
        public let status: ModelImportJobStatus?
        /// The Virtual Private Cloud (VPC) configuration of the import model job.
        public let vpcConfig: VpcConfig?

        @inlinable
        public init(creationTime: Date? = nil, endTime: Date? = nil, failureMessage: String? = nil, importedModelArn: String? = nil, importedModelKmsKeyArn: String? = nil, importedModelName: String? = nil, jobArn: String? = nil, jobName: String? = nil, lastModifiedTime: Date? = nil, modelDataSource: ModelDataSource? = nil, roleArn: String? = nil, status: ModelImportJobStatus? = nil, vpcConfig: VpcConfig? = nil) {
            self.creationTime = creationTime
            self.endTime = endTime
            self.failureMessage = failureMessage
            self.importedModelArn = importedModelArn
            self.importedModelKmsKeyArn = importedModelKmsKeyArn
            self.importedModelName = importedModelName
            self.jobArn = jobArn
            self.jobName = jobName
            self.lastModifiedTime = lastModifiedTime
            self.modelDataSource = modelDataSource
            self.roleArn = roleArn
            self.status = status
            self.vpcConfig = vpcConfig
        }

        private enum CodingKeys: String, CodingKey {
            case creationTime = "creationTime"
            case endTime = "endTime"
            case failureMessage = "failureMessage"
            case importedModelArn = "importedModelArn"
            case importedModelKmsKeyArn = "importedModelKmsKeyArn"
            case importedModelName = "importedModelName"
            case jobArn = "jobArn"
            case jobName = "jobName"
            case lastModifiedTime = "lastModifiedTime"
            case modelDataSource = "modelDataSource"
            case roleArn = "roleArn"
            case status = "status"
            case vpcConfig = "vpcConfig"
        }
    }

    public struct GetModelInvocationJobRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the batch inference job.
        public let jobIdentifier: String

        @inlinable
        public init(jobIdentifier: String) {
            self.jobIdentifier = jobIdentifier
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.jobIdentifier, key: "jobIdentifier")
        }

        public func validate(name: String) throws {
            try self.validate(self.jobIdentifier, name: "jobIdentifier", parent: name, max: 1011)
            try self.validate(self.jobIdentifier, name: "jobIdentifier", parent: name, pattern: "^((arn:aws(-[^:]+)?:bedrock:[a-z0-9-]{1,20}:[0-9]{12}:model-invocation-job/)?[a-z0-9]{12})$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetModelInvocationJobResponse: AWSDecodableShape {
        /// A unique, case-sensitive identifier to ensure that the API request completes no more than one time. If this token matches a previous request, Amazon Bedrock ignores the request, but does not return an error. For more information, see Ensuring idempotency.
        public let clientRequestToken: String?
        /// The time at which the batch inference job ended.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var endTime: Date?
        /// Details about the location of the input to the batch inference job.
        public let inputDataConfig: ModelInvocationJobInputDataConfig
        /// The Amazon Resource Name (ARN) of the batch inference job.
        public let jobArn: String
        /// The time at which the batch inference job times or timed out.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var jobExpirationTime: Date?
        /// The name of the batch inference job.
        public let jobName: String?
        /// The time at which the batch inference job was last modified.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var lastModifiedTime: Date?
        /// If the batch inference job failed, this field contains a message describing why the job failed.
        public let message: String?
        /// The unique identifier of the foundation model used for model inference.
        public let modelId: String
        /// Details about the location of the output of the batch inference job.
        public let outputDataConfig: ModelInvocationJobOutputDataConfig
        /// The Amazon Resource Name (ARN) of the service role with permissions to carry out and manage batch inference. You can use the console to create a default service role or follow the steps at Create a service role for batch inference.
        public let roleArn: String
        /// The status of the batch inference job. The following statuses are possible:   Submitted – This job has been submitted to a queue for validation.   Validating – This job is being validated for the requirements described in Format and upload your batch inference data. The criteria include the following:   Your IAM service role has access to the Amazon S3 buckets containing your files.   Your files are .jsonl files and each individual record is a JSON object in the correct format. Note that validation doesn't check if the modelInput value matches the request body for the model.   Your files fulfill the requirements for file size and number of records. For more information, see Quotas for Amazon Bedrock.     Scheduled – This job has been validated and is now in a queue. The job will automatically start when it reaches its turn.   Expired – This job timed out because it was scheduled but didn't begin before the set timeout duration. Submit a new job request.   InProgress – This job has begun. You can start viewing the results in the output S3 location.   Completed – This job has successfully completed. View the output files in the output S3 location.   PartiallyCompleted – This job has partially completed. Not all of your records could be processed in time. View the output files in the output S3 location.   Failed – This job has failed. Check the failure message for any further details. For further assistance, reach out to the Amazon Web Services Support Center.   Stopped – This job was stopped by a user.   Stopping – This job is being stopped by a user.
        public let status: ModelInvocationJobStatus?
        /// The time at which the batch inference job was submitted.
        @CustomCoding<ISO8601DateCoder>
        public var submitTime: Date
        /// The number of hours after which batch inference job was set to time out.
        public let timeoutDurationInHours: Int?
        /// The configuration of the Virtual Private Cloud (VPC) for the data in the batch inference job. For more information, see Protect batch inference jobs using a VPC.
        public let vpcConfig: VpcConfig?

        @inlinable
        public init(clientRequestToken: String? = nil, endTime: Date? = nil, inputDataConfig: ModelInvocationJobInputDataConfig, jobArn: String, jobExpirationTime: Date? = nil, jobName: String? = nil, lastModifiedTime: Date? = nil, message: String? = nil, modelId: String, outputDataConfig: ModelInvocationJobOutputDataConfig, roleArn: String, status: ModelInvocationJobStatus? = nil, submitTime: Date, timeoutDurationInHours: Int? = nil, vpcConfig: VpcConfig? = nil) {
            self.clientRequestToken = clientRequestToken
            self.endTime = endTime
            self.inputDataConfig = inputDataConfig
            self.jobArn = jobArn
            self.jobExpirationTime = jobExpirationTime
            self.jobName = jobName
            self.lastModifiedTime = lastModifiedTime
            self.message = message
            self.modelId = modelId
            self.outputDataConfig = outputDataConfig
            self.roleArn = roleArn
            self.status = status
            self.submitTime = submitTime
            self.timeoutDurationInHours = timeoutDurationInHours
            self.vpcConfig = vpcConfig
        }

        private enum CodingKeys: String, CodingKey {
            case clientRequestToken = "clientRequestToken"
            case endTime = "endTime"
            case inputDataConfig = "inputDataConfig"
            case jobArn = "jobArn"
            case jobExpirationTime = "jobExpirationTime"
            case jobName = "jobName"
            case lastModifiedTime = "lastModifiedTime"
            case message = "message"
            case modelId = "modelId"
            case outputDataConfig = "outputDataConfig"
            case roleArn = "roleArn"
            case status = "status"
            case submitTime = "submitTime"
            case timeoutDurationInHours = "timeoutDurationInHours"
            case vpcConfig = "vpcConfig"
        }
    }

    public struct GetModelInvocationLoggingConfigurationRequest: AWSEncodableShape {
        public init() {}
    }

    public struct GetModelInvocationLoggingConfigurationResponse: AWSDecodableShape {
        /// The current configuration values.
        public let loggingConfig: LoggingConfig?

        @inlinable
        public init(loggingConfig: LoggingConfig? = nil) {
            self.loggingConfig = loggingConfig
        }

        private enum CodingKeys: String, CodingKey {
            case loggingConfig = "loggingConfig"
        }
    }

    public struct GetPromptRouterRequest: AWSEncodableShape {
        /// The prompt router's ARN
        public let promptRouterArn: String

        @inlinable
        public init(promptRouterArn: String) {
            self.promptRouterArn = promptRouterArn
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.promptRouterArn, key: "promptRouterArn")
        }

        public func validate(name: String) throws {
            try self.validate(self.promptRouterArn, name: "promptRouterArn", parent: name, max: 2048)
            try self.validate(self.promptRouterArn, name: "promptRouterArn", parent: name, min: 1)
            try self.validate(self.promptRouterArn, name: "promptRouterArn", parent: name, pattern: "^arn:aws(-[^:]+)?:bedrock:[a-z0-9-]{1,20}:[0-9]{12}:default-prompt-router/[a-zA-Z0-9-:.]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetPromptRouterResponse: AWSDecodableShape {
        /// When the router was created.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var createdAt: Date?
        /// The router's description.
        public let description: String?
        /// The router's fallback model.
        public let fallbackModel: PromptRouterTargetModel
        /// The router's models.
        public let models: [PromptRouterTargetModel]
        /// The prompt router's ARN
        public let promptRouterArn: String
        /// The router's name.
        public let promptRouterName: String
        /// The router's routing criteria.
        public let routingCriteria: RoutingCriteria
        /// The router's status.
        public let status: PromptRouterStatus
        /// The router's type.
        public let type: PromptRouterType
        /// When the router was updated.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var updatedAt: Date?

        @inlinable
        public init(createdAt: Date? = nil, description: String? = nil, fallbackModel: PromptRouterTargetModel, models: [PromptRouterTargetModel], promptRouterArn: String, promptRouterName: String, routingCriteria: RoutingCriteria, status: PromptRouterStatus, type: PromptRouterType, updatedAt: Date? = nil) {
            self.createdAt = createdAt
            self.description = description
            self.fallbackModel = fallbackModel
            self.models = models
            self.promptRouterArn = promptRouterArn
            self.promptRouterName = promptRouterName
            self.routingCriteria = routingCriteria
            self.status = status
            self.type = type
            self.updatedAt = updatedAt
        }

        private enum CodingKeys: String, CodingKey {
            case createdAt = "createdAt"
            case description = "description"
            case fallbackModel = "fallbackModel"
            case models = "models"
            case promptRouterArn = "promptRouterArn"
            case promptRouterName = "promptRouterName"
            case routingCriteria = "routingCriteria"
            case status = "status"
            case type = "type"
            case updatedAt = "updatedAt"
        }
    }

    public struct GetProvisionedModelThroughputRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) or name of the Provisioned Throughput.
        public let provisionedModelId: String

        @inlinable
        public init(provisionedModelId: String) {
            self.provisionedModelId = provisionedModelId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.provisionedModelId, key: "provisionedModelId")
        }

        public func validate(name: String) throws {
            try self.validate(self.provisionedModelId, name: "provisionedModelId", parent: name, pattern: "^((([0-9a-zA-Z][_-]?)+)|(arn:aws(-[^:]+)?:bedrock:[a-z0-9-]{1,20}:[0-9]{12}:provisioned-model/[a-z0-9]{12}))$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetProvisionedModelThroughputResponse: AWSDecodableShape {
        /// Commitment duration of the Provisioned Throughput.
        public let commitmentDuration: CommitmentDuration?
        /// The timestamp for when the commitment term for the Provisioned Throughput expires.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var commitmentExpirationTime: Date?
        /// The timestamp of the creation time for this Provisioned Throughput.
        @CustomCoding<ISO8601DateCoder>
        public var creationTime: Date
        /// The Amazon Resource Name (ARN) of the model requested to be associated to this Provisioned Throughput. This value differs from the modelArn if updating hasn't completed.
        public let desiredModelArn: String
        /// The number of model units that was requested for this Provisioned Throughput.
        public let desiredModelUnits: Int
        /// A failure message for any issues that occurred during creation, updating, or deletion of the Provisioned Throughput.
        public let failureMessage: String?
        /// The Amazon Resource Name (ARN) of the base model for which the Provisioned Throughput was created, or of the base model that the custom model for which the Provisioned Throughput was created was customized.
        public let foundationModelArn: String
        /// The timestamp of the last time that this Provisioned Throughput was modified.
        @CustomCoding<ISO8601DateCoder>
        public var lastModifiedTime: Date
        /// The Amazon Resource Name (ARN) of the model associated with this Provisioned Throughput.
        public let modelArn: String
        /// The number of model units allocated to this Provisioned Throughput.
        public let modelUnits: Int
        /// The Amazon Resource Name (ARN) of the Provisioned Throughput.
        public let provisionedModelArn: String
        /// The name of the Provisioned Throughput.
        public let provisionedModelName: String
        /// The status of the Provisioned Throughput.
        public let status: ProvisionedModelStatus

        @inlinable
        public init(commitmentDuration: CommitmentDuration? = nil, commitmentExpirationTime: Date? = nil, creationTime: Date, desiredModelArn: String, desiredModelUnits: Int, failureMessage: String? = nil, foundationModelArn: String, lastModifiedTime: Date, modelArn: String, modelUnits: Int, provisionedModelArn: String, provisionedModelName: String, status: ProvisionedModelStatus) {
            self.commitmentDuration = commitmentDuration
            self.commitmentExpirationTime = commitmentExpirationTime
            self.creationTime = creationTime
            self.desiredModelArn = desiredModelArn
            self.desiredModelUnits = desiredModelUnits
            self.failureMessage = failureMessage
            self.foundationModelArn = foundationModelArn
            self.lastModifiedTime = lastModifiedTime
            self.modelArn = modelArn
            self.modelUnits = modelUnits
            self.provisionedModelArn = provisionedModelArn
            self.provisionedModelName = provisionedModelName
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case commitmentDuration = "commitmentDuration"
            case commitmentExpirationTime = "commitmentExpirationTime"
            case creationTime = "creationTime"
            case desiredModelArn = "desiredModelArn"
            case desiredModelUnits = "desiredModelUnits"
            case failureMessage = "failureMessage"
            case foundationModelArn = "foundationModelArn"
            case lastModifiedTime = "lastModifiedTime"
            case modelArn = "modelArn"
            case modelUnits = "modelUnits"
            case provisionedModelArn = "provisionedModelArn"
            case provisionedModelName = "provisionedModelName"
            case status = "status"
        }
    }

    public struct GuardrailConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The unique identifier for the guardrail.
        public let guardrailId: String
        /// The version of the guardrail.
        public let guardrailVersion: String

        @inlinable
        public init(guardrailId: String, guardrailVersion: String) {
            self.guardrailId = guardrailId
            self.guardrailVersion = guardrailVersion
        }

        private enum CodingKeys: String, CodingKey {
            case guardrailId = "guardrailId"
            case guardrailVersion = "guardrailVersion"
        }
    }

    public struct GuardrailContentFilter: AWSDecodableShape {
        /// The input modalities selected for the guardrail content filter.
        public let inputModalities: [GuardrailModality]?
        /// The strength of the content filter to apply to prompts. As you increase the filter strength, the likelihood of filtering harmful content increases and the probability of seeing harmful content in your application reduces.
        public let inputStrength: GuardrailFilterStrength
        /// The output modalities selected for the guardrail content filter.
        public let outputModalities: [GuardrailModality]?
        /// The strength of the content filter to apply to model responses. As you increase the filter strength, the likelihood of filtering harmful content increases and the probability of seeing harmful content in your application reduces.
        public let outputStrength: GuardrailFilterStrength
        /// The harmful category that the content filter is applied to.
        public let type: GuardrailContentFilterType

        @inlinable
        public init(inputModalities: [GuardrailModality]? = nil, inputStrength: GuardrailFilterStrength, outputModalities: [GuardrailModality]? = nil, outputStrength: GuardrailFilterStrength, type: GuardrailContentFilterType) {
            self.inputModalities = inputModalities
            self.inputStrength = inputStrength
            self.outputModalities = outputModalities
            self.outputStrength = outputStrength
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case inputModalities = "inputModalities"
            case inputStrength = "inputStrength"
            case outputModalities = "outputModalities"
            case outputStrength = "outputStrength"
            case type = "type"
        }
    }

    public struct GuardrailContentFilterConfig: AWSEncodableShape {
        /// The input modalities selected for the guardrail content filter configuration.
        public let inputModalities: [GuardrailModality]?
        /// The strength of the content filter to apply to prompts. As you increase the filter strength, the likelihood of filtering harmful content increases and the probability of seeing harmful content in your application reduces.
        public let inputStrength: GuardrailFilterStrength
        /// The output modalities selected for the guardrail content filter configuration.
        public let outputModalities: [GuardrailModality]?
        /// The strength of the content filter to apply to model responses. As you increase the filter strength, the likelihood of filtering harmful content increases and the probability of seeing harmful content in your application reduces.
        public let outputStrength: GuardrailFilterStrength
        /// The harmful category that the content filter is applied to.
        public let type: GuardrailContentFilterType

        @inlinable
        public init(inputModalities: [GuardrailModality]? = nil, inputStrength: GuardrailFilterStrength, outputModalities: [GuardrailModality]? = nil, outputStrength: GuardrailFilterStrength, type: GuardrailContentFilterType) {
            self.inputModalities = inputModalities
            self.inputStrength = inputStrength
            self.outputModalities = outputModalities
            self.outputStrength = outputStrength
            self.type = type
        }

        public func validate(name: String) throws {
            try self.validate(self.inputModalities, name: "inputModalities", parent: name, max: 2)
            try self.validate(self.inputModalities, name: "inputModalities", parent: name, min: 1)
            try self.validate(self.outputModalities, name: "outputModalities", parent: name, max: 2)
            try self.validate(self.outputModalities, name: "outputModalities", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case inputModalities = "inputModalities"
            case inputStrength = "inputStrength"
            case outputModalities = "outputModalities"
            case outputStrength = "outputStrength"
            case type = "type"
        }
    }

    public struct GuardrailContentPolicy: AWSDecodableShape {
        /// Contains the type of the content filter and how strongly it should apply to prompts and model responses.
        public let filters: [GuardrailContentFilter]?

        @inlinable
        public init(filters: [GuardrailContentFilter]? = nil) {
            self.filters = filters
        }

        private enum CodingKeys: String, CodingKey {
            case filters = "filters"
        }
    }

    public struct GuardrailContentPolicyConfig: AWSEncodableShape {
        /// Contains the type of the content filter and how strongly it should apply to prompts and model responses.
        public let filtersConfig: [GuardrailContentFilterConfig]

        @inlinable
        public init(filtersConfig: [GuardrailContentFilterConfig]) {
            self.filtersConfig = filtersConfig
        }

        public func validate(name: String) throws {
            try self.filtersConfig.forEach {
                try $0.validate(name: "\(name).filtersConfig[]")
            }
            try self.validate(self.filtersConfig, name: "filtersConfig", parent: name, max: 6)
            try self.validate(self.filtersConfig, name: "filtersConfig", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case filtersConfig = "filtersConfig"
        }
    }

    public struct GuardrailContextualGroundingFilter: AWSDecodableShape {
        /// The threshold details for the guardrails contextual grounding filter.
        public let threshold: Double
        /// The filter type details for the guardrails contextual grounding filter.
        public let type: GuardrailContextualGroundingFilterType

        @inlinable
        public init(threshold: Double, type: GuardrailContextualGroundingFilterType) {
            self.threshold = threshold
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case threshold = "threshold"
            case type = "type"
        }
    }

    public struct GuardrailContextualGroundingFilterConfig: AWSEncodableShape {
        /// The threshold details for the guardrails contextual grounding filter.
        public let threshold: Double
        /// The filter details for the guardrails contextual grounding filter.
        public let type: GuardrailContextualGroundingFilterType

        @inlinable
        public init(threshold: Double, type: GuardrailContextualGroundingFilterType) {
            self.threshold = threshold
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case threshold = "threshold"
            case type = "type"
        }
    }

    public struct GuardrailContextualGroundingPolicy: AWSDecodableShape {
        /// The filter details for the guardrails contextual grounding policy.
        public let filters: [GuardrailContextualGroundingFilter]

        @inlinable
        public init(filters: [GuardrailContextualGroundingFilter]) {
            self.filters = filters
        }

        private enum CodingKeys: String, CodingKey {
            case filters = "filters"
        }
    }

    public struct GuardrailContextualGroundingPolicyConfig: AWSEncodableShape {
        /// The filter configuration details for the guardrails contextual grounding policy.
        public let filtersConfig: [GuardrailContextualGroundingFilterConfig]

        @inlinable
        public init(filtersConfig: [GuardrailContextualGroundingFilterConfig]) {
            self.filtersConfig = filtersConfig
        }

        public func validate(name: String) throws {
            try self.validate(self.filtersConfig, name: "filtersConfig", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case filtersConfig = "filtersConfig"
        }
    }

    public struct GuardrailManagedWords: AWSDecodableShape {
        /// ManagedWords$type The managed word type that was configured for the guardrail. (For now, we only offer profanity word list)
        public let type: GuardrailManagedWordsType

        @inlinable
        public init(type: GuardrailManagedWordsType) {
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case type = "type"
        }
    }

    public struct GuardrailManagedWordsConfig: AWSEncodableShape {
        /// The managed word type to configure for the guardrail.
        public let type: GuardrailManagedWordsType

        @inlinable
        public init(type: GuardrailManagedWordsType) {
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case type = "type"
        }
    }

    public struct GuardrailPiiEntity: AWSDecodableShape {
        /// The configured guardrail action when PII entity is detected.
        public let action: GuardrailSensitiveInformationAction
        /// The type of PII entity. For example, Social Security Number.
        public let type: GuardrailPiiEntityType

        @inlinable
        public init(action: GuardrailSensitiveInformationAction, type: GuardrailPiiEntityType) {
            self.action = action
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case action = "action"
            case type = "type"
        }
    }

    public struct GuardrailPiiEntityConfig: AWSEncodableShape {
        /// Configure guardrail action when the PII entity is detected.
        public let action: GuardrailSensitiveInformationAction
        /// Configure guardrail type when the PII entity is detected. The following PIIs are used to block or mask sensitive information:    General     ADDRESS  A physical address, such as "100 Main Street, Anytown, USA"  or "Suite #12, Building 123". An address can include information  such as the street, building, location, city, state, country, county,  zip code, precinct, and neighborhood.     AGE  An individual's age, including the quantity and unit of time. For  example, in the phrase "I am 40 years old," Guardrails recognizes "40 years"  as an age.     NAME  An individual's name. This entity type does not include titles, such as  Dr., Mr., Mrs., or Miss. guardrails doesn't apply this entity type to names that  are part of organizations or addresses. For example, guardrails recognizes  the "John Doe Organization" as an organization, and it recognizes "Jane Doe  Street" as an address.     EMAIL  An email address, such as marymajor@email.com.    PHONE  A phone number. This entity type also includes fax and pager numbers.     USERNAME  A user name that identifies an account, such as a login name, screen name,  nick name, or handle.     PASSWORD  An alphanumeric string that is used as a password, such as  "*very20special#pass*".     DRIVER_ID  The number assigned to a driver's license, which is an official  document permitting an individual to operate one or more motorized  vehicles on a public road. A driver's license number consists of  alphanumeric characters.     LICENSE_PLATE  A license plate for a vehicle is issued by the state or country where  the vehicle is registered. The format for passenger vehicles is typically  five to eight digits, consisting of upper-case letters and numbers. The  format varies depending on the location of the issuing state or country.     VEHICLE_IDENTIFICATION_NUMBER  A Vehicle Identification Number (VIN) uniquely identifies a vehicle.  VIN content and format are defined in the ISO 3779 specification.  Each country has specific codes and formats for VINs.       Finance     CREDIT_DEBIT_CARD_CVV  A three-digit card verification code (CVV) that is present on VISA,  MasterCard, and Discover credit and debit cards. For American Express  credit or debit cards, the CVV is a four-digit numeric code.     CREDIT_DEBIT_CARD_EXPIRY  The expiration date for a credit or debit card. This number is usually  four digits long and is often formatted as month/year or  MM/YY. Guardrails recognizes expiration dates such as  01/21, 01/2021, and Jan 2021.     CREDIT_DEBIT_CARD_NUMBER  The number for a credit or debit card. These numbers can vary from 13 to 16  digits in length. However, Amazon Comprehend also recognizes credit or debit  card numbers when only the last four digits are present.     PIN  A four-digit personal identification number (PIN) with which you can  access your bank account.     INTERNATIONAL_BANK_ACCOUNT_NUMBER  An International Bank Account Number has specific formats in each country.  For more information, see www.iban.com/structure.    SWIFT_CODE  A SWIFT code is a standard format of Bank Identifier Code (BIC) used to specify  a particular bank or branch. Banks use these codes for money transfers such as  international wire transfers. SWIFT codes consist of eight or 11 characters. The 11-digit codes refer to specific  branches, while eight-digit codes (or 11-digit codes ending in 'XXX') refer to the  head or primary office.      IT     IP_ADDRESS  An IPv4 address, such as 198.51.100.0.     MAC_ADDRESS  A media access control (MAC) address is a unique identifier  assigned to a network interface controller (NIC).     URL  A web address, such as www.example.com.     AWS_ACCESS_KEY  A unique identifier that's associated with a secret access key;  you use the access key ID and secret access key to sign programmatic  Amazon Web Services requests cryptographically.     AWS_SECRET_KEY  A unique identifier that's associated with an access key. You use the  access key ID and secret access key to sign programmatic Amazon Web Services  requests cryptographically.       USA specific     US_BANK_ACCOUNT_NUMBER  A US bank account number, which is typically 10 to 12 digits long.                                    US_BANK_ROUTING_NUMBER  A US bank account routing number. These are typically nine digits long,                                      US_INDIVIDUAL_TAX_IDENTIFICATION_NUMBER  A US Individual Taxpayer Identification Number (ITIN) is a nine-digit number  that starts with a "9" and contain a "7" or "8" as the fourth digit. An ITIN  can be formatted with a space or a dash after the third and forth digits.     US_PASSPORT_NUMBER  A US passport number. Passport numbers range from six to nine alphanumeric  characters.     US_SOCIAL_SECURITY_NUMBER  A US Social Security Number (SSN) is a nine-digit number that is issued to  US citizens, permanent residents, and temporary working residents.                                        Canada specific     CA_HEALTH_NUMBER  A Canadian Health Service Number is a 10-digit unique identifier,  required for individuals to access healthcare benefits.     CA_SOCIAL_INSURANCE_NUMBER  A Canadian Social Insurance Number (SIN) is a nine-digit unique identifier,  required for individuals to access government programs and benefits. The SIN is formatted as three groups of three digits, such as  123-456-789. A SIN can be validated through a simple  check-digit process called the Luhn algorithm.      UK Specific     UK_NATIONAL_HEALTH_SERVICE_NUMBER  A UK National Health Service Number is a 10-17 digit number,  such as 485 777 3456. The current system formats the 10-digit  number with spaces after the third and sixth digits. The final digit is an  error-detecting checksum.    UK_NATIONAL_INSURANCE_NUMBER  A UK National Insurance Number (NINO) provides individuals with access to National  Insurance (social security) benefits. It is also used for some purposes in the UK  tax system. The number is nine digits long and starts with two letters, followed by six  numbers and one letter. A NINO can be formatted with a space or a dash after  the two letters and after the second, forth, and sixth digits.    UK_UNIQUE_TAXPAYER_REFERENCE_NUMBER  A UK Unique Taxpayer Reference (UTR) is a 10-digit number that identifies a taxpayer or a business.       Custom     Regex filter - You can use a regular expressions to define patterns for a guardrail to recognize and act upon such as serial number, booking ID etc..
        public let type: GuardrailPiiEntityType

        @inlinable
        public init(action: GuardrailSensitiveInformationAction, type: GuardrailPiiEntityType) {
            self.action = action
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case action = "action"
            case type = "type"
        }
    }

    public struct GuardrailRegex: AWSDecodableShape {
        /// The action taken when a match to the regular expression is detected.
        public let action: GuardrailSensitiveInformationAction
        /// The description of the regular expression for the guardrail.
        public let description: String?
        /// The name of the regular expression for the guardrail.
        public let name: String
        /// The pattern of the regular expression configured for the guardrail.
        public let pattern: String

        @inlinable
        public init(action: GuardrailSensitiveInformationAction, description: String? = nil, name: String, pattern: String) {
            self.action = action
            self.description = description
            self.name = name
            self.pattern = pattern
        }

        private enum CodingKeys: String, CodingKey {
            case action = "action"
            case description = "description"
            case name = "name"
            case pattern = "pattern"
        }
    }

    public struct GuardrailRegexConfig: AWSEncodableShape {
        /// The guardrail action to configure when matching regular expression is detected.
        public let action: GuardrailSensitiveInformationAction
        /// The description of the regular expression to configure for the guardrail.
        public let description: String?
        /// The name of the regular expression to configure for the guardrail.
        public let name: String
        /// The regular expression pattern to configure for the guardrail.
        public let pattern: String

        @inlinable
        public init(action: GuardrailSensitiveInformationAction, description: String? = nil, name: String, pattern: String) {
            self.action = action
            self.description = description
            self.name = name
            self.pattern = pattern
        }

        private enum CodingKeys: String, CodingKey {
            case action = "action"
            case description = "description"
            case name = "name"
            case pattern = "pattern"
        }
    }

    public struct GuardrailSensitiveInformationPolicy: AWSDecodableShape {
        /// The list of PII entities configured for the guardrail.
        public let piiEntities: [GuardrailPiiEntity]?
        /// The list of regular expressions configured for the guardrail.
        public let regexes: [GuardrailRegex]?

        @inlinable
        public init(piiEntities: [GuardrailPiiEntity]? = nil, regexes: [GuardrailRegex]? = nil) {
            self.piiEntities = piiEntities
            self.regexes = regexes
        }

        private enum CodingKeys: String, CodingKey {
            case piiEntities = "piiEntities"
            case regexes = "regexes"
        }
    }

    public struct GuardrailSensitiveInformationPolicyConfig: AWSEncodableShape {
        /// A list of PII entities to configure to the guardrail.
        public let piiEntitiesConfig: [GuardrailPiiEntityConfig]?
        /// A list of regular expressions to configure to the guardrail.
        public let regexesConfig: [GuardrailRegexConfig]?

        @inlinable
        public init(piiEntitiesConfig: [GuardrailPiiEntityConfig]? = nil, regexesConfig: [GuardrailRegexConfig]? = nil) {
            self.piiEntitiesConfig = piiEntitiesConfig
            self.regexesConfig = regexesConfig
        }

        public func validate(name: String) throws {
            try self.validate(self.piiEntitiesConfig, name: "piiEntitiesConfig", parent: name, min: 1)
            try self.validate(self.regexesConfig, name: "regexesConfig", parent: name, max: 10)
            try self.validate(self.regexesConfig, name: "regexesConfig", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case piiEntitiesConfig = "piiEntitiesConfig"
            case regexesConfig = "regexesConfig"
        }
    }

    public struct GuardrailSummary: AWSDecodableShape {
        /// The ARN of the guardrail.
        public let arn: String
        /// The date and time at which the guardrail was created.
        @CustomCoding<ISO8601DateCoder>
        public var createdAt: Date
        /// A description of the guardrail.
        public let description: String?
        /// The unique identifier of the guardrail.
        public let id: String
        /// The name of the guardrail.
        public let name: String
        /// The status of the guardrail.
        public let status: GuardrailStatus
        /// The date and time at which the guardrail was last updated.
        @CustomCoding<ISO8601DateCoder>
        public var updatedAt: Date
        /// The version of the guardrail.
        public let version: String

        @inlinable
        public init(arn: String, createdAt: Date, description: String? = nil, id: String, name: String, status: GuardrailStatus, updatedAt: Date, version: String) {
            self.arn = arn
            self.createdAt = createdAt
            self.description = description
            self.id = id
            self.name = name
            self.status = status
            self.updatedAt = updatedAt
            self.version = version
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case createdAt = "createdAt"
            case description = "description"
            case id = "id"
            case name = "name"
            case status = "status"
            case updatedAt = "updatedAt"
            case version = "version"
        }
    }

    public struct GuardrailTopic: AWSDecodableShape {
        /// A definition of the topic to deny.
        public let definition: String
        /// A list of prompts, each of which is an example of a prompt that can be categorized as belonging to the topic.
        public let examples: [String]?
        /// The name of the topic to deny.
        public let name: String
        /// Specifies to deny the topic.
        public let type: GuardrailTopicType?

        @inlinable
        public init(definition: String, examples: [String]? = nil, name: String, type: GuardrailTopicType? = nil) {
            self.definition = definition
            self.examples = examples
            self.name = name
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case definition = "definition"
            case examples = "examples"
            case name = "name"
            case type = "type"
        }
    }

    public struct GuardrailTopicConfig: AWSEncodableShape {
        /// A definition of the topic to deny.
        public let definition: String
        /// A list of prompts, each of which is an example of a prompt that can be categorized as belonging to the topic.
        public let examples: [String]?
        /// The name of the topic to deny.
        public let name: String
        /// Specifies to deny the topic.
        public let type: GuardrailTopicType

        @inlinable
        public init(definition: String, examples: [String]? = nil, name: String, type: GuardrailTopicType) {
            self.definition = definition
            self.examples = examples
            self.name = name
            self.type = type
        }

        public func validate(name: String) throws {
            try self.validate(self.definition, name: "definition", parent: name, max: 200)
            try self.validate(self.definition, name: "definition", parent: name, min: 1)
            try self.examples?.forEach {
                try validate($0, name: "examples[]", parent: name, max: 100)
                try validate($0, name: "examples[]", parent: name, min: 1)
            }
            try self.validate(self.examples, name: "examples", parent: name, max: 5)
            try self.validate(self.name, name: "name", parent: name, max: 100)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[0-9a-zA-Z-_ !?.]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case definition = "definition"
            case examples = "examples"
            case name = "name"
            case type = "type"
        }
    }

    public struct GuardrailTopicPolicy: AWSDecodableShape {
        /// A list of policies related to topics that the guardrail should deny.
        public let topics: [GuardrailTopic]

        @inlinable
        public init(topics: [GuardrailTopic]) {
            self.topics = topics
        }

        private enum CodingKeys: String, CodingKey {
            case topics = "topics"
        }
    }

    public struct GuardrailTopicPolicyConfig: AWSEncodableShape {
        /// A list of policies related to topics that the guardrail should deny.
        public let topicsConfig: [GuardrailTopicConfig]

        @inlinable
        public init(topicsConfig: [GuardrailTopicConfig]) {
            self.topicsConfig = topicsConfig
        }

        public func validate(name: String) throws {
            try self.topicsConfig.forEach {
                try $0.validate(name: "\(name).topicsConfig[]")
            }
            try self.validate(self.topicsConfig, name: "topicsConfig", parent: name, max: 30)
            try self.validate(self.topicsConfig, name: "topicsConfig", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case topicsConfig = "topicsConfig"
        }
    }

    public struct GuardrailWord: AWSDecodableShape {
        /// Text of the word configured for the guardrail to block.
        public let text: String

        @inlinable
        public init(text: String) {
            self.text = text
        }

        private enum CodingKeys: String, CodingKey {
            case text = "text"
        }
    }

    public struct GuardrailWordConfig: AWSEncodableShape {
        /// Text of the word configured for the guardrail to block.
        public let text: String

        @inlinable
        public init(text: String) {
            self.text = text
        }

        private enum CodingKeys: String, CodingKey {
            case text = "text"
        }
    }

    public struct GuardrailWordPolicy: AWSDecodableShape {
        /// A list of managed words configured for the guardrail.
        public let managedWordLists: [GuardrailManagedWords]?
        /// A list of words configured for the guardrail.
        public let words: [GuardrailWord]?

        @inlinable
        public init(managedWordLists: [GuardrailManagedWords]? = nil, words: [GuardrailWord]? = nil) {
            self.managedWordLists = managedWordLists
            self.words = words
        }

        private enum CodingKeys: String, CodingKey {
            case managedWordLists = "managedWordLists"
            case words = "words"
        }
    }

    public struct GuardrailWordPolicyConfig: AWSEncodableShape {
        /// A list of managed words to configure for the guardrail.
        public let managedWordListsConfig: [GuardrailManagedWordsConfig]?
        /// A list of words to configure for the guardrail.
        public let wordsConfig: [GuardrailWordConfig]?

        @inlinable
        public init(managedWordListsConfig: [GuardrailManagedWordsConfig]? = nil, wordsConfig: [GuardrailWordConfig]? = nil) {
            self.managedWordListsConfig = managedWordListsConfig
            self.wordsConfig = wordsConfig
        }

        public func validate(name: String) throws {
            try self.validate(self.wordsConfig, name: "wordsConfig", parent: name, max: 10000)
            try self.validate(self.wordsConfig, name: "wordsConfig", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case managedWordListsConfig = "managedWordListsConfig"
            case wordsConfig = "wordsConfig"
        }
    }

    public struct HumanEvaluationConfig: AWSEncodableShape & AWSDecodableShape {
        /// A HumanEvaluationCustomMetric object. It contains the names the metrics, how the metrics are to be evaluated, an optional description.
        public let customMetrics: [HumanEvaluationCustomMetric]?
        /// Use to specify the metrics, task, and prompt dataset to be used in your model evaluation job.
        public let datasetMetricConfigs: [EvaluationDatasetMetricConfig]
        /// The parameters of the human workflow.
        public let humanWorkflowConfig: HumanWorkflowConfig?

        @inlinable
        public init(customMetrics: [HumanEvaluationCustomMetric]? = nil, datasetMetricConfigs: [EvaluationDatasetMetricConfig], humanWorkflowConfig: HumanWorkflowConfig? = nil) {
            self.customMetrics = customMetrics
            self.datasetMetricConfigs = datasetMetricConfigs
            self.humanWorkflowConfig = humanWorkflowConfig
        }

        public func validate(name: String) throws {
            try self.customMetrics?.forEach {
                try $0.validate(name: "\(name).customMetrics[]")
            }
            try self.validate(self.customMetrics, name: "customMetrics", parent: name, max: 10)
            try self.validate(self.customMetrics, name: "customMetrics", parent: name, min: 1)
            try self.datasetMetricConfigs.forEach {
                try $0.validate(name: "\(name).datasetMetricConfigs[]")
            }
            try self.validate(self.datasetMetricConfigs, name: "datasetMetricConfigs", parent: name, max: 5)
            try self.validate(self.datasetMetricConfigs, name: "datasetMetricConfigs", parent: name, min: 1)
            try self.humanWorkflowConfig?.validate(name: "\(name).humanWorkflowConfig")
        }

        private enum CodingKeys: String, CodingKey {
            case customMetrics = "customMetrics"
            case datasetMetricConfigs = "datasetMetricConfigs"
            case humanWorkflowConfig = "humanWorkflowConfig"
        }
    }

    public struct HumanEvaluationCustomMetric: AWSEncodableShape & AWSDecodableShape {
        /// An optional description of the metric. Use this parameter to provide more details about the metric.
        public let description: String?
        /// The name of the metric. Your human evaluators will see this name in the evaluation UI.
        public let name: String
        /// Choose how you want your human workers to evaluation your model. Valid values for rating methods are ThumbsUpDown, IndividualLikertScale,ComparisonLikertScale, ComparisonChoice, and ComparisonRank
        public let ratingMethod: String

        @inlinable
        public init(description: String? = nil, name: String, ratingMethod: String) {
            self.description = description
            self.name = name
            self.ratingMethod = ratingMethod
        }

        public func validate(name: String) throws {
            try self.validate(self.description, name: "description", parent: name, max: 63)
            try self.validate(self.description, name: "description", parent: name, min: 1)
            try self.validate(self.description, name: "description", parent: name, pattern: "^.+$")
            try self.validate(self.name, name: "name", parent: name, max: 63)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[0-9a-zA-Z-_.]+$")
            try self.validate(self.ratingMethod, name: "ratingMethod", parent: name, max: 100)
            try self.validate(self.ratingMethod, name: "ratingMethod", parent: name, min: 1)
            try self.validate(self.ratingMethod, name: "ratingMethod", parent: name, pattern: "^[0-9a-zA-Z-_]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case description = "description"
            case name = "name"
            case ratingMethod = "ratingMethod"
        }
    }

    public struct HumanWorkflowConfig: AWSEncodableShape & AWSDecodableShape {
        /// The Amazon Resource Number (ARN) for the flow definition
        public let flowDefinitionArn: String
        /// Instructions for the flow definition
        public let instructions: String?

        @inlinable
        public init(flowDefinitionArn: String, instructions: String? = nil) {
            self.flowDefinitionArn = flowDefinitionArn
            self.instructions = instructions
        }

        public func validate(name: String) throws {
            try self.validate(self.flowDefinitionArn, name: "flowDefinitionArn", parent: name, max: 1024)
            try self.validate(self.flowDefinitionArn, name: "flowDefinitionArn", parent: name, pattern: "^arn:aws(-[^:]+)?:sagemaker:[a-z0-9-]{1,20}:[0-9]{12}:flow-definition/.*$")
            try self.validate(self.instructions, name: "instructions", parent: name, max: 5000)
            try self.validate(self.instructions, name: "instructions", parent: name, min: 1)
            try self.validate(self.instructions, name: "instructions", parent: name, pattern: "^[\\S\\s]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case flowDefinitionArn = "flowDefinitionArn"
            case instructions = "instructions"
        }
    }

    public struct ImportedModelSummary: AWSDecodableShape {
        /// Creation time of the imported model.
        @CustomCoding<ISO8601DateCoder>
        public var creationTime: Date
        /// Specifies if the imported model supports converse.
        public let instructSupported: Bool?
        /// The architecture of the imported model.
        public let modelArchitecture: String?
        /// The Amazon Resource Name (ARN) of the imported model.
        public let modelArn: String
        /// Name of the imported model.
        public let modelName: String

        @inlinable
        public init(creationTime: Date, instructSupported: Bool? = nil, modelArchitecture: String? = nil, modelArn: String, modelName: String) {
            self.creationTime = creationTime
            self.instructSupported = instructSupported
            self.modelArchitecture = modelArchitecture
            self.modelArn = modelArn
            self.modelName = modelName
        }

        private enum CodingKeys: String, CodingKey {
            case creationTime = "creationTime"
            case instructSupported = "instructSupported"
            case modelArchitecture = "modelArchitecture"
            case modelArn = "modelArn"
            case modelName = "modelName"
        }
    }

    public struct InferenceProfileModel: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the model.
        public let modelArn: String?

        @inlinable
        public init(modelArn: String? = nil) {
            self.modelArn = modelArn
        }

        private enum CodingKeys: String, CodingKey {
            case modelArn = "modelArn"
        }
    }

    public struct InferenceProfileSummary: AWSDecodableShape {
        /// The time at which the inference profile was created.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var createdAt: Date?
        /// The description of the inference profile.
        public let description: String?
        /// The Amazon Resource Name (ARN) of the inference profile.
        public let inferenceProfileArn: String
        /// The unique identifier of the inference profile.
        public let inferenceProfileId: String
        /// The name of the inference profile.
        public let inferenceProfileName: String
        /// A list of information about each model in the inference profile.
        public let models: [InferenceProfileModel]
        /// The status of the inference profile. ACTIVE means that the inference profile is ready to be used.
        public let status: InferenceProfileStatus
        /// The type of the inference profile. The following types are possible:    SYSTEM_DEFINED – The inference profile is defined by Amazon Bedrock. You can route inference requests across regions with these inference profiles.    APPLICATION – The inference profile was created by a user. This type of inference profile can track metrics and costs when invoking the model in it. The inference profile may route requests to one or multiple regions.
        public let type: InferenceProfileType
        /// The time at which the inference profile was last updated.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var updatedAt: Date?

        @inlinable
        public init(createdAt: Date? = nil, description: String? = nil, inferenceProfileArn: String, inferenceProfileId: String, inferenceProfileName: String, models: [InferenceProfileModel], status: InferenceProfileStatus, type: InferenceProfileType, updatedAt: Date? = nil) {
            self.createdAt = createdAt
            self.description = description
            self.inferenceProfileArn = inferenceProfileArn
            self.inferenceProfileId = inferenceProfileId
            self.inferenceProfileName = inferenceProfileName
            self.models = models
            self.status = status
            self.type = type
            self.updatedAt = updatedAt
        }

        private enum CodingKeys: String, CodingKey {
            case createdAt = "createdAt"
            case description = "description"
            case inferenceProfileArn = "inferenceProfileArn"
            case inferenceProfileId = "inferenceProfileId"
            case inferenceProfileName = "inferenceProfileName"
            case models = "models"
            case status = "status"
            case type = "type"
            case updatedAt = "updatedAt"
        }
    }

    public struct InvocationLogsConfig: AWSEncodableShape & AWSDecodableShape {
        /// The source of the invocation logs.
        public let invocationLogSource: InvocationLogSource
        /// Rules for filtering invocation logs based on request metadata.
        public let requestMetadataFilters: RequestMetadataFilters?
        /// Whether to use the model's response for training, or just the prompt. The default value is False.
        public let usePromptResponse: Bool?

        @inlinable
        public init(invocationLogSource: InvocationLogSource, requestMetadataFilters: RequestMetadataFilters? = nil, usePromptResponse: Bool? = nil) {
            self.invocationLogSource = invocationLogSource
            self.requestMetadataFilters = requestMetadataFilters
            self.usePromptResponse = usePromptResponse
        }

        public func validate(name: String) throws {
            try self.invocationLogSource.validate(name: "\(name).invocationLogSource")
            try self.requestMetadataFilters?.validate(name: "\(name).requestMetadataFilters")
        }

        private enum CodingKeys: String, CodingKey {
            case invocationLogSource = "invocationLogSource"
            case requestMetadataFilters = "requestMetadataFilters"
            case usePromptResponse = "usePromptResponse"
        }
    }

    public struct KbInferenceConfig: AWSEncodableShape & AWSDecodableShape {
        /// Contains configuration details for text generation using a language model via the  RetrieveAndGenerate function.
        public let textInferenceConfig: TextInferenceConfig?

        @inlinable
        public init(textInferenceConfig: TextInferenceConfig? = nil) {
            self.textInferenceConfig = textInferenceConfig
        }

        public func validate(name: String) throws {
            try self.textInferenceConfig?.validate(name: "\(name).textInferenceConfig")
        }

        private enum CodingKeys: String, CodingKey {
            case textInferenceConfig = "textInferenceConfig"
        }
    }

    public struct KnowledgeBaseRetrievalConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// Contains configuration details for returning the results from the vector search.
        public let vectorSearchConfiguration: KnowledgeBaseVectorSearchConfiguration

        @inlinable
        public init(vectorSearchConfiguration: KnowledgeBaseVectorSearchConfiguration) {
            self.vectorSearchConfiguration = vectorSearchConfiguration
        }

        public func validate(name: String) throws {
            try self.vectorSearchConfiguration.validate(name: "\(name).vectorSearchConfiguration")
        }

        private enum CodingKeys: String, CodingKey {
            case vectorSearchConfiguration = "vectorSearchConfiguration"
        }
    }

    public struct KnowledgeBaseRetrieveAndGenerateConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// Contains configurations details for response generation based on retrieved text chunks.
        public let generationConfiguration: GenerationConfiguration?
        /// The unique identifier of the knowledge base.
        public let knowledgeBaseId: String
        /// The Amazon Resource Name (ARN) of the foundation model or inference profile  used to generate responses.
        public let modelArn: String
        /// Contains configuration details for the model to process the prompt prior to retrieval and response generation.
        public let orchestrationConfiguration: OrchestrationConfiguration?
        /// Contains configuration details for retrieving text chunks.
        public let retrievalConfiguration: KnowledgeBaseRetrievalConfiguration?

        @inlinable
        public init(generationConfiguration: GenerationConfiguration? = nil, knowledgeBaseId: String, modelArn: String, orchestrationConfiguration: OrchestrationConfiguration? = nil, retrievalConfiguration: KnowledgeBaseRetrievalConfiguration? = nil) {
            self.generationConfiguration = generationConfiguration
            self.knowledgeBaseId = knowledgeBaseId
            self.modelArn = modelArn
            self.orchestrationConfiguration = orchestrationConfiguration
            self.retrievalConfiguration = retrievalConfiguration
        }

        public func validate(name: String) throws {
            try self.generationConfiguration?.validate(name: "\(name).generationConfiguration")
            try self.validate(self.knowledgeBaseId, name: "knowledgeBaseId", parent: name, max: 10)
            try self.validate(self.knowledgeBaseId, name: "knowledgeBaseId", parent: name, pattern: "^[0-9a-zA-Z]+$")
            try self.validate(self.modelArn, name: "modelArn", parent: name, max: 2048)
            try self.validate(self.modelArn, name: "modelArn", parent: name, min: 1)
            try self.validate(self.modelArn, name: "modelArn", parent: name, pattern: "^(arn:aws(-[^:]+)?:bedrock:[a-z0-9-]{1,20}:(([0-9]{12}:custom-model/[a-z0-9-]{1,63}[.]{1}[a-z0-9-]{1,63}/[a-z0-9]{12})|(:foundation-model/[a-z0-9-]{1,63}[.]{1}[a-z0-9-]{1,63}([.:]?[a-z0-9-]{1,63}))))|(arn:aws(|-us-gov|-cn|-iso|-iso-b):bedrock:(|[0-9a-z-]{1,20}):(|[0-9]{12}):inference-profile/[a-zA-Z0-9-:.]+)|([a-z0-9-]{1,63}[.]{1}[a-z0-9-]{1,63}([.:]?[a-z0-9-]{1,63}))|(([0-9a-zA-Z][_-]?)+)$")
            try self.retrievalConfiguration?.validate(name: "\(name).retrievalConfiguration")
        }

        private enum CodingKeys: String, CodingKey {
            case generationConfiguration = "generationConfiguration"
            case knowledgeBaseId = "knowledgeBaseId"
            case modelArn = "modelArn"
            case orchestrationConfiguration = "orchestrationConfiguration"
            case retrievalConfiguration = "retrievalConfiguration"
        }
    }

    public struct KnowledgeBaseVectorSearchConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// Specifies the filters to use on the metadata fields in the knowledge base data sources before returning results.
        public let filter: RetrievalFilter?
        /// The number of text chunks to retrieve; the number of results to return.
        public let numberOfResults: Int?
        /// By default, Amazon Bedrock decides a search strategy for you. If you're using an  Amazon OpenSearch Serverless vector store that contains a filterable text field, you  can specify whether to query the knowledge base with a HYBRID search  using both vector embeddings and raw text, or SEMANTIC search using  only vector embeddings. For other vector store configurations, only SEMANTIC  search is available.
        public let overrideSearchType: SearchType?

        @inlinable
        public init(filter: RetrievalFilter? = nil, numberOfResults: Int? = nil, overrideSearchType: SearchType? = nil) {
            self.filter = filter
            self.numberOfResults = numberOfResults
            self.overrideSearchType = overrideSearchType
        }

        public func validate(name: String) throws {
            try self.filter?.validate(name: "\(name).filter")
        }

        private enum CodingKeys: String, CodingKey {
            case filter = "filter"
            case numberOfResults = "numberOfResults"
            case overrideSearchType = "overrideSearchType"
        }
    }

    public struct ListCustomModelsRequest: AWSEncodableShape {
        /// Return custom models only if the base model Amazon Resource Name (ARN) matches this parameter.
        public let baseModelArnEquals: String?
        /// Return custom models created after the specified time.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var creationTimeAfter: Date?
        /// Return custom models created before the specified time.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var creationTimeBefore: Date?
        /// Return custom models only if the foundation model Amazon Resource Name (ARN) matches this parameter.
        public let foundationModelArnEquals: String?
        /// Return custom models depending on if the current account owns them (true) or if they were shared with the current account (false).
        public let isOwned: Bool?
        /// The maximum number of results to return in the response. If the total number of results is greater than this value, use the token returned in the response in the nextToken field when making another request to return the next batch of results.
        public let maxResults: Int?
        /// Return custom models only if the job name contains these characters.
        public let nameContains: String?
        /// If the total number of results is greater than the maxResults value provided in the request, enter the token returned in the nextToken field in the response in this field to return the next batch of results.
        public let nextToken: String?
        /// The field to sort by in the returned list of models.
        public let sortBy: SortModelsBy?
        /// The sort order of the results.
        public let sortOrder: SortOrder?

        @inlinable
        public init(baseModelArnEquals: String? = nil, creationTimeAfter: Date? = nil, creationTimeBefore: Date? = nil, foundationModelArnEquals: String? = nil, isOwned: Bool? = nil, maxResults: Int? = nil, nameContains: String? = nil, nextToken: String? = nil, sortBy: SortModelsBy? = nil, sortOrder: SortOrder? = nil) {
            self.baseModelArnEquals = baseModelArnEquals
            self.creationTimeAfter = creationTimeAfter
            self.creationTimeBefore = creationTimeBefore
            self.foundationModelArnEquals = foundationModelArnEquals
            self.isOwned = isOwned
            self.maxResults = maxResults
            self.nameContains = nameContains
            self.nextToken = nextToken
            self.sortBy = sortBy
            self.sortOrder = sortOrder
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.baseModelArnEquals, key: "baseModelArnEquals")
            request.encodeQuery(self._creationTimeAfter, key: "creationTimeAfter")
            request.encodeQuery(self._creationTimeBefore, key: "creationTimeBefore")
            request.encodeQuery(self.foundationModelArnEquals, key: "foundationModelArnEquals")
            request.encodeQuery(self.isOwned, key: "isOwned")
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nameContains, key: "nameContains")
            request.encodeQuery(self.nextToken, key: "nextToken")
            request.encodeQuery(self.sortBy, key: "sortBy")
            request.encodeQuery(self.sortOrder, key: "sortOrder")
        }

        public func validate(name: String) throws {
            try self.validate(self.baseModelArnEquals, name: "baseModelArnEquals", parent: name, max: 1011)
            try self.validate(self.baseModelArnEquals, name: "baseModelArnEquals", parent: name, min: 20)
            try self.validate(self.baseModelArnEquals, name: "baseModelArnEquals", parent: name, pattern: "^arn:aws(-[^:]+)?:bedrock:[a-z0-9-]{1,20}:(([0-9]{12}:custom-model/[a-z0-9-]{1,63}[.]{1}[a-z0-9-]{1,63}/[a-z0-9]{12})|(:foundation-model/[a-z0-9-]{1,63}[.]{1}([a-z0-9-]{1,63}[.]){0,2}[a-z0-9-]{1,63}([:][a-z0-9-]{1,63}){0,2}))$")
            try self.validate(self.foundationModelArnEquals, name: "foundationModelArnEquals", parent: name, pattern: "^arn:aws(-[^:]+)?:bedrock:[a-z0-9-]{1,20}::foundation-model/[a-z0-9-]{1,63}[.]{1}([a-z0-9-]{1,63}[.]){0,2}[a-z0-9-]{1,63}([:][a-z0-9-]{1,63}){0,2}$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 1000)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nameContains, name: "nameContains", parent: name, max: 63)
            try self.validate(self.nameContains, name: "nameContains", parent: name, min: 1)
            try self.validate(self.nameContains, name: "nameContains", parent: name, pattern: "^([0-9a-zA-Z][_-]?){1,63}$")
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 2048)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^\\S*$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListCustomModelsResponse: AWSDecodableShape {
        /// Model summaries.
        public let modelSummaries: [CustomModelSummary]?
        /// If the total number of results is greater than the maxResults value provided in the request, use this token when making another request in the nextToken field to return the next batch of results.
        public let nextToken: String?

        @inlinable
        public init(modelSummaries: [CustomModelSummary]? = nil, nextToken: String? = nil) {
            self.modelSummaries = modelSummaries
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case modelSummaries = "modelSummaries"
            case nextToken = "nextToken"
        }
    }

    public struct ListEvaluationJobsRequest: AWSEncodableShape {
        /// A filter to only list evaluation jobs that are either model evaluations or knowledge base evaluations.
        public let applicationTypeEquals: ApplicationType?
        /// A filter to only list evaluation jobs created after a specified time.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var creationTimeAfter: Date?
        /// A filter to only list evaluation jobs created before a specified time.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var creationTimeBefore: Date?
        /// The maximum number of results to return.
        public let maxResults: Int?
        /// A filter to only list evaluation jobs that contain a specified string in the job name.
        public let nameContains: String?
        /// Continuation token from the previous response, for Amazon Bedrock to list the next set of results.
        public let nextToken: String?
        /// Specifies a creation time to sort the list of evaluation jobs by when they were created.
        public let sortBy: SortJobsBy?
        /// Specifies whether to sort the list of evaluation jobs by either ascending or descending order.
        public let sortOrder: SortOrder?
        /// A filter to only list evaluation jobs that are of a certain status.
        public let statusEquals: EvaluationJobStatus?

        @inlinable
        public init(applicationTypeEquals: ApplicationType? = nil, creationTimeAfter: Date? = nil, creationTimeBefore: Date? = nil, maxResults: Int? = nil, nameContains: String? = nil, nextToken: String? = nil, sortBy: SortJobsBy? = nil, sortOrder: SortOrder? = nil, statusEquals: EvaluationJobStatus? = nil) {
            self.applicationTypeEquals = applicationTypeEquals
            self.creationTimeAfter = creationTimeAfter
            self.creationTimeBefore = creationTimeBefore
            self.maxResults = maxResults
            self.nameContains = nameContains
            self.nextToken = nextToken
            self.sortBy = sortBy
            self.sortOrder = sortOrder
            self.statusEquals = statusEquals
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.applicationTypeEquals, key: "applicationTypeEquals")
            request.encodeQuery(self._creationTimeAfter, key: "creationTimeAfter")
            request.encodeQuery(self._creationTimeBefore, key: "creationTimeBefore")
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nameContains, key: "nameContains")
            request.encodeQuery(self.nextToken, key: "nextToken")
            request.encodeQuery(self.sortBy, key: "sortBy")
            request.encodeQuery(self.sortOrder, key: "sortOrder")
            request.encodeQuery(self.statusEquals, key: "statusEquals")
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 1000)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nameContains, name: "nameContains", parent: name, max: 63)
            try self.validate(self.nameContains, name: "nameContains", parent: name, min: 1)
            try self.validate(self.nameContains, name: "nameContains", parent: name, pattern: "^[a-z0-9](-*[a-z0-9]){0,62}$")
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 2048)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^\\S*$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListEvaluationJobsResponse: AWSDecodableShape {
        /// A list of summaries of the evaluation jobs.
        public let jobSummaries: [EvaluationSummary]?
        /// Continuation token from the previous response, for Amazon Bedrock to list the next set of results.
        public let nextToken: String?

        @inlinable
        public init(jobSummaries: [EvaluationSummary]? = nil, nextToken: String? = nil) {
            self.jobSummaries = jobSummaries
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case jobSummaries = "jobSummaries"
            case nextToken = "nextToken"
        }
    }

    public struct ListFoundationModelsRequest: AWSEncodableShape {
        /// Return models that support the customization type that you specify. For more information, see Custom models in the Amazon Bedrock User Guide.
        public let byCustomizationType: ModelCustomization?
        /// Return models that support the inference type that you specify. For more information, see Provisioned Throughput in the Amazon Bedrock User Guide.
        public let byInferenceType: InferenceType?
        /// Return models that support the output modality that you specify.
        public let byOutputModality: ModelModality?
        /// Return models belonging to the model provider that you specify.
        public let byProvider: String?

        @inlinable
        public init(byCustomizationType: ModelCustomization? = nil, byInferenceType: InferenceType? = nil, byOutputModality: ModelModality? = nil, byProvider: String? = nil) {
            self.byCustomizationType = byCustomizationType
            self.byInferenceType = byInferenceType
            self.byOutputModality = byOutputModality
            self.byProvider = byProvider
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.byCustomizationType, key: "byCustomizationType")
            request.encodeQuery(self.byInferenceType, key: "byInferenceType")
            request.encodeQuery(self.byOutputModality, key: "byOutputModality")
            request.encodeQuery(self.byProvider, key: "byProvider")
        }

        public func validate(name: String) throws {
            try self.validate(self.byProvider, name: "byProvider", parent: name, pattern: "^[A-Za-z0-9- ]{1,63}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListFoundationModelsResponse: AWSDecodableShape {
        /// A list of Amazon Bedrock foundation models.
        public let modelSummaries: [FoundationModelSummary]?

        @inlinable
        public init(modelSummaries: [FoundationModelSummary]? = nil) {
            self.modelSummaries = modelSummaries
        }

        private enum CodingKeys: String, CodingKey {
            case modelSummaries = "modelSummaries"
        }
    }

    public struct ListGuardrailsRequest: AWSEncodableShape {
        /// The unique identifier of the guardrail.  This can be an ID or the ARN.
        public let guardrailIdentifier: String?
        /// The maximum number of results to return in the response.
        public let maxResults: Int?
        /// If there are more results than were returned in the response, the response returns a nextToken that you can send in another ListGuardrails request to see the next batch of results.
        public let nextToken: String?

        @inlinable
        public init(guardrailIdentifier: String? = nil, maxResults: Int? = nil, nextToken: String? = nil) {
            self.guardrailIdentifier = guardrailIdentifier
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.guardrailIdentifier, key: "guardrailIdentifier")
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
        }

        public func validate(name: String) throws {
            try self.validate(self.guardrailIdentifier, name: "guardrailIdentifier", parent: name, max: 2048)
            try self.validate(self.guardrailIdentifier, name: "guardrailIdentifier", parent: name, pattern: "^(([a-z0-9]+)|(arn:aws(-[^:]+)?:bedrock:[a-z0-9-]{1,20}:[0-9]{12}:guardrail/[a-z0-9]+))$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 1000)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 2048)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^\\S*$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListGuardrailsResponse: AWSDecodableShape {
        /// A list of objects, each of which contains details about a guardrail.
        public let guardrails: [GuardrailSummary]
        /// If there are more results than were returned in the response, the response returns a nextToken that you can send in another ListGuardrails request to see the next batch of results.
        public let nextToken: String?

        @inlinable
        public init(guardrails: [GuardrailSummary], nextToken: String? = nil) {
            self.guardrails = guardrails
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case guardrails = "guardrails"
            case nextToken = "nextToken"
        }
    }

    public struct ListImportedModelsRequest: AWSEncodableShape {
        /// Return imported models that were created after the specified time.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var creationTimeAfter: Date?
        /// Return imported models that created before the specified time.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var creationTimeBefore: Date?
        /// The maximum number of results to return in the response. If the total number of results is greater than this value, use the token returned in the response in the nextToken field when making another request to return the next batch of results.
        public let maxResults: Int?
        /// Return imported models only if the model name contains these characters.
        public let nameContains: String?
        /// If the total number of results is greater than the maxResults value provided in the request, enter the token returned in the nextToken field in the response in this field to return the next batch of results.
        public let nextToken: String?
        /// The field to sort by in the returned list of imported models.
        public let sortBy: SortModelsBy?
        /// Specifies whetehr to sort the results in ascending or descending order.
        public let sortOrder: SortOrder?

        @inlinable
        public init(creationTimeAfter: Date? = nil, creationTimeBefore: Date? = nil, maxResults: Int? = nil, nameContains: String? = nil, nextToken: String? = nil, sortBy: SortModelsBy? = nil, sortOrder: SortOrder? = nil) {
            self.creationTimeAfter = creationTimeAfter
            self.creationTimeBefore = creationTimeBefore
            self.maxResults = maxResults
            self.nameContains = nameContains
            self.nextToken = nextToken
            self.sortBy = sortBy
            self.sortOrder = sortOrder
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self._creationTimeAfter, key: "creationTimeAfter")
            request.encodeQuery(self._creationTimeBefore, key: "creationTimeBefore")
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nameContains, key: "nameContains")
            request.encodeQuery(self.nextToken, key: "nextToken")
            request.encodeQuery(self.sortBy, key: "sortBy")
            request.encodeQuery(self.sortOrder, key: "sortOrder")
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 1000)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nameContains, name: "nameContains", parent: name, max: 63)
            try self.validate(self.nameContains, name: "nameContains", parent: name, min: 1)
            try self.validate(self.nameContains, name: "nameContains", parent: name, pattern: "^([0-9a-zA-Z][_-]?)+$")
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 2048)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^\\S*$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListImportedModelsResponse: AWSDecodableShape {
        /// Model summaries.
        public let modelSummaries: [ImportedModelSummary]?
        /// If the total number of results is greater than the maxResults value provided in the request, use this token when making another request in the nextToken field to return the next batch of results.
        public let nextToken: String?

        @inlinable
        public init(modelSummaries: [ImportedModelSummary]? = nil, nextToken: String? = nil) {
            self.modelSummaries = modelSummaries
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case modelSummaries = "modelSummaries"
            case nextToken = "nextToken"
        }
    }

    public struct ListInferenceProfilesRequest: AWSEncodableShape {
        /// The maximum number of results to return in the response. If the total number of results is greater than this value, use the token returned in the response in the nextToken field when making another request to return the next batch of results.
        public let maxResults: Int?
        /// If the total number of results is greater than the maxResults value provided in the request, enter the token returned in the nextToken field in the response in this field to return the next batch of results.
        public let nextToken: String?
        /// Filters for inference profiles that match the type you specify.    SYSTEM_DEFINED – The inference profile is defined by Amazon Bedrock. You can route inference requests across regions with these inference profiles.    APPLICATION – The inference profile was created by a user. This type of inference profile can track metrics and costs when invoking the model in it. The inference profile may route requests to one or multiple regions.
        public let typeEquals: InferenceProfileType?

        @inlinable
        public init(maxResults: Int? = nil, nextToken: String? = nil, typeEquals: InferenceProfileType? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.typeEquals = typeEquals
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
            request.encodeQuery(self.typeEquals, key: "type")
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 1000)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 2048)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^\\S*$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListInferenceProfilesResponse: AWSDecodableShape {
        /// A list of information about each inference profile that you can use.
        public let inferenceProfileSummaries: [InferenceProfileSummary]?
        /// If the total number of results is greater than the maxResults value provided in the request, use this token when making another request in the nextToken field to return the next batch of results.
        public let nextToken: String?

        @inlinable
        public init(inferenceProfileSummaries: [InferenceProfileSummary]? = nil, nextToken: String? = nil) {
            self.inferenceProfileSummaries = inferenceProfileSummaries
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case inferenceProfileSummaries = "inferenceProfileSummaries"
            case nextToken = "nextToken"
        }
    }

    public struct ListMarketplaceModelEndpointsRequest: AWSEncodableShape {
        /// The maximum number of results to return in a single call. If more results are available, the operation returns a NextToken value.
        public let maxResults: Int?
        /// If specified, only endpoints for the given model source identifier are returned.
        public let modelSourceEquals: String?
        /// The token for the next set of results. You receive this token from a previous ListMarketplaceModelEndpoints call.
        public let nextToken: String?

        @inlinable
        public init(maxResults: Int? = nil, modelSourceEquals: String? = nil, nextToken: String? = nil) {
            self.maxResults = maxResults
            self.modelSourceEquals = modelSourceEquals
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.modelSourceEquals, key: "modelSourceIdentifier")
            request.encodeQuery(self.nextToken, key: "nextToken")
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 1000)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.modelSourceEquals, name: "modelSourceEquals", parent: name, max: 2048)
            try self.validate(self.modelSourceEquals, name: "modelSourceEquals", parent: name, pattern: "arn:aws:sagemaker:.*:hub-content/SageMakerPublicHub/Model/.*")
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 2048)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^\\S*$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListMarketplaceModelEndpointsResponse: AWSDecodableShape {
        /// An array of endpoint summaries.
        public let marketplaceModelEndpoints: [MarketplaceModelEndpointSummary]?
        /// The token for the next set of results. Use this token to get the next set of results.
        public let nextToken: String?

        @inlinable
        public init(marketplaceModelEndpoints: [MarketplaceModelEndpointSummary]? = nil, nextToken: String? = nil) {
            self.marketplaceModelEndpoints = marketplaceModelEndpoints
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case marketplaceModelEndpoints = "marketplaceModelEndpoints"
            case nextToken = "nextToken"
        }
    }

    public struct ListModelCopyJobsRequest: AWSEncodableShape {
        /// Filters for model copy jobs created after the specified time.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var creationTimeAfter: Date?
        /// Filters for model copy jobs created before the specified time.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var creationTimeBefore: Date?
        /// The maximum number of results to return in the response. If the total number of results is greater than this value, use the token returned in the response in the nextToken field when making another request to return the next batch of results.
        public let maxResults: Int?
        /// If the total number of results is greater than the maxResults value provided in the request, enter the token returned in the nextToken field in the response in this field to return the next batch of results.
        public let nextToken: String?
        /// The field to sort by in the returned list of model copy jobs.
        public let sortBy: SortJobsBy?
        /// Specifies whether to sort the results in ascending or descending order.
        public let sortOrder: SortOrder?
        /// Filters for model copy jobs in which the account that the source model belongs to is equal to the value that you specify.
        public let sourceAccountEquals: String?
        /// Filters for model copy jobs in which the Amazon Resource Name (ARN) of the source model to is equal to the value that you specify.
        public let sourceModelArnEquals: String?
        /// Filters for model copy jobs whose status matches the value that you specify.
        public let statusEquals: ModelCopyJobStatus?
        /// Filters for model copy jobs in which the name of the copied model contains the string that you specify.
        public let targetModelNameContains: String?

        @inlinable
        public init(creationTimeAfter: Date? = nil, creationTimeBefore: Date? = nil, maxResults: Int? = nil, nextToken: String? = nil, sortBy: SortJobsBy? = nil, sortOrder: SortOrder? = nil, sourceAccountEquals: String? = nil, sourceModelArnEquals: String? = nil, statusEquals: ModelCopyJobStatus? = nil, targetModelNameContains: String? = nil) {
            self.creationTimeAfter = creationTimeAfter
            self.creationTimeBefore = creationTimeBefore
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.sortBy = sortBy
            self.sortOrder = sortOrder
            self.sourceAccountEquals = sourceAccountEquals
            self.sourceModelArnEquals = sourceModelArnEquals
            self.statusEquals = statusEquals
            self.targetModelNameContains = targetModelNameContains
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self._creationTimeAfter, key: "creationTimeAfter")
            request.encodeQuery(self._creationTimeBefore, key: "creationTimeBefore")
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
            request.encodeQuery(self.sortBy, key: "sortBy")
            request.encodeQuery(self.sortOrder, key: "sortOrder")
            request.encodeQuery(self.sourceAccountEquals, key: "sourceAccountEquals")
            request.encodeQuery(self.sourceModelArnEquals, key: "sourceModelArnEquals")
            request.encodeQuery(self.statusEquals, key: "statusEquals")
            request.encodeQuery(self.targetModelNameContains, key: "outputModelNameContains")
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 1000)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 2048)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^\\S*$")
            try self.validate(self.sourceAccountEquals, name: "sourceAccountEquals", parent: name, pattern: "^[0-9]{12}$")
            try self.validate(self.sourceModelArnEquals, name: "sourceModelArnEquals", parent: name, max: 1011)
            try self.validate(self.sourceModelArnEquals, name: "sourceModelArnEquals", parent: name, min: 20)
            try self.validate(self.sourceModelArnEquals, name: "sourceModelArnEquals", parent: name, pattern: "^arn:aws(-[^:]+)?:bedrock:[a-z0-9-]{1,20}:(([0-9]{12}:custom-model/[a-z0-9-]{1,63}[.]{1}[a-z0-9-]{1,63}/[a-z0-9]{12})|(:foundation-model/[a-z0-9-]{1,63}[.]{1}([a-z0-9-]{1,63}[.]){0,2}[a-z0-9-]{1,63}([:][a-z0-9-]{1,63}){0,2}))$")
            try self.validate(self.targetModelNameContains, name: "targetModelNameContains", parent: name, max: 63)
            try self.validate(self.targetModelNameContains, name: "targetModelNameContains", parent: name, min: 1)
            try self.validate(self.targetModelNameContains, name: "targetModelNameContains", parent: name, pattern: "^([0-9a-zA-Z][_-]?){1,63}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListModelCopyJobsResponse: AWSDecodableShape {
        /// A list of information about each model copy job.
        public let modelCopyJobSummaries: [ModelCopyJobSummary]?
        /// If the total number of results is greater than the maxResults value provided in the request, use this token when making another request in the nextToken field to return the next batch of results.
        public let nextToken: String?

        @inlinable
        public init(modelCopyJobSummaries: [ModelCopyJobSummary]? = nil, nextToken: String? = nil) {
            self.modelCopyJobSummaries = modelCopyJobSummaries
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case modelCopyJobSummaries = "modelCopyJobSummaries"
            case nextToken = "nextToken"
        }
    }

    public struct ListModelCustomizationJobsRequest: AWSEncodableShape {
        /// Return customization jobs created after the specified time.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var creationTimeAfter: Date?
        /// Return customization jobs created before the specified time.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var creationTimeBefore: Date?
        /// The maximum number of results to return in the response. If the total number of results is greater than this value, use the token returned in the response in the nextToken field when making another request to return the next batch of results.
        public let maxResults: Int?
        /// Return customization jobs only if the job name contains these characters.
        public let nameContains: String?
        /// If the total number of results is greater than the maxResults value provided in the request, enter the token returned in the nextToken field in the response in this field to return the next batch of results.
        public let nextToken: String?
        /// The field to sort by in the returned list of jobs.
        public let sortBy: SortJobsBy?
        /// The sort order of the results.
        public let sortOrder: SortOrder?
        /// Return customization jobs with the specified status.
        public let statusEquals: FineTuningJobStatus?

        @inlinable
        public init(creationTimeAfter: Date? = nil, creationTimeBefore: Date? = nil, maxResults: Int? = nil, nameContains: String? = nil, nextToken: String? = nil, sortBy: SortJobsBy? = nil, sortOrder: SortOrder? = nil, statusEquals: FineTuningJobStatus? = nil) {
            self.creationTimeAfter = creationTimeAfter
            self.creationTimeBefore = creationTimeBefore
            self.maxResults = maxResults
            self.nameContains = nameContains
            self.nextToken = nextToken
            self.sortBy = sortBy
            self.sortOrder = sortOrder
            self.statusEquals = statusEquals
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self._creationTimeAfter, key: "creationTimeAfter")
            request.encodeQuery(self._creationTimeBefore, key: "creationTimeBefore")
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nameContains, key: "nameContains")
            request.encodeQuery(self.nextToken, key: "nextToken")
            request.encodeQuery(self.sortBy, key: "sortBy")
            request.encodeQuery(self.sortOrder, key: "sortOrder")
            request.encodeQuery(self.statusEquals, key: "statusEquals")
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 1000)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nameContains, name: "nameContains", parent: name, max: 63)
            try self.validate(self.nameContains, name: "nameContains", parent: name, min: 1)
            try self.validate(self.nameContains, name: "nameContains", parent: name, pattern: "^[a-zA-Z0-9](-*[a-zA-Z0-9\\+\\-\\.])*$")
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 2048)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^\\S*$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListModelCustomizationJobsResponse: AWSDecodableShape {
        /// Job summaries.
        public let modelCustomizationJobSummaries: [ModelCustomizationJobSummary]?
        /// If the total number of results is greater than the maxResults value provided in the request, use this token when making another request in the nextToken field to return the next batch of results.
        public let nextToken: String?

        @inlinable
        public init(modelCustomizationJobSummaries: [ModelCustomizationJobSummary]? = nil, nextToken: String? = nil) {
            self.modelCustomizationJobSummaries = modelCustomizationJobSummaries
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case modelCustomizationJobSummaries = "modelCustomizationJobSummaries"
            case nextToken = "nextToken"
        }
    }

    public struct ListModelImportJobsRequest: AWSEncodableShape {
        /// Return import jobs that were created after the specified time.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var creationTimeAfter: Date?
        /// Return import jobs that were created before the specified time.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var creationTimeBefore: Date?
        /// The maximum number of results to return in the response. If the total number of results is greater than this value, use the token returned in the response in the nextToken field when making another request to return the next batch of results.
        public let maxResults: Int?
        /// Return imported jobs only if the job name contains these characters.
        public let nameContains: String?
        /// If the total number of results is greater than the maxResults value provided in the request, enter the token returned in the nextToken field in the response in this field to return the next batch of results.
        public let nextToken: String?
        /// The field to sort by in the returned list of imported jobs.
        public let sortBy: SortJobsBy?
        /// Specifies whether to sort the results in ascending or descending order.
        public let sortOrder: SortOrder?
        /// Return imported jobs with the specified status.
        public let statusEquals: ModelImportJobStatus?

        @inlinable
        public init(creationTimeAfter: Date? = nil, creationTimeBefore: Date? = nil, maxResults: Int? = nil, nameContains: String? = nil, nextToken: String? = nil, sortBy: SortJobsBy? = nil, sortOrder: SortOrder? = nil, statusEquals: ModelImportJobStatus? = nil) {
            self.creationTimeAfter = creationTimeAfter
            self.creationTimeBefore = creationTimeBefore
            self.maxResults = maxResults
            self.nameContains = nameContains
            self.nextToken = nextToken
            self.sortBy = sortBy
            self.sortOrder = sortOrder
            self.statusEquals = statusEquals
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self._creationTimeAfter, key: "creationTimeAfter")
            request.encodeQuery(self._creationTimeBefore, key: "creationTimeBefore")
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nameContains, key: "nameContains")
            request.encodeQuery(self.nextToken, key: "nextToken")
            request.encodeQuery(self.sortBy, key: "sortBy")
            request.encodeQuery(self.sortOrder, key: "sortOrder")
            request.encodeQuery(self.statusEquals, key: "statusEquals")
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 1000)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nameContains, name: "nameContains", parent: name, max: 63)
            try self.validate(self.nameContains, name: "nameContains", parent: name, min: 1)
            try self.validate(self.nameContains, name: "nameContains", parent: name, pattern: "^[a-zA-Z0-9](-*[a-zA-Z0-9\\+\\-\\.])*$")
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 2048)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^\\S*$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListModelImportJobsResponse: AWSDecodableShape {
        /// Import job summaries.
        public let modelImportJobSummaries: [ModelImportJobSummary]?
        /// If the total number of results is greater than the maxResults value provided in the request, enter the token returned in the nextToken field in the response in this field to return the next batch of results.
        public let nextToken: String?

        @inlinable
        public init(modelImportJobSummaries: [ModelImportJobSummary]? = nil, nextToken: String? = nil) {
            self.modelImportJobSummaries = modelImportJobSummaries
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case modelImportJobSummaries = "modelImportJobSummaries"
            case nextToken = "nextToken"
        }
    }

    public struct ListModelInvocationJobsRequest: AWSEncodableShape {
        /// The maximum number of results to return. If there are more results than the number that you specify, a nextToken value is returned. Use the nextToken in a request to return the next batch of results.
        public let maxResults: Int?
        /// Specify a string to filter for batch inference jobs whose names contain the string.
        public let nameContains: String?
        /// If there were more results than the value you specified in the maxResults field in a previous ListModelInvocationJobs request, the response would have returned a nextToken value. To see the next batch of results, send the nextToken value in another request.
        public let nextToken: String?
        /// An attribute by which to sort the results.
        public let sortBy: SortJobsBy?
        /// Specifies whether to sort the results by ascending or descending order.
        public let sortOrder: SortOrder?
        /// Specify a status to filter for batch inference jobs whose statuses match the string you specify. The following statuses are possible:   Submitted – This job has been submitted to a queue for validation.   Validating – This job is being validated for the requirements described in Format and upload your batch inference data. The criteria include the following:   Your IAM service role has access to the Amazon S3 buckets containing your files.   Your files are .jsonl files and each individual record is a JSON object in the correct format. Note that validation doesn't check if the modelInput value matches the request body for the model.   Your files fulfill the requirements for file size and number of records. For more information, see Quotas for Amazon Bedrock.     Scheduled – This job has been validated and is now in a queue. The job will automatically start when it reaches its turn.   Expired – This job timed out because it was scheduled but didn't begin before the set timeout duration. Submit a new job request.   InProgress – This job has begun. You can start viewing the results in the output S3 location.   Completed – This job has successfully completed. View the output files in the output S3 location.   PartiallyCompleted – This job has partially completed. Not all of your records could be processed in time. View the output files in the output S3 location.   Failed – This job has failed. Check the failure message for any further details. For further assistance, reach out to the Amazon Web Services Support Center.   Stopped – This job was stopped by a user.   Stopping – This job is being stopped by a user.
        public let statusEquals: ModelInvocationJobStatus?
        /// Specify a time to filter for batch inference jobs that were submitted after the time you specify.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var submitTimeAfter: Date?
        /// Specify a time to filter for batch inference jobs that were submitted before the time you specify.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var submitTimeBefore: Date?

        @inlinable
        public init(maxResults: Int? = nil, nameContains: String? = nil, nextToken: String? = nil, sortBy: SortJobsBy? = nil, sortOrder: SortOrder? = nil, statusEquals: ModelInvocationJobStatus? = nil, submitTimeAfter: Date? = nil, submitTimeBefore: Date? = nil) {
            self.maxResults = maxResults
            self.nameContains = nameContains
            self.nextToken = nextToken
            self.sortBy = sortBy
            self.sortOrder = sortOrder
            self.statusEquals = statusEquals
            self.submitTimeAfter = submitTimeAfter
            self.submitTimeBefore = submitTimeBefore
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nameContains, key: "nameContains")
            request.encodeQuery(self.nextToken, key: "nextToken")
            request.encodeQuery(self.sortBy, key: "sortBy")
            request.encodeQuery(self.sortOrder, key: "sortOrder")
            request.encodeQuery(self.statusEquals, key: "statusEquals")
            request.encodeQuery(self._submitTimeAfter, key: "submitTimeAfter")
            request.encodeQuery(self._submitTimeBefore, key: "submitTimeBefore")
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 1000)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nameContains, name: "nameContains", parent: name, max: 63)
            try self.validate(self.nameContains, name: "nameContains", parent: name, min: 1)
            try self.validate(self.nameContains, name: "nameContains", parent: name, pattern: "^[a-zA-Z0-9]{1,63}(-*[a-zA-Z0-9\\+\\-\\.]){0,63}$")
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 2048)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^\\S*$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListModelInvocationJobsResponse: AWSDecodableShape {
        /// A list of items, each of which contains a summary about a batch inference job.
        public let invocationJobSummaries: [ModelInvocationJobSummary]?
        /// If there are more results than can fit in the response, a nextToken is returned. Use the nextToken in a request to return the next batch of results.
        public let nextToken: String?

        @inlinable
        public init(invocationJobSummaries: [ModelInvocationJobSummary]? = nil, nextToken: String? = nil) {
            self.invocationJobSummaries = invocationJobSummaries
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case invocationJobSummaries = "invocationJobSummaries"
            case nextToken = "nextToken"
        }
    }

    public struct ListPromptRoutersRequest: AWSEncodableShape {
        /// The maximum number of prompt routers to return in one page of results.
        public let maxResults: Int?
        /// Specify the pagination token from a previous request to retrieve the next page of results.
        public let nextToken: String?

        @inlinable
        public init(maxResults: Int? = nil, nextToken: String? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 1000)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 2048)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^\\S*$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListPromptRoutersResponse: AWSDecodableShape {
        /// Specify the pagination token from a previous request to retrieve the next page of results.
        public let nextToken: String?
        /// A list of prompt router summaries.
        public let promptRouterSummaries: [PromptRouterSummary]?

        @inlinable
        public init(nextToken: String? = nil, promptRouterSummaries: [PromptRouterSummary]? = nil) {
            self.nextToken = nextToken
            self.promptRouterSummaries = promptRouterSummaries
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "nextToken"
            case promptRouterSummaries = "promptRouterSummaries"
        }
    }

    public struct ListProvisionedModelThroughputsRequest: AWSEncodableShape {
        /// A filter that returns Provisioned Throughputs created after the specified time.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var creationTimeAfter: Date?
        /// A filter that returns Provisioned Throughputs created before the specified time.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var creationTimeBefore: Date?
        /// THe maximum number of results to return in the response. If there are more results than the number you specified, the response returns a nextToken value. To see the next batch of results, send the nextToken value in another list request.
        public let maxResults: Int?
        /// A filter that returns Provisioned Throughputs whose model Amazon Resource Name (ARN) is equal to the value that you specify.
        public let modelArnEquals: String?
        /// A filter that returns Provisioned Throughputs if their name contains the expression that you specify.
        public let nameContains: String?
        /// If there are more results than the number you specified in the maxResults field, the response returns a nextToken value. To see the next batch of results, specify the nextToken value in this field.
        public let nextToken: String?
        /// The field by which to sort the returned list of Provisioned Throughputs.
        public let sortBy: SortByProvisionedModels?
        /// The sort order of the results.
        public let sortOrder: SortOrder?
        /// A filter that returns Provisioned Throughputs if their statuses matches the value that you specify.
        public let statusEquals: ProvisionedModelStatus?

        @inlinable
        public init(creationTimeAfter: Date? = nil, creationTimeBefore: Date? = nil, maxResults: Int? = nil, modelArnEquals: String? = nil, nameContains: String? = nil, nextToken: String? = nil, sortBy: SortByProvisionedModels? = nil, sortOrder: SortOrder? = nil, statusEquals: ProvisionedModelStatus? = nil) {
            self.creationTimeAfter = creationTimeAfter
            self.creationTimeBefore = creationTimeBefore
            self.maxResults = maxResults
            self.modelArnEquals = modelArnEquals
            self.nameContains = nameContains
            self.nextToken = nextToken
            self.sortBy = sortBy
            self.sortOrder = sortOrder
            self.statusEquals = statusEquals
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self._creationTimeAfter, key: "creationTimeAfter")
            request.encodeQuery(self._creationTimeBefore, key: "creationTimeBefore")
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.modelArnEquals, key: "modelArnEquals")
            request.encodeQuery(self.nameContains, key: "nameContains")
            request.encodeQuery(self.nextToken, key: "nextToken")
            request.encodeQuery(self.sortBy, key: "sortBy")
            request.encodeQuery(self.sortOrder, key: "sortOrder")
            request.encodeQuery(self.statusEquals, key: "statusEquals")
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 1000)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.modelArnEquals, name: "modelArnEquals", parent: name, max: 1011)
            try self.validate(self.modelArnEquals, name: "modelArnEquals", parent: name, min: 20)
            try self.validate(self.modelArnEquals, name: "modelArnEquals", parent: name, pattern: "^arn:aws(-[^:]+)?:bedrock:[a-z0-9-]{1,20}:(([0-9]{12}:custom-model/[a-z0-9-]{1,63}[.]{1}[a-z0-9-]{1,63}/[a-z0-9]{12})|(:foundation-model/[a-z0-9-]{1,63}[.]{1}([a-z0-9-]{1,63}[.]){0,2}[a-z0-9-]{1,63}([:][a-z0-9-]{1,63}){0,2}))$")
            try self.validate(self.nameContains, name: "nameContains", parent: name, max: 63)
            try self.validate(self.nameContains, name: "nameContains", parent: name, min: 1)
            try self.validate(self.nameContains, name: "nameContains", parent: name, pattern: "^([0-9a-zA-Z][_-]?)+$")
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 2048)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^\\S*$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListProvisionedModelThroughputsResponse: AWSDecodableShape {
        /// If there are more results than the number you specified in the maxResults field, this value is returned. To see the next batch of results, include this value in the nextToken field in another list request.
        public let nextToken: String?
        /// A list of summaries, one for each Provisioned Throughput in the response.
        public let provisionedModelSummaries: [ProvisionedModelSummary]?

        @inlinable
        public init(nextToken: String? = nil, provisionedModelSummaries: [ProvisionedModelSummary]? = nil) {
            self.nextToken = nextToken
            self.provisionedModelSummaries = provisionedModelSummaries
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "nextToken"
            case provisionedModelSummaries = "provisionedModelSummaries"
        }
    }

    public struct ListTagsForResourceRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the resource.
        public let resourceARN: String

        @inlinable
        public init(resourceARN: String) {
            self.resourceARN = resourceARN
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceARN, name: "resourceARN", parent: name, max: 1011)
            try self.validate(self.resourceARN, name: "resourceARN", parent: name, min: 20)
            try self.validate(self.resourceARN, name: "resourceARN", parent: name, pattern: "(^[a-zA-Z0-9][a-zA-Z0-9\\-]*$)|(^arn:aws(-[^:]+)?:bedrock:[a-z0-9-]{1,20}:([0-9]{12}|)((:(fine-tuning-job|model-customization-job|custom-model)/[a-z0-9-]{1,63}[.]{1}[a-z0-9-]{1,63}([a-z0-9-]{1,63}[.]){0,2}[a-z0-9-]{1,63}([:][a-z0-9-]{1,63}){0,2}(/[a-z0-9]{12})$)|(:guardrail/[a-z0-9]+$)|(:(inference-profile|application-inference-profile)/[a-zA-Z0-9-:.]+$)|(:(provisioned-model|model-invocation-job|model-evaluation-job|evaluation-job|model-import-job|imported-model|async-invoke)/[a-z0-9]{12}$)))")
        }

        private enum CodingKeys: String, CodingKey {
            case resourceARN = "resourceARN"
        }
    }

    public struct ListTagsForResourceResponse: AWSDecodableShape {
        /// An array of the tags associated with this resource.
        public let tags: [Tag]?

        @inlinable
        public init(tags: [Tag]? = nil) {
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case tags = "tags"
        }
    }

    public struct LoggingConfig: AWSEncodableShape & AWSDecodableShape {
        /// CloudWatch logging configuration.
        public let cloudWatchConfig: CloudWatchConfig?
        /// Set to include embeddings data in the log delivery.
        public let embeddingDataDeliveryEnabled: Bool?
        /// Set to include image data in the log delivery.
        public let imageDataDeliveryEnabled: Bool?
        /// S3 configuration for storing log data.
        public let s3Config: S3Config?
        /// Set to include text data in the log delivery.
        public let textDataDeliveryEnabled: Bool?
        /// Set to include video data in the log delivery.
        public let videoDataDeliveryEnabled: Bool?

        @inlinable
        public init(cloudWatchConfig: CloudWatchConfig? = nil, embeddingDataDeliveryEnabled: Bool? = nil, imageDataDeliveryEnabled: Bool? = nil, s3Config: S3Config? = nil, textDataDeliveryEnabled: Bool? = nil, videoDataDeliveryEnabled: Bool? = nil) {
            self.cloudWatchConfig = cloudWatchConfig
            self.embeddingDataDeliveryEnabled = embeddingDataDeliveryEnabled
            self.imageDataDeliveryEnabled = imageDataDeliveryEnabled
            self.s3Config = s3Config
            self.textDataDeliveryEnabled = textDataDeliveryEnabled
            self.videoDataDeliveryEnabled = videoDataDeliveryEnabled
        }

        public func validate(name: String) throws {
            try self.cloudWatchConfig?.validate(name: "\(name).cloudWatchConfig")
            try self.s3Config?.validate(name: "\(name).s3Config")
        }

        private enum CodingKeys: String, CodingKey {
            case cloudWatchConfig = "cloudWatchConfig"
            case embeddingDataDeliveryEnabled = "embeddingDataDeliveryEnabled"
            case imageDataDeliveryEnabled = "imageDataDeliveryEnabled"
            case s3Config = "s3Config"
            case textDataDeliveryEnabled = "textDataDeliveryEnabled"
            case videoDataDeliveryEnabled = "videoDataDeliveryEnabled"
        }
    }

    public struct MarketplaceModelEndpoint: AWSDecodableShape {
        /// The timestamp when the endpoint was registered.
        @CustomCoding<ISO8601DateCoder>
        public var createdAt: Date
        /// The Amazon Resource Name (ARN) of the endpoint.
        public let endpointArn: String
        /// The configuration of the endpoint, including the number and type of instances used.
        public let endpointConfig: EndpointConfig
        /// The current status of the endpoint (e.g., Creating, InService, Updating, Failed).
        public let endpointStatus: String
        /// Additional information about the endpoint status, if available.
        public let endpointStatusMessage: String?
        /// The ARN of the model from Amazon Bedrock Marketplace that is deployed on this endpoint.
        public let modelSourceIdentifier: String
        /// The overall status of the endpoint in Amazon Bedrock Marketplace (e.g., ACTIVE, INACTIVE).
        public let status: Status?
        /// Additional information about the overall status, if available.
        public let statusMessage: String?
        /// The timestamp when the endpoint was last updated.
        @CustomCoding<ISO8601DateCoder>
        public var updatedAt: Date

        @inlinable
        public init(createdAt: Date, endpointArn: String, endpointConfig: EndpointConfig, endpointStatus: String, endpointStatusMessage: String? = nil, modelSourceIdentifier: String, status: Status? = nil, statusMessage: String? = nil, updatedAt: Date) {
            self.createdAt = createdAt
            self.endpointArn = endpointArn
            self.endpointConfig = endpointConfig
            self.endpointStatus = endpointStatus
            self.endpointStatusMessage = endpointStatusMessage
            self.modelSourceIdentifier = modelSourceIdentifier
            self.status = status
            self.statusMessage = statusMessage
            self.updatedAt = updatedAt
        }

        private enum CodingKeys: String, CodingKey {
            case createdAt = "createdAt"
            case endpointArn = "endpointArn"
            case endpointConfig = "endpointConfig"
            case endpointStatus = "endpointStatus"
            case endpointStatusMessage = "endpointStatusMessage"
            case modelSourceIdentifier = "modelSourceIdentifier"
            case status = "status"
            case statusMessage = "statusMessage"
            case updatedAt = "updatedAt"
        }
    }

    public struct MarketplaceModelEndpointSummary: AWSDecodableShape {
        /// The timestamp when the endpoint was created.
        @CustomCoding<ISO8601DateCoder>
        public var createdAt: Date
        /// The Amazon Resource Name (ARN) of the endpoint.
        public let endpointArn: String
        /// The ARN of the model from Amazon Bedrock Marketplace that is deployed on this endpoint.
        public let modelSourceIdentifier: String
        /// The overall status of the endpoint in Amazon Bedrock Marketplace.
        public let status: Status?
        /// Additional information about the overall status, if available.
        public let statusMessage: String?
        /// The timestamp when the endpoint was last updated.
        @CustomCoding<ISO8601DateCoder>
        public var updatedAt: Date

        @inlinable
        public init(createdAt: Date, endpointArn: String, modelSourceIdentifier: String, status: Status? = nil, statusMessage: String? = nil, updatedAt: Date) {
            self.createdAt = createdAt
            self.endpointArn = endpointArn
            self.modelSourceIdentifier = modelSourceIdentifier
            self.status = status
            self.statusMessage = statusMessage
            self.updatedAt = updatedAt
        }

        private enum CodingKeys: String, CodingKey {
            case createdAt = "createdAt"
            case endpointArn = "endpointArn"
            case modelSourceIdentifier = "modelSourceIdentifier"
            case status = "status"
            case statusMessage = "statusMessage"
            case updatedAt = "updatedAt"
        }
    }

    public struct ModelCopyJobSummary: AWSDecodableShape {
        /// The time that the model copy job was created.
        @CustomCoding<ISO8601DateCoder>
        public var creationTime: Date
        /// If a model fails to be copied, a message describing why the job failed is included here.
        public let failureMessage: String?
        /// The Amazon Resoource Name (ARN) of the model copy job.
        public let jobArn: String
        /// The unique identifier of the account that the model being copied originated from.
        public let sourceAccountId: String
        /// The Amazon Resource Name (ARN) of the original model being copied.
        public let sourceModelArn: String
        /// The name of the original model being copied.
        public let sourceModelName: String?
        /// The status of the model copy job.
        public let status: ModelCopyJobStatus
        /// The Amazon Resource Name (ARN) of the copied model.
        public let targetModelArn: String
        /// The Amazon Resource Name (ARN) of the KMS key used to encrypt the copied model.
        public let targetModelKmsKeyArn: String?
        /// The name of the copied model.
        public let targetModelName: String?
        /// Tags associated with the copied model.
        public let targetModelTags: [Tag]?

        @inlinable
        public init(creationTime: Date, failureMessage: String? = nil, jobArn: String, sourceAccountId: String, sourceModelArn: String, sourceModelName: String? = nil, status: ModelCopyJobStatus, targetModelArn: String, targetModelKmsKeyArn: String? = nil, targetModelName: String? = nil, targetModelTags: [Tag]? = nil) {
            self.creationTime = creationTime
            self.failureMessage = failureMessage
            self.jobArn = jobArn
            self.sourceAccountId = sourceAccountId
            self.sourceModelArn = sourceModelArn
            self.sourceModelName = sourceModelName
            self.status = status
            self.targetModelArn = targetModelArn
            self.targetModelKmsKeyArn = targetModelKmsKeyArn
            self.targetModelName = targetModelName
            self.targetModelTags = targetModelTags
        }

        private enum CodingKeys: String, CodingKey {
            case creationTime = "creationTime"
            case failureMessage = "failureMessage"
            case jobArn = "jobArn"
            case sourceAccountId = "sourceAccountId"
            case sourceModelArn = "sourceModelArn"
            case sourceModelName = "sourceModelName"
            case status = "status"
            case targetModelArn = "targetModelArn"
            case targetModelKmsKeyArn = "targetModelKmsKeyArn"
            case targetModelName = "targetModelName"
            case targetModelTags = "targetModelTags"
        }
    }

    public struct ModelCustomizationJobSummary: AWSDecodableShape {
        /// Amazon Resource Name (ARN) of the base model.
        public let baseModelArn: String
        /// Creation time of the custom model.
        @CustomCoding<ISO8601DateCoder>
        public var creationTime: Date
        /// Specifies whether to carry out continued pre-training of a model or whether to fine-tune it. For more information, see Custom models.
        public let customizationType: CustomizationType?
        /// Amazon Resource Name (ARN) of the custom model.
        public let customModelArn: String?
        /// Name of the custom model.
        public let customModelName: String?
        /// Time that the customization job ended.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var endTime: Date?
        /// Amazon Resource Name (ARN) of the customization job.
        public let jobArn: String
        /// Name of the customization job.
        public let jobName: String
        /// Time that the customization job was last modified.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var lastModifiedTime: Date?
        /// Status of the customization job.
        public let status: ModelCustomizationJobStatus

        @inlinable
        public init(baseModelArn: String, creationTime: Date, customizationType: CustomizationType? = nil, customModelArn: String? = nil, customModelName: String? = nil, endTime: Date? = nil, jobArn: String, jobName: String, lastModifiedTime: Date? = nil, status: ModelCustomizationJobStatus) {
            self.baseModelArn = baseModelArn
            self.creationTime = creationTime
            self.customizationType = customizationType
            self.customModelArn = customModelArn
            self.customModelName = customModelName
            self.endTime = endTime
            self.jobArn = jobArn
            self.jobName = jobName
            self.lastModifiedTime = lastModifiedTime
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case baseModelArn = "baseModelArn"
            case creationTime = "creationTime"
            case customizationType = "customizationType"
            case customModelArn = "customModelArn"
            case customModelName = "customModelName"
            case endTime = "endTime"
            case jobArn = "jobArn"
            case jobName = "jobName"
            case lastModifiedTime = "lastModifiedTime"
            case status = "status"
        }
    }

    public struct ModelImportJobSummary: AWSDecodableShape {
        /// The time import job was created.
        @CustomCoding<ISO8601DateCoder>
        public var creationTime: Date
        /// The time when import job ended.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var endTime: Date?
        /// The Amazon resource Name (ARN) of the imported model.
        public let importedModelArn: String?
        /// The name of the imported model.
        public let importedModelName: String?
        /// The Amazon Resource Name (ARN) of the import job.
        public let jobArn: String
        /// The name of the import job.
        public let jobName: String
        /// The time when the import job was last modified.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var lastModifiedTime: Date?
        /// The status of the imported job.
        public let status: ModelImportJobStatus

        @inlinable
        public init(creationTime: Date, endTime: Date? = nil, importedModelArn: String? = nil, importedModelName: String? = nil, jobArn: String, jobName: String, lastModifiedTime: Date? = nil, status: ModelImportJobStatus) {
            self.creationTime = creationTime
            self.endTime = endTime
            self.importedModelArn = importedModelArn
            self.importedModelName = importedModelName
            self.jobArn = jobArn
            self.jobName = jobName
            self.lastModifiedTime = lastModifiedTime
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case creationTime = "creationTime"
            case endTime = "endTime"
            case importedModelArn = "importedModelArn"
            case importedModelName = "importedModelName"
            case jobArn = "jobArn"
            case jobName = "jobName"
            case lastModifiedTime = "lastModifiedTime"
            case status = "status"
        }
    }

    public struct ModelInvocationJobS3InputDataConfig: AWSEncodableShape & AWSDecodableShape {
        /// The ID of the Amazon Web Services account that owns the S3 bucket containing the input data.
        public let s3BucketOwner: String?
        /// The format of the input data.
        public let s3InputFormat: S3InputFormat?
        /// The S3 location of the input data.
        public let s3Uri: String

        @inlinable
        public init(s3BucketOwner: String? = nil, s3InputFormat: S3InputFormat? = nil, s3Uri: String) {
            self.s3BucketOwner = s3BucketOwner
            self.s3InputFormat = s3InputFormat
            self.s3Uri = s3Uri
        }

        public func validate(name: String) throws {
            try self.validate(self.s3BucketOwner, name: "s3BucketOwner", parent: name, pattern: "^[0-9]{12}$")
            try self.validate(self.s3Uri, name: "s3Uri", parent: name, max: 1024)
            try self.validate(self.s3Uri, name: "s3Uri", parent: name, min: 1)
            try self.validate(self.s3Uri, name: "s3Uri", parent: name, pattern: "^s3://[a-z0-9][-.a-z0-9]{1,61}(?:/[-!_*'().a-z0-9A-Z]+(?:/[-!_*'().a-z0-9A-Z]+)*)?/?$")
        }

        private enum CodingKeys: String, CodingKey {
            case s3BucketOwner = "s3BucketOwner"
            case s3InputFormat = "s3InputFormat"
            case s3Uri = "s3Uri"
        }
    }

    public struct ModelInvocationJobS3OutputDataConfig: AWSEncodableShape & AWSDecodableShape {
        /// The ID of the Amazon Web Services account that owns the S3 bucket containing the output data.
        public let s3BucketOwner: String?
        /// The unique identifier of the key that encrypts the S3 location of the output data.
        public let s3EncryptionKeyId: String?
        /// The S3 location of the output data.
        public let s3Uri: String

        @inlinable
        public init(s3BucketOwner: String? = nil, s3EncryptionKeyId: String? = nil, s3Uri: String) {
            self.s3BucketOwner = s3BucketOwner
            self.s3EncryptionKeyId = s3EncryptionKeyId
            self.s3Uri = s3Uri
        }

        public func validate(name: String) throws {
            try self.validate(self.s3BucketOwner, name: "s3BucketOwner", parent: name, pattern: "^[0-9]{12}$")
            try self.validate(self.s3EncryptionKeyId, name: "s3EncryptionKeyId", parent: name, max: 2048)
            try self.validate(self.s3EncryptionKeyId, name: "s3EncryptionKeyId", parent: name, min: 1)
            try self.validate(self.s3EncryptionKeyId, name: "s3EncryptionKeyId", parent: name, pattern: "^(arn:aws(-[^:]+)?:kms:[a-zA-Z0-9-]*:[0-9]{12}:((key/[a-zA-Z0-9-]{36})|(alias/[a-zA-Z0-9-_/]+)))|([a-zA-Z0-9-]{36})|(alias/[a-zA-Z0-9-_/]+)$")
            try self.validate(self.s3Uri, name: "s3Uri", parent: name, max: 1024)
            try self.validate(self.s3Uri, name: "s3Uri", parent: name, min: 1)
            try self.validate(self.s3Uri, name: "s3Uri", parent: name, pattern: "^s3://[a-z0-9][-.a-z0-9]{1,61}(?:/[-!_*'().a-z0-9A-Z]+(?:/[-!_*'().a-z0-9A-Z]+)*)?/?$")
        }

        private enum CodingKeys: String, CodingKey {
            case s3BucketOwner = "s3BucketOwner"
            case s3EncryptionKeyId = "s3EncryptionKeyId"
            case s3Uri = "s3Uri"
        }
    }

    public struct ModelInvocationJobSummary: AWSDecodableShape {
        /// A unique, case-sensitive identifier to ensure that the API request completes no more than one time. If this token matches a previous request, Amazon Bedrock ignores the request, but does not return an error. For more information, see Ensuring idempotency.
        public let clientRequestToken: String?
        /// The time at which the batch inference job ended.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var endTime: Date?
        /// Details about the location of the input to the batch inference job.
        public let inputDataConfig: ModelInvocationJobInputDataConfig
        /// The Amazon Resource Name (ARN) of the batch inference job.
        public let jobArn: String
        /// The time at which the batch inference job times or timed out.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var jobExpirationTime: Date?
        /// The name of the batch inference job.
        public let jobName: String
        /// The time at which the batch inference job was last modified.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var lastModifiedTime: Date?
        /// If the batch inference job failed, this field contains a message describing why the job failed.
        public let message: String?
        /// The unique identifier of the foundation model used for model inference.
        public let modelId: String
        /// Details about the location of the output of the batch inference job.
        public let outputDataConfig: ModelInvocationJobOutputDataConfig
        /// The Amazon Resource Name (ARN) of the service role with permissions to carry out and manage batch inference. You can use the console to create a default service role or follow the steps at Create a service role for batch inference.
        public let roleArn: String
        /// The status of the batch inference job. The following statuses are possible:   Submitted – This job has been submitted to a queue for validation.   Validating – This job is being validated for the requirements described in Format and upload your batch inference data. The criteria include the following:   Your IAM service role has access to the Amazon S3 buckets containing your files.   Your files are .jsonl files and each individual record is a JSON object in the correct format. Note that validation doesn't check if the modelInput value matches the request body for the model.   Your files fulfill the requirements for file size and number of records. For more information, see Quotas for Amazon Bedrock.     Scheduled – This job has been validated and is now in a queue. The job will automatically start when it reaches its turn.   Expired – This job timed out because it was scheduled but didn't begin before the set timeout duration. Submit a new job request.   InProgress – This job has begun. You can start viewing the results in the output S3 location.   Completed – This job has successfully completed. View the output files in the output S3 location.   PartiallyCompleted – This job has partially completed. Not all of your records could be processed in time. View the output files in the output S3 location.   Failed – This job has failed. Check the failure message for any further details. For further assistance, reach out to the Amazon Web Services Support Center.   Stopped – This job was stopped by a user.   Stopping – This job is being stopped by a user.
        public let status: ModelInvocationJobStatus?
        /// The time at which the batch inference job was submitted.
        @CustomCoding<ISO8601DateCoder>
        public var submitTime: Date
        /// The number of hours after which the batch inference job was set to time out.
        public let timeoutDurationInHours: Int?
        /// The configuration of the Virtual Private Cloud (VPC) for the data in the batch inference job. For more information, see Protect batch inference jobs using a VPC.
        public let vpcConfig: VpcConfig?

        @inlinable
        public init(clientRequestToken: String? = nil, endTime: Date? = nil, inputDataConfig: ModelInvocationJobInputDataConfig, jobArn: String, jobExpirationTime: Date? = nil, jobName: String, lastModifiedTime: Date? = nil, message: String? = nil, modelId: String, outputDataConfig: ModelInvocationJobOutputDataConfig, roleArn: String, status: ModelInvocationJobStatus? = nil, submitTime: Date, timeoutDurationInHours: Int? = nil, vpcConfig: VpcConfig? = nil) {
            self.clientRequestToken = clientRequestToken
            self.endTime = endTime
            self.inputDataConfig = inputDataConfig
            self.jobArn = jobArn
            self.jobExpirationTime = jobExpirationTime
            self.jobName = jobName
            self.lastModifiedTime = lastModifiedTime
            self.message = message
            self.modelId = modelId
            self.outputDataConfig = outputDataConfig
            self.roleArn = roleArn
            self.status = status
            self.submitTime = submitTime
            self.timeoutDurationInHours = timeoutDurationInHours
            self.vpcConfig = vpcConfig
        }

        private enum CodingKeys: String, CodingKey {
            case clientRequestToken = "clientRequestToken"
            case endTime = "endTime"
            case inputDataConfig = "inputDataConfig"
            case jobArn = "jobArn"
            case jobExpirationTime = "jobExpirationTime"
            case jobName = "jobName"
            case lastModifiedTime = "lastModifiedTime"
            case message = "message"
            case modelId = "modelId"
            case outputDataConfig = "outputDataConfig"
            case roleArn = "roleArn"
            case status = "status"
            case submitTime = "submitTime"
            case timeoutDurationInHours = "timeoutDurationInHours"
            case vpcConfig = "vpcConfig"
        }
    }

    public struct OrchestrationConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// Contains configuration details for transforming the prompt.
        public let queryTransformationConfiguration: QueryTransformationConfiguration

        @inlinable
        public init(queryTransformationConfiguration: QueryTransformationConfiguration) {
            self.queryTransformationConfiguration = queryTransformationConfiguration
        }

        private enum CodingKeys: String, CodingKey {
            case queryTransformationConfiguration = "queryTransformationConfiguration"
        }
    }

    public struct OutputDataConfig: AWSEncodableShape & AWSDecodableShape {
        /// The S3 URI where the output data is stored.
        public let s3Uri: String

        @inlinable
        public init(s3Uri: String) {
            self.s3Uri = s3Uri
        }

        public func validate(name: String) throws {
            try self.validate(self.s3Uri, name: "s3Uri", parent: name, max: 1024)
            try self.validate(self.s3Uri, name: "s3Uri", parent: name, min: 1)
            try self.validate(self.s3Uri, name: "s3Uri", parent: name, pattern: "^s3://[a-z0-9][-.a-z0-9]{1,61}(?:/[-!_*'().a-z0-9A-Z]+(?:/[-!_*'().a-z0-9A-Z]+)*)?/?$")
        }

        private enum CodingKeys: String, CodingKey {
            case s3Uri = "s3Uri"
        }
    }

    public struct PromptRouterSummary: AWSDecodableShape {
        /// When the router was created.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var createdAt: Date?
        /// The router's description.
        public let description: String?
        /// The router's fallback model.
        public let fallbackModel: PromptRouterTargetModel
        /// The router's models.
        public let models: [PromptRouterTargetModel]
        /// The router's ARN.
        public let promptRouterArn: String
        /// The router's name.
        public let promptRouterName: String
        /// The router's routing criteria.
        public let routingCriteria: RoutingCriteria
        /// The router's status.
        public let status: PromptRouterStatus
        /// The summary's type.
        public let type: PromptRouterType
        /// When the router was updated.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var updatedAt: Date?

        @inlinable
        public init(createdAt: Date? = nil, description: String? = nil, fallbackModel: PromptRouterTargetModel, models: [PromptRouterTargetModel], promptRouterArn: String, promptRouterName: String, routingCriteria: RoutingCriteria, status: PromptRouterStatus, type: PromptRouterType, updatedAt: Date? = nil) {
            self.createdAt = createdAt
            self.description = description
            self.fallbackModel = fallbackModel
            self.models = models
            self.promptRouterArn = promptRouterArn
            self.promptRouterName = promptRouterName
            self.routingCriteria = routingCriteria
            self.status = status
            self.type = type
            self.updatedAt = updatedAt
        }

        private enum CodingKeys: String, CodingKey {
            case createdAt = "createdAt"
            case description = "description"
            case fallbackModel = "fallbackModel"
            case models = "models"
            case promptRouterArn = "promptRouterArn"
            case promptRouterName = "promptRouterName"
            case routingCriteria = "routingCriteria"
            case status = "status"
            case type = "type"
            case updatedAt = "updatedAt"
        }
    }

    public struct PromptRouterTargetModel: AWSDecodableShape {
        /// The target model's ARN.
        public let modelArn: String?

        @inlinable
        public init(modelArn: String? = nil) {
            self.modelArn = modelArn
        }

        private enum CodingKeys: String, CodingKey {
            case modelArn = "modelArn"
        }
    }

    public struct PromptTemplate: AWSEncodableShape & AWSDecodableShape {
        /// The template for the prompt that's sent to the model for response generation. You can include  prompt placeholders, which become replaced before the prompt is sent to the model to provide  instructions and context to the model. In addition, you can include XML tags to delineate  meaningful sections of the prompt template. For more information, see Knowledge base prompt template and  Use XML tags with Anthropic Claude models.
        public let textPromptTemplate: String?

        @inlinable
        public init(textPromptTemplate: String? = nil) {
            self.textPromptTemplate = textPromptTemplate
        }

        public func validate(name: String) throws {
            try self.validate(self.textPromptTemplate, name: "textPromptTemplate", parent: name, max: 100000)
            try self.validate(self.textPromptTemplate, name: "textPromptTemplate", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case textPromptTemplate = "textPromptTemplate"
        }
    }

    public struct ProvisionedModelSummary: AWSDecodableShape {
        /// The duration for which the Provisioned Throughput was committed.
        public let commitmentDuration: CommitmentDuration?
        /// The timestamp for when the commitment term of the Provisioned Throughput expires.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var commitmentExpirationTime: Date?
        /// The time that the Provisioned Throughput was created.
        @CustomCoding<ISO8601DateCoder>
        public var creationTime: Date
        /// The Amazon Resource Name (ARN) of the model requested to be associated to this Provisioned Throughput. This value differs from the modelArn if updating hasn't completed.
        public let desiredModelArn: String
        /// The number of model units that was requested to be allocated to the Provisioned Throughput.
        public let desiredModelUnits: Int
        /// The Amazon Resource Name (ARN) of the base model for which the Provisioned Throughput was created, or of the base model that the custom model for which the Provisioned Throughput was created was customized.
        public let foundationModelArn: String
        /// The time that the Provisioned Throughput was last modified.
        @CustomCoding<ISO8601DateCoder>
        public var lastModifiedTime: Date
        /// The Amazon Resource Name (ARN) of the model associated with the Provisioned Throughput.
        public let modelArn: String
        /// The number of model units allocated to the Provisioned Throughput.
        public let modelUnits: Int
        /// The Amazon Resource Name (ARN) of the Provisioned Throughput.
        public let provisionedModelArn: String
        /// The name of the Provisioned Throughput.
        public let provisionedModelName: String
        /// The status of the Provisioned Throughput.
        public let status: ProvisionedModelStatus

        @inlinable
        public init(commitmentDuration: CommitmentDuration? = nil, commitmentExpirationTime: Date? = nil, creationTime: Date, desiredModelArn: String, desiredModelUnits: Int, foundationModelArn: String, lastModifiedTime: Date, modelArn: String, modelUnits: Int, provisionedModelArn: String, provisionedModelName: String, status: ProvisionedModelStatus) {
            self.commitmentDuration = commitmentDuration
            self.commitmentExpirationTime = commitmentExpirationTime
            self.creationTime = creationTime
            self.desiredModelArn = desiredModelArn
            self.desiredModelUnits = desiredModelUnits
            self.foundationModelArn = foundationModelArn
            self.lastModifiedTime = lastModifiedTime
            self.modelArn = modelArn
            self.modelUnits = modelUnits
            self.provisionedModelArn = provisionedModelArn
            self.provisionedModelName = provisionedModelName
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case commitmentDuration = "commitmentDuration"
            case commitmentExpirationTime = "commitmentExpirationTime"
            case creationTime = "creationTime"
            case desiredModelArn = "desiredModelArn"
            case desiredModelUnits = "desiredModelUnits"
            case foundationModelArn = "foundationModelArn"
            case lastModifiedTime = "lastModifiedTime"
            case modelArn = "modelArn"
            case modelUnits = "modelUnits"
            case provisionedModelArn = "provisionedModelArn"
            case provisionedModelName = "provisionedModelName"
            case status = "status"
        }
    }

    public struct PutModelInvocationLoggingConfigurationRequest: AWSEncodableShape {
        /// The logging configuration values to set.
        public let loggingConfig: LoggingConfig

        @inlinable
        public init(loggingConfig: LoggingConfig) {
            self.loggingConfig = loggingConfig
        }

        public func validate(name: String) throws {
            try self.loggingConfig.validate(name: "\(name).loggingConfig")
        }

        private enum CodingKeys: String, CodingKey {
            case loggingConfig = "loggingConfig"
        }
    }

    public struct PutModelInvocationLoggingConfigurationResponse: AWSDecodableShape {
        public init() {}
    }

    public struct QueryTransformationConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The type of transformation to apply to the prompt.
        public let type: QueryTransformationType

        @inlinable
        public init(type: QueryTransformationType) {
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case type = "type"
        }
    }

    public struct RegisterMarketplaceModelEndpointRequest: AWSEncodableShape {
        /// The ARN of the Amazon SageMaker endpoint you want to register with Amazon Bedrock Marketplace.
        public let endpointIdentifier: String
        /// The ARN of the model from Amazon Bedrock Marketplace that is deployed on the endpoint.
        public let modelSourceIdentifier: String

        @inlinable
        public init(endpointIdentifier: String, modelSourceIdentifier: String) {
            self.endpointIdentifier = endpointIdentifier
            self.modelSourceIdentifier = modelSourceIdentifier
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.endpointIdentifier, key: "endpointIdentifier")
            try container.encode(self.modelSourceIdentifier, forKey: .modelSourceIdentifier)
        }

        public func validate(name: String) throws {
            try self.validate(self.endpointIdentifier, name: "endpointIdentifier", parent: name, max: 2048)
            try self.validate(self.modelSourceIdentifier, name: "modelSourceIdentifier", parent: name, max: 2048)
            try self.validate(self.modelSourceIdentifier, name: "modelSourceIdentifier", parent: name, pattern: "arn:aws:sagemaker:.*:hub-content/SageMakerPublicHub/Model/.*")
        }

        private enum CodingKeys: String, CodingKey {
            case modelSourceIdentifier = "modelSourceIdentifier"
        }
    }

    public struct RegisterMarketplaceModelEndpointResponse: AWSDecodableShape {
        /// Details about the registered endpoint.
        public let marketplaceModelEndpoint: MarketplaceModelEndpoint

        @inlinable
        public init(marketplaceModelEndpoint: MarketplaceModelEndpoint) {
            self.marketplaceModelEndpoint = marketplaceModelEndpoint
        }

        private enum CodingKeys: String, CodingKey {
            case marketplaceModelEndpoint = "marketplaceModelEndpoint"
        }
    }

    public struct RequestMetadataBaseFilters: AWSEncodableShape & AWSDecodableShape {
        /// Include results where the key equals the value.
        public let equals: [String: String]?
        /// Include results where the key does not equal the value.
        public let notEquals: [String: String]?

        @inlinable
        public init(equals: [String: String]? = nil, notEquals: [String: String]? = nil) {
            self.equals = equals
            self.notEquals = notEquals
        }

        public func validate(name: String) throws {
            try self.validate(self.equals, name: "equals", parent: name, max: 1)
            try self.validate(self.equals, name: "equals", parent: name, min: 1)
            try self.validate(self.notEquals, name: "notEquals", parent: name, max: 1)
            try self.validate(self.notEquals, name: "notEquals", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case equals = "equals"
            case notEquals = "notEquals"
        }
    }

    public struct RetrieveAndGenerateConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The configuration for the external source wrapper object in the  retrieveAndGenerate function.
        public let externalSourcesConfiguration: ExternalSourcesRetrieveAndGenerateConfiguration?
        /// Contains configuration details for the knowledge base retrieval and response generation.
        public let knowledgeBaseConfiguration: KnowledgeBaseRetrieveAndGenerateConfiguration?
        /// The type of resource that contains your data for retrieving information and generating responses. If you choose to use EXTERNAL_SOURCES, then currently only Claude 3 Sonnet models for knowledge bases are supported.
        public let type: RetrieveAndGenerateType

        @inlinable
        public init(externalSourcesConfiguration: ExternalSourcesRetrieveAndGenerateConfiguration? = nil, knowledgeBaseConfiguration: KnowledgeBaseRetrieveAndGenerateConfiguration? = nil, type: RetrieveAndGenerateType) {
            self.externalSourcesConfiguration = externalSourcesConfiguration
            self.knowledgeBaseConfiguration = knowledgeBaseConfiguration
            self.type = type
        }

        public func validate(name: String) throws {
            try self.externalSourcesConfiguration?.validate(name: "\(name).externalSourcesConfiguration")
            try self.knowledgeBaseConfiguration?.validate(name: "\(name).knowledgeBaseConfiguration")
        }

        private enum CodingKeys: String, CodingKey {
            case externalSourcesConfiguration = "externalSourcesConfiguration"
            case knowledgeBaseConfiguration = "knowledgeBaseConfiguration"
            case type = "type"
        }
    }

    public struct RetrieveConfig: AWSEncodableShape & AWSDecodableShape {
        /// The unique identifier of the knowledge base.
        public let knowledgeBaseId: String
        /// Contains configuration details for knowledge base retrieval.
        public let knowledgeBaseRetrievalConfiguration: KnowledgeBaseRetrievalConfiguration

        @inlinable
        public init(knowledgeBaseId: String, knowledgeBaseRetrievalConfiguration: KnowledgeBaseRetrievalConfiguration) {
            self.knowledgeBaseId = knowledgeBaseId
            self.knowledgeBaseRetrievalConfiguration = knowledgeBaseRetrievalConfiguration
        }

        public func validate(name: String) throws {
            try self.validate(self.knowledgeBaseId, name: "knowledgeBaseId", parent: name, max: 10)
            try self.validate(self.knowledgeBaseId, name: "knowledgeBaseId", parent: name, pattern: "^[0-9a-zA-Z]+$")
            try self.knowledgeBaseRetrievalConfiguration.validate(name: "\(name).knowledgeBaseRetrievalConfiguration")
        }

        private enum CodingKeys: String, CodingKey {
            case knowledgeBaseId = "knowledgeBaseId"
            case knowledgeBaseRetrievalConfiguration = "knowledgeBaseRetrievalConfiguration"
        }
    }

    public struct RoutingCriteria: AWSDecodableShape {
        /// The criteria's response quality difference.
        public let responseQualityDifference: Double

        @inlinable
        public init(responseQualityDifference: Double) {
            self.responseQualityDifference = responseQualityDifference
        }

        private enum CodingKeys: String, CodingKey {
            case responseQualityDifference = "responseQualityDifference"
        }
    }

    public struct S3Config: AWSEncodableShape & AWSDecodableShape {
        /// S3 bucket name.
        public let bucketName: String
        /// S3 prefix.
        public let keyPrefix: String?

        @inlinable
        public init(bucketName: String, keyPrefix: String? = nil) {
            self.bucketName = bucketName
            self.keyPrefix = keyPrefix
        }

        public func validate(name: String) throws {
            try self.validate(self.bucketName, name: "bucketName", parent: name, max: 63)
            try self.validate(self.bucketName, name: "bucketName", parent: name, min: 3)
            try self.validate(self.keyPrefix, name: "keyPrefix", parent: name, max: 1024)
        }

        private enum CodingKeys: String, CodingKey {
            case bucketName = "bucketName"
            case keyPrefix = "keyPrefix"
        }
    }

    public struct S3DataSource: AWSEncodableShape & AWSDecodableShape {
        /// The URI of the Amazon S3 data source.
        public let s3Uri: String

        @inlinable
        public init(s3Uri: String) {
            self.s3Uri = s3Uri
        }

        public func validate(name: String) throws {
            try self.validate(self.s3Uri, name: "s3Uri", parent: name, max: 1024)
            try self.validate(self.s3Uri, name: "s3Uri", parent: name, min: 1)
            try self.validate(self.s3Uri, name: "s3Uri", parent: name, pattern: "^s3://[a-z0-9][-.a-z0-9]{1,61}(?:/[-!_*'().a-z0-9A-Z]+(?:/[-!_*'().a-z0-9A-Z]+)*)?/?$")
        }

        private enum CodingKeys: String, CodingKey {
            case s3Uri = "s3Uri"
        }
    }

    public struct S3ObjectDoc: AWSEncodableShape & AWSDecodableShape {
        /// The S3 URI location for the wrapper object of the document.
        public let uri: String

        @inlinable
        public init(uri: String) {
            self.uri = uri
        }

        public func validate(name: String) throws {
            try self.validate(self.uri, name: "uri", parent: name, max: 1024)
            try self.validate(self.uri, name: "uri", parent: name, min: 1)
            try self.validate(self.uri, name: "uri", parent: name, pattern: "^s3://[a-z0-9][a-z0-9.-]{1,61}[a-z0-9]/.{1,1024}$")
        }

        private enum CodingKeys: String, CodingKey {
            case uri = "uri"
        }
    }

    public struct SageMakerEndpoint: AWSEncodableShape & AWSDecodableShape {
        /// The ARN of the IAM role that Amazon SageMaker can assume to access model artifacts and docker image for deployment on Amazon EC2 compute instances or for batch transform jobs.
        public let executionRole: String
        /// The number of Amazon EC2 compute instances to deploy for initial endpoint creation.
        public let initialInstanceCount: Int
        /// The Amazon EC2 compute instance type to deploy for hosting the model.
        public let instanceType: String
        /// The Amazon Web Services KMS key that Amazon SageMaker uses to encrypt data on the storage volume attached to the Amazon EC2 compute instance that hosts the endpoint.
        public let kmsEncryptionKey: String?
        /// The VPC configuration for the endpoint.
        public let vpc: VpcConfig?

        @inlinable
        public init(executionRole: String, initialInstanceCount: Int, instanceType: String, kmsEncryptionKey: String? = nil, vpc: VpcConfig? = nil) {
            self.executionRole = executionRole
            self.initialInstanceCount = initialInstanceCount
            self.instanceType = instanceType
            self.kmsEncryptionKey = kmsEncryptionKey
            self.vpc = vpc
        }

        public func validate(name: String) throws {
            try self.validate(self.executionRole, name: "executionRole", parent: name, max: 2048)
            try self.validate(self.executionRole, name: "executionRole", parent: name, pattern: "^arn:aws(-[^:]+)?:iam::([0-9]{12})?:role/.+$")
            try self.validate(self.initialInstanceCount, name: "initialInstanceCount", parent: name, min: 1)
            try self.validate(self.instanceType, name: "instanceType", parent: name, max: 50)
            try self.validate(self.instanceType, name: "instanceType", parent: name, min: 1)
            try self.validate(self.kmsEncryptionKey, name: "kmsEncryptionKey", parent: name, max: 2048)
            try self.validate(self.kmsEncryptionKey, name: "kmsEncryptionKey", parent: name, min: 1)
            try self.validate(self.kmsEncryptionKey, name: "kmsEncryptionKey", parent: name, pattern: "^(arn:aws(-[^:]+)?:kms:[a-zA-Z0-9-]*:[0-9]{12}:((key/[a-zA-Z0-9-]{36})|(alias/[a-zA-Z0-9-_/]+)))|([a-zA-Z0-9-]{36})|(alias/[a-zA-Z0-9-_/]+)$")
            try self.vpc?.validate(name: "\(name).vpc")
        }

        private enum CodingKeys: String, CodingKey {
            case executionRole = "executionRole"
            case initialInstanceCount = "initialInstanceCount"
            case instanceType = "instanceType"
            case kmsEncryptionKey = "kmsEncryptionKey"
            case vpc = "vpc"
        }
    }

    public struct StopEvaluationJobRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the evaluation job you want to stop.
        public let jobIdentifier: String

        @inlinable
        public init(jobIdentifier: String) {
            self.jobIdentifier = jobIdentifier
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.jobIdentifier, key: "jobIdentifier")
        }

        public func validate(name: String) throws {
            try self.validate(self.jobIdentifier, name: "jobIdentifier", parent: name, max: 1011)
            try self.validate(self.jobIdentifier, name: "jobIdentifier", parent: name, pattern: "^(arn:aws(-[^:]+)?:bedrock:[a-z0-9-]{1,20}:[0-9]{12}:evaluation-job/[a-z0-9]{12})$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct StopEvaluationJobResponse: AWSDecodableShape {
        public init() {}
    }

    public struct StopModelCustomizationJobRequest: AWSEncodableShape {
        /// Job identifier of the job to stop.
        public let jobIdentifier: String

        @inlinable
        public init(jobIdentifier: String) {
            self.jobIdentifier = jobIdentifier
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.jobIdentifier, key: "jobIdentifier")
        }

        public func validate(name: String) throws {
            try self.validate(self.jobIdentifier, name: "jobIdentifier", parent: name, max: 1011)
            try self.validate(self.jobIdentifier, name: "jobIdentifier", parent: name, pattern: "^(arn:aws(-[^:]+)?:bedrock:[a-z0-9-]{1,20}:[0-9]{12}:model-customization-job/[a-z0-9-]{1,63}[.]{1}[a-z0-9-]{1,63}([a-z0-9-]{1,63}[.]){0,2}[a-z0-9-]{1,63}([:][a-z0-9-]{1,63}){0,2}/[a-z0-9]{12})|([a-zA-Z0-9](-*[a-zA-Z0-9\\+\\-\\.])*)$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct StopModelCustomizationJobResponse: AWSDecodableShape {
        public init() {}
    }

    public struct StopModelInvocationJobRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the batch inference job to stop.
        public let jobIdentifier: String

        @inlinable
        public init(jobIdentifier: String) {
            self.jobIdentifier = jobIdentifier
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.jobIdentifier, key: "jobIdentifier")
        }

        public func validate(name: String) throws {
            try self.validate(self.jobIdentifier, name: "jobIdentifier", parent: name, max: 1011)
            try self.validate(self.jobIdentifier, name: "jobIdentifier", parent: name, pattern: "^((arn:aws(-[^:]+)?:bedrock:[a-z0-9-]{1,20}:[0-9]{12}:model-invocation-job/)?[a-z0-9]{12})$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct StopModelInvocationJobResponse: AWSDecodableShape {
        public init() {}
    }

    public struct Tag: AWSEncodableShape & AWSDecodableShape {
        /// Key for the tag.
        public let key: String
        /// Value for the tag.
        public let value: String

        @inlinable
        public init(key: String, value: String) {
            self.key = key
            self.value = value
        }

        public func validate(name: String) throws {
            try self.validate(self.key, name: "key", parent: name, max: 128)
            try self.validate(self.key, name: "key", parent: name, min: 1)
            try self.validate(self.key, name: "key", parent: name, pattern: "^[a-zA-Z0-9\\s._:/=+@-]*$")
            try self.validate(self.value, name: "value", parent: name, max: 256)
            try self.validate(self.value, name: "value", parent: name, pattern: "^[a-zA-Z0-9\\s._:/=+@-]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case key = "key"
            case value = "value"
        }
    }

    public struct TagResourceRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the resource to tag.
        public let resourceARN: String
        /// Tags to associate with the resource.
        public let tags: [Tag]

        @inlinable
        public init(resourceARN: String, tags: [Tag]) {
            self.resourceARN = resourceARN
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceARN, name: "resourceARN", parent: name, max: 1011)
            try self.validate(self.resourceARN, name: "resourceARN", parent: name, min: 20)
            try self.validate(self.resourceARN, name: "resourceARN", parent: name, pattern: "(^[a-zA-Z0-9][a-zA-Z0-9\\-]*$)|(^arn:aws(-[^:]+)?:bedrock:[a-z0-9-]{1,20}:([0-9]{12}|)((:(fine-tuning-job|model-customization-job|custom-model)/[a-z0-9-]{1,63}[.]{1}[a-z0-9-]{1,63}([a-z0-9-]{1,63}[.]){0,2}[a-z0-9-]{1,63}([:][a-z0-9-]{1,63}){0,2}(/[a-z0-9]{12})$)|(:guardrail/[a-z0-9]+$)|(:(inference-profile|application-inference-profile)/[a-zA-Z0-9-:.]+$)|(:(provisioned-model|model-invocation-job|model-evaluation-job|evaluation-job|model-import-job|imported-model|async-invoke)/[a-z0-9]{12}$)))")
            try self.tags.forEach {
                try $0.validate(name: "\(name).tags[]")
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 200)
        }

        private enum CodingKeys: String, CodingKey {
            case resourceARN = "resourceARN"
            case tags = "tags"
        }
    }

    public struct TagResourceResponse: AWSDecodableShape {
        public init() {}
    }

    public struct TeacherModelConfig: AWSEncodableShape & AWSDecodableShape {
        /// The maximum number of tokens requested when the customization job invokes the teacher model.
        public let maxResponseLengthForInference: Int?
        /// The identifier of the teacher model.
        public let teacherModelIdentifier: String

        @inlinable
        public init(maxResponseLengthForInference: Int? = nil, teacherModelIdentifier: String) {
            self.maxResponseLengthForInference = maxResponseLengthForInference
            self.teacherModelIdentifier = teacherModelIdentifier
        }

        public func validate(name: String) throws {
            try self.validate(self.teacherModelIdentifier, name: "teacherModelIdentifier", parent: name, pattern: "^arn:aws(-[^:]+)?:bedrock:[a-z0-9-]{1,20}::foundation-model/[a-z0-9-]{1,63}[.]{1}([a-z0-9-]{1,63}[.]){0,2}[a-z0-9-]{1,63}([:][a-z0-9-]{1,63}){0,2}|([a-z0-9-]{1,63}[.]{1}[a-z0-9-]{1,63}([.]?[a-z0-9-]{1,63})([:][a-z0-9-]{1,63}){0,2})|(([0-9a-zA-Z][_-]?)+)$")
        }

        private enum CodingKeys: String, CodingKey {
            case maxResponseLengthForInference = "maxResponseLengthForInference"
            case teacherModelIdentifier = "teacherModelIdentifier"
        }
    }

    public struct TextInferenceConfig: AWSEncodableShape & AWSDecodableShape {
        /// The maximum number of tokens to generate in the output text. Do not use the minimum of 0  or the maximum of 65536. The limit values described here are arbitrary values, for actual  values consult the limits defined by your specific model.
        public let maxTokens: Int?
        /// A list of sequences of characters that, if generated, will cause the model to stop  generating further tokens. Do not use a minimum length of 1 or a maximum length of 1000.  The limit values described here are arbitrary values, for actual values consult the  limits defined by your specific model.
        public let stopSequences: [String]?
        /// Controls the random-ness of text generated by the language model, influencing how  much the model sticks to the most predictable next words versus exploring more  surprising options. A lower temperature value (e.g. 0.2 or 0.3) makes model outputs  more deterministic or predictable, while a higher temperature (e.g. 0.8 or 0.9) makes  the outputs more creative or unpredictable.
        public let temperature: Float?
        /// A probability distribution threshold which controls what the model considers for  the set of possible next tokens. The model will only consider the top p% of the  probability distribution when generating the next token.
        public let topP: Float?

        @inlinable
        public init(maxTokens: Int? = nil, stopSequences: [String]? = nil, temperature: Float? = nil, topP: Float? = nil) {
            self.maxTokens = maxTokens
            self.stopSequences = stopSequences
            self.temperature = temperature
            self.topP = topP
        }

        public func validate(name: String) throws {
            try self.validate(self.maxTokens, name: "maxTokens", parent: name, max: 65536)
            try self.validate(self.maxTokens, name: "maxTokens", parent: name, min: 0)
            try self.validate(self.stopSequences, name: "stopSequences", parent: name, max: 4)
            try self.validate(self.temperature, name: "temperature", parent: name, max: 1.0)
            try self.validate(self.temperature, name: "temperature", parent: name, min: 0.0)
            try self.validate(self.topP, name: "topP", parent: name, max: 1.0)
            try self.validate(self.topP, name: "topP", parent: name, min: 0.0)
        }

        private enum CodingKeys: String, CodingKey {
            case maxTokens = "maxTokens"
            case stopSequences = "stopSequences"
            case temperature = "temperature"
            case topP = "topP"
        }
    }

    public struct TrainingDataConfig: AWSEncodableShape & AWSDecodableShape {
        /// Settings for using invocation logs to customize a model.
        public let invocationLogsConfig: InvocationLogsConfig?
        /// The S3 URI where the training data is stored.
        public let s3Uri: String?

        @inlinable
        public init(invocationLogsConfig: InvocationLogsConfig? = nil, s3Uri: String? = nil) {
            self.invocationLogsConfig = invocationLogsConfig
            self.s3Uri = s3Uri
        }

        public func validate(name: String) throws {
            try self.invocationLogsConfig?.validate(name: "\(name).invocationLogsConfig")
            try self.validate(self.s3Uri, name: "s3Uri", parent: name, max: 1024)
            try self.validate(self.s3Uri, name: "s3Uri", parent: name, min: 1)
            try self.validate(self.s3Uri, name: "s3Uri", parent: name, pattern: "^s3://[a-z0-9][-.a-z0-9]{1,61}(?:/[-!_*'().a-z0-9A-Z]+(?:/[-!_*'().a-z0-9A-Z]+)*)?/?$")
        }

        private enum CodingKeys: String, CodingKey {
            case invocationLogsConfig = "invocationLogsConfig"
            case s3Uri = "s3Uri"
        }
    }

    public struct TrainingMetrics: AWSDecodableShape {
        /// Loss metric associated with the custom job.
        public let trainingLoss: Float?

        @inlinable
        public init(trainingLoss: Float? = nil) {
            self.trainingLoss = trainingLoss
        }

        private enum CodingKeys: String, CodingKey {
            case trainingLoss = "trainingLoss"
        }
    }

    public struct UntagResourceRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the resource to untag.
        public let resourceARN: String
        /// Tag keys of the tags to remove from the resource.
        public let tagKeys: [String]

        @inlinable
        public init(resourceARN: String, tagKeys: [String]) {
            self.resourceARN = resourceARN
            self.tagKeys = tagKeys
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceARN, name: "resourceARN", parent: name, max: 1011)
            try self.validate(self.resourceARN, name: "resourceARN", parent: name, min: 20)
            try self.validate(self.resourceARN, name: "resourceARN", parent: name, pattern: "(^[a-zA-Z0-9][a-zA-Z0-9\\-]*$)|(^arn:aws(-[^:]+)?:bedrock:[a-z0-9-]{1,20}:([0-9]{12}|)((:(fine-tuning-job|model-customization-job|custom-model)/[a-z0-9-]{1,63}[.]{1}[a-z0-9-]{1,63}([a-z0-9-]{1,63}[.]){0,2}[a-z0-9-]{1,63}([:][a-z0-9-]{1,63}){0,2}(/[a-z0-9]{12})$)|(:guardrail/[a-z0-9]+$)|(:(inference-profile|application-inference-profile)/[a-zA-Z0-9-:.]+$)|(:(provisioned-model|model-invocation-job|model-evaluation-job|evaluation-job|model-import-job|imported-model|async-invoke)/[a-z0-9]{12}$)))")
            try self.tagKeys.forEach {
                try validate($0, name: "tagKeys[]", parent: name, max: 128)
                try validate($0, name: "tagKeys[]", parent: name, min: 1)
                try validate($0, name: "tagKeys[]", parent: name, pattern: "^[a-zA-Z0-9\\s._:/=+@-]*$")
            }
            try self.validate(self.tagKeys, name: "tagKeys", parent: name, max: 200)
        }

        private enum CodingKeys: String, CodingKey {
            case resourceARN = "resourceARN"
            case tagKeys = "tagKeys"
        }
    }

    public struct UntagResourceResponse: AWSDecodableShape {
        public init() {}
    }

    public struct UpdateGuardrailRequest: AWSEncodableShape {
        /// The message to return when the guardrail blocks a prompt.
        public let blockedInputMessaging: String
        /// The message to return when the guardrail blocks a model response.
        public let blockedOutputsMessaging: String
        /// The content policy to configure for the guardrail.
        public let contentPolicyConfig: GuardrailContentPolicyConfig?
        /// The contextual grounding policy configuration used to update a guardrail.
        public let contextualGroundingPolicyConfig: GuardrailContextualGroundingPolicyConfig?
        /// A description of the guardrail.
        public let description: String?
        /// The unique identifier of the guardrail.  This can be an ID or the ARN.
        public let guardrailIdentifier: String
        /// The ARN of the KMS key with which to encrypt the guardrail.
        public let kmsKeyId: String?
        /// A name for the guardrail.
        public let name: String
        /// The sensitive information policy to configure for the guardrail.
        public let sensitiveInformationPolicyConfig: GuardrailSensitiveInformationPolicyConfig?
        /// The topic policy to configure for the guardrail.
        public let topicPolicyConfig: GuardrailTopicPolicyConfig?
        /// The word policy to configure for the guardrail.
        public let wordPolicyConfig: GuardrailWordPolicyConfig?

        @inlinable
        public init(blockedInputMessaging: String, blockedOutputsMessaging: String, contentPolicyConfig: GuardrailContentPolicyConfig? = nil, contextualGroundingPolicyConfig: GuardrailContextualGroundingPolicyConfig? = nil, description: String? = nil, guardrailIdentifier: String, kmsKeyId: String? = nil, name: String, sensitiveInformationPolicyConfig: GuardrailSensitiveInformationPolicyConfig? = nil, topicPolicyConfig: GuardrailTopicPolicyConfig? = nil, wordPolicyConfig: GuardrailWordPolicyConfig? = nil) {
            self.blockedInputMessaging = blockedInputMessaging
            self.blockedOutputsMessaging = blockedOutputsMessaging
            self.contentPolicyConfig = contentPolicyConfig
            self.contextualGroundingPolicyConfig = contextualGroundingPolicyConfig
            self.description = description
            self.guardrailIdentifier = guardrailIdentifier
            self.kmsKeyId = kmsKeyId
            self.name = name
            self.sensitiveInformationPolicyConfig = sensitiveInformationPolicyConfig
            self.topicPolicyConfig = topicPolicyConfig
            self.wordPolicyConfig = wordPolicyConfig
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encode(self.blockedInputMessaging, forKey: .blockedInputMessaging)
            try container.encode(self.blockedOutputsMessaging, forKey: .blockedOutputsMessaging)
            try container.encodeIfPresent(self.contentPolicyConfig, forKey: .contentPolicyConfig)
            try container.encodeIfPresent(self.contextualGroundingPolicyConfig, forKey: .contextualGroundingPolicyConfig)
            try container.encodeIfPresent(self.description, forKey: .description)
            request.encodePath(self.guardrailIdentifier, key: "guardrailIdentifier")
            try container.encodeIfPresent(self.kmsKeyId, forKey: .kmsKeyId)
            try container.encode(self.name, forKey: .name)
            try container.encodeIfPresent(self.sensitiveInformationPolicyConfig, forKey: .sensitiveInformationPolicyConfig)
            try container.encodeIfPresent(self.topicPolicyConfig, forKey: .topicPolicyConfig)
            try container.encodeIfPresent(self.wordPolicyConfig, forKey: .wordPolicyConfig)
        }

        public func validate(name: String) throws {
            try self.validate(self.blockedInputMessaging, name: "blockedInputMessaging", parent: name, max: 500)
            try self.validate(self.blockedInputMessaging, name: "blockedInputMessaging", parent: name, min: 1)
            try self.validate(self.blockedOutputsMessaging, name: "blockedOutputsMessaging", parent: name, max: 500)
            try self.validate(self.blockedOutputsMessaging, name: "blockedOutputsMessaging", parent: name, min: 1)
            try self.contentPolicyConfig?.validate(name: "\(name).contentPolicyConfig")
            try self.contextualGroundingPolicyConfig?.validate(name: "\(name).contextualGroundingPolicyConfig")
            try self.validate(self.description, name: "description", parent: name, max: 200)
            try self.validate(self.description, name: "description", parent: name, min: 1)
            try self.validate(self.guardrailIdentifier, name: "guardrailIdentifier", parent: name, max: 2048)
            try self.validate(self.guardrailIdentifier, name: "guardrailIdentifier", parent: name, pattern: "^(([a-z0-9]+)|(arn:aws(-[^:]+)?:bedrock:[a-z0-9-]{1,20}:[0-9]{12}:guardrail/[a-z0-9]+))$")
            try self.validate(self.kmsKeyId, name: "kmsKeyId", parent: name, max: 2048)
            try self.validate(self.kmsKeyId, name: "kmsKeyId", parent: name, min: 1)
            try self.validate(self.kmsKeyId, name: "kmsKeyId", parent: name, pattern: "^(arn:aws(-[^:]+)?:kms:[a-zA-Z0-9-]*:[0-9]{12}:((key/[a-zA-Z0-9-]{36})|(alias/[a-zA-Z0-9-_/]+)))|([a-zA-Z0-9-]{36})|(alias/[a-zA-Z0-9-_/]+)$")
            try self.validate(self.name, name: "name", parent: name, max: 50)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[0-9a-zA-Z-_]+$")
            try self.sensitiveInformationPolicyConfig?.validate(name: "\(name).sensitiveInformationPolicyConfig")
            try self.topicPolicyConfig?.validate(name: "\(name).topicPolicyConfig")
            try self.wordPolicyConfig?.validate(name: "\(name).wordPolicyConfig")
        }

        private enum CodingKeys: String, CodingKey {
            case blockedInputMessaging = "blockedInputMessaging"
            case blockedOutputsMessaging = "blockedOutputsMessaging"
            case contentPolicyConfig = "contentPolicyConfig"
            case contextualGroundingPolicyConfig = "contextualGroundingPolicyConfig"
            case description = "description"
            case kmsKeyId = "kmsKeyId"
            case name = "name"
            case sensitiveInformationPolicyConfig = "sensitiveInformationPolicyConfig"
            case topicPolicyConfig = "topicPolicyConfig"
            case wordPolicyConfig = "wordPolicyConfig"
        }
    }

    public struct UpdateGuardrailResponse: AWSDecodableShape {
        /// The ARN of the guardrail.
        public let guardrailArn: String
        /// The unique identifier of the guardrail
        public let guardrailId: String
        /// The date and time at which the guardrail was updated.
        @CustomCoding<ISO8601DateCoder>
        public var updatedAt: Date
        /// The version of the guardrail.
        public let version: String

        @inlinable
        public init(guardrailArn: String, guardrailId: String, updatedAt: Date, version: String) {
            self.guardrailArn = guardrailArn
            self.guardrailId = guardrailId
            self.updatedAt = updatedAt
            self.version = version
        }

        private enum CodingKeys: String, CodingKey {
            case guardrailArn = "guardrailArn"
            case guardrailId = "guardrailId"
            case updatedAt = "updatedAt"
            case version = "version"
        }
    }

    public struct UpdateMarketplaceModelEndpointRequest: AWSEncodableShape {
        /// A unique, case-sensitive identifier that you provide to ensure the idempotency of the request. This token is listed as not required because Amazon Web Services SDKs automatically generate it for you and set this parameter. If you're not using the Amazon Web Services SDK or the CLI, you must provide this token or the action will fail.
        public let clientRequestToken: String?
        /// The Amazon Resource Name (ARN) of the endpoint you want to update.
        public let endpointArn: String
        /// The new configuration for the endpoint, including the number and type of instances to use.
        public let endpointConfig: EndpointConfig

        @inlinable
        public init(clientRequestToken: String? = UpdateMarketplaceModelEndpointRequest.idempotencyToken(), endpointArn: String, endpointConfig: EndpointConfig) {
            self.clientRequestToken = clientRequestToken
            self.endpointArn = endpointArn
            self.endpointConfig = endpointConfig
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.clientRequestToken, forKey: .clientRequestToken)
            request.encodePath(self.endpointArn, key: "endpointArn")
            try container.encode(self.endpointConfig, forKey: .endpointConfig)
        }

        public func validate(name: String) throws {
            try self.validate(self.clientRequestToken, name: "clientRequestToken", parent: name, max: 256)
            try self.validate(self.clientRequestToken, name: "clientRequestToken", parent: name, min: 1)
            try self.validate(self.clientRequestToken, name: "clientRequestToken", parent: name, pattern: "^[a-zA-Z0-9](-*[a-zA-Z0-9])*$")
            try self.validate(self.endpointArn, name: "endpointArn", parent: name, max: 2048)
            try self.endpointConfig.validate(name: "\(name).endpointConfig")
        }

        private enum CodingKeys: String, CodingKey {
            case clientRequestToken = "clientRequestToken"
            case endpointConfig = "endpointConfig"
        }
    }

    public struct UpdateMarketplaceModelEndpointResponse: AWSDecodableShape {
        /// Details about the updated endpoint.
        public let marketplaceModelEndpoint: MarketplaceModelEndpoint

        @inlinable
        public init(marketplaceModelEndpoint: MarketplaceModelEndpoint) {
            self.marketplaceModelEndpoint = marketplaceModelEndpoint
        }

        private enum CodingKeys: String, CodingKey {
            case marketplaceModelEndpoint = "marketplaceModelEndpoint"
        }
    }

    public struct UpdateProvisionedModelThroughputRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the new model to associate with this Provisioned Throughput. You can't specify this field if this Provisioned Throughput is associated with a base model. If this Provisioned Throughput is associated with a custom model, you can specify one of the following options:   The base model from which the custom model was customized.   Another custom model that was customized from the same base model as the custom model.
        public let desiredModelId: String?
        /// The new name for this Provisioned Throughput.
        public let desiredProvisionedModelName: String?
        /// The Amazon Resource Name (ARN) or name of the Provisioned Throughput to update.
        public let provisionedModelId: String

        @inlinable
        public init(desiredModelId: String? = nil, desiredProvisionedModelName: String? = nil, provisionedModelId: String) {
            self.desiredModelId = desiredModelId
            self.desiredProvisionedModelName = desiredProvisionedModelName
            self.provisionedModelId = provisionedModelId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.desiredModelId, forKey: .desiredModelId)
            try container.encodeIfPresent(self.desiredProvisionedModelName, forKey: .desiredProvisionedModelName)
            request.encodePath(self.provisionedModelId, key: "provisionedModelId")
        }

        public func validate(name: String) throws {
            try self.validate(self.desiredModelId, name: "desiredModelId", parent: name, max: 2048)
            try self.validate(self.desiredModelId, name: "desiredModelId", parent: name, min: 1)
            try self.validate(self.desiredModelId, name: "desiredModelId", parent: name, pattern: "^arn:aws(-[^:]+)?:bedrock:[a-z0-9-]{1,20}:(([0-9]{12}:custom-model/[a-z0-9-]{1,63}[.]{1}[a-z0-9-]{1,63}(([:][a-z0-9-]{1,63}){0,2})?/[a-z0-9]{12})|(:foundation-model/([a-z0-9-]{1,63}[.]{1}[a-z0-9-]{1,63}([.]?[a-z0-9-]{1,63})([:][a-z0-9-]{1,63}){0,2})))|(([a-z0-9-]{1,63}[.]{1}[a-z0-9-]{1,63}([.]?[a-z0-9-]{1,63})([:][a-z0-9-]{1,63}){0,2}))|(([0-9a-zA-Z][_-]?)+)$")
            try self.validate(self.desiredProvisionedModelName, name: "desiredProvisionedModelName", parent: name, max: 63)
            try self.validate(self.desiredProvisionedModelName, name: "desiredProvisionedModelName", parent: name, min: 1)
            try self.validate(self.desiredProvisionedModelName, name: "desiredProvisionedModelName", parent: name, pattern: "^([0-9a-zA-Z][_-]?)+$")
            try self.validate(self.provisionedModelId, name: "provisionedModelId", parent: name, pattern: "^((([0-9a-zA-Z][_-]?)+)|(arn:aws(-[^:]+)?:bedrock:[a-z0-9-]{1,20}:[0-9]{12}:provisioned-model/[a-z0-9]{12}))$")
        }

        private enum CodingKeys: String, CodingKey {
            case desiredModelId = "desiredModelId"
            case desiredProvisionedModelName = "desiredProvisionedModelName"
        }
    }

    public struct UpdateProvisionedModelThroughputResponse: AWSDecodableShape {
        public init() {}
    }

    public struct ValidationDataConfig: AWSEncodableShape & AWSDecodableShape {
        /// Information about the validators.
        public let validators: [Validator]

        @inlinable
        public init(validators: [Validator]) {
            self.validators = validators
        }

        public func validate(name: String) throws {
            try self.validators.forEach {
                try $0.validate(name: "\(name).validators[]")
            }
            try self.validate(self.validators, name: "validators", parent: name, max: 10)
        }

        private enum CodingKeys: String, CodingKey {
            case validators = "validators"
        }
    }

    public struct Validator: AWSEncodableShape & AWSDecodableShape {
        /// The S3 URI where the validation data is stored.
        public let s3Uri: String

        @inlinable
        public init(s3Uri: String) {
            self.s3Uri = s3Uri
        }

        public func validate(name: String) throws {
            try self.validate(self.s3Uri, name: "s3Uri", parent: name, max: 1024)
            try self.validate(self.s3Uri, name: "s3Uri", parent: name, min: 1)
            try self.validate(self.s3Uri, name: "s3Uri", parent: name, pattern: "^s3://[a-z0-9][-.a-z0-9]{1,61}(?:/[-!_*'().a-z0-9A-Z]+(?:/[-!_*'().a-z0-9A-Z]+)*)?/?$")
        }

        private enum CodingKeys: String, CodingKey {
            case s3Uri = "s3Uri"
        }
    }

    public struct ValidatorMetric: AWSDecodableShape {
        /// The validation loss associated with this validator.
        public let validationLoss: Float?

        @inlinable
        public init(validationLoss: Float? = nil) {
            self.validationLoss = validationLoss
        }

        private enum CodingKeys: String, CodingKey {
            case validationLoss = "validationLoss"
        }
    }

    public struct VpcConfig: AWSEncodableShape & AWSDecodableShape {
        /// An array of IDs for each security group in the VPC to use.
        public let securityGroupIds: [String]
        /// An array of IDs for each subnet in the VPC to use.
        public let subnetIds: [String]

        @inlinable
        public init(securityGroupIds: [String], subnetIds: [String]) {
            self.securityGroupIds = securityGroupIds
            self.subnetIds = subnetIds
        }

        public func validate(name: String) throws {
            try self.securityGroupIds.forEach {
                try validate($0, name: "securityGroupIds[]", parent: name, max: 32)
                try validate($0, name: "securityGroupIds[]", parent: name, pattern: "^[-0-9a-zA-Z]+$")
            }
            try self.validate(self.securityGroupIds, name: "securityGroupIds", parent: name, max: 5)
            try self.validate(self.securityGroupIds, name: "securityGroupIds", parent: name, min: 1)
            try self.subnetIds.forEach {
                try validate($0, name: "subnetIds[]", parent: name, max: 32)
                try validate($0, name: "subnetIds[]", parent: name, pattern: "^[-0-9a-zA-Z]+$")
            }
            try self.validate(self.subnetIds, name: "subnetIds", parent: name, max: 16)
            try self.validate(self.subnetIds, name: "subnetIds", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case securityGroupIds = "securityGroupIds"
            case subnetIds = "subnetIds"
        }
    }

    public struct CustomizationConfig: AWSEncodableShape & AWSDecodableShape {
        /// The distillation configuration for the custom model.
        public let distillationConfig: DistillationConfig?

        @inlinable
        public init(distillationConfig: DistillationConfig? = nil) {
            self.distillationConfig = distillationConfig
        }

        public func validate(name: String) throws {
            try self.distillationConfig?.validate(name: "\(name).distillationConfig")
        }

        private enum CodingKeys: String, CodingKey {
            case distillationConfig = "distillationConfig"
        }
    }

    public struct EndpointConfig: AWSEncodableShape & AWSDecodableShape {
        /// The configuration specific to Amazon SageMaker for the endpoint.
        public let sageMaker: SageMakerEndpoint?

        @inlinable
        public init(sageMaker: SageMakerEndpoint? = nil) {
            self.sageMaker = sageMaker
        }

        public func validate(name: String) throws {
            try self.sageMaker?.validate(name: "\(name).sageMaker")
        }

        private enum CodingKeys: String, CodingKey {
            case sageMaker = "sageMaker"
        }
    }

    public struct EvaluationDatasetLocation: AWSEncodableShape & AWSDecodableShape {
        /// The S3 URI of the S3 bucket specified in the job.
        public let s3Uri: String?

        @inlinable
        public init(s3Uri: String? = nil) {
            self.s3Uri = s3Uri
        }

        public func validate(name: String) throws {
            try self.validate(self.s3Uri, name: "s3Uri", parent: name, max: 1024)
            try self.validate(self.s3Uri, name: "s3Uri", parent: name, min: 1)
            try self.validate(self.s3Uri, name: "s3Uri", parent: name, pattern: "^s3://[a-z0-9][-.a-z0-9]{1,61}(?:/[-!_*'().a-z0-9A-Z]+(?:/[-!_*'().a-z0-9A-Z]+)*)?/?$")
        }

        private enum CodingKeys: String, CodingKey {
            case s3Uri = "s3Uri"
        }
    }

    public struct EvaluationModelConfig: AWSEncodableShape & AWSDecodableShape {
        /// Defines the Amazon Bedrock model or inference profile and inference parameters you want used.
        public let bedrockModel: EvaluationBedrockModel?

        @inlinable
        public init(bedrockModel: EvaluationBedrockModel? = nil) {
            self.bedrockModel = bedrockModel
        }

        public func validate(name: String) throws {
            try self.bedrockModel?.validate(name: "\(name).bedrockModel")
        }

        private enum CodingKeys: String, CodingKey {
            case bedrockModel = "bedrockModel"
        }
    }

    public struct EvaluatorModelConfig: AWSEncodableShape & AWSDecodableShape {
        /// The evaluator model used in knowledge base evaluation job or in model evaluation job that use a model as judge. This model computes all evaluation related metrics.
        public let bedrockEvaluatorModels: [BedrockEvaluatorModel]?

        @inlinable
        public init(bedrockEvaluatorModels: [BedrockEvaluatorModel]? = nil) {
            self.bedrockEvaluatorModels = bedrockEvaluatorModels
        }

        public func validate(name: String) throws {
            try self.bedrockEvaluatorModels?.forEach {
                try $0.validate(name: "\(name).bedrockEvaluatorModels[]")
            }
            try self.validate(self.bedrockEvaluatorModels, name: "bedrockEvaluatorModels", parent: name, max: 1)
            try self.validate(self.bedrockEvaluatorModels, name: "bedrockEvaluatorModels", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case bedrockEvaluatorModels = "bedrockEvaluatorModels"
        }
    }

    public struct InferenceProfileModelSource: AWSEncodableShape {
        /// The ARN of the model or system-defined inference profile that is the source for the inference profile.
        public let copyFrom: String?

        @inlinable
        public init(copyFrom: String? = nil) {
            self.copyFrom = copyFrom
        }

        public func validate(name: String) throws {
            try self.validate(self.copyFrom, name: "copyFrom", parent: name, max: 2048)
            try self.validate(self.copyFrom, name: "copyFrom", parent: name, min: 1)
            try self.validate(self.copyFrom, name: "copyFrom", parent: name, pattern: "^arn:aws(|-us-gov|-cn|-iso|-iso-b):bedrock:(|[0-9a-z-]{0,20}):(|[0-9]{12}):(inference-profile|foundation-model)/[a-zA-Z0-9-:.]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case copyFrom = "copyFrom"
        }
    }

    public struct InvocationLogSource: AWSEncodableShape & AWSDecodableShape {
        /// The URI of an invocation log in a bucket.
        public let s3Uri: String?

        @inlinable
        public init(s3Uri: String? = nil) {
            self.s3Uri = s3Uri
        }

        public func validate(name: String) throws {
            try self.validate(self.s3Uri, name: "s3Uri", parent: name, max: 1024)
            try self.validate(self.s3Uri, name: "s3Uri", parent: name, min: 1)
            try self.validate(self.s3Uri, name: "s3Uri", parent: name, pattern: "^s3://[a-z0-9][-.a-z0-9]{1,61}(?:/[-!_*'().a-z0-9A-Z]+(?:/[-!_*'().a-z0-9A-Z]+)*)?/?$")
        }

        private enum CodingKeys: String, CodingKey {
            case s3Uri = "s3Uri"
        }
    }

    public struct ModelDataSource: AWSEncodableShape & AWSDecodableShape {
        /// The Amazon S3 data source of the imported model.
        public let s3DataSource: S3DataSource?

        @inlinable
        public init(s3DataSource: S3DataSource? = nil) {
            self.s3DataSource = s3DataSource
        }

        public func validate(name: String) throws {
            try self.s3DataSource?.validate(name: "\(name).s3DataSource")
        }

        private enum CodingKeys: String, CodingKey {
            case s3DataSource = "s3DataSource"
        }
    }

    public struct ModelInvocationJobInputDataConfig: AWSEncodableShape & AWSDecodableShape {
        /// Contains the configuration of the S3 location of the input data.
        public let s3InputDataConfig: ModelInvocationJobS3InputDataConfig?

        @inlinable
        public init(s3InputDataConfig: ModelInvocationJobS3InputDataConfig? = nil) {
            self.s3InputDataConfig = s3InputDataConfig
        }

        public func validate(name: String) throws {
            try self.s3InputDataConfig?.validate(name: "\(name).s3InputDataConfig")
        }

        private enum CodingKeys: String, CodingKey {
            case s3InputDataConfig = "s3InputDataConfig"
        }
    }

    public struct ModelInvocationJobOutputDataConfig: AWSEncodableShape & AWSDecodableShape {
        /// Contains the configuration of the S3 location of the output data.
        public let s3OutputDataConfig: ModelInvocationJobS3OutputDataConfig?

        @inlinable
        public init(s3OutputDataConfig: ModelInvocationJobS3OutputDataConfig? = nil) {
            self.s3OutputDataConfig = s3OutputDataConfig
        }

        public func validate(name: String) throws {
            try self.s3OutputDataConfig?.validate(name: "\(name).s3OutputDataConfig")
        }

        private enum CodingKeys: String, CodingKey {
            case s3OutputDataConfig = "s3OutputDataConfig"
        }
    }

    public struct RAGConfig: AWSEncodableShape & AWSDecodableShape {
        /// Contains configuration details for knowledge base retrieval and response generation.
        public let knowledgeBaseConfig: KnowledgeBaseConfig?

        @inlinable
        public init(knowledgeBaseConfig: KnowledgeBaseConfig? = nil) {
            self.knowledgeBaseConfig = knowledgeBaseConfig
        }

        public func validate(name: String) throws {
            try self.knowledgeBaseConfig?.validate(name: "\(name).knowledgeBaseConfig")
        }

        private enum CodingKeys: String, CodingKey {
            case knowledgeBaseConfig = "knowledgeBaseConfig"
        }
    }
}

// MARK: - Errors

/// Error enum for Bedrock
public struct BedrockErrorType: AWSErrorType {
    enum Code: String {
        case accessDeniedException = "AccessDeniedException"
        case conflictException = "ConflictException"
        case internalServerException = "InternalServerException"
        case resourceNotFoundException = "ResourceNotFoundException"
        case serviceQuotaExceededException = "ServiceQuotaExceededException"
        case serviceUnavailableException = "ServiceUnavailableException"
        case throttlingException = "ThrottlingException"
        case tooManyTagsException = "TooManyTagsException"
        case validationException = "ValidationException"
    }

    private let error: Code
    public let context: AWSErrorContext?

    /// initialize Bedrock
    public init?(errorCode: String, context: AWSErrorContext) {
        guard let error = Code(rawValue: errorCode) else { return nil }
        self.error = error
        self.context = context
    }

    internal init(_ error: Code) {
        self.error = error
        self.context = nil
    }

    /// return error code string
    public var errorCode: String { self.error.rawValue }

    /// The request is denied because of missing access permissions.
    public static var accessDeniedException: Self { .init(.accessDeniedException) }
    /// Error occurred because of a conflict while performing an operation.
    public static var conflictException: Self { .init(.conflictException) }
    /// An internal server error occurred. Retry your request.
    public static var internalServerException: Self { .init(.internalServerException) }
    /// The specified resource Amazon Resource Name (ARN) was not found. Check the Amazon Resource Name (ARN) and try your request again.
    public static var resourceNotFoundException: Self { .init(.resourceNotFoundException) }
    /// The number of requests exceeds the service quota. Resubmit your request later.
    public static var serviceQuotaExceededException: Self { .init(.serviceQuotaExceededException) }
    /// Returned if the service cannot complete the request.
    public static var serviceUnavailableException: Self { .init(.serviceUnavailableException) }
    /// The number of requests exceeds the limit. Resubmit your request later.
    public static var throttlingException: Self { .init(.throttlingException) }
    /// The request contains more tags than can be associated with a resource (50 tags per resource).  The maximum number of tags includes both existing tags and those included in your current request.
    public static var tooManyTagsException: Self { .init(.tooManyTagsException) }
    /// Input validation failed. Check your request parameters and retry the request.
    public static var validationException: Self { .init(.validationException) }
}

extension BedrockErrorType: Equatable {
    public static func == (lhs: BedrockErrorType, rhs: BedrockErrorType) -> Bool {
        lhs.error == rhs.error
    }
}

extension BedrockErrorType: CustomStringConvertible {
    public var description: String {
        return "\(self.error.rawValue): \(self.message ?? "")"
    }
}
