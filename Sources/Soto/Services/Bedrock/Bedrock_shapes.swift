//===----------------------------------------------------------------------===//
//
// This source file is part of the Soto for AWS open source project
//
// Copyright (c) 2017-2023 the Soto project authors
// Licensed under Apache License v2.0
//
// See LICENSE.txt for license information
// See CONTRIBUTORS.txt for the list of Soto project authors
//
// SPDX-License-Identifier: Apache-2.0
//
//===----------------------------------------------------------------------===//

// THIS FILE IS AUTOMATICALLY GENERATED by https://github.com/soto-project/soto-codegenerator.
// DO NOT EDIT.

#if os(Linux) && compiler(<5.10)
// swift-corelibs-foundation hasn't been updated with Sendable conformances
@preconcurrency import Foundation
#else
import Foundation
#endif
@_spi(SotoInternal) import SotoCore

extension Bedrock {
    // MARK: Enums

    public enum CommitmentDuration: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case oneMonth = "OneMonth"
        case sixMonths = "SixMonths"
        public var description: String { return self.rawValue }
    }

    public enum CustomizationType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case continuedPreTraining = "CONTINUED_PRE_TRAINING"
        case fineTuning = "FINE_TUNING"
        public var description: String { return self.rawValue }
    }

    public enum FineTuningJobStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case completed = "Completed"
        case failed = "Failed"
        case inProgress = "InProgress"
        case stopped = "Stopped"
        case stopping = "Stopping"
        public var description: String { return self.rawValue }
    }

    public enum FoundationModelLifecycleStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case active = "ACTIVE"
        case legacy = "LEGACY"
        public var description: String { return self.rawValue }
    }

    public enum InferenceType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case onDemand = "ON_DEMAND"
        case provisioned = "PROVISIONED"
        public var description: String { return self.rawValue }
    }

    public enum ModelCustomization: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case continuedPreTraining = "CONTINUED_PRE_TRAINING"
        case fineTuning = "FINE_TUNING"
        public var description: String { return self.rawValue }
    }

    public enum ModelCustomizationJobStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case completed = "Completed"
        case failed = "Failed"
        case inProgress = "InProgress"
        case stopped = "Stopped"
        case stopping = "Stopping"
        public var description: String { return self.rawValue }
    }

    public enum ModelModality: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case embedding = "EMBEDDING"
        case image = "IMAGE"
        case text = "TEXT"
        public var description: String { return self.rawValue }
    }

    public enum ProvisionedModelStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case creating = "Creating"
        case failed = "Failed"
        case inService = "InService"
        case updating = "Updating"
        public var description: String { return self.rawValue }
    }

    public enum SortByProvisionedModels: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case creationTime = "CreationTime"
        public var description: String { return self.rawValue }
    }

    public enum SortJobsBy: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case creationTime = "CreationTime"
        public var description: String { return self.rawValue }
    }

    public enum SortModelsBy: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case creationTime = "CreationTime"
        public var description: String { return self.rawValue }
    }

    public enum SortOrder: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case ascending = "Ascending"
        case descending = "Descending"
        public var description: String { return self.rawValue }
    }

    // MARK: Shapes

    public struct CloudWatchConfig: AWSEncodableShape & AWSDecodableShape {
        /// S3 configuration for delivering a large amount of data.
        public let largeDataDeliveryS3Config: S3Config?
        /// The log group name.
        public let logGroupName: String
        /// The role ARN.
        public let roleArn: String

        public init(largeDataDeliveryS3Config: S3Config? = nil, logGroupName: String, roleArn: String) {
            self.largeDataDeliveryS3Config = largeDataDeliveryS3Config
            self.logGroupName = logGroupName
            self.roleArn = roleArn
        }

        public func validate(name: String) throws {
            try self.largeDataDeliveryS3Config?.validate(name: "\(name).largeDataDeliveryS3Config")
            try self.validate(self.logGroupName, name: "logGroupName", parent: name, max: 512)
            try self.validate(self.logGroupName, name: "logGroupName", parent: name, min: 1)
            try self.validate(self.roleArn, name: "roleArn", parent: name, max: 2048)
            try self.validate(self.roleArn, name: "roleArn", parent: name, pattern: "^arn:aws(-[^:]+)?:iam::([0-9]{12})?:role/.+$")
        }

        private enum CodingKeys: String, CodingKey {
            case largeDataDeliveryS3Config = "largeDataDeliveryS3Config"
            case logGroupName = "logGroupName"
            case roleArn = "roleArn"
        }
    }

    public struct CreateModelCustomizationJobRequest: AWSEncodableShape {
        /// Name of the base model.
        public let baseModelIdentifier: String
        /// Unique token value that you can provide. The GetModelCustomizationJob response includes the same token value.
        public let clientRequestToken: String?
        /// The customization type.
        public let customizationType: CustomizationType?
        /// The custom model is encrypted at rest using this key.
        public let customModelKmsKeyId: String?
        /// Enter a name for the custom model.
        public let customModelName: String
        /// Assign tags to the custom model.
        public let customModelTags: [Tag]?
        /// Parameters related to tuning the model.
        public let hyperParameters: [String: String]
        /// Enter a unique name for the fine-tuning job.
        public let jobName: String
        /// Assign tags to the job.
        public let jobTags: [Tag]?
        /// S3 location for the output data.
        public let outputDataConfig: OutputDataConfig
        /// The Amazon Resource Name (ARN) of an IAM role that Amazon Bedrock can assume to perform tasks on your behalf. For example, during model training, Amazon Bedrock needs your permission to read input data from an S3 bucket, write model artifacts to an S3 bucket. To pass this role to Amazon Bedrock, the caller of this API must have the iam:PassRole permission.
        public let roleArn: String
        /// Information about the training dataset.
        public let trainingDataConfig: TrainingDataConfig
        /// Information about the validation dataset.
        public let validationDataConfig: ValidationDataConfig?
        /// VPC configuration (optional). Configuration parameters for the private Virtual Private Cloud (VPC) that contains the resources you are using for this job.
        public let vpcConfig: VpcConfig?

        public init(baseModelIdentifier: String, clientRequestToken: String? = CreateModelCustomizationJobRequest.idempotencyToken(), customizationType: CustomizationType? = nil, customModelKmsKeyId: String? = nil, customModelName: String, customModelTags: [Tag]? = nil, hyperParameters: [String: String], jobName: String, jobTags: [Tag]? = nil, outputDataConfig: OutputDataConfig, roleArn: String, trainingDataConfig: TrainingDataConfig, validationDataConfig: ValidationDataConfig? = nil, vpcConfig: VpcConfig? = nil) {
            self.baseModelIdentifier = baseModelIdentifier
            self.clientRequestToken = clientRequestToken
            self.customizationType = customizationType
            self.customModelKmsKeyId = customModelKmsKeyId
            self.customModelName = customModelName
            self.customModelTags = customModelTags
            self.hyperParameters = hyperParameters
            self.jobName = jobName
            self.jobTags = jobTags
            self.outputDataConfig = outputDataConfig
            self.roleArn = roleArn
            self.trainingDataConfig = trainingDataConfig
            self.validationDataConfig = validationDataConfig
            self.vpcConfig = vpcConfig
        }

        public func validate(name: String) throws {
            try self.validate(self.baseModelIdentifier, name: "baseModelIdentifier", parent: name, max: 2048)
            try self.validate(self.baseModelIdentifier, name: "baseModelIdentifier", parent: name, min: 1)
            try self.validate(self.baseModelIdentifier, name: "baseModelIdentifier", parent: name, pattern: "^(arn:aws(-[^:]+)?:bedrock:[a-z0-9-]{1,20}:(([0-9]{12}:custom-model/([a-z0-9-]{1,63}[.]{1}[a-z0-9-]{1,63}([.]?[a-z0-9-]{1,63})([:][a-z0-9-]{1,63}){0,2})/[a-z0-9]{12})|(:foundation-model/[a-z0-9-]{1,63}[.]{1}[a-z0-9-]{1,63}([:][a-z0-9-]{1,63}){0,2})))|([a-z0-9-]{1,63}[.]{1}[a-z0-9-]{1,63}([.]?[a-z0-9-]{1,63})([:][a-z0-9-]{1,63}){0,2})|(([0-9a-zA-Z][_-]?)+)$")
            try self.validate(self.clientRequestToken, name: "clientRequestToken", parent: name, max: 256)
            try self.validate(self.clientRequestToken, name: "clientRequestToken", parent: name, min: 1)
            try self.validate(self.clientRequestToken, name: "clientRequestToken", parent: name, pattern: "^[a-zA-Z0-9](-*[a-zA-Z0-9])*$")
            try self.validate(self.customModelKmsKeyId, name: "customModelKmsKeyId", parent: name, max: 2048)
            try self.validate(self.customModelKmsKeyId, name: "customModelKmsKeyId", parent: name, min: 1)
            try self.validate(self.customModelKmsKeyId, name: "customModelKmsKeyId", parent: name, pattern: "^arn:aws(-[^:]+)?:kms:[a-zA-Z0-9-]*:[0-9]{12}:((key/[a-zA-Z0-9-]{36})|(alias/[a-zA-Z0-9-_/]+))$")
            try self.validate(self.customModelName, name: "customModelName", parent: name, max: 63)
            try self.validate(self.customModelName, name: "customModelName", parent: name, min: 1)
            try self.validate(self.customModelName, name: "customModelName", parent: name, pattern: "^([0-9a-zA-Z][_-]?)+$")
            try self.customModelTags?.forEach {
                try $0.validate(name: "\(name).customModelTags[]")
            }
            try self.validate(self.customModelTags, name: "customModelTags", parent: name, max: 200)
            try self.validate(self.jobName, name: "jobName", parent: name, max: 63)
            try self.validate(self.jobName, name: "jobName", parent: name, min: 1)
            try self.validate(self.jobName, name: "jobName", parent: name, pattern: "^[a-zA-Z0-9](-*[a-zA-Z0-9\\+\\-\\.])*$")
            try self.jobTags?.forEach {
                try $0.validate(name: "\(name).jobTags[]")
            }
            try self.validate(self.jobTags, name: "jobTags", parent: name, max: 200)
            try self.outputDataConfig.validate(name: "\(name).outputDataConfig")
            try self.validate(self.roleArn, name: "roleArn", parent: name, max: 2048)
            try self.validate(self.roleArn, name: "roleArn", parent: name, pattern: "^arn:aws(-[^:]+)?:iam::([0-9]{12})?:role/.+$")
            try self.trainingDataConfig.validate(name: "\(name).trainingDataConfig")
            try self.validationDataConfig?.validate(name: "\(name).validationDataConfig")
            try self.vpcConfig?.validate(name: "\(name).vpcConfig")
        }

        private enum CodingKeys: String, CodingKey {
            case baseModelIdentifier = "baseModelIdentifier"
            case clientRequestToken = "clientRequestToken"
            case customizationType = "customizationType"
            case customModelKmsKeyId = "customModelKmsKeyId"
            case customModelName = "customModelName"
            case customModelTags = "customModelTags"
            case hyperParameters = "hyperParameters"
            case jobName = "jobName"
            case jobTags = "jobTags"
            case outputDataConfig = "outputDataConfig"
            case roleArn = "roleArn"
            case trainingDataConfig = "trainingDataConfig"
            case validationDataConfig = "validationDataConfig"
            case vpcConfig = "vpcConfig"
        }
    }

    public struct CreateModelCustomizationJobResponse: AWSDecodableShape {
        /// ARN of the fine tuning job
        public let jobArn: String

        public init(jobArn: String) {
            self.jobArn = jobArn
        }

        private enum CodingKeys: String, CodingKey {
            case jobArn = "jobArn"
        }
    }

    public struct CreateProvisionedModelThroughputRequest: AWSEncodableShape {
        /// Unique token value that you can provide. If this token matches a previous request, Amazon Bedrock ignores the request, but does not return an error.
        public let clientRequestToken: String?
        /// Commitment duration requested for the provisioned throughput.
        public let commitmentDuration: CommitmentDuration?
        /// Name or ARN of the model to associate with this provisioned throughput.
        public let modelId: String
        /// Number of model units to allocate.
        public let modelUnits: Int
        /// Unique name for this provisioned throughput.
        public let provisionedModelName: String
        /// Tags to associate with this provisioned throughput.
        public let tags: [Tag]?

        public init(clientRequestToken: String? = CreateProvisionedModelThroughputRequest.idempotencyToken(), commitmentDuration: CommitmentDuration? = nil, modelId: String, modelUnits: Int, provisionedModelName: String, tags: [Tag]? = nil) {
            self.clientRequestToken = clientRequestToken
            self.commitmentDuration = commitmentDuration
            self.modelId = modelId
            self.modelUnits = modelUnits
            self.provisionedModelName = provisionedModelName
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.validate(self.clientRequestToken, name: "clientRequestToken", parent: name, max: 256)
            try self.validate(self.clientRequestToken, name: "clientRequestToken", parent: name, min: 1)
            try self.validate(self.clientRequestToken, name: "clientRequestToken", parent: name, pattern: "^[a-zA-Z0-9](-*[a-zA-Z0-9])*$")
            try self.validate(self.modelId, name: "modelId", parent: name, max: 2048)
            try self.validate(self.modelId, name: "modelId", parent: name, min: 1)
            try self.validate(self.modelId, name: "modelId", parent: name, pattern: "^arn:aws(-[^:]+)?:bedrock:[a-z0-9-]{1,20}:(([0-9]{12}:custom-model/[a-z0-9-]{1,63}[.]{1}[a-z0-9-]{1,63}(([:][a-z0-9-]{1,63}){0,2})?/[a-z0-9]{12})|(:foundation-model/([a-z0-9-]{1,63}[.]{1}[a-z0-9-]{1,63}([.]?[a-z0-9-]{1,63})([:][a-z0-9-]{1,63}){0,2})))|(([a-z0-9-]{1,63}[.]{1}[a-z0-9-]{1,63}([.]?[a-z0-9-]{1,63})([:][a-z0-9-]{1,63}){0,2}))|(([0-9a-zA-Z][_-]?)+)$")
            try self.validate(self.modelUnits, name: "modelUnits", parent: name, min: 1)
            try self.validate(self.provisionedModelName, name: "provisionedModelName", parent: name, max: 63)
            try self.validate(self.provisionedModelName, name: "provisionedModelName", parent: name, min: 1)
            try self.validate(self.provisionedModelName, name: "provisionedModelName", parent: name, pattern: "^([0-9a-zA-Z][_-]?)+$")
            try self.tags?.forEach {
                try $0.validate(name: "\(name).tags[]")
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 200)
        }

        private enum CodingKeys: String, CodingKey {
            case clientRequestToken = "clientRequestToken"
            case commitmentDuration = "commitmentDuration"
            case modelId = "modelId"
            case modelUnits = "modelUnits"
            case provisionedModelName = "provisionedModelName"
            case tags = "tags"
        }
    }

    public struct CreateProvisionedModelThroughputResponse: AWSDecodableShape {
        /// The ARN for this provisioned throughput.
        public let provisionedModelArn: String

        public init(provisionedModelArn: String) {
            self.provisionedModelArn = provisionedModelArn
        }

        private enum CodingKeys: String, CodingKey {
            case provisionedModelArn = "provisionedModelArn"
        }
    }

    public struct CustomModelSummary: AWSDecodableShape {
        /// The base model ARN.
        public let baseModelArn: String
        /// The base model name.
        public let baseModelName: String
        /// Creation time of the model.
        @CustomCoding<ISO8601DateCoder>
        public var creationTime: Date
        /// Specifies whether to carry out continued pre-training of a model or whether to fine-tune it. For more information, see Custom models.
        public let customizationType: CustomizationType?
        /// The ARN of the custom model.
        public let modelArn: String
        /// The name of the custom model.
        public let modelName: String

        public init(baseModelArn: String, baseModelName: String, creationTime: Date, customizationType: CustomizationType? = nil, modelArn: String, modelName: String) {
            self.baseModelArn = baseModelArn
            self.baseModelName = baseModelName
            self.creationTime = creationTime
            self.customizationType = customizationType
            self.modelArn = modelArn
            self.modelName = modelName
        }

        private enum CodingKeys: String, CodingKey {
            case baseModelArn = "baseModelArn"
            case baseModelName = "baseModelName"
            case creationTime = "creationTime"
            case customizationType = "customizationType"
            case modelArn = "modelArn"
            case modelName = "modelName"
        }
    }

    public struct DeleteCustomModelRequest: AWSEncodableShape {
        /// Name of the model to delete.
        public let modelIdentifier: String

        public init(modelIdentifier: String) {
            self.modelIdentifier = modelIdentifier
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.modelIdentifier, key: "modelIdentifier")
        }

        public func validate(name: String) throws {
            try self.validate(self.modelIdentifier, name: "modelIdentifier", parent: name, max: 2048)
            try self.validate(self.modelIdentifier, name: "modelIdentifier", parent: name, min: 1)
            try self.validate(self.modelIdentifier, name: "modelIdentifier", parent: name, pattern: "^arn:aws(-[^:]+)?:bedrock:[a-z0-9-]{1,20}:(([0-9]{12}:custom-model/[a-z0-9-]{1,63}[.]{1}[a-z0-9-]{1,63}(([:][a-z0-9-]{1,63}){0,2})?/[a-z0-9]{12})|(:foundation-model/([a-z0-9-]{1,63}[.]{1}[a-z0-9-]{1,63}([.]?[a-z0-9-]{1,63})([:][a-z0-9-]{1,63}){0,2})))|(([a-z0-9-]{1,63}[.]{1}[a-z0-9-]{1,63}([.]?[a-z0-9-]{1,63})([:][a-z0-9-]{1,63}){0,2}))|(([0-9a-zA-Z][_-]?)+)$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteCustomModelResponse: AWSDecodableShape {
        public init() {}
    }

    public struct DeleteModelInvocationLoggingConfigurationRequest: AWSEncodableShape {
        public init() {}
    }

    public struct DeleteModelInvocationLoggingConfigurationResponse: AWSDecodableShape {
        public init() {}
    }

    public struct DeleteProvisionedModelThroughputRequest: AWSEncodableShape {
        /// The ARN or name of the provisioned throughput.
        public let provisionedModelId: String

        public init(provisionedModelId: String) {
            self.provisionedModelId = provisionedModelId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.provisionedModelId, key: "provisionedModelId")
        }

        public func validate(name: String) throws {
            try self.validate(self.provisionedModelId, name: "provisionedModelId", parent: name, pattern: "^((([0-9a-zA-Z][_-]?)+)|(arn:aws(-[^:]+)?:bedrock:[a-z0-9-]{1,20}:[0-9]{12}:provisioned-model/[a-z0-9]{12}))$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteProvisionedModelThroughputResponse: AWSDecodableShape {
        public init() {}
    }

    public struct FoundationModelDetails: AWSDecodableShape {
        /// The customization that the model supports.
        public let customizationsSupported: [ModelCustomization]?
        /// The inference types that the model supports.
        public let inferenceTypesSupported: [InferenceType]?
        /// The input modalities that the model supports.
        public let inputModalities: [ModelModality]?
        /// The model ARN.
        public let modelArn: String
        /// The model identifier.
        public let modelId: String
        /// Contains details about whether a model version is available or deprecated
        public let modelLifecycle: FoundationModelLifecycle?
        /// The model name.
        public let modelName: String?
        /// The output modalities that the model supports.
        public let outputModalities: [ModelModality]?
        /// he model's provider name.
        public let providerName: String?
        /// Indicates whether the model supports streaming.
        public let responseStreamingSupported: Bool?

        public init(customizationsSupported: [ModelCustomization]? = nil, inferenceTypesSupported: [InferenceType]? = nil, inputModalities: [ModelModality]? = nil, modelArn: String, modelId: String, modelLifecycle: FoundationModelLifecycle? = nil, modelName: String? = nil, outputModalities: [ModelModality]? = nil, providerName: String? = nil, responseStreamingSupported: Bool? = nil) {
            self.customizationsSupported = customizationsSupported
            self.inferenceTypesSupported = inferenceTypesSupported
            self.inputModalities = inputModalities
            self.modelArn = modelArn
            self.modelId = modelId
            self.modelLifecycle = modelLifecycle
            self.modelName = modelName
            self.outputModalities = outputModalities
            self.providerName = providerName
            self.responseStreamingSupported = responseStreamingSupported
        }

        private enum CodingKeys: String, CodingKey {
            case customizationsSupported = "customizationsSupported"
            case inferenceTypesSupported = "inferenceTypesSupported"
            case inputModalities = "inputModalities"
            case modelArn = "modelArn"
            case modelId = "modelId"
            case modelLifecycle = "modelLifecycle"
            case modelName = "modelName"
            case outputModalities = "outputModalities"
            case providerName = "providerName"
            case responseStreamingSupported = "responseStreamingSupported"
        }
    }

    public struct FoundationModelLifecycle: AWSDecodableShape {
        /// Specifies whether a model version is available (ACTIVE) or deprecated (LEGACY.
        public let status: FoundationModelLifecycleStatus

        public init(status: FoundationModelLifecycleStatus) {
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case status = "status"
        }
    }

    public struct FoundationModelSummary: AWSDecodableShape {
        /// Whether the model supports fine-tuning or continual pre-training.
        public let customizationsSupported: [ModelCustomization]?
        /// The inference types that the model supports.
        public let inferenceTypesSupported: [InferenceType]?
        /// The input modalities that the model supports.
        public let inputModalities: [ModelModality]?
        /// The ARN of the foundation model.
        public let modelArn: String
        /// The model Id of the foundation model.
        public let modelId: String
        /// Contains details about whether a model version is available or deprecated.
        public let modelLifecycle: FoundationModelLifecycle?
        /// The name of the model.
        public let modelName: String?
        /// The output modalities that the model supports.
        public let outputModalities: [ModelModality]?
        /// The model's provider name.
        public let providerName: String?
        /// Indicates whether the model supports streaming.
        public let responseStreamingSupported: Bool?

        public init(customizationsSupported: [ModelCustomization]? = nil, inferenceTypesSupported: [InferenceType]? = nil, inputModalities: [ModelModality]? = nil, modelArn: String, modelId: String, modelLifecycle: FoundationModelLifecycle? = nil, modelName: String? = nil, outputModalities: [ModelModality]? = nil, providerName: String? = nil, responseStreamingSupported: Bool? = nil) {
            self.customizationsSupported = customizationsSupported
            self.inferenceTypesSupported = inferenceTypesSupported
            self.inputModalities = inputModalities
            self.modelArn = modelArn
            self.modelId = modelId
            self.modelLifecycle = modelLifecycle
            self.modelName = modelName
            self.outputModalities = outputModalities
            self.providerName = providerName
            self.responseStreamingSupported = responseStreamingSupported
        }

        private enum CodingKeys: String, CodingKey {
            case customizationsSupported = "customizationsSupported"
            case inferenceTypesSupported = "inferenceTypesSupported"
            case inputModalities = "inputModalities"
            case modelArn = "modelArn"
            case modelId = "modelId"
            case modelLifecycle = "modelLifecycle"
            case modelName = "modelName"
            case outputModalities = "outputModalities"
            case providerName = "providerName"
            case responseStreamingSupported = "responseStreamingSupported"
        }
    }

    public struct GetCustomModelRequest: AWSEncodableShape {
        /// Name or ARN of the custom model.
        public let modelIdentifier: String

        public init(modelIdentifier: String) {
            self.modelIdentifier = modelIdentifier
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.modelIdentifier, key: "modelIdentifier")
        }

        public func validate(name: String) throws {
            try self.validate(self.modelIdentifier, name: "modelIdentifier", parent: name, max: 2048)
            try self.validate(self.modelIdentifier, name: "modelIdentifier", parent: name, min: 1)
            try self.validate(self.modelIdentifier, name: "modelIdentifier", parent: name, pattern: "^arn:aws(-[^:]+)?:bedrock:[a-z0-9-]{1,20}:(([0-9]{12}:custom-model/[a-z0-9-]{1,63}[.]{1}[a-z0-9-]{1,63}(([:][a-z0-9-]{1,63}){0,2})?/[a-z0-9]{12})|(:foundation-model/([a-z0-9-]{1,63}[.]{1}[a-z0-9-]{1,63}([.]?[a-z0-9-]{1,63})([:][a-z0-9-]{1,63}){0,2})))|(([a-z0-9-]{1,63}[.]{1}[a-z0-9-]{1,63}([.]?[a-z0-9-]{1,63})([:][a-z0-9-]{1,63}){0,2}))|(([0-9a-zA-Z][_-]?)+)$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetCustomModelResponse: AWSDecodableShape {
        /// ARN of the base model.
        public let baseModelArn: String
        /// Creation time of the model.
        @CustomCoding<ISO8601DateCoder>
        public var creationTime: Date
        /// The type of model customization.
        public let customizationType: CustomizationType?
        /// Hyperparameter values associated with this model.
        public let hyperParameters: [String: String]?
        /// Job ARN associated with this model.
        public let jobArn: String
        /// Job name associated with this model.
        public let jobName: String?
        /// ARN associated with this model.
        public let modelArn: String
        /// The custom model is encrypted at rest using this key.
        public let modelKmsKeyArn: String?
        /// Model name associated with this model.
        public let modelName: String
        /// Output data configuration associated with this custom model.
        public let outputDataConfig: OutputDataConfig
        /// Information about the training dataset.
        public let trainingDataConfig: TrainingDataConfig
        /// The training metrics from the job creation.
        public let trainingMetrics: TrainingMetrics?
        public let validationDataConfig: ValidationDataConfig?
        /// The validation metrics from the job creation.
        public let validationMetrics: [ValidatorMetric]?

        public init(baseModelArn: String, creationTime: Date, customizationType: CustomizationType? = nil, hyperParameters: [String: String]? = nil, jobArn: String, jobName: String? = nil, modelArn: String, modelKmsKeyArn: String? = nil, modelName: String, outputDataConfig: OutputDataConfig, trainingDataConfig: TrainingDataConfig, trainingMetrics: TrainingMetrics? = nil, validationDataConfig: ValidationDataConfig? = nil, validationMetrics: [ValidatorMetric]? = nil) {
            self.baseModelArn = baseModelArn
            self.creationTime = creationTime
            self.customizationType = customizationType
            self.hyperParameters = hyperParameters
            self.jobArn = jobArn
            self.jobName = jobName
            self.modelArn = modelArn
            self.modelKmsKeyArn = modelKmsKeyArn
            self.modelName = modelName
            self.outputDataConfig = outputDataConfig
            self.trainingDataConfig = trainingDataConfig
            self.trainingMetrics = trainingMetrics
            self.validationDataConfig = validationDataConfig
            self.validationMetrics = validationMetrics
        }

        private enum CodingKeys: String, CodingKey {
            case baseModelArn = "baseModelArn"
            case creationTime = "creationTime"
            case customizationType = "customizationType"
            case hyperParameters = "hyperParameters"
            case jobArn = "jobArn"
            case jobName = "jobName"
            case modelArn = "modelArn"
            case modelKmsKeyArn = "modelKmsKeyArn"
            case modelName = "modelName"
            case outputDataConfig = "outputDataConfig"
            case trainingDataConfig = "trainingDataConfig"
            case trainingMetrics = "trainingMetrics"
            case validationDataConfig = "validationDataConfig"
            case validationMetrics = "validationMetrics"
        }
    }

    public struct GetFoundationModelRequest: AWSEncodableShape {
        /// The model identifier.
        public let modelIdentifier: String

        public init(modelIdentifier: String) {
            self.modelIdentifier = modelIdentifier
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.modelIdentifier, key: "modelIdentifier")
        }

        public func validate(name: String) throws {
            try self.validate(self.modelIdentifier, name: "modelIdentifier", parent: name, max: 2048)
            try self.validate(self.modelIdentifier, name: "modelIdentifier", parent: name, min: 1)
            try self.validate(self.modelIdentifier, name: "modelIdentifier", parent: name, pattern: "^arn:aws(-[^:]+)?:bedrock:[a-z0-9-]{1,20}:(([0-9]{12}:custom-model/[a-z0-9-]{1,63}[.]{1}[a-z0-9-]{1,63}(([:][a-z0-9-]{1,63}){0,2})?/[a-z0-9]{12})|(:foundation-model/([a-z0-9-]{1,63}[.]{1}[a-z0-9-]{1,63}([.]?[a-z0-9-]{1,63})([:][a-z0-9-]{1,63}){0,2})))|(([a-z0-9-]{1,63}[.]{1}[a-z0-9-]{1,63}([.]?[a-z0-9-]{1,63})([:][a-z0-9-]{1,63}){0,2}))|(([0-9a-zA-Z][_-]?)+)$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetFoundationModelResponse: AWSDecodableShape {
        /// Information about the foundation model.
        public let modelDetails: FoundationModelDetails?

        public init(modelDetails: FoundationModelDetails? = nil) {
            self.modelDetails = modelDetails
        }

        private enum CodingKeys: String, CodingKey {
            case modelDetails = "modelDetails"
        }
    }

    public struct GetModelCustomizationJobRequest: AWSEncodableShape {
        /// Identifier for the customization job.
        public let jobIdentifier: String

        public init(jobIdentifier: String) {
            self.jobIdentifier = jobIdentifier
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.jobIdentifier, key: "jobIdentifier")
        }

        public func validate(name: String) throws {
            try self.validate(self.jobIdentifier, name: "jobIdentifier", parent: name, max: 1011)
            try self.validate(self.jobIdentifier, name: "jobIdentifier", parent: name, pattern: "^(arn:aws(-[^:]+)?:bedrock:[a-z0-9-]{1,20}:[0-9]{12}:model-customization-job/[a-z0-9-]{1,63}[.]{1}[a-z0-9-]{1,63}([a-z0-9-]{1,63}[.]){0,2}[a-z0-9-]{1,63}([:][a-z0-9-]{1,63}){0,2}/[a-z0-9]{12})|([a-zA-Z0-9](-*[a-zA-Z0-9\\+\\-\\.])*)$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetModelCustomizationJobResponse: AWSDecodableShape {
        /// ARN of the base model.
        public let baseModelArn: String
        /// The token that you specified in the CreateCustomizationJob request.
        public let clientRequestToken: String?
        /// Time that the resource was created.
        @CustomCoding<ISO8601DateCoder>
        public var creationTime: Date
        /// The type of model customization.
        public let customizationType: CustomizationType?
        /// Time that the resource transitioned to terminal state.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var endTime: Date?
        /// Information about why the job failed.
        public let failureMessage: String?
        /// The hyperparameter values for the job. For information about hyperparameters for specific models, see Guidelines for model customization.
        public let hyperParameters: [String: String]
        /// The ARN of the customization job.
        public let jobArn: String
        /// The name of the customization job.
        public let jobName: String
        /// Time that the resource was last modified.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var lastModifiedTime: Date?
        /// Output data configuration
        public let outputDataConfig: OutputDataConfig
        /// The ARN of the output model.
        public let outputModelArn: String?
        /// The custom model is encrypted at rest using this key.
        public let outputModelKmsKeyArn: String?
        /// The name of the output model.
        public let outputModelName: String
        /// The ARN of the IAM role.
        public let roleArn: String
        /// The status of the job. A successful job transitions from in-progress to completed when the output model is ready to use. If the job failed, the failure message contains information about why the job failed.
        public let status: ModelCustomizationJobStatus?
        public let trainingDataConfig: TrainingDataConfig
        public let trainingMetrics: TrainingMetrics?
        public let validationDataConfig: ValidationDataConfig
        /// The loss metric for each validator that you provided in the createjob request.
        public let validationMetrics: [ValidatorMetric]?
        /// VPC configuration for the custom model job.
        public let vpcConfig: VpcConfig?

        public init(baseModelArn: String, clientRequestToken: String? = nil, creationTime: Date, customizationType: CustomizationType? = nil, endTime: Date? = nil, failureMessage: String? = nil, hyperParameters: [String: String], jobArn: String, jobName: String, lastModifiedTime: Date? = nil, outputDataConfig: OutputDataConfig, outputModelArn: String? = nil, outputModelKmsKeyArn: String? = nil, outputModelName: String, roleArn: String, status: ModelCustomizationJobStatus? = nil, trainingDataConfig: TrainingDataConfig, trainingMetrics: TrainingMetrics? = nil, validationDataConfig: ValidationDataConfig, validationMetrics: [ValidatorMetric]? = nil, vpcConfig: VpcConfig? = nil) {
            self.baseModelArn = baseModelArn
            self.clientRequestToken = clientRequestToken
            self.creationTime = creationTime
            self.customizationType = customizationType
            self.endTime = endTime
            self.failureMessage = failureMessage
            self.hyperParameters = hyperParameters
            self.jobArn = jobArn
            self.jobName = jobName
            self.lastModifiedTime = lastModifiedTime
            self.outputDataConfig = outputDataConfig
            self.outputModelArn = outputModelArn
            self.outputModelKmsKeyArn = outputModelKmsKeyArn
            self.outputModelName = outputModelName
            self.roleArn = roleArn
            self.status = status
            self.trainingDataConfig = trainingDataConfig
            self.trainingMetrics = trainingMetrics
            self.validationDataConfig = validationDataConfig
            self.validationMetrics = validationMetrics
            self.vpcConfig = vpcConfig
        }

        private enum CodingKeys: String, CodingKey {
            case baseModelArn = "baseModelArn"
            case clientRequestToken = "clientRequestToken"
            case creationTime = "creationTime"
            case customizationType = "customizationType"
            case endTime = "endTime"
            case failureMessage = "failureMessage"
            case hyperParameters = "hyperParameters"
            case jobArn = "jobArn"
            case jobName = "jobName"
            case lastModifiedTime = "lastModifiedTime"
            case outputDataConfig = "outputDataConfig"
            case outputModelArn = "outputModelArn"
            case outputModelKmsKeyArn = "outputModelKmsKeyArn"
            case outputModelName = "outputModelName"
            case roleArn = "roleArn"
            case status = "status"
            case trainingDataConfig = "trainingDataConfig"
            case trainingMetrics = "trainingMetrics"
            case validationDataConfig = "validationDataConfig"
            case validationMetrics = "validationMetrics"
            case vpcConfig = "vpcConfig"
        }
    }

    public struct GetModelInvocationLoggingConfigurationRequest: AWSEncodableShape {
        public init() {}
    }

    public struct GetModelInvocationLoggingConfigurationResponse: AWSDecodableShape {
        /// The current configuration values.
        public let loggingConfig: LoggingConfig?

        public init(loggingConfig: LoggingConfig? = nil) {
            self.loggingConfig = loggingConfig
        }

        private enum CodingKeys: String, CodingKey {
            case loggingConfig = "loggingConfig"
        }
    }

    public struct GetProvisionedModelThroughputRequest: AWSEncodableShape {
        /// The ARN or name of the provisioned throughput.
        public let provisionedModelId: String

        public init(provisionedModelId: String) {
            self.provisionedModelId = provisionedModelId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.provisionedModelId, key: "provisionedModelId")
        }

        public func validate(name: String) throws {
            try self.validate(self.provisionedModelId, name: "provisionedModelId", parent: name, pattern: "^((([0-9a-zA-Z][_-]?)+)|(arn:aws(-[^:]+)?:bedrock:[a-z0-9-]{1,20}:[0-9]{12}:provisioned-model/[a-z0-9]{12}))$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetProvisionedModelThroughputResponse: AWSDecodableShape {
        /// Commitment duration of the provisioned throughput.
        public let commitmentDuration: CommitmentDuration?
        /// Commitment expiration time for the provisioned throughput.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var commitmentExpirationTime: Date?
        /// The timestamp of the creation time for this provisioned throughput.
        @CustomCoding<ISO8601DateCoder>
        public var creationTime: Date
        /// The ARN of the new model to asssociate with this provisioned throughput.
        public let desiredModelArn: String
        /// The desired number of model units that was requested to be available for this provisioned throughput.
        public let desiredModelUnits: Int
        /// Failure message for any issues that the create operation encounters.
        public let failureMessage: String?
        /// ARN of the foundation model.
        public let foundationModelArn: String
        /// The timestamp of the last modified time of this provisioned throughput.
        @CustomCoding<ISO8601DateCoder>
        public var lastModifiedTime: Date
        /// The ARN or name of the model associated with this provisioned throughput.
        public let modelArn: String
        /// The current number of model units requested to be available for this provisioned throughput.
        public let modelUnits: Int
        /// The ARN of the provisioned throughput.
        public let provisionedModelArn: String
        /// The name of the provisioned throughput.
        public let provisionedModelName: String
        /// Status of the provisioned throughput.
        public let status: ProvisionedModelStatus

        public init(commitmentDuration: CommitmentDuration? = nil, commitmentExpirationTime: Date? = nil, creationTime: Date, desiredModelArn: String, desiredModelUnits: Int, failureMessage: String? = nil, foundationModelArn: String, lastModifiedTime: Date, modelArn: String, modelUnits: Int, provisionedModelArn: String, provisionedModelName: String, status: ProvisionedModelStatus) {
            self.commitmentDuration = commitmentDuration
            self.commitmentExpirationTime = commitmentExpirationTime
            self.creationTime = creationTime
            self.desiredModelArn = desiredModelArn
            self.desiredModelUnits = desiredModelUnits
            self.failureMessage = failureMessage
            self.foundationModelArn = foundationModelArn
            self.lastModifiedTime = lastModifiedTime
            self.modelArn = modelArn
            self.modelUnits = modelUnits
            self.provisionedModelArn = provisionedModelArn
            self.provisionedModelName = provisionedModelName
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case commitmentDuration = "commitmentDuration"
            case commitmentExpirationTime = "commitmentExpirationTime"
            case creationTime = "creationTime"
            case desiredModelArn = "desiredModelArn"
            case desiredModelUnits = "desiredModelUnits"
            case failureMessage = "failureMessage"
            case foundationModelArn = "foundationModelArn"
            case lastModifiedTime = "lastModifiedTime"
            case modelArn = "modelArn"
            case modelUnits = "modelUnits"
            case provisionedModelArn = "provisionedModelArn"
            case provisionedModelName = "provisionedModelName"
            case status = "status"
        }
    }

    public struct ListCustomModelsRequest: AWSEncodableShape {
        /// Return custom models only if the base model ARN matches this parameter.
        public let baseModelArnEquals: String?
        /// Return custom models created after the specified time.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var creationTimeAfter: Date?
        /// Return custom models created before the specified time.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var creationTimeBefore: Date?
        /// Return custom models only if the foundation model ARN matches this parameter.
        public let foundationModelArnEquals: String?
        /// Maximum number of results to return in the response.
        public let maxResults: Int?
        /// Return custom models only if the job name contains these characters.
        public let nameContains: String?
        /// Continuation token from the previous response, for Amazon Bedrock to list the next set of results.
        public let nextToken: String?
        /// The field to sort by in the returned list of models.
        public let sortBy: SortModelsBy?
        /// The sort order of the results.
        public let sortOrder: SortOrder?

        public init(baseModelArnEquals: String? = nil, creationTimeAfter: Date? = nil, creationTimeBefore: Date? = nil, foundationModelArnEquals: String? = nil, maxResults: Int? = nil, nameContains: String? = nil, nextToken: String? = nil, sortBy: SortModelsBy? = nil, sortOrder: SortOrder? = nil) {
            self.baseModelArnEquals = baseModelArnEquals
            self.creationTimeAfter = creationTimeAfter
            self.creationTimeBefore = creationTimeBefore
            self.foundationModelArnEquals = foundationModelArnEquals
            self.maxResults = maxResults
            self.nameContains = nameContains
            self.nextToken = nextToken
            self.sortBy = sortBy
            self.sortOrder = sortOrder
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.baseModelArnEquals, key: "baseModelArnEquals")
            request.encodeQuery(self._creationTimeAfter, key: "creationTimeAfter")
            request.encodeQuery(self._creationTimeBefore, key: "creationTimeBefore")
            request.encodeQuery(self.foundationModelArnEquals, key: "foundationModelArnEquals")
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nameContains, key: "nameContains")
            request.encodeQuery(self.nextToken, key: "nextToken")
            request.encodeQuery(self.sortBy, key: "sortBy")
            request.encodeQuery(self.sortOrder, key: "sortOrder")
        }

        public func validate(name: String) throws {
            try self.validate(self.baseModelArnEquals, name: "baseModelArnEquals", parent: name, max: 1011)
            try self.validate(self.baseModelArnEquals, name: "baseModelArnEquals", parent: name, min: 20)
            try self.validate(self.baseModelArnEquals, name: "baseModelArnEquals", parent: name, pattern: "^arn:aws(-[^:]+)?:bedrock:[a-z0-9-]{1,20}:(([0-9]{12}:custom-model/[a-z0-9-]{1,63}[.]{1}[a-z0-9-]{1,63}/[a-z0-9]{12})|(:foundation-model/[a-z0-9-]{1,63}[.]{1}([a-z0-9-]{1,63}[.]){0,2}[a-z0-9-]{1,63}([:][a-z0-9-]{1,63}){0,2}))$")
            try self.validate(self.foundationModelArnEquals, name: "foundationModelArnEquals", parent: name, pattern: "^arn:aws(-[^:]+)?:bedrock:[a-z0-9-]{1,20}::foundation-model/[a-z0-9-]{1,63}[.]{1}([a-z0-9-]{1,63}[.]){0,2}[a-z0-9-]{1,63}([:][a-z0-9-]{1,63}){0,2}$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 1000)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nameContains, name: "nameContains", parent: name, max: 63)
            try self.validate(self.nameContains, name: "nameContains", parent: name, min: 1)
            try self.validate(self.nameContains, name: "nameContains", parent: name, pattern: "^([0-9a-zA-Z][_-]?)+$")
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 2048)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^\\S*$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListCustomModelsResponse: AWSDecodableShape {
        /// Model summaries.
        public let modelSummaries: [CustomModelSummary]?
        /// Continuation token for the next request to list the next set of results.
        public let nextToken: String?

        public init(modelSummaries: [CustomModelSummary]? = nil, nextToken: String? = nil) {
            self.modelSummaries = modelSummaries
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case modelSummaries = "modelSummaries"
            case nextToken = "nextToken"
        }
    }

    public struct ListFoundationModelsRequest: AWSEncodableShape {
        /// List by customization type.
        public let byCustomizationType: ModelCustomization?
        /// List by inference type.
        public let byInferenceType: InferenceType?
        /// List by output modality type.
        public let byOutputModality: ModelModality?
        /// A Amazon Bedrock model provider.
        public let byProvider: String?

        public init(byCustomizationType: ModelCustomization? = nil, byInferenceType: InferenceType? = nil, byOutputModality: ModelModality? = nil, byProvider: String? = nil) {
            self.byCustomizationType = byCustomizationType
            self.byInferenceType = byInferenceType
            self.byOutputModality = byOutputModality
            self.byProvider = byProvider
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.byCustomizationType, key: "byCustomizationType")
            request.encodeQuery(self.byInferenceType, key: "byInferenceType")
            request.encodeQuery(self.byOutputModality, key: "byOutputModality")
            request.encodeQuery(self.byProvider, key: "byProvider")
        }

        public func validate(name: String) throws {
            try self.validate(self.byProvider, name: "byProvider", parent: name, pattern: "^[A-Za-z0-9- ]{1,63}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListFoundationModelsResponse: AWSDecodableShape {
        /// A list of Amazon Bedrock foundation models.
        public let modelSummaries: [FoundationModelSummary]?

        public init(modelSummaries: [FoundationModelSummary]? = nil) {
            self.modelSummaries = modelSummaries
        }

        private enum CodingKeys: String, CodingKey {
            case modelSummaries = "modelSummaries"
        }
    }

    public struct ListModelCustomizationJobsRequest: AWSEncodableShape {
        /// Return customization jobs created after the specified time.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var creationTimeAfter: Date?
        /// Return customization jobs created before the specified time.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var creationTimeBefore: Date?
        /// Maximum number of results to return in the response.
        public let maxResults: Int?
        /// Return customization jobs only if the job name contains these characters.
        public let nameContains: String?
        /// Continuation token from the previous response, for Amazon Bedrock to list the next set of results.
        public let nextToken: String?
        /// The field to sort by in the returned list of jobs.
        public let sortBy: SortJobsBy?
        /// The sort order of the results.
        public let sortOrder: SortOrder?
        /// Return customization jobs with the specified status.
        public let statusEquals: FineTuningJobStatus?

        public init(creationTimeAfter: Date? = nil, creationTimeBefore: Date? = nil, maxResults: Int? = nil, nameContains: String? = nil, nextToken: String? = nil, sortBy: SortJobsBy? = nil, sortOrder: SortOrder? = nil, statusEquals: FineTuningJobStatus? = nil) {
            self.creationTimeAfter = creationTimeAfter
            self.creationTimeBefore = creationTimeBefore
            self.maxResults = maxResults
            self.nameContains = nameContains
            self.nextToken = nextToken
            self.sortBy = sortBy
            self.sortOrder = sortOrder
            self.statusEquals = statusEquals
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self._creationTimeAfter, key: "creationTimeAfter")
            request.encodeQuery(self._creationTimeBefore, key: "creationTimeBefore")
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nameContains, key: "nameContains")
            request.encodeQuery(self.nextToken, key: "nextToken")
            request.encodeQuery(self.sortBy, key: "sortBy")
            request.encodeQuery(self.sortOrder, key: "sortOrder")
            request.encodeQuery(self.statusEquals, key: "statusEquals")
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 1000)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nameContains, name: "nameContains", parent: name, max: 63)
            try self.validate(self.nameContains, name: "nameContains", parent: name, min: 1)
            try self.validate(self.nameContains, name: "nameContains", parent: name, pattern: "^[a-zA-Z0-9](-*[a-zA-Z0-9\\+\\-\\.])*$")
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 2048)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^\\S*$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListModelCustomizationJobsResponse: AWSDecodableShape {
        /// Job summaries.
        public let modelCustomizationJobSummaries: [ModelCustomizationJobSummary]?
        /// Page continuation token to use in the next request.
        public let nextToken: String?

        public init(modelCustomizationJobSummaries: [ModelCustomizationJobSummary]? = nil, nextToken: String? = nil) {
            self.modelCustomizationJobSummaries = modelCustomizationJobSummaries
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case modelCustomizationJobSummaries = "modelCustomizationJobSummaries"
            case nextToken = "nextToken"
        }
    }

    public struct ListProvisionedModelThroughputsRequest: AWSEncodableShape {
        /// Return provisioned capacities created after the specified time.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var creationTimeAfter: Date?
        /// Return provisioned capacities created before the specified time.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var creationTimeBefore: Date?
        /// THe maximum number of results to return in the response.
        public let maxResults: Int?
        /// Return the list of provisioned capacities where their model ARN is equal to this parameter.
        public let modelArnEquals: String?
        /// Return the list of provisioned capacities if their name contains these characters.
        public let nameContains: String?
        /// Continuation token from the previous response, for Amazon Bedrock to list the next set of results.
        public let nextToken: String?
        /// The field to sort by in the returned list of provisioned capacities.
        public let sortBy: SortByProvisionedModels?
        /// The sort order of the results.
        public let sortOrder: SortOrder?
        /// Return the list of provisioned capacities that match the specified status.
        public let statusEquals: ProvisionedModelStatus?

        public init(creationTimeAfter: Date? = nil, creationTimeBefore: Date? = nil, maxResults: Int? = nil, modelArnEquals: String? = nil, nameContains: String? = nil, nextToken: String? = nil, sortBy: SortByProvisionedModels? = nil, sortOrder: SortOrder? = nil, statusEquals: ProvisionedModelStatus? = nil) {
            self.creationTimeAfter = creationTimeAfter
            self.creationTimeBefore = creationTimeBefore
            self.maxResults = maxResults
            self.modelArnEquals = modelArnEquals
            self.nameContains = nameContains
            self.nextToken = nextToken
            self.sortBy = sortBy
            self.sortOrder = sortOrder
            self.statusEquals = statusEquals
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self._creationTimeAfter, key: "creationTimeAfter")
            request.encodeQuery(self._creationTimeBefore, key: "creationTimeBefore")
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.modelArnEquals, key: "modelArnEquals")
            request.encodeQuery(self.nameContains, key: "nameContains")
            request.encodeQuery(self.nextToken, key: "nextToken")
            request.encodeQuery(self.sortBy, key: "sortBy")
            request.encodeQuery(self.sortOrder, key: "sortOrder")
            request.encodeQuery(self.statusEquals, key: "statusEquals")
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 1000)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.modelArnEquals, name: "modelArnEquals", parent: name, max: 1011)
            try self.validate(self.modelArnEquals, name: "modelArnEquals", parent: name, min: 20)
            try self.validate(self.modelArnEquals, name: "modelArnEquals", parent: name, pattern: "^arn:aws(-[^:]+)?:bedrock:[a-z0-9-]{1,20}:(([0-9]{12}:custom-model/[a-z0-9-]{1,63}[.]{1}[a-z0-9-]{1,63}/[a-z0-9]{12})|(:foundation-model/[a-z0-9-]{1,63}[.]{1}([a-z0-9-]{1,63}[.]){0,2}[a-z0-9-]{1,63}([:][a-z0-9-]{1,63}){0,2}))$")
            try self.validate(self.nameContains, name: "nameContains", parent: name, max: 63)
            try self.validate(self.nameContains, name: "nameContains", parent: name, min: 1)
            try self.validate(self.nameContains, name: "nameContains", parent: name, pattern: "^([0-9a-zA-Z][_-]?)+$")
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 2048)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^\\S*$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListProvisionedModelThroughputsResponse: AWSDecodableShape {
        /// Continuation token for the next request to list the next set of results.
        public let nextToken: String?
        /// List of summaries, one for each provisioned throughput in the response.
        public let provisionedModelSummaries: [ProvisionedModelSummary]?

        public init(nextToken: String? = nil, provisionedModelSummaries: [ProvisionedModelSummary]? = nil) {
            self.nextToken = nextToken
            self.provisionedModelSummaries = provisionedModelSummaries
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "nextToken"
            case provisionedModelSummaries = "provisionedModelSummaries"
        }
    }

    public struct ListTagsForResourceRequest: AWSEncodableShape {
        /// The ARN of the resource.
        public let resourceARN: String

        public init(resourceARN: String) {
            self.resourceARN = resourceARN
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceARN, name: "resourceARN", parent: name, max: 1011)
            try self.validate(self.resourceARN, name: "resourceARN", parent: name, min: 20)
            try self.validate(self.resourceARN, name: "resourceARN", parent: name, pattern: "(^[a-zA-Z0-9][a-zA-Z0-9\\-]*$)|(^arn:aws(-[^:]+)?:bedrock:[a-z0-9-]{1,20}:([0-9]{12}|)((:(fine-tuning-job|model-customization-job|custom-model)/[a-z0-9-]{1,63}[.]{1}[a-z0-9-]{1,63}([a-z0-9-]{1,63}[.]){0,2}[a-z0-9-]{1,63}([:][a-z0-9-]{1,63}){0,2}(/[a-z0-9]{12})$)|(:provisioned-model/[a-z0-9]{12}$)))")
        }

        private enum CodingKeys: String, CodingKey {
            case resourceARN = "resourceARN"
        }
    }

    public struct ListTagsForResourceResponse: AWSDecodableShape {
        /// An array of the tags associated with this resource.
        public let tags: [Tag]?

        public init(tags: [Tag]? = nil) {
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case tags = "tags"
        }
    }

    public struct LoggingConfig: AWSEncodableShape & AWSDecodableShape {
        /// CloudWatch logging configuration.
        public let cloudWatchConfig: CloudWatchConfig?
        /// Set to include embeddings data in the log delivery.
        public let embeddingDataDeliveryEnabled: Bool?
        /// Set to include image data in the log delivery.
        public let imageDataDeliveryEnabled: Bool?
        /// S3 configuration for storing log data.
        public let s3Config: S3Config?
        /// Set to include text data in the log delivery.
        public let textDataDeliveryEnabled: Bool?

        public init(cloudWatchConfig: CloudWatchConfig? = nil, embeddingDataDeliveryEnabled: Bool? = nil, imageDataDeliveryEnabled: Bool? = nil, s3Config: S3Config? = nil, textDataDeliveryEnabled: Bool? = nil) {
            self.cloudWatchConfig = cloudWatchConfig
            self.embeddingDataDeliveryEnabled = embeddingDataDeliveryEnabled
            self.imageDataDeliveryEnabled = imageDataDeliveryEnabled
            self.s3Config = s3Config
            self.textDataDeliveryEnabled = textDataDeliveryEnabled
        }

        public func validate(name: String) throws {
            try self.cloudWatchConfig?.validate(name: "\(name).cloudWatchConfig")
            try self.s3Config?.validate(name: "\(name).s3Config")
        }

        private enum CodingKeys: String, CodingKey {
            case cloudWatchConfig = "cloudWatchConfig"
            case embeddingDataDeliveryEnabled = "embeddingDataDeliveryEnabled"
            case imageDataDeliveryEnabled = "imageDataDeliveryEnabled"
            case s3Config = "s3Config"
            case textDataDeliveryEnabled = "textDataDeliveryEnabled"
        }
    }

    public struct ModelCustomizationJobSummary: AWSDecodableShape {
        /// ARN of the base model.
        public let baseModelArn: String
        /// Creation time of the custom model.
        @CustomCoding<ISO8601DateCoder>
        public var creationTime: Date
        /// Specifies whether to carry out continued pre-training of a model or whether to fine-tune it. For more information, see Custom models.
        public let customizationType: CustomizationType?
        /// ARN of the custom model.
        public let customModelArn: String?
        /// Name of the custom model.
        public let customModelName: String?
        /// Time that the customization job ended.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var endTime: Date?
        /// ARN of the customization job.
        public let jobArn: String
        /// Name of the customization job.
        public let jobName: String
        /// Time that the customization job was last modified.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var lastModifiedTime: Date?
        /// Status of the customization job.
        public let status: ModelCustomizationJobStatus

        public init(baseModelArn: String, creationTime: Date, customizationType: CustomizationType? = nil, customModelArn: String? = nil, customModelName: String? = nil, endTime: Date? = nil, jobArn: String, jobName: String, lastModifiedTime: Date? = nil, status: ModelCustomizationJobStatus) {
            self.baseModelArn = baseModelArn
            self.creationTime = creationTime
            self.customizationType = customizationType
            self.customModelArn = customModelArn
            self.customModelName = customModelName
            self.endTime = endTime
            self.jobArn = jobArn
            self.jobName = jobName
            self.lastModifiedTime = lastModifiedTime
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case baseModelArn = "baseModelArn"
            case creationTime = "creationTime"
            case customizationType = "customizationType"
            case customModelArn = "customModelArn"
            case customModelName = "customModelName"
            case endTime = "endTime"
            case jobArn = "jobArn"
            case jobName = "jobName"
            case lastModifiedTime = "lastModifiedTime"
            case status = "status"
        }
    }

    public struct OutputDataConfig: AWSEncodableShape & AWSDecodableShape {
        /// The S3 URI where the output data is stored.
        public let s3Uri: String

        public init(s3Uri: String) {
            self.s3Uri = s3Uri
        }

        public func validate(name: String) throws {
            try self.validate(self.s3Uri, name: "s3Uri", parent: name, max: 1024)
            try self.validate(self.s3Uri, name: "s3Uri", parent: name, min: 1)
            try self.validate(self.s3Uri, name: "s3Uri", parent: name, pattern: "^s3://[a-z0-9][\\.\\-a-z0-9]{1,61}[a-z0-9](/.*)?$")
        }

        private enum CodingKeys: String, CodingKey {
            case s3Uri = "s3Uri"
        }
    }

    public struct ProvisionedModelSummary: AWSDecodableShape {
        /// Commitment duration for the provisioned throughput.
        public let commitmentDuration: CommitmentDuration?
        /// Commitment expiration time for the provisioned throughput.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var commitmentExpirationTime: Date?
        /// The time that this provisioned throughput was created.
        @CustomCoding<ISO8601DateCoder>
        public var creationTime: Date
        /// Desired model ARN.
        public let desiredModelArn: String
        /// Desired model units.
        public let desiredModelUnits: Int
        /// Foundation model ARN.
        public let foundationModelArn: String
        /// The time that this provisioned throughput was last modified.
        @CustomCoding<ISO8601DateCoder>
        public var lastModifiedTime: Date
        /// The ARN of the model associated with this provisioned throughput.
        public let modelArn: String
        /// The number of model units allocated.
        public let modelUnits: Int
        /// The ARN of the provisioned throughput.
        public let provisionedModelArn: String
        /// The name of the provisioned throughput.
        public let provisionedModelName: String
        /// Status of the provisioned throughput.
        public let status: ProvisionedModelStatus

        public init(commitmentDuration: CommitmentDuration? = nil, commitmentExpirationTime: Date? = nil, creationTime: Date, desiredModelArn: String, desiredModelUnits: Int, foundationModelArn: String, lastModifiedTime: Date, modelArn: String, modelUnits: Int, provisionedModelArn: String, provisionedModelName: String, status: ProvisionedModelStatus) {
            self.commitmentDuration = commitmentDuration
            self.commitmentExpirationTime = commitmentExpirationTime
            self.creationTime = creationTime
            self.desiredModelArn = desiredModelArn
            self.desiredModelUnits = desiredModelUnits
            self.foundationModelArn = foundationModelArn
            self.lastModifiedTime = lastModifiedTime
            self.modelArn = modelArn
            self.modelUnits = modelUnits
            self.provisionedModelArn = provisionedModelArn
            self.provisionedModelName = provisionedModelName
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case commitmentDuration = "commitmentDuration"
            case commitmentExpirationTime = "commitmentExpirationTime"
            case creationTime = "creationTime"
            case desiredModelArn = "desiredModelArn"
            case desiredModelUnits = "desiredModelUnits"
            case foundationModelArn = "foundationModelArn"
            case lastModifiedTime = "lastModifiedTime"
            case modelArn = "modelArn"
            case modelUnits = "modelUnits"
            case provisionedModelArn = "provisionedModelArn"
            case provisionedModelName = "provisionedModelName"
            case status = "status"
        }
    }

    public struct PutModelInvocationLoggingConfigurationRequest: AWSEncodableShape {
        /// The logging configuration values to set.
        public let loggingConfig: LoggingConfig

        public init(loggingConfig: LoggingConfig) {
            self.loggingConfig = loggingConfig
        }

        public func validate(name: String) throws {
            try self.loggingConfig.validate(name: "\(name).loggingConfig")
        }

        private enum CodingKeys: String, CodingKey {
            case loggingConfig = "loggingConfig"
        }
    }

    public struct PutModelInvocationLoggingConfigurationResponse: AWSDecodableShape {
        public init() {}
    }

    public struct S3Config: AWSEncodableShape & AWSDecodableShape {
        /// S3 bucket name.
        public let bucketName: String
        /// S3 prefix.
        public let keyPrefix: String?

        public init(bucketName: String, keyPrefix: String? = nil) {
            self.bucketName = bucketName
            self.keyPrefix = keyPrefix
        }

        public func validate(name: String) throws {
            try self.validate(self.bucketName, name: "bucketName", parent: name, max: 63)
            try self.validate(self.bucketName, name: "bucketName", parent: name, min: 3)
            try self.validate(self.keyPrefix, name: "keyPrefix", parent: name, max: 1024)
        }

        private enum CodingKeys: String, CodingKey {
            case bucketName = "bucketName"
            case keyPrefix = "keyPrefix"
        }
    }

    public struct StopModelCustomizationJobRequest: AWSEncodableShape {
        /// Job identifier of the job to stop.
        public let jobIdentifier: String

        public init(jobIdentifier: String) {
            self.jobIdentifier = jobIdentifier
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.jobIdentifier, key: "jobIdentifier")
        }

        public func validate(name: String) throws {
            try self.validate(self.jobIdentifier, name: "jobIdentifier", parent: name, max: 1011)
            try self.validate(self.jobIdentifier, name: "jobIdentifier", parent: name, pattern: "^(arn:aws(-[^:]+)?:bedrock:[a-z0-9-]{1,20}:[0-9]{12}:model-customization-job/[a-z0-9-]{1,63}[.]{1}[a-z0-9-]{1,63}([a-z0-9-]{1,63}[.]){0,2}[a-z0-9-]{1,63}([:][a-z0-9-]{1,63}){0,2}/[a-z0-9]{12})|([a-zA-Z0-9](-*[a-zA-Z0-9\\+\\-\\.])*)$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct StopModelCustomizationJobResponse: AWSDecodableShape {
        public init() {}
    }

    public struct Tag: AWSEncodableShape & AWSDecodableShape {
        /// Key for the tag.
        public let key: String
        /// Value for the tag.
        public let value: String

        public init(key: String, value: String) {
            self.key = key
            self.value = value
        }

        public func validate(name: String) throws {
            try self.validate(self.key, name: "key", parent: name, max: 128)
            try self.validate(self.key, name: "key", parent: name, min: 1)
            try self.validate(self.key, name: "key", parent: name, pattern: "^[a-zA-Z0-9\\s._:/=+@-]*$")
            try self.validate(self.value, name: "value", parent: name, max: 256)
            try self.validate(self.value, name: "value", parent: name, pattern: "^[a-zA-Z0-9\\s._:/=+@-]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case key = "key"
            case value = "value"
        }
    }

    public struct TagResourceRequest: AWSEncodableShape {
        /// The ARN of the resource to tag.
        public let resourceARN: String
        /// Tags to associate with the resource.
        public let tags: [Tag]

        public init(resourceARN: String, tags: [Tag]) {
            self.resourceARN = resourceARN
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceARN, name: "resourceARN", parent: name, max: 1011)
            try self.validate(self.resourceARN, name: "resourceARN", parent: name, min: 20)
            try self.validate(self.resourceARN, name: "resourceARN", parent: name, pattern: "(^[a-zA-Z0-9][a-zA-Z0-9\\-]*$)|(^arn:aws(-[^:]+)?:bedrock:[a-z0-9-]{1,20}:([0-9]{12}|)((:(fine-tuning-job|model-customization-job|custom-model)/[a-z0-9-]{1,63}[.]{1}[a-z0-9-]{1,63}([a-z0-9-]{1,63}[.]){0,2}[a-z0-9-]{1,63}([:][a-z0-9-]{1,63}){0,2}(/[a-z0-9]{12})$)|(:provisioned-model/[a-z0-9]{12}$)))")
            try self.tags.forEach {
                try $0.validate(name: "\(name).tags[]")
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 200)
        }

        private enum CodingKeys: String, CodingKey {
            case resourceARN = "resourceARN"
            case tags = "tags"
        }
    }

    public struct TagResourceResponse: AWSDecodableShape {
        public init() {}
    }

    public struct TrainingDataConfig: AWSEncodableShape & AWSDecodableShape {
        /// The S3 URI where the training data is stored.
        public let s3Uri: String

        public init(s3Uri: String) {
            self.s3Uri = s3Uri
        }

        public func validate(name: String) throws {
            try self.validate(self.s3Uri, name: "s3Uri", parent: name, max: 1024)
            try self.validate(self.s3Uri, name: "s3Uri", parent: name, min: 1)
            try self.validate(self.s3Uri, name: "s3Uri", parent: name, pattern: "^s3://[a-z0-9][\\.\\-a-z0-9]{1,61}[a-z0-9](/.*)?$")
        }

        private enum CodingKeys: String, CodingKey {
            case s3Uri = "s3Uri"
        }
    }

    public struct TrainingMetrics: AWSDecodableShape {
        /// Loss metric associated with the custom job.
        public let trainingLoss: Float?

        public init(trainingLoss: Float? = nil) {
            self.trainingLoss = trainingLoss
        }

        private enum CodingKeys: String, CodingKey {
            case trainingLoss = "trainingLoss"
        }
    }

    public struct UntagResourceRequest: AWSEncodableShape {
        /// The ARN of the resource to untag.
        public let resourceARN: String
        /// Tag keys of the tags to remove from the resource.
        public let tagKeys: [String]

        public init(resourceARN: String, tagKeys: [String]) {
            self.resourceARN = resourceARN
            self.tagKeys = tagKeys
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceARN, name: "resourceARN", parent: name, max: 1011)
            try self.validate(self.resourceARN, name: "resourceARN", parent: name, min: 20)
            try self.validate(self.resourceARN, name: "resourceARN", parent: name, pattern: "(^[a-zA-Z0-9][a-zA-Z0-9\\-]*$)|(^arn:aws(-[^:]+)?:bedrock:[a-z0-9-]{1,20}:([0-9]{12}|)((:(fine-tuning-job|model-customization-job|custom-model)/[a-z0-9-]{1,63}[.]{1}[a-z0-9-]{1,63}([a-z0-9-]{1,63}[.]){0,2}[a-z0-9-]{1,63}([:][a-z0-9-]{1,63}){0,2}(/[a-z0-9]{12})$)|(:provisioned-model/[a-z0-9]{12}$)))")
            try self.tagKeys.forEach {
                try validate($0, name: "tagKeys[]", parent: name, max: 128)
                try validate($0, name: "tagKeys[]", parent: name, min: 1)
                try validate($0, name: "tagKeys[]", parent: name, pattern: "^[a-zA-Z0-9\\s._:/=+@-]*$")
            }
            try self.validate(self.tagKeys, name: "tagKeys", parent: name, max: 200)
        }

        private enum CodingKeys: String, CodingKey {
            case resourceARN = "resourceARN"
            case tagKeys = "tagKeys"
        }
    }

    public struct UntagResourceResponse: AWSDecodableShape {
        public init() {}
    }

    public struct UpdateProvisionedModelThroughputRequest: AWSEncodableShape {
        /// The ARN of the new model to associate with this provisioned throughput.
        public let desiredModelId: String?
        /// The new name for this provisioned throughput.
        public let desiredProvisionedModelName: String?
        /// The ARN or name of the provisioned throughput to update.
        public let provisionedModelId: String

        public init(desiredModelId: String? = nil, desiredProvisionedModelName: String? = nil, provisionedModelId: String) {
            self.desiredModelId = desiredModelId
            self.desiredProvisionedModelName = desiredProvisionedModelName
            self.provisionedModelId = provisionedModelId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.desiredModelId, forKey: .desiredModelId)
            try container.encodeIfPresent(self.desiredProvisionedModelName, forKey: .desiredProvisionedModelName)
            request.encodePath(self.provisionedModelId, key: "provisionedModelId")
        }

        public func validate(name: String) throws {
            try self.validate(self.desiredModelId, name: "desiredModelId", parent: name, max: 2048)
            try self.validate(self.desiredModelId, name: "desiredModelId", parent: name, min: 1)
            try self.validate(self.desiredModelId, name: "desiredModelId", parent: name, pattern: "^arn:aws(-[^:]+)?:bedrock:[a-z0-9-]{1,20}:(([0-9]{12}:custom-model/[a-z0-9-]{1,63}[.]{1}[a-z0-9-]{1,63}(([:][a-z0-9-]{1,63}){0,2})?/[a-z0-9]{12})|(:foundation-model/([a-z0-9-]{1,63}[.]{1}[a-z0-9-]{1,63}([.]?[a-z0-9-]{1,63})([:][a-z0-9-]{1,63}){0,2})))|(([a-z0-9-]{1,63}[.]{1}[a-z0-9-]{1,63}([.]?[a-z0-9-]{1,63})([:][a-z0-9-]{1,63}){0,2}))|(([0-9a-zA-Z][_-]?)+)$")
            try self.validate(self.desiredProvisionedModelName, name: "desiredProvisionedModelName", parent: name, max: 63)
            try self.validate(self.desiredProvisionedModelName, name: "desiredProvisionedModelName", parent: name, min: 1)
            try self.validate(self.desiredProvisionedModelName, name: "desiredProvisionedModelName", parent: name, pattern: "^([0-9a-zA-Z][_-]?)+$")
            try self.validate(self.provisionedModelId, name: "provisionedModelId", parent: name, pattern: "^((([0-9a-zA-Z][_-]?)+)|(arn:aws(-[^:]+)?:bedrock:[a-z0-9-]{1,20}:[0-9]{12}:provisioned-model/[a-z0-9]{12}))$")
        }

        private enum CodingKeys: String, CodingKey {
            case desiredModelId = "desiredModelId"
            case desiredProvisionedModelName = "desiredProvisionedModelName"
        }
    }

    public struct UpdateProvisionedModelThroughputResponse: AWSDecodableShape {
        public init() {}
    }

    public struct ValidationDataConfig: AWSEncodableShape & AWSDecodableShape {
        /// Information about the validators.
        public let validators: [Validator]

        public init(validators: [Validator]) {
            self.validators = validators
        }

        public func validate(name: String) throws {
            try self.validators.forEach {
                try $0.validate(name: "\(name).validators[]")
            }
            try self.validate(self.validators, name: "validators", parent: name, max: 10)
        }

        private enum CodingKeys: String, CodingKey {
            case validators = "validators"
        }
    }

    public struct Validator: AWSEncodableShape & AWSDecodableShape {
        /// The S3 URI where the validation data is stored.
        public let s3Uri: String

        public init(s3Uri: String) {
            self.s3Uri = s3Uri
        }

        public func validate(name: String) throws {
            try self.validate(self.s3Uri, name: "s3Uri", parent: name, max: 1024)
            try self.validate(self.s3Uri, name: "s3Uri", parent: name, min: 1)
            try self.validate(self.s3Uri, name: "s3Uri", parent: name, pattern: "^s3://[a-z0-9][\\.\\-a-z0-9]{1,61}[a-z0-9](/.*)?$")
        }

        private enum CodingKeys: String, CodingKey {
            case s3Uri = "s3Uri"
        }
    }

    public struct ValidatorMetric: AWSDecodableShape {
        /// The validation loss associated with this validator.
        public let validationLoss: Float?

        public init(validationLoss: Float? = nil) {
            self.validationLoss = validationLoss
        }

        private enum CodingKeys: String, CodingKey {
            case validationLoss = "validationLoss"
        }
    }

    public struct VpcConfig: AWSEncodableShape & AWSDecodableShape {
        /// VPC configuration security group Ids.
        public let securityGroupIds: [String]
        /// VPC configuration subnets.
        public let subnetIds: [String]

        public init(securityGroupIds: [String], subnetIds: [String]) {
            self.securityGroupIds = securityGroupIds
            self.subnetIds = subnetIds
        }

        public func validate(name: String) throws {
            try self.securityGroupIds.forEach {
                try validate($0, name: "securityGroupIds[]", parent: name, max: 32)
                try validate($0, name: "securityGroupIds[]", parent: name, pattern: "^[-0-9a-zA-Z]+$")
            }
            try self.validate(self.securityGroupIds, name: "securityGroupIds", parent: name, max: 5)
            try self.validate(self.securityGroupIds, name: "securityGroupIds", parent: name, min: 1)
            try self.subnetIds.forEach {
                try validate($0, name: "subnetIds[]", parent: name, max: 32)
                try validate($0, name: "subnetIds[]", parent: name, pattern: "^[-0-9a-zA-Z]+$")
            }
            try self.validate(self.subnetIds, name: "subnetIds", parent: name, max: 16)
            try self.validate(self.subnetIds, name: "subnetIds", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case securityGroupIds = "securityGroupIds"
            case subnetIds = "subnetIds"
        }
    }
}

// MARK: - Errors

/// Error enum for Bedrock
public struct BedrockErrorType: AWSErrorType {
    enum Code: String {
        case accessDeniedException = "AccessDeniedException"
        case conflictException = "ConflictException"
        case internalServerException = "InternalServerException"
        case resourceNotFoundException = "ResourceNotFoundException"
        case serviceQuotaExceededException = "ServiceQuotaExceededException"
        case throttlingException = "ThrottlingException"
        case tooManyTagsException = "TooManyTagsException"
        case validationException = "ValidationException"
    }

    private let error: Code
    public let context: AWSErrorContext?

    /// initialize Bedrock
    public init?(errorCode: String, context: AWSErrorContext) {
        guard let error = Code(rawValue: errorCode) else { return nil }
        self.error = error
        self.context = context
    }

    internal init(_ error: Code) {
        self.error = error
        self.context = nil
    }

    /// return error code string
    public var errorCode: String { self.error.rawValue }

    /// The request is denied because of missing access permissions.
    public static var accessDeniedException: Self { .init(.accessDeniedException) }
    /// Error occurred because of a conflict while performing an operation.
    public static var conflictException: Self { .init(.conflictException) }
    /// An internal server error occurred. Retry your request.
    public static var internalServerException: Self { .init(.internalServerException) }
    /// The specified resource ARN was not found. Check the ARN and try your request again.
    public static var resourceNotFoundException: Self { .init(.resourceNotFoundException) }
    /// The number of requests exceeds the service quota. Resubmit your request later.
    public static var serviceQuotaExceededException: Self { .init(.serviceQuotaExceededException) }
    /// The number of requests exceeds the limit. Resubmit your request later.
    public static var throttlingException: Self { .init(.throttlingException) }
    /// The request contains more tags than can be associated with a resource (50 tags per resource).  The maximum number of tags includes both existing tags and those included in your current request.
    public static var tooManyTagsException: Self { .init(.tooManyTagsException) }
    /// Input validation failed. Check your request parameters and retry the request.
    public static var validationException: Self { .init(.validationException) }
}

extension BedrockErrorType: Equatable {
    public static func == (lhs: BedrockErrorType, rhs: BedrockErrorType) -> Bool {
        lhs.error == rhs.error
    }
}

extension BedrockErrorType: CustomStringConvertible {
    public var description: String {
        return "\(self.error.rawValue): \(self.message ?? "")"
    }
}
