//===----------------------------------------------------------------------===//
//
// This source file is part of the Soto for AWS open source project
//
// Copyright (c) 2017-2024 the Soto project authors
// Licensed under Apache License v2.0
//
// See LICENSE.txt for license information
// See CONTRIBUTORS.txt for the list of Soto project authors
//
// SPDX-License-Identifier: Apache-2.0
//
//===----------------------------------------------------------------------===//

// THIS FILE IS AUTOMATICALLY GENERATED by https://github.com/soto-project/soto-codegenerator.
// DO NOT EDIT.

#if os(Linux) && compiler(<5.10)
// swift-corelibs-foundation hasn't been updated with Sendable conformances
@preconcurrency import Foundation
#else
import Foundation
#endif
@_exported import SotoCore

/// Service object for interacting with AWS Kafka service.
///
/// The operations for managing an Amazon MSK cluster.
public struct Kafka: AWSService {
    // MARK: Member variables

    /// Client used for communication with AWS
    public let client: AWSClient
    /// Service configuration
    public let config: AWSServiceConfig

    // MARK: Initialization

    /// Initialize the Kafka client
    /// - parameters:
    ///     - client: AWSClient used to process requests
    ///     - region: Region of server you want to communicate with. This will override the partition parameter.
    ///     - partition: AWS partition where service resides, standard (.aws), china (.awscn), government (.awsusgov).
    ///     - endpoint: Custom endpoint URL to use instead of standard AWS servers
    ///     - middleware: Middleware chain used to edit requests before they are sent and responses before they are decoded 
    ///     - timeout: Timeout value for HTTP requests
    ///     - byteBufferAllocator: Allocator for ByteBuffers
    ///     - options: Service options
    public init(
        client: AWSClient,
        region: SotoCore.Region? = nil,
        partition: AWSPartition = .aws,
        endpoint: String? = nil,
        middleware: AWSMiddlewareProtocol? = nil,
        timeout: TimeAmount? = nil,
        byteBufferAllocator: ByteBufferAllocator = ByteBufferAllocator(),
        options: AWSServiceConfig.Options = []
    ) {
        self.client = client
        self.config = AWSServiceConfig(
            region: region,
            partition: region?.partition ?? partition,
            serviceName: "Kafka",
            serviceIdentifier: "kafka",
            serviceProtocol: .restjson,
            apiVersion: "2018-11-14",
            endpoint: endpoint,
            serviceEndpoints: Self.serviceEndpoints,
            variantEndpoints: Self.variantEndpoints,
            errorType: KafkaErrorType.self,
            middleware: middleware,
            timeout: timeout,
            byteBufferAllocator: byteBufferAllocator,
            options: options
        )
    }


    /// custom endpoints for regions
    static var serviceEndpoints: [String: String] {[
        "us-gov-east-1": "kafka.us-gov-east-1.amazonaws.com",
        "us-gov-west-1": "kafka.us-gov-west-1.amazonaws.com"
    ]}


    /// FIPS and dualstack endpoints
    static var variantEndpoints: [EndpointVariantType: AWSServiceConfig.EndpointVariant] {[
        [.fips]: .init(endpoints: [
            "ca-central-1": "kafka-fips.ca-central-1.amazonaws.com",
            "ca-west-1": "kafka-fips.ca-west-1.amazonaws.com",
            "us-east-1": "kafka-fips.us-east-1.amazonaws.com",
            "us-east-2": "kafka-fips.us-east-2.amazonaws.com",
            "us-gov-east-1": "kafka.us-gov-east-1.amazonaws.com",
            "us-gov-west-1": "kafka.us-gov-west-1.amazonaws.com",
            "us-west-1": "kafka-fips.us-west-1.amazonaws.com",
            "us-west-2": "kafka-fips.us-west-2.amazonaws.com"
        ])
    ]}

    // MARK: API Calls

    /// Associates one or more Scram Secrets with an Amazon MSK cluster.
    @Sendable
    @inlinable
    public func batchAssociateScramSecret(_ input: BatchAssociateScramSecretRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> BatchAssociateScramSecretResponse {
        try await self.client.execute(
            operation: "BatchAssociateScramSecret", 
            path: "/v1/clusters/{ClusterArn}/scram-secrets", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Associates one or more Scram Secrets with an Amazon MSK cluster.
    ///
    /// Parameters:
    ///   - clusterArn: The Amazon Resource Name (ARN) of the cluster to be updated.
    ///   - secretArnList: List of AWS Secrets Manager secret ARNs.
    ///   - logger: Logger use during operation
    @inlinable
    public func batchAssociateScramSecret(
        clusterArn: String,
        secretArnList: [String]? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> BatchAssociateScramSecretResponse {
        let input = BatchAssociateScramSecretRequest(
            clusterArn: clusterArn, 
            secretArnList: secretArnList
        )
        return try await self.batchAssociateScramSecret(input, logger: logger)
    }

    /// Disassociates one or more Scram Secrets from an Amazon MSK cluster.
    @Sendable
    @inlinable
    public func batchDisassociateScramSecret(_ input: BatchDisassociateScramSecretRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> BatchDisassociateScramSecretResponse {
        try await self.client.execute(
            operation: "BatchDisassociateScramSecret", 
            path: "/v1/clusters/{ClusterArn}/scram-secrets", 
            httpMethod: .PATCH, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Disassociates one or more Scram Secrets from an Amazon MSK cluster.
    ///
    /// Parameters:
    ///   - clusterArn: The Amazon Resource Name (ARN) of the cluster to be updated.
    ///   - secretArnList: List of AWS Secrets Manager secret ARNs.
    ///   - logger: Logger use during operation
    @inlinable
    public func batchDisassociateScramSecret(
        clusterArn: String,
        secretArnList: [String]? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> BatchDisassociateScramSecretResponse {
        let input = BatchDisassociateScramSecretRequest(
            clusterArn: clusterArn, 
            secretArnList: secretArnList
        )
        return try await self.batchDisassociateScramSecret(input, logger: logger)
    }

    /// Creates a new MSK cluster.
    @Sendable
    @inlinable
    public func createCluster(_ input: CreateClusterRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> CreateClusterResponse {
        try await self.client.execute(
            operation: "CreateCluster", 
            path: "/v1/clusters", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Creates a new MSK cluster.
    ///
    /// Parameters:
    ///   - brokerNodeGroupInfo: Information about the broker nodes in the cluster.
    ///   - clientAuthentication: Includes all client authentication related information.
    ///   - clusterName: The name of the cluster.
    ///   - configurationInfo: Represents the configuration that you want MSK to use for the brokers in a cluster.
    ///   - encryptionInfo: Includes all encryption-related information.
    ///   - enhancedMonitoring: Specifies the level of monitoring for the MSK cluster. The possible values are DEFAULT, PER_BROKER, PER_TOPIC_PER_BROKER, and PER_TOPIC_PER_PARTITION.
    ///   - kafkaVersion: The version of Apache Kafka.
    ///   - loggingInfo: 
    ///   - numberOfBrokerNodes: The number of broker nodes in the cluster.
    ///   - openMonitoring: The settings for open monitoring.
    ///   - storageMode: This controls storage mode for supported storage tiers.
    ///   - tags: Create tags when creating the cluster.
    ///   - logger: Logger use during operation
    @inlinable
    public func createCluster(
        brokerNodeGroupInfo: BrokerNodeGroupInfo? = nil,
        clientAuthentication: ClientAuthentication? = nil,
        clusterName: String? = nil,
        configurationInfo: ConfigurationInfo? = nil,
        encryptionInfo: EncryptionInfo? = nil,
        enhancedMonitoring: EnhancedMonitoring? = nil,
        kafkaVersion: String? = nil,
        loggingInfo: LoggingInfo? = nil,
        numberOfBrokerNodes: Int? = nil,
        openMonitoring: OpenMonitoringInfo? = nil,
        storageMode: StorageMode? = nil,
        tags: [String: String]? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> CreateClusterResponse {
        let input = CreateClusterRequest(
            brokerNodeGroupInfo: brokerNodeGroupInfo, 
            clientAuthentication: clientAuthentication, 
            clusterName: clusterName, 
            configurationInfo: configurationInfo, 
            encryptionInfo: encryptionInfo, 
            enhancedMonitoring: enhancedMonitoring, 
            kafkaVersion: kafkaVersion, 
            loggingInfo: loggingInfo, 
            numberOfBrokerNodes: numberOfBrokerNodes, 
            openMonitoring: openMonitoring, 
            storageMode: storageMode, 
            tags: tags
        )
        return try await self.createCluster(input, logger: logger)
    }

    /// Creates a new MSK cluster.
    @Sendable
    @inlinable
    public func createClusterV2(_ input: CreateClusterV2Request, logger: Logger = AWSClient.loggingDisabled) async throws -> CreateClusterV2Response {
        try await self.client.execute(
            operation: "CreateClusterV2", 
            path: "/api/v2/clusters", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Creates a new MSK cluster.
    ///
    /// Parameters:
    ///   - clusterName: The name of the cluster.
    ///   - provisioned: Information about the provisioned cluster.
    ///   - serverless: Information about the serverless cluster.
    ///   - tags: A map of tags that you want the cluster to have.
    ///   - logger: Logger use during operation
    @inlinable
    public func createClusterV2(
        clusterName: String? = nil,
        provisioned: ProvisionedRequest? = nil,
        serverless: ServerlessRequest? = nil,
        tags: [String: String]? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> CreateClusterV2Response {
        let input = CreateClusterV2Request(
            clusterName: clusterName, 
            provisioned: provisioned, 
            serverless: serverless, 
            tags: tags
        )
        return try await self.createClusterV2(input, logger: logger)
    }

    /// Creates a new MSK configuration.
    @Sendable
    @inlinable
    public func createConfiguration(_ input: CreateConfigurationRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> CreateConfigurationResponse {
        try await self.client.execute(
            operation: "CreateConfiguration", 
            path: "/v1/configurations", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Creates a new MSK configuration.
    ///
    /// Parameters:
    ///   - description: The description of the configuration.
    ///   - kafkaVersions: The versions of Apache Kafka with which you can use this MSK configuration.
    ///   - name: The name of the configuration.
    ///   - serverProperties: Contents of the server.properties file. When using the API, you must ensure that the contents of the file are base64 encoded.  When using the AWS Management Console, the SDK, or the AWS CLI, the contents of server.properties can be in plaintext.
    ///   - logger: Logger use during operation
    @inlinable
    public func createConfiguration(
        description: String? = nil,
        kafkaVersions: [String]? = nil,
        name: String? = nil,
        serverProperties: AWSBase64Data? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> CreateConfigurationResponse {
        let input = CreateConfigurationRequest(
            description: description, 
            kafkaVersions: kafkaVersions, 
            name: name, 
            serverProperties: serverProperties
        )
        return try await self.createConfiguration(input, logger: logger)
    }

    /// Creates the replicator.
    @Sendable
    @inlinable
    public func createReplicator(_ input: CreateReplicatorRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> CreateReplicatorResponse {
        try await self.client.execute(
            operation: "CreateReplicator", 
            path: "/replication/v1/replicators", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Creates the replicator.
    ///
    /// Parameters:
    ///   - description: A summary description of the replicator.
    ///   - kafkaClusters: Kafka Clusters to use in setting up sources / targets for replication.
    ///   - replicationInfoList: A list of replication configurations, where each configuration targets a given source cluster to target cluster replication flow.
    ///   - replicatorName: The name of the replicator. Alpha-numeric characters with '-' are allowed.
    ///   - serviceExecutionRoleArn: The ARN of the IAM role used by the replicator to access resources in the customer's account (e.g source and target clusters)
    ///   - tags: List of tags to attach to created Replicator.
    ///   - logger: Logger use during operation
    @inlinable
    public func createReplicator(
        description: String? = nil,
        kafkaClusters: [KafkaCluster]? = nil,
        replicationInfoList: [ReplicationInfo]? = nil,
        replicatorName: String? = nil,
        serviceExecutionRoleArn: String? = nil,
        tags: [String: String]? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> CreateReplicatorResponse {
        let input = CreateReplicatorRequest(
            description: description, 
            kafkaClusters: kafkaClusters, 
            replicationInfoList: replicationInfoList, 
            replicatorName: replicatorName, 
            serviceExecutionRoleArn: serviceExecutionRoleArn, 
            tags: tags
        )
        return try await self.createReplicator(input, logger: logger)
    }

    /// Creates a new MSK VPC connection.
    @Sendable
    @inlinable
    public func createVpcConnection(_ input: CreateVpcConnectionRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> CreateVpcConnectionResponse {
        try await self.client.execute(
            operation: "CreateVpcConnection", 
            path: "/v1/vpc-connection", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Creates a new MSK VPC connection.
    ///
    /// Parameters:
    ///   - authentication: The authentication type of VPC connection.
    ///   - clientSubnets: The list of client subnets.
    ///   - securityGroups: The list of security groups.
    ///   - tags: A map of tags for the VPC connection.
    ///   - targetClusterArn: The cluster Amazon Resource Name (ARN) for the VPC connection.
    ///   - vpcId: The VPC ID of VPC connection.
    ///   - logger: Logger use during operation
    @inlinable
    public func createVpcConnection(
        authentication: String? = nil,
        clientSubnets: [String]? = nil,
        securityGroups: [String]? = nil,
        tags: [String: String]? = nil,
        targetClusterArn: String? = nil,
        vpcId: String? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> CreateVpcConnectionResponse {
        let input = CreateVpcConnectionRequest(
            authentication: authentication, 
            clientSubnets: clientSubnets, 
            securityGroups: securityGroups, 
            tags: tags, 
            targetClusterArn: targetClusterArn, 
            vpcId: vpcId
        )
        return try await self.createVpcConnection(input, logger: logger)
    }

    /// Deletes the MSK cluster specified by the Amazon Resource Name (ARN) in the request.
    @Sendable
    @inlinable
    public func deleteCluster(_ input: DeleteClusterRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> DeleteClusterResponse {
        try await self.client.execute(
            operation: "DeleteCluster", 
            path: "/v1/clusters/{ClusterArn}", 
            httpMethod: .DELETE, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Deletes the MSK cluster specified by the Amazon Resource Name (ARN) in the request.
    ///
    /// Parameters:
    ///   - clusterArn: The Amazon Resource Name (ARN) that uniquely identifies the cluster.
    ///   - currentVersion: The current version of the MSK cluster.
    ///   - logger: Logger use during operation
    @inlinable
    public func deleteCluster(
        clusterArn: String,
        currentVersion: String? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> DeleteClusterResponse {
        let input = DeleteClusterRequest(
            clusterArn: clusterArn, 
            currentVersion: currentVersion
        )
        return try await self.deleteCluster(input, logger: logger)
    }

    /// Deletes the MSK cluster policy specified by the Amazon Resource Name (ARN) in the request.
    @Sendable
    @inlinable
    public func deleteClusterPolicy(_ input: DeleteClusterPolicyRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> DeleteClusterPolicyResponse {
        try await self.client.execute(
            operation: "DeleteClusterPolicy", 
            path: "/v1/clusters/{ClusterArn}/policy", 
            httpMethod: .DELETE, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Deletes the MSK cluster policy specified by the Amazon Resource Name (ARN) in the request.
    ///
    /// Parameters:
    ///   - clusterArn: The Amazon Resource Name (ARN) of the cluster.
    ///   - logger: Logger use during operation
    @inlinable
    public func deleteClusterPolicy(
        clusterArn: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> DeleteClusterPolicyResponse {
        let input = DeleteClusterPolicyRequest(
            clusterArn: clusterArn
        )
        return try await self.deleteClusterPolicy(input, logger: logger)
    }

    /// Deletes an MSK Configuration.
    @Sendable
    @inlinable
    public func deleteConfiguration(_ input: DeleteConfigurationRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> DeleteConfigurationResponse {
        try await self.client.execute(
            operation: "DeleteConfiguration", 
            path: "/v1/configurations/{Arn}", 
            httpMethod: .DELETE, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Deletes an MSK Configuration.
    ///
    /// Parameters:
    ///   - arn: The Amazon Resource Name (ARN) that uniquely identifies an MSK configuration.
    ///   - logger: Logger use during operation
    @inlinable
    public func deleteConfiguration(
        arn: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> DeleteConfigurationResponse {
        let input = DeleteConfigurationRequest(
            arn: arn
        )
        return try await self.deleteConfiguration(input, logger: logger)
    }

    /// Deletes a replicator.
    @Sendable
    @inlinable
    public func deleteReplicator(_ input: DeleteReplicatorRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> DeleteReplicatorResponse {
        try await self.client.execute(
            operation: "DeleteReplicator", 
            path: "/replication/v1/replicators/{ReplicatorArn}", 
            httpMethod: .DELETE, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Deletes a replicator.
    ///
    /// Parameters:
    ///   - currentVersion: The current version of the replicator.
    ///   - replicatorArn: The Amazon Resource Name (ARN) of the replicator to be deleted.
    ///   - logger: Logger use during operation
    @inlinable
    public func deleteReplicator(
        currentVersion: String? = nil,
        replicatorArn: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> DeleteReplicatorResponse {
        let input = DeleteReplicatorRequest(
            currentVersion: currentVersion, 
            replicatorArn: replicatorArn
        )
        return try await self.deleteReplicator(input, logger: logger)
    }

    /// Deletes a MSK VPC connection.
    @Sendable
    @inlinable
    public func deleteVpcConnection(_ input: DeleteVpcConnectionRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> DeleteVpcConnectionResponse {
        try await self.client.execute(
            operation: "DeleteVpcConnection", 
            path: "/v1/vpc-connection/{Arn}", 
            httpMethod: .DELETE, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Deletes a MSK VPC connection.
    ///
    /// Parameters:
    ///   - arn: The Amazon Resource Name (ARN) that uniquely identifies an MSK VPC connection.
    ///   - logger: Logger use during operation
    @inlinable
    public func deleteVpcConnection(
        arn: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> DeleteVpcConnectionResponse {
        let input = DeleteVpcConnectionRequest(
            arn: arn
        )
        return try await self.deleteVpcConnection(input, logger: logger)
    }

    /// Returns a description of the MSK cluster whose Amazon Resource Name (ARN) is specified in the request.
    @Sendable
    @inlinable
    public func describeCluster(_ input: DescribeClusterRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> DescribeClusterResponse {
        try await self.client.execute(
            operation: "DescribeCluster", 
            path: "/v1/clusters/{ClusterArn}", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Returns a description of the MSK cluster whose Amazon Resource Name (ARN) is specified in the request.
    ///
    /// Parameters:
    ///   - clusterArn: The Amazon Resource Name (ARN) that uniquely identifies the cluster.
    ///   - logger: Logger use during operation
    @inlinable
    public func describeCluster(
        clusterArn: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> DescribeClusterResponse {
        let input = DescribeClusterRequest(
            clusterArn: clusterArn
        )
        return try await self.describeCluster(input, logger: logger)
    }

    /// Returns a description of the cluster operation specified by the ARN.
    @Sendable
    @inlinable
    public func describeClusterOperation(_ input: DescribeClusterOperationRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> DescribeClusterOperationResponse {
        try await self.client.execute(
            operation: "DescribeClusterOperation", 
            path: "/v1/operations/{ClusterOperationArn}", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Returns a description of the cluster operation specified by the ARN.
    ///
    /// Parameters:
    ///   - clusterOperationArn: The Amazon Resource Name (ARN) that uniquely identifies the MSK cluster operation.
    ///   - logger: Logger use during operation
    @inlinable
    public func describeClusterOperation(
        clusterOperationArn: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> DescribeClusterOperationResponse {
        let input = DescribeClusterOperationRequest(
            clusterOperationArn: clusterOperationArn
        )
        return try await self.describeClusterOperation(input, logger: logger)
    }

    /// Returns a description of the cluster operation specified by the ARN.
    @Sendable
    @inlinable
    public func describeClusterOperationV2(_ input: DescribeClusterOperationV2Request, logger: Logger = AWSClient.loggingDisabled) async throws -> DescribeClusterOperationV2Response {
        try await self.client.execute(
            operation: "DescribeClusterOperationV2", 
            path: "/api/v2/operations/{ClusterOperationArn}", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Returns a description of the cluster operation specified by the ARN.
    ///
    /// Parameters:
    ///   - clusterOperationArn: ARN of the cluster operation to describe.
    ///   - logger: Logger use during operation
    @inlinable
    public func describeClusterOperationV2(
        clusterOperationArn: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> DescribeClusterOperationV2Response {
        let input = DescribeClusterOperationV2Request(
            clusterOperationArn: clusterOperationArn
        )
        return try await self.describeClusterOperationV2(input, logger: logger)
    }

    /// Returns a description of the MSK cluster whose Amazon Resource Name (ARN) is specified in the request.
    @Sendable
    @inlinable
    public func describeClusterV2(_ input: DescribeClusterV2Request, logger: Logger = AWSClient.loggingDisabled) async throws -> DescribeClusterV2Response {
        try await self.client.execute(
            operation: "DescribeClusterV2", 
            path: "/api/v2/clusters/{ClusterArn}", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Returns a description of the MSK cluster whose Amazon Resource Name (ARN) is specified in the request.
    ///
    /// Parameters:
    ///   - clusterArn: The Amazon Resource Name (ARN) that uniquely identifies the cluster.
    ///   - logger: Logger use during operation
    @inlinable
    public func describeClusterV2(
        clusterArn: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> DescribeClusterV2Response {
        let input = DescribeClusterV2Request(
            clusterArn: clusterArn
        )
        return try await self.describeClusterV2(input, logger: logger)
    }

    /// Returns a description of this MSK configuration.
    @Sendable
    @inlinable
    public func describeConfiguration(_ input: DescribeConfigurationRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> DescribeConfigurationResponse {
        try await self.client.execute(
            operation: "DescribeConfiguration", 
            path: "/v1/configurations/{Arn}", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Returns a description of this MSK configuration.
    ///
    /// Parameters:
    ///   - arn: The Amazon Resource Name (ARN) that uniquely identifies an MSK configuration and all of its revisions.
    ///   - logger: Logger use during operation
    @inlinable
    public func describeConfiguration(
        arn: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> DescribeConfigurationResponse {
        let input = DescribeConfigurationRequest(
            arn: arn
        )
        return try await self.describeConfiguration(input, logger: logger)
    }

    /// Returns a description of this revision of the configuration.
    @Sendable
    @inlinable
    public func describeConfigurationRevision(_ input: DescribeConfigurationRevisionRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> DescribeConfigurationRevisionResponse {
        try await self.client.execute(
            operation: "DescribeConfigurationRevision", 
            path: "/v1/configurations/{Arn}/revisions/{Revision}", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Returns a description of this revision of the configuration.
    ///
    /// Parameters:
    ///   - arn: The Amazon Resource Name (ARN) that uniquely identifies an MSK configuration and all of its revisions.
    ///   - revision: A string that uniquely identifies a revision of an MSK configuration.
    ///   - logger: Logger use during operation
    @inlinable
    public func describeConfigurationRevision(
        arn: String,
        revision: Int64,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> DescribeConfigurationRevisionResponse {
        let input = DescribeConfigurationRevisionRequest(
            arn: arn, 
            revision: revision
        )
        return try await self.describeConfigurationRevision(input, logger: logger)
    }

    /// Describes a replicator.
    @Sendable
    @inlinable
    public func describeReplicator(_ input: DescribeReplicatorRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> DescribeReplicatorResponse {
        try await self.client.execute(
            operation: "DescribeReplicator", 
            path: "/replication/v1/replicators/{ReplicatorArn}", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Describes a replicator.
    ///
    /// Parameters:
    ///   - replicatorArn: The Amazon Resource Name (ARN) of the replicator to be described.
    ///   - logger: Logger use during operation
    @inlinable
    public func describeReplicator(
        replicatorArn: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> DescribeReplicatorResponse {
        let input = DescribeReplicatorRequest(
            replicatorArn: replicatorArn
        )
        return try await self.describeReplicator(input, logger: logger)
    }

    /// Returns a description of this MSK VPC connection.
    @Sendable
    @inlinable
    public func describeVpcConnection(_ input: DescribeVpcConnectionRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> DescribeVpcConnectionResponse {
        try await self.client.execute(
            operation: "DescribeVpcConnection", 
            path: "/v1/vpc-connection/{Arn}", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Returns a description of this MSK VPC connection.
    ///
    /// Parameters:
    ///   - arn: The Amazon Resource Name (ARN) that uniquely identifies a MSK VPC connection.
    ///   - logger: Logger use during operation
    @inlinable
    public func describeVpcConnection(
        arn: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> DescribeVpcConnectionResponse {
        let input = DescribeVpcConnectionRequest(
            arn: arn
        )
        return try await self.describeVpcConnection(input, logger: logger)
    }

    /// A list of brokers that a client application can use to bootstrap. This list doesn't necessarily include all of the brokers in the cluster. The following Python 3.6 example shows how you can use the Amazon Resource Name (ARN) of a cluster to get its bootstrap brokers. If you don't know the ARN of your cluster, you can use the ListClusters operation to get the ARNs of all the clusters in this account and Region.
    @Sendable
    @inlinable
    public func getBootstrapBrokers(_ input: GetBootstrapBrokersRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> GetBootstrapBrokersResponse {
        try await self.client.execute(
            operation: "GetBootstrapBrokers", 
            path: "/v1/clusters/{ClusterArn}/bootstrap-brokers", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// A list of brokers that a client application can use to bootstrap. This list doesn't necessarily include all of the brokers in the cluster. The following Python 3.6 example shows how you can use the Amazon Resource Name (ARN) of a cluster to get its bootstrap brokers. If you don't know the ARN of your cluster, you can use the ListClusters operation to get the ARNs of all the clusters in this account and Region.
    ///
    /// Parameters:
    ///   - clusterArn: The Amazon Resource Name (ARN) that uniquely identifies the cluster.
    ///   - logger: Logger use during operation
    @inlinable
    public func getBootstrapBrokers(
        clusterArn: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> GetBootstrapBrokersResponse {
        let input = GetBootstrapBrokersRequest(
            clusterArn: clusterArn
        )
        return try await self.getBootstrapBrokers(input, logger: logger)
    }

    /// Get the MSK cluster policy specified by the Amazon Resource Name (ARN) in the request.
    @Sendable
    @inlinable
    public func getClusterPolicy(_ input: GetClusterPolicyRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> GetClusterPolicyResponse {
        try await self.client.execute(
            operation: "GetClusterPolicy", 
            path: "/v1/clusters/{ClusterArn}/policy", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Get the MSK cluster policy specified by the Amazon Resource Name (ARN) in the request.
    ///
    /// Parameters:
    ///   - clusterArn: The Amazon Resource Name (ARN) of the cluster.
    ///   - logger: Logger use during operation
    @inlinable
    public func getClusterPolicy(
        clusterArn: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> GetClusterPolicyResponse {
        let input = GetClusterPolicyRequest(
            clusterArn: clusterArn
        )
        return try await self.getClusterPolicy(input, logger: logger)
    }

    /// Gets the Apache Kafka versions to which you can update the MSK cluster.
    @Sendable
    @inlinable
    public func getCompatibleKafkaVersions(_ input: GetCompatibleKafkaVersionsRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> GetCompatibleKafkaVersionsResponse {
        try await self.client.execute(
            operation: "GetCompatibleKafkaVersions", 
            path: "/v1/compatible-kafka-versions", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Gets the Apache Kafka versions to which you can update the MSK cluster.
    ///
    /// Parameters:
    ///   - clusterArn: The Amazon Resource Name (ARN) of the cluster check.
    ///   - logger: Logger use during operation
    @inlinable
    public func getCompatibleKafkaVersions(
        clusterArn: String? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> GetCompatibleKafkaVersionsResponse {
        let input = GetCompatibleKafkaVersionsRequest(
            clusterArn: clusterArn
        )
        return try await self.getCompatibleKafkaVersions(input, logger: logger)
    }

    /// Returns a list of all the VPC connections in this Region.
    @Sendable
    @inlinable
    public func listClientVpcConnections(_ input: ListClientVpcConnectionsRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> ListClientVpcConnectionsResponse {
        try await self.client.execute(
            operation: "ListClientVpcConnections", 
            path: "/v1/clusters/{ClusterArn}/client-vpc-connections", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Returns a list of all the VPC connections in this Region.
    ///
    /// Parameters:
    ///   - clusterArn: The Amazon Resource Name (ARN) of the cluster.
    ///   - maxResults: The maximum number of results to return in the response. If there are more results, the response includes a NextToken parameter.
    ///   - nextToken: The paginated results marker. When the result of the operation is truncated, the call returns NextToken in the response.  To get the next batch, provide this token in your next request.
    ///   - logger: Logger use during operation
    @inlinable
    public func listClientVpcConnections(
        clusterArn: String,
        maxResults: Int? = nil,
        nextToken: String? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ListClientVpcConnectionsResponse {
        let input = ListClientVpcConnectionsRequest(
            clusterArn: clusterArn, 
            maxResults: maxResults, 
            nextToken: nextToken
        )
        return try await self.listClientVpcConnections(input, logger: logger)
    }

    /// Returns a list of all the operations that have been performed on the specified MSK cluster.
    @Sendable
    @inlinable
    public func listClusterOperations(_ input: ListClusterOperationsRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> ListClusterOperationsResponse {
        try await self.client.execute(
            operation: "ListClusterOperations", 
            path: "/v1/clusters/{ClusterArn}/operations", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Returns a list of all the operations that have been performed on the specified MSK cluster.
    ///
    /// Parameters:
    ///   - clusterArn: The Amazon Resource Name (ARN) that uniquely identifies the cluster.
    ///   - maxResults: The maximum number of results to return in the response. If there are more results, the response includes a NextToken parameter.
    ///   - nextToken: The paginated results marker. When the result of the operation is truncated, the call returns NextToken in the response.  To get the next batch, provide this token in your next request.
    ///   - logger: Logger use during operation
    @inlinable
    public func listClusterOperations(
        clusterArn: String,
        maxResults: Int? = nil,
        nextToken: String? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ListClusterOperationsResponse {
        let input = ListClusterOperationsRequest(
            clusterArn: clusterArn, 
            maxResults: maxResults, 
            nextToken: nextToken
        )
        return try await self.listClusterOperations(input, logger: logger)
    }

    /// Returns a list of all the operations that have been performed on the specified MSK cluster.
    @Sendable
    @inlinable
    public func listClusterOperationsV2(_ input: ListClusterOperationsV2Request, logger: Logger = AWSClient.loggingDisabled) async throws -> ListClusterOperationsV2Response {
        try await self.client.execute(
            operation: "ListClusterOperationsV2", 
            path: "/api/v2/clusters/{ClusterArn}/operations", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Returns a list of all the operations that have been performed on the specified MSK cluster.
    ///
    /// Parameters:
    ///   - clusterArn: The arn of the cluster whose operations are being requested.
    ///   - maxResults: The maxResults of the query.
    ///   - nextToken: The nextToken of the query.
    ///   - logger: Logger use during operation
    @inlinable
    public func listClusterOperationsV2(
        clusterArn: String,
        maxResults: Int? = nil,
        nextToken: String? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ListClusterOperationsV2Response {
        let input = ListClusterOperationsV2Request(
            clusterArn: clusterArn, 
            maxResults: maxResults, 
            nextToken: nextToken
        )
        return try await self.listClusterOperationsV2(input, logger: logger)
    }

    /// Returns a list of all the MSK clusters in the current Region.
    @Sendable
    @inlinable
    public func listClusters(_ input: ListClustersRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> ListClustersResponse {
        try await self.client.execute(
            operation: "ListClusters", 
            path: "/v1/clusters", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Returns a list of all the MSK clusters in the current Region.
    ///
    /// Parameters:
    ///   - clusterNameFilter: Specify a prefix of the name of the clusters that you want to list. The service lists all the clusters whose names start with this prefix.
    ///   - maxResults: The maximum number of results to return in the response. If there are more results, the response includes a NextToken parameter.
    ///   - nextToken: The paginated results marker. When the result of the operation is truncated, the call returns NextToken in the response.  To get the next batch, provide this token in your next request.
    ///   - logger: Logger use during operation
    @inlinable
    public func listClusters(
        clusterNameFilter: String? = nil,
        maxResults: Int? = nil,
        nextToken: String? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ListClustersResponse {
        let input = ListClustersRequest(
            clusterNameFilter: clusterNameFilter, 
            maxResults: maxResults, 
            nextToken: nextToken
        )
        return try await self.listClusters(input, logger: logger)
    }

    /// Returns a list of all the MSK clusters in the current Region.
    @Sendable
    @inlinable
    public func listClustersV2(_ input: ListClustersV2Request, logger: Logger = AWSClient.loggingDisabled) async throws -> ListClustersV2Response {
        try await self.client.execute(
            operation: "ListClustersV2", 
            path: "/api/v2/clusters", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Returns a list of all the MSK clusters in the current Region.
    ///
    /// Parameters:
    ///   - clusterNameFilter: Specify a prefix of the names of the clusters that you want to list. The service lists all the clusters whose names start with this prefix.
    ///   - clusterTypeFilter: Specify either PROVISIONED or SERVERLESS.
    ///   - maxResults: The maximum number of results to return in the response. If there are more results, the response includes a NextToken parameter.
    ///   - nextToken: The paginated results marker. When the result of the operation is truncated, the call returns NextToken in the response.  To get the next batch, provide this token in your next request.
    ///   - logger: Logger use during operation
    @inlinable
    public func listClustersV2(
        clusterNameFilter: String? = nil,
        clusterTypeFilter: String? = nil,
        maxResults: Int? = nil,
        nextToken: String? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ListClustersV2Response {
        let input = ListClustersV2Request(
            clusterNameFilter: clusterNameFilter, 
            clusterTypeFilter: clusterTypeFilter, 
            maxResults: maxResults, 
            nextToken: nextToken
        )
        return try await self.listClustersV2(input, logger: logger)
    }

    /// Returns a list of all the MSK configurations in this Region.
    @Sendable
    @inlinable
    public func listConfigurationRevisions(_ input: ListConfigurationRevisionsRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> ListConfigurationRevisionsResponse {
        try await self.client.execute(
            operation: "ListConfigurationRevisions", 
            path: "/v1/configurations/{Arn}/revisions", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Returns a list of all the MSK configurations in this Region.
    ///
    /// Parameters:
    ///   - arn: The Amazon Resource Name (ARN) that uniquely identifies an MSK configuration and all of its revisions.
    ///   - maxResults: The maximum number of results to return in the response. If there are more results, the response includes a NextToken parameter.
    ///   - nextToken: The paginated results marker. When the result of the operation is truncated, the call returns NextToken in the response.  To get the next batch, provide this token in your next request.
    ///   - logger: Logger use during operation
    @inlinable
    public func listConfigurationRevisions(
        arn: String,
        maxResults: Int? = nil,
        nextToken: String? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ListConfigurationRevisionsResponse {
        let input = ListConfigurationRevisionsRequest(
            arn: arn, 
            maxResults: maxResults, 
            nextToken: nextToken
        )
        return try await self.listConfigurationRevisions(input, logger: logger)
    }

    /// Returns a list of all the MSK configurations in this Region.
    @Sendable
    @inlinable
    public func listConfigurations(_ input: ListConfigurationsRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> ListConfigurationsResponse {
        try await self.client.execute(
            operation: "ListConfigurations", 
            path: "/v1/configurations", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Returns a list of all the MSK configurations in this Region.
    ///
    /// Parameters:
    ///   - maxResults: The maximum number of results to return in the response. If there are more results, the response includes a NextToken parameter.
    ///   - nextToken: The paginated results marker. When the result of the operation is truncated, the call returns NextToken in the response.  To get the next batch, provide this token in your next request.
    ///   - logger: Logger use during operation
    @inlinable
    public func listConfigurations(
        maxResults: Int? = nil,
        nextToken: String? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ListConfigurationsResponse {
        let input = ListConfigurationsRequest(
            maxResults: maxResults, 
            nextToken: nextToken
        )
        return try await self.listConfigurations(input, logger: logger)
    }

    /// Returns a list of Apache Kafka versions.
    @Sendable
    @inlinable
    public func listKafkaVersions(_ input: ListKafkaVersionsRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> ListKafkaVersionsResponse {
        try await self.client.execute(
            operation: "ListKafkaVersions", 
            path: "/v1/kafka-versions", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Returns a list of Apache Kafka versions.
    ///
    /// Parameters:
    ///   - maxResults: The maximum number of results to return in the response. If there are more results, the response includes a NextToken parameter.
    ///   - nextToken: The paginated results marker. When the result of the operation is truncated, the call returns NextToken in the response. To get the next batch, provide this token in your next request.
    ///   - logger: Logger use during operation
    @inlinable
    public func listKafkaVersions(
        maxResults: Int? = nil,
        nextToken: String? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ListKafkaVersionsResponse {
        let input = ListKafkaVersionsRequest(
            maxResults: maxResults, 
            nextToken: nextToken
        )
        return try await self.listKafkaVersions(input, logger: logger)
    }

    /// Returns a list of the broker nodes in the cluster.
    @Sendable
    @inlinable
    public func listNodes(_ input: ListNodesRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> ListNodesResponse {
        try await self.client.execute(
            operation: "ListNodes", 
            path: "/v1/clusters/{ClusterArn}/nodes", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Returns a list of the broker nodes in the cluster.
    ///
    /// Parameters:
    ///   - clusterArn: The Amazon Resource Name (ARN) that uniquely identifies the cluster.
    ///   - maxResults: The maximum number of results to return in the response. If there are more results, the response includes a NextToken parameter.
    ///   - nextToken: The paginated results marker. When the result of the operation is truncated, the call returns NextToken in the response.  To get the next batch, provide this token in your next request.
    ///   - logger: Logger use during operation
    @inlinable
    public func listNodes(
        clusterArn: String,
        maxResults: Int? = nil,
        nextToken: String? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ListNodesResponse {
        let input = ListNodesRequest(
            clusterArn: clusterArn, 
            maxResults: maxResults, 
            nextToken: nextToken
        )
        return try await self.listNodes(input, logger: logger)
    }

    /// Lists the replicators.
    @Sendable
    @inlinable
    public func listReplicators(_ input: ListReplicatorsRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> ListReplicatorsResponse {
        try await self.client.execute(
            operation: "ListReplicators", 
            path: "/replication/v1/replicators", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Lists the replicators.
    ///
    /// Parameters:
    ///   - maxResults: The maximum number of results to return in the response. If there are more results, the response includes a NextToken parameter.
    ///   - nextToken: If the response of ListReplicators is truncated, it returns a NextToken in the response. This NextToken should be sent in the subsequent request to ListReplicators.
    ///   - replicatorNameFilter: Returns replicators starting with given name.
    ///   - logger: Logger use during operation
    @inlinable
    public func listReplicators(
        maxResults: Int? = nil,
        nextToken: String? = nil,
        replicatorNameFilter: String? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ListReplicatorsResponse {
        let input = ListReplicatorsRequest(
            maxResults: maxResults, 
            nextToken: nextToken, 
            replicatorNameFilter: replicatorNameFilter
        )
        return try await self.listReplicators(input, logger: logger)
    }

    /// Returns a list of the Scram Secrets associated with an Amazon MSK cluster.
    @Sendable
    @inlinable
    public func listScramSecrets(_ input: ListScramSecretsRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> ListScramSecretsResponse {
        try await self.client.execute(
            operation: "ListScramSecrets", 
            path: "/v1/clusters/{ClusterArn}/scram-secrets", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Returns a list of the Scram Secrets associated with an Amazon MSK cluster.
    ///
    /// Parameters:
    ///   - clusterArn: The arn of the cluster.
    ///   - maxResults: The maxResults of the query.
    ///   - nextToken: The nextToken of the query.
    ///   - logger: Logger use during operation
    @inlinable
    public func listScramSecrets(
        clusterArn: String,
        maxResults: Int? = nil,
        nextToken: String? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ListScramSecretsResponse {
        let input = ListScramSecretsRequest(
            clusterArn: clusterArn, 
            maxResults: maxResults, 
            nextToken: nextToken
        )
        return try await self.listScramSecrets(input, logger: logger)
    }

    /// Returns a list of the tags associated with the specified resource.
    @Sendable
    @inlinable
    public func listTagsForResource(_ input: ListTagsForResourceRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> ListTagsForResourceResponse {
        try await self.client.execute(
            operation: "ListTagsForResource", 
            path: "/v1/tags/{ResourceArn}", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Returns a list of the tags associated with the specified resource.
    ///
    /// Parameters:
    ///   - resourceArn: The Amazon Resource Name (ARN) that uniquely identifies the resource that's associated with the tags.
    ///   - logger: Logger use during operation
    @inlinable
    public func listTagsForResource(
        resourceArn: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ListTagsForResourceResponse {
        let input = ListTagsForResourceRequest(
            resourceArn: resourceArn
        )
        return try await self.listTagsForResource(input, logger: logger)
    }

    /// Returns a list of all the VPC connections in this Region.
    @Sendable
    @inlinable
    public func listVpcConnections(_ input: ListVpcConnectionsRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> ListVpcConnectionsResponse {
        try await self.client.execute(
            operation: "ListVpcConnections", 
            path: "/v1/vpc-connections", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Returns a list of all the VPC connections in this Region.
    ///
    /// Parameters:
    ///   - maxResults: The maximum number of results to return in the response. If there are more results, the response includes a NextToken parameter.
    ///   - nextToken: The paginated results marker. When the result of the operation is truncated, the call returns NextToken in the response.  To get the next batch, provide this token in your next request.
    ///   - logger: Logger use during operation
    @inlinable
    public func listVpcConnections(
        maxResults: Int? = nil,
        nextToken: String? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ListVpcConnectionsResponse {
        let input = ListVpcConnectionsRequest(
            maxResults: maxResults, 
            nextToken: nextToken
        )
        return try await self.listVpcConnections(input, logger: logger)
    }

    /// Creates or updates the MSK cluster policy specified by the cluster Amazon Resource Name (ARN) in the request.
    @Sendable
    @inlinable
    public func putClusterPolicy(_ input: PutClusterPolicyRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> PutClusterPolicyResponse {
        try await self.client.execute(
            operation: "PutClusterPolicy", 
            path: "/v1/clusters/{ClusterArn}/policy", 
            httpMethod: .PUT, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Creates or updates the MSK cluster policy specified by the cluster Amazon Resource Name (ARN) in the request.
    ///
    /// Parameters:
    ///   - clusterArn: The Amazon Resource Name (ARN) of the cluster.
    ///   - currentVersion: The policy version.
    ///   - policy: The policy.
    ///   - logger: Logger use during operation
    @inlinable
    public func putClusterPolicy(
        clusterArn: String,
        currentVersion: String? = nil,
        policy: String? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> PutClusterPolicyResponse {
        let input = PutClusterPolicyRequest(
            clusterArn: clusterArn, 
            currentVersion: currentVersion, 
            policy: policy
        )
        return try await self.putClusterPolicy(input, logger: logger)
    }

    /// Reboots brokers.
    @Sendable
    @inlinable
    public func rebootBroker(_ input: RebootBrokerRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> RebootBrokerResponse {
        try await self.client.execute(
            operation: "RebootBroker", 
            path: "/v1/clusters/{ClusterArn}/reboot-broker", 
            httpMethod: .PUT, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Reboots brokers.
    ///
    /// Parameters:
    ///   - brokerIds: The list of broker IDs to be rebooted. The reboot-broker operation supports rebooting one broker at a time.
    ///   - clusterArn: The Amazon Resource Name (ARN) of the cluster to be updated.
    ///   - logger: Logger use during operation
    @inlinable
    public func rebootBroker(
        brokerIds: [String]? = nil,
        clusterArn: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> RebootBrokerResponse {
        let input = RebootBrokerRequest(
            brokerIds: brokerIds, 
            clusterArn: clusterArn
        )
        return try await self.rebootBroker(input, logger: logger)
    }

    /// Returns empty response.
    @Sendable
    @inlinable
    public func rejectClientVpcConnection(_ input: RejectClientVpcConnectionRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> RejectClientVpcConnectionResponse {
        try await self.client.execute(
            operation: "RejectClientVpcConnection", 
            path: "/v1/clusters/{ClusterArn}/client-vpc-connection", 
            httpMethod: .PUT, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Returns empty response.
    ///
    /// Parameters:
    ///   - clusterArn: The Amazon Resource Name (ARN) of the cluster.
    ///   - vpcConnectionArn: The VPC connection ARN.
    ///   - logger: Logger use during operation
    @inlinable
    public func rejectClientVpcConnection(
        clusterArn: String,
        vpcConnectionArn: String? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> RejectClientVpcConnectionResponse {
        let input = RejectClientVpcConnectionRequest(
            clusterArn: clusterArn, 
            vpcConnectionArn: vpcConnectionArn
        )
        return try await self.rejectClientVpcConnection(input, logger: logger)
    }

    /// Adds tags to the specified MSK resource.
    @Sendable
    @inlinable
    public func tagResource(_ input: TagResourceRequest, logger: Logger = AWSClient.loggingDisabled) async throws {
        try await self.client.execute(
            operation: "TagResource", 
            path: "/v1/tags/{ResourceArn}", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Adds tags to the specified MSK resource.
    ///
    /// Parameters:
    ///   - resourceArn: The Amazon Resource Name (ARN) that uniquely identifies the resource that's associated with the tags.
    ///   - tags: The key-value pair for the resource tag.
    ///   - logger: Logger use during operation
    @inlinable
    public func tagResource(
        resourceArn: String,
        tags: [String: String]? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws {
        let input = TagResourceRequest(
            resourceArn: resourceArn, 
            tags: tags
        )
        return try await self.tagResource(input, logger: logger)
    }

    /// Removes the tags associated with the keys that are provided in the query.
    @Sendable
    @inlinable
    public func untagResource(_ input: UntagResourceRequest, logger: Logger = AWSClient.loggingDisabled) async throws {
        try await self.client.execute(
            operation: "UntagResource", 
            path: "/v1/tags/{ResourceArn}", 
            httpMethod: .DELETE, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Removes the tags associated with the keys that are provided in the query.
    ///
    /// Parameters:
    ///   - resourceArn: The Amazon Resource Name (ARN) that uniquely identifies the resource that's associated with the tags.
    ///   - tagKeys: Tag keys must be unique for a given cluster. In addition, the following restrictions apply:   Each tag key must be unique. If you add a tag with a key that's already in use, your new tag overwrites the existing key-value pair.    You can't start a tag key with aws: because this prefix is reserved for use by  AWS.  AWS creates tags that begin with this prefix on your behalf, but you can't edit or delete them.   Tag keys must be between 1 and 128 Unicode characters in length.   Tag keys must consist of the following characters: Unicode letters, digits, white space, and the following special characters: _ . / = + - @.
    ///   - logger: Logger use during operation
    @inlinable
    public func untagResource(
        resourceArn: String,
        tagKeys: [String]? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws {
        let input = UntagResourceRequest(
            resourceArn: resourceArn, 
            tagKeys: tagKeys
        )
        return try await self.untagResource(input, logger: logger)
    }

    /// Updates the number of broker nodes in the cluster.
    @Sendable
    @inlinable
    public func updateBrokerCount(_ input: UpdateBrokerCountRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> UpdateBrokerCountResponse {
        try await self.client.execute(
            operation: "UpdateBrokerCount", 
            path: "/v1/clusters/{ClusterArn}/nodes/count", 
            httpMethod: .PUT, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Updates the number of broker nodes in the cluster.
    ///
    /// Parameters:
    ///   - clusterArn: The Amazon Resource Name (ARN) that uniquely identifies the cluster.
    ///   - currentVersion: The version of cluster to update from. A successful operation will then generate a new version.
    ///   - targetNumberOfBrokerNodes: The number of broker nodes that you want the cluster to have after this operation completes successfully.
    ///   - logger: Logger use during operation
    @inlinable
    public func updateBrokerCount(
        clusterArn: String,
        currentVersion: String? = nil,
        targetNumberOfBrokerNodes: Int? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> UpdateBrokerCountResponse {
        let input = UpdateBrokerCountRequest(
            clusterArn: clusterArn, 
            currentVersion: currentVersion, 
            targetNumberOfBrokerNodes: targetNumberOfBrokerNodes
        )
        return try await self.updateBrokerCount(input, logger: logger)
    }

    /// Updates the EBS storage associated with MSK brokers.
    @Sendable
    @inlinable
    public func updateBrokerStorage(_ input: UpdateBrokerStorageRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> UpdateBrokerStorageResponse {
        try await self.client.execute(
            operation: "UpdateBrokerStorage", 
            path: "/v1/clusters/{ClusterArn}/nodes/storage", 
            httpMethod: .PUT, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Updates the EBS storage associated with MSK brokers.
    ///
    /// Parameters:
    ///   - clusterArn: The Amazon Resource Name (ARN) that uniquely identifies the cluster.
    ///   - currentVersion: The version of cluster to update from. A successful operation will then generate a new version.
    ///   - targetBrokerEBSVolumeInfo: Describes the target volume size and the ID of the broker to apply the update to.
    ///   - logger: Logger use during operation
    @inlinable
    public func updateBrokerStorage(
        clusterArn: String,
        currentVersion: String? = nil,
        targetBrokerEBSVolumeInfo: [BrokerEBSVolumeInfo]? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> UpdateBrokerStorageResponse {
        let input = UpdateBrokerStorageRequest(
            clusterArn: clusterArn, 
            currentVersion: currentVersion, 
            targetBrokerEBSVolumeInfo: targetBrokerEBSVolumeInfo
        )
        return try await self.updateBrokerStorage(input, logger: logger)
    }

    /// Updates EC2 instance type.
    @Sendable
    @inlinable
    public func updateBrokerType(_ input: UpdateBrokerTypeRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> UpdateBrokerTypeResponse {
        try await self.client.execute(
            operation: "UpdateBrokerType", 
            path: "/v1/clusters/{ClusterArn}/nodes/type", 
            httpMethod: .PUT, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Updates EC2 instance type.
    ///
    /// Parameters:
    ///   - clusterArn: The Amazon Resource Name (ARN) that uniquely identifies the cluster.
    ///   - currentVersion: The cluster version that you want to change. After this operation completes successfully, the cluster will have a new version.
    ///   - targetInstanceType: The Amazon MSK broker type that you want all of the brokers in this cluster to be.
    ///   - logger: Logger use during operation
    @inlinable
    public func updateBrokerType(
        clusterArn: String,
        currentVersion: String? = nil,
        targetInstanceType: String? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> UpdateBrokerTypeResponse {
        let input = UpdateBrokerTypeRequest(
            clusterArn: clusterArn, 
            currentVersion: currentVersion, 
            targetInstanceType: targetInstanceType
        )
        return try await self.updateBrokerType(input, logger: logger)
    }

    /// Updates the cluster with the configuration that is specified in the request body.
    @Sendable
    @inlinable
    public func updateClusterConfiguration(_ input: UpdateClusterConfigurationRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> UpdateClusterConfigurationResponse {
        try await self.client.execute(
            operation: "UpdateClusterConfiguration", 
            path: "/v1/clusters/{ClusterArn}/configuration", 
            httpMethod: .PUT, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Updates the cluster with the configuration that is specified in the request body.
    ///
    /// Parameters:
    ///   - clusterArn: The Amazon Resource Name (ARN) that uniquely identifies the cluster.
    ///   - configurationInfo: Represents the configuration that you want MSK to use for the brokers in a cluster.
    ///   - currentVersion: The version of the cluster that needs to be updated.
    ///   - logger: Logger use during operation
    @inlinable
    public func updateClusterConfiguration(
        clusterArn: String,
        configurationInfo: ConfigurationInfo? = nil,
        currentVersion: String? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> UpdateClusterConfigurationResponse {
        let input = UpdateClusterConfigurationRequest(
            clusterArn: clusterArn, 
            configurationInfo: configurationInfo, 
            currentVersion: currentVersion
        )
        return try await self.updateClusterConfiguration(input, logger: logger)
    }

    /// Updates the Apache Kafka version for the cluster.
    @Sendable
    @inlinable
    public func updateClusterKafkaVersion(_ input: UpdateClusterKafkaVersionRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> UpdateClusterKafkaVersionResponse {
        try await self.client.execute(
            operation: "UpdateClusterKafkaVersion", 
            path: "/v1/clusters/{ClusterArn}/version", 
            httpMethod: .PUT, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Updates the Apache Kafka version for the cluster.
    ///
    /// Parameters:
    ///   - clusterArn: The Amazon Resource Name (ARN) of the cluster to be updated.
    ///   - configurationInfo: The custom configuration that should be applied on the new version of cluster.
    ///   - currentVersion: Current cluster version.
    ///   - targetKafkaVersion: Target Kafka version.
    ///   - logger: Logger use during operation
    @inlinable
    public func updateClusterKafkaVersion(
        clusterArn: String,
        configurationInfo: ConfigurationInfo? = nil,
        currentVersion: String? = nil,
        targetKafkaVersion: String? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> UpdateClusterKafkaVersionResponse {
        let input = UpdateClusterKafkaVersionRequest(
            clusterArn: clusterArn, 
            configurationInfo: configurationInfo, 
            currentVersion: currentVersion, 
            targetKafkaVersion: targetKafkaVersion
        )
        return try await self.updateClusterKafkaVersion(input, logger: logger)
    }

    /// Updates an MSK configuration.
    @Sendable
    @inlinable
    public func updateConfiguration(_ input: UpdateConfigurationRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> UpdateConfigurationResponse {
        try await self.client.execute(
            operation: "UpdateConfiguration", 
            path: "/v1/configurations/{Arn}", 
            httpMethod: .PUT, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Updates an MSK configuration.
    ///
    /// Parameters:
    ///   - arn: The Amazon Resource Name (ARN) of the configuration.
    ///   - description: The description of the configuration revision.
    ///   - serverProperties: Contents of the server.properties file. When using the API, you must ensure that the contents of the file are base64 encoded.  When using the AWS Management Console, the SDK, or the AWS CLI, the contents of server.properties can be in plaintext.
    ///   - logger: Logger use during operation
    @inlinable
    public func updateConfiguration(
        arn: String,
        description: String? = nil,
        serverProperties: AWSBase64Data? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> UpdateConfigurationResponse {
        let input = UpdateConfigurationRequest(
            arn: arn, 
            description: description, 
            serverProperties: serverProperties
        )
        return try await self.updateConfiguration(input, logger: logger)
    }

    /// Updates the cluster's connectivity configuration.
    @Sendable
    @inlinable
    public func updateConnectivity(_ input: UpdateConnectivityRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> UpdateConnectivityResponse {
        try await self.client.execute(
            operation: "UpdateConnectivity", 
            path: "/v1/clusters/{ClusterArn}/connectivity", 
            httpMethod: .PUT, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Updates the cluster's connectivity configuration.
    ///
    /// Parameters:
    ///   - clusterArn: The Amazon Resource Name (ARN) of the configuration.
    ///   - connectivityInfo: Information about the broker access configuration.
    ///   - currentVersion: The version of the MSK cluster to update. Cluster versions aren't simple numbers. You can describe an MSK cluster to find its version. When this update operation is successful, it generates a new cluster version.
    ///   - logger: Logger use during operation
    @inlinable
    public func updateConnectivity(
        clusterArn: String,
        connectivityInfo: ConnectivityInfo? = nil,
        currentVersion: String? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> UpdateConnectivityResponse {
        let input = UpdateConnectivityRequest(
            clusterArn: clusterArn, 
            connectivityInfo: connectivityInfo, 
            currentVersion: currentVersion
        )
        return try await self.updateConnectivity(input, logger: logger)
    }

    /// Updates the monitoring settings for the cluster. You can use this operation to specify which Apache Kafka metrics you want Amazon MSK to send to Amazon CloudWatch. You can also specify settings for open monitoring with Prometheus.
    @Sendable
    @inlinable
    public func updateMonitoring(_ input: UpdateMonitoringRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> UpdateMonitoringResponse {
        try await self.client.execute(
            operation: "UpdateMonitoring", 
            path: "/v1/clusters/{ClusterArn}/monitoring", 
            httpMethod: .PUT, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Updates the monitoring settings for the cluster. You can use this operation to specify which Apache Kafka metrics you want Amazon MSK to send to Amazon CloudWatch. You can also specify settings for open monitoring with Prometheus.
    ///
    /// Parameters:
    ///   - clusterArn: The Amazon Resource Name (ARN) that uniquely identifies the cluster.
    ///   - currentVersion: The version of the MSK cluster to update. Cluster versions aren't simple numbers. You can describe an MSK cluster to find its version. When this update operation is successful, it generates a new cluster version.
    ///   - enhancedMonitoring: Specifies which Apache Kafka metrics Amazon MSK gathers and sends to Amazon CloudWatch for this cluster.
    ///   - loggingInfo: 
    ///   - openMonitoring: The settings for open monitoring.
    ///   - logger: Logger use during operation
    @inlinable
    public func updateMonitoring(
        clusterArn: String,
        currentVersion: String? = nil,
        enhancedMonitoring: EnhancedMonitoring? = nil,
        loggingInfo: LoggingInfo? = nil,
        openMonitoring: OpenMonitoringInfo? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> UpdateMonitoringResponse {
        let input = UpdateMonitoringRequest(
            clusterArn: clusterArn, 
            currentVersion: currentVersion, 
            enhancedMonitoring: enhancedMonitoring, 
            loggingInfo: loggingInfo, 
            openMonitoring: openMonitoring
        )
        return try await self.updateMonitoring(input, logger: logger)
    }

    /// Updates replication info of a replicator.
    @Sendable
    @inlinable
    public func updateReplicationInfo(_ input: UpdateReplicationInfoRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> UpdateReplicationInfoResponse {
        try await self.client.execute(
            operation: "UpdateReplicationInfo", 
            path: "/replication/v1/replicators/{ReplicatorArn}/replication-info", 
            httpMethod: .PUT, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Updates replication info of a replicator.
    ///
    /// Parameters:
    ///   - consumerGroupReplication: Updated consumer group replication information.
    ///   - currentVersion: Current replicator version.
    ///   - replicatorArn: The Amazon Resource Name (ARN) of the replicator to be updated.
    ///   - sourceKafkaClusterArn: The ARN of the source Kafka cluster.
    ///   - targetKafkaClusterArn: The ARN of the target Kafka cluster.
    ///   - topicReplication: Updated topic replication information.
    ///   - logger: Logger use during operation
    @inlinable
    public func updateReplicationInfo(
        consumerGroupReplication: ConsumerGroupReplicationUpdate? = nil,
        currentVersion: String? = nil,
        replicatorArn: String,
        sourceKafkaClusterArn: String? = nil,
        targetKafkaClusterArn: String? = nil,
        topicReplication: TopicReplicationUpdate? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> UpdateReplicationInfoResponse {
        let input = UpdateReplicationInfoRequest(
            consumerGroupReplication: consumerGroupReplication, 
            currentVersion: currentVersion, 
            replicatorArn: replicatorArn, 
            sourceKafkaClusterArn: sourceKafkaClusterArn, 
            targetKafkaClusterArn: targetKafkaClusterArn, 
            topicReplication: topicReplication
        )
        return try await self.updateReplicationInfo(input, logger: logger)
    }

    /// Updates the security settings for the cluster. You can use this operation to specify encryption and authentication on existing clusters.
    @Sendable
    @inlinable
    public func updateSecurity(_ input: UpdateSecurityRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> UpdateSecurityResponse {
        try await self.client.execute(
            operation: "UpdateSecurity", 
            path: "/v1/clusters/{ClusterArn}/security", 
            httpMethod: .PATCH, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Updates the security settings for the cluster. You can use this operation to specify encryption and authentication on existing clusters.
    ///
    /// Parameters:
    ///   - clientAuthentication: Includes all client authentication related information.
    ///   - clusterArn: The Amazon Resource Name (ARN) that uniquely identifies the cluster.
    ///   - currentVersion: The version of the MSK cluster to update. Cluster versions aren't simple numbers. You can describe an MSK cluster to find its version. When this update operation is successful, it generates a new cluster version.
    ///   - encryptionInfo: Includes all encryption-related information.
    ///   - logger: Logger use during operation
    @inlinable
    public func updateSecurity(
        clientAuthentication: ClientAuthentication? = nil,
        clusterArn: String,
        currentVersion: String? = nil,
        encryptionInfo: EncryptionInfo? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> UpdateSecurityResponse {
        let input = UpdateSecurityRequest(
            clientAuthentication: clientAuthentication, 
            clusterArn: clusterArn, 
            currentVersion: currentVersion, 
            encryptionInfo: encryptionInfo
        )
        return try await self.updateSecurity(input, logger: logger)
    }

    /// Updates cluster broker volume size (or) sets cluster storage mode to TIERED.
    @Sendable
    @inlinable
    public func updateStorage(_ input: UpdateStorageRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> UpdateStorageResponse {
        try await self.client.execute(
            operation: "UpdateStorage", 
            path: "/v1/clusters/{ClusterArn}/storage", 
            httpMethod: .PUT, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Updates cluster broker volume size (or) sets cluster storage mode to TIERED.
    ///
    /// Parameters:
    ///   - clusterArn: The Amazon Resource Name (ARN) of the cluster to be updated.
    ///   - currentVersion: The version of cluster to update from. A successful operation will then generate a new version.
    ///   - provisionedThroughput: EBS volume provisioned throughput information.
    ///   - storageMode: Controls storage mode for supported storage tiers.
    ///   - volumeSizeGB: size of the EBS volume to update.
    ///   - logger: Logger use during operation
    @inlinable
    public func updateStorage(
        clusterArn: String,
        currentVersion: String? = nil,
        provisionedThroughput: ProvisionedThroughput? = nil,
        storageMode: StorageMode? = nil,
        volumeSizeGB: Int? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> UpdateStorageResponse {
        let input = UpdateStorageRequest(
            clusterArn: clusterArn, 
            currentVersion: currentVersion, 
            provisionedThroughput: provisionedThroughput, 
            storageMode: storageMode, 
            volumeSizeGB: volumeSizeGB
        )
        return try await self.updateStorage(input, logger: logger)
    }
}

extension Kafka {
    /// Initializer required by `AWSService.with(middlewares:timeout:byteBufferAllocator:options)`. You are not able to use this initializer directly as there are not public
    /// initializers for `AWSServiceConfig.Patch`. Please use `AWSService.with(middlewares:timeout:byteBufferAllocator:options)` instead.
    public init(from: Kafka, patch: AWSServiceConfig.Patch) {
        self.client = from.client
        self.config = from.config.with(patch: patch)
    }
}

// MARK: Paginators

@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension Kafka {
    /// Return PaginatorSequence for operation ``listClientVpcConnections(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func listClientVpcConnectionsPaginator(
        _ input: ListClientVpcConnectionsRequest,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<ListClientVpcConnectionsRequest, ListClientVpcConnectionsResponse> {
        return .init(
            input: input,
            command: self.listClientVpcConnections,
            inputKey: \ListClientVpcConnectionsRequest.nextToken,
            outputKey: \ListClientVpcConnectionsResponse.nextToken,
            logger: logger
        )
    }
    /// Return PaginatorSequence for operation ``listClientVpcConnections(_:logger:)``.
    ///
    /// - Parameters:
    ///   - clusterArn: The Amazon Resource Name (ARN) of the cluster.
    ///   - maxResults: The maximum number of results to return in the response. If there are more results, the response includes a NextToken parameter.
    ///   - logger: Logger used for logging
    @inlinable
    public func listClientVpcConnectionsPaginator(
        clusterArn: String,
        maxResults: Int? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) -> AWSClient.PaginatorSequence<ListClientVpcConnectionsRequest, ListClientVpcConnectionsResponse> {
        let input = ListClientVpcConnectionsRequest(
            clusterArn: clusterArn, 
            maxResults: maxResults
        )
        return self.listClientVpcConnectionsPaginator(input, logger: logger)
    }

    /// Return PaginatorSequence for operation ``listClusterOperations(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func listClusterOperationsPaginator(
        _ input: ListClusterOperationsRequest,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<ListClusterOperationsRequest, ListClusterOperationsResponse> {
        return .init(
            input: input,
            command: self.listClusterOperations,
            inputKey: \ListClusterOperationsRequest.nextToken,
            outputKey: \ListClusterOperationsResponse.nextToken,
            logger: logger
        )
    }
    /// Return PaginatorSequence for operation ``listClusterOperations(_:logger:)``.
    ///
    /// - Parameters:
    ///   - clusterArn: The Amazon Resource Name (ARN) that uniquely identifies the cluster.
    ///   - maxResults: The maximum number of results to return in the response. If there are more results, the response includes a NextToken parameter.
    ///   - logger: Logger used for logging
    @inlinable
    public func listClusterOperationsPaginator(
        clusterArn: String,
        maxResults: Int? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) -> AWSClient.PaginatorSequence<ListClusterOperationsRequest, ListClusterOperationsResponse> {
        let input = ListClusterOperationsRequest(
            clusterArn: clusterArn, 
            maxResults: maxResults
        )
        return self.listClusterOperationsPaginator(input, logger: logger)
    }

    /// Return PaginatorSequence for operation ``listClusterOperationsV2(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func listClusterOperationsV2Paginator(
        _ input: ListClusterOperationsV2Request,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<ListClusterOperationsV2Request, ListClusterOperationsV2Response> {
        return .init(
            input: input,
            command: self.listClusterOperationsV2,
            inputKey: \ListClusterOperationsV2Request.nextToken,
            outputKey: \ListClusterOperationsV2Response.nextToken,
            logger: logger
        )
    }
    /// Return PaginatorSequence for operation ``listClusterOperationsV2(_:logger:)``.
    ///
    /// - Parameters:
    ///   - clusterArn: The arn of the cluster whose operations are being requested.
    ///   - maxResults: The maxResults of the query.
    ///   - logger: Logger used for logging
    @inlinable
    public func listClusterOperationsV2Paginator(
        clusterArn: String,
        maxResults: Int? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) -> AWSClient.PaginatorSequence<ListClusterOperationsV2Request, ListClusterOperationsV2Response> {
        let input = ListClusterOperationsV2Request(
            clusterArn: clusterArn, 
            maxResults: maxResults
        )
        return self.listClusterOperationsV2Paginator(input, logger: logger)
    }

    /// Return PaginatorSequence for operation ``listClusters(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func listClustersPaginator(
        _ input: ListClustersRequest,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<ListClustersRequest, ListClustersResponse> {
        return .init(
            input: input,
            command: self.listClusters,
            inputKey: \ListClustersRequest.nextToken,
            outputKey: \ListClustersResponse.nextToken,
            logger: logger
        )
    }
    /// Return PaginatorSequence for operation ``listClusters(_:logger:)``.
    ///
    /// - Parameters:
    ///   - clusterNameFilter: Specify a prefix of the name of the clusters that you want to list. The service lists all the clusters whose names start with this prefix.
    ///   - maxResults: The maximum number of results to return in the response. If there are more results, the response includes a NextToken parameter.
    ///   - logger: Logger used for logging
    @inlinable
    public func listClustersPaginator(
        clusterNameFilter: String? = nil,
        maxResults: Int? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) -> AWSClient.PaginatorSequence<ListClustersRequest, ListClustersResponse> {
        let input = ListClustersRequest(
            clusterNameFilter: clusterNameFilter, 
            maxResults: maxResults
        )
        return self.listClustersPaginator(input, logger: logger)
    }

    /// Return PaginatorSequence for operation ``listClustersV2(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func listClustersV2Paginator(
        _ input: ListClustersV2Request,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<ListClustersV2Request, ListClustersV2Response> {
        return .init(
            input: input,
            command: self.listClustersV2,
            inputKey: \ListClustersV2Request.nextToken,
            outputKey: \ListClustersV2Response.nextToken,
            logger: logger
        )
    }
    /// Return PaginatorSequence for operation ``listClustersV2(_:logger:)``.
    ///
    /// - Parameters:
    ///   - clusterNameFilter: Specify a prefix of the names of the clusters that you want to list. The service lists all the clusters whose names start with this prefix.
    ///   - clusterTypeFilter: Specify either PROVISIONED or SERVERLESS.
    ///   - maxResults: The maximum number of results to return in the response. If there are more results, the response includes a NextToken parameter.
    ///   - logger: Logger used for logging
    @inlinable
    public func listClustersV2Paginator(
        clusterNameFilter: String? = nil,
        clusterTypeFilter: String? = nil,
        maxResults: Int? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) -> AWSClient.PaginatorSequence<ListClustersV2Request, ListClustersV2Response> {
        let input = ListClustersV2Request(
            clusterNameFilter: clusterNameFilter, 
            clusterTypeFilter: clusterTypeFilter, 
            maxResults: maxResults
        )
        return self.listClustersV2Paginator(input, logger: logger)
    }

    /// Return PaginatorSequence for operation ``listConfigurationRevisions(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func listConfigurationRevisionsPaginator(
        _ input: ListConfigurationRevisionsRequest,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<ListConfigurationRevisionsRequest, ListConfigurationRevisionsResponse> {
        return .init(
            input: input,
            command: self.listConfigurationRevisions,
            inputKey: \ListConfigurationRevisionsRequest.nextToken,
            outputKey: \ListConfigurationRevisionsResponse.nextToken,
            logger: logger
        )
    }
    /// Return PaginatorSequence for operation ``listConfigurationRevisions(_:logger:)``.
    ///
    /// - Parameters:
    ///   - arn: The Amazon Resource Name (ARN) that uniquely identifies an MSK configuration and all of its revisions.
    ///   - maxResults: The maximum number of results to return in the response. If there are more results, the response includes a NextToken parameter.
    ///   - logger: Logger used for logging
    @inlinable
    public func listConfigurationRevisionsPaginator(
        arn: String,
        maxResults: Int? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) -> AWSClient.PaginatorSequence<ListConfigurationRevisionsRequest, ListConfigurationRevisionsResponse> {
        let input = ListConfigurationRevisionsRequest(
            arn: arn, 
            maxResults: maxResults
        )
        return self.listConfigurationRevisionsPaginator(input, logger: logger)
    }

    /// Return PaginatorSequence for operation ``listConfigurations(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func listConfigurationsPaginator(
        _ input: ListConfigurationsRequest,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<ListConfigurationsRequest, ListConfigurationsResponse> {
        return .init(
            input: input,
            command: self.listConfigurations,
            inputKey: \ListConfigurationsRequest.nextToken,
            outputKey: \ListConfigurationsResponse.nextToken,
            logger: logger
        )
    }
    /// Return PaginatorSequence for operation ``listConfigurations(_:logger:)``.
    ///
    /// - Parameters:
    ///   - maxResults: The maximum number of results to return in the response. If there are more results, the response includes a NextToken parameter.
    ///   - logger: Logger used for logging
    @inlinable
    public func listConfigurationsPaginator(
        maxResults: Int? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) -> AWSClient.PaginatorSequence<ListConfigurationsRequest, ListConfigurationsResponse> {
        let input = ListConfigurationsRequest(
            maxResults: maxResults
        )
        return self.listConfigurationsPaginator(input, logger: logger)
    }

    /// Return PaginatorSequence for operation ``listKafkaVersions(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func listKafkaVersionsPaginator(
        _ input: ListKafkaVersionsRequest,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<ListKafkaVersionsRequest, ListKafkaVersionsResponse> {
        return .init(
            input: input,
            command: self.listKafkaVersions,
            inputKey: \ListKafkaVersionsRequest.nextToken,
            outputKey: \ListKafkaVersionsResponse.nextToken,
            logger: logger
        )
    }
    /// Return PaginatorSequence for operation ``listKafkaVersions(_:logger:)``.
    ///
    /// - Parameters:
    ///   - maxResults: The maximum number of results to return in the response. If there are more results, the response includes a NextToken parameter.
    ///   - logger: Logger used for logging
    @inlinable
    public func listKafkaVersionsPaginator(
        maxResults: Int? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) -> AWSClient.PaginatorSequence<ListKafkaVersionsRequest, ListKafkaVersionsResponse> {
        let input = ListKafkaVersionsRequest(
            maxResults: maxResults
        )
        return self.listKafkaVersionsPaginator(input, logger: logger)
    }

    /// Return PaginatorSequence for operation ``listNodes(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func listNodesPaginator(
        _ input: ListNodesRequest,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<ListNodesRequest, ListNodesResponse> {
        return .init(
            input: input,
            command: self.listNodes,
            inputKey: \ListNodesRequest.nextToken,
            outputKey: \ListNodesResponse.nextToken,
            logger: logger
        )
    }
    /// Return PaginatorSequence for operation ``listNodes(_:logger:)``.
    ///
    /// - Parameters:
    ///   - clusterArn: The Amazon Resource Name (ARN) that uniquely identifies the cluster.
    ///   - maxResults: The maximum number of results to return in the response. If there are more results, the response includes a NextToken parameter.
    ///   - logger: Logger used for logging
    @inlinable
    public func listNodesPaginator(
        clusterArn: String,
        maxResults: Int? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) -> AWSClient.PaginatorSequence<ListNodesRequest, ListNodesResponse> {
        let input = ListNodesRequest(
            clusterArn: clusterArn, 
            maxResults: maxResults
        )
        return self.listNodesPaginator(input, logger: logger)
    }

    /// Return PaginatorSequence for operation ``listReplicators(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func listReplicatorsPaginator(
        _ input: ListReplicatorsRequest,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<ListReplicatorsRequest, ListReplicatorsResponse> {
        return .init(
            input: input,
            command: self.listReplicators,
            inputKey: \ListReplicatorsRequest.nextToken,
            outputKey: \ListReplicatorsResponse.nextToken,
            logger: logger
        )
    }
    /// Return PaginatorSequence for operation ``listReplicators(_:logger:)``.
    ///
    /// - Parameters:
    ///   - maxResults: The maximum number of results to return in the response. If there are more results, the response includes a NextToken parameter.
    ///   - replicatorNameFilter: Returns replicators starting with given name.
    ///   - logger: Logger used for logging
    @inlinable
    public func listReplicatorsPaginator(
        maxResults: Int? = nil,
        replicatorNameFilter: String? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) -> AWSClient.PaginatorSequence<ListReplicatorsRequest, ListReplicatorsResponse> {
        let input = ListReplicatorsRequest(
            maxResults: maxResults, 
            replicatorNameFilter: replicatorNameFilter
        )
        return self.listReplicatorsPaginator(input, logger: logger)
    }

    /// Return PaginatorSequence for operation ``listScramSecrets(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func listScramSecretsPaginator(
        _ input: ListScramSecretsRequest,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<ListScramSecretsRequest, ListScramSecretsResponse> {
        return .init(
            input: input,
            command: self.listScramSecrets,
            inputKey: \ListScramSecretsRequest.nextToken,
            outputKey: \ListScramSecretsResponse.nextToken,
            logger: logger
        )
    }
    /// Return PaginatorSequence for operation ``listScramSecrets(_:logger:)``.
    ///
    /// - Parameters:
    ///   - clusterArn: The arn of the cluster.
    ///   - maxResults: The maxResults of the query.
    ///   - logger: Logger used for logging
    @inlinable
    public func listScramSecretsPaginator(
        clusterArn: String,
        maxResults: Int? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) -> AWSClient.PaginatorSequence<ListScramSecretsRequest, ListScramSecretsResponse> {
        let input = ListScramSecretsRequest(
            clusterArn: clusterArn, 
            maxResults: maxResults
        )
        return self.listScramSecretsPaginator(input, logger: logger)
    }

    /// Return PaginatorSequence for operation ``listVpcConnections(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func listVpcConnectionsPaginator(
        _ input: ListVpcConnectionsRequest,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<ListVpcConnectionsRequest, ListVpcConnectionsResponse> {
        return .init(
            input: input,
            command: self.listVpcConnections,
            inputKey: \ListVpcConnectionsRequest.nextToken,
            outputKey: \ListVpcConnectionsResponse.nextToken,
            logger: logger
        )
    }
    /// Return PaginatorSequence for operation ``listVpcConnections(_:logger:)``.
    ///
    /// - Parameters:
    ///   - maxResults: The maximum number of results to return in the response. If there are more results, the response includes a NextToken parameter.
    ///   - logger: Logger used for logging
    @inlinable
    public func listVpcConnectionsPaginator(
        maxResults: Int? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) -> AWSClient.PaginatorSequence<ListVpcConnectionsRequest, ListVpcConnectionsResponse> {
        let input = ListVpcConnectionsRequest(
            maxResults: maxResults
        )
        return self.listVpcConnectionsPaginator(input, logger: logger)
    }
}

extension Kafka.ListClientVpcConnectionsRequest: AWSPaginateToken {
    @inlinable
    public func usingPaginationToken(_ token: String) -> Kafka.ListClientVpcConnectionsRequest {
        return .init(
            clusterArn: self.clusterArn,
            maxResults: self.maxResults,
            nextToken: token
        )
    }
}

extension Kafka.ListClusterOperationsRequest: AWSPaginateToken {
    @inlinable
    public func usingPaginationToken(_ token: String) -> Kafka.ListClusterOperationsRequest {
        return .init(
            clusterArn: self.clusterArn,
            maxResults: self.maxResults,
            nextToken: token
        )
    }
}

extension Kafka.ListClusterOperationsV2Request: AWSPaginateToken {
    @inlinable
    public func usingPaginationToken(_ token: String) -> Kafka.ListClusterOperationsV2Request {
        return .init(
            clusterArn: self.clusterArn,
            maxResults: self.maxResults,
            nextToken: token
        )
    }
}

extension Kafka.ListClustersRequest: AWSPaginateToken {
    @inlinable
    public func usingPaginationToken(_ token: String) -> Kafka.ListClustersRequest {
        return .init(
            clusterNameFilter: self.clusterNameFilter,
            maxResults: self.maxResults,
            nextToken: token
        )
    }
}

extension Kafka.ListClustersV2Request: AWSPaginateToken {
    @inlinable
    public func usingPaginationToken(_ token: String) -> Kafka.ListClustersV2Request {
        return .init(
            clusterNameFilter: self.clusterNameFilter,
            clusterTypeFilter: self.clusterTypeFilter,
            maxResults: self.maxResults,
            nextToken: token
        )
    }
}

extension Kafka.ListConfigurationRevisionsRequest: AWSPaginateToken {
    @inlinable
    public func usingPaginationToken(_ token: String) -> Kafka.ListConfigurationRevisionsRequest {
        return .init(
            arn: self.arn,
            maxResults: self.maxResults,
            nextToken: token
        )
    }
}

extension Kafka.ListConfigurationsRequest: AWSPaginateToken {
    @inlinable
    public func usingPaginationToken(_ token: String) -> Kafka.ListConfigurationsRequest {
        return .init(
            maxResults: self.maxResults,
            nextToken: token
        )
    }
}

extension Kafka.ListKafkaVersionsRequest: AWSPaginateToken {
    @inlinable
    public func usingPaginationToken(_ token: String) -> Kafka.ListKafkaVersionsRequest {
        return .init(
            maxResults: self.maxResults,
            nextToken: token
        )
    }
}

extension Kafka.ListNodesRequest: AWSPaginateToken {
    @inlinable
    public func usingPaginationToken(_ token: String) -> Kafka.ListNodesRequest {
        return .init(
            clusterArn: self.clusterArn,
            maxResults: self.maxResults,
            nextToken: token
        )
    }
}

extension Kafka.ListReplicatorsRequest: AWSPaginateToken {
    @inlinable
    public func usingPaginationToken(_ token: String) -> Kafka.ListReplicatorsRequest {
        return .init(
            maxResults: self.maxResults,
            nextToken: token,
            replicatorNameFilter: self.replicatorNameFilter
        )
    }
}

extension Kafka.ListScramSecretsRequest: AWSPaginateToken {
    @inlinable
    public func usingPaginationToken(_ token: String) -> Kafka.ListScramSecretsRequest {
        return .init(
            clusterArn: self.clusterArn,
            maxResults: self.maxResults,
            nextToken: token
        )
    }
}

extension Kafka.ListVpcConnectionsRequest: AWSPaginateToken {
    @inlinable
    public func usingPaginationToken(_ token: String) -> Kafka.ListVpcConnectionsRequest {
        return .init(
            maxResults: self.maxResults,
            nextToken: token
        )
    }
}
