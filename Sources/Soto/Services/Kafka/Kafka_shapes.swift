//===----------------------------------------------------------------------===//
//
// This source file is part of the Soto for AWS open source project
//
// Copyright (c) 2017-2022 the Soto project authors
// Licensed under Apache License v2.0
//
// See LICENSE.txt for license information
// See CONTRIBUTORS.txt for the list of Soto project authors
//
// SPDX-License-Identifier: Apache-2.0
//
//===----------------------------------------------------------------------===//

// THIS FILE IS AUTOMATICALLY GENERATED by https://github.com/soto-project/soto-codegenerator.
// DO NOT EDIT.

import Foundation
import SotoCore

extension Kafka {
    // MARK: Enums

    public enum BrokerAZDistribution: String, CustomStringConvertible, Codable, _SotoSendable {
        case `default` = "DEFAULT"
        public var description: String { return self.rawValue }
    }

    public enum ClientBroker: String, CustomStringConvertible, Codable, _SotoSendable {
        case plaintext = "PLAINTEXT"
        case tls = "TLS"
        case tlsPlaintext = "TLS_PLAINTEXT"
        public var description: String { return self.rawValue }
    }

    public enum ClusterState: String, CustomStringConvertible, Codable, _SotoSendable {
        case active = "ACTIVE"
        case creating = "CREATING"
        case deleting = "DELETING"
        case failed = "FAILED"
        case healing = "HEALING"
        case maintenance = "MAINTENANCE"
        case rebootingBroker = "REBOOTING_BROKER"
        case updating = "UPDATING"
        public var description: String { return self.rawValue }
    }

    public enum ClusterType: String, CustomStringConvertible, Codable, _SotoSendable {
        case provisioned = "PROVISIONED"
        case serverless = "SERVERLESS"
        public var description: String { return self.rawValue }
    }

    public enum ConfigurationState: String, CustomStringConvertible, Codable, _SotoSendable {
        case active = "ACTIVE"
        case deleteFailed = "DELETE_FAILED"
        case deleting = "DELETING"
        public var description: String { return self.rawValue }
    }

    public enum EnhancedMonitoring: String, CustomStringConvertible, Codable, _SotoSendable {
        case `default` = "DEFAULT"
        case perBroker = "PER_BROKER"
        case perTopicPerBroker = "PER_TOPIC_PER_BROKER"
        case perTopicPerPartition = "PER_TOPIC_PER_PARTITION"
        public var description: String { return self.rawValue }
    }

    public enum KafkaVersionStatus: String, CustomStringConvertible, Codable, _SotoSendable {
        case active = "ACTIVE"
        case deprecated = "DEPRECATED"
        public var description: String { return self.rawValue }
    }

    public enum NodeType: String, CustomStringConvertible, Codable, _SotoSendable {
        case broker = "BROKER"
        public var description: String { return self.rawValue }
    }

    public enum StorageMode: String, CustomStringConvertible, Codable, _SotoSendable {
        case local = "LOCAL"
        case tiered = "TIERED"
        public var description: String { return self.rawValue }
    }

    // MARK: Shapes

    public struct BatchAssociateScramSecretRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "clusterArn", location: .uri("ClusterArn"))
        ]

        /// The Amazon Resource Name (ARN) of the cluster to be updated.
        public let clusterArn: String
        /// List of AWS Secrets Manager secret ARNs.
        public let secretArnList: [String]

        public init(clusterArn: String, secretArnList: [String]) {
            self.clusterArn = clusterArn
            self.secretArnList = secretArnList
        }

        private enum CodingKeys: String, CodingKey {
            case secretArnList
        }
    }

    public struct BatchAssociateScramSecretResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the cluster.
        public let clusterArn: String?
        /// List of errors when associating secrets to cluster.
        public let unprocessedScramSecrets: [UnprocessedScramSecret]?

        public init(clusterArn: String? = nil, unprocessedScramSecrets: [UnprocessedScramSecret]? = nil) {
            self.clusterArn = clusterArn
            self.unprocessedScramSecrets = unprocessedScramSecrets
        }

        private enum CodingKeys: String, CodingKey {
            case clusterArn
            case unprocessedScramSecrets
        }
    }

    public struct BatchDisassociateScramSecretRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "clusterArn", location: .uri("ClusterArn"))
        ]

        /// The Amazon Resource Name (ARN) of the cluster to be updated.
        public let clusterArn: String
        /// List of AWS Secrets Manager secret ARNs.
        public let secretArnList: [String]

        public init(clusterArn: String, secretArnList: [String]) {
            self.clusterArn = clusterArn
            self.secretArnList = secretArnList
        }

        private enum CodingKeys: String, CodingKey {
            case secretArnList
        }
    }

    public struct BatchDisassociateScramSecretResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the cluster.
        public let clusterArn: String?
        /// List of errors when disassociating secrets to cluster.
        public let unprocessedScramSecrets: [UnprocessedScramSecret]?

        public init(clusterArn: String? = nil, unprocessedScramSecrets: [UnprocessedScramSecret]? = nil) {
            self.clusterArn = clusterArn
            self.unprocessedScramSecrets = unprocessedScramSecrets
        }

        private enum CodingKeys: String, CodingKey {
            case clusterArn
            case unprocessedScramSecrets
        }
    }

    public struct BrokerEBSVolumeInfo: AWSEncodableShape & AWSDecodableShape {
        /// The ID of the broker to update.
        public let kafkaBrokerNodeId: String
        /// EBS volume provisioned throughput information.
        public let provisionedThroughput: ProvisionedThroughput?
        /// Size of the EBS volume to update.
        public let volumeSizeGB: Int?

        public init(kafkaBrokerNodeId: String, provisionedThroughput: ProvisionedThroughput? = nil, volumeSizeGB: Int? = nil) {
            self.kafkaBrokerNodeId = kafkaBrokerNodeId
            self.provisionedThroughput = provisionedThroughput
            self.volumeSizeGB = volumeSizeGB
        }

        private enum CodingKeys: String, CodingKey {
            case kafkaBrokerNodeId
            case provisionedThroughput
            case volumeSizeGB
        }
    }

    public struct BrokerLogs: AWSEncodableShape & AWSDecodableShape {
        public let cloudWatchLogs: CloudWatchLogs?
        public let firehose: Firehose?
        public let s3: S3?

        public init(cloudWatchLogs: CloudWatchLogs? = nil, firehose: Firehose? = nil, s3: S3? = nil) {
            self.cloudWatchLogs = cloudWatchLogs
            self.firehose = firehose
            self.s3 = s3
        }

        private enum CodingKeys: String, CodingKey {
            case cloudWatchLogs
            case firehose
            case s3
        }
    }

    public struct BrokerNodeGroupInfo: AWSEncodableShape & AWSDecodableShape {
        /// The distribution of broker nodes across Availability Zones. This is an optional parameter. If you don't specify it, Amazon MSK gives it the value DEFAULT. You can also explicitly set this parameter to the value DEFAULT. No other values are currently allowed. Amazon MSK distributes the broker nodes evenly across the Availability Zones that correspond to the subnets you provide when you create the cluster.
        public let brokerAZDistribution: BrokerAZDistribution?
        /// The list of subnets to connect to in the client virtual private cloud (VPC). AWS creates elastic network interfaces inside these subnets. Client applications use elastic network interfaces to produce and consume data. Client subnets can't occupy the Availability Zone with ID use use1-az3.
        public let clientSubnets: [String]
        /// Information about the broker access configuration.
        public let connectivityInfo: ConnectivityInfo?
        /// The type of Amazon EC2 instances to use for Apache Kafka brokers. The following instance types are allowed: kafka.m5.large, kafka.m5.xlarge, kafka.m5.2xlarge,
        /// kafka.m5.4xlarge, kafka.m5.12xlarge, and kafka.m5.24xlarge.
        public let instanceType: String
        /// The AWS security groups to associate with the elastic network interfaces in order to specify who can connect to and communicate with the Amazon MSK cluster. If you don't specify a security group, Amazon MSK uses the default security group associated with the VPC.
        public let securityGroups: [String]?
        /// Contains information about storage volumes attached to MSK broker nodes.
        public let storageInfo: StorageInfo?

        public init(brokerAZDistribution: BrokerAZDistribution? = nil, clientSubnets: [String], connectivityInfo: ConnectivityInfo? = nil, instanceType: String, securityGroups: [String]? = nil, storageInfo: StorageInfo? = nil) {
            self.brokerAZDistribution = brokerAZDistribution
            self.clientSubnets = clientSubnets
            self.connectivityInfo = connectivityInfo
            self.instanceType = instanceType
            self.securityGroups = securityGroups
            self.storageInfo = storageInfo
        }

        public func validate(name: String) throws {
            try self.validate(self.instanceType, name: "instanceType", parent: name, max: 32)
            try self.validate(self.instanceType, name: "instanceType", parent: name, min: 5)
            try self.storageInfo?.validate(name: "\(name).storageInfo")
        }

        private enum CodingKeys: String, CodingKey {
            case brokerAZDistribution
            case clientSubnets
            case connectivityInfo
            case instanceType
            case securityGroups
            case storageInfo
        }
    }

    public struct BrokerNodeInfo: AWSDecodableShape {
        /// The attached elastic network interface of the broker.
        public let attachedENIId: String?
        /// The ID of the broker.
        public let brokerId: Double?
        /// The client subnet to which this broker node belongs.
        public let clientSubnet: String?
        /// The virtual private cloud (VPC) of the client.
        public let clientVpcIpAddress: String?
        /// Information about the version of software currently deployed on the Apache Kafka brokers in the cluster.
        public let currentBrokerSoftwareInfo: BrokerSoftwareInfo?
        /// Endpoints for accessing the broker.
        public let endpoints: [String]?

        public init(attachedENIId: String? = nil, brokerId: Double? = nil, clientSubnet: String? = nil, clientVpcIpAddress: String? = nil, currentBrokerSoftwareInfo: BrokerSoftwareInfo? = nil, endpoints: [String]? = nil) {
            self.attachedENIId = attachedENIId
            self.brokerId = brokerId
            self.clientSubnet = clientSubnet
            self.clientVpcIpAddress = clientVpcIpAddress
            self.currentBrokerSoftwareInfo = currentBrokerSoftwareInfo
            self.endpoints = endpoints
        }

        private enum CodingKeys: String, CodingKey {
            case attachedENIId
            case brokerId
            case clientSubnet
            case clientVpcIpAddress
            case currentBrokerSoftwareInfo
            case endpoints
        }
    }

    public struct BrokerSoftwareInfo: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the configuration used for the cluster. This field isn't visible in this preview release.
        public let configurationArn: String?
        /// The revision of the configuration to use. This field isn't visible in this preview release.
        public let configurationRevision: Int64?
        /// The version of Apache Kafka.
        public let kafkaVersion: String?

        public init(configurationArn: String? = nil, configurationRevision: Int64? = nil, kafkaVersion: String? = nil) {
            self.configurationArn = configurationArn
            self.configurationRevision = configurationRevision
            self.kafkaVersion = kafkaVersion
        }

        private enum CodingKeys: String, CodingKey {
            case configurationArn
            case configurationRevision
            case kafkaVersion
        }
    }

    public struct ClientAuthentication: AWSEncodableShape & AWSDecodableShape {
        /// Details for ClientAuthentication using SASL.
        public let sasl: Sasl?
        /// Details for ClientAuthentication using TLS.
        public let tls: Tls?
        /// Contains information about unauthenticated traffic to the cluster.
        public let unauthenticated: Unauthenticated?

        public init(sasl: Sasl? = nil, tls: Tls? = nil, unauthenticated: Unauthenticated? = nil) {
            self.sasl = sasl
            self.tls = tls
            self.unauthenticated = unauthenticated
        }

        private enum CodingKeys: String, CodingKey {
            case sasl
            case tls
            case unauthenticated
        }
    }

    public struct CloudWatchLogs: AWSEncodableShape & AWSDecodableShape {
        public let enabled: Bool
        public let logGroup: String?

        public init(enabled: Bool, logGroup: String? = nil) {
            self.enabled = enabled
            self.logGroup = logGroup
        }

        private enum CodingKeys: String, CodingKey {
            case enabled
            case logGroup
        }
    }

    public struct Cluster: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) that uniquely identifies a cluster operation.
        public let activeOperationArn: String?
        /// The Amazon Resource Name (ARN) that uniquely identifies the cluster.
        public let clusterArn: String?
        /// The name of the cluster.
        public let clusterName: String?
        /// Cluster Type.
        public let clusterType: ClusterType?
        /// The time when the cluster was created.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var creationTime: Date?
        /// The current version of the MSK cluster.
        public let currentVersion: String?
        /// Information about the provisioned cluster.
        public let provisioned: Provisioned?
        /// Information about the serverless cluster.
        public let serverless: Serverless?
        /// The state of the cluster. The possible states are ACTIVE, CREATING, DELETING, FAILED, HEALING, MAINTENANCE, REBOOTING_BROKER, and UPDATING.
        public let state: ClusterState?
        /// State Info for the Amazon MSK cluster.
        public let stateInfo: StateInfo?
        /// Tags attached to the cluster.
        public let tags: [String: String]?

        public init(activeOperationArn: String? = nil, clusterArn: String? = nil, clusterName: String? = nil, clusterType: ClusterType? = nil, creationTime: Date? = nil, currentVersion: String? = nil, provisioned: Provisioned? = nil, serverless: Serverless? = nil, state: ClusterState? = nil, stateInfo: StateInfo? = nil, tags: [String: String]? = nil) {
            self.activeOperationArn = activeOperationArn
            self.clusterArn = clusterArn
            self.clusterName = clusterName
            self.clusterType = clusterType
            self.creationTime = creationTime
            self.currentVersion = currentVersion
            self.provisioned = provisioned
            self.serverless = serverless
            self.state = state
            self.stateInfo = stateInfo
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case activeOperationArn
            case clusterArn
            case clusterName
            case clusterType
            case creationTime
            case currentVersion
            case provisioned
            case serverless
            case state
            case stateInfo
            case tags
        }
    }

    public struct ClusterInfo: AWSDecodableShape {
        /// Arn of active cluster operation.
        public let activeOperationArn: String?
        /// Information about the broker nodes.
        public let brokerNodeGroupInfo: BrokerNodeGroupInfo?
        /// Includes all client authentication information.
        public let clientAuthentication: ClientAuthentication?
        /// The Amazon Resource Name (ARN) that uniquely identifies the cluster.
        public let clusterArn: String?
        /// The name of the cluster.
        public let clusterName: String?
        /// The time when the cluster was created.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var creationTime: Date?
        /// Information about the version of software currently deployed on the Apache Kafka brokers in the cluster.
        public let currentBrokerSoftwareInfo: BrokerSoftwareInfo?
        /// The current version of the MSK cluster.
        public let currentVersion: String?
        /// Includes all encryption-related information.
        public let encryptionInfo: EncryptionInfo?
        /// Specifies which metrics are gathered for the MSK cluster. This property has the following possible values: DEFAULT, PER_BROKER, PER_TOPIC_PER_BROKER, and PER_TOPIC_PER_PARTITION. For a list of the metrics associated with each of these levels of monitoring, see Monitoring.
        public let enhancedMonitoring: EnhancedMonitoring?
        public let loggingInfo: LoggingInfo?
        /// The number of broker nodes in the cluster.
        public let numberOfBrokerNodes: Int?
        /// Settings for open monitoring using Prometheus.
        public let openMonitoring: OpenMonitoring?
        /// The state of the cluster. The possible states are ACTIVE, CREATING, DELETING, FAILED, HEALING, MAINTENANCE, REBOOTING_BROKER, and UPDATING.
        public let state: ClusterState?
        public let stateInfo: StateInfo?
        /// This controls storage mode for supported storage tiers.
        public let storageMode: StorageMode?
        /// Tags attached to the cluster.
        public let tags: [String: String]?
        /// The connection string to use to connect to the Apache ZooKeeper cluster.
        public let zookeeperConnectString: String?
        /// The connection string to use to connect to zookeeper cluster on Tls port.
        public let zookeeperConnectStringTls: String?

        public init(activeOperationArn: String? = nil, brokerNodeGroupInfo: BrokerNodeGroupInfo? = nil, clientAuthentication: ClientAuthentication? = nil, clusterArn: String? = nil, clusterName: String? = nil, creationTime: Date? = nil, currentBrokerSoftwareInfo: BrokerSoftwareInfo? = nil, currentVersion: String? = nil, encryptionInfo: EncryptionInfo? = nil, enhancedMonitoring: EnhancedMonitoring? = nil, loggingInfo: LoggingInfo? = nil, numberOfBrokerNodes: Int? = nil, openMonitoring: OpenMonitoring? = nil, state: ClusterState? = nil, stateInfo: StateInfo? = nil, storageMode: StorageMode? = nil, tags: [String: String]? = nil, zookeeperConnectString: String? = nil, zookeeperConnectStringTls: String? = nil) {
            self.activeOperationArn = activeOperationArn
            self.brokerNodeGroupInfo = brokerNodeGroupInfo
            self.clientAuthentication = clientAuthentication
            self.clusterArn = clusterArn
            self.clusterName = clusterName
            self.creationTime = creationTime
            self.currentBrokerSoftwareInfo = currentBrokerSoftwareInfo
            self.currentVersion = currentVersion
            self.encryptionInfo = encryptionInfo
            self.enhancedMonitoring = enhancedMonitoring
            self.loggingInfo = loggingInfo
            self.numberOfBrokerNodes = numberOfBrokerNodes
            self.openMonitoring = openMonitoring
            self.state = state
            self.stateInfo = stateInfo
            self.storageMode = storageMode
            self.tags = tags
            self.zookeeperConnectString = zookeeperConnectString
            self.zookeeperConnectStringTls = zookeeperConnectStringTls
        }

        private enum CodingKeys: String, CodingKey {
            case activeOperationArn
            case brokerNodeGroupInfo
            case clientAuthentication
            case clusterArn
            case clusterName
            case creationTime
            case currentBrokerSoftwareInfo
            case currentVersion
            case encryptionInfo
            case enhancedMonitoring
            case loggingInfo
            case numberOfBrokerNodes
            case openMonitoring
            case state
            case stateInfo
            case storageMode
            case tags
            case zookeeperConnectString
            case zookeeperConnectStringTls
        }
    }

    public struct ClusterOperationInfo: AWSDecodableShape {
        /// The ID of the API request that triggered this operation.
        public let clientRequestId: String?
        /// ARN of the cluster.
        public let clusterArn: String?
        /// The time that the operation was created.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var creationTime: Date?
        /// The time at which the operation finished.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var endTime: Date?
        /// Describes the error if the operation fails.
        public let errorInfo: ErrorInfo?
        /// ARN of the cluster operation.
        public let operationArn: String?
        /// State of the cluster operation.
        public let operationState: String?
        /// Steps completed during the operation.
        public let operationSteps: [ClusterOperationStep]?
        /// Type of the cluster operation.
        public let operationType: String?
        /// Information about cluster attributes before a cluster is updated.
        public let sourceClusterInfo: MutableClusterInfo?
        /// Information about cluster attributes after a cluster is updated.
        public let targetClusterInfo: MutableClusterInfo?

        public init(clientRequestId: String? = nil, clusterArn: String? = nil, creationTime: Date? = nil, endTime: Date? = nil, errorInfo: ErrorInfo? = nil, operationArn: String? = nil, operationState: String? = nil, operationSteps: [ClusterOperationStep]? = nil, operationType: String? = nil, sourceClusterInfo: MutableClusterInfo? = nil, targetClusterInfo: MutableClusterInfo? = nil) {
            self.clientRequestId = clientRequestId
            self.clusterArn = clusterArn
            self.creationTime = creationTime
            self.endTime = endTime
            self.errorInfo = errorInfo
            self.operationArn = operationArn
            self.operationState = operationState
            self.operationSteps = operationSteps
            self.operationType = operationType
            self.sourceClusterInfo = sourceClusterInfo
            self.targetClusterInfo = targetClusterInfo
        }

        private enum CodingKeys: String, CodingKey {
            case clientRequestId
            case clusterArn
            case creationTime
            case endTime
            case errorInfo
            case operationArn
            case operationState
            case operationSteps
            case operationType
            case sourceClusterInfo
            case targetClusterInfo
        }
    }

    public struct ClusterOperationStep: AWSDecodableShape {
        /// Information about the step and its status.
        public let stepInfo: ClusterOperationStepInfo?
        /// The name of the step.
        public let stepName: String?

        public init(stepInfo: ClusterOperationStepInfo? = nil, stepName: String? = nil) {
            self.stepInfo = stepInfo
            self.stepName = stepName
        }

        private enum CodingKeys: String, CodingKey {
            case stepInfo
            case stepName
        }
    }

    public struct ClusterOperationStepInfo: AWSDecodableShape {
        /// The steps current status.
        public let stepStatus: String?

        public init(stepStatus: String? = nil) {
            self.stepStatus = stepStatus
        }

        private enum CodingKeys: String, CodingKey {
            case stepStatus
        }
    }

    public struct CompatibleKafkaVersion: AWSDecodableShape {
        /// An Apache Kafka version.
        public let sourceVersion: String?
        /// A list of Apache Kafka versions.
        public let targetVersions: [String]?

        public init(sourceVersion: String? = nil, targetVersions: [String]? = nil) {
            self.sourceVersion = sourceVersion
            self.targetVersions = targetVersions
        }

        private enum CodingKeys: String, CodingKey {
            case sourceVersion
            case targetVersions
        }
    }

    public struct Configuration: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the configuration.
        public let arn: String
        /// The time when the configuration was created.
        @CustomCoding<ISO8601DateCoder>
        public var creationTime: Date
        /// The description of the configuration.
        public let description: String
        /// An array of the versions of Apache Kafka with which you can use this MSK configuration. You can use this configuration for an MSK cluster only if the Apache Kafka version specified for the cluster appears in this array.
        public let kafkaVersions: [String]
        /// Latest revision of the configuration.
        public let latestRevision: ConfigurationRevision
        /// The name of the configuration.
        public let name: String
        /// The state of the configuration. The possible states are ACTIVE, DELETING, and DELETE_FAILED.
        public let state: ConfigurationState

        public init(arn: String, creationTime: Date, description: String, kafkaVersions: [String], latestRevision: ConfigurationRevision, name: String, state: ConfigurationState) {
            self.arn = arn
            self.creationTime = creationTime
            self.description = description
            self.kafkaVersions = kafkaVersions
            self.latestRevision = latestRevision
            self.name = name
            self.state = state
        }

        private enum CodingKeys: String, CodingKey {
            case arn
            case creationTime
            case description
            case kafkaVersions
            case latestRevision
            case name
            case state
        }
    }

    public struct ConfigurationInfo: AWSEncodableShape & AWSDecodableShape {
        /// ARN of the configuration to use.
        public let arn: String
        /// The revision of the configuration to use.
        public let revision: Int64

        public init(arn: String, revision: Int64) {
            self.arn = arn
            self.revision = revision
        }

        private enum CodingKeys: String, CodingKey {
            case arn
            case revision
        }
    }

    public struct ConfigurationRevision: AWSDecodableShape {
        /// The time when the configuration revision was created.
        @CustomCoding<ISO8601DateCoder>
        public var creationTime: Date
        /// The description of the configuration revision.
        public let description: String?
        /// The revision number.
        public let revision: Int64

        public init(creationTime: Date, description: String? = nil, revision: Int64) {
            self.creationTime = creationTime
            self.description = description
            self.revision = revision
        }

        private enum CodingKeys: String, CodingKey {
            case creationTime
            case description
            case revision
        }
    }

    public struct ConnectivityInfo: AWSEncodableShape & AWSDecodableShape {
        /// Public access control for brokers.
        public let publicAccess: PublicAccess?

        public init(publicAccess: PublicAccess? = nil) {
            self.publicAccess = publicAccess
        }

        private enum CodingKeys: String, CodingKey {
            case publicAccess
        }
    }

    public struct CreateClusterRequest: AWSEncodableShape {
        /// Information about the broker nodes in the cluster.
        public let brokerNodeGroupInfo: BrokerNodeGroupInfo
        /// Includes all client authentication related information.
        public let clientAuthentication: ClientAuthentication?
        /// The name of the cluster.
        public let clusterName: String
        /// Represents the configuration that you want MSK to use for the brokers in a cluster.
        public let configurationInfo: ConfigurationInfo?
        /// Includes all encryption-related information.
        public let encryptionInfo: EncryptionInfo?
        /// Specifies the level of monitoring for the MSK cluster. The possible values are DEFAULT, PER_BROKER, PER_TOPIC_PER_BROKER, and PER_TOPIC_PER_PARTITION.
        public let enhancedMonitoring: EnhancedMonitoring?
        /// The version of Apache Kafka.
        public let kafkaVersion: String
        public let loggingInfo: LoggingInfo?
        /// The number of broker nodes in the cluster.
        public let numberOfBrokerNodes: Int
        /// The settings for open monitoring.
        public let openMonitoring: OpenMonitoringInfo?
        /// This controls storage mode for supported storage tiers.
        public let storageMode: StorageMode?
        /// Create tags when creating the cluster.
        public let tags: [String: String]?

        public init(brokerNodeGroupInfo: BrokerNodeGroupInfo, clientAuthentication: ClientAuthentication? = nil, clusterName: String, configurationInfo: ConfigurationInfo? = nil, encryptionInfo: EncryptionInfo? = nil, enhancedMonitoring: EnhancedMonitoring? = nil, kafkaVersion: String, loggingInfo: LoggingInfo? = nil, numberOfBrokerNodes: Int = 0, openMonitoring: OpenMonitoringInfo? = nil, storageMode: StorageMode? = nil, tags: [String: String]? = nil) {
            self.brokerNodeGroupInfo = brokerNodeGroupInfo
            self.clientAuthentication = clientAuthentication
            self.clusterName = clusterName
            self.configurationInfo = configurationInfo
            self.encryptionInfo = encryptionInfo
            self.enhancedMonitoring = enhancedMonitoring
            self.kafkaVersion = kafkaVersion
            self.loggingInfo = loggingInfo
            self.numberOfBrokerNodes = numberOfBrokerNodes
            self.openMonitoring = openMonitoring
            self.storageMode = storageMode
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.brokerNodeGroupInfo.validate(name: "\(name).brokerNodeGroupInfo")
            try self.validate(self.clusterName, name: "clusterName", parent: name, max: 64)
            try self.validate(self.clusterName, name: "clusterName", parent: name, min: 1)
            try self.validate(self.kafkaVersion, name: "kafkaVersion", parent: name, max: 128)
            try self.validate(self.kafkaVersion, name: "kafkaVersion", parent: name, min: 1)
            try self.validate(self.numberOfBrokerNodes, name: "numberOfBrokerNodes", parent: name, max: 15)
            try self.validate(self.numberOfBrokerNodes, name: "numberOfBrokerNodes", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case brokerNodeGroupInfo
            case clientAuthentication
            case clusterName
            case configurationInfo
            case encryptionInfo
            case enhancedMonitoring
            case kafkaVersion
            case loggingInfo
            case numberOfBrokerNodes
            case openMonitoring
            case storageMode
            case tags
        }
    }

    public struct CreateClusterResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the cluster.
        public let clusterArn: String?
        /// The name of the MSK cluster.
        public let clusterName: String?
        /// The state of the cluster. The possible states are ACTIVE, CREATING, DELETING, FAILED, HEALING, MAINTENANCE, REBOOTING_BROKER, and UPDATING.
        public let state: ClusterState?

        public init(clusterArn: String? = nil, clusterName: String? = nil, state: ClusterState? = nil) {
            self.clusterArn = clusterArn
            self.clusterName = clusterName
            self.state = state
        }

        private enum CodingKeys: String, CodingKey {
            case clusterArn
            case clusterName
            case state
        }
    }

    public struct CreateClusterV2Request: AWSEncodableShape {
        /// The name of the cluster.
        public let clusterName: String
        /// Information about the provisioned cluster.
        public let provisioned: ProvisionedRequest?
        /// Information about the serverless cluster.
        public let serverless: ServerlessRequest?
        /// A map of tags that you want the cluster to have.
        public let tags: [String: String]?

        public init(clusterName: String, provisioned: ProvisionedRequest? = nil, serverless: ServerlessRequest? = nil, tags: [String: String]? = nil) {
            self.clusterName = clusterName
            self.provisioned = provisioned
            self.serverless = serverless
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.validate(self.clusterName, name: "clusterName", parent: name, max: 64)
            try self.validate(self.clusterName, name: "clusterName", parent: name, min: 1)
            try self.provisioned?.validate(name: "\(name).provisioned")
        }

        private enum CodingKeys: String, CodingKey {
            case clusterName
            case provisioned
            case serverless
            case tags
        }
    }

    public struct CreateClusterV2Response: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the cluster.
        public let clusterArn: String?
        /// The name of the MSK cluster.
        public let clusterName: String?
        /// The type of the cluster. The possible states are PROVISIONED or SERVERLESS.
        public let clusterType: ClusterType?
        /// The state of the cluster. The possible states are ACTIVE, CREATING, DELETING, FAILED, HEALING, MAINTENANCE, REBOOTING_BROKER, and UPDATING.
        public let state: ClusterState?

        public init(clusterArn: String? = nil, clusterName: String? = nil, clusterType: ClusterType? = nil, state: ClusterState? = nil) {
            self.clusterArn = clusterArn
            self.clusterName = clusterName
            self.clusterType = clusterType
            self.state = state
        }

        private enum CodingKeys: String, CodingKey {
            case clusterArn
            case clusterName
            case clusterType
            case state
        }
    }

    public struct CreateConfigurationRequest: AWSEncodableShape {
        /// The description of the configuration.
        public let description: String?
        /// The versions of Apache Kafka with which you can use this MSK configuration.
        public let kafkaVersions: [String]?
        /// The name of the configuration.
        public let name: String
        /// Contents of the server.properties file. When using the API, you must ensure that the contents of the file are base64 encoded.  When using the AWS Management Console, the SDK, or the AWS CLI, the contents of server.properties can be in plaintext.
        public let serverProperties: AWSBase64Data

        public init(description: String? = nil, kafkaVersions: [String]? = nil, name: String, serverProperties: AWSBase64Data) {
            self.description = description
            self.kafkaVersions = kafkaVersions
            self.name = name
            self.serverProperties = serverProperties
        }

        private enum CodingKeys: String, CodingKey {
            case description
            case kafkaVersions
            case name
            case serverProperties
        }
    }

    public struct CreateConfigurationResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the configuration.
        public let arn: String?
        /// The time when the configuration was created.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var creationTime: Date?
        /// Latest revision of the configuration.
        public let latestRevision: ConfigurationRevision?
        /// The name of the configuration.
        public let name: String?
        /// The state of the configuration. The possible states are ACTIVE, DELETING, and DELETE_FAILED.
        public let state: ConfigurationState?

        public init(arn: String? = nil, creationTime: Date? = nil, latestRevision: ConfigurationRevision? = nil, name: String? = nil, state: ConfigurationState? = nil) {
            self.arn = arn
            self.creationTime = creationTime
            self.latestRevision = latestRevision
            self.name = name
            self.state = state
        }

        private enum CodingKeys: String, CodingKey {
            case arn
            case creationTime
            case latestRevision
            case name
            case state
        }
    }

    public struct DeleteClusterRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "clusterArn", location: .uri("ClusterArn")),
            AWSMemberEncoding(label: "currentVersion", location: .querystring("currentVersion"))
        ]

        /// The Amazon Resource Name (ARN) that uniquely identifies the cluster.
        public let clusterArn: String
        /// The current version of the MSK cluster.
        public let currentVersion: String?

        public init(clusterArn: String, currentVersion: String? = nil) {
            self.clusterArn = clusterArn
            self.currentVersion = currentVersion
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteClusterResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the cluster.
        public let clusterArn: String?
        /// The state of the cluster. The possible states are ACTIVE, CREATING, DELETING, FAILED, HEALING, MAINTENANCE, REBOOTING_BROKER, and UPDATING.
        public let state: ClusterState?

        public init(clusterArn: String? = nil, state: ClusterState? = nil) {
            self.clusterArn = clusterArn
            self.state = state
        }

        private enum CodingKeys: String, CodingKey {
            case clusterArn
            case state
        }
    }

    public struct DeleteConfigurationRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "arn", location: .uri("Arn"))
        ]

        /// The Amazon Resource Name (ARN) that uniquely identifies an MSK configuration.
        public let arn: String

        public init(arn: String) {
            self.arn = arn
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteConfigurationResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) that uniquely identifies an MSK configuration.
        public let arn: String?
        /// The state of the configuration. The possible states are ACTIVE, DELETING, and DELETE_FAILED.
        public let state: ConfigurationState?

        public init(arn: String? = nil, state: ConfigurationState? = nil) {
            self.arn = arn
            self.state = state
        }

        private enum CodingKeys: String, CodingKey {
            case arn
            case state
        }
    }

    public struct DescribeClusterOperationRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "clusterOperationArn", location: .uri("ClusterOperationArn"))
        ]

        /// The Amazon Resource Name (ARN) that uniquely identifies the MSK cluster operation.
        public let clusterOperationArn: String

        public init(clusterOperationArn: String) {
            self.clusterOperationArn = clusterOperationArn
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DescribeClusterOperationResponse: AWSDecodableShape {
        /// Cluster operation information
        public let clusterOperationInfo: ClusterOperationInfo?

        public init(clusterOperationInfo: ClusterOperationInfo? = nil) {
            self.clusterOperationInfo = clusterOperationInfo
        }

        private enum CodingKeys: String, CodingKey {
            case clusterOperationInfo
        }
    }

    public struct DescribeClusterRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "clusterArn", location: .uri("ClusterArn"))
        ]

        /// The Amazon Resource Name (ARN) that uniquely identifies the cluster.
        public let clusterArn: String

        public init(clusterArn: String) {
            self.clusterArn = clusterArn
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DescribeClusterResponse: AWSDecodableShape {
        /// The cluster information.
        public let clusterInfo: ClusterInfo?

        public init(clusterInfo: ClusterInfo? = nil) {
            self.clusterInfo = clusterInfo
        }

        private enum CodingKeys: String, CodingKey {
            case clusterInfo
        }
    }

    public struct DescribeClusterV2Request: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "clusterArn", location: .uri("ClusterArn"))
        ]

        /// The Amazon Resource Name (ARN) that uniquely identifies the cluster.
        public let clusterArn: String

        public init(clusterArn: String) {
            self.clusterArn = clusterArn
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DescribeClusterV2Response: AWSDecodableShape {
        /// The cluster information.
        public let clusterInfo: Cluster?

        public init(clusterInfo: Cluster? = nil) {
            self.clusterInfo = clusterInfo
        }

        private enum CodingKeys: String, CodingKey {
            case clusterInfo
        }
    }

    public struct DescribeConfigurationRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "arn", location: .uri("Arn"))
        ]

        /// The Amazon Resource Name (ARN) that uniquely identifies an MSK configuration and all of its revisions.
        public let arn: String

        public init(arn: String) {
            self.arn = arn
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DescribeConfigurationResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the configuration.
        public let arn: String?
        /// The time when the configuration was created.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var creationTime: Date?
        /// The description of the configuration.
        public let description: String?
        /// The versions of Apache Kafka with which you can use this MSK configuration.
        public let kafkaVersions: [String]?
        /// Latest revision of the configuration.
        public let latestRevision: ConfigurationRevision?
        /// The name of the configuration.
        public let name: String?
        /// The state of the configuration. The possible states are ACTIVE, DELETING, and DELETE_FAILED.
        public let state: ConfigurationState?

        public init(arn: String? = nil, creationTime: Date? = nil, description: String? = nil, kafkaVersions: [String]? = nil, latestRevision: ConfigurationRevision? = nil, name: String? = nil, state: ConfigurationState? = nil) {
            self.arn = arn
            self.creationTime = creationTime
            self.description = description
            self.kafkaVersions = kafkaVersions
            self.latestRevision = latestRevision
            self.name = name
            self.state = state
        }

        private enum CodingKeys: String, CodingKey {
            case arn
            case creationTime
            case description
            case kafkaVersions
            case latestRevision
            case name
            case state
        }
    }

    public struct DescribeConfigurationRevisionRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "arn", location: .uri("Arn")),
            AWSMemberEncoding(label: "revision", location: .uri("Revision"))
        ]

        /// The Amazon Resource Name (ARN) that uniquely identifies an MSK configuration and all of its revisions.
        public let arn: String
        /// A string that uniquely identifies a revision of an MSK configuration.
        public let revision: Int64

        public init(arn: String, revision: Int64 = 0) {
            self.arn = arn
            self.revision = revision
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DescribeConfigurationRevisionResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the configuration.
        public let arn: String?
        /// The time when the configuration was created.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var creationTime: Date?
        /// The description of the configuration.
        public let description: String?
        /// The revision number.
        public let revision: Int64?
        /// Contents of the server.properties file. When using the API, you must ensure that the contents of the file are base64 encoded.  When using the AWS Management Console, the SDK, or the AWS CLI, the contents of server.properties can be in plaintext.
        public let serverProperties: AWSBase64Data?

        public init(arn: String? = nil, creationTime: Date? = nil, description: String? = nil, revision: Int64? = nil, serverProperties: AWSBase64Data? = nil) {
            self.arn = arn
            self.creationTime = creationTime
            self.description = description
            self.revision = revision
            self.serverProperties = serverProperties
        }

        private enum CodingKeys: String, CodingKey {
            case arn
            case creationTime
            case description
            case revision
            case serverProperties
        }
    }

    public struct EBSStorageInfo: AWSEncodableShape & AWSDecodableShape {
        /// EBS volume provisioned throughput information.
        public let provisionedThroughput: ProvisionedThroughput?
        /// The size in GiB of the EBS volume for the data drive on each broker node.
        public let volumeSize: Int?

        public init(provisionedThroughput: ProvisionedThroughput? = nil, volumeSize: Int? = nil) {
            self.provisionedThroughput = provisionedThroughput
            self.volumeSize = volumeSize
        }

        public func validate(name: String) throws {
            try self.validate(self.volumeSize, name: "volumeSize", parent: name, max: 16384)
            try self.validate(self.volumeSize, name: "volumeSize", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case provisionedThroughput
            case volumeSize
        }
    }

    public struct EncryptionAtRest: AWSEncodableShape & AWSDecodableShape {
        /// The ARN of the AWS KMS key for encrypting data at rest. If you don't specify a KMS key, MSK creates one for you and uses it.
        public let dataVolumeKMSKeyId: String

        public init(dataVolumeKMSKeyId: String) {
            self.dataVolumeKMSKeyId = dataVolumeKMSKeyId
        }

        private enum CodingKeys: String, CodingKey {
            case dataVolumeKMSKeyId
        }
    }

    public struct EncryptionInTransit: AWSEncodableShape & AWSDecodableShape {
        /// Indicates the encryption setting for data in transit between clients and brokers. The following are the possible values.  TLS means that client-broker communication is enabled with TLS only.  TLS_PLAINTEXT means that client-broker communication is enabled for both TLS-encrypted, as well as plaintext data.  PLAINTEXT means that client-broker communication is enabled in plaintext only. The default value is TLS_PLAINTEXT.
        public let clientBroker: ClientBroker?
        /// When set to true, it indicates that data communication among the broker nodes of the cluster is encrypted. When set to false, the communication happens in plaintext. The default value is true.
        public let inCluster: Bool?

        public init(clientBroker: ClientBroker? = nil, inCluster: Bool? = nil) {
            self.clientBroker = clientBroker
            self.inCluster = inCluster
        }

        private enum CodingKeys: String, CodingKey {
            case clientBroker
            case inCluster
        }
    }

    public struct EncryptionInfo: AWSEncodableShape & AWSDecodableShape {
        /// The data-volume encryption details.
        public let encryptionAtRest: EncryptionAtRest?
        /// The details for encryption in transit.
        public let encryptionInTransit: EncryptionInTransit?

        public init(encryptionAtRest: EncryptionAtRest? = nil, encryptionInTransit: EncryptionInTransit? = nil) {
            self.encryptionAtRest = encryptionAtRest
            self.encryptionInTransit = encryptionInTransit
        }

        private enum CodingKeys: String, CodingKey {
            case encryptionAtRest
            case encryptionInTransit
        }
    }

    public struct ErrorInfo: AWSDecodableShape {
        /// A number describing the error programmatically.
        public let errorCode: String?
        /// An optional field to provide more details about the error.
        public let errorString: String?

        public init(errorCode: String? = nil, errorString: String? = nil) {
            self.errorCode = errorCode
            self.errorString = errorString
        }

        private enum CodingKeys: String, CodingKey {
            case errorCode
            case errorString
        }
    }

    public struct Firehose: AWSEncodableShape & AWSDecodableShape {
        public let deliveryStream: String?
        public let enabled: Bool

        public init(deliveryStream: String? = nil, enabled: Bool) {
            self.deliveryStream = deliveryStream
            self.enabled = enabled
        }

        private enum CodingKeys: String, CodingKey {
            case deliveryStream
            case enabled
        }
    }

    public struct GetBootstrapBrokersRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "clusterArn", location: .uri("ClusterArn"))
        ]

        /// The Amazon Resource Name (ARN) that uniquely identifies the cluster.
        public let clusterArn: String

        public init(clusterArn: String) {
            self.clusterArn = clusterArn
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetBootstrapBrokersResponse: AWSDecodableShape {
        /// A string containing one or more hostname:port pairs.
        public let bootstrapBrokerString: String?
        /// A string that contains one or more DNS names (or IP addresses) and SASL IAM port pairs.
        public let bootstrapBrokerStringPublicSaslIam: String?
        /// A string containing one or more DNS names (or IP) and Sasl Scram port pairs.
        public let bootstrapBrokerStringPublicSaslScram: String?
        /// A string containing one or more DNS names (or IP) and TLS port pairs.
        public let bootstrapBrokerStringPublicTls: String?
        /// A string that contains one or more DNS names (or IP addresses) and SASL IAM port pairs.
        public let bootstrapBrokerStringSaslIam: String?
        /// A string containing one or more DNS names (or IP) and Sasl Scram port pairs.
        public let bootstrapBrokerStringSaslScram: String?
        /// A string containing one or more DNS names (or IP) and TLS port pairs.
        public let bootstrapBrokerStringTls: String?

        public init(bootstrapBrokerString: String? = nil, bootstrapBrokerStringPublicSaslIam: String? = nil, bootstrapBrokerStringPublicSaslScram: String? = nil, bootstrapBrokerStringPublicTls: String? = nil, bootstrapBrokerStringSaslIam: String? = nil, bootstrapBrokerStringSaslScram: String? = nil, bootstrapBrokerStringTls: String? = nil) {
            self.bootstrapBrokerString = bootstrapBrokerString
            self.bootstrapBrokerStringPublicSaslIam = bootstrapBrokerStringPublicSaslIam
            self.bootstrapBrokerStringPublicSaslScram = bootstrapBrokerStringPublicSaslScram
            self.bootstrapBrokerStringPublicTls = bootstrapBrokerStringPublicTls
            self.bootstrapBrokerStringSaslIam = bootstrapBrokerStringSaslIam
            self.bootstrapBrokerStringSaslScram = bootstrapBrokerStringSaslScram
            self.bootstrapBrokerStringTls = bootstrapBrokerStringTls
        }

        private enum CodingKeys: String, CodingKey {
            case bootstrapBrokerString
            case bootstrapBrokerStringPublicSaslIam
            case bootstrapBrokerStringPublicSaslScram
            case bootstrapBrokerStringPublicTls
            case bootstrapBrokerStringSaslIam
            case bootstrapBrokerStringSaslScram
            case bootstrapBrokerStringTls
        }
    }

    public struct GetCompatibleKafkaVersionsRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "clusterArn", location: .querystring("clusterArn"))
        ]

        /// The Amazon Resource Name (ARN) of the cluster check.
        public let clusterArn: String?

        public init(clusterArn: String? = nil) {
            self.clusterArn = clusterArn
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetCompatibleKafkaVersionsResponse: AWSDecodableShape {
        /// A list of CompatibleKafkaVersion objects.
        public let compatibleKafkaVersions: [CompatibleKafkaVersion]?

        public init(compatibleKafkaVersions: [CompatibleKafkaVersion]? = nil) {
            self.compatibleKafkaVersions = compatibleKafkaVersions
        }

        private enum CodingKeys: String, CodingKey {
            case compatibleKafkaVersions
        }
    }

    public struct Iam: AWSEncodableShape & AWSDecodableShape {
        /// Indicates whether IAM access control is enabled.
        public let enabled: Bool?

        public init(enabled: Bool? = nil) {
            self.enabled = enabled
        }

        private enum CodingKeys: String, CodingKey {
            case enabled
        }
    }

    public struct JmxExporter: AWSDecodableShape {
        /// Indicates whether you want to turn on or turn off the JMX Exporter.
        public let enabledInBroker: Bool

        public init(enabledInBroker: Bool) {
            self.enabledInBroker = enabledInBroker
        }

        private enum CodingKeys: String, CodingKey {
            case enabledInBroker
        }
    }

    public struct JmxExporterInfo: AWSEncodableShape & AWSDecodableShape {
        /// Indicates whether you want to turn on or turn off the JMX Exporter.
        public let enabledInBroker: Bool

        public init(enabledInBroker: Bool) {
            self.enabledInBroker = enabledInBroker
        }

        private enum CodingKeys: String, CodingKey {
            case enabledInBroker
        }
    }

    public struct KafkaVersion: AWSDecodableShape {
        public let status: KafkaVersionStatus?
        public let version: String?

        public init(status: KafkaVersionStatus? = nil, version: String? = nil) {
            self.status = status
            self.version = version
        }

        private enum CodingKeys: String, CodingKey {
            case status
            case version
        }
    }

    public struct ListClusterOperationsRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "clusterArn", location: .uri("ClusterArn")),
            AWSMemberEncoding(label: "maxResults", location: .querystring("maxResults")),
            AWSMemberEncoding(label: "nextToken", location: .querystring("nextToken"))
        ]

        /// The Amazon Resource Name (ARN) that uniquely identifies the cluster.
        public let clusterArn: String
        /// The maximum number of results to return in the response. If there are more results, the response includes a NextToken parameter.
        public let maxResults: Int?
        /// The paginated results marker. When the result of the operation is truncated, the call returns NextToken in the response.  To get the next batch, provide this token in your next request.
        public let nextToken: String?

        public init(clusterArn: String, maxResults: Int? = nil, nextToken: String? = nil) {
            self.clusterArn = clusterArn
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListClusterOperationsResponse: AWSDecodableShape {
        /// An array of cluster operation information objects.
        public let clusterOperationInfoList: [ClusterOperationInfo]?
        /// If the response of ListClusterOperations is truncated, it returns a NextToken in the response. This Nexttoken should be sent in the subsequent request to ListClusterOperations.
        public let nextToken: String?

        public init(clusterOperationInfoList: [ClusterOperationInfo]? = nil, nextToken: String? = nil) {
            self.clusterOperationInfoList = clusterOperationInfoList
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case clusterOperationInfoList
            case nextToken
        }
    }

    public struct ListClustersRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "clusterNameFilter", location: .querystring("clusterNameFilter")),
            AWSMemberEncoding(label: "maxResults", location: .querystring("maxResults")),
            AWSMemberEncoding(label: "nextToken", location: .querystring("nextToken"))
        ]

        /// Specify a prefix of the name of the clusters that you want to list. The service lists all the clusters whose names start with this prefix.
        public let clusterNameFilter: String?
        /// The maximum number of results to return in the response. If there are more results, the response includes a NextToken parameter.
        public let maxResults: Int?
        /// The paginated results marker. When the result of the operation is truncated, the call returns NextToken in the response.  To get the next batch, provide this token in your next request.
        public let nextToken: String?

        public init(clusterNameFilter: String? = nil, maxResults: Int? = nil, nextToken: String? = nil) {
            self.clusterNameFilter = clusterNameFilter
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListClustersResponse: AWSDecodableShape {
        /// Information on each of the MSK clusters in the response.
        public let clusterInfoList: [ClusterInfo]?
        /// The paginated results marker. When the result of a ListClusters operation is truncated, the call returns NextToken in the response.  To get another batch of clusters, provide this token in your next request.
        public let nextToken: String?

        public init(clusterInfoList: [ClusterInfo]? = nil, nextToken: String? = nil) {
            self.clusterInfoList = clusterInfoList
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case clusterInfoList
            case nextToken
        }
    }

    public struct ListClustersV2Request: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "clusterNameFilter", location: .querystring("clusterNameFilter")),
            AWSMemberEncoding(label: "clusterTypeFilter", location: .querystring("clusterTypeFilter")),
            AWSMemberEncoding(label: "maxResults", location: .querystring("maxResults")),
            AWSMemberEncoding(label: "nextToken", location: .querystring("nextToken"))
        ]

        /// Specify a prefix of the names of the clusters that you want to list. The service lists all the clusters whose names start with this prefix.
        public let clusterNameFilter: String?
        /// Specify either PROVISIONED or SERVERLESS.
        public let clusterTypeFilter: String?
        /// The maximum number of results to return in the response. If there are more results, the response includes a NextToken parameter.
        public let maxResults: Int?
        /// The paginated results marker. When the result of the operation is truncated, the call returns NextToken in the response.  To get the next batch, provide this token in your next request.
        public let nextToken: String?

        public init(clusterNameFilter: String? = nil, clusterTypeFilter: String? = nil, maxResults: Int? = nil, nextToken: String? = nil) {
            self.clusterNameFilter = clusterNameFilter
            self.clusterTypeFilter = clusterTypeFilter
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListClustersV2Response: AWSDecodableShape {
        /// Information on each of the MSK clusters in the response.
        public let clusterInfoList: [Cluster]?
        /// The paginated results marker. When the result of a ListClusters operation is truncated, the call returns NextToken in the response.  To get another batch of clusters, provide this token in your next request.
        public let nextToken: String?

        public init(clusterInfoList: [Cluster]? = nil, nextToken: String? = nil) {
            self.clusterInfoList = clusterInfoList
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case clusterInfoList
            case nextToken
        }
    }

    public struct ListConfigurationRevisionsRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "arn", location: .uri("Arn")),
            AWSMemberEncoding(label: "maxResults", location: .querystring("maxResults")),
            AWSMemberEncoding(label: "nextToken", location: .querystring("nextToken"))
        ]

        /// The Amazon Resource Name (ARN) that uniquely identifies an MSK configuration and all of its revisions.
        public let arn: String
        /// The maximum number of results to return in the response. If there are more results, the response includes a NextToken parameter.
        public let maxResults: Int?
        /// The paginated results marker. When the result of the operation is truncated, the call returns NextToken in the response.  To get the next batch, provide this token in your next request.
        public let nextToken: String?

        public init(arn: String, maxResults: Int? = nil, nextToken: String? = nil) {
            self.arn = arn
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListConfigurationRevisionsResponse: AWSDecodableShape {
        /// Paginated results marker.
        public let nextToken: String?
        /// List of ConfigurationRevision objects.
        public let revisions: [ConfigurationRevision]?

        public init(nextToken: String? = nil, revisions: [ConfigurationRevision]? = nil) {
            self.nextToken = nextToken
            self.revisions = revisions
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken
            case revisions
        }
    }

    public struct ListConfigurationsRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "maxResults", location: .querystring("maxResults")),
            AWSMemberEncoding(label: "nextToken", location: .querystring("nextToken"))
        ]

        /// The maximum number of results to return in the response. If there are more results, the response includes a NextToken parameter.
        public let maxResults: Int?
        /// The paginated results marker. When the result of the operation is truncated, the call returns NextToken in the response.  To get the next batch, provide this token in your next request.
        public let nextToken: String?

        public init(maxResults: Int? = nil, nextToken: String? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListConfigurationsResponse: AWSDecodableShape {
        /// An array of MSK configurations.
        public let configurations: [Configuration]?
        /// The paginated results marker. When the result of a ListConfigurations operation is truncated, the call returns NextToken in the response.  To get another batch of configurations, provide this token in your next request.
        public let nextToken: String?

        public init(configurations: [Configuration]? = nil, nextToken: String? = nil) {
            self.configurations = configurations
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case configurations
            case nextToken
        }
    }

    public struct ListKafkaVersionsRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "maxResults", location: .querystring("maxResults")),
            AWSMemberEncoding(label: "nextToken", location: .querystring("nextToken"))
        ]

        /// The maximum number of results to return in the response. If there are more results, the response includes a NextToken parameter.
        public let maxResults: Int?
        /// The paginated results marker. When the result of the operation is truncated, the call returns NextToken in the response. To get the next batch, provide this token in your next request.
        public let nextToken: String?

        public init(maxResults: Int? = nil, nextToken: String? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListKafkaVersionsResponse: AWSDecodableShape {
        public let kafkaVersions: [KafkaVersion]?
        public let nextToken: String?

        public init(kafkaVersions: [KafkaVersion]? = nil, nextToken: String? = nil) {
            self.kafkaVersions = kafkaVersions
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case kafkaVersions
            case nextToken
        }
    }

    public struct ListNodesRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "clusterArn", location: .uri("ClusterArn")),
            AWSMemberEncoding(label: "maxResults", location: .querystring("maxResults")),
            AWSMemberEncoding(label: "nextToken", location: .querystring("nextToken"))
        ]

        /// The Amazon Resource Name (ARN) that uniquely identifies the cluster.
        public let clusterArn: String
        /// The maximum number of results to return in the response. If there are more results, the response includes a NextToken parameter.
        public let maxResults: Int?
        /// The paginated results marker. When the result of the operation is truncated, the call returns NextToken in the response.  To get the next batch, provide this token in your next request.
        public let nextToken: String?

        public init(clusterArn: String, maxResults: Int? = nil, nextToken: String? = nil) {
            self.clusterArn = clusterArn
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListNodesResponse: AWSDecodableShape {
        /// The paginated results marker. When the result of a ListNodes operation is truncated, the call returns NextToken in the response.  To get another batch of nodes, provide this token in your next request.
        public let nextToken: String?
        /// List containing a NodeInfo object.
        public let nodeInfoList: [NodeInfo]?

        public init(nextToken: String? = nil, nodeInfoList: [NodeInfo]? = nil) {
            self.nextToken = nextToken
            self.nodeInfoList = nodeInfoList
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken
            case nodeInfoList
        }
    }

    public struct ListScramSecretsRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "clusterArn", location: .uri("ClusterArn")),
            AWSMemberEncoding(label: "maxResults", location: .querystring("maxResults")),
            AWSMemberEncoding(label: "nextToken", location: .querystring("nextToken"))
        ]

        /// The arn of the cluster.
        public let clusterArn: String
        /// The maxResults of the query.
        public let maxResults: Int?
        /// The nextToken of the query.
        public let nextToken: String?

        public init(clusterArn: String, maxResults: Int? = nil, nextToken: String? = nil) {
            self.clusterArn = clusterArn
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListScramSecretsResponse: AWSDecodableShape {
        /// Paginated results marker.
        public let nextToken: String?
        /// The list of scram secrets associated with the cluster.
        public let secretArnList: [String]?

        public init(nextToken: String? = nil, secretArnList: [String]? = nil) {
            self.nextToken = nextToken
            self.secretArnList = secretArnList
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken
            case secretArnList
        }
    }

    public struct ListTagsForResourceRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "resourceArn", location: .uri("ResourceArn"))
        ]

        /// The Amazon Resource Name (ARN) that uniquely identifies the resource that's associated with the tags.
        public let resourceArn: String

        public init(resourceArn: String) {
            self.resourceArn = resourceArn
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListTagsForResourceResponse: AWSDecodableShape {
        /// The key-value pair for the resource tag.
        public let tags: [String: String]?

        public init(tags: [String: String]? = nil) {
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case tags
        }
    }

    public struct LoggingInfo: AWSEncodableShape & AWSDecodableShape {
        public let brokerLogs: BrokerLogs

        public init(brokerLogs: BrokerLogs) {
            self.brokerLogs = brokerLogs
        }

        private enum CodingKeys: String, CodingKey {
            case brokerLogs
        }
    }

    public struct MutableClusterInfo: AWSDecodableShape {
        /// Specifies the size of the EBS volume and the ID of the associated broker.
        public let brokerEBSVolumeInfo: [BrokerEBSVolumeInfo]?
        /// Includes all client authentication information.
        public let clientAuthentication: ClientAuthentication?
        /// Information about the changes in the configuration of the brokers.
        public let configurationInfo: ConfigurationInfo?
        /// Information about the broker access configuration.
        public let connectivityInfo: ConnectivityInfo?
        /// Includes all encryption-related information.
        public let encryptionInfo: EncryptionInfo?
        /// Specifies which Apache Kafka metrics Amazon MSK gathers and sends to Amazon CloudWatch for this cluster.
        public let enhancedMonitoring: EnhancedMonitoring?
        /// Information about the Amazon MSK broker type.
        public let instanceType: String?
        /// The Apache Kafka version.
        public let kafkaVersion: String?
        /// You can configure your MSK cluster to send broker logs to different destination types. This is a container for the configuration details related to broker logs.
        public let loggingInfo: LoggingInfo?
        /// The number of broker nodes in the cluster.
        public let numberOfBrokerNodes: Int?
        /// The settings for open monitoring.
        public let openMonitoring: OpenMonitoring?
        /// This controls storage mode for supported storage tiers.
        public let storageMode: StorageMode?

        public init(brokerEBSVolumeInfo: [BrokerEBSVolumeInfo]? = nil, clientAuthentication: ClientAuthentication? = nil, configurationInfo: ConfigurationInfo? = nil, connectivityInfo: ConnectivityInfo? = nil, encryptionInfo: EncryptionInfo? = nil, enhancedMonitoring: EnhancedMonitoring? = nil, instanceType: String? = nil, kafkaVersion: String? = nil, loggingInfo: LoggingInfo? = nil, numberOfBrokerNodes: Int? = nil, openMonitoring: OpenMonitoring? = nil, storageMode: StorageMode? = nil) {
            self.brokerEBSVolumeInfo = brokerEBSVolumeInfo
            self.clientAuthentication = clientAuthentication
            self.configurationInfo = configurationInfo
            self.connectivityInfo = connectivityInfo
            self.encryptionInfo = encryptionInfo
            self.enhancedMonitoring = enhancedMonitoring
            self.instanceType = instanceType
            self.kafkaVersion = kafkaVersion
            self.loggingInfo = loggingInfo
            self.numberOfBrokerNodes = numberOfBrokerNodes
            self.openMonitoring = openMonitoring
            self.storageMode = storageMode
        }

        private enum CodingKeys: String, CodingKey {
            case brokerEBSVolumeInfo
            case clientAuthentication
            case configurationInfo
            case connectivityInfo
            case encryptionInfo
            case enhancedMonitoring
            case instanceType
            case kafkaVersion
            case loggingInfo
            case numberOfBrokerNodes
            case openMonitoring
            case storageMode
        }
    }

    public struct NodeExporter: AWSDecodableShape {
        /// Indicates whether you want to turn on or turn off the Node Exporter.
        public let enabledInBroker: Bool

        public init(enabledInBroker: Bool) {
            self.enabledInBroker = enabledInBroker
        }

        private enum CodingKeys: String, CodingKey {
            case enabledInBroker
        }
    }

    public struct NodeExporterInfo: AWSEncodableShape & AWSDecodableShape {
        /// Indicates whether you want to turn on or turn off the Node Exporter.
        public let enabledInBroker: Bool

        public init(enabledInBroker: Bool) {
            self.enabledInBroker = enabledInBroker
        }

        private enum CodingKeys: String, CodingKey {
            case enabledInBroker
        }
    }

    public struct NodeInfo: AWSDecodableShape {
        /// The start time.
        public let addedToClusterTime: String?
        /// The broker node info.
        public let brokerNodeInfo: BrokerNodeInfo?
        /// The instance type.
        public let instanceType: String?
        /// The Amazon Resource Name (ARN) of the node.
        public let nodeARN: String?
        /// The node type.
        public let nodeType: NodeType?
        /// The ZookeeperNodeInfo.
        public let zookeeperNodeInfo: ZookeeperNodeInfo?

        public init(addedToClusterTime: String? = nil, brokerNodeInfo: BrokerNodeInfo? = nil, instanceType: String? = nil, nodeARN: String? = nil, nodeType: NodeType? = nil, zookeeperNodeInfo: ZookeeperNodeInfo? = nil) {
            self.addedToClusterTime = addedToClusterTime
            self.brokerNodeInfo = brokerNodeInfo
            self.instanceType = instanceType
            self.nodeARN = nodeARN
            self.nodeType = nodeType
            self.zookeeperNodeInfo = zookeeperNodeInfo
        }

        private enum CodingKeys: String, CodingKey {
            case addedToClusterTime
            case brokerNodeInfo
            case instanceType
            case nodeARN
            case nodeType
            case zookeeperNodeInfo
        }
    }

    public struct OpenMonitoring: AWSDecodableShape {
        /// Prometheus settings.
        public let prometheus: Prometheus

        public init(prometheus: Prometheus) {
            self.prometheus = prometheus
        }

        private enum CodingKeys: String, CodingKey {
            case prometheus
        }
    }

    public struct OpenMonitoringInfo: AWSEncodableShape & AWSDecodableShape {
        /// Prometheus settings.
        public let prometheus: PrometheusInfo

        public init(prometheus: PrometheusInfo) {
            self.prometheus = prometheus
        }

        private enum CodingKeys: String, CodingKey {
            case prometheus
        }
    }

    public struct Prometheus: AWSDecodableShape {
        /// Indicates whether you want to turn on or turn off the JMX Exporter.
        public let jmxExporter: JmxExporter?
        /// Indicates whether you want to turn on or turn off the Node Exporter.
        public let nodeExporter: NodeExporter?

        public init(jmxExporter: JmxExporter? = nil, nodeExporter: NodeExporter? = nil) {
            self.jmxExporter = jmxExporter
            self.nodeExporter = nodeExporter
        }

        private enum CodingKeys: String, CodingKey {
            case jmxExporter
            case nodeExporter
        }
    }

    public struct PrometheusInfo: AWSEncodableShape & AWSDecodableShape {
        /// Indicates whether you want to turn on or turn off the JMX Exporter.
        public let jmxExporter: JmxExporterInfo?
        /// Indicates whether you want to turn on or turn off the Node Exporter.
        public let nodeExporter: NodeExporterInfo?

        public init(jmxExporter: JmxExporterInfo? = nil, nodeExporter: NodeExporterInfo? = nil) {
            self.jmxExporter = jmxExporter
            self.nodeExporter = nodeExporter
        }

        private enum CodingKeys: String, CodingKey {
            case jmxExporter
            case nodeExporter
        }
    }

    public struct Provisioned: AWSDecodableShape {
        /// Information about the brokers.
        public let brokerNodeGroupInfo: BrokerNodeGroupInfo
        /// Includes all client authentication information.
        public let clientAuthentication: ClientAuthentication?
        /// Information about the Apache Kafka version deployed on the brokers.
        public let currentBrokerSoftwareInfo: BrokerSoftwareInfo?
        /// Includes all encryption-related information.
        public let encryptionInfo: EncryptionInfo?
        /// Specifies the level of monitoring for the MSK cluster. The possible values are DEFAULT, PER_BROKER, PER_TOPIC_PER_BROKER, and PER_TOPIC_PER_PARTITION.
        public let enhancedMonitoring: EnhancedMonitoring?
        /// Log delivery information for the cluster.
        public let loggingInfo: LoggingInfo?
        /// The number of broker nodes in the cluster.
        public let numberOfBrokerNodes: Int
        /// The settings for open monitoring.
        public let openMonitoring: OpenMonitoringInfo?
        /// This controls storage mode for supported storage tiers.
        public let storageMode: StorageMode?
        /// The connection string to use to connect to the Apache ZooKeeper cluster.
        public let zookeeperConnectString: String?
        /// The connection string to use to connect to the Apache ZooKeeper cluster on a TLS port.
        public let zookeeperConnectStringTls: String?

        public init(brokerNodeGroupInfo: BrokerNodeGroupInfo, clientAuthentication: ClientAuthentication? = nil, currentBrokerSoftwareInfo: BrokerSoftwareInfo? = nil, encryptionInfo: EncryptionInfo? = nil, enhancedMonitoring: EnhancedMonitoring? = nil, loggingInfo: LoggingInfo? = nil, numberOfBrokerNodes: Int, openMonitoring: OpenMonitoringInfo? = nil, storageMode: StorageMode? = nil, zookeeperConnectString: String? = nil, zookeeperConnectStringTls: String? = nil) {
            self.brokerNodeGroupInfo = brokerNodeGroupInfo
            self.clientAuthentication = clientAuthentication
            self.currentBrokerSoftwareInfo = currentBrokerSoftwareInfo
            self.encryptionInfo = encryptionInfo
            self.enhancedMonitoring = enhancedMonitoring
            self.loggingInfo = loggingInfo
            self.numberOfBrokerNodes = numberOfBrokerNodes
            self.openMonitoring = openMonitoring
            self.storageMode = storageMode
            self.zookeeperConnectString = zookeeperConnectString
            self.zookeeperConnectStringTls = zookeeperConnectStringTls
        }

        private enum CodingKeys: String, CodingKey {
            case brokerNodeGroupInfo
            case clientAuthentication
            case currentBrokerSoftwareInfo
            case encryptionInfo
            case enhancedMonitoring
            case loggingInfo
            case numberOfBrokerNodes
            case openMonitoring
            case storageMode
            case zookeeperConnectString
            case zookeeperConnectStringTls
        }
    }

    public struct ProvisionedRequest: AWSEncodableShape {
        /// Information about the brokers.
        public let brokerNodeGroupInfo: BrokerNodeGroupInfo
        /// Includes all client authentication information.
        public let clientAuthentication: ClientAuthentication?
        /// Represents the configuration that you want Amazon MSK to use for the brokers in a cluster.
        public let configurationInfo: ConfigurationInfo?
        /// Includes all encryption-related information.
        public let encryptionInfo: EncryptionInfo?
        /// Specifies the level of monitoring for the MSK cluster. The possible values are DEFAULT, PER_BROKER, PER_TOPIC_PER_BROKER, and PER_TOPIC_PER_PARTITION.
        public let enhancedMonitoring: EnhancedMonitoring?
        /// The Apache Kafka version that you want for the cluster.
        public let kafkaVersion: String
        /// Log delivery information for the cluster.
        public let loggingInfo: LoggingInfo?
        /// The number of broker nodes in the cluster.
        public let numberOfBrokerNodes: Int
        /// The settings for open monitoring.
        public let openMonitoring: OpenMonitoringInfo?
        /// This controls storage mode for supported storage tiers.
        public let storageMode: StorageMode?

        public init(brokerNodeGroupInfo: BrokerNodeGroupInfo, clientAuthentication: ClientAuthentication? = nil, configurationInfo: ConfigurationInfo? = nil, encryptionInfo: EncryptionInfo? = nil, enhancedMonitoring: EnhancedMonitoring? = nil, kafkaVersion: String, loggingInfo: LoggingInfo? = nil, numberOfBrokerNodes: Int = 0, openMonitoring: OpenMonitoringInfo? = nil, storageMode: StorageMode? = nil) {
            self.brokerNodeGroupInfo = brokerNodeGroupInfo
            self.clientAuthentication = clientAuthentication
            self.configurationInfo = configurationInfo
            self.encryptionInfo = encryptionInfo
            self.enhancedMonitoring = enhancedMonitoring
            self.kafkaVersion = kafkaVersion
            self.loggingInfo = loggingInfo
            self.numberOfBrokerNodes = numberOfBrokerNodes
            self.openMonitoring = openMonitoring
            self.storageMode = storageMode
        }

        public func validate(name: String) throws {
            try self.brokerNodeGroupInfo.validate(name: "\(name).brokerNodeGroupInfo")
            try self.validate(self.kafkaVersion, name: "kafkaVersion", parent: name, max: 128)
            try self.validate(self.kafkaVersion, name: "kafkaVersion", parent: name, min: 1)
            try self.validate(self.numberOfBrokerNodes, name: "numberOfBrokerNodes", parent: name, max: 15)
            try self.validate(self.numberOfBrokerNodes, name: "numberOfBrokerNodes", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case brokerNodeGroupInfo
            case clientAuthentication
            case configurationInfo
            case encryptionInfo
            case enhancedMonitoring
            case kafkaVersion
            case loggingInfo
            case numberOfBrokerNodes
            case openMonitoring
            case storageMode
        }
    }

    public struct ProvisionedThroughput: AWSEncodableShape & AWSDecodableShape {
        /// Provisioned throughput is enabled or not.
        public let enabled: Bool?
        /// Throughput value of the EBS volumes for the data drive on each kafka broker node in MiB per second.
        public let volumeThroughput: Int?

        public init(enabled: Bool? = nil, volumeThroughput: Int? = nil) {
            self.enabled = enabled
            self.volumeThroughput = volumeThroughput
        }

        private enum CodingKeys: String, CodingKey {
            case enabled
            case volumeThroughput
        }
    }

    public struct PublicAccess: AWSEncodableShape & AWSDecodableShape {
        /// The value DISABLED indicates that public access is turned off. SERVICE_PROVIDED_EIPS indicates that public access is turned on.
        public let type: String?

        public init(type: String? = nil) {
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case type
        }
    }

    public struct RebootBrokerRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "clusterArn", location: .uri("ClusterArn"))
        ]

        /// The list of broker IDs to be rebooted. The reboot-broker operation supports rebooting one broker at a time.
        public let brokerIds: [String]
        /// The Amazon Resource Name (ARN) of the cluster to be updated.
        public let clusterArn: String

        public init(brokerIds: [String], clusterArn: String) {
            self.brokerIds = brokerIds
            self.clusterArn = clusterArn
        }

        private enum CodingKeys: String, CodingKey {
            case brokerIds
        }
    }

    public struct RebootBrokerResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the cluster.
        public let clusterArn: String?
        /// The Amazon Resource Name (ARN) of the cluster operation.
        public let clusterOperationArn: String?

        public init(clusterArn: String? = nil, clusterOperationArn: String? = nil) {
            self.clusterArn = clusterArn
            self.clusterOperationArn = clusterOperationArn
        }

        private enum CodingKeys: String, CodingKey {
            case clusterArn
            case clusterOperationArn
        }
    }

    public struct S3: AWSEncodableShape & AWSDecodableShape {
        public let bucket: String?
        public let enabled: Bool
        public let prefix: String?

        public init(bucket: String? = nil, enabled: Bool, prefix: String? = nil) {
            self.bucket = bucket
            self.enabled = enabled
            self.prefix = prefix
        }

        private enum CodingKeys: String, CodingKey {
            case bucket
            case enabled
            case prefix
        }
    }

    public struct Sasl: AWSEncodableShape & AWSDecodableShape {
        /// Indicates whether IAM access control is enabled.
        public let iam: Iam?
        /// Details for SASL/SCRAM client authentication.
        public let scram: Scram?

        public init(iam: Iam? = nil, scram: Scram? = nil) {
            self.iam = iam
            self.scram = scram
        }

        private enum CodingKeys: String, CodingKey {
            case iam
            case scram
        }
    }

    public struct Scram: AWSEncodableShape & AWSDecodableShape {
        /// SASL/SCRAM authentication is enabled or not.
        public let enabled: Bool?

        public init(enabled: Bool? = nil) {
            self.enabled = enabled
        }

        private enum CodingKeys: String, CodingKey {
            case enabled
        }
    }

    public struct Serverless: AWSDecodableShape {
        /// Includes all client authentication information.
        public let clientAuthentication: ServerlessClientAuthentication?
        /// The configuration of the Amazon VPCs for the cluster.
        public let vpcConfigs: [VpcConfig]

        public init(clientAuthentication: ServerlessClientAuthentication? = nil, vpcConfigs: [VpcConfig]) {
            self.clientAuthentication = clientAuthentication
            self.vpcConfigs = vpcConfigs
        }

        private enum CodingKeys: String, CodingKey {
            case clientAuthentication
            case vpcConfigs
        }
    }

    public struct ServerlessClientAuthentication: AWSEncodableShape & AWSDecodableShape {
        /// Details for ClientAuthentication using SASL.
        public let sasl: ServerlessSasl?

        public init(sasl: ServerlessSasl? = nil) {
            self.sasl = sasl
        }

        private enum CodingKeys: String, CodingKey {
            case sasl
        }
    }

    public struct ServerlessRequest: AWSEncodableShape {
        /// Includes all client authentication information.
        public let clientAuthentication: ServerlessClientAuthentication?
        /// The configuration of the Amazon VPCs for the cluster.
        public let vpcConfigs: [VpcConfig]

        public init(clientAuthentication: ServerlessClientAuthentication? = nil, vpcConfigs: [VpcConfig]) {
            self.clientAuthentication = clientAuthentication
            self.vpcConfigs = vpcConfigs
        }

        private enum CodingKeys: String, CodingKey {
            case clientAuthentication
            case vpcConfigs
        }
    }

    public struct ServerlessSasl: AWSEncodableShape & AWSDecodableShape {
        /// Indicates whether IAM access control is enabled.
        public let iam: Iam?

        public init(iam: Iam? = nil) {
            self.iam = iam
        }

        private enum CodingKeys: String, CodingKey {
            case iam
        }
    }

    public struct StateInfo: AWSDecodableShape {
        public let code: String?
        public let message: String?

        public init(code: String? = nil, message: String? = nil) {
            self.code = code
            self.message = message
        }

        private enum CodingKeys: String, CodingKey {
            case code
            case message
        }
    }

    public struct StorageInfo: AWSEncodableShape & AWSDecodableShape {
        /// EBS volume information.
        public let ebsStorageInfo: EBSStorageInfo?

        public init(ebsStorageInfo: EBSStorageInfo? = nil) {
            self.ebsStorageInfo = ebsStorageInfo
        }

        public func validate(name: String) throws {
            try self.ebsStorageInfo?.validate(name: "\(name).ebsStorageInfo")
        }

        private enum CodingKeys: String, CodingKey {
            case ebsStorageInfo
        }
    }

    public struct TagResourceRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "resourceArn", location: .uri("ResourceArn"))
        ]

        /// The Amazon Resource Name (ARN) that uniquely identifies the resource that's associated with the tags.
        public let resourceArn: String
        /// The key-value pair for the resource tag.
        public let tags: [String: String]

        public init(resourceArn: String, tags: [String: String]) {
            self.resourceArn = resourceArn
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case tags
        }
    }

    public struct Tls: AWSEncodableShape & AWSDecodableShape {
        /// List of ACM Certificate Authority ARNs.
        public let certificateAuthorityArnList: [String]?
        /// Specifies whether you want to turn on or turn off TLS authentication.
        public let enabled: Bool?

        public init(certificateAuthorityArnList: [String]? = nil, enabled: Bool? = nil) {
            self.certificateAuthorityArnList = certificateAuthorityArnList
            self.enabled = enabled
        }

        private enum CodingKeys: String, CodingKey {
            case certificateAuthorityArnList
            case enabled
        }
    }

    public struct Unauthenticated: AWSEncodableShape & AWSDecodableShape {
        /// Specifies whether you want to turn on or turn off unauthenticated traffic to your cluster.
        public let enabled: Bool?

        public init(enabled: Bool? = nil) {
            self.enabled = enabled
        }

        private enum CodingKeys: String, CodingKey {
            case enabled
        }
    }

    public struct UnprocessedScramSecret: AWSDecodableShape {
        /// Error code for associate/disassociate failure.
        public let errorCode: String?
        /// Error message for associate/disassociate failure.
        public let errorMessage: String?
        /// AWS Secrets Manager secret ARN.
        public let secretArn: String?

        public init(errorCode: String? = nil, errorMessage: String? = nil, secretArn: String? = nil) {
            self.errorCode = errorCode
            self.errorMessage = errorMessage
            self.secretArn = secretArn
        }

        private enum CodingKeys: String, CodingKey {
            case errorCode
            case errorMessage
            case secretArn
        }
    }

    public struct UntagResourceRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "resourceArn", location: .uri("ResourceArn")),
            AWSMemberEncoding(label: "tagKeys", location: .querystring("tagKeys"))
        ]

        /// The Amazon Resource Name (ARN) that uniquely identifies the resource that's associated with the tags.
        public let resourceArn: String
        /// Tag keys must be unique for a given cluster. In addition, the following restrictions apply:   Each tag key must be unique. If you add a tag with a key that's already in use, your new tag overwrites the existing key-value pair.    You can't start a tag key with aws: because this prefix is reserved for use by  AWS.  AWS creates tags that begin with this prefix on your behalf, but you can't edit or delete them.   Tag keys must be between 1 and 128 Unicode characters in length.   Tag keys must consist of the following characters: Unicode letters, digits, white space, and the following special characters: _ . / = + - @.
        public let tagKeys: [String]

        public init(resourceArn: String, tagKeys: [String]) {
            self.resourceArn = resourceArn
            self.tagKeys = tagKeys
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct UpdateBrokerCountRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "clusterArn", location: .uri("ClusterArn"))
        ]

        /// The Amazon Resource Name (ARN) that uniquely identifies the cluster.
        public let clusterArn: String
        /// The version of cluster to update from. A successful operation will then generate a new version.
        public let currentVersion: String
        /// The number of broker nodes that you want the cluster to have after this operation completes successfully.
        public let targetNumberOfBrokerNodes: Int

        public init(clusterArn: String, currentVersion: String, targetNumberOfBrokerNodes: Int = 0) {
            self.clusterArn = clusterArn
            self.currentVersion = currentVersion
            self.targetNumberOfBrokerNodes = targetNumberOfBrokerNodes
        }

        public func validate(name: String) throws {
            try self.validate(self.targetNumberOfBrokerNodes, name: "targetNumberOfBrokerNodes", parent: name, max: 15)
            try self.validate(self.targetNumberOfBrokerNodes, name: "targetNumberOfBrokerNodes", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case currentVersion
            case targetNumberOfBrokerNodes
        }
    }

    public struct UpdateBrokerCountResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the cluster.
        public let clusterArn: String?
        /// The Amazon Resource Name (ARN) of the cluster operation.
        public let clusterOperationArn: String?

        public init(clusterArn: String? = nil, clusterOperationArn: String? = nil) {
            self.clusterArn = clusterArn
            self.clusterOperationArn = clusterOperationArn
        }

        private enum CodingKeys: String, CodingKey {
            case clusterArn
            case clusterOperationArn
        }
    }

    public struct UpdateBrokerStorageRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "clusterArn", location: .uri("ClusterArn"))
        ]

        /// The Amazon Resource Name (ARN) that uniquely identifies the cluster.
        public let clusterArn: String
        /// The version of cluster to update from. A successful operation will then generate a new version.
        public let currentVersion: String
        /// Describes the target volume size and the ID of the broker to apply the update to.
        public let targetBrokerEBSVolumeInfo: [BrokerEBSVolumeInfo]

        public init(clusterArn: String, currentVersion: String, targetBrokerEBSVolumeInfo: [BrokerEBSVolumeInfo]) {
            self.clusterArn = clusterArn
            self.currentVersion = currentVersion
            self.targetBrokerEBSVolumeInfo = targetBrokerEBSVolumeInfo
        }

        private enum CodingKeys: String, CodingKey {
            case currentVersion
            case targetBrokerEBSVolumeInfo
        }
    }

    public struct UpdateBrokerStorageResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the cluster.
        public let clusterArn: String?
        /// The Amazon Resource Name (ARN) of the cluster operation.
        public let clusterOperationArn: String?

        public init(clusterArn: String? = nil, clusterOperationArn: String? = nil) {
            self.clusterArn = clusterArn
            self.clusterOperationArn = clusterOperationArn
        }

        private enum CodingKeys: String, CodingKey {
            case clusterArn
            case clusterOperationArn
        }
    }

    public struct UpdateBrokerTypeRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "clusterArn", location: .uri("ClusterArn"))
        ]

        /// The Amazon Resource Name (ARN) that uniquely identifies the cluster.
        public let clusterArn: String
        /// The cluster version that you want to change. After this operation completes successfully, the cluster will have a new version.
        public let currentVersion: String
        /// The Amazon MSK broker type that you want all of the brokers in this cluster to be.
        public let targetInstanceType: String

        public init(clusterArn: String, currentVersion: String, targetInstanceType: String) {
            self.clusterArn = clusterArn
            self.currentVersion = currentVersion
            self.targetInstanceType = targetInstanceType
        }

        private enum CodingKeys: String, CodingKey {
            case currentVersion
            case targetInstanceType
        }
    }

    public struct UpdateBrokerTypeResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the cluster.
        public let clusterArn: String?
        /// The Amazon Resource Name (ARN) of the cluster operation.
        public let clusterOperationArn: String?

        public init(clusterArn: String? = nil, clusterOperationArn: String? = nil) {
            self.clusterArn = clusterArn
            self.clusterOperationArn = clusterOperationArn
        }

        private enum CodingKeys: String, CodingKey {
            case clusterArn
            case clusterOperationArn
        }
    }

    public struct UpdateClusterConfigurationRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "clusterArn", location: .uri("ClusterArn"))
        ]

        /// The Amazon Resource Name (ARN) that uniquely identifies the cluster.
        public let clusterArn: String
        /// Represents the configuration that you want MSK to use for the brokers in a cluster.
        public let configurationInfo: ConfigurationInfo
        /// The version of the cluster that needs to be updated.
        public let currentVersion: String

        public init(clusterArn: String, configurationInfo: ConfigurationInfo, currentVersion: String) {
            self.clusterArn = clusterArn
            self.configurationInfo = configurationInfo
            self.currentVersion = currentVersion
        }

        private enum CodingKeys: String, CodingKey {
            case configurationInfo
            case currentVersion
        }
    }

    public struct UpdateClusterConfigurationResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the cluster.
        public let clusterArn: String?
        /// The Amazon Resource Name (ARN) of the cluster operation.
        public let clusterOperationArn: String?

        public init(clusterArn: String? = nil, clusterOperationArn: String? = nil) {
            self.clusterArn = clusterArn
            self.clusterOperationArn = clusterOperationArn
        }

        private enum CodingKeys: String, CodingKey {
            case clusterArn
            case clusterOperationArn
        }
    }

    public struct UpdateClusterKafkaVersionRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "clusterArn", location: .uri("ClusterArn"))
        ]

        /// The Amazon Resource Name (ARN) of the cluster to be updated.
        public let clusterArn: String
        /// The custom configuration that should be applied on the new version of cluster.
        public let configurationInfo: ConfigurationInfo?
        /// Current cluster version.
        public let currentVersion: String
        /// Target Kafka version.
        public let targetKafkaVersion: String

        public init(clusterArn: String, configurationInfo: ConfigurationInfo? = nil, currentVersion: String, targetKafkaVersion: String) {
            self.clusterArn = clusterArn
            self.configurationInfo = configurationInfo
            self.currentVersion = currentVersion
            self.targetKafkaVersion = targetKafkaVersion
        }

        private enum CodingKeys: String, CodingKey {
            case configurationInfo
            case currentVersion
            case targetKafkaVersion
        }
    }

    public struct UpdateClusterKafkaVersionResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the cluster.
        public let clusterArn: String?
        /// The Amazon Resource Name (ARN) of the cluster operation.
        public let clusterOperationArn: String?

        public init(clusterArn: String? = nil, clusterOperationArn: String? = nil) {
            self.clusterArn = clusterArn
            self.clusterOperationArn = clusterOperationArn
        }

        private enum CodingKeys: String, CodingKey {
            case clusterArn
            case clusterOperationArn
        }
    }

    public struct UpdateConfigurationRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "arn", location: .uri("Arn"))
        ]

        /// The Amazon Resource Name (ARN) of the configuration.
        public let arn: String
        /// The description of the configuration revision.
        public let description: String?
        /// Contents of the server.properties file. When using the API, you must ensure that the contents of the file are base64 encoded.  When using the AWS Management Console, the SDK, or the AWS CLI, the contents of server.properties can be in plaintext.
        public let serverProperties: AWSBase64Data

        public init(arn: String, description: String? = nil, serverProperties: AWSBase64Data) {
            self.arn = arn
            self.description = description
            self.serverProperties = serverProperties
        }

        private enum CodingKeys: String, CodingKey {
            case description
            case serverProperties
        }
    }

    public struct UpdateConfigurationResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the configuration.
        public let arn: String?
        /// Latest revision of the configuration.
        public let latestRevision: ConfigurationRevision?

        public init(arn: String? = nil, latestRevision: ConfigurationRevision? = nil) {
            self.arn = arn
            self.latestRevision = latestRevision
        }

        private enum CodingKeys: String, CodingKey {
            case arn
            case latestRevision
        }
    }

    public struct UpdateConnectivityRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "clusterArn", location: .uri("ClusterArn"))
        ]

        /// The Amazon Resource Name (ARN) of the configuration.
        public let clusterArn: String
        /// Information about the broker access configuration.
        public let connectivityInfo: ConnectivityInfo
        /// The version of the MSK cluster to update. Cluster versions aren't simple numbers. You can describe an MSK cluster to find its version. When this update operation is successful, it generates a new cluster version.
        public let currentVersion: String

        public init(clusterArn: String, connectivityInfo: ConnectivityInfo, currentVersion: String) {
            self.clusterArn = clusterArn
            self.connectivityInfo = connectivityInfo
            self.currentVersion = currentVersion
        }

        private enum CodingKeys: String, CodingKey {
            case connectivityInfo
            case currentVersion
        }
    }

    public struct UpdateConnectivityResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the cluster.
        public let clusterArn: String?
        /// The Amazon Resource Name (ARN) of the cluster operation.
        public let clusterOperationArn: String?

        public init(clusterArn: String? = nil, clusterOperationArn: String? = nil) {
            self.clusterArn = clusterArn
            self.clusterOperationArn = clusterOperationArn
        }

        private enum CodingKeys: String, CodingKey {
            case clusterArn
            case clusterOperationArn
        }
    }

    public struct UpdateMonitoringRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "clusterArn", location: .uri("ClusterArn"))
        ]

        /// The Amazon Resource Name (ARN) that uniquely identifies the cluster.
        public let clusterArn: String
        /// The version of the MSK cluster to update. Cluster versions aren't simple numbers. You can describe an MSK cluster to find its version. When this update operation is successful, it generates a new cluster version.
        public let currentVersion: String
        /// Specifies which Apache Kafka metrics Amazon MSK gathers and sends to Amazon CloudWatch for this cluster.
        public let enhancedMonitoring: EnhancedMonitoring?
        public let loggingInfo: LoggingInfo?
        /// The settings for open monitoring.
        public let openMonitoring: OpenMonitoringInfo?

        public init(clusterArn: String, currentVersion: String, enhancedMonitoring: EnhancedMonitoring? = nil, loggingInfo: LoggingInfo? = nil, openMonitoring: OpenMonitoringInfo? = nil) {
            self.clusterArn = clusterArn
            self.currentVersion = currentVersion
            self.enhancedMonitoring = enhancedMonitoring
            self.loggingInfo = loggingInfo
            self.openMonitoring = openMonitoring
        }

        private enum CodingKeys: String, CodingKey {
            case currentVersion
            case enhancedMonitoring
            case loggingInfo
            case openMonitoring
        }
    }

    public struct UpdateMonitoringResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the cluster.
        public let clusterArn: String?
        /// The Amazon Resource Name (ARN) of the cluster operation.
        public let clusterOperationArn: String?

        public init(clusterArn: String? = nil, clusterOperationArn: String? = nil) {
            self.clusterArn = clusterArn
            self.clusterOperationArn = clusterOperationArn
        }

        private enum CodingKeys: String, CodingKey {
            case clusterArn
            case clusterOperationArn
        }
    }

    public struct UpdateSecurityRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "clusterArn", location: .uri("ClusterArn"))
        ]

        /// Includes all client authentication related information.
        public let clientAuthentication: ClientAuthentication?
        /// The Amazon Resource Name (ARN) that uniquely identifies the cluster.
        public let clusterArn: String
        /// The version of the MSK cluster to update. Cluster versions aren't simple numbers. You can describe an MSK cluster to find its version. When this update operation is successful, it generates a new cluster version.
        public let currentVersion: String
        /// Includes all encryption-related information.
        public let encryptionInfo: EncryptionInfo?

        public init(clientAuthentication: ClientAuthentication? = nil, clusterArn: String, currentVersion: String, encryptionInfo: EncryptionInfo? = nil) {
            self.clientAuthentication = clientAuthentication
            self.clusterArn = clusterArn
            self.currentVersion = currentVersion
            self.encryptionInfo = encryptionInfo
        }

        private enum CodingKeys: String, CodingKey {
            case clientAuthentication
            case currentVersion
            case encryptionInfo
        }
    }

    public struct UpdateSecurityResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the cluster.
        public let clusterArn: String?
        /// The Amazon Resource Name (ARN) of the cluster operation.
        public let clusterOperationArn: String?

        public init(clusterArn: String? = nil, clusterOperationArn: String? = nil) {
            self.clusterArn = clusterArn
            self.clusterOperationArn = clusterOperationArn
        }

        private enum CodingKeys: String, CodingKey {
            case clusterArn
            case clusterOperationArn
        }
    }

    public struct UpdateStorageRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "clusterArn", location: .uri("ClusterArn"))
        ]

        /// The Amazon Resource Name (ARN) of the cluster to be updated.
        public let clusterArn: String
        /// The version of cluster to update from. A successful operation will then generate a new version.
        public let currentVersion: String
        /// EBS volume provisioned throughput information.
        public let provisionedThroughput: ProvisionedThroughput?
        /// Controls storage mode for supported storage tiers.
        public let storageMode: StorageMode?
        /// size of the EBS volume to update.
        public let volumeSizeGB: Int?

        public init(clusterArn: String, currentVersion: String, provisionedThroughput: ProvisionedThroughput? = nil, storageMode: StorageMode? = nil, volumeSizeGB: Int? = nil) {
            self.clusterArn = clusterArn
            self.currentVersion = currentVersion
            self.provisionedThroughput = provisionedThroughput
            self.storageMode = storageMode
            self.volumeSizeGB = volumeSizeGB
        }

        private enum CodingKeys: String, CodingKey {
            case currentVersion
            case provisionedThroughput
            case storageMode
            case volumeSizeGB
        }
    }

    public struct UpdateStorageResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the cluster.
        public let clusterArn: String?
        /// The Amazon Resource Name (ARN) of the cluster operation.
        public let clusterOperationArn: String?

        public init(clusterArn: String? = nil, clusterOperationArn: String? = nil) {
            self.clusterArn = clusterArn
            self.clusterOperationArn = clusterOperationArn
        }

        private enum CodingKeys: String, CodingKey {
            case clusterArn
            case clusterOperationArn
        }
    }

    public struct VpcConfig: AWSEncodableShape & AWSDecodableShape {
        /// The IDs of the security groups associated with the cluster.
        public let securityGroupIds: [String]?
        /// The IDs of the subnets associated with the cluster.
        public let subnetIds: [String]

        public init(securityGroupIds: [String]? = nil, subnetIds: [String]) {
            self.securityGroupIds = securityGroupIds
            self.subnetIds = subnetIds
        }

        private enum CodingKeys: String, CodingKey {
            case securityGroupIds
            case subnetIds
        }
    }

    public struct ZookeeperNodeInfo: AWSDecodableShape {
        /// The attached elastic network interface of the broker.
        public let attachedENIId: String?
        /// The virtual private cloud (VPC) IP address of the client.
        public let clientVpcIpAddress: String?
        /// Endpoints for accessing the ZooKeeper.
        public let endpoints: [String]?
        /// The role-specific ID for Zookeeper.
        public let zookeeperId: Double?
        /// The version of Zookeeper.
        public let zookeeperVersion: String?

        public init(attachedENIId: String? = nil, clientVpcIpAddress: String? = nil, endpoints: [String]? = nil, zookeeperId: Double? = nil, zookeeperVersion: String? = nil) {
            self.attachedENIId = attachedENIId
            self.clientVpcIpAddress = clientVpcIpAddress
            self.endpoints = endpoints
            self.zookeeperId = zookeeperId
            self.zookeeperVersion = zookeeperVersion
        }

        private enum CodingKeys: String, CodingKey {
            case attachedENIId
            case clientVpcIpAddress
            case endpoints
            case zookeeperId
            case zookeeperVersion
        }
    }
}

// MARK: - Errors

/// Error enum for Kafka
public struct KafkaErrorType: AWSErrorType {
    enum Code: String {
        case badRequestException = "BadRequestException"
        case conflictException = "ConflictException"
        case forbiddenException = "ForbiddenException"
        case internalServerErrorException = "InternalServerErrorException"
        case notFoundException = "NotFoundException"
        case serviceUnavailableException = "ServiceUnavailableException"
        case tooManyRequestsException = "TooManyRequestsException"
        case unauthorizedException = "UnauthorizedException"
    }

    private let error: Code
    public let context: AWSErrorContext?

    /// initialize Kafka
    public init?(errorCode: String, context: AWSErrorContext) {
        guard let error = Code(rawValue: errorCode) else { return nil }
        self.error = error
        self.context = context
    }

    internal init(_ error: Code) {
        self.error = error
        self.context = nil
    }

    /// return error code string
    public var errorCode: String { self.error.rawValue }

    /// Returns information about an error.
    public static var badRequestException: Self { .init(.badRequestException) }
    /// Returns information about an error.
    public static var conflictException: Self { .init(.conflictException) }
    /// Returns information about an error.
    public static var forbiddenException: Self { .init(.forbiddenException) }
    /// Returns information about an error.
    public static var internalServerErrorException: Self { .init(.internalServerErrorException) }
    /// Returns information about an error.
    public static var notFoundException: Self { .init(.notFoundException) }
    /// Returns information about an error.
    public static var serviceUnavailableException: Self { .init(.serviceUnavailableException) }
    /// Returns information about an error.
    public static var tooManyRequestsException: Self { .init(.tooManyRequestsException) }
    /// Returns information about an error.
    public static var unauthorizedException: Self { .init(.unauthorizedException) }
}

extension KafkaErrorType: Equatable {
    public static func == (lhs: KafkaErrorType, rhs: KafkaErrorType) -> Bool {
        lhs.error == rhs.error
    }
}

extension KafkaErrorType: CustomStringConvertible {
    public var description: String {
        return "\(self.error.rawValue): \(self.message ?? "")"
    }
}
