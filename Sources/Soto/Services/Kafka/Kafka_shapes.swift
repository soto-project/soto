//===----------------------------------------------------------------------===//
//
// This source file is part of the Soto for AWS open source project
//
// Copyright (c) 2017-2023 the Soto project authors
// Licensed under Apache License v2.0
//
// See LICENSE.txt for license information
// See CONTRIBUTORS.txt for the list of Soto project authors
//
// SPDX-License-Identifier: Apache-2.0
//
//===----------------------------------------------------------------------===//

// THIS FILE IS AUTOMATICALLY GENERATED by https://github.com/soto-project/soto-codegenerator.
// DO NOT EDIT.

#if os(Linux) && compiler(<5.10)
// swift-corelibs-foundation hasn't been updated with Sendable conformances
@preconcurrency import Foundation
#else
import Foundation
#endif
@_spi(SotoInternal) import SotoCore

extension Kafka {
    // MARK: Enums

    public enum BrokerAZDistribution: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case `default` = "DEFAULT"
        public var description: String { return self.rawValue }
    }

    public enum ClientBroker: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case plaintext = "PLAINTEXT"
        case tls = "TLS"
        case tlsPlaintext = "TLS_PLAINTEXT"
        public var description: String { return self.rawValue }
    }

    public enum ClusterState: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case active = "ACTIVE"
        case creating = "CREATING"
        case deleting = "DELETING"
        case failed = "FAILED"
        case healing = "HEALING"
        case maintenance = "MAINTENANCE"
        case rebootingBroker = "REBOOTING_BROKER"
        case updating = "UPDATING"
        public var description: String { return self.rawValue }
    }

    public enum ClusterType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case provisioned = "PROVISIONED"
        case serverless = "SERVERLESS"
        public var description: String { return self.rawValue }
    }

    public enum ConfigurationState: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case active = "ACTIVE"
        case deleteFailed = "DELETE_FAILED"
        case deleting = "DELETING"
        public var description: String { return self.rawValue }
    }

    public enum CustomerActionStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case actionRecommended = "ACTION_RECOMMENDED"
        case criticalActionRequired = "CRITICAL_ACTION_REQUIRED"
        case none = "NONE"
        public var description: String { return self.rawValue }
    }

    public enum EnhancedMonitoring: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case `default` = "DEFAULT"
        case perBroker = "PER_BROKER"
        case perTopicPerBroker = "PER_TOPIC_PER_BROKER"
        case perTopicPerPartition = "PER_TOPIC_PER_PARTITION"
        public var description: String { return self.rawValue }
    }

    public enum KafkaVersionStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case active = "ACTIVE"
        case deprecated = "DEPRECATED"
        public var description: String { return self.rawValue }
    }

    public enum NodeType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case broker = "BROKER"
        public var description: String { return self.rawValue }
    }

    public enum ReplicationStartingPositionType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case earliest = "EARLIEST"
        case latest = "LATEST"
        public var description: String { return self.rawValue }
    }

    public enum ReplicatorState: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case creating = "CREATING"
        case deleting = "DELETING"
        case failed = "FAILED"
        case running = "RUNNING"
        case updating = "UPDATING"
        public var description: String { return self.rawValue }
    }

    public enum StorageMode: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case local = "LOCAL"
        case tiered = "TIERED"
        public var description: String { return self.rawValue }
    }

    public enum TargetCompressionType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case gzip = "GZIP"
        case lz4 = "LZ4"
        case none = "NONE"
        case snappy = "SNAPPY"
        case zstd = "ZSTD"
        public var description: String { return self.rawValue }
    }

    public enum UserIdentityType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case awsaccount = "AWSACCOUNT"
        case awsservice = "AWSSERVICE"
        public var description: String { return self.rawValue }
    }

    public enum VpcConnectionState: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case available = "AVAILABLE"
        case creating = "CREATING"
        case deactivating = "DEACTIVATING"
        case deleting = "DELETING"
        case failed = "FAILED"
        case inactive = "INACTIVE"
        case rejected = "REJECTED"
        case rejecting = "REJECTING"
        public var description: String { return self.rawValue }
    }

    // MARK: Shapes

    public struct AmazonMskCluster: AWSEncodableShape & AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of an Amazon MSK cluster.
        public let mskClusterArn: String?

        public init(mskClusterArn: String? = nil) {
            self.mskClusterArn = mskClusterArn
        }

        private enum CodingKeys: String, CodingKey {
            case mskClusterArn = "mskClusterArn"
        }
    }

    public struct BatchAssociateScramSecretRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the cluster to be updated.
        public let clusterArn: String
        /// List of AWS Secrets Manager secret ARNs.
        public let secretArnList: [String]?

        public init(clusterArn: String, secretArnList: [String]? = nil) {
            self.clusterArn = clusterArn
            self.secretArnList = secretArnList
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.clusterArn, key: "ClusterArn")
            try container.encodeIfPresent(self.secretArnList, forKey: .secretArnList)
        }

        private enum CodingKeys: String, CodingKey {
            case secretArnList = "secretArnList"
        }
    }

    public struct BatchAssociateScramSecretResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the cluster.
        public let clusterArn: String?
        /// List of errors when associating secrets to cluster.
        public let unprocessedScramSecrets: [UnprocessedScramSecret]?

        public init(clusterArn: String? = nil, unprocessedScramSecrets: [UnprocessedScramSecret]? = nil) {
            self.clusterArn = clusterArn
            self.unprocessedScramSecrets = unprocessedScramSecrets
        }

        private enum CodingKeys: String, CodingKey {
            case clusterArn = "clusterArn"
            case unprocessedScramSecrets = "unprocessedScramSecrets"
        }
    }

    public struct BatchDisassociateScramSecretRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the cluster to be updated.
        public let clusterArn: String
        /// List of AWS Secrets Manager secret ARNs.
        public let secretArnList: [String]?

        public init(clusterArn: String, secretArnList: [String]? = nil) {
            self.clusterArn = clusterArn
            self.secretArnList = secretArnList
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.clusterArn, key: "ClusterArn")
            try container.encodeIfPresent(self.secretArnList, forKey: .secretArnList)
        }

        private enum CodingKeys: String, CodingKey {
            case secretArnList = "secretArnList"
        }
    }

    public struct BatchDisassociateScramSecretResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the cluster.
        public let clusterArn: String?
        /// List of errors when disassociating secrets to cluster.
        public let unprocessedScramSecrets: [UnprocessedScramSecret]?

        public init(clusterArn: String? = nil, unprocessedScramSecrets: [UnprocessedScramSecret]? = nil) {
            self.clusterArn = clusterArn
            self.unprocessedScramSecrets = unprocessedScramSecrets
        }

        private enum CodingKeys: String, CodingKey {
            case clusterArn = "clusterArn"
            case unprocessedScramSecrets = "unprocessedScramSecrets"
        }
    }

    public struct BrokerEBSVolumeInfo: AWSEncodableShape & AWSDecodableShape {
        /// The ID of the broker to update.
        public let kafkaBrokerNodeId: String?
        /// EBS volume provisioned throughput information.
        public let provisionedThroughput: ProvisionedThroughput?
        /// Size of the EBS volume to update.
        public let volumeSizeGB: Int?

        public init(kafkaBrokerNodeId: String? = nil, provisionedThroughput: ProvisionedThroughput? = nil, volumeSizeGB: Int? = nil) {
            self.kafkaBrokerNodeId = kafkaBrokerNodeId
            self.provisionedThroughput = provisionedThroughput
            self.volumeSizeGB = volumeSizeGB
        }

        private enum CodingKeys: String, CodingKey {
            case kafkaBrokerNodeId = "kafkaBrokerNodeId"
            case provisionedThroughput = "provisionedThroughput"
            case volumeSizeGB = "volumeSizeGB"
        }
    }

    public struct BrokerLogs: AWSEncodableShape & AWSDecodableShape {
        public let cloudWatchLogs: CloudWatchLogs?
        public let firehose: Firehose?
        public let s3: S3?

        public init(cloudWatchLogs: CloudWatchLogs? = nil, firehose: Firehose? = nil, s3: S3? = nil) {
            self.cloudWatchLogs = cloudWatchLogs
            self.firehose = firehose
            self.s3 = s3
        }

        private enum CodingKeys: String, CodingKey {
            case cloudWatchLogs = "cloudWatchLogs"
            case firehose = "firehose"
            case s3 = "s3"
        }
    }

    public struct BrokerNodeGroupInfo: AWSEncodableShape & AWSDecodableShape {
        /// The distribution of broker nodes across Availability Zones. This is an optional parameter. If you don't specify it, Amazon MSK gives it the value DEFAULT. You can also explicitly set this parameter to the value DEFAULT. No other values are currently allowed. Amazon MSK distributes the broker nodes evenly across the Availability Zones that correspond to the subnets you provide when you create the cluster.
        public let brokerAZDistribution: BrokerAZDistribution?
        /// The list of subnets to connect to in the client virtual private cloud (VPC). AWS creates elastic network interfaces inside these subnets. Client applications use elastic network interfaces to produce and consume data. Client subnets can't occupy the Availability Zone with ID use use1-az3.
        public let clientSubnets: [String]?
        /// Information about the broker access configuration.
        public let connectivityInfo: ConnectivityInfo?
        /// The type of Amazon EC2 instances to use for Apache Kafka brokers. The following instance types are allowed: kafka.m5.large, kafka.m5.xlarge, kafka.m5.2xlarge,
        /// kafka.m5.4xlarge, kafka.m5.12xlarge, and kafka.m5.24xlarge.
        public let instanceType: String?
        /// The AWS security groups to associate with the elastic network interfaces in order to specify who can connect to and communicate with the Amazon MSK cluster. If you don't specify a security group, Amazon MSK uses the default security group associated with the VPC.
        public let securityGroups: [String]?
        /// Contains information about storage volumes attached to MSK broker nodes.
        public let storageInfo: StorageInfo?
        /// The list of zoneIds for the cluster in the virtual private cloud (VPC).
        public let zoneIds: [String]?

        public init(brokerAZDistribution: BrokerAZDistribution? = nil, clientSubnets: [String]? = nil, connectivityInfo: ConnectivityInfo? = nil, instanceType: String? = nil, securityGroups: [String]? = nil, storageInfo: StorageInfo? = nil, zoneIds: [String]? = nil) {
            self.brokerAZDistribution = brokerAZDistribution
            self.clientSubnets = clientSubnets
            self.connectivityInfo = connectivityInfo
            self.instanceType = instanceType
            self.securityGroups = securityGroups
            self.storageInfo = storageInfo
            self.zoneIds = zoneIds
        }

        public func validate(name: String) throws {
            try self.validate(self.instanceType, name: "instanceType", parent: name, max: 32)
            try self.validate(self.instanceType, name: "instanceType", parent: name, min: 5)
            try self.storageInfo?.validate(name: "\(name).storageInfo")
        }

        private enum CodingKeys: String, CodingKey {
            case brokerAZDistribution = "brokerAZDistribution"
            case clientSubnets = "clientSubnets"
            case connectivityInfo = "connectivityInfo"
            case instanceType = "instanceType"
            case securityGroups = "securityGroups"
            case storageInfo = "storageInfo"
            case zoneIds = "zoneIds"
        }
    }

    public struct BrokerNodeInfo: AWSDecodableShape {
        /// The attached elastic network interface of the broker.
        public let attachedENIId: String?
        /// The ID of the broker.
        public let brokerId: Double?
        /// The client subnet to which this broker node belongs.
        public let clientSubnet: String?
        /// The virtual private cloud (VPC) of the client.
        public let clientVpcIpAddress: String?
        /// Information about the version of software currently deployed on the Apache Kafka brokers in the cluster.
        public let currentBrokerSoftwareInfo: BrokerSoftwareInfo?
        /// Endpoints for accessing the broker.
        public let endpoints: [String]?

        public init(attachedENIId: String? = nil, brokerId: Double? = nil, clientSubnet: String? = nil, clientVpcIpAddress: String? = nil, currentBrokerSoftwareInfo: BrokerSoftwareInfo? = nil, endpoints: [String]? = nil) {
            self.attachedENIId = attachedENIId
            self.brokerId = brokerId
            self.clientSubnet = clientSubnet
            self.clientVpcIpAddress = clientVpcIpAddress
            self.currentBrokerSoftwareInfo = currentBrokerSoftwareInfo
            self.endpoints = endpoints
        }

        private enum CodingKeys: String, CodingKey {
            case attachedENIId = "attachedENIId"
            case brokerId = "brokerId"
            case clientSubnet = "clientSubnet"
            case clientVpcIpAddress = "clientVpcIpAddress"
            case currentBrokerSoftwareInfo = "currentBrokerSoftwareInfo"
            case endpoints = "endpoints"
        }
    }

    public struct BrokerSoftwareInfo: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the configuration used for the cluster. This field isn't visible in this preview release.
        public let configurationArn: String?
        /// The revision of the configuration to use. This field isn't visible in this preview release.
        public let configurationRevision: Int64?
        /// The version of Apache Kafka.
        public let kafkaVersion: String?

        public init(configurationArn: String? = nil, configurationRevision: Int64? = nil, kafkaVersion: String? = nil) {
            self.configurationArn = configurationArn
            self.configurationRevision = configurationRevision
            self.kafkaVersion = kafkaVersion
        }

        private enum CodingKeys: String, CodingKey {
            case configurationArn = "configurationArn"
            case configurationRevision = "configurationRevision"
            case kafkaVersion = "kafkaVersion"
        }
    }

    public struct ClientAuthentication: AWSEncodableShape & AWSDecodableShape {
        /// Details for ClientAuthentication using SASL.
        public let sasl: Sasl?
        /// Details for ClientAuthentication using TLS.
        public let tls: Tls?
        /// Contains information about unauthenticated traffic to the cluster.
        public let unauthenticated: Unauthenticated?

        public init(sasl: Sasl? = nil, tls: Tls? = nil, unauthenticated: Unauthenticated? = nil) {
            self.sasl = sasl
            self.tls = tls
            self.unauthenticated = unauthenticated
        }

        private enum CodingKeys: String, CodingKey {
            case sasl = "sasl"
            case tls = "tls"
            case unauthenticated = "unauthenticated"
        }
    }

    public struct ClientVpcConnection: AWSDecodableShape {
        /// Information about the auth scheme of Vpc Connection.
        public let authentication: String?
        /// Creation time of the Vpc Connection.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var creationTime: Date?
        /// The Owner of the Vpc Connection.
        public let owner: String?
        /// State of the Vpc Connection.
        public let state: VpcConnectionState?
        /// The ARN that identifies the Vpc Connection.
        public let vpcConnectionArn: String?

        public init(authentication: String? = nil, creationTime: Date? = nil, owner: String? = nil, state: VpcConnectionState? = nil, vpcConnectionArn: String? = nil) {
            self.authentication = authentication
            self.creationTime = creationTime
            self.owner = owner
            self.state = state
            self.vpcConnectionArn = vpcConnectionArn
        }

        private enum CodingKeys: String, CodingKey {
            case authentication = "authentication"
            case creationTime = "creationTime"
            case owner = "owner"
            case state = "state"
            case vpcConnectionArn = "vpcConnectionArn"
        }
    }

    public struct CloudWatchLogs: AWSEncodableShape & AWSDecodableShape {
        public let enabled: Bool?
        public let logGroup: String?

        public init(enabled: Bool? = nil, logGroup: String? = nil) {
            self.enabled = enabled
            self.logGroup = logGroup
        }

        private enum CodingKeys: String, CodingKey {
            case enabled = "enabled"
            case logGroup = "logGroup"
        }
    }

    public struct Cluster: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) that uniquely identifies a cluster operation.
        public let activeOperationArn: String?
        /// The Amazon Resource Name (ARN) that uniquely identifies the cluster.
        public let clusterArn: String?
        /// The name of the cluster.
        public let clusterName: String?
        /// Cluster Type.
        public let clusterType: ClusterType?
        /// The time when the cluster was created.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var creationTime: Date?
        /// The current version of the MSK cluster.
        public let currentVersion: String?
        /// Information about the provisioned cluster.
        public let provisioned: Provisioned?
        /// Information about the serverless cluster.
        public let serverless: Serverless?
        /// The state of the cluster. The possible states are ACTIVE, CREATING, DELETING, FAILED, HEALING, MAINTENANCE, REBOOTING_BROKER, and UPDATING.
        public let state: ClusterState?
        /// State Info for the Amazon MSK cluster.
        public let stateInfo: StateInfo?
        /// Tags attached to the cluster.
        public let tags: [String: String]?

        public init(activeOperationArn: String? = nil, clusterArn: String? = nil, clusterName: String? = nil, clusterType: ClusterType? = nil, creationTime: Date? = nil, currentVersion: String? = nil, provisioned: Provisioned? = nil, serverless: Serverless? = nil, state: ClusterState? = nil, stateInfo: StateInfo? = nil, tags: [String: String]? = nil) {
            self.activeOperationArn = activeOperationArn
            self.clusterArn = clusterArn
            self.clusterName = clusterName
            self.clusterType = clusterType
            self.creationTime = creationTime
            self.currentVersion = currentVersion
            self.provisioned = provisioned
            self.serverless = serverless
            self.state = state
            self.stateInfo = stateInfo
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case activeOperationArn = "activeOperationArn"
            case clusterArn = "clusterArn"
            case clusterName = "clusterName"
            case clusterType = "clusterType"
            case creationTime = "creationTime"
            case currentVersion = "currentVersion"
            case provisioned = "provisioned"
            case serverless = "serverless"
            case state = "state"
            case stateInfo = "stateInfo"
            case tags = "tags"
        }
    }

    public struct ClusterInfo: AWSDecodableShape {
        /// Arn of active cluster operation.
        public let activeOperationArn: String?
        /// Information about the broker nodes.
        public let brokerNodeGroupInfo: BrokerNodeGroupInfo?
        /// Includes all client authentication information.
        public let clientAuthentication: ClientAuthentication?
        /// The Amazon Resource Name (ARN) that uniquely identifies the cluster.
        public let clusterArn: String?
        /// The name of the cluster.
        public let clusterName: String?
        /// The time when the cluster was created.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var creationTime: Date?
        /// Information about the version of software currently deployed on the Apache Kafka brokers in the cluster.
        public let currentBrokerSoftwareInfo: BrokerSoftwareInfo?
        /// The current version of the MSK cluster.
        public let currentVersion: String?
        /// Determines if there is an action required from the customer.
        public let customerActionStatus: CustomerActionStatus?
        /// Includes all encryption-related information.
        public let encryptionInfo: EncryptionInfo?
        /// Specifies which metrics are gathered for the MSK cluster. This property has the following possible values: DEFAULT, PER_BROKER, PER_TOPIC_PER_BROKER, and PER_TOPIC_PER_PARTITION. For a list of the metrics associated with each of these levels of monitoring, see Monitoring.
        public let enhancedMonitoring: EnhancedMonitoring?
        public let loggingInfo: LoggingInfo?
        /// The number of broker nodes in the cluster.
        public let numberOfBrokerNodes: Int?
        /// Settings for open monitoring using Prometheus.
        public let openMonitoring: OpenMonitoring?
        /// The state of the cluster. The possible states are ACTIVE, CREATING, DELETING, FAILED, HEALING, MAINTENANCE, REBOOTING_BROKER, and UPDATING.
        public let state: ClusterState?
        public let stateInfo: StateInfo?
        /// This controls storage mode for supported storage tiers.
        public let storageMode: StorageMode?
        /// Tags attached to the cluster.
        public let tags: [String: String]?
        /// The connection string to use to connect to the Apache ZooKeeper cluster.
        public let zookeeperConnectString: String?
        /// The connection string to use to connect to zookeeper cluster on Tls port.
        public let zookeeperConnectStringTls: String?

        public init(activeOperationArn: String? = nil, brokerNodeGroupInfo: BrokerNodeGroupInfo? = nil, clientAuthentication: ClientAuthentication? = nil, clusterArn: String? = nil, clusterName: String? = nil, creationTime: Date? = nil, currentBrokerSoftwareInfo: BrokerSoftwareInfo? = nil, currentVersion: String? = nil, customerActionStatus: CustomerActionStatus? = nil, encryptionInfo: EncryptionInfo? = nil, enhancedMonitoring: EnhancedMonitoring? = nil, loggingInfo: LoggingInfo? = nil, numberOfBrokerNodes: Int? = nil, openMonitoring: OpenMonitoring? = nil, state: ClusterState? = nil, stateInfo: StateInfo? = nil, storageMode: StorageMode? = nil, tags: [String: String]? = nil, zookeeperConnectString: String? = nil, zookeeperConnectStringTls: String? = nil) {
            self.activeOperationArn = activeOperationArn
            self.brokerNodeGroupInfo = brokerNodeGroupInfo
            self.clientAuthentication = clientAuthentication
            self.clusterArn = clusterArn
            self.clusterName = clusterName
            self.creationTime = creationTime
            self.currentBrokerSoftwareInfo = currentBrokerSoftwareInfo
            self.currentVersion = currentVersion
            self.customerActionStatus = customerActionStatus
            self.encryptionInfo = encryptionInfo
            self.enhancedMonitoring = enhancedMonitoring
            self.loggingInfo = loggingInfo
            self.numberOfBrokerNodes = numberOfBrokerNodes
            self.openMonitoring = openMonitoring
            self.state = state
            self.stateInfo = stateInfo
            self.storageMode = storageMode
            self.tags = tags
            self.zookeeperConnectString = zookeeperConnectString
            self.zookeeperConnectStringTls = zookeeperConnectStringTls
        }

        private enum CodingKeys: String, CodingKey {
            case activeOperationArn = "activeOperationArn"
            case brokerNodeGroupInfo = "brokerNodeGroupInfo"
            case clientAuthentication = "clientAuthentication"
            case clusterArn = "clusterArn"
            case clusterName = "clusterName"
            case creationTime = "creationTime"
            case currentBrokerSoftwareInfo = "currentBrokerSoftwareInfo"
            case currentVersion = "currentVersion"
            case customerActionStatus = "customerActionStatus"
            case encryptionInfo = "encryptionInfo"
            case enhancedMonitoring = "enhancedMonitoring"
            case loggingInfo = "loggingInfo"
            case numberOfBrokerNodes = "numberOfBrokerNodes"
            case openMonitoring = "openMonitoring"
            case state = "state"
            case stateInfo = "stateInfo"
            case storageMode = "storageMode"
            case tags = "tags"
            case zookeeperConnectString = "zookeeperConnectString"
            case zookeeperConnectStringTls = "zookeeperConnectStringTls"
        }
    }

    public struct ClusterOperationInfo: AWSDecodableShape {
        /// The ID of the API request that triggered this operation.
        public let clientRequestId: String?
        /// ARN of the cluster.
        public let clusterArn: String?
        /// The time that the operation was created.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var creationTime: Date?
        /// The time at which the operation finished.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var endTime: Date?
        /// Describes the error if the operation fails.
        public let errorInfo: ErrorInfo?
        /// ARN of the cluster operation.
        public let operationArn: String?
        /// State of the cluster operation.
        public let operationState: String?
        /// Steps completed during the operation.
        public let operationSteps: [ClusterOperationStep]?
        /// Type of the cluster operation.
        public let operationType: String?
        /// Information about cluster attributes before a cluster is updated.
        public let sourceClusterInfo: MutableClusterInfo?
        /// Information about cluster attributes after a cluster is updated.
        public let targetClusterInfo: MutableClusterInfo?
        /// Description of the VPC connection for CreateVpcConnection and DeleteVpcConnection operations.
        public let vpcConnectionInfo: VpcConnectionInfo?

        public init(clientRequestId: String? = nil, clusterArn: String? = nil, creationTime: Date? = nil, endTime: Date? = nil, errorInfo: ErrorInfo? = nil, operationArn: String? = nil, operationState: String? = nil, operationSteps: [ClusterOperationStep]? = nil, operationType: String? = nil, sourceClusterInfo: MutableClusterInfo? = nil, targetClusterInfo: MutableClusterInfo? = nil, vpcConnectionInfo: VpcConnectionInfo? = nil) {
            self.clientRequestId = clientRequestId
            self.clusterArn = clusterArn
            self.creationTime = creationTime
            self.endTime = endTime
            self.errorInfo = errorInfo
            self.operationArn = operationArn
            self.operationState = operationState
            self.operationSteps = operationSteps
            self.operationType = operationType
            self.sourceClusterInfo = sourceClusterInfo
            self.targetClusterInfo = targetClusterInfo
            self.vpcConnectionInfo = vpcConnectionInfo
        }

        private enum CodingKeys: String, CodingKey {
            case clientRequestId = "clientRequestId"
            case clusterArn = "clusterArn"
            case creationTime = "creationTime"
            case endTime = "endTime"
            case errorInfo = "errorInfo"
            case operationArn = "operationArn"
            case operationState = "operationState"
            case operationSteps = "operationSteps"
            case operationType = "operationType"
            case sourceClusterInfo = "sourceClusterInfo"
            case targetClusterInfo = "targetClusterInfo"
            case vpcConnectionInfo = "vpcConnectionInfo"
        }
    }

    public struct ClusterOperationStep: AWSDecodableShape {
        /// Information about the step and its status.
        public let stepInfo: ClusterOperationStepInfo?
        /// The name of the step.
        public let stepName: String?

        public init(stepInfo: ClusterOperationStepInfo? = nil, stepName: String? = nil) {
            self.stepInfo = stepInfo
            self.stepName = stepName
        }

        private enum CodingKeys: String, CodingKey {
            case stepInfo = "stepInfo"
            case stepName = "stepName"
        }
    }

    public struct ClusterOperationStepInfo: AWSDecodableShape {
        /// The steps current status.
        public let stepStatus: String?

        public init(stepStatus: String? = nil) {
            self.stepStatus = stepStatus
        }

        private enum CodingKeys: String, CodingKey {
            case stepStatus = "stepStatus"
        }
    }

    public struct ClusterOperationV2: AWSDecodableShape {
        /// ARN of the cluster.
        public let clusterArn: String?
        /// Type of the backend cluster.
        public let clusterType: ClusterType?
        /// The time at which the operation finished.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var endTime: Date?
        /// If cluster operation failed from an error, it describes the error.
        public let errorInfo: ErrorInfo?
        /// ARN of the cluster operation.
        public let operationArn: String?
        /// State of the cluster operation.
        public let operationState: String?
        /// Type of the cluster operation.
        public let operationType: String?
        /// Properties of a provisioned cluster.
        public let provisioned: ClusterOperationV2Provisioned?
        /// Properties of a serverless cluster.
        public let serverless: ClusterOperationV2Serverless?
        /// The time at which operation was started.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var startTime: Date?

        public init(clusterArn: String? = nil, clusterType: ClusterType? = nil, endTime: Date? = nil, errorInfo: ErrorInfo? = nil, operationArn: String? = nil, operationState: String? = nil, operationType: String? = nil, provisioned: ClusterOperationV2Provisioned? = nil, serverless: ClusterOperationV2Serverless? = nil, startTime: Date? = nil) {
            self.clusterArn = clusterArn
            self.clusterType = clusterType
            self.endTime = endTime
            self.errorInfo = errorInfo
            self.operationArn = operationArn
            self.operationState = operationState
            self.operationType = operationType
            self.provisioned = provisioned
            self.serverless = serverless
            self.startTime = startTime
        }

        private enum CodingKeys: String, CodingKey {
            case clusterArn = "clusterArn"
            case clusterType = "clusterType"
            case endTime = "endTime"
            case errorInfo = "errorInfo"
            case operationArn = "operationArn"
            case operationState = "operationState"
            case operationType = "operationType"
            case provisioned = "provisioned"
            case serverless = "serverless"
            case startTime = "startTime"
        }
    }

    public struct ClusterOperationV2Provisioned: AWSDecodableShape {
        /// Steps completed during the operation.
        public let operationSteps: [ClusterOperationStep]?
        /// Information about cluster attributes before a cluster is updated.
        public let sourceClusterInfo: MutableClusterInfo?
        /// Information about cluster attributes after a cluster is updated.
        public let targetClusterInfo: MutableClusterInfo?
        /// Description of the VPC connection for CreateVpcConnection and DeleteVpcConnection operations.
        public let vpcConnectionInfo: VpcConnectionInfo?

        public init(operationSteps: [ClusterOperationStep]? = nil, sourceClusterInfo: MutableClusterInfo? = nil, targetClusterInfo: MutableClusterInfo? = nil, vpcConnectionInfo: VpcConnectionInfo? = nil) {
            self.operationSteps = operationSteps
            self.sourceClusterInfo = sourceClusterInfo
            self.targetClusterInfo = targetClusterInfo
            self.vpcConnectionInfo = vpcConnectionInfo
        }

        private enum CodingKeys: String, CodingKey {
            case operationSteps = "operationSteps"
            case sourceClusterInfo = "sourceClusterInfo"
            case targetClusterInfo = "targetClusterInfo"
            case vpcConnectionInfo = "vpcConnectionInfo"
        }
    }

    public struct ClusterOperationV2Serverless: AWSDecodableShape {
        /// Description of the VPC connection for CreateVpcConnection and DeleteVpcConnection operations.
        public let vpcConnectionInfo: VpcConnectionInfoServerless?

        public init(vpcConnectionInfo: VpcConnectionInfoServerless? = nil) {
            self.vpcConnectionInfo = vpcConnectionInfo
        }

        private enum CodingKeys: String, CodingKey {
            case vpcConnectionInfo = "vpcConnectionInfo"
        }
    }

    public struct ClusterOperationV2Summary: AWSDecodableShape {
        /// ARN of the cluster.
        public let clusterArn: String?
        /// Type of the backend cluster.
        public let clusterType: ClusterType?
        /// The time at which the operation finished.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var endTime: Date?
        /// ARN of the cluster operation.
        public let operationArn: String?
        /// State of the cluster operation.
        public let operationState: String?
        /// Type of the cluster operation.
        public let operationType: String?
        /// The time at which operation was started.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var startTime: Date?

        public init(clusterArn: String? = nil, clusterType: ClusterType? = nil, endTime: Date? = nil, operationArn: String? = nil, operationState: String? = nil, operationType: String? = nil, startTime: Date? = nil) {
            self.clusterArn = clusterArn
            self.clusterType = clusterType
            self.endTime = endTime
            self.operationArn = operationArn
            self.operationState = operationState
            self.operationType = operationType
            self.startTime = startTime
        }

        private enum CodingKeys: String, CodingKey {
            case clusterArn = "clusterArn"
            case clusterType = "clusterType"
            case endTime = "endTime"
            case operationArn = "operationArn"
            case operationState = "operationState"
            case operationType = "operationType"
            case startTime = "startTime"
        }
    }

    public struct CompatibleKafkaVersion: AWSDecodableShape {
        /// An Apache Kafka version.
        public let sourceVersion: String?
        /// A list of Apache Kafka versions.
        public let targetVersions: [String]?

        public init(sourceVersion: String? = nil, targetVersions: [String]? = nil) {
            self.sourceVersion = sourceVersion
            self.targetVersions = targetVersions
        }

        private enum CodingKeys: String, CodingKey {
            case sourceVersion = "sourceVersion"
            case targetVersions = "targetVersions"
        }
    }

    public struct Configuration: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the configuration.
        public let arn: String?
        /// The time when the configuration was created.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var creationTime: Date?
        /// The description of the configuration.
        public let description: String?
        /// An array of the versions of Apache Kafka with which you can use this MSK configuration. You can use this configuration for an MSK cluster only if the Apache Kafka version specified for the cluster appears in this array.
        public let kafkaVersions: [String]?
        /// Latest revision of the configuration.
        public let latestRevision: ConfigurationRevision?
        /// The name of the configuration.
        public let name: String?
        /// The state of the configuration. The possible states are ACTIVE, DELETING, and DELETE_FAILED.
        public let state: ConfigurationState?

        public init(arn: String? = nil, creationTime: Date? = nil, description: String? = nil, kafkaVersions: [String]? = nil, latestRevision: ConfigurationRevision? = nil, name: String? = nil, state: ConfigurationState? = nil) {
            self.arn = arn
            self.creationTime = creationTime
            self.description = description
            self.kafkaVersions = kafkaVersions
            self.latestRevision = latestRevision
            self.name = name
            self.state = state
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case creationTime = "creationTime"
            case description = "description"
            case kafkaVersions = "kafkaVersions"
            case latestRevision = "latestRevision"
            case name = "name"
            case state = "state"
        }
    }

    public struct ConfigurationInfo: AWSEncodableShape & AWSDecodableShape {
        /// ARN of the configuration to use.
        public let arn: String?
        /// The revision of the configuration to use.
        public let revision: Int64?

        public init(arn: String? = nil, revision: Int64? = nil) {
            self.arn = arn
            self.revision = revision
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case revision = "revision"
        }
    }

    public struct ConfigurationRevision: AWSDecodableShape {
        /// The time when the configuration revision was created.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var creationTime: Date?
        /// The description of the configuration revision.
        public let description: String?
        /// The revision number.
        public let revision: Int64?

        public init(creationTime: Date? = nil, description: String? = nil, revision: Int64? = nil) {
            self.creationTime = creationTime
            self.description = description
            self.revision = revision
        }

        private enum CodingKeys: String, CodingKey {
            case creationTime = "creationTime"
            case description = "description"
            case revision = "revision"
        }
    }

    public struct ConnectivityInfo: AWSEncodableShape & AWSDecodableShape {
        /// Public access control for brokers.
        public let publicAccess: PublicAccess?
        /// VPC connectivity access control for brokers.
        public let vpcConnectivity: VpcConnectivity?

        public init(publicAccess: PublicAccess? = nil, vpcConnectivity: VpcConnectivity? = nil) {
            self.publicAccess = publicAccess
            self.vpcConnectivity = vpcConnectivity
        }

        private enum CodingKeys: String, CodingKey {
            case publicAccess = "publicAccess"
            case vpcConnectivity = "vpcConnectivity"
        }
    }

    public struct ConsumerGroupReplication: AWSEncodableShape & AWSDecodableShape {
        /// List of regular expression patterns indicating the consumer groups that should not be replicated.
        public let consumerGroupsToExclude: [String]?
        /// List of regular expression patterns indicating the consumer groups to copy.
        public let consumerGroupsToReplicate: [String]?
        /// Enables synchronization of consumer groups to target cluster.
        public let detectAndCopyNewConsumerGroups: Bool?
        /// Enables synchronization of consumer group offsets to target cluster. The translated offsets will be written to topic __consumer_offsets.
        public let synchroniseConsumerGroupOffsets: Bool?

        public init(consumerGroupsToExclude: [String]? = nil, consumerGroupsToReplicate: [String]? = nil, detectAndCopyNewConsumerGroups: Bool? = nil, synchroniseConsumerGroupOffsets: Bool? = nil) {
            self.consumerGroupsToExclude = consumerGroupsToExclude
            self.consumerGroupsToReplicate = consumerGroupsToReplicate
            self.detectAndCopyNewConsumerGroups = detectAndCopyNewConsumerGroups
            self.synchroniseConsumerGroupOffsets = synchroniseConsumerGroupOffsets
        }

        public func validate(name: String) throws {
            try self.consumerGroupsToExclude?.forEach {
                try validate($0, name: "consumerGroupsToExclude[]", parent: name, max: 256)
            }
            try self.consumerGroupsToReplicate?.forEach {
                try validate($0, name: "consumerGroupsToReplicate[]", parent: name, max: 256)
            }
        }

        private enum CodingKeys: String, CodingKey {
            case consumerGroupsToExclude = "consumerGroupsToExclude"
            case consumerGroupsToReplicate = "consumerGroupsToReplicate"
            case detectAndCopyNewConsumerGroups = "detectAndCopyNewConsumerGroups"
            case synchroniseConsumerGroupOffsets = "synchroniseConsumerGroupOffsets"
        }
    }

    public struct ConsumerGroupReplicationUpdate: AWSEncodableShape {
        /// List of regular expression patterns indicating the consumer groups that should not be replicated.
        public let consumerGroupsToExclude: [String]?
        /// List of regular expression patterns indicating the consumer groups to copy.
        public let consumerGroupsToReplicate: [String]?
        /// Enables synchronization of consumer groups to target cluster.
        public let detectAndCopyNewConsumerGroups: Bool?
        /// Enables synchronization of consumer group offsets to target cluster. The translated offsets will be written to topic __consumer_offsets.
        public let synchroniseConsumerGroupOffsets: Bool?

        public init(consumerGroupsToExclude: [String]? = nil, consumerGroupsToReplicate: [String]? = nil, detectAndCopyNewConsumerGroups: Bool? = nil, synchroniseConsumerGroupOffsets: Bool? = nil) {
            self.consumerGroupsToExclude = consumerGroupsToExclude
            self.consumerGroupsToReplicate = consumerGroupsToReplicate
            self.detectAndCopyNewConsumerGroups = detectAndCopyNewConsumerGroups
            self.synchroniseConsumerGroupOffsets = synchroniseConsumerGroupOffsets
        }

        public func validate(name: String) throws {
            try self.consumerGroupsToExclude?.forEach {
                try validate($0, name: "consumerGroupsToExclude[]", parent: name, max: 256)
            }
            try self.consumerGroupsToReplicate?.forEach {
                try validate($0, name: "consumerGroupsToReplicate[]", parent: name, max: 256)
            }
        }

        private enum CodingKeys: String, CodingKey {
            case consumerGroupsToExclude = "consumerGroupsToExclude"
            case consumerGroupsToReplicate = "consumerGroupsToReplicate"
            case detectAndCopyNewConsumerGroups = "detectAndCopyNewConsumerGroups"
            case synchroniseConsumerGroupOffsets = "synchroniseConsumerGroupOffsets"
        }
    }

    public struct CreateClusterRequest: AWSEncodableShape {
        /// Information about the broker nodes in the cluster.
        public let brokerNodeGroupInfo: BrokerNodeGroupInfo?
        /// Includes all client authentication related information.
        public let clientAuthentication: ClientAuthentication?
        /// The name of the cluster.
        public let clusterName: String?
        /// Represents the configuration that you want MSK to use for the brokers in a cluster.
        public let configurationInfo: ConfigurationInfo?
        /// Includes all encryption-related information.
        public let encryptionInfo: EncryptionInfo?
        /// Specifies the level of monitoring for the MSK cluster. The possible values are DEFAULT, PER_BROKER, PER_TOPIC_PER_BROKER, and PER_TOPIC_PER_PARTITION.
        public let enhancedMonitoring: EnhancedMonitoring?
        /// The version of Apache Kafka.
        public let kafkaVersion: String?
        public let loggingInfo: LoggingInfo?
        /// The number of broker nodes in the cluster.
        public let numberOfBrokerNodes: Int?
        /// The settings for open monitoring.
        public let openMonitoring: OpenMonitoringInfo?
        /// This controls storage mode for supported storage tiers.
        public let storageMode: StorageMode?
        /// Create tags when creating the cluster.
        public let tags: [String: String]?

        public init(brokerNodeGroupInfo: BrokerNodeGroupInfo? = nil, clientAuthentication: ClientAuthentication? = nil, clusterName: String? = nil, configurationInfo: ConfigurationInfo? = nil, encryptionInfo: EncryptionInfo? = nil, enhancedMonitoring: EnhancedMonitoring? = nil, kafkaVersion: String? = nil, loggingInfo: LoggingInfo? = nil, numberOfBrokerNodes: Int? = nil, openMonitoring: OpenMonitoringInfo? = nil, storageMode: StorageMode? = nil, tags: [String: String]? = nil) {
            self.brokerNodeGroupInfo = brokerNodeGroupInfo
            self.clientAuthentication = clientAuthentication
            self.clusterName = clusterName
            self.configurationInfo = configurationInfo
            self.encryptionInfo = encryptionInfo
            self.enhancedMonitoring = enhancedMonitoring
            self.kafkaVersion = kafkaVersion
            self.loggingInfo = loggingInfo
            self.numberOfBrokerNodes = numberOfBrokerNodes
            self.openMonitoring = openMonitoring
            self.storageMode = storageMode
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.brokerNodeGroupInfo?.validate(name: "\(name).brokerNodeGroupInfo")
            try self.validate(self.clusterName, name: "clusterName", parent: name, max: 64)
            try self.validate(self.clusterName, name: "clusterName", parent: name, min: 1)
            try self.validate(self.kafkaVersion, name: "kafkaVersion", parent: name, max: 128)
            try self.validate(self.kafkaVersion, name: "kafkaVersion", parent: name, min: 1)
            try self.validate(self.numberOfBrokerNodes, name: "numberOfBrokerNodes", parent: name, max: 15)
            try self.validate(self.numberOfBrokerNodes, name: "numberOfBrokerNodes", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case brokerNodeGroupInfo = "brokerNodeGroupInfo"
            case clientAuthentication = "clientAuthentication"
            case clusterName = "clusterName"
            case configurationInfo = "configurationInfo"
            case encryptionInfo = "encryptionInfo"
            case enhancedMonitoring = "enhancedMonitoring"
            case kafkaVersion = "kafkaVersion"
            case loggingInfo = "loggingInfo"
            case numberOfBrokerNodes = "numberOfBrokerNodes"
            case openMonitoring = "openMonitoring"
            case storageMode = "storageMode"
            case tags = "tags"
        }
    }

    public struct CreateClusterResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the cluster.
        public let clusterArn: String?
        /// The name of the MSK cluster.
        public let clusterName: String?
        /// The state of the cluster. The possible states are ACTIVE, CREATING, DELETING, FAILED, HEALING, MAINTENANCE, REBOOTING_BROKER, and UPDATING.
        public let state: ClusterState?

        public init(clusterArn: String? = nil, clusterName: String? = nil, state: ClusterState? = nil) {
            self.clusterArn = clusterArn
            self.clusterName = clusterName
            self.state = state
        }

        private enum CodingKeys: String, CodingKey {
            case clusterArn = "clusterArn"
            case clusterName = "clusterName"
            case state = "state"
        }
    }

    public struct CreateClusterV2Request: AWSEncodableShape {
        /// The name of the cluster.
        public let clusterName: String?
        /// Information about the provisioned cluster.
        public let provisioned: ProvisionedRequest?
        /// Information about the serverless cluster.
        public let serverless: ServerlessRequest?
        /// A map of tags that you want the cluster to have.
        public let tags: [String: String]?

        public init(clusterName: String? = nil, provisioned: ProvisionedRequest? = nil, serverless: ServerlessRequest? = nil, tags: [String: String]? = nil) {
            self.clusterName = clusterName
            self.provisioned = provisioned
            self.serverless = serverless
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.validate(self.clusterName, name: "clusterName", parent: name, max: 64)
            try self.validate(self.clusterName, name: "clusterName", parent: name, min: 1)
            try self.provisioned?.validate(name: "\(name).provisioned")
        }

        private enum CodingKeys: String, CodingKey {
            case clusterName = "clusterName"
            case provisioned = "provisioned"
            case serverless = "serverless"
            case tags = "tags"
        }
    }

    public struct CreateClusterV2Response: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the cluster.
        public let clusterArn: String?
        /// The name of the MSK cluster.
        public let clusterName: String?
        /// The type of the cluster. The possible states are PROVISIONED or SERVERLESS.
        public let clusterType: ClusterType?
        /// The state of the cluster. The possible states are ACTIVE, CREATING, DELETING, FAILED, HEALING, MAINTENANCE, REBOOTING_BROKER, and UPDATING.
        public let state: ClusterState?

        public init(clusterArn: String? = nil, clusterName: String? = nil, clusterType: ClusterType? = nil, state: ClusterState? = nil) {
            self.clusterArn = clusterArn
            self.clusterName = clusterName
            self.clusterType = clusterType
            self.state = state
        }

        private enum CodingKeys: String, CodingKey {
            case clusterArn = "clusterArn"
            case clusterName = "clusterName"
            case clusterType = "clusterType"
            case state = "state"
        }
    }

    public struct CreateConfigurationRequest: AWSEncodableShape {
        /// The description of the configuration.
        public let description: String?
        /// The versions of Apache Kafka with which you can use this MSK configuration.
        public let kafkaVersions: [String]?
        /// The name of the configuration.
        public let name: String?
        /// Contents of the server.properties file. When using the API, you must ensure that the contents of the file are base64 encoded.  When using the AWS Management Console, the SDK, or the AWS CLI, the contents of server.properties can be in plaintext.
        public let serverProperties: AWSBase64Data?

        public init(description: String? = nil, kafkaVersions: [String]? = nil, name: String? = nil, serverProperties: AWSBase64Data? = nil) {
            self.description = description
            self.kafkaVersions = kafkaVersions
            self.name = name
            self.serverProperties = serverProperties
        }

        private enum CodingKeys: String, CodingKey {
            case description = "description"
            case kafkaVersions = "kafkaVersions"
            case name = "name"
            case serverProperties = "serverProperties"
        }
    }

    public struct CreateConfigurationResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the configuration.
        public let arn: String?
        /// The time when the configuration was created.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var creationTime: Date?
        /// Latest revision of the configuration.
        public let latestRevision: ConfigurationRevision?
        /// The name of the configuration.
        public let name: String?
        /// The state of the configuration. The possible states are ACTIVE, DELETING, and DELETE_FAILED.
        public let state: ConfigurationState?

        public init(arn: String? = nil, creationTime: Date? = nil, latestRevision: ConfigurationRevision? = nil, name: String? = nil, state: ConfigurationState? = nil) {
            self.arn = arn
            self.creationTime = creationTime
            self.latestRevision = latestRevision
            self.name = name
            self.state = state
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case creationTime = "creationTime"
            case latestRevision = "latestRevision"
            case name = "name"
            case state = "state"
        }
    }

    public struct CreateReplicatorRequest: AWSEncodableShape {
        /// A summary description of the replicator.
        public let description: String?
        /// Kafka Clusters to use in setting up sources / targets for replication.
        public let kafkaClusters: [KafkaCluster]?
        /// A list of replication configurations, where each configuration targets a given source cluster to target cluster replication flow.
        public let replicationInfoList: [ReplicationInfo]?
        /// The name of the replicator. Alpha-numeric characters with '-' are allowed.
        public let replicatorName: String?
        /// The ARN of the IAM role used by the replicator to access resources in the customer's account (e.g source and target clusters)
        public let serviceExecutionRoleArn: String?
        /// List of tags to attach to created Replicator.
        public let tags: [String: String]?

        public init(description: String? = nil, kafkaClusters: [KafkaCluster]? = nil, replicationInfoList: [ReplicationInfo]? = nil, replicatorName: String? = nil, serviceExecutionRoleArn: String? = nil, tags: [String: String]? = nil) {
            self.description = description
            self.kafkaClusters = kafkaClusters
            self.replicationInfoList = replicationInfoList
            self.replicatorName = replicatorName
            self.serviceExecutionRoleArn = serviceExecutionRoleArn
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.validate(self.description, name: "description", parent: name, max: 1024)
            try self.replicationInfoList?.forEach {
                try $0.validate(name: "\(name).replicationInfoList[]")
            }
            try self.validate(self.replicatorName, name: "replicatorName", parent: name, max: 128)
            try self.validate(self.replicatorName, name: "replicatorName", parent: name, min: 1)
            try self.validate(self.replicatorName, name: "replicatorName", parent: name, pattern: "^[0-9A-Za-z][0-9A-Za-z-]{0,}$")
        }

        private enum CodingKeys: String, CodingKey {
            case description = "description"
            case kafkaClusters = "kafkaClusters"
            case replicationInfoList = "replicationInfoList"
            case replicatorName = "replicatorName"
            case serviceExecutionRoleArn = "serviceExecutionRoleArn"
            case tags = "tags"
        }
    }

    public struct CreateReplicatorResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the replicator.
        public let replicatorArn: String?
        /// Name of the replicator provided by the customer.
        public let replicatorName: String?
        /// State of the replicator.
        public let replicatorState: ReplicatorState?

        public init(replicatorArn: String? = nil, replicatorName: String? = nil, replicatorState: ReplicatorState? = nil) {
            self.replicatorArn = replicatorArn
            self.replicatorName = replicatorName
            self.replicatorState = replicatorState
        }

        private enum CodingKeys: String, CodingKey {
            case replicatorArn = "replicatorArn"
            case replicatorName = "replicatorName"
            case replicatorState = "replicatorState"
        }
    }

    public struct CreateVpcConnectionRequest: AWSEncodableShape {
        /// The authentication type of VPC connection.
        public let authentication: String?
        /// The list of client subnets.
        public let clientSubnets: [String]?
        /// The list of security groups.
        public let securityGroups: [String]?
        /// A map of tags for the VPC connection.
        public let tags: [String: String]?
        /// The cluster Amazon Resource Name (ARN) for the VPC connection.
        public let targetClusterArn: String?
        /// The VPC ID of VPC connection.
        public let vpcId: String?

        public init(authentication: String? = nil, clientSubnets: [String]? = nil, securityGroups: [String]? = nil, tags: [String: String]? = nil, targetClusterArn: String? = nil, vpcId: String? = nil) {
            self.authentication = authentication
            self.clientSubnets = clientSubnets
            self.securityGroups = securityGroups
            self.tags = tags
            self.targetClusterArn = targetClusterArn
            self.vpcId = vpcId
        }

        private enum CodingKeys: String, CodingKey {
            case authentication = "authentication"
            case clientSubnets = "clientSubnets"
            case securityGroups = "securityGroups"
            case tags = "tags"
            case targetClusterArn = "targetClusterArn"
            case vpcId = "vpcId"
        }
    }

    public struct CreateVpcConnectionResponse: AWSDecodableShape {
        /// The authentication type of VPC connection.
        public let authentication: String?
        /// The list of client subnets.
        public let clientSubnets: [String]?
        /// The creation time of VPC connection.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var creationTime: Date?
        /// The list of security groups.
        public let securityGroups: [String]?
        /// The State of Vpc Connection.
        public let state: VpcConnectionState?
        /// A map of tags for the VPC connection.
        public let tags: [String: String]?
        /// The VPC connection ARN.
        public let vpcConnectionArn: String?
        /// The VPC ID of the VPC connection.
        public let vpcId: String?

        public init(authentication: String? = nil, clientSubnets: [String]? = nil, creationTime: Date? = nil, securityGroups: [String]? = nil, state: VpcConnectionState? = nil, tags: [String: String]? = nil, vpcConnectionArn: String? = nil, vpcId: String? = nil) {
            self.authentication = authentication
            self.clientSubnets = clientSubnets
            self.creationTime = creationTime
            self.securityGroups = securityGroups
            self.state = state
            self.tags = tags
            self.vpcConnectionArn = vpcConnectionArn
            self.vpcId = vpcId
        }

        private enum CodingKeys: String, CodingKey {
            case authentication = "authentication"
            case clientSubnets = "clientSubnets"
            case creationTime = "creationTime"
            case securityGroups = "securityGroups"
            case state = "state"
            case tags = "tags"
            case vpcConnectionArn = "vpcConnectionArn"
            case vpcId = "vpcId"
        }
    }

    public struct DeleteClusterPolicyRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the cluster.
        public let clusterArn: String

        public init(clusterArn: String) {
            self.clusterArn = clusterArn
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.clusterArn, key: "ClusterArn")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteClusterPolicyResponse: AWSDecodableShape {
        public init() {}
    }

    public struct DeleteClusterRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) that uniquely identifies the cluster.
        public let clusterArn: String
        /// The current version of the MSK cluster.
        public let currentVersion: String?

        public init(clusterArn: String, currentVersion: String? = nil) {
            self.clusterArn = clusterArn
            self.currentVersion = currentVersion
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.clusterArn, key: "ClusterArn")
            request.encodeQuery(self.currentVersion, key: "currentVersion")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteClusterResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the cluster.
        public let clusterArn: String?
        /// The state of the cluster. The possible states are ACTIVE, CREATING, DELETING, FAILED, HEALING, MAINTENANCE, REBOOTING_BROKER, and UPDATING.
        public let state: ClusterState?

        public init(clusterArn: String? = nil, state: ClusterState? = nil) {
            self.clusterArn = clusterArn
            self.state = state
        }

        private enum CodingKeys: String, CodingKey {
            case clusterArn = "clusterArn"
            case state = "state"
        }
    }

    public struct DeleteConfigurationRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) that uniquely identifies an MSK configuration.
        public let arn: String

        public init(arn: String) {
            self.arn = arn
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.arn, key: "Arn")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteConfigurationResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) that uniquely identifies an MSK configuration.
        public let arn: String?
        /// The state of the configuration. The possible states are ACTIVE, DELETING, and DELETE_FAILED.
        public let state: ConfigurationState?

        public init(arn: String? = nil, state: ConfigurationState? = nil) {
            self.arn = arn
            self.state = state
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case state = "state"
        }
    }

    public struct DeleteReplicatorRequest: AWSEncodableShape {
        /// The current version of the replicator.
        public let currentVersion: String?
        /// The Amazon Resource Name (ARN) of the replicator to be deleted.
        public let replicatorArn: String

        public init(currentVersion: String? = nil, replicatorArn: String) {
            self.currentVersion = currentVersion
            self.replicatorArn = replicatorArn
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.currentVersion, key: "currentVersion")
            request.encodePath(self.replicatorArn, key: "ReplicatorArn")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteReplicatorResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the replicator.
        public let replicatorArn: String?
        /// The state of the replicator.
        public let replicatorState: ReplicatorState?

        public init(replicatorArn: String? = nil, replicatorState: ReplicatorState? = nil) {
            self.replicatorArn = replicatorArn
            self.replicatorState = replicatorState
        }

        private enum CodingKeys: String, CodingKey {
            case replicatorArn = "replicatorArn"
            case replicatorState = "replicatorState"
        }
    }

    public struct DeleteVpcConnectionRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) that uniquely identifies an MSK VPC connection.
        public let arn: String

        public init(arn: String) {
            self.arn = arn
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.arn, key: "Arn")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteVpcConnectionResponse: AWSDecodableShape {
        /// The state of the VPC connection.
        public let state: VpcConnectionState?
        /// The Amazon Resource Name (ARN) that uniquely identifies an MSK VPC connection.
        public let vpcConnectionArn: String?

        public init(state: VpcConnectionState? = nil, vpcConnectionArn: String? = nil) {
            self.state = state
            self.vpcConnectionArn = vpcConnectionArn
        }

        private enum CodingKeys: String, CodingKey {
            case state = "state"
            case vpcConnectionArn = "vpcConnectionArn"
        }
    }

    public struct DescribeClusterOperationRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) that uniquely identifies the MSK cluster operation.
        public let clusterOperationArn: String

        public init(clusterOperationArn: String) {
            self.clusterOperationArn = clusterOperationArn
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.clusterOperationArn, key: "ClusterOperationArn")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DescribeClusterOperationResponse: AWSDecodableShape {
        /// Cluster operation information
        public let clusterOperationInfo: ClusterOperationInfo?

        public init(clusterOperationInfo: ClusterOperationInfo? = nil) {
            self.clusterOperationInfo = clusterOperationInfo
        }

        private enum CodingKeys: String, CodingKey {
            case clusterOperationInfo = "clusterOperationInfo"
        }
    }

    public struct DescribeClusterOperationV2Request: AWSEncodableShape {
        /// ARN of the cluster operation to describe.
        public let clusterOperationArn: String

        public init(clusterOperationArn: String) {
            self.clusterOperationArn = clusterOperationArn
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.clusterOperationArn, key: "ClusterOperationArn")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DescribeClusterOperationV2Response: AWSDecodableShape {
        /// Cluster operation information
        public let clusterOperationInfo: ClusterOperationV2?

        public init(clusterOperationInfo: ClusterOperationV2? = nil) {
            self.clusterOperationInfo = clusterOperationInfo
        }

        private enum CodingKeys: String, CodingKey {
            case clusterOperationInfo = "clusterOperationInfo"
        }
    }

    public struct DescribeClusterRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) that uniquely identifies the cluster.
        public let clusterArn: String

        public init(clusterArn: String) {
            self.clusterArn = clusterArn
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.clusterArn, key: "ClusterArn")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DescribeClusterResponse: AWSDecodableShape {
        /// The cluster information.
        public let clusterInfo: ClusterInfo?

        public init(clusterInfo: ClusterInfo? = nil) {
            self.clusterInfo = clusterInfo
        }

        private enum CodingKeys: String, CodingKey {
            case clusterInfo = "clusterInfo"
        }
    }

    public struct DescribeClusterV2Request: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) that uniquely identifies the cluster.
        public let clusterArn: String

        public init(clusterArn: String) {
            self.clusterArn = clusterArn
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.clusterArn, key: "ClusterArn")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DescribeClusterV2Response: AWSDecodableShape {
        /// The cluster information.
        public let clusterInfo: Cluster?

        public init(clusterInfo: Cluster? = nil) {
            self.clusterInfo = clusterInfo
        }

        private enum CodingKeys: String, CodingKey {
            case clusterInfo = "clusterInfo"
        }
    }

    public struct DescribeConfigurationRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) that uniquely identifies an MSK configuration and all of its revisions.
        public let arn: String

        public init(arn: String) {
            self.arn = arn
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.arn, key: "Arn")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DescribeConfigurationResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the configuration.
        public let arn: String?
        /// The time when the configuration was created.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var creationTime: Date?
        /// The description of the configuration.
        public let description: String?
        /// The versions of Apache Kafka with which you can use this MSK configuration.
        public let kafkaVersions: [String]?
        /// Latest revision of the configuration.
        public let latestRevision: ConfigurationRevision?
        /// The name of the configuration.
        public let name: String?
        /// The state of the configuration. The possible states are ACTIVE, DELETING, and DELETE_FAILED.
        public let state: ConfigurationState?

        public init(arn: String? = nil, creationTime: Date? = nil, description: String? = nil, kafkaVersions: [String]? = nil, latestRevision: ConfigurationRevision? = nil, name: String? = nil, state: ConfigurationState? = nil) {
            self.arn = arn
            self.creationTime = creationTime
            self.description = description
            self.kafkaVersions = kafkaVersions
            self.latestRevision = latestRevision
            self.name = name
            self.state = state
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case creationTime = "creationTime"
            case description = "description"
            case kafkaVersions = "kafkaVersions"
            case latestRevision = "latestRevision"
            case name = "name"
            case state = "state"
        }
    }

    public struct DescribeConfigurationRevisionRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) that uniquely identifies an MSK configuration and all of its revisions.
        public let arn: String
        /// A string that uniquely identifies a revision of an MSK configuration.
        public let revision: Int64

        public init(arn: String, revision: Int64) {
            self.arn = arn
            self.revision = revision
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.arn, key: "Arn")
            request.encodePath(self.revision, key: "Revision")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DescribeConfigurationRevisionResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the configuration.
        public let arn: String?
        /// The time when the configuration was created.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var creationTime: Date?
        /// The description of the configuration.
        public let description: String?
        /// The revision number.
        public let revision: Int64?
        /// Contents of the server.properties file. When using the API, you must ensure that the contents of the file are base64 encoded.  When using the AWS Management Console, the SDK, or the AWS CLI, the contents of server.properties can be in plaintext.
        public let serverProperties: AWSBase64Data?

        public init(arn: String? = nil, creationTime: Date? = nil, description: String? = nil, revision: Int64? = nil, serverProperties: AWSBase64Data? = nil) {
            self.arn = arn
            self.creationTime = creationTime
            self.description = description
            self.revision = revision
            self.serverProperties = serverProperties
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case creationTime = "creationTime"
            case description = "description"
            case revision = "revision"
            case serverProperties = "serverProperties"
        }
    }

    public struct DescribeReplicatorRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the replicator to be described.
        public let replicatorArn: String

        public init(replicatorArn: String) {
            self.replicatorArn = replicatorArn
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.replicatorArn, key: "ReplicatorArn")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DescribeReplicatorResponse: AWSDecodableShape {
        /// The time when the replicator was created.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var creationTime: Date?
        /// The current version number of the replicator.
        public let currentVersion: String?
        /// Whether this resource is a replicator reference.
        public let isReplicatorReference: Bool?
        /// Kafka Clusters used in setting up sources / targets for replication.
        public let kafkaClusters: [KafkaClusterDescription]?
        /// A list of replication configurations, where each configuration targets a given source cluster to target cluster replication flow.
        public let replicationInfoList: [ReplicationInfoDescription]?
        /// The Amazon Resource Name (ARN) of the replicator.
        public let replicatorArn: String?
        /// The description of the replicator.
        public let replicatorDescription: String?
        /// The name of the replicator.
        public let replicatorName: String?
        /// The Amazon Resource Name (ARN) of the replicator resource in the region where the replicator was created.
        public let replicatorResourceArn: String?
        /// State of the replicator.
        public let replicatorState: ReplicatorState?
        /// The Amazon Resource Name (ARN) of the IAM role used by the replicator to access resources in the customer's account (e.g source and target clusters)
        public let serviceExecutionRoleArn: String?
        /// Details about the state of the replicator.
        public let stateInfo: ReplicationStateInfo?
        /// List of tags attached to the Replicator.
        public let tags: [String: String]?

        public init(creationTime: Date? = nil, currentVersion: String? = nil, isReplicatorReference: Bool? = nil, kafkaClusters: [KafkaClusterDescription]? = nil, replicationInfoList: [ReplicationInfoDescription]? = nil, replicatorArn: String? = nil, replicatorDescription: String? = nil, replicatorName: String? = nil, replicatorResourceArn: String? = nil, replicatorState: ReplicatorState? = nil, serviceExecutionRoleArn: String? = nil, stateInfo: ReplicationStateInfo? = nil, tags: [String: String]? = nil) {
            self.creationTime = creationTime
            self.currentVersion = currentVersion
            self.isReplicatorReference = isReplicatorReference
            self.kafkaClusters = kafkaClusters
            self.replicationInfoList = replicationInfoList
            self.replicatorArn = replicatorArn
            self.replicatorDescription = replicatorDescription
            self.replicatorName = replicatorName
            self.replicatorResourceArn = replicatorResourceArn
            self.replicatorState = replicatorState
            self.serviceExecutionRoleArn = serviceExecutionRoleArn
            self.stateInfo = stateInfo
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case creationTime = "creationTime"
            case currentVersion = "currentVersion"
            case isReplicatorReference = "isReplicatorReference"
            case kafkaClusters = "kafkaClusters"
            case replicationInfoList = "replicationInfoList"
            case replicatorArn = "replicatorArn"
            case replicatorDescription = "replicatorDescription"
            case replicatorName = "replicatorName"
            case replicatorResourceArn = "replicatorResourceArn"
            case replicatorState = "replicatorState"
            case serviceExecutionRoleArn = "serviceExecutionRoleArn"
            case stateInfo = "stateInfo"
            case tags = "tags"
        }
    }

    public struct DescribeVpcConnectionRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) that uniquely identifies a MSK VPC connection.
        public let arn: String

        public init(arn: String) {
            self.arn = arn
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.arn, key: "Arn")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DescribeVpcConnectionResponse: AWSDecodableShape {
        /// The authentication type of VPC connection.
        public let authentication: String?
        /// The creation time of the VPC connection.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var creationTime: Date?
        /// The list of security groups for the VPC connection.
        public let securityGroups: [String]?
        /// The state of VPC connection.
        public let state: VpcConnectionState?
        /// The list of subnets for the VPC connection.
        public let subnets: [String]?
        /// A map of tags for the VPC connection.
        public let tags: [String: String]?
        /// The Amazon Resource Name (ARN) that uniquely identifies an MSK cluster.
        public let targetClusterArn: String?
        /// The Amazon Resource Name (ARN) that uniquely identifies a MSK VPC connection.
        public let vpcConnectionArn: String?
        /// The VPC Id for the VPC connection.
        public let vpcId: String?

        public init(authentication: String? = nil, creationTime: Date? = nil, securityGroups: [String]? = nil, state: VpcConnectionState? = nil, subnets: [String]? = nil, tags: [String: String]? = nil, targetClusterArn: String? = nil, vpcConnectionArn: String? = nil, vpcId: String? = nil) {
            self.authentication = authentication
            self.creationTime = creationTime
            self.securityGroups = securityGroups
            self.state = state
            self.subnets = subnets
            self.tags = tags
            self.targetClusterArn = targetClusterArn
            self.vpcConnectionArn = vpcConnectionArn
            self.vpcId = vpcId
        }

        private enum CodingKeys: String, CodingKey {
            case authentication = "authentication"
            case creationTime = "creationTime"
            case securityGroups = "securityGroups"
            case state = "state"
            case subnets = "subnets"
            case tags = "tags"
            case targetClusterArn = "targetClusterArn"
            case vpcConnectionArn = "vpcConnectionArn"
            case vpcId = "vpcId"
        }
    }

    public struct EBSStorageInfo: AWSEncodableShape & AWSDecodableShape {
        /// EBS volume provisioned throughput information.
        public let provisionedThroughput: ProvisionedThroughput?
        /// The size in GiB of the EBS volume for the data drive on each broker node.
        public let volumeSize: Int?

        public init(provisionedThroughput: ProvisionedThroughput? = nil, volumeSize: Int? = nil) {
            self.provisionedThroughput = provisionedThroughput
            self.volumeSize = volumeSize
        }

        public func validate(name: String) throws {
            try self.validate(self.volumeSize, name: "volumeSize", parent: name, max: 16384)
            try self.validate(self.volumeSize, name: "volumeSize", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case provisionedThroughput = "provisionedThroughput"
            case volumeSize = "volumeSize"
        }
    }

    public struct EncryptionAtRest: AWSEncodableShape & AWSDecodableShape {
        /// The ARN of the AWS KMS key for encrypting data at rest. If you don't specify a KMS key, MSK creates one for you and uses it.
        public let dataVolumeKMSKeyId: String?

        public init(dataVolumeKMSKeyId: String? = nil) {
            self.dataVolumeKMSKeyId = dataVolumeKMSKeyId
        }

        private enum CodingKeys: String, CodingKey {
            case dataVolumeKMSKeyId = "dataVolumeKMSKeyId"
        }
    }

    public struct EncryptionInTransit: AWSEncodableShape & AWSDecodableShape {
        /// Indicates the encryption setting for data in transit between clients and brokers. The following are the possible values.  TLS means that client-broker communication is enabled with TLS only.  TLS_PLAINTEXT means that client-broker communication is enabled for both TLS-encrypted, as well as plaintext data.  PLAINTEXT means that client-broker communication is enabled in plaintext only. The default value is TLS_PLAINTEXT.
        public let clientBroker: ClientBroker?
        /// When set to true, it indicates that data communication among the broker nodes of the cluster is encrypted. When set to false, the communication happens in plaintext. The default value is true.
        public let inCluster: Bool?

        public init(clientBroker: ClientBroker? = nil, inCluster: Bool? = nil) {
            self.clientBroker = clientBroker
            self.inCluster = inCluster
        }

        private enum CodingKeys: String, CodingKey {
            case clientBroker = "clientBroker"
            case inCluster = "inCluster"
        }
    }

    public struct EncryptionInfo: AWSEncodableShape & AWSDecodableShape {
        /// The data-volume encryption details.
        public let encryptionAtRest: EncryptionAtRest?
        /// The details for encryption in transit.
        public let encryptionInTransit: EncryptionInTransit?

        public init(encryptionAtRest: EncryptionAtRest? = nil, encryptionInTransit: EncryptionInTransit? = nil) {
            self.encryptionAtRest = encryptionAtRest
            self.encryptionInTransit = encryptionInTransit
        }

        private enum CodingKeys: String, CodingKey {
            case encryptionAtRest = "encryptionAtRest"
            case encryptionInTransit = "encryptionInTransit"
        }
    }

    public struct ErrorInfo: AWSDecodableShape {
        /// A number describing the error programmatically.
        public let errorCode: String?
        /// An optional field to provide more details about the error.
        public let errorString: String?

        public init(errorCode: String? = nil, errorString: String? = nil) {
            self.errorCode = errorCode
            self.errorString = errorString
        }

        private enum CodingKeys: String, CodingKey {
            case errorCode = "errorCode"
            case errorString = "errorString"
        }
    }

    public struct Firehose: AWSEncodableShape & AWSDecodableShape {
        public let deliveryStream: String?
        public let enabled: Bool?

        public init(deliveryStream: String? = nil, enabled: Bool? = nil) {
            self.deliveryStream = deliveryStream
            self.enabled = enabled
        }

        private enum CodingKeys: String, CodingKey {
            case deliveryStream = "deliveryStream"
            case enabled = "enabled"
        }
    }

    public struct GetBootstrapBrokersRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) that uniquely identifies the cluster.
        public let clusterArn: String

        public init(clusterArn: String) {
            self.clusterArn = clusterArn
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.clusterArn, key: "ClusterArn")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetBootstrapBrokersResponse: AWSDecodableShape {
        /// A string containing one or more hostname:port pairs.
        public let bootstrapBrokerString: String?
        /// A string that contains one or more DNS names (or IP addresses) and SASL IAM port pairs.
        public let bootstrapBrokerStringPublicSaslIam: String?
        /// A string containing one or more DNS names (or IP) and Sasl Scram port pairs.
        public let bootstrapBrokerStringPublicSaslScram: String?
        /// A string containing one or more DNS names (or IP) and TLS port pairs.
        public let bootstrapBrokerStringPublicTls: String?
        /// A string that contains one or more DNS names (or IP addresses) and SASL IAM port pairs.
        public let bootstrapBrokerStringSaslIam: String?
        /// A string containing one or more DNS names (or IP) and Sasl Scram port pairs.
        public let bootstrapBrokerStringSaslScram: String?
        /// A string containing one or more DNS names (or IP) and TLS port pairs.
        public let bootstrapBrokerStringTls: String?
        /// A string containing one or more DNS names (or IP) and SASL/IAM port pairs for VPC connectivity.
        public let bootstrapBrokerStringVpcConnectivitySaslIam: String?
        /// A string containing one or more DNS names (or IP) and SASL/SCRAM port pairs for VPC connectivity.
        public let bootstrapBrokerStringVpcConnectivitySaslScram: String?
        /// A string containing one or more DNS names (or IP) and TLS port pairs for VPC connectivity.
        public let bootstrapBrokerStringVpcConnectivityTls: String?

        public init(bootstrapBrokerString: String? = nil, bootstrapBrokerStringPublicSaslIam: String? = nil, bootstrapBrokerStringPublicSaslScram: String? = nil, bootstrapBrokerStringPublicTls: String? = nil, bootstrapBrokerStringSaslIam: String? = nil, bootstrapBrokerStringSaslScram: String? = nil, bootstrapBrokerStringTls: String? = nil, bootstrapBrokerStringVpcConnectivitySaslIam: String? = nil, bootstrapBrokerStringVpcConnectivitySaslScram: String? = nil, bootstrapBrokerStringVpcConnectivityTls: String? = nil) {
            self.bootstrapBrokerString = bootstrapBrokerString
            self.bootstrapBrokerStringPublicSaslIam = bootstrapBrokerStringPublicSaslIam
            self.bootstrapBrokerStringPublicSaslScram = bootstrapBrokerStringPublicSaslScram
            self.bootstrapBrokerStringPublicTls = bootstrapBrokerStringPublicTls
            self.bootstrapBrokerStringSaslIam = bootstrapBrokerStringSaslIam
            self.bootstrapBrokerStringSaslScram = bootstrapBrokerStringSaslScram
            self.bootstrapBrokerStringTls = bootstrapBrokerStringTls
            self.bootstrapBrokerStringVpcConnectivitySaslIam = bootstrapBrokerStringVpcConnectivitySaslIam
            self.bootstrapBrokerStringVpcConnectivitySaslScram = bootstrapBrokerStringVpcConnectivitySaslScram
            self.bootstrapBrokerStringVpcConnectivityTls = bootstrapBrokerStringVpcConnectivityTls
        }

        private enum CodingKeys: String, CodingKey {
            case bootstrapBrokerString = "bootstrapBrokerString"
            case bootstrapBrokerStringPublicSaslIam = "bootstrapBrokerStringPublicSaslIam"
            case bootstrapBrokerStringPublicSaslScram = "bootstrapBrokerStringPublicSaslScram"
            case bootstrapBrokerStringPublicTls = "bootstrapBrokerStringPublicTls"
            case bootstrapBrokerStringSaslIam = "bootstrapBrokerStringSaslIam"
            case bootstrapBrokerStringSaslScram = "bootstrapBrokerStringSaslScram"
            case bootstrapBrokerStringTls = "bootstrapBrokerStringTls"
            case bootstrapBrokerStringVpcConnectivitySaslIam = "bootstrapBrokerStringVpcConnectivitySaslIam"
            case bootstrapBrokerStringVpcConnectivitySaslScram = "bootstrapBrokerStringVpcConnectivitySaslScram"
            case bootstrapBrokerStringVpcConnectivityTls = "bootstrapBrokerStringVpcConnectivityTls"
        }
    }

    public struct GetClusterPolicyRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the cluster.
        public let clusterArn: String

        public init(clusterArn: String) {
            self.clusterArn = clusterArn
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.clusterArn, key: "ClusterArn")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetClusterPolicyResponse: AWSDecodableShape {
        /// The version of cluster policy.
        public let currentVersion: String?
        /// The cluster policy.
        public let policy: String?

        public init(currentVersion: String? = nil, policy: String? = nil) {
            self.currentVersion = currentVersion
            self.policy = policy
        }

        private enum CodingKeys: String, CodingKey {
            case currentVersion = "currentVersion"
            case policy = "policy"
        }
    }

    public struct GetCompatibleKafkaVersionsRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the cluster check.
        public let clusterArn: String?

        public init(clusterArn: String? = nil) {
            self.clusterArn = clusterArn
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.clusterArn, key: "clusterArn")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetCompatibleKafkaVersionsResponse: AWSDecodableShape {
        /// A list of CompatibleKafkaVersion objects.
        public let compatibleKafkaVersions: [CompatibleKafkaVersion]?

        public init(compatibleKafkaVersions: [CompatibleKafkaVersion]? = nil) {
            self.compatibleKafkaVersions = compatibleKafkaVersions
        }

        private enum CodingKeys: String, CodingKey {
            case compatibleKafkaVersions = "compatibleKafkaVersions"
        }
    }

    public struct Iam: AWSEncodableShape & AWSDecodableShape {
        /// Indicates whether IAM access control is enabled.
        public let enabled: Bool?

        public init(enabled: Bool? = nil) {
            self.enabled = enabled
        }

        private enum CodingKeys: String, CodingKey {
            case enabled = "enabled"
        }
    }

    public struct JmxExporter: AWSDecodableShape {
        /// Indicates whether you want to turn on or turn off the JMX Exporter.
        public let enabledInBroker: Bool?

        public init(enabledInBroker: Bool? = nil) {
            self.enabledInBroker = enabledInBroker
        }

        private enum CodingKeys: String, CodingKey {
            case enabledInBroker = "enabledInBroker"
        }
    }

    public struct JmxExporterInfo: AWSEncodableShape & AWSDecodableShape {
        /// Indicates whether you want to turn on or turn off the JMX Exporter.
        public let enabledInBroker: Bool?

        public init(enabledInBroker: Bool? = nil) {
            self.enabledInBroker = enabledInBroker
        }

        private enum CodingKeys: String, CodingKey {
            case enabledInBroker = "enabledInBroker"
        }
    }

    public struct KafkaCluster: AWSEncodableShape {
        /// Details of an Amazon MSK Cluster.
        public let amazonMskCluster: AmazonMskCluster?
        /// Details of an Amazon VPC which has network connectivity to the Apache Kafka cluster.
        public let vpcConfig: KafkaClusterClientVpcConfig?

        public init(amazonMskCluster: AmazonMskCluster? = nil, vpcConfig: KafkaClusterClientVpcConfig? = nil) {
            self.amazonMskCluster = amazonMskCluster
            self.vpcConfig = vpcConfig
        }

        private enum CodingKeys: String, CodingKey {
            case amazonMskCluster = "amazonMskCluster"
            case vpcConfig = "vpcConfig"
        }
    }

    public struct KafkaClusterClientVpcConfig: AWSEncodableShape & AWSDecodableShape {
        /// The security groups to attach to the ENIs for the broker nodes.
        public let securityGroupIds: [String]?
        /// The list of subnets in the client VPC to connect to.
        public let subnetIds: [String]?

        public init(securityGroupIds: [String]? = nil, subnetIds: [String]? = nil) {
            self.securityGroupIds = securityGroupIds
            self.subnetIds = subnetIds
        }

        private enum CodingKeys: String, CodingKey {
            case securityGroupIds = "securityGroupIds"
            case subnetIds = "subnetIds"
        }
    }

    public struct KafkaClusterDescription: AWSDecodableShape {
        /// Details of an Amazon MSK Cluster.
        public let amazonMskCluster: AmazonMskCluster?
        /// The alias of the Kafka cluster. Used to prefix names of replicated topics.
        public let kafkaClusterAlias: String?
        /// Details of an Amazon VPC which has network connectivity to the Apache Kafka cluster.
        public let vpcConfig: KafkaClusterClientVpcConfig?

        public init(amazonMskCluster: AmazonMskCluster? = nil, kafkaClusterAlias: String? = nil, vpcConfig: KafkaClusterClientVpcConfig? = nil) {
            self.amazonMskCluster = amazonMskCluster
            self.kafkaClusterAlias = kafkaClusterAlias
            self.vpcConfig = vpcConfig
        }

        private enum CodingKeys: String, CodingKey {
            case amazonMskCluster = "amazonMskCluster"
            case kafkaClusterAlias = "kafkaClusterAlias"
            case vpcConfig = "vpcConfig"
        }
    }

    public struct KafkaClusterSummary: AWSDecodableShape {
        /// Details of an Amazon MSK Cluster.
        public let amazonMskCluster: AmazonMskCluster?
        /// The alias of the Kafka cluster. Used to prefix names of replicated topics.
        public let kafkaClusterAlias: String?

        public init(amazonMskCluster: AmazonMskCluster? = nil, kafkaClusterAlias: String? = nil) {
            self.amazonMskCluster = amazonMskCluster
            self.kafkaClusterAlias = kafkaClusterAlias
        }

        private enum CodingKeys: String, CodingKey {
            case amazonMskCluster = "amazonMskCluster"
            case kafkaClusterAlias = "kafkaClusterAlias"
        }
    }

    public struct KafkaVersion: AWSDecodableShape {
        public let status: KafkaVersionStatus?
        public let version: String?

        public init(status: KafkaVersionStatus? = nil, version: String? = nil) {
            self.status = status
            self.version = version
        }

        private enum CodingKeys: String, CodingKey {
            case status = "status"
            case version = "version"
        }
    }

    public struct ListClientVpcConnectionsRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the cluster.
        public let clusterArn: String
        /// The maximum number of results to return in the response. If there are more results, the response includes a NextToken parameter.
        public let maxResults: Int?
        /// The paginated results marker. When the result of the operation is truncated, the call returns NextToken in the response.  To get the next batch, provide this token in your next request.
        public let nextToken: String?

        public init(clusterArn: String, maxResults: Int? = nil, nextToken: String? = nil) {
            self.clusterArn = clusterArn
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.clusterArn, key: "ClusterArn")
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListClientVpcConnectionsResponse: AWSDecodableShape {
        /// List of client VPC connections.
        public let clientVpcConnections: [ClientVpcConnection]?
        /// The paginated results marker. When the result of a ListClientVpcConnections operation is truncated, the call returns NextToken in the response.  To get another batch of configurations, provide this token in your next request.
        public let nextToken: String?

        public init(clientVpcConnections: [ClientVpcConnection]? = nil, nextToken: String? = nil) {
            self.clientVpcConnections = clientVpcConnections
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case clientVpcConnections = "clientVpcConnections"
            case nextToken = "nextToken"
        }
    }

    public struct ListClusterOperationsRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) that uniquely identifies the cluster.
        public let clusterArn: String
        /// The maximum number of results to return in the response. If there are more results, the response includes a NextToken parameter.
        public let maxResults: Int?
        /// The paginated results marker. When the result of the operation is truncated, the call returns NextToken in the response.  To get the next batch, provide this token in your next request.
        public let nextToken: String?

        public init(clusterArn: String, maxResults: Int? = nil, nextToken: String? = nil) {
            self.clusterArn = clusterArn
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.clusterArn, key: "ClusterArn")
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListClusterOperationsResponse: AWSDecodableShape {
        /// An array of cluster operation information objects.
        public let clusterOperationInfoList: [ClusterOperationInfo]?
        /// If the response of ListClusterOperations is truncated, it returns a NextToken in the response. This Nexttoken should be sent in the subsequent request to ListClusterOperations.
        public let nextToken: String?

        public init(clusterOperationInfoList: [ClusterOperationInfo]? = nil, nextToken: String? = nil) {
            self.clusterOperationInfoList = clusterOperationInfoList
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case clusterOperationInfoList = "clusterOperationInfoList"
            case nextToken = "nextToken"
        }
    }

    public struct ListClusterOperationsV2Request: AWSEncodableShape {
        /// The arn of the cluster whose operations are being requested.
        public let clusterArn: String
        /// The maxResults of the query.
        public let maxResults: Int?
        /// The nextToken of the query.
        public let nextToken: String?

        public init(clusterArn: String, maxResults: Int? = nil, nextToken: String? = nil) {
            self.clusterArn = clusterArn
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.clusterArn, key: "ClusterArn")
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListClusterOperationsV2Response: AWSDecodableShape {
        /// An array of cluster operation information objects.
        public let clusterOperationInfoList: [ClusterOperationV2Summary]?
        /// If the response of ListClusterOperationsV2 is truncated, it returns a NextToken in the response. This NextToken should be sent in the subsequent request to ListClusterOperationsV2.
        public let nextToken: String?

        public init(clusterOperationInfoList: [ClusterOperationV2Summary]? = nil, nextToken: String? = nil) {
            self.clusterOperationInfoList = clusterOperationInfoList
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case clusterOperationInfoList = "clusterOperationInfoList"
            case nextToken = "nextToken"
        }
    }

    public struct ListClustersRequest: AWSEncodableShape {
        /// Specify a prefix of the name of the clusters that you want to list. The service lists all the clusters whose names start with this prefix.
        public let clusterNameFilter: String?
        /// The maximum number of results to return in the response. If there are more results, the response includes a NextToken parameter.
        public let maxResults: Int?
        /// The paginated results marker. When the result of the operation is truncated, the call returns NextToken in the response.  To get the next batch, provide this token in your next request.
        public let nextToken: String?

        public init(clusterNameFilter: String? = nil, maxResults: Int? = nil, nextToken: String? = nil) {
            self.clusterNameFilter = clusterNameFilter
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.clusterNameFilter, key: "clusterNameFilter")
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListClustersResponse: AWSDecodableShape {
        /// Information on each of the MSK clusters in the response.
        public let clusterInfoList: [ClusterInfo]?
        /// The paginated results marker. When the result of a ListClusters operation is truncated, the call returns NextToken in the response.  To get another batch of clusters, provide this token in your next request.
        public let nextToken: String?

        public init(clusterInfoList: [ClusterInfo]? = nil, nextToken: String? = nil) {
            self.clusterInfoList = clusterInfoList
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case clusterInfoList = "clusterInfoList"
            case nextToken = "nextToken"
        }
    }

    public struct ListClustersV2Request: AWSEncodableShape {
        /// Specify a prefix of the names of the clusters that you want to list. The service lists all the clusters whose names start with this prefix.
        public let clusterNameFilter: String?
        /// Specify either PROVISIONED or SERVERLESS.
        public let clusterTypeFilter: String?
        /// The maximum number of results to return in the response. If there are more results, the response includes a NextToken parameter.
        public let maxResults: Int?
        /// The paginated results marker. When the result of the operation is truncated, the call returns NextToken in the response.  To get the next batch, provide this token in your next request.
        public let nextToken: String?

        public init(clusterNameFilter: String? = nil, clusterTypeFilter: String? = nil, maxResults: Int? = nil, nextToken: String? = nil) {
            self.clusterNameFilter = clusterNameFilter
            self.clusterTypeFilter = clusterTypeFilter
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.clusterNameFilter, key: "clusterNameFilter")
            request.encodeQuery(self.clusterTypeFilter, key: "clusterTypeFilter")
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListClustersV2Response: AWSDecodableShape {
        /// Information on each of the MSK clusters in the response.
        public let clusterInfoList: [Cluster]?
        /// The paginated results marker. When the result of a ListClusters operation is truncated, the call returns NextToken in the response.  To get another batch of clusters, provide this token in your next request.
        public let nextToken: String?

        public init(clusterInfoList: [Cluster]? = nil, nextToken: String? = nil) {
            self.clusterInfoList = clusterInfoList
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case clusterInfoList = "clusterInfoList"
            case nextToken = "nextToken"
        }
    }

    public struct ListConfigurationRevisionsRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) that uniquely identifies an MSK configuration and all of its revisions.
        public let arn: String
        /// The maximum number of results to return in the response. If there are more results, the response includes a NextToken parameter.
        public let maxResults: Int?
        /// The paginated results marker. When the result of the operation is truncated, the call returns NextToken in the response.  To get the next batch, provide this token in your next request.
        public let nextToken: String?

        public init(arn: String, maxResults: Int? = nil, nextToken: String? = nil) {
            self.arn = arn
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.arn, key: "Arn")
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListConfigurationRevisionsResponse: AWSDecodableShape {
        /// Paginated results marker.
        public let nextToken: String?
        /// List of ConfigurationRevision objects.
        public let revisions: [ConfigurationRevision]?

        public init(nextToken: String? = nil, revisions: [ConfigurationRevision]? = nil) {
            self.nextToken = nextToken
            self.revisions = revisions
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "nextToken"
            case revisions = "revisions"
        }
    }

    public struct ListConfigurationsRequest: AWSEncodableShape {
        /// The maximum number of results to return in the response. If there are more results, the response includes a NextToken parameter.
        public let maxResults: Int?
        /// The paginated results marker. When the result of the operation is truncated, the call returns NextToken in the response.  To get the next batch, provide this token in your next request.
        public let nextToken: String?

        public init(maxResults: Int? = nil, nextToken: String? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListConfigurationsResponse: AWSDecodableShape {
        /// An array of MSK configurations.
        public let configurations: [Configuration]?
        /// The paginated results marker. When the result of a ListConfigurations operation is truncated, the call returns NextToken in the response.  To get another batch of configurations, provide this token in your next request.
        public let nextToken: String?

        public init(configurations: [Configuration]? = nil, nextToken: String? = nil) {
            self.configurations = configurations
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case configurations = "configurations"
            case nextToken = "nextToken"
        }
    }

    public struct ListKafkaVersionsRequest: AWSEncodableShape {
        /// The maximum number of results to return in the response. If there are more results, the response includes a NextToken parameter.
        public let maxResults: Int?
        /// The paginated results marker. When the result of the operation is truncated, the call returns NextToken in the response. To get the next batch, provide this token in your next request.
        public let nextToken: String?

        public init(maxResults: Int? = nil, nextToken: String? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListKafkaVersionsResponse: AWSDecodableShape {
        public let kafkaVersions: [KafkaVersion]?
        public let nextToken: String?

        public init(kafkaVersions: [KafkaVersion]? = nil, nextToken: String? = nil) {
            self.kafkaVersions = kafkaVersions
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case kafkaVersions = "kafkaVersions"
            case nextToken = "nextToken"
        }
    }

    public struct ListNodesRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) that uniquely identifies the cluster.
        public let clusterArn: String
        /// The maximum number of results to return in the response. If there are more results, the response includes a NextToken parameter.
        public let maxResults: Int?
        /// The paginated results marker. When the result of the operation is truncated, the call returns NextToken in the response.  To get the next batch, provide this token in your next request.
        public let nextToken: String?

        public init(clusterArn: String, maxResults: Int? = nil, nextToken: String? = nil) {
            self.clusterArn = clusterArn
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.clusterArn, key: "ClusterArn")
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListNodesResponse: AWSDecodableShape {
        /// The paginated results marker. When the result of a ListNodes operation is truncated, the call returns NextToken in the response.  To get another batch of nodes, provide this token in your next request.
        public let nextToken: String?
        /// List containing a NodeInfo object.
        public let nodeInfoList: [NodeInfo]?

        public init(nextToken: String? = nil, nodeInfoList: [NodeInfo]? = nil) {
            self.nextToken = nextToken
            self.nodeInfoList = nodeInfoList
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "nextToken"
            case nodeInfoList = "nodeInfoList"
        }
    }

    public struct ListReplicatorsRequest: AWSEncodableShape {
        /// The maximum number of results to return in the response. If there are more results, the response includes a NextToken parameter.
        public let maxResults: Int?
        /// If the response of ListReplicators is truncated, it returns a NextToken in the response. This NextToken should be sent in the subsequent request to ListReplicators.
        public let nextToken: String?
        /// Returns replicators starting with given name.
        public let replicatorNameFilter: String?

        public init(maxResults: Int? = nil, nextToken: String? = nil, replicatorNameFilter: String? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.replicatorNameFilter = replicatorNameFilter
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
            request.encodeQuery(self.replicatorNameFilter, key: "replicatorNameFilter")
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListReplicatorsResponse: AWSDecodableShape {
        /// If the response of ListReplicators is truncated, it returns a NextToken in the response. This NextToken should be sent in the subsequent request to ListReplicators.
        public let nextToken: String?
        /// List containing information of each of the replicators in the account.
        public let replicators: [ReplicatorSummary]?

        public init(nextToken: String? = nil, replicators: [ReplicatorSummary]? = nil) {
            self.nextToken = nextToken
            self.replicators = replicators
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "nextToken"
            case replicators = "replicators"
        }
    }

    public struct ListScramSecretsRequest: AWSEncodableShape {
        /// The arn of the cluster.
        public let clusterArn: String
        /// The maxResults of the query.
        public let maxResults: Int?
        /// The nextToken of the query.
        public let nextToken: String?

        public init(clusterArn: String, maxResults: Int? = nil, nextToken: String? = nil) {
            self.clusterArn = clusterArn
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.clusterArn, key: "ClusterArn")
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListScramSecretsResponse: AWSDecodableShape {
        /// Paginated results marker.
        public let nextToken: String?
        /// The list of scram secrets associated with the cluster.
        public let secretArnList: [String]?

        public init(nextToken: String? = nil, secretArnList: [String]? = nil) {
            self.nextToken = nextToken
            self.secretArnList = secretArnList
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "nextToken"
            case secretArnList = "secretArnList"
        }
    }

    public struct ListTagsForResourceRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) that uniquely identifies the resource that's associated with the tags.
        public let resourceArn: String

        public init(resourceArn: String) {
            self.resourceArn = resourceArn
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.resourceArn, key: "ResourceArn")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListTagsForResourceResponse: AWSDecodableShape {
        /// The key-value pair for the resource tag.
        public let tags: [String: String]?

        public init(tags: [String: String]? = nil) {
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case tags = "tags"
        }
    }

    public struct ListVpcConnectionsRequest: AWSEncodableShape {
        /// The maximum number of results to return in the response. If there are more results, the response includes a NextToken parameter.
        public let maxResults: Int?
        /// The paginated results marker. When the result of the operation is truncated, the call returns NextToken in the response.  To get the next batch, provide this token in your next request.
        public let nextToken: String?

        public init(maxResults: Int? = nil, nextToken: String? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListVpcConnectionsResponse: AWSDecodableShape {
        /// The paginated results marker. When the result of a ListClientVpcConnections operation is truncated, the call returns NextToken in the response.  To get another batch of configurations, provide this token in your next request.
        public let nextToken: String?
        /// List of VPC connections.
        public let vpcConnections: [VpcConnection]?

        public init(nextToken: String? = nil, vpcConnections: [VpcConnection]? = nil) {
            self.nextToken = nextToken
            self.vpcConnections = vpcConnections
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "nextToken"
            case vpcConnections = "vpcConnections"
        }
    }

    public struct LoggingInfo: AWSEncodableShape & AWSDecodableShape {
        public let brokerLogs: BrokerLogs?

        public init(brokerLogs: BrokerLogs? = nil) {
            self.brokerLogs = brokerLogs
        }

        private enum CodingKeys: String, CodingKey {
            case brokerLogs = "brokerLogs"
        }
    }

    public struct MutableClusterInfo: AWSDecodableShape {
        /// Specifies the size of the EBS volume and the ID of the associated broker.
        public let brokerEBSVolumeInfo: [BrokerEBSVolumeInfo]?
        /// Includes all client authentication information.
        public let clientAuthentication: ClientAuthentication?
        /// Information about the changes in the configuration of the brokers.
        public let configurationInfo: ConfigurationInfo?
        /// Information about the broker access configuration.
        public let connectivityInfo: ConnectivityInfo?
        /// Includes all encryption-related information.
        public let encryptionInfo: EncryptionInfo?
        /// Specifies which Apache Kafka metrics Amazon MSK gathers and sends to Amazon CloudWatch for this cluster.
        public let enhancedMonitoring: EnhancedMonitoring?
        /// Information about the Amazon MSK broker type.
        public let instanceType: String?
        /// The Apache Kafka version.
        public let kafkaVersion: String?
        /// You can configure your MSK cluster to send broker logs to different destination types. This is a container for the configuration details related to broker logs.
        public let loggingInfo: LoggingInfo?
        /// The number of broker nodes in the cluster.
        public let numberOfBrokerNodes: Int?
        /// The settings for open monitoring.
        public let openMonitoring: OpenMonitoring?
        /// This controls storage mode for supported storage tiers.
        public let storageMode: StorageMode?

        public init(brokerEBSVolumeInfo: [BrokerEBSVolumeInfo]? = nil, clientAuthentication: ClientAuthentication? = nil, configurationInfo: ConfigurationInfo? = nil, connectivityInfo: ConnectivityInfo? = nil, encryptionInfo: EncryptionInfo? = nil, enhancedMonitoring: EnhancedMonitoring? = nil, instanceType: String? = nil, kafkaVersion: String? = nil, loggingInfo: LoggingInfo? = nil, numberOfBrokerNodes: Int? = nil, openMonitoring: OpenMonitoring? = nil, storageMode: StorageMode? = nil) {
            self.brokerEBSVolumeInfo = brokerEBSVolumeInfo
            self.clientAuthentication = clientAuthentication
            self.configurationInfo = configurationInfo
            self.connectivityInfo = connectivityInfo
            self.encryptionInfo = encryptionInfo
            self.enhancedMonitoring = enhancedMonitoring
            self.instanceType = instanceType
            self.kafkaVersion = kafkaVersion
            self.loggingInfo = loggingInfo
            self.numberOfBrokerNodes = numberOfBrokerNodes
            self.openMonitoring = openMonitoring
            self.storageMode = storageMode
        }

        private enum CodingKeys: String, CodingKey {
            case brokerEBSVolumeInfo = "brokerEBSVolumeInfo"
            case clientAuthentication = "clientAuthentication"
            case configurationInfo = "configurationInfo"
            case connectivityInfo = "connectivityInfo"
            case encryptionInfo = "encryptionInfo"
            case enhancedMonitoring = "enhancedMonitoring"
            case instanceType = "instanceType"
            case kafkaVersion = "kafkaVersion"
            case loggingInfo = "loggingInfo"
            case numberOfBrokerNodes = "numberOfBrokerNodes"
            case openMonitoring = "openMonitoring"
            case storageMode = "storageMode"
        }
    }

    public struct NodeExporter: AWSDecodableShape {
        /// Indicates whether you want to turn on or turn off the Node Exporter.
        public let enabledInBroker: Bool?

        public init(enabledInBroker: Bool? = nil) {
            self.enabledInBroker = enabledInBroker
        }

        private enum CodingKeys: String, CodingKey {
            case enabledInBroker = "enabledInBroker"
        }
    }

    public struct NodeExporterInfo: AWSEncodableShape & AWSDecodableShape {
        /// Indicates whether you want to turn on or turn off the Node Exporter.
        public let enabledInBroker: Bool?

        public init(enabledInBroker: Bool? = nil) {
            self.enabledInBroker = enabledInBroker
        }

        private enum CodingKeys: String, CodingKey {
            case enabledInBroker = "enabledInBroker"
        }
    }

    public struct NodeInfo: AWSDecodableShape {
        /// The start time.
        public let addedToClusterTime: String?
        /// The broker node info.
        public let brokerNodeInfo: BrokerNodeInfo?
        /// The instance type.
        public let instanceType: String?
        /// The Amazon Resource Name (ARN) of the node.
        public let nodeARN: String?
        /// The node type.
        public let nodeType: NodeType?
        /// The ZookeeperNodeInfo.
        public let zookeeperNodeInfo: ZookeeperNodeInfo?

        public init(addedToClusterTime: String? = nil, brokerNodeInfo: BrokerNodeInfo? = nil, instanceType: String? = nil, nodeARN: String? = nil, nodeType: NodeType? = nil, zookeeperNodeInfo: ZookeeperNodeInfo? = nil) {
            self.addedToClusterTime = addedToClusterTime
            self.brokerNodeInfo = brokerNodeInfo
            self.instanceType = instanceType
            self.nodeARN = nodeARN
            self.nodeType = nodeType
            self.zookeeperNodeInfo = zookeeperNodeInfo
        }

        private enum CodingKeys: String, CodingKey {
            case addedToClusterTime = "addedToClusterTime"
            case brokerNodeInfo = "brokerNodeInfo"
            case instanceType = "instanceType"
            case nodeARN = "nodeARN"
            case nodeType = "nodeType"
            case zookeeperNodeInfo = "zookeeperNodeInfo"
        }
    }

    public struct OpenMonitoring: AWSDecodableShape {
        /// Prometheus settings.
        public let prometheus: Prometheus?

        public init(prometheus: Prometheus? = nil) {
            self.prometheus = prometheus
        }

        private enum CodingKeys: String, CodingKey {
            case prometheus = "prometheus"
        }
    }

    public struct OpenMonitoringInfo: AWSEncodableShape & AWSDecodableShape {
        /// Prometheus settings.
        public let prometheus: PrometheusInfo?

        public init(prometheus: PrometheusInfo? = nil) {
            self.prometheus = prometheus
        }

        private enum CodingKeys: String, CodingKey {
            case prometheus = "prometheus"
        }
    }

    public struct Prometheus: AWSDecodableShape {
        /// Indicates whether you want to turn on or turn off the JMX Exporter.
        public let jmxExporter: JmxExporter?
        /// Indicates whether you want to turn on or turn off the Node Exporter.
        public let nodeExporter: NodeExporter?

        public init(jmxExporter: JmxExporter? = nil, nodeExporter: NodeExporter? = nil) {
            self.jmxExporter = jmxExporter
            self.nodeExporter = nodeExporter
        }

        private enum CodingKeys: String, CodingKey {
            case jmxExporter = "jmxExporter"
            case nodeExporter = "nodeExporter"
        }
    }

    public struct PrometheusInfo: AWSEncodableShape & AWSDecodableShape {
        /// Indicates whether you want to turn on or turn off the JMX Exporter.
        public let jmxExporter: JmxExporterInfo?
        /// Indicates whether you want to turn on or turn off the Node Exporter.
        public let nodeExporter: NodeExporterInfo?

        public init(jmxExporter: JmxExporterInfo? = nil, nodeExporter: NodeExporterInfo? = nil) {
            self.jmxExporter = jmxExporter
            self.nodeExporter = nodeExporter
        }

        private enum CodingKeys: String, CodingKey {
            case jmxExporter = "jmxExporter"
            case nodeExporter = "nodeExporter"
        }
    }

    public struct Provisioned: AWSDecodableShape {
        /// Information about the brokers.
        public let brokerNodeGroupInfo: BrokerNodeGroupInfo?
        /// Includes all client authentication information.
        public let clientAuthentication: ClientAuthentication?
        /// Information about the Apache Kafka version deployed on the brokers.
        public let currentBrokerSoftwareInfo: BrokerSoftwareInfo?
        /// Determines if there is an action required from the customer.
        public let customerActionStatus: CustomerActionStatus?
        /// Includes all encryption-related information.
        public let encryptionInfo: EncryptionInfo?
        /// Specifies the level of monitoring for the MSK cluster. The possible values are DEFAULT, PER_BROKER, PER_TOPIC_PER_BROKER, and PER_TOPIC_PER_PARTITION.
        public let enhancedMonitoring: EnhancedMonitoring?
        /// Log delivery information for the cluster.
        public let loggingInfo: LoggingInfo?
        /// The number of broker nodes in the cluster.
        public let numberOfBrokerNodes: Int?
        /// The settings for open monitoring.
        public let openMonitoring: OpenMonitoringInfo?
        /// This controls storage mode for supported storage tiers.
        public let storageMode: StorageMode?
        /// The connection string to use to connect to the Apache ZooKeeper cluster.
        public let zookeeperConnectString: String?
        /// The connection string to use to connect to the Apache ZooKeeper cluster on a TLS port.
        public let zookeeperConnectStringTls: String?

        public init(brokerNodeGroupInfo: BrokerNodeGroupInfo? = nil, clientAuthentication: ClientAuthentication? = nil, currentBrokerSoftwareInfo: BrokerSoftwareInfo? = nil, customerActionStatus: CustomerActionStatus? = nil, encryptionInfo: EncryptionInfo? = nil, enhancedMonitoring: EnhancedMonitoring? = nil, loggingInfo: LoggingInfo? = nil, numberOfBrokerNodes: Int? = nil, openMonitoring: OpenMonitoringInfo? = nil, storageMode: StorageMode? = nil, zookeeperConnectString: String? = nil, zookeeperConnectStringTls: String? = nil) {
            self.brokerNodeGroupInfo = brokerNodeGroupInfo
            self.clientAuthentication = clientAuthentication
            self.currentBrokerSoftwareInfo = currentBrokerSoftwareInfo
            self.customerActionStatus = customerActionStatus
            self.encryptionInfo = encryptionInfo
            self.enhancedMonitoring = enhancedMonitoring
            self.loggingInfo = loggingInfo
            self.numberOfBrokerNodes = numberOfBrokerNodes
            self.openMonitoring = openMonitoring
            self.storageMode = storageMode
            self.zookeeperConnectString = zookeeperConnectString
            self.zookeeperConnectStringTls = zookeeperConnectStringTls
        }

        private enum CodingKeys: String, CodingKey {
            case brokerNodeGroupInfo = "brokerNodeGroupInfo"
            case clientAuthentication = "clientAuthentication"
            case currentBrokerSoftwareInfo = "currentBrokerSoftwareInfo"
            case customerActionStatus = "customerActionStatus"
            case encryptionInfo = "encryptionInfo"
            case enhancedMonitoring = "enhancedMonitoring"
            case loggingInfo = "loggingInfo"
            case numberOfBrokerNodes = "numberOfBrokerNodes"
            case openMonitoring = "openMonitoring"
            case storageMode = "storageMode"
            case zookeeperConnectString = "zookeeperConnectString"
            case zookeeperConnectStringTls = "zookeeperConnectStringTls"
        }
    }

    public struct ProvisionedRequest: AWSEncodableShape {
        /// Information about the brokers.
        public let brokerNodeGroupInfo: BrokerNodeGroupInfo?
        /// Includes all client authentication information.
        public let clientAuthentication: ClientAuthentication?
        /// Represents the configuration that you want Amazon MSK to use for the brokers in a cluster.
        public let configurationInfo: ConfigurationInfo?
        /// Includes all encryption-related information.
        public let encryptionInfo: EncryptionInfo?
        /// Specifies the level of monitoring for the MSK cluster. The possible values are DEFAULT, PER_BROKER, PER_TOPIC_PER_BROKER, and PER_TOPIC_PER_PARTITION.
        public let enhancedMonitoring: EnhancedMonitoring?
        /// The Apache Kafka version that you want for the cluster.
        public let kafkaVersion: String?
        /// Log delivery information for the cluster.
        public let loggingInfo: LoggingInfo?
        /// The number of broker nodes in the cluster.
        public let numberOfBrokerNodes: Int?
        /// The settings for open monitoring.
        public let openMonitoring: OpenMonitoringInfo?
        /// This controls storage mode for supported storage tiers.
        public let storageMode: StorageMode?

        public init(brokerNodeGroupInfo: BrokerNodeGroupInfo? = nil, clientAuthentication: ClientAuthentication? = nil, configurationInfo: ConfigurationInfo? = nil, encryptionInfo: EncryptionInfo? = nil, enhancedMonitoring: EnhancedMonitoring? = nil, kafkaVersion: String? = nil, loggingInfo: LoggingInfo? = nil, numberOfBrokerNodes: Int? = nil, openMonitoring: OpenMonitoringInfo? = nil, storageMode: StorageMode? = nil) {
            self.brokerNodeGroupInfo = brokerNodeGroupInfo
            self.clientAuthentication = clientAuthentication
            self.configurationInfo = configurationInfo
            self.encryptionInfo = encryptionInfo
            self.enhancedMonitoring = enhancedMonitoring
            self.kafkaVersion = kafkaVersion
            self.loggingInfo = loggingInfo
            self.numberOfBrokerNodes = numberOfBrokerNodes
            self.openMonitoring = openMonitoring
            self.storageMode = storageMode
        }

        public func validate(name: String) throws {
            try self.brokerNodeGroupInfo?.validate(name: "\(name).brokerNodeGroupInfo")
            try self.validate(self.kafkaVersion, name: "kafkaVersion", parent: name, max: 128)
            try self.validate(self.kafkaVersion, name: "kafkaVersion", parent: name, min: 1)
            try self.validate(self.numberOfBrokerNodes, name: "numberOfBrokerNodes", parent: name, max: 15)
            try self.validate(self.numberOfBrokerNodes, name: "numberOfBrokerNodes", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case brokerNodeGroupInfo = "brokerNodeGroupInfo"
            case clientAuthentication = "clientAuthentication"
            case configurationInfo = "configurationInfo"
            case encryptionInfo = "encryptionInfo"
            case enhancedMonitoring = "enhancedMonitoring"
            case kafkaVersion = "kafkaVersion"
            case loggingInfo = "loggingInfo"
            case numberOfBrokerNodes = "numberOfBrokerNodes"
            case openMonitoring = "openMonitoring"
            case storageMode = "storageMode"
        }
    }

    public struct ProvisionedThroughput: AWSEncodableShape & AWSDecodableShape {
        /// Provisioned throughput is enabled or not.
        public let enabled: Bool?
        /// Throughput value of the EBS volumes for the data drive on each kafka broker node in MiB per second.
        public let volumeThroughput: Int?

        public init(enabled: Bool? = nil, volumeThroughput: Int? = nil) {
            self.enabled = enabled
            self.volumeThroughput = volumeThroughput
        }

        private enum CodingKeys: String, CodingKey {
            case enabled = "enabled"
            case volumeThroughput = "volumeThroughput"
        }
    }

    public struct PublicAccess: AWSEncodableShape & AWSDecodableShape {
        /// The value DISABLED indicates that public access is turned off. SERVICE_PROVIDED_EIPS indicates that public access is turned on.
        public let type: String?

        public init(type: String? = nil) {
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case type = "type"
        }
    }

    public struct PutClusterPolicyRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the cluster.
        public let clusterArn: String
        /// The policy version.
        public let currentVersion: String?
        /// The policy.
        public let policy: String?

        public init(clusterArn: String, currentVersion: String? = nil, policy: String? = nil) {
            self.clusterArn = clusterArn
            self.currentVersion = currentVersion
            self.policy = policy
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.clusterArn, key: "ClusterArn")
            try container.encodeIfPresent(self.currentVersion, forKey: .currentVersion)
            try container.encodeIfPresent(self.policy, forKey: .policy)
        }

        private enum CodingKeys: String, CodingKey {
            case currentVersion = "currentVersion"
            case policy = "policy"
        }
    }

    public struct PutClusterPolicyResponse: AWSDecodableShape {
        /// The policy version.
        public let currentVersion: String?

        public init(currentVersion: String? = nil) {
            self.currentVersion = currentVersion
        }

        private enum CodingKeys: String, CodingKey {
            case currentVersion = "currentVersion"
        }
    }

    public struct RebootBrokerRequest: AWSEncodableShape {
        /// The list of broker IDs to be rebooted. The reboot-broker operation supports rebooting one broker at a time.
        public let brokerIds: [String]?
        /// The Amazon Resource Name (ARN) of the cluster to be updated.
        public let clusterArn: String

        public init(brokerIds: [String]? = nil, clusterArn: String) {
            self.brokerIds = brokerIds
            self.clusterArn = clusterArn
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.brokerIds, forKey: .brokerIds)
            request.encodePath(self.clusterArn, key: "ClusterArn")
        }

        private enum CodingKeys: String, CodingKey {
            case brokerIds = "brokerIds"
        }
    }

    public struct RebootBrokerResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the cluster.
        public let clusterArn: String?
        /// The Amazon Resource Name (ARN) of the cluster operation.
        public let clusterOperationArn: String?

        public init(clusterArn: String? = nil, clusterOperationArn: String? = nil) {
            self.clusterArn = clusterArn
            self.clusterOperationArn = clusterOperationArn
        }

        private enum CodingKeys: String, CodingKey {
            case clusterArn = "clusterArn"
            case clusterOperationArn = "clusterOperationArn"
        }
    }

    public struct RejectClientVpcConnectionRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the cluster.
        public let clusterArn: String
        /// The VPC connection ARN.
        public let vpcConnectionArn: String?

        public init(clusterArn: String, vpcConnectionArn: String? = nil) {
            self.clusterArn = clusterArn
            self.vpcConnectionArn = vpcConnectionArn
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.clusterArn, key: "ClusterArn")
            try container.encodeIfPresent(self.vpcConnectionArn, forKey: .vpcConnectionArn)
        }

        private enum CodingKeys: String, CodingKey {
            case vpcConnectionArn = "vpcConnectionArn"
        }
    }

    public struct RejectClientVpcConnectionResponse: AWSDecodableShape {
        public init() {}
    }

    public struct ReplicationInfo: AWSEncodableShape {
        /// Configuration relating to consumer group replication.
        public let consumerGroupReplication: ConsumerGroupReplication?
        /// The ARN of the source Kafka cluster.
        public let sourceKafkaClusterArn: String?
        /// The compression type to use when producing records to target cluster.
        public let targetCompressionType: TargetCompressionType?
        /// The ARN of the target Kafka cluster.
        public let targetKafkaClusterArn: String?
        /// Configuration relating to topic replication.
        public let topicReplication: TopicReplication?

        public init(consumerGroupReplication: ConsumerGroupReplication? = nil, sourceKafkaClusterArn: String? = nil, targetCompressionType: TargetCompressionType? = nil, targetKafkaClusterArn: String? = nil, topicReplication: TopicReplication? = nil) {
            self.consumerGroupReplication = consumerGroupReplication
            self.sourceKafkaClusterArn = sourceKafkaClusterArn
            self.targetCompressionType = targetCompressionType
            self.targetKafkaClusterArn = targetKafkaClusterArn
            self.topicReplication = topicReplication
        }

        public func validate(name: String) throws {
            try self.consumerGroupReplication?.validate(name: "\(name).consumerGroupReplication")
            try self.topicReplication?.validate(name: "\(name).topicReplication")
        }

        private enum CodingKeys: String, CodingKey {
            case consumerGroupReplication = "consumerGroupReplication"
            case sourceKafkaClusterArn = "sourceKafkaClusterArn"
            case targetCompressionType = "targetCompressionType"
            case targetKafkaClusterArn = "targetKafkaClusterArn"
            case topicReplication = "topicReplication"
        }
    }

    public struct ReplicationInfoDescription: AWSDecodableShape {
        /// Configuration relating to consumer group replication.
        public let consumerGroupReplication: ConsumerGroupReplication?
        /// The alias of the source Kafka cluster.
        public let sourceKafkaClusterAlias: String?
        /// The compression type to use when producing records to target cluster.
        public let targetCompressionType: TargetCompressionType?
        /// The alias of the target Kafka cluster.
        public let targetKafkaClusterAlias: String?
        /// Configuration relating to topic replication.
        public let topicReplication: TopicReplication?

        public init(consumerGroupReplication: ConsumerGroupReplication? = nil, sourceKafkaClusterAlias: String? = nil, targetCompressionType: TargetCompressionType? = nil, targetKafkaClusterAlias: String? = nil, topicReplication: TopicReplication? = nil) {
            self.consumerGroupReplication = consumerGroupReplication
            self.sourceKafkaClusterAlias = sourceKafkaClusterAlias
            self.targetCompressionType = targetCompressionType
            self.targetKafkaClusterAlias = targetKafkaClusterAlias
            self.topicReplication = topicReplication
        }

        private enum CodingKeys: String, CodingKey {
            case consumerGroupReplication = "consumerGroupReplication"
            case sourceKafkaClusterAlias = "sourceKafkaClusterAlias"
            case targetCompressionType = "targetCompressionType"
            case targetKafkaClusterAlias = "targetKafkaClusterAlias"
            case topicReplication = "topicReplication"
        }
    }

    public struct ReplicationInfoSummary: AWSDecodableShape {
        /// The alias of the source Kafka cluster.
        public let sourceKafkaClusterAlias: String?
        /// The alias of the target Kafka cluster.
        public let targetKafkaClusterAlias: String?

        public init(sourceKafkaClusterAlias: String? = nil, targetKafkaClusterAlias: String? = nil) {
            self.sourceKafkaClusterAlias = sourceKafkaClusterAlias
            self.targetKafkaClusterAlias = targetKafkaClusterAlias
        }

        private enum CodingKeys: String, CodingKey {
            case sourceKafkaClusterAlias = "sourceKafkaClusterAlias"
            case targetKafkaClusterAlias = "targetKafkaClusterAlias"
        }
    }

    public struct ReplicationStartingPosition: AWSEncodableShape & AWSDecodableShape {
        /// The type of replication starting position.
        public let type: ReplicationStartingPositionType?

        public init(type: ReplicationStartingPositionType? = nil) {
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case type = "type"
        }
    }

    public struct ReplicationStateInfo: AWSDecodableShape {
        /// Code that describes the current state of the replicator.
        public let code: String?
        /// Message that describes the state of the replicator.
        public let message: String?

        public init(code: String? = nil, message: String? = nil) {
            self.code = code
            self.message = message
        }

        private enum CodingKeys: String, CodingKey {
            case code = "code"
            case message = "message"
        }
    }

    public struct ReplicatorSummary: AWSDecodableShape {
        /// The time the replicator was created.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var creationTime: Date?
        /// The current version of the replicator.
        public let currentVersion: String?
        /// Whether this resource is a replicator reference.
        public let isReplicatorReference: Bool?
        /// Kafka Clusters used in setting up sources / targets for replication.
        public let kafkaClustersSummary: [KafkaClusterSummary]?
        /// A list of summarized information of replications between clusters.
        public let replicationInfoSummaryList: [ReplicationInfoSummary]?
        /// The Amazon Resource Name (ARN) of the replicator.
        public let replicatorArn: String?
        /// The name of the replicator.
        public let replicatorName: String?
        /// The Amazon Resource Name (ARN) of the replicator resource in the region where the replicator was created.
        public let replicatorResourceArn: String?
        /// State of the replicator.
        public let replicatorState: ReplicatorState?

        public init(creationTime: Date? = nil, currentVersion: String? = nil, isReplicatorReference: Bool? = nil, kafkaClustersSummary: [KafkaClusterSummary]? = nil, replicationInfoSummaryList: [ReplicationInfoSummary]? = nil, replicatorArn: String? = nil, replicatorName: String? = nil, replicatorResourceArn: String? = nil, replicatorState: ReplicatorState? = nil) {
            self.creationTime = creationTime
            self.currentVersion = currentVersion
            self.isReplicatorReference = isReplicatorReference
            self.kafkaClustersSummary = kafkaClustersSummary
            self.replicationInfoSummaryList = replicationInfoSummaryList
            self.replicatorArn = replicatorArn
            self.replicatorName = replicatorName
            self.replicatorResourceArn = replicatorResourceArn
            self.replicatorState = replicatorState
        }

        private enum CodingKeys: String, CodingKey {
            case creationTime = "creationTime"
            case currentVersion = "currentVersion"
            case isReplicatorReference = "isReplicatorReference"
            case kafkaClustersSummary = "kafkaClustersSummary"
            case replicationInfoSummaryList = "replicationInfoSummaryList"
            case replicatorArn = "replicatorArn"
            case replicatorName = "replicatorName"
            case replicatorResourceArn = "replicatorResourceArn"
            case replicatorState = "replicatorState"
        }
    }

    public struct S3: AWSEncodableShape & AWSDecodableShape {
        public let bucket: String?
        public let enabled: Bool?
        public let prefix: String?

        public init(bucket: String? = nil, enabled: Bool? = nil, prefix: String? = nil) {
            self.bucket = bucket
            self.enabled = enabled
            self.prefix = prefix
        }

        private enum CodingKeys: String, CodingKey {
            case bucket = "bucket"
            case enabled = "enabled"
            case prefix = "prefix"
        }
    }

    public struct Sasl: AWSEncodableShape & AWSDecodableShape {
        /// Indicates whether IAM access control is enabled.
        public let iam: Iam?
        /// Details for SASL/SCRAM client authentication.
        public let scram: Scram?

        public init(iam: Iam? = nil, scram: Scram? = nil) {
            self.iam = iam
            self.scram = scram
        }

        private enum CodingKeys: String, CodingKey {
            case iam = "iam"
            case scram = "scram"
        }
    }

    public struct Scram: AWSEncodableShape & AWSDecodableShape {
        /// SASL/SCRAM authentication is enabled or not.
        public let enabled: Bool?

        public init(enabled: Bool? = nil) {
            self.enabled = enabled
        }

        private enum CodingKeys: String, CodingKey {
            case enabled = "enabled"
        }
    }

    public struct Serverless: AWSDecodableShape {
        /// Includes all client authentication information.
        public let clientAuthentication: ServerlessClientAuthentication?
        /// The configuration of the Amazon VPCs for the cluster.
        public let vpcConfigs: [VpcConfig]?

        public init(clientAuthentication: ServerlessClientAuthentication? = nil, vpcConfigs: [VpcConfig]? = nil) {
            self.clientAuthentication = clientAuthentication
            self.vpcConfigs = vpcConfigs
        }

        private enum CodingKeys: String, CodingKey {
            case clientAuthentication = "clientAuthentication"
            case vpcConfigs = "vpcConfigs"
        }
    }

    public struct ServerlessClientAuthentication: AWSEncodableShape & AWSDecodableShape {
        /// Details for ClientAuthentication using SASL.
        public let sasl: ServerlessSasl?

        public init(sasl: ServerlessSasl? = nil) {
            self.sasl = sasl
        }

        private enum CodingKeys: String, CodingKey {
            case sasl = "sasl"
        }
    }

    public struct ServerlessRequest: AWSEncodableShape {
        /// Includes all client authentication information.
        public let clientAuthentication: ServerlessClientAuthentication?
        /// The configuration of the Amazon VPCs for the cluster.
        public let vpcConfigs: [VpcConfig]?

        public init(clientAuthentication: ServerlessClientAuthentication? = nil, vpcConfigs: [VpcConfig]? = nil) {
            self.clientAuthentication = clientAuthentication
            self.vpcConfigs = vpcConfigs
        }

        private enum CodingKeys: String, CodingKey {
            case clientAuthentication = "clientAuthentication"
            case vpcConfigs = "vpcConfigs"
        }
    }

    public struct ServerlessSasl: AWSEncodableShape & AWSDecodableShape {
        /// Indicates whether IAM access control is enabled.
        public let iam: Iam?

        public init(iam: Iam? = nil) {
            self.iam = iam
        }

        private enum CodingKeys: String, CodingKey {
            case iam = "iam"
        }
    }

    public struct StateInfo: AWSDecodableShape {
        public let code: String?
        public let message: String?

        public init(code: String? = nil, message: String? = nil) {
            self.code = code
            self.message = message
        }

        private enum CodingKeys: String, CodingKey {
            case code = "code"
            case message = "message"
        }
    }

    public struct StorageInfo: AWSEncodableShape & AWSDecodableShape {
        /// EBS volume information.
        public let ebsStorageInfo: EBSStorageInfo?

        public init(ebsStorageInfo: EBSStorageInfo? = nil) {
            self.ebsStorageInfo = ebsStorageInfo
        }

        public func validate(name: String) throws {
            try self.ebsStorageInfo?.validate(name: "\(name).ebsStorageInfo")
        }

        private enum CodingKeys: String, CodingKey {
            case ebsStorageInfo = "ebsStorageInfo"
        }
    }

    public struct TagResourceRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) that uniquely identifies the resource that's associated with the tags.
        public let resourceArn: String
        /// The key-value pair for the resource tag.
        public let tags: [String: String]?

        public init(resourceArn: String, tags: [String: String]? = nil) {
            self.resourceArn = resourceArn
            self.tags = tags
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.resourceArn, key: "ResourceArn")
            try container.encodeIfPresent(self.tags, forKey: .tags)
        }

        private enum CodingKeys: String, CodingKey {
            case tags = "tags"
        }
    }

    public struct Tls: AWSEncodableShape & AWSDecodableShape {
        /// List of ACM Certificate Authority ARNs.
        public let certificateAuthorityArnList: [String]?
        /// Specifies whether you want to turn on or turn off TLS authentication.
        public let enabled: Bool?

        public init(certificateAuthorityArnList: [String]? = nil, enabled: Bool? = nil) {
            self.certificateAuthorityArnList = certificateAuthorityArnList
            self.enabled = enabled
        }

        private enum CodingKeys: String, CodingKey {
            case certificateAuthorityArnList = "certificateAuthorityArnList"
            case enabled = "enabled"
        }
    }

    public struct TopicReplication: AWSEncodableShape & AWSDecodableShape {
        /// Whether to periodically configure remote topic ACLs to match their corresponding upstream topics.
        public let copyAccessControlListsForTopics: Bool?
        /// Whether to periodically configure remote topics to match their corresponding upstream topics.
        public let copyTopicConfigurations: Bool?
        /// Whether to periodically check for new topics and partitions.
        public let detectAndCopyNewTopics: Bool?
        /// Configuration for specifying the position in the topics to start replicating from.
        public let startingPosition: ReplicationStartingPosition?
        /// List of regular expression patterns indicating the topics that should not be replicated.
        public let topicsToExclude: [String]?
        /// List of regular expression patterns indicating the topics to copy.
        public let topicsToReplicate: [String]?

        public init(copyAccessControlListsForTopics: Bool? = nil, copyTopicConfigurations: Bool? = nil, detectAndCopyNewTopics: Bool? = nil, startingPosition: ReplicationStartingPosition? = nil, topicsToExclude: [String]? = nil, topicsToReplicate: [String]? = nil) {
            self.copyAccessControlListsForTopics = copyAccessControlListsForTopics
            self.copyTopicConfigurations = copyTopicConfigurations
            self.detectAndCopyNewTopics = detectAndCopyNewTopics
            self.startingPosition = startingPosition
            self.topicsToExclude = topicsToExclude
            self.topicsToReplicate = topicsToReplicate
        }

        public func validate(name: String) throws {
            try self.topicsToExclude?.forEach {
                try validate($0, name: "topicsToExclude[]", parent: name, max: 249)
            }
            try self.topicsToReplicate?.forEach {
                try validate($0, name: "topicsToReplicate[]", parent: name, max: 249)
            }
        }

        private enum CodingKeys: String, CodingKey {
            case copyAccessControlListsForTopics = "copyAccessControlListsForTopics"
            case copyTopicConfigurations = "copyTopicConfigurations"
            case detectAndCopyNewTopics = "detectAndCopyNewTopics"
            case startingPosition = "startingPosition"
            case topicsToExclude = "topicsToExclude"
            case topicsToReplicate = "topicsToReplicate"
        }
    }

    public struct TopicReplicationUpdate: AWSEncodableShape {
        /// Whether to periodically configure remote topic ACLs to match their corresponding upstream topics.
        public let copyAccessControlListsForTopics: Bool?
        /// Whether to periodically configure remote topics to match their corresponding upstream topics.
        public let copyTopicConfigurations: Bool?
        /// Whether to periodically check for new topics and partitions.
        public let detectAndCopyNewTopics: Bool?
        /// List of regular expression patterns indicating the topics that should not be replicated.
        public let topicsToExclude: [String]?
        /// List of regular expression patterns indicating the topics to copy.
        public let topicsToReplicate: [String]?

        public init(copyAccessControlListsForTopics: Bool? = nil, copyTopicConfigurations: Bool? = nil, detectAndCopyNewTopics: Bool? = nil, topicsToExclude: [String]? = nil, topicsToReplicate: [String]? = nil) {
            self.copyAccessControlListsForTopics = copyAccessControlListsForTopics
            self.copyTopicConfigurations = copyTopicConfigurations
            self.detectAndCopyNewTopics = detectAndCopyNewTopics
            self.topicsToExclude = topicsToExclude
            self.topicsToReplicate = topicsToReplicate
        }

        public func validate(name: String) throws {
            try self.topicsToExclude?.forEach {
                try validate($0, name: "topicsToExclude[]", parent: name, max: 249)
            }
            try self.topicsToReplicate?.forEach {
                try validate($0, name: "topicsToReplicate[]", parent: name, max: 249)
            }
        }

        private enum CodingKeys: String, CodingKey {
            case copyAccessControlListsForTopics = "copyAccessControlListsForTopics"
            case copyTopicConfigurations = "copyTopicConfigurations"
            case detectAndCopyNewTopics = "detectAndCopyNewTopics"
            case topicsToExclude = "topicsToExclude"
            case topicsToReplicate = "topicsToReplicate"
        }
    }

    public struct Unauthenticated: AWSEncodableShape & AWSDecodableShape {
        /// Specifies whether you want to turn on or turn off unauthenticated traffic to your cluster.
        public let enabled: Bool?

        public init(enabled: Bool? = nil) {
            self.enabled = enabled
        }

        private enum CodingKeys: String, CodingKey {
            case enabled = "enabled"
        }
    }

    public struct UnprocessedScramSecret: AWSDecodableShape {
        /// Error code for associate/disassociate failure.
        public let errorCode: String?
        /// Error message for associate/disassociate failure.
        public let errorMessage: String?
        /// AWS Secrets Manager secret ARN.
        public let secretArn: String?

        public init(errorCode: String? = nil, errorMessage: String? = nil, secretArn: String? = nil) {
            self.errorCode = errorCode
            self.errorMessage = errorMessage
            self.secretArn = secretArn
        }

        private enum CodingKeys: String, CodingKey {
            case errorCode = "errorCode"
            case errorMessage = "errorMessage"
            case secretArn = "secretArn"
        }
    }

    public struct UntagResourceRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) that uniquely identifies the resource that's associated with the tags.
        public let resourceArn: String
        /// Tag keys must be unique for a given cluster. In addition, the following restrictions apply:   Each tag key must be unique. If you add a tag with a key that's already in use, your new tag overwrites the existing key-value pair.    You can't start a tag key with aws: because this prefix is reserved for use by  AWS.  AWS creates tags that begin with this prefix on your behalf, but you can't edit or delete them.   Tag keys must be between 1 and 128 Unicode characters in length.   Tag keys must consist of the following characters: Unicode letters, digits, white space, and the following special characters: _ . / = + - @.
        public let tagKeys: [String]?

        public init(resourceArn: String, tagKeys: [String]? = nil) {
            self.resourceArn = resourceArn
            self.tagKeys = tagKeys
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.resourceArn, key: "ResourceArn")
            request.encodeQuery(self.tagKeys, key: "tagKeys")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct UpdateBrokerCountRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) that uniquely identifies the cluster.
        public let clusterArn: String
        /// The version of cluster to update from. A successful operation will then generate a new version.
        public let currentVersion: String?
        /// The number of broker nodes that you want the cluster to have after this operation completes successfully.
        public let targetNumberOfBrokerNodes: Int?

        public init(clusterArn: String, currentVersion: String? = nil, targetNumberOfBrokerNodes: Int? = nil) {
            self.clusterArn = clusterArn
            self.currentVersion = currentVersion
            self.targetNumberOfBrokerNodes = targetNumberOfBrokerNodes
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.clusterArn, key: "ClusterArn")
            try container.encodeIfPresent(self.currentVersion, forKey: .currentVersion)
            try container.encodeIfPresent(self.targetNumberOfBrokerNodes, forKey: .targetNumberOfBrokerNodes)
        }

        public func validate(name: String) throws {
            try self.validate(self.targetNumberOfBrokerNodes, name: "targetNumberOfBrokerNodes", parent: name, max: 15)
            try self.validate(self.targetNumberOfBrokerNodes, name: "targetNumberOfBrokerNodes", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case currentVersion = "currentVersion"
            case targetNumberOfBrokerNodes = "targetNumberOfBrokerNodes"
        }
    }

    public struct UpdateBrokerCountResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the cluster.
        public let clusterArn: String?
        /// The Amazon Resource Name (ARN) of the cluster operation.
        public let clusterOperationArn: String?

        public init(clusterArn: String? = nil, clusterOperationArn: String? = nil) {
            self.clusterArn = clusterArn
            self.clusterOperationArn = clusterOperationArn
        }

        private enum CodingKeys: String, CodingKey {
            case clusterArn = "clusterArn"
            case clusterOperationArn = "clusterOperationArn"
        }
    }

    public struct UpdateBrokerStorageRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) that uniquely identifies the cluster.
        public let clusterArn: String
        /// The version of cluster to update from. A successful operation will then generate a new version.
        public let currentVersion: String?
        /// Describes the target volume size and the ID of the broker to apply the update to.
        public let targetBrokerEBSVolumeInfo: [BrokerEBSVolumeInfo]?

        public init(clusterArn: String, currentVersion: String? = nil, targetBrokerEBSVolumeInfo: [BrokerEBSVolumeInfo]? = nil) {
            self.clusterArn = clusterArn
            self.currentVersion = currentVersion
            self.targetBrokerEBSVolumeInfo = targetBrokerEBSVolumeInfo
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.clusterArn, key: "ClusterArn")
            try container.encodeIfPresent(self.currentVersion, forKey: .currentVersion)
            try container.encodeIfPresent(self.targetBrokerEBSVolumeInfo, forKey: .targetBrokerEBSVolumeInfo)
        }

        private enum CodingKeys: String, CodingKey {
            case currentVersion = "currentVersion"
            case targetBrokerEBSVolumeInfo = "targetBrokerEBSVolumeInfo"
        }
    }

    public struct UpdateBrokerStorageResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the cluster.
        public let clusterArn: String?
        /// The Amazon Resource Name (ARN) of the cluster operation.
        public let clusterOperationArn: String?

        public init(clusterArn: String? = nil, clusterOperationArn: String? = nil) {
            self.clusterArn = clusterArn
            self.clusterOperationArn = clusterOperationArn
        }

        private enum CodingKeys: String, CodingKey {
            case clusterArn = "clusterArn"
            case clusterOperationArn = "clusterOperationArn"
        }
    }

    public struct UpdateBrokerTypeRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) that uniquely identifies the cluster.
        public let clusterArn: String
        /// The cluster version that you want to change. After this operation completes successfully, the cluster will have a new version.
        public let currentVersion: String?
        /// The Amazon MSK broker type that you want all of the brokers in this cluster to be.
        public let targetInstanceType: String?

        public init(clusterArn: String, currentVersion: String? = nil, targetInstanceType: String? = nil) {
            self.clusterArn = clusterArn
            self.currentVersion = currentVersion
            self.targetInstanceType = targetInstanceType
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.clusterArn, key: "ClusterArn")
            try container.encodeIfPresent(self.currentVersion, forKey: .currentVersion)
            try container.encodeIfPresent(self.targetInstanceType, forKey: .targetInstanceType)
        }

        private enum CodingKeys: String, CodingKey {
            case currentVersion = "currentVersion"
            case targetInstanceType = "targetInstanceType"
        }
    }

    public struct UpdateBrokerTypeResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the cluster.
        public let clusterArn: String?
        /// The Amazon Resource Name (ARN) of the cluster operation.
        public let clusterOperationArn: String?

        public init(clusterArn: String? = nil, clusterOperationArn: String? = nil) {
            self.clusterArn = clusterArn
            self.clusterOperationArn = clusterOperationArn
        }

        private enum CodingKeys: String, CodingKey {
            case clusterArn = "clusterArn"
            case clusterOperationArn = "clusterOperationArn"
        }
    }

    public struct UpdateClusterConfigurationRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) that uniquely identifies the cluster.
        public let clusterArn: String
        /// Represents the configuration that you want MSK to use for the brokers in a cluster.
        public let configurationInfo: ConfigurationInfo?
        /// The version of the cluster that needs to be updated.
        public let currentVersion: String?

        public init(clusterArn: String, configurationInfo: ConfigurationInfo? = nil, currentVersion: String? = nil) {
            self.clusterArn = clusterArn
            self.configurationInfo = configurationInfo
            self.currentVersion = currentVersion
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.clusterArn, key: "ClusterArn")
            try container.encodeIfPresent(self.configurationInfo, forKey: .configurationInfo)
            try container.encodeIfPresent(self.currentVersion, forKey: .currentVersion)
        }

        private enum CodingKeys: String, CodingKey {
            case configurationInfo = "configurationInfo"
            case currentVersion = "currentVersion"
        }
    }

    public struct UpdateClusterConfigurationResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the cluster.
        public let clusterArn: String?
        /// The Amazon Resource Name (ARN) of the cluster operation.
        public let clusterOperationArn: String?

        public init(clusterArn: String? = nil, clusterOperationArn: String? = nil) {
            self.clusterArn = clusterArn
            self.clusterOperationArn = clusterOperationArn
        }

        private enum CodingKeys: String, CodingKey {
            case clusterArn = "clusterArn"
            case clusterOperationArn = "clusterOperationArn"
        }
    }

    public struct UpdateClusterKafkaVersionRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the cluster to be updated.
        public let clusterArn: String
        /// The custom configuration that should be applied on the new version of cluster.
        public let configurationInfo: ConfigurationInfo?
        /// Current cluster version.
        public let currentVersion: String?
        /// Target Kafka version.
        public let targetKafkaVersion: String?

        public init(clusterArn: String, configurationInfo: ConfigurationInfo? = nil, currentVersion: String? = nil, targetKafkaVersion: String? = nil) {
            self.clusterArn = clusterArn
            self.configurationInfo = configurationInfo
            self.currentVersion = currentVersion
            self.targetKafkaVersion = targetKafkaVersion
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.clusterArn, key: "ClusterArn")
            try container.encodeIfPresent(self.configurationInfo, forKey: .configurationInfo)
            try container.encodeIfPresent(self.currentVersion, forKey: .currentVersion)
            try container.encodeIfPresent(self.targetKafkaVersion, forKey: .targetKafkaVersion)
        }

        private enum CodingKeys: String, CodingKey {
            case configurationInfo = "configurationInfo"
            case currentVersion = "currentVersion"
            case targetKafkaVersion = "targetKafkaVersion"
        }
    }

    public struct UpdateClusterKafkaVersionResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the cluster.
        public let clusterArn: String?
        /// The Amazon Resource Name (ARN) of the cluster operation.
        public let clusterOperationArn: String?

        public init(clusterArn: String? = nil, clusterOperationArn: String? = nil) {
            self.clusterArn = clusterArn
            self.clusterOperationArn = clusterOperationArn
        }

        private enum CodingKeys: String, CodingKey {
            case clusterArn = "clusterArn"
            case clusterOperationArn = "clusterOperationArn"
        }
    }

    public struct UpdateConfigurationRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the configuration.
        public let arn: String
        /// The description of the configuration revision.
        public let description: String?
        /// Contents of the server.properties file. When using the API, you must ensure that the contents of the file are base64 encoded.  When using the AWS Management Console, the SDK, or the AWS CLI, the contents of server.properties can be in plaintext.
        public let serverProperties: AWSBase64Data?

        public init(arn: String, description: String? = nil, serverProperties: AWSBase64Data? = nil) {
            self.arn = arn
            self.description = description
            self.serverProperties = serverProperties
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.arn, key: "Arn")
            try container.encodeIfPresent(self.description, forKey: .description)
            try container.encodeIfPresent(self.serverProperties, forKey: .serverProperties)
        }

        private enum CodingKeys: String, CodingKey {
            case description = "description"
            case serverProperties = "serverProperties"
        }
    }

    public struct UpdateConfigurationResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the configuration.
        public let arn: String?
        /// Latest revision of the configuration.
        public let latestRevision: ConfigurationRevision?

        public init(arn: String? = nil, latestRevision: ConfigurationRevision? = nil) {
            self.arn = arn
            self.latestRevision = latestRevision
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case latestRevision = "latestRevision"
        }
    }

    public struct UpdateConnectivityRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the configuration.
        public let clusterArn: String
        /// Information about the broker access configuration.
        public let connectivityInfo: ConnectivityInfo?
        /// The version of the MSK cluster to update. Cluster versions aren't simple numbers. You can describe an MSK cluster to find its version. When this update operation is successful, it generates a new cluster version.
        public let currentVersion: String?

        public init(clusterArn: String, connectivityInfo: ConnectivityInfo? = nil, currentVersion: String? = nil) {
            self.clusterArn = clusterArn
            self.connectivityInfo = connectivityInfo
            self.currentVersion = currentVersion
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.clusterArn, key: "ClusterArn")
            try container.encodeIfPresent(self.connectivityInfo, forKey: .connectivityInfo)
            try container.encodeIfPresent(self.currentVersion, forKey: .currentVersion)
        }

        private enum CodingKeys: String, CodingKey {
            case connectivityInfo = "connectivityInfo"
            case currentVersion = "currentVersion"
        }
    }

    public struct UpdateConnectivityResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the cluster.
        public let clusterArn: String?
        /// The Amazon Resource Name (ARN) of the cluster operation.
        public let clusterOperationArn: String?

        public init(clusterArn: String? = nil, clusterOperationArn: String? = nil) {
            self.clusterArn = clusterArn
            self.clusterOperationArn = clusterOperationArn
        }

        private enum CodingKeys: String, CodingKey {
            case clusterArn = "clusterArn"
            case clusterOperationArn = "clusterOperationArn"
        }
    }

    public struct UpdateMonitoringRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) that uniquely identifies the cluster.
        public let clusterArn: String
        /// The version of the MSK cluster to update. Cluster versions aren't simple numbers. You can describe an MSK cluster to find its version. When this update operation is successful, it generates a new cluster version.
        public let currentVersion: String?
        /// Specifies which Apache Kafka metrics Amazon MSK gathers and sends to Amazon CloudWatch for this cluster.
        public let enhancedMonitoring: EnhancedMonitoring?
        public let loggingInfo: LoggingInfo?
        /// The settings for open monitoring.
        public let openMonitoring: OpenMonitoringInfo?

        public init(clusterArn: String, currentVersion: String? = nil, enhancedMonitoring: EnhancedMonitoring? = nil, loggingInfo: LoggingInfo? = nil, openMonitoring: OpenMonitoringInfo? = nil) {
            self.clusterArn = clusterArn
            self.currentVersion = currentVersion
            self.enhancedMonitoring = enhancedMonitoring
            self.loggingInfo = loggingInfo
            self.openMonitoring = openMonitoring
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.clusterArn, key: "ClusterArn")
            try container.encodeIfPresent(self.currentVersion, forKey: .currentVersion)
            try container.encodeIfPresent(self.enhancedMonitoring, forKey: .enhancedMonitoring)
            try container.encodeIfPresent(self.loggingInfo, forKey: .loggingInfo)
            try container.encodeIfPresent(self.openMonitoring, forKey: .openMonitoring)
        }

        private enum CodingKeys: String, CodingKey {
            case currentVersion = "currentVersion"
            case enhancedMonitoring = "enhancedMonitoring"
            case loggingInfo = "loggingInfo"
            case openMonitoring = "openMonitoring"
        }
    }

    public struct UpdateMonitoringResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the cluster.
        public let clusterArn: String?
        /// The Amazon Resource Name (ARN) of the cluster operation.
        public let clusterOperationArn: String?

        public init(clusterArn: String? = nil, clusterOperationArn: String? = nil) {
            self.clusterArn = clusterArn
            self.clusterOperationArn = clusterOperationArn
        }

        private enum CodingKeys: String, CodingKey {
            case clusterArn = "clusterArn"
            case clusterOperationArn = "clusterOperationArn"
        }
    }

    public struct UpdateReplicationInfoRequest: AWSEncodableShape {
        /// Updated consumer group replication information.
        public let consumerGroupReplication: ConsumerGroupReplicationUpdate?
        /// Current replicator version.
        public let currentVersion: String?
        /// The Amazon Resource Name (ARN) of the replicator to be updated.
        public let replicatorArn: String
        /// The ARN of the source Kafka cluster.
        public let sourceKafkaClusterArn: String?
        /// The ARN of the target Kafka cluster.
        public let targetKafkaClusterArn: String?
        /// Updated topic replication information.
        public let topicReplication: TopicReplicationUpdate?

        public init(consumerGroupReplication: ConsumerGroupReplicationUpdate? = nil, currentVersion: String? = nil, replicatorArn: String, sourceKafkaClusterArn: String? = nil, targetKafkaClusterArn: String? = nil, topicReplication: TopicReplicationUpdate? = nil) {
            self.consumerGroupReplication = consumerGroupReplication
            self.currentVersion = currentVersion
            self.replicatorArn = replicatorArn
            self.sourceKafkaClusterArn = sourceKafkaClusterArn
            self.targetKafkaClusterArn = targetKafkaClusterArn
            self.topicReplication = topicReplication
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.consumerGroupReplication, forKey: .consumerGroupReplication)
            try container.encodeIfPresent(self.currentVersion, forKey: .currentVersion)
            request.encodePath(self.replicatorArn, key: "ReplicatorArn")
            try container.encodeIfPresent(self.sourceKafkaClusterArn, forKey: .sourceKafkaClusterArn)
            try container.encodeIfPresent(self.targetKafkaClusterArn, forKey: .targetKafkaClusterArn)
            try container.encodeIfPresent(self.topicReplication, forKey: .topicReplication)
        }

        public func validate(name: String) throws {
            try self.consumerGroupReplication?.validate(name: "\(name).consumerGroupReplication")
            try self.topicReplication?.validate(name: "\(name).topicReplication")
        }

        private enum CodingKeys: String, CodingKey {
            case consumerGroupReplication = "consumerGroupReplication"
            case currentVersion = "currentVersion"
            case sourceKafkaClusterArn = "sourceKafkaClusterArn"
            case targetKafkaClusterArn = "targetKafkaClusterArn"
            case topicReplication = "topicReplication"
        }
    }

    public struct UpdateReplicationInfoResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the replicator.
        public let replicatorArn: String?
        /// State of the replicator.
        public let replicatorState: ReplicatorState?

        public init(replicatorArn: String? = nil, replicatorState: ReplicatorState? = nil) {
            self.replicatorArn = replicatorArn
            self.replicatorState = replicatorState
        }

        private enum CodingKeys: String, CodingKey {
            case replicatorArn = "replicatorArn"
            case replicatorState = "replicatorState"
        }
    }

    public struct UpdateSecurityRequest: AWSEncodableShape {
        /// Includes all client authentication related information.
        public let clientAuthentication: ClientAuthentication?
        /// The Amazon Resource Name (ARN) that uniquely identifies the cluster.
        public let clusterArn: String
        /// The version of the MSK cluster to update. Cluster versions aren't simple numbers. You can describe an MSK cluster to find its version. When this update operation is successful, it generates a new cluster version.
        public let currentVersion: String?
        /// Includes all encryption-related information.
        public let encryptionInfo: EncryptionInfo?

        public init(clientAuthentication: ClientAuthentication? = nil, clusterArn: String, currentVersion: String? = nil, encryptionInfo: EncryptionInfo? = nil) {
            self.clientAuthentication = clientAuthentication
            self.clusterArn = clusterArn
            self.currentVersion = currentVersion
            self.encryptionInfo = encryptionInfo
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.clientAuthentication, forKey: .clientAuthentication)
            request.encodePath(self.clusterArn, key: "ClusterArn")
            try container.encodeIfPresent(self.currentVersion, forKey: .currentVersion)
            try container.encodeIfPresent(self.encryptionInfo, forKey: .encryptionInfo)
        }

        private enum CodingKeys: String, CodingKey {
            case clientAuthentication = "clientAuthentication"
            case currentVersion = "currentVersion"
            case encryptionInfo = "encryptionInfo"
        }
    }

    public struct UpdateSecurityResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the cluster.
        public let clusterArn: String?
        /// The Amazon Resource Name (ARN) of the cluster operation.
        public let clusterOperationArn: String?

        public init(clusterArn: String? = nil, clusterOperationArn: String? = nil) {
            self.clusterArn = clusterArn
            self.clusterOperationArn = clusterOperationArn
        }

        private enum CodingKeys: String, CodingKey {
            case clusterArn = "clusterArn"
            case clusterOperationArn = "clusterOperationArn"
        }
    }

    public struct UpdateStorageRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the cluster to be updated.
        public let clusterArn: String
        /// The version of cluster to update from. A successful operation will then generate a new version.
        public let currentVersion: String?
        /// EBS volume provisioned throughput information.
        public let provisionedThroughput: ProvisionedThroughput?
        /// Controls storage mode for supported storage tiers.
        public let storageMode: StorageMode?
        /// size of the EBS volume to update.
        public let volumeSizeGB: Int?

        public init(clusterArn: String, currentVersion: String? = nil, provisionedThroughput: ProvisionedThroughput? = nil, storageMode: StorageMode? = nil, volumeSizeGB: Int? = nil) {
            self.clusterArn = clusterArn
            self.currentVersion = currentVersion
            self.provisionedThroughput = provisionedThroughput
            self.storageMode = storageMode
            self.volumeSizeGB = volumeSizeGB
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.clusterArn, key: "ClusterArn")
            try container.encodeIfPresent(self.currentVersion, forKey: .currentVersion)
            try container.encodeIfPresent(self.provisionedThroughput, forKey: .provisionedThroughput)
            try container.encodeIfPresent(self.storageMode, forKey: .storageMode)
            try container.encodeIfPresent(self.volumeSizeGB, forKey: .volumeSizeGB)
        }

        private enum CodingKeys: String, CodingKey {
            case currentVersion = "currentVersion"
            case provisionedThroughput = "provisionedThroughput"
            case storageMode = "storageMode"
            case volumeSizeGB = "volumeSizeGB"
        }
    }

    public struct UpdateStorageResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the cluster.
        public let clusterArn: String?
        /// The Amazon Resource Name (ARN) of the cluster operation.
        public let clusterOperationArn: String?

        public init(clusterArn: String? = nil, clusterOperationArn: String? = nil) {
            self.clusterArn = clusterArn
            self.clusterOperationArn = clusterOperationArn
        }

        private enum CodingKeys: String, CodingKey {
            case clusterArn = "clusterArn"
            case clusterOperationArn = "clusterOperationArn"
        }
    }

    public struct UserIdentity: AWSDecodableShape {
        /// A unique identifier for the requester that calls the API operation.
        public let principalId: String?
        /// The identity type of the requester that calls the API operation.
        public let type: UserIdentityType?

        public init(principalId: String? = nil, type: UserIdentityType? = nil) {
            self.principalId = principalId
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case principalId = "principalId"
            case type = "type"
        }
    }

    public struct VpcConfig: AWSEncodableShape & AWSDecodableShape {
        /// The IDs of the security groups associated with the cluster.
        public let securityGroupIds: [String]?
        /// The IDs of the subnets associated with the cluster.
        public let subnetIds: [String]?

        public init(securityGroupIds: [String]? = nil, subnetIds: [String]? = nil) {
            self.securityGroupIds = securityGroupIds
            self.subnetIds = subnetIds
        }

        private enum CodingKeys: String, CodingKey {
            case securityGroupIds = "securityGroupIds"
            case subnetIds = "subnetIds"
        }
    }

    public struct VpcConnection: AWSDecodableShape {
        /// Information about the auth scheme of Vpc Connection.
        public let authentication: String?
        /// Creation time of the Vpc Connection.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var creationTime: Date?
        /// State of the Vpc Connection.
        public let state: VpcConnectionState?
        /// The ARN that identifies the Cluster which the Vpc Connection belongs to.
        public let targetClusterArn: String?
        /// The ARN that identifies the Vpc Connection.
        public let vpcConnectionArn: String?
        /// The vpcId that belongs to the Vpc Connection.
        public let vpcId: String?

        public init(authentication: String? = nil, creationTime: Date? = nil, state: VpcConnectionState? = nil, targetClusterArn: String? = nil, vpcConnectionArn: String? = nil, vpcId: String? = nil) {
            self.authentication = authentication
            self.creationTime = creationTime
            self.state = state
            self.targetClusterArn = targetClusterArn
            self.vpcConnectionArn = vpcConnectionArn
            self.vpcId = vpcId
        }

        private enum CodingKeys: String, CodingKey {
            case authentication = "authentication"
            case creationTime = "creationTime"
            case state = "state"
            case targetClusterArn = "targetClusterArn"
            case vpcConnectionArn = "vpcConnectionArn"
            case vpcId = "vpcId"
        }
    }

    public struct VpcConnectionInfo: AWSDecodableShape {
        /// The time when Amazon MSK creates the VPC Connnection.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var creationTime: Date?
        /// The owner of the VPC Connection.
        public let owner: String?
        /// Description of the requester that calls the API operation.
        public let userIdentity: UserIdentity?
        /// The Amazon Resource Name (ARN) of the VPC connection.
        public let vpcConnectionArn: String?

        public init(creationTime: Date? = nil, owner: String? = nil, userIdentity: UserIdentity? = nil, vpcConnectionArn: String? = nil) {
            self.creationTime = creationTime
            self.owner = owner
            self.userIdentity = userIdentity
            self.vpcConnectionArn = vpcConnectionArn
        }

        private enum CodingKeys: String, CodingKey {
            case creationTime = "creationTime"
            case owner = "owner"
            case userIdentity = "userIdentity"
            case vpcConnectionArn = "vpcConnectionArn"
        }
    }

    public struct VpcConnectionInfoServerless: AWSDecodableShape {
        /// The time when Amazon MSK creates the VPC Connnection.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var creationTime: Date?
        /// The owner of the VPC Connection.
        public let owner: String?
        /// Description of the requester that calls the API operation.
        public let userIdentity: UserIdentity?
        /// The Amazon Resource Name (ARN) of the VPC connection.
        public let vpcConnectionArn: String?

        public init(creationTime: Date? = nil, owner: String? = nil, userIdentity: UserIdentity? = nil, vpcConnectionArn: String? = nil) {
            self.creationTime = creationTime
            self.owner = owner
            self.userIdentity = userIdentity
            self.vpcConnectionArn = vpcConnectionArn
        }

        private enum CodingKeys: String, CodingKey {
            case creationTime = "creationTime"
            case owner = "owner"
            case userIdentity = "userIdentity"
            case vpcConnectionArn = "vpcConnectionArn"
        }
    }

    public struct VpcConnectivity: AWSEncodableShape & AWSDecodableShape {
        /// Includes all client authentication information for VPC connectivity.
        public let clientAuthentication: VpcConnectivityClientAuthentication?

        public init(clientAuthentication: VpcConnectivityClientAuthentication? = nil) {
            self.clientAuthentication = clientAuthentication
        }

        private enum CodingKeys: String, CodingKey {
            case clientAuthentication = "clientAuthentication"
        }
    }

    public struct VpcConnectivityClientAuthentication: AWSEncodableShape & AWSDecodableShape {
        /// SASL authentication type details for VPC connectivity.
        public let sasl: VpcConnectivitySasl?
        /// TLS authentication type details for VPC connectivity.
        public let tls: VpcConnectivityTls?

        public init(sasl: VpcConnectivitySasl? = nil, tls: VpcConnectivityTls? = nil) {
            self.sasl = sasl
            self.tls = tls
        }

        private enum CodingKeys: String, CodingKey {
            case sasl = "sasl"
            case tls = "tls"
        }
    }

    public struct VpcConnectivityIam: AWSEncodableShape & AWSDecodableShape {
        /// SASL/IAM authentication is on or off for VPC connectivity.
        public let enabled: Bool?

        public init(enabled: Bool? = nil) {
            self.enabled = enabled
        }

        private enum CodingKeys: String, CodingKey {
            case enabled = "enabled"
        }
    }

    public struct VpcConnectivitySasl: AWSEncodableShape & AWSDecodableShape {
        /// Details for SASL/IAM client authentication for VPC connectivity.
        public let iam: VpcConnectivityIam?
        /// Details for SASL/SCRAM client authentication for VPC connectivity.
        public let scram: VpcConnectivityScram?

        public init(iam: VpcConnectivityIam? = nil, scram: VpcConnectivityScram? = nil) {
            self.iam = iam
            self.scram = scram
        }

        private enum CodingKeys: String, CodingKey {
            case iam = "iam"
            case scram = "scram"
        }
    }

    public struct VpcConnectivityScram: AWSEncodableShape & AWSDecodableShape {
        /// SASL/SCRAM authentication is on or off for VPC connectivity.
        public let enabled: Bool?

        public init(enabled: Bool? = nil) {
            self.enabled = enabled
        }

        private enum CodingKeys: String, CodingKey {
            case enabled = "enabled"
        }
    }

    public struct VpcConnectivityTls: AWSEncodableShape & AWSDecodableShape {
        /// TLS authentication is on or off for VPC connectivity.
        public let enabled: Bool?

        public init(enabled: Bool? = nil) {
            self.enabled = enabled
        }

        private enum CodingKeys: String, CodingKey {
            case enabled = "enabled"
        }
    }

    public struct ZookeeperNodeInfo: AWSDecodableShape {
        /// The attached elastic network interface of the broker.
        public let attachedENIId: String?
        /// The virtual private cloud (VPC) IP address of the client.
        public let clientVpcIpAddress: String?
        /// Endpoints for accessing the ZooKeeper.
        public let endpoints: [String]?
        /// The role-specific ID for Zookeeper.
        public let zookeeperId: Double?
        /// The version of Zookeeper.
        public let zookeeperVersion: String?

        public init(attachedENIId: String? = nil, clientVpcIpAddress: String? = nil, endpoints: [String]? = nil, zookeeperId: Double? = nil, zookeeperVersion: String? = nil) {
            self.attachedENIId = attachedENIId
            self.clientVpcIpAddress = clientVpcIpAddress
            self.endpoints = endpoints
            self.zookeeperId = zookeeperId
            self.zookeeperVersion = zookeeperVersion
        }

        private enum CodingKeys: String, CodingKey {
            case attachedENIId = "attachedENIId"
            case clientVpcIpAddress = "clientVpcIpAddress"
            case endpoints = "endpoints"
            case zookeeperId = "zookeeperId"
            case zookeeperVersion = "zookeeperVersion"
        }
    }
}

// MARK: - Errors

/// Error enum for Kafka
public struct KafkaErrorType: AWSErrorType {
    enum Code: String {
        case badRequestException = "BadRequestException"
        case conflictException = "ConflictException"
        case forbiddenException = "ForbiddenException"
        case internalServerErrorException = "InternalServerErrorException"
        case notFoundException = "NotFoundException"
        case serviceUnavailableException = "ServiceUnavailableException"
        case tooManyRequestsException = "TooManyRequestsException"
        case unauthorizedException = "UnauthorizedException"
    }

    private let error: Code
    public let context: AWSErrorContext?

    /// initialize Kafka
    public init?(errorCode: String, context: AWSErrorContext) {
        guard let error = Code(rawValue: errorCode) else { return nil }
        self.error = error
        self.context = context
    }

    internal init(_ error: Code) {
        self.error = error
        self.context = nil
    }

    /// return error code string
    public var errorCode: String { self.error.rawValue }

    /// Returns information about an error.
    public static var badRequestException: Self { .init(.badRequestException) }
    /// Returns information about an error.
    public static var conflictException: Self { .init(.conflictException) }
    /// Returns information about an error.
    public static var forbiddenException: Self { .init(.forbiddenException) }
    /// Returns information about an error.
    public static var internalServerErrorException: Self { .init(.internalServerErrorException) }
    /// Returns information about an error.
    public static var notFoundException: Self { .init(.notFoundException) }
    /// Returns information about an error.
    public static var serviceUnavailableException: Self { .init(.serviceUnavailableException) }
    /// Returns information about an error.
    public static var tooManyRequestsException: Self { .init(.tooManyRequestsException) }
    /// Returns information about an error.
    public static var unauthorizedException: Self { .init(.unauthorizedException) }
}

extension KafkaErrorType: Equatable {
    public static func == (lhs: KafkaErrorType, rhs: KafkaErrorType) -> Bool {
        lhs.error == rhs.error
    }
}

extension KafkaErrorType: CustomStringConvertible {
    public var description: String {
        return "\(self.error.rawValue): \(self.message ?? "")"
    }
}
