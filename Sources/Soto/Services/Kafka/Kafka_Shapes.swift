//===----------------------------------------------------------------------===//
//
// This source file is part of the Soto for AWS open source project
//
// Copyright (c) 2017-2021 the Soto project authors
// Licensed under Apache License v2.0
//
// See LICENSE.txt for license information
// See CONTRIBUTORS.txt for the list of Soto project authors
//
// SPDX-License-Identifier: Apache-2.0
//
//===----------------------------------------------------------------------===//

// THIS FILE IS AUTOMATICALLY GENERATED by https://github.com/soto-project/soto/tree/main/CodeGenerator. DO NOT EDIT.

import Foundation
import SotoCore

extension Kafka {
    // MARK: Enums

    public enum BrokerAZDistribution: String, CustomStringConvertible, Codable {
        case `default` = "DEFAULT"
        public var description: String { return self.rawValue }
    }

    public enum ClientBroker: String, CustomStringConvertible, Codable {
        case plaintext = "PLAINTEXT"
        case tls = "TLS"
        case tlsPlaintext = "TLS_PLAINTEXT"
        public var description: String { return self.rawValue }
    }

    public enum ClusterState: String, CustomStringConvertible, Codable {
        case active = "ACTIVE"
        case creating = "CREATING"
        case deleting = "DELETING"
        case failed = "FAILED"
        case healing = "HEALING"
        case maintenance = "MAINTENANCE"
        case rebootingBroker = "REBOOTING_BROKER"
        case updating = "UPDATING"
        public var description: String { return self.rawValue }
    }

    public enum ConfigurationState: String, CustomStringConvertible, Codable {
        case active = "ACTIVE"
        case deleteFailed = "DELETE_FAILED"
        case deleting = "DELETING"
        public var description: String { return self.rawValue }
    }

    public enum EnhancedMonitoring: String, CustomStringConvertible, Codable {
        case `default` = "DEFAULT"
        case perBroker = "PER_BROKER"
        case perTopicPerBroker = "PER_TOPIC_PER_BROKER"
        case perTopicPerPartition = "PER_TOPIC_PER_PARTITION"
        public var description: String { return self.rawValue }
    }

    public enum KafkaVersionStatus: String, CustomStringConvertible, Codable {
        case active = "ACTIVE"
        case deprecated = "DEPRECATED"
        public var description: String { return self.rawValue }
    }

    public enum NodeType: String, CustomStringConvertible, Codable {
        case broker = "BROKER"
        public var description: String { return self.rawValue }
    }

    // MARK: Shapes

    public struct BatchAssociateScramSecretRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "clusterArn", location: .uri(locationName: "clusterArn"))
        ]

        public let clusterArn: String
        /// List of AWS Secrets Manager secret ARNs.
        public let secretArnList: [String]

        public init(clusterArn: String, secretArnList: [String]) {
            self.clusterArn = clusterArn
            self.secretArnList = secretArnList
        }

        private enum CodingKeys: String, CodingKey {
            case secretArnList
        }
    }

    public struct BatchAssociateScramSecretResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the cluster.
        public let clusterArn: String?
        /// List of errors when associating secrets to cluster.
        public let unprocessedScramSecrets: [UnprocessedScramSecret]?

        public init(clusterArn: String? = nil, unprocessedScramSecrets: [UnprocessedScramSecret]? = nil) {
            self.clusterArn = clusterArn
            self.unprocessedScramSecrets = unprocessedScramSecrets
        }

        private enum CodingKeys: String, CodingKey {
            case clusterArn
            case unprocessedScramSecrets
        }
    }

    public struct BatchDisassociateScramSecretRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "clusterArn", location: .uri(locationName: "clusterArn"))
        ]

        public let clusterArn: String
        /// List of AWS Secrets Manager secret ARNs.
        public let secretArnList: [String]

        public init(clusterArn: String, secretArnList: [String]) {
            self.clusterArn = clusterArn
            self.secretArnList = secretArnList
        }

        private enum CodingKeys: String, CodingKey {
            case secretArnList
        }
    }

    public struct BatchDisassociateScramSecretResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the cluster.
        public let clusterArn: String?
        /// List of errors when disassociating secrets to cluster.
        public let unprocessedScramSecrets: [UnprocessedScramSecret]?

        public init(clusterArn: String? = nil, unprocessedScramSecrets: [UnprocessedScramSecret]? = nil) {
            self.clusterArn = clusterArn
            self.unprocessedScramSecrets = unprocessedScramSecrets
        }

        private enum CodingKeys: String, CodingKey {
            case clusterArn
            case unprocessedScramSecrets
        }
    }

    public struct BrokerEBSVolumeInfo: AWSEncodableShape & AWSDecodableShape {
        /// The ID of the broker to update.
        public let kafkaBrokerNodeId: String
        ///             Size of the EBS volume to update.
        public let volumeSizeGB: Int

        public init(kafkaBrokerNodeId: String, volumeSizeGB: Int) {
            self.kafkaBrokerNodeId = kafkaBrokerNodeId
            self.volumeSizeGB = volumeSizeGB
        }

        private enum CodingKeys: String, CodingKey {
            case kafkaBrokerNodeId
            case volumeSizeGB
        }
    }

    public struct BrokerLogs: AWSEncodableShape & AWSDecodableShape {
        /// Details of the CloudWatch Logs destination for broker logs.
        public let cloudWatchLogs: CloudWatchLogs?
        /// Details of the Kinesis Data Firehose delivery stream that is the destination for broker logs.
        public let firehose: Firehose?
        /// Details of the Amazon S3 destination for broker logs.
        public let s3: S3?

        public init(cloudWatchLogs: CloudWatchLogs? = nil, firehose: Firehose? = nil, s3: S3? = nil) {
            self.cloudWatchLogs = cloudWatchLogs
            self.firehose = firehose
            self.s3 = s3
        }

        private enum CodingKeys: String, CodingKey {
            case cloudWatchLogs
            case firehose
            case s3
        }
    }

    public struct BrokerNodeGroupInfo: AWSEncodableShape & AWSDecodableShape {
        /// The distribution of broker nodes across Availability Zones.
        public let brokerAZDistribution: BrokerAZDistribution?
        /// The list of subnets to connect to in the client virtual private cloud (VPC). AWS creates elastic network interfaces inside these subnets. Client applications use elastic network interfaces to produce and consume data. Client subnets can't be in Availability Zone us-east-1e.
        public let clientSubnets: [String]
        /// The type of broker used in the Amazon MSK cluster.
        public let instanceType: String
        /// The AWS security groups to associate with the elastic network interfaces in order to specify who can connect to and communicate with the Amazon MSK cluster. If you don't specify a security group, Amazon MSK uses the default security group associated with the VPC. If you specify security groups that were shared with you, you must ensure that you have permissions to them. Specifically, you need the ec2:DescribeSecurityGroups permission.
        public let securityGroups: [String]?
        /// Contains information about storage volumes attached to MSK broker nodes.
        public let storageInfo: StorageInfo?

        public init(brokerAZDistribution: BrokerAZDistribution? = nil, clientSubnets: [String], instanceType: String, securityGroups: [String]? = nil, storageInfo: StorageInfo? = nil) {
            self.brokerAZDistribution = brokerAZDistribution
            self.clientSubnets = clientSubnets
            self.instanceType = instanceType
            self.securityGroups = securityGroups
            self.storageInfo = storageInfo
        }

        public func validate(name: String) throws {
            try self.validate(self.instanceType, name: "instanceType", parent: name, max: 32)
            try self.validate(self.instanceType, name: "instanceType", parent: name, min: 5)
            try self.storageInfo?.validate(name: "\(name).storageInfo")
        }

        private enum CodingKeys: String, CodingKey {
            case brokerAZDistribution
            case clientSubnets
            case instanceType
            case securityGroups
            case storageInfo
        }
    }

    public struct BrokerNodeInfo: AWSDecodableShape {
        /// The attached elastic network interface of the broker.
        public let attachedENIId: String?
        /// The ID of the broker.
        public let brokerId: Double?
        /// The client subnet to which this broker node belongs.
        public let clientSubnet: String?
        /// The virtual private cloud (VPC) of the client.
        public let clientVpcIpAddress: String?
        /// Information about the version of software currently deployed on the Kafka brokers in the cluster.
        public let currentBrokerSoftwareInfo: BrokerSoftwareInfo?
        /// Endpoints for accessing the broker.
        public let endpoints: [String]?

        public init(attachedENIId: String? = nil, brokerId: Double? = nil, clientSubnet: String? = nil, clientVpcIpAddress: String? = nil, currentBrokerSoftwareInfo: BrokerSoftwareInfo? = nil, endpoints: [String]? = nil) {
            self.attachedENIId = attachedENIId
            self.brokerId = brokerId
            self.clientSubnet = clientSubnet
            self.clientVpcIpAddress = clientVpcIpAddress
            self.currentBrokerSoftwareInfo = currentBrokerSoftwareInfo
            self.endpoints = endpoints
        }

        private enum CodingKeys: String, CodingKey {
            case attachedENIId
            case brokerId
            case clientSubnet
            case clientVpcIpAddress
            case currentBrokerSoftwareInfo
            case endpoints
        }
    }

    public struct BrokerSoftwareInfo: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the configuration used for the cluster. This field isn't visible in this preview release.
        public let configurationArn: String?
        /// The revision of the configuration to use. This field isn't visible in this preview release.
        public let configurationRevision: Int64?
        /// The version of Apache Kafka.
        public let kafkaVersion: String?

        public init(configurationArn: String? = nil, configurationRevision: Int64? = nil, kafkaVersion: String? = nil) {
            self.configurationArn = configurationArn
            self.configurationRevision = configurationRevision
            self.kafkaVersion = kafkaVersion
        }

        private enum CodingKeys: String, CodingKey {
            case configurationArn
            case configurationRevision
            case kafkaVersion
        }
    }

    public struct ClientAuthentication: AWSEncodableShape & AWSDecodableShape {
        public let sasl: Sasl?
        /// Details for ClientAuthentication using TLS.
        public let tls: Tls?

        public init(sasl: Sasl? = nil, tls: Tls? = nil) {
            self.sasl = sasl
            self.tls = tls
        }

        private enum CodingKeys: String, CodingKey {
            case sasl
            case tls
        }
    }

    public struct CloudWatchLogs: AWSEncodableShape & AWSDecodableShape {
        /// Specifies whether broker logs get sent to the specified CloudWatch Logs destination.
        public let enabled: Bool
        /// The CloudWatch log group that is the destination for broker logs.
        public let logGroup: String?

        public init(enabled: Bool, logGroup: String? = nil) {
            self.enabled = enabled
            self.logGroup = logGroup
        }

        private enum CodingKeys: String, CodingKey {
            case enabled
            case logGroup
        }
    }

    public struct ClusterInfo: AWSDecodableShape {
        /// Arn of active cluster operation.
        public let activeOperationArn: String?
        /// Information about the brokers.
        public let brokerNodeGroupInfo: BrokerNodeGroupInfo?
        /// Includes all client authentication information.
        public let clientAuthentication: ClientAuthentication?
        /// The Amazon Resource Name (ARN) that uniquely identifies the cluster.
        public let clusterArn: String?
        /// The name of the cluster.
        public let clusterName: String?
        /// The time when the cluster was created.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var creationTime: Date?
        /// Information about the version of software currently deployed on the Kafka brokers in the cluster.
        public let currentBrokerSoftwareInfo: BrokerSoftwareInfo?
        /// The current version of the MSK cluster. Cluster versions aren't simple integers. You can obtain the current version by describing the cluster. An example version is KTVPDKIKX0DER.
        public let currentVersion: String?
        /// Includes all encryption-related information.
        public let encryptionInfo: EncryptionInfo?
        /// Specifies which metrics are gathered for the MSK cluster. This property has the following possible values: DEFAULT, PER_BROKER, PER_TOPIC_PER_BROKER, and PER_TOPIC_PER_PARTITION. For a list of the metrics associated with each of these levels of monitoring, see Monitoring.
        public let enhancedMonitoring: EnhancedMonitoring?
        /// You can configure your MSK cluster to send broker logs to different destination types. This is a container for the configuration details related to broker logs.
        public let loggingInfo: LoggingInfo?
        ///             The number of broker nodes in the cluster.
        public let numberOfBrokerNodes: Int?
        /// Settings for open monitoring using Prometheus.
        public let openMonitoring: OpenMonitoring?
        /// The state of the cluster. The possible states are ACTIVE, CREATING, DELETING, FAILED, HEALING, MAINTENANCE, REBOOTING_BROKER, and UPDATING.
        public let state: ClusterState?
        /// Tags attached to the cluster.
        public let tags: [String: String]?
        /// The connection string to use to connect to the Apache ZooKeeper cluster.
        public let zookeeperConnectString: String?
        /// The connection string to use to connect to zookeeper cluster on Tls port.
        public let zookeeperConnectStringTls: String?

        public init(activeOperationArn: String? = nil, brokerNodeGroupInfo: BrokerNodeGroupInfo? = nil, clientAuthentication: ClientAuthentication? = nil, clusterArn: String? = nil, clusterName: String? = nil, creationTime: Date? = nil, currentBrokerSoftwareInfo: BrokerSoftwareInfo? = nil, currentVersion: String? = nil, encryptionInfo: EncryptionInfo? = nil, enhancedMonitoring: EnhancedMonitoring? = nil, loggingInfo: LoggingInfo? = nil, numberOfBrokerNodes: Int? = nil, openMonitoring: OpenMonitoring? = nil, state: ClusterState? = nil, tags: [String: String]? = nil, zookeeperConnectString: String? = nil, zookeeperConnectStringTls: String? = nil) {
            self.activeOperationArn = activeOperationArn
            self.brokerNodeGroupInfo = brokerNodeGroupInfo
            self.clientAuthentication = clientAuthentication
            self.clusterArn = clusterArn
            self.clusterName = clusterName
            self.creationTime = creationTime
            self.currentBrokerSoftwareInfo = currentBrokerSoftwareInfo
            self.currentVersion = currentVersion
            self.encryptionInfo = encryptionInfo
            self.enhancedMonitoring = enhancedMonitoring
            self.loggingInfo = loggingInfo
            self.numberOfBrokerNodes = numberOfBrokerNodes
            self.openMonitoring = openMonitoring
            self.state = state
            self.tags = tags
            self.zookeeperConnectString = zookeeperConnectString
            self.zookeeperConnectStringTls = zookeeperConnectStringTls
        }

        private enum CodingKeys: String, CodingKey {
            case activeOperationArn
            case brokerNodeGroupInfo
            case clientAuthentication
            case clusterArn
            case clusterName
            case creationTime
            case currentBrokerSoftwareInfo
            case currentVersion
            case encryptionInfo
            case enhancedMonitoring
            case loggingInfo
            case numberOfBrokerNodes
            case openMonitoring
            case state
            case tags
            case zookeeperConnectString
            case zookeeperConnectStringTls
        }
    }

    public struct ClusterOperationInfo: AWSDecodableShape {
        /// The ID of the API request that triggered this operation.
        public let clientRequestId: String?
        /// ARN of the cluster.
        public let clusterArn: String?
        /// The time at which operation was created.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var creationTime: Date?
        /// The time at which the operation finished.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var endTime: Date?
        /// Describes the error if the operation fails.
        public let errorInfo: ErrorInfo?
        /// ARN of the cluster operation.
        public let operationArn: String?
        /// State of the cluster operation.
        public let operationState: String?
        /// Steps completed during the operation.
        public let operationSteps: [ClusterOperationStep]?
        /// Type of the cluster operation.
        public let operationType: String?
        /// Information about cluster attributes before a cluster is updated.
        public let sourceClusterInfo: MutableClusterInfo?
        /// Information about cluster attributes after a cluster is updated.
        public let targetClusterInfo: MutableClusterInfo?

        public init(clientRequestId: String? = nil, clusterArn: String? = nil, creationTime: Date? = nil, endTime: Date? = nil, errorInfo: ErrorInfo? = nil, operationArn: String? = nil, operationState: String? = nil, operationSteps: [ClusterOperationStep]? = nil, operationType: String? = nil, sourceClusterInfo: MutableClusterInfo? = nil, targetClusterInfo: MutableClusterInfo? = nil) {
            self.clientRequestId = clientRequestId
            self.clusterArn = clusterArn
            self.creationTime = creationTime
            self.endTime = endTime
            self.errorInfo = errorInfo
            self.operationArn = operationArn
            self.operationState = operationState
            self.operationSteps = operationSteps
            self.operationType = operationType
            self.sourceClusterInfo = sourceClusterInfo
            self.targetClusterInfo = targetClusterInfo
        }

        private enum CodingKeys: String, CodingKey {
            case clientRequestId
            case clusterArn
            case creationTime
            case endTime
            case errorInfo
            case operationArn
            case operationState
            case operationSteps
            case operationType
            case sourceClusterInfo
            case targetClusterInfo
        }
    }

    public struct ClusterOperationStep: AWSDecodableShape {
        /// Information about the step and its status.
        public let stepInfo: ClusterOperationStepInfo?
        /// The name of the step.
        public let stepName: String?

        public init(stepInfo: ClusterOperationStepInfo? = nil, stepName: String? = nil) {
            self.stepInfo = stepInfo
            self.stepName = stepName
        }

        private enum CodingKeys: String, CodingKey {
            case stepInfo
            case stepName
        }
    }

    public struct ClusterOperationStepInfo: AWSDecodableShape {
        /// The steps current status.
        public let stepStatus: String?

        public init(stepStatus: String? = nil) {
            self.stepStatus = stepStatus
        }

        private enum CodingKeys: String, CodingKey {
            case stepStatus
        }
    }

    public struct CompatibleKafkaVersion: AWSDecodableShape {
        public let sourceVersion: String?
        public let targetVersions: [String]?

        public init(sourceVersion: String? = nil, targetVersions: [String]? = nil) {
            self.sourceVersion = sourceVersion
            self.targetVersions = targetVersions
        }

        private enum CodingKeys: String, CodingKey {
            case sourceVersion
            case targetVersions
        }
    }

    public struct Configuration: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the configuration.
        public let arn: String
        @CustomCoding<ISO8601DateCoder>
        public var creationTime: Date
        /// The description of the configuration.
        public let description: String
        /// An array of the versions of Apache Kafka with which you can use this MSK configuration. You can use this configuration for an MSK cluster only if the Apache Kafka version specified for the cluster appears in this array.
        public let kafkaVersions: [String]
        /// Latest revision of the configuration.
        public let latestRevision: ConfigurationRevision
        /// The name of the configuration. Configuration names are strings that match the regex "^[0-9A-Za-z-]+$".
        public let name: String
        public let state: ConfigurationState

        public init(arn: String, creationTime: Date, description: String, kafkaVersions: [String], latestRevision: ConfigurationRevision, name: String, state: ConfigurationState) {
            self.arn = arn
            self.creationTime = creationTime
            self.description = description
            self.kafkaVersions = kafkaVersions
            self.latestRevision = latestRevision
            self.name = name
            self.state = state
        }

        private enum CodingKeys: String, CodingKey {
            case arn
            case creationTime
            case description
            case kafkaVersions
            case latestRevision
            case name
            case state
        }
    }

    public struct ConfigurationInfo: AWSEncodableShape & AWSDecodableShape {
        /// ARN of the configuration to use.
        public let arn: String
        /// The revision of the configuration to use.
        public let revision: Int64

        public init(arn: String, revision: Int64) {
            self.arn = arn
            self.revision = revision
        }

        private enum CodingKeys: String, CodingKey {
            case arn
            case revision
        }
    }

    public struct ConfigurationRevision: AWSDecodableShape {
        /// The time when the configuration revision was created.
        @CustomCoding<ISO8601DateCoder>
        public var creationTime: Date
        /// The description of the configuration revision.
        public let description: String?
        /// The revision number.
        public let revision: Int64

        public init(creationTime: Date, description: String? = nil, revision: Int64) {
            self.creationTime = creationTime
            self.description = description
            self.revision = revision
        }

        private enum CodingKeys: String, CodingKey {
            case creationTime
            case description
            case revision
        }
    }

    public struct CreateClusterRequest: AWSEncodableShape {
        /// Information about the brokers.
        public let brokerNodeGroupInfo: BrokerNodeGroupInfo
        /// Includes all client authentication related information.
        public let clientAuthentication: ClientAuthentication?
        /// The name of the cluster.
        public let clusterName: String
        /// Represents the configuration that you want MSK to use for the cluster.
        public let configurationInfo: ConfigurationInfo?
        /// Includes all encryption-related information.
        public let encryptionInfo: EncryptionInfo?
        /// Specifies the level of monitoring for the MSK cluster. The possible values are DEFAULT, PER_BROKER, PER_TOPIC_PER_BROKER, and PER_TOPIC_PER_PARTITION.
        public let enhancedMonitoring: EnhancedMonitoring?
        /// The version of Apache Kafka.
        public let kafkaVersion: String
        /// LoggingInfo details.
        public let loggingInfo: LoggingInfo?
        /// The number of Kafka broker nodes in the Amazon MSK cluster.
        public let numberOfBrokerNodes: Int
        /// The settings for open monitoring.
        public let openMonitoring: OpenMonitoringInfo?
        /// Create tags when creating the cluster.
        public let tags: [String: String]?

        public init(brokerNodeGroupInfo: BrokerNodeGroupInfo, clientAuthentication: ClientAuthentication? = nil, clusterName: String, configurationInfo: ConfigurationInfo? = nil, encryptionInfo: EncryptionInfo? = nil, enhancedMonitoring: EnhancedMonitoring? = nil, kafkaVersion: String, loggingInfo: LoggingInfo? = nil, numberOfBrokerNodes: Int, openMonitoring: OpenMonitoringInfo? = nil, tags: [String: String]? = nil) {
            self.brokerNodeGroupInfo = brokerNodeGroupInfo
            self.clientAuthentication = clientAuthentication
            self.clusterName = clusterName
            self.configurationInfo = configurationInfo
            self.encryptionInfo = encryptionInfo
            self.enhancedMonitoring = enhancedMonitoring
            self.kafkaVersion = kafkaVersion
            self.loggingInfo = loggingInfo
            self.numberOfBrokerNodes = numberOfBrokerNodes
            self.openMonitoring = openMonitoring
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.brokerNodeGroupInfo.validate(name: "\(name).brokerNodeGroupInfo")
            try self.validate(self.clusterName, name: "clusterName", parent: name, max: 64)
            try self.validate(self.clusterName, name: "clusterName", parent: name, min: 1)
            try self.validate(self.kafkaVersion, name: "kafkaVersion", parent: name, max: 128)
            try self.validate(self.kafkaVersion, name: "kafkaVersion", parent: name, min: 1)
            try self.validate(self.numberOfBrokerNodes, name: "numberOfBrokerNodes", parent: name, max: 15)
            try self.validate(self.numberOfBrokerNodes, name: "numberOfBrokerNodes", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case brokerNodeGroupInfo
            case clientAuthentication
            case clusterName
            case configurationInfo
            case encryptionInfo
            case enhancedMonitoring
            case kafkaVersion
            case loggingInfo
            case numberOfBrokerNodes
            case openMonitoring
            case tags
        }
    }

    public struct CreateClusterResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the cluster.
        public let clusterArn: String?
        /// The name of the MSK cluster.
        public let clusterName: String?
        /// The state of the cluster. The possible states are ACTIVE, CREATING, DELETING, FAILED, HEALING, MAINTENANCE, REBOOTING_BROKER, and UPDATING.
        public let state: ClusterState?

        public init(clusterArn: String? = nil, clusterName: String? = nil, state: ClusterState? = nil) {
            self.clusterArn = clusterArn
            self.clusterName = clusterName
            self.state = state
        }

        private enum CodingKeys: String, CodingKey {
            case clusterArn
            case clusterName
            case state
        }
    }

    public struct CreateConfigurationRequest: AWSEncodableShape {
        /// The description of the configuration.
        public let description: String?
        /// The versions of Apache Kafka with which you can use this MSK configuration.
        public let kafkaVersions: [String]?
        /// The name of the configuration. Configuration names are strings that match the regex "^[0-9A-Za-z-]+$".
        public let name: String
        public let serverProperties: Data

        public init(description: String? = nil, kafkaVersions: [String]? = nil, name: String, serverProperties: Data) {
            self.description = description
            self.kafkaVersions = kafkaVersions
            self.name = name
            self.serverProperties = serverProperties
        }

        private enum CodingKeys: String, CodingKey {
            case description
            case kafkaVersions
            case name
            case serverProperties
        }
    }

    public struct CreateConfigurationResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the configuration.
        public let arn: String?
        /// The time when the configuration was created.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var creationTime: Date?
        /// Latest revision of the configuration.
        public let latestRevision: ConfigurationRevision?
        /// The name of the configuration. Configuration names are strings that match the regex "^[0-9A-Za-z-]+$".
        public let name: String?
        /// The state of the configuration. The possible states are ACTIVE, DELETING and DELETE_FAILED.
        public let state: ConfigurationState?

        public init(arn: String? = nil, creationTime: Date? = nil, latestRevision: ConfigurationRevision? = nil, name: String? = nil, state: ConfigurationState? = nil) {
            self.arn = arn
            self.creationTime = creationTime
            self.latestRevision = latestRevision
            self.name = name
            self.state = state
        }

        private enum CodingKeys: String, CodingKey {
            case arn
            case creationTime
            case latestRevision
            case name
            case state
        }
    }

    public struct DeleteClusterRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "clusterArn", location: .uri(locationName: "clusterArn")),
            AWSMemberEncoding(label: "currentVersion", location: .querystring(locationName: "currentVersion"))
        ]

        public let clusterArn: String
        public let currentVersion: String?

        public init(clusterArn: String, currentVersion: String? = nil) {
            self.clusterArn = clusterArn
            self.currentVersion = currentVersion
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteClusterResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the cluster.
        public let clusterArn: String?
        /// The state of the cluster. The possible states are ACTIVE, CREATING, DELETING, FAILED, HEALING, MAINTENANCE, REBOOTING_BROKER, and UPDATING.
        public let state: ClusterState?

        public init(clusterArn: String? = nil, state: ClusterState? = nil) {
            self.clusterArn = clusterArn
            self.state = state
        }

        private enum CodingKeys: String, CodingKey {
            case clusterArn
            case state
        }
    }

    public struct DeleteConfigurationRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "arn", location: .uri(locationName: "arn"))
        ]

        /// The Amazon Resource Name (ARN) of the configuration.
        public let arn: String

        public init(arn: String) {
            self.arn = arn
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteConfigurationResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the configuration.
        public let arn: String?
        /// The state of the configuration. The possible states are ACTIVE, DELETING and DELETE_FAILED.
        public let state: ConfigurationState?

        public init(arn: String? = nil, state: ConfigurationState? = nil) {
            self.arn = arn
            self.state = state
        }

        private enum CodingKeys: String, CodingKey {
            case arn
            case state
        }
    }

    public struct DescribeClusterOperationRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "clusterOperationArn", location: .uri(locationName: "clusterOperationArn"))
        ]

        public let clusterOperationArn: String

        public init(clusterOperationArn: String) {
            self.clusterOperationArn = clusterOperationArn
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DescribeClusterOperationResponse: AWSDecodableShape {
        /// Cluster operation information
        public let clusterOperationInfo: ClusterOperationInfo?

        public init(clusterOperationInfo: ClusterOperationInfo? = nil) {
            self.clusterOperationInfo = clusterOperationInfo
        }

        private enum CodingKeys: String, CodingKey {
            case clusterOperationInfo
        }
    }

    public struct DescribeClusterRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "clusterArn", location: .uri(locationName: "clusterArn"))
        ]

        public let clusterArn: String

        public init(clusterArn: String) {
            self.clusterArn = clusterArn
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DescribeClusterResponse: AWSDecodableShape {
        /// The cluster information.
        public let clusterInfo: ClusterInfo?

        public init(clusterInfo: ClusterInfo? = nil) {
            self.clusterInfo = clusterInfo
        }

        private enum CodingKeys: String, CodingKey {
            case clusterInfo
        }
    }

    public struct DescribeConfigurationRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "arn", location: .uri(locationName: "arn"))
        ]

        public let arn: String

        public init(arn: String) {
            self.arn = arn
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DescribeConfigurationResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the configuration.
        public let arn: String?
        /// The time when the configuration was created.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var creationTime: Date?
        /// The description of the configuration.
        public let description: String?
        /// The versions of Apache Kafka with which you can use this MSK configuration.
        public let kafkaVersions: [String]?
        /// Latest revision of the configuration.
        public let latestRevision: ConfigurationRevision?
        /// The name of the configuration. Configuration names are strings that match the regex "^[0-9A-Za-z-]+$".
        public let name: String?
        /// The state of the configuration. The possible states are ACTIVE, DELETING and DELETE_FAILED.
        public let state: ConfigurationState?

        public init(arn: String? = nil, creationTime: Date? = nil, description: String? = nil, kafkaVersions: [String]? = nil, latestRevision: ConfigurationRevision? = nil, name: String? = nil, state: ConfigurationState? = nil) {
            self.arn = arn
            self.creationTime = creationTime
            self.description = description
            self.kafkaVersions = kafkaVersions
            self.latestRevision = latestRevision
            self.name = name
            self.state = state
        }

        private enum CodingKeys: String, CodingKey {
            case arn
            case creationTime
            case description
            case kafkaVersions
            case latestRevision
            case name
            case state
        }
    }

    public struct DescribeConfigurationRevisionRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "arn", location: .uri(locationName: "arn")),
            AWSMemberEncoding(label: "revision", location: .uri(locationName: "revision"))
        ]

        public let arn: String
        public let revision: Int64

        public init(arn: String, revision: Int64) {
            self.arn = arn
            self.revision = revision
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DescribeConfigurationRevisionResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the configuration.
        public let arn: String?
        /// The time when the configuration was created.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var creationTime: Date?
        /// The description of the configuration.
        public let description: String?
        /// The revision number.
        public let revision: Int64?
        public let serverProperties: Data?

        public init(arn: String? = nil, creationTime: Date? = nil, description: String? = nil, revision: Int64? = nil, serverProperties: Data? = nil) {
            self.arn = arn
            self.creationTime = creationTime
            self.description = description
            self.revision = revision
            self.serverProperties = serverProperties
        }

        private enum CodingKeys: String, CodingKey {
            case arn
            case creationTime
            case description
            case revision
            case serverProperties
        }
    }

    public struct EBSStorageInfo: AWSEncodableShape & AWSDecodableShape {
        /// The size in GiB of the EBS volume for the data drive on each broker node.
        public let volumeSize: Int?

        public init(volumeSize: Int? = nil) {
            self.volumeSize = volumeSize
        }

        public func validate(name: String) throws {
            try self.validate(self.volumeSize, name: "volumeSize", parent: name, max: 16384)
            try self.validate(self.volumeSize, name: "volumeSize", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case volumeSize
        }
    }

    public struct EncryptionAtRest: AWSEncodableShape & AWSDecodableShape {
        /// The ARN of the AWS KMS key for encrypting data at rest. If you don't specify a KMS key, MSK creates one for you and uses it.
        public let dataVolumeKMSKeyId: String

        public init(dataVolumeKMSKeyId: String) {
            self.dataVolumeKMSKeyId = dataVolumeKMSKeyId
        }

        private enum CodingKeys: String, CodingKey {
            case dataVolumeKMSKeyId
        }
    }

    public struct EncryptionInTransit: AWSEncodableShape & AWSDecodableShape {
        /// Indicates the encryption setting for data in transit between clients and brokers. You must set it to one of the following values. TLS means that client-broker communication is enabled with TLS only. TLS_PLAINTEXT means that client-broker communication is enabled for both TLS-encrypted, as well as plaintext data. PLAINTEXT means that client-broker communication is enabled in plaintext only. The default value is TLS.
        public let clientBroker: ClientBroker?
        /// When set to true, it indicates that data communication among the broker nodes of the cluster is encrypted. When set to false, the communication happens in plaintext. The default value is true.
        public let inCluster: Bool?

        public init(clientBroker: ClientBroker? = nil, inCluster: Bool? = nil) {
            self.clientBroker = clientBroker
            self.inCluster = inCluster
        }

        private enum CodingKeys: String, CodingKey {
            case clientBroker
            case inCluster
        }
    }

    public struct EncryptionInfo: AWSEncodableShape & AWSDecodableShape {
        /// The data-volume encryption details.
        public let encryptionAtRest: EncryptionAtRest?
        /// The details for encryption in transit.
        public let encryptionInTransit: EncryptionInTransit?

        public init(encryptionAtRest: EncryptionAtRest? = nil, encryptionInTransit: EncryptionInTransit? = nil) {
            self.encryptionAtRest = encryptionAtRest
            self.encryptionInTransit = encryptionInTransit
        }

        private enum CodingKeys: String, CodingKey {
            case encryptionAtRest
            case encryptionInTransit
        }
    }

    public struct ErrorInfo: AWSDecodableShape {
        /// A number describing the error programmatically.
        public let errorCode: String?
        /// An optional field to provide more details about the error.
        public let errorString: String?

        public init(errorCode: String? = nil, errorString: String? = nil) {
            self.errorCode = errorCode
            self.errorString = errorString
        }

        private enum CodingKeys: String, CodingKey {
            case errorCode
            case errorString
        }
    }

    public struct Firehose: AWSEncodableShape & AWSDecodableShape {
        /// The Kinesis Data Firehose delivery stream that is the destination for broker logs.
        public let deliveryStream: String?
        /// Specifies whether broker logs get sent to the specified Kinesis Data Firehose delivery stream.
        public let enabled: Bool

        public init(deliveryStream: String? = nil, enabled: Bool) {
            self.deliveryStream = deliveryStream
            self.enabled = enabled
        }

        private enum CodingKeys: String, CodingKey {
            case deliveryStream
            case enabled
        }
    }

    public struct GetBootstrapBrokersRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "clusterArn", location: .uri(locationName: "clusterArn"))
        ]

        public let clusterArn: String

        public init(clusterArn: String) {
            self.clusterArn = clusterArn
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetBootstrapBrokersResponse: AWSDecodableShape {
        /// A string containing one or more hostname:port pairs.
        public let bootstrapBrokerString: String?
        /// A string that contains one or more DNS names (or IP addresses) and SASL IAM port pairs. The following is an example. {
        ///     "BootstrapBrokerStringSaslIam": "b-3.exampleClusterName.abcde.c2.kafka.us-east-1.amazonaws.com:9098,b-1.exampleClusterName.abcde.c2.kafka.us-east-1.amazonaws.com:9098,b-2.exampleClusterName.abcde.c2.kafka.us-east-1.amazonaws.com:9098"
        /// }
        public let bootstrapBrokerStringSaslIam: String?
        /// A string containing one or more DNS names (or IP) and SASL SCRAM port pairs. The following is an example. {
        ///     "BootstrapBrokerStringSaslScram": "b-3.exampleClusterName.abcde.c2.kafka.us-east-1.amazonaws.com:9096,b-1.exampleClusterName.abcde.c2.kafka.us-east-1.amazonaws.com:9096,b-2.exampleClusterName.abcde.c2.kafka.us-east-1.amazonaws.com:9096"
        /// }
        public let bootstrapBrokerStringSaslScram: String?
        /// A string containing one or more DNS names (or IP) and TLS port pairs. The following is an example. {
        ///     "BootstrapBrokerStringTls": "b-3.exampleClusterName.abcde.c2.kafka.us-east-1.amazonaws.com:9094,b-1.exampleClusterName.abcde.c2.kafka.us-east-1.amazonaws.com:9094,b-2.exampleClusterName.abcde.c2.kafka.us-east-1.amazonaws.com:9094"
        /// }
        public let bootstrapBrokerStringTls: String?

        public init(bootstrapBrokerString: String? = nil, bootstrapBrokerStringSaslIam: String? = nil, bootstrapBrokerStringSaslScram: String? = nil, bootstrapBrokerStringTls: String? = nil) {
            self.bootstrapBrokerString = bootstrapBrokerString
            self.bootstrapBrokerStringSaslIam = bootstrapBrokerStringSaslIam
            self.bootstrapBrokerStringSaslScram = bootstrapBrokerStringSaslScram
            self.bootstrapBrokerStringTls = bootstrapBrokerStringTls
        }

        private enum CodingKeys: String, CodingKey {
            case bootstrapBrokerString
            case bootstrapBrokerStringSaslIam
            case bootstrapBrokerStringSaslScram
            case bootstrapBrokerStringTls
        }
    }

    public struct GetCompatibleKafkaVersionsRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "clusterArn", location: .querystring(locationName: "clusterArn"))
        ]

        public let clusterArn: String?

        public init(clusterArn: String? = nil) {
            self.clusterArn = clusterArn
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetCompatibleKafkaVersionsResponse: AWSDecodableShape {
        /// A list of CompatibleKafkaVersion objects.
        public let compatibleKafkaVersions: [CompatibleKafkaVersion]?

        public init(compatibleKafkaVersions: [CompatibleKafkaVersion]? = nil) {
            self.compatibleKafkaVersions = compatibleKafkaVersions
        }

        private enum CodingKeys: String, CodingKey {
            case compatibleKafkaVersions
        }
    }

    public struct Iam: AWSEncodableShape & AWSDecodableShape {
        public let enabled: Bool?

        public init(enabled: Bool? = nil) {
            self.enabled = enabled
        }

        private enum CodingKeys: String, CodingKey {
            case enabled
        }
    }

    public struct JmxExporter: AWSDecodableShape {
        /// Indicates whether you want to enable or disable the JMX Exporter.
        public let enabledInBroker: Bool

        public init(enabledInBroker: Bool) {
            self.enabledInBroker = enabledInBroker
        }

        private enum CodingKeys: String, CodingKey {
            case enabledInBroker
        }
    }

    public struct JmxExporterInfo: AWSEncodableShape {
        /// JMX Exporter being enabled in broker.
        public let enabledInBroker: Bool

        public init(enabledInBroker: Bool) {
            self.enabledInBroker = enabledInBroker
        }

        private enum CodingKeys: String, CodingKey {
            case enabledInBroker
        }
    }

    public struct KafkaVersion: AWSDecodableShape {
        /// The status of the Apache Kafka version.
        public let status: KafkaVersionStatus?
        /// The Kafka version.
        public let version: String?

        public init(status: KafkaVersionStatus? = nil, version: String? = nil) {
            self.status = status
            self.version = version
        }

        private enum CodingKeys: String, CodingKey {
            case status
            case version
        }
    }

    public struct ListClusterOperationsRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "clusterArn", location: .uri(locationName: "clusterArn")),
            AWSMemberEncoding(label: "maxResults", location: .querystring(locationName: "maxResults")),
            AWSMemberEncoding(label: "nextToken", location: .querystring(locationName: "nextToken"))
        ]

        public let clusterArn: String
        public let maxResults: Int?
        public let nextToken: String?

        public init(clusterArn: String, maxResults: Int? = nil, nextToken: String? = nil) {
            self.clusterArn = clusterArn
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListClusterOperationsResponse: AWSDecodableShape {
        /// An array of cluster operation information objects.
        public let clusterOperationInfoList: [ClusterOperationInfo]?
        /// If the response of ListClusterOperations is truncated, it returns a NextToken in the response. This Nexttoken should be sent in the subsequent request to ListClusterOperations.
        public let nextToken: String?

        public init(clusterOperationInfoList: [ClusterOperationInfo]? = nil, nextToken: String? = nil) {
            self.clusterOperationInfoList = clusterOperationInfoList
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case clusterOperationInfoList
            case nextToken
        }
    }

    public struct ListClustersRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "clusterNameFilter", location: .querystring(locationName: "clusterNameFilter")),
            AWSMemberEncoding(label: "maxResults", location: .querystring(locationName: "maxResults")),
            AWSMemberEncoding(label: "nextToken", location: .querystring(locationName: "nextToken"))
        ]

        public let clusterNameFilter: String?
        public let maxResults: Int?
        public let nextToken: String?

        public init(clusterNameFilter: String? = nil, maxResults: Int? = nil, nextToken: String? = nil) {
            self.clusterNameFilter = clusterNameFilter
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListClustersResponse: AWSDecodableShape {
        /// Information on each of the MSK clusters in the response.
        public let clusterInfoList: [ClusterInfo]?
        /// The paginated results marker. When the result of a ListClusters operation is truncated, the call returns NextToken in the response. To get another batch of clusters, provide this token in your next request.
        public let nextToken: String?

        public init(clusterInfoList: [ClusterInfo]? = nil, nextToken: String? = nil) {
            self.clusterInfoList = clusterInfoList
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case clusterInfoList
            case nextToken
        }
    }

    public struct ListConfigurationRevisionsRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "arn", location: .uri(locationName: "arn")),
            AWSMemberEncoding(label: "maxResults", location: .querystring(locationName: "maxResults")),
            AWSMemberEncoding(label: "nextToken", location: .querystring(locationName: "nextToken"))
        ]

        public let arn: String
        public let maxResults: Int?
        public let nextToken: String?

        public init(arn: String, maxResults: Int? = nil, nextToken: String? = nil) {
            self.arn = arn
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListConfigurationRevisionsResponse: AWSDecodableShape {
        /// Paginated results marker.
        public let nextToken: String?
        /// List of ConfigurationRevision objects.
        public let revisions: [ConfigurationRevision]?

        public init(nextToken: String? = nil, revisions: [ConfigurationRevision]? = nil) {
            self.nextToken = nextToken
            self.revisions = revisions
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken
            case revisions
        }
    }

    public struct ListConfigurationsRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "maxResults", location: .querystring(locationName: "maxResults")),
            AWSMemberEncoding(label: "nextToken", location: .querystring(locationName: "nextToken"))
        ]

        public let maxResults: Int?
        public let nextToken: String?

        public init(maxResults: Int? = nil, nextToken: String? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListConfigurationsResponse: AWSDecodableShape {
        /// An array of MSK configurations.
        public let configurations: [Configuration]?
        /// The paginated results marker. When the result of a ListConfigurations operation is truncated, the call returns NextToken in the response. To get another batch of configurations, provide this token in your next request.
        public let nextToken: String?

        public init(configurations: [Configuration]? = nil, nextToken: String? = nil) {
            self.configurations = configurations
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case configurations
            case nextToken
        }
    }

    public struct ListKafkaVersionsRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "maxResults", location: .querystring(locationName: "maxResults")),
            AWSMemberEncoding(label: "nextToken", location: .querystring(locationName: "nextToken"))
        ]

        public let maxResults: Int?
        public let nextToken: String?

        public init(maxResults: Int? = nil, nextToken: String? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListKafkaVersionsResponse: AWSDecodableShape {
        /// An array of Kafka version objects.
        public let kafkaVersions: [KafkaVersion]?
        /// Paginated results marker.
        public let nextToken: String?

        public init(kafkaVersions: [KafkaVersion]? = nil, nextToken: String? = nil) {
            self.kafkaVersions = kafkaVersions
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case kafkaVersions
            case nextToken
        }
    }

    public struct ListNodesRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "clusterArn", location: .uri(locationName: "clusterArn")),
            AWSMemberEncoding(label: "maxResults", location: .querystring(locationName: "maxResults")),
            AWSMemberEncoding(label: "nextToken", location: .querystring(locationName: "nextToken"))
        ]

        public let clusterArn: String
        public let maxResults: Int?
        public let nextToken: String?

        public init(clusterArn: String, maxResults: Int? = nil, nextToken: String? = nil) {
            self.clusterArn = clusterArn
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListNodesResponse: AWSDecodableShape {
        /// The paginated results marker. When the result of a ListNodes operation is truncated, the call returns NextToken in the response. To get another batch of nodes, provide this token in your next request.
        public let nextToken: String?
        /// List containing a NodeInfo object.
        public let nodeInfoList: [NodeInfo]?

        public init(nextToken: String? = nil, nodeInfoList: [NodeInfo]? = nil) {
            self.nextToken = nextToken
            self.nodeInfoList = nodeInfoList
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken
            case nodeInfoList
        }
    }

    public struct ListScramSecretsRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "clusterArn", location: .uri(locationName: "clusterArn")),
            AWSMemberEncoding(label: "maxResults", location: .querystring(locationName: "maxResults")),
            AWSMemberEncoding(label: "nextToken", location: .querystring(locationName: "nextToken"))
        ]

        public let clusterArn: String
        public let maxResults: Int?
        public let nextToken: String?

        public init(clusterArn: String, maxResults: Int? = nil, nextToken: String? = nil) {
            self.clusterArn = clusterArn
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListScramSecretsResponse: AWSDecodableShape {
        /// Paginated results marker.
        public let nextToken: String?
        /// The list of scram secrets associated with the cluster.
        public let secretArnList: [String]?

        public init(nextToken: String? = nil, secretArnList: [String]? = nil) {
            self.nextToken = nextToken
            self.secretArnList = secretArnList
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken
            case secretArnList
        }
    }

    public struct ListTagsForResourceRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "resourceArn", location: .uri(locationName: "resourceArn"))
        ]

        public let resourceArn: String

        public init(resourceArn: String) {
            self.resourceArn = resourceArn
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListTagsForResourceResponse: AWSDecodableShape {
        /// The key-value pair for the resource tag.
        public let tags: [String: String]?

        public init(tags: [String: String]? = nil) {
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case tags
        }
    }

    public struct LoggingInfo: AWSEncodableShape & AWSDecodableShape {
        /// You can configure your MSK cluster to send broker logs to different destination types. This configuration specifies the details of these destinations.
        public let brokerLogs: BrokerLogs

        public init(brokerLogs: BrokerLogs) {
            self.brokerLogs = brokerLogs
        }

        private enum CodingKeys: String, CodingKey {
            case brokerLogs
        }
    }

    public struct MutableClusterInfo: AWSDecodableShape {
        /// Specifies the size of the EBS volume and the ID of the associated broker.
        public let brokerEBSVolumeInfo: [BrokerEBSVolumeInfo]?
        /// Information about the changes in the configuration of the brokers.
        public let configurationInfo: ConfigurationInfo?
        /// Specifies which Apache Kafka metrics Amazon MSK gathers and sends to Amazon CloudWatch for this cluster.
        public let enhancedMonitoring: EnhancedMonitoring?
        /// The Amazon MSK broker type that you want all of the brokers in this cluster to be.
        public let instanceType: String?
        public let kafkaVersion: String?
        /// LoggingInfo details.
        public let loggingInfo: LoggingInfo?
        ///             The number of broker nodes in the cluster.
        public let numberOfBrokerNodes: Int?
        /// Settings for open monitoring using Prometheus.
        public let openMonitoring: OpenMonitoring?

        public init(brokerEBSVolumeInfo: [BrokerEBSVolumeInfo]? = nil, configurationInfo: ConfigurationInfo? = nil, enhancedMonitoring: EnhancedMonitoring? = nil, instanceType: String? = nil, kafkaVersion: String? = nil, loggingInfo: LoggingInfo? = nil, numberOfBrokerNodes: Int? = nil, openMonitoring: OpenMonitoring? = nil) {
            self.brokerEBSVolumeInfo = brokerEBSVolumeInfo
            self.configurationInfo = configurationInfo
            self.enhancedMonitoring = enhancedMonitoring
            self.instanceType = instanceType
            self.kafkaVersion = kafkaVersion
            self.loggingInfo = loggingInfo
            self.numberOfBrokerNodes = numberOfBrokerNodes
            self.openMonitoring = openMonitoring
        }

        private enum CodingKeys: String, CodingKey {
            case brokerEBSVolumeInfo
            case configurationInfo
            case enhancedMonitoring
            case instanceType
            case kafkaVersion
            case loggingInfo
            case numberOfBrokerNodes
            case openMonitoring
        }
    }

    public struct NodeExporter: AWSDecodableShape {
        /// Indicates whether you want to enable or disable the Node Exporter.
        public let enabledInBroker: Bool

        public init(enabledInBroker: Bool) {
            self.enabledInBroker = enabledInBroker
        }

        private enum CodingKeys: String, CodingKey {
            case enabledInBroker
        }
    }

    public struct NodeExporterInfo: AWSEncodableShape {
        /// Node Exporter being enabled in broker.
        public let enabledInBroker: Bool

        public init(enabledInBroker: Bool) {
            self.enabledInBroker = enabledInBroker
        }

        private enum CodingKeys: String, CodingKey {
            case enabledInBroker
        }
    }

    public struct NodeInfo: AWSDecodableShape {
        /// The start time.
        public let addedToClusterTime: String?
        /// The broker node info.
        public let brokerNodeInfo: BrokerNodeInfo?
        /// The instance type.
        public let instanceType: String?
        /// The Amazon Resource Name (ARN) of the node.
        public let nodeARN: String?
        /// The node type.
        public let nodeType: NodeType?
        /// The ZookeeperNodeInfo.
        public let zookeeperNodeInfo: ZookeeperNodeInfo?

        public init(addedToClusterTime: String? = nil, brokerNodeInfo: BrokerNodeInfo? = nil, instanceType: String? = nil, nodeARN: String? = nil, nodeType: NodeType? = nil, zookeeperNodeInfo: ZookeeperNodeInfo? = nil) {
            self.addedToClusterTime = addedToClusterTime
            self.brokerNodeInfo = brokerNodeInfo
            self.instanceType = instanceType
            self.nodeARN = nodeARN
            self.nodeType = nodeType
            self.zookeeperNodeInfo = zookeeperNodeInfo
        }

        private enum CodingKeys: String, CodingKey {
            case addedToClusterTime
            case brokerNodeInfo
            case instanceType
            case nodeARN
            case nodeType
            case zookeeperNodeInfo
        }
    }

    public struct OpenMonitoring: AWSDecodableShape {
        /// Prometheus settings.
        public let prometheus: Prometheus

        public init(prometheus: Prometheus) {
            self.prometheus = prometheus
        }

        private enum CodingKeys: String, CodingKey {
            case prometheus
        }
    }

    public struct OpenMonitoringInfo: AWSEncodableShape {
        /// Prometheus settings.
        public let prometheus: PrometheusInfo

        public init(prometheus: PrometheusInfo) {
            self.prometheus = prometheus
        }

        private enum CodingKeys: String, CodingKey {
            case prometheus
        }
    }

    public struct Prometheus: AWSDecodableShape {
        /// Indicates whether you want to enable or disable the JMX Exporter.
        public let jmxExporter: JmxExporter?
        /// Indicates whether you want to enable or disable the Node Exporter.
        public let nodeExporter: NodeExporter?

        public init(jmxExporter: JmxExporter? = nil, nodeExporter: NodeExporter? = nil) {
            self.jmxExporter = jmxExporter
            self.nodeExporter = nodeExporter
        }

        private enum CodingKeys: String, CodingKey {
            case jmxExporter
            case nodeExporter
        }
    }

    public struct PrometheusInfo: AWSEncodableShape {
        /// JMX Exporter settings.
        public let jmxExporter: JmxExporterInfo?
        /// Node Exporter settings.
        public let nodeExporter: NodeExporterInfo?

        public init(jmxExporter: JmxExporterInfo? = nil, nodeExporter: NodeExporterInfo? = nil) {
            self.jmxExporter = jmxExporter
            self.nodeExporter = nodeExporter
        }

        private enum CodingKeys: String, CodingKey {
            case jmxExporter
            case nodeExporter
        }
    }

    public struct RebootBrokerRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "clusterArn", location: .uri(locationName: "clusterArn"))
        ]

        /// The list of broker ids to be rebooted.
        public let brokerIds: [String]
        public let clusterArn: String

        public init(brokerIds: [String], clusterArn: String) {
            self.brokerIds = brokerIds
            self.clusterArn = clusterArn
        }

        private enum CodingKeys: String, CodingKey {
            case brokerIds
        }
    }

    public struct RebootBrokerResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the cluster.
        public let clusterArn: String?
        /// The Amazon Resource Name (ARN) of the cluster operation.
        public let clusterOperationArn: String?

        public init(clusterArn: String? = nil, clusterOperationArn: String? = nil) {
            self.clusterArn = clusterArn
            self.clusterOperationArn = clusterOperationArn
        }

        private enum CodingKeys: String, CodingKey {
            case clusterArn
            case clusterOperationArn
        }
    }

    public struct S3: AWSEncodableShape & AWSDecodableShape {
        /// The name of the S3 bucket that is the destination for broker logs.
        public let bucket: String?
        /// Specifies whether broker logs get sent to the specified Amazon S3 destination.
        public let enabled: Bool
        /// The S3 prefix that is the destination for broker logs.
        public let prefix: String?

        public init(bucket: String? = nil, enabled: Bool, prefix: String? = nil) {
            self.bucket = bucket
            self.enabled = enabled
            self.prefix = prefix
        }

        private enum CodingKeys: String, CodingKey {
            case bucket
            case enabled
            case prefix
        }
    }

    public struct Sasl: AWSEncodableShape & AWSDecodableShape {
        public let iam: Iam?
        public let scram: Scram?

        public init(iam: Iam? = nil, scram: Scram? = nil) {
            self.iam = iam
            self.scram = scram
        }

        private enum CodingKeys: String, CodingKey {
            case iam
            case scram
        }
    }

    public struct Scram: AWSEncodableShape & AWSDecodableShape {
        public let enabled: Bool?

        public init(enabled: Bool? = nil) {
            self.enabled = enabled
        }

        private enum CodingKeys: String, CodingKey {
            case enabled
        }
    }

    public struct StorageInfo: AWSEncodableShape & AWSDecodableShape {
        /// EBS volume information.
        public let ebsStorageInfo: EBSStorageInfo?

        public init(ebsStorageInfo: EBSStorageInfo? = nil) {
            self.ebsStorageInfo = ebsStorageInfo
        }

        public func validate(name: String) throws {
            try self.ebsStorageInfo?.validate(name: "\(name).ebsStorageInfo")
        }

        private enum CodingKeys: String, CodingKey {
            case ebsStorageInfo
        }
    }

    public struct TagResourceRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "resourceArn", location: .uri(locationName: "resourceArn"))
        ]

        public let resourceArn: String
        /// The key-value pair for the resource tag.
        public let tags: [String: String]

        public init(resourceArn: String, tags: [String: String]) {
            self.resourceArn = resourceArn
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case tags
        }
    }

    public struct Tls: AWSEncodableShape & AWSDecodableShape {
        /// List of ACM Certificate Authority ARNs.
        public let certificateAuthorityArnList: [String]?

        public init(certificateAuthorityArnList: [String]? = nil) {
            self.certificateAuthorityArnList = certificateAuthorityArnList
        }

        private enum CodingKeys: String, CodingKey {
            case certificateAuthorityArnList
        }
    }

    public struct UnprocessedScramSecret: AWSDecodableShape {
        public let errorCode: String?
        public let errorMessage: String?
        public let secretArn: String?

        public init(errorCode: String? = nil, errorMessage: String? = nil, secretArn: String? = nil) {
            self.errorCode = errorCode
            self.errorMessage = errorMessage
            self.secretArn = secretArn
        }

        private enum CodingKeys: String, CodingKey {
            case errorCode
            case errorMessage
            case secretArn
        }
    }

    public struct UntagResourceRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "resourceArn", location: .uri(locationName: "resourceArn")),
            AWSMemberEncoding(label: "tagKeys", location: .querystring(locationName: "tagKeys"))
        ]

        public let resourceArn: String
        public let tagKeys: [String]

        public init(resourceArn: String, tagKeys: [String]) {
            self.resourceArn = resourceArn
            self.tagKeys = tagKeys
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct UpdateBrokerCountRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "clusterArn", location: .uri(locationName: "clusterArn"))
        ]

        public let clusterArn: String
        /// The current version of the cluster.
        public let currentVersion: String
        /// The number of broker nodes that you want the cluster to have after this operation completes successfully.
        public let targetNumberOfBrokerNodes: Int

        public init(clusterArn: String, currentVersion: String, targetNumberOfBrokerNodes: Int) {
            self.clusterArn = clusterArn
            self.currentVersion = currentVersion
            self.targetNumberOfBrokerNodes = targetNumberOfBrokerNodes
        }

        public func validate(name: String) throws {
            try self.validate(self.targetNumberOfBrokerNodes, name: "targetNumberOfBrokerNodes", parent: name, max: 15)
            try self.validate(self.targetNumberOfBrokerNodes, name: "targetNumberOfBrokerNodes", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case currentVersion
            case targetNumberOfBrokerNodes
        }
    }

    public struct UpdateBrokerCountResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the cluster.
        public let clusterArn: String?
        /// The Amazon Resource Name (ARN) of the cluster operation.
        public let clusterOperationArn: String?

        public init(clusterArn: String? = nil, clusterOperationArn: String? = nil) {
            self.clusterArn = clusterArn
            self.clusterOperationArn = clusterOperationArn
        }

        private enum CodingKeys: String, CodingKey {
            case clusterArn
            case clusterOperationArn
        }
    }

    public struct UpdateBrokerStorageRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "clusterArn", location: .uri(locationName: "clusterArn"))
        ]

        public let clusterArn: String
        /// The version of cluster to update from. A successful operation will then generate a new version.
        public let currentVersion: String
        /// Describes the target volume size and the ID of the broker to apply the update to. The value you specify for Target-Volume-in-GiB must be a whole number that is greater than 100 GiB. The storage per broker after the update operation can't exceed 16384 GiB.
        public let targetBrokerEBSVolumeInfo: [BrokerEBSVolumeInfo]

        public init(clusterArn: String, currentVersion: String, targetBrokerEBSVolumeInfo: [BrokerEBSVolumeInfo]) {
            self.clusterArn = clusterArn
            self.currentVersion = currentVersion
            self.targetBrokerEBSVolumeInfo = targetBrokerEBSVolumeInfo
        }

        private enum CodingKeys: String, CodingKey {
            case currentVersion
            case targetBrokerEBSVolumeInfo
        }
    }

    public struct UpdateBrokerStorageResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the cluster.
        public let clusterArn: String?
        /// The Amazon Resource Name (ARN) of the cluster operation.
        public let clusterOperationArn: String?

        public init(clusterArn: String? = nil, clusterOperationArn: String? = nil) {
            self.clusterArn = clusterArn
            self.clusterOperationArn = clusterOperationArn
        }

        private enum CodingKeys: String, CodingKey {
            case clusterArn
            case clusterOperationArn
        }
    }

    public struct UpdateBrokerTypeRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "clusterArn", location: .uri(locationName: "clusterArn"))
        ]

        public let clusterArn: String
        /// The current version of the cluster.
        public let currentVersion: String
        /// The Amazon MSK broker type that you want all of the brokers in this cluster to be.
        public let targetInstanceType: String

        public init(clusterArn: String, currentVersion: String, targetInstanceType: String) {
            self.clusterArn = clusterArn
            self.currentVersion = currentVersion
            self.targetInstanceType = targetInstanceType
        }

        private enum CodingKeys: String, CodingKey {
            case currentVersion
            case targetInstanceType
        }
    }

    public struct UpdateBrokerTypeResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the cluster.
        public let clusterArn: String?
        /// The Amazon Resource Name (ARN) of the cluster operation.
        public let clusterOperationArn: String?

        public init(clusterArn: String? = nil, clusterOperationArn: String? = nil) {
            self.clusterArn = clusterArn
            self.clusterOperationArn = clusterOperationArn
        }

        private enum CodingKeys: String, CodingKey {
            case clusterArn
            case clusterOperationArn
        }
    }

    public struct UpdateClusterConfigurationRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "clusterArn", location: .uri(locationName: "clusterArn"))
        ]

        public let clusterArn: String
        /// Represents the configuration that you want MSK to use for the cluster.
        public let configurationInfo: ConfigurationInfo
        /// The version of the cluster that you want to update.
        public let currentVersion: String

        public init(clusterArn: String, configurationInfo: ConfigurationInfo, currentVersion: String) {
            self.clusterArn = clusterArn
            self.configurationInfo = configurationInfo
            self.currentVersion = currentVersion
        }

        private enum CodingKeys: String, CodingKey {
            case configurationInfo
            case currentVersion
        }
    }

    public struct UpdateClusterConfigurationResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the cluster.
        public let clusterArn: String?
        /// The Amazon Resource Name (ARN) of the cluster operation.
        public let clusterOperationArn: String?

        public init(clusterArn: String? = nil, clusterOperationArn: String? = nil) {
            self.clusterArn = clusterArn
            self.clusterOperationArn = clusterOperationArn
        }

        private enum CodingKeys: String, CodingKey {
            case clusterArn
            case clusterOperationArn
        }
    }

    public struct UpdateClusterKafkaVersionRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "clusterArn", location: .uri(locationName: "clusterArn"))
        ]

        public let clusterArn: String
        public let configurationInfo: ConfigurationInfo?
        /// Current cluster version.
        public let currentVersion: String
        /// Target Kafka version.
        public let targetKafkaVersion: String

        public init(clusterArn: String, configurationInfo: ConfigurationInfo? = nil, currentVersion: String, targetKafkaVersion: String) {
            self.clusterArn = clusterArn
            self.configurationInfo = configurationInfo
            self.currentVersion = currentVersion
            self.targetKafkaVersion = targetKafkaVersion
        }

        private enum CodingKeys: String, CodingKey {
            case configurationInfo
            case currentVersion
            case targetKafkaVersion
        }
    }

    public struct UpdateClusterKafkaVersionResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the cluster.
        public let clusterArn: String?
        /// The Amazon Resource Name (ARN) of the cluster operation.
        public let clusterOperationArn: String?

        public init(clusterArn: String? = nil, clusterOperationArn: String? = nil) {
            self.clusterArn = clusterArn
            self.clusterOperationArn = clusterOperationArn
        }

        private enum CodingKeys: String, CodingKey {
            case clusterArn
            case clusterOperationArn
        }
    }

    public struct UpdateConfigurationRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "arn", location: .uri(locationName: "arn"))
        ]

        /// The Amazon Resource Name (ARN) of the configuration.
        public let arn: String
        /// The description of the configuration.
        public let description: String?
        public let serverProperties: Data

        public init(arn: String, description: String? = nil, serverProperties: Data) {
            self.arn = arn
            self.description = description
            self.serverProperties = serverProperties
        }

        private enum CodingKeys: String, CodingKey {
            case description
            case serverProperties
        }
    }

    public struct UpdateConfigurationResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the configuration.
        public let arn: String?
        /// Latest revision of the configuration.
        public let latestRevision: ConfigurationRevision?

        public init(arn: String? = nil, latestRevision: ConfigurationRevision? = nil) {
            self.arn = arn
            self.latestRevision = latestRevision
        }

        private enum CodingKeys: String, CodingKey {
            case arn
            case latestRevision
        }
    }

    public struct UpdateMonitoringRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "clusterArn", location: .uri(locationName: "clusterArn"))
        ]

        public let clusterArn: String
        /// The version of cluster to update from. A successful operation will then generate a new version.
        public let currentVersion: String
        /// Specifies which Apache Kafka metrics Amazon MSK gathers and sends to Amazon CloudWatch for this cluster.
        public let enhancedMonitoring: EnhancedMonitoring?
        /// LoggingInfo details.
        public let loggingInfo: LoggingInfo?
        /// The settings for open monitoring.
        public let openMonitoring: OpenMonitoringInfo?

        public init(clusterArn: String, currentVersion: String, enhancedMonitoring: EnhancedMonitoring? = nil, loggingInfo: LoggingInfo? = nil, openMonitoring: OpenMonitoringInfo? = nil) {
            self.clusterArn = clusterArn
            self.currentVersion = currentVersion
            self.enhancedMonitoring = enhancedMonitoring
            self.loggingInfo = loggingInfo
            self.openMonitoring = openMonitoring
        }

        private enum CodingKeys: String, CodingKey {
            case currentVersion
            case enhancedMonitoring
            case loggingInfo
            case openMonitoring
        }
    }

    public struct UpdateMonitoringResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the cluster.
        public let clusterArn: String?
        /// The Amazon Resource Name (ARN) of the cluster operation.
        public let clusterOperationArn: String?

        public init(clusterArn: String? = nil, clusterOperationArn: String? = nil) {
            self.clusterArn = clusterArn
            self.clusterOperationArn = clusterOperationArn
        }

        private enum CodingKeys: String, CodingKey {
            case clusterArn
            case clusterOperationArn
        }
    }

    public struct ZookeeperNodeInfo: AWSDecodableShape {
        /// The attached elastic network interface of the broker.
        public let attachedENIId: String?
        /// The virtual private cloud (VPC) IP address of the client.
        public let clientVpcIpAddress: String?
        /// Endpoints for accessing the ZooKeeper.
        public let endpoints: [String]?
        /// The role-specific ID for Zookeeper.
        public let zookeeperId: Double?
        /// The version of Zookeeper.
        public let zookeeperVersion: String?

        public init(attachedENIId: String? = nil, clientVpcIpAddress: String? = nil, endpoints: [String]? = nil, zookeeperId: Double? = nil, zookeeperVersion: String? = nil) {
            self.attachedENIId = attachedENIId
            self.clientVpcIpAddress = clientVpcIpAddress
            self.endpoints = endpoints
            self.zookeeperId = zookeeperId
            self.zookeeperVersion = zookeeperVersion
        }

        private enum CodingKeys: String, CodingKey {
            case attachedENIId
            case clientVpcIpAddress
            case endpoints
            case zookeeperId
            case zookeeperVersion
        }
    }
}
