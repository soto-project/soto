//===----------------------------------------------------------------------===//
//
// This source file is part of the Soto for AWS open source project
//
// Copyright (c) 2017-2023 the Soto project authors
// Licensed under Apache License v2.0
//
// See LICENSE.txt for license information
// See CONTRIBUTORS.txt for the list of Soto project authors
//
// SPDX-License-Identifier: Apache-2.0
//
//===----------------------------------------------------------------------===//

// THIS FILE IS AUTOMATICALLY GENERATED by https://github.com/soto-project/soto-codegenerator.
// DO NOT EDIT.

@_exported import SotoCore

/// Service object for interacting with AWS DatabaseMigrationService service.
///
/// Database Migration Service Database Migration Service (DMS) can migrate your data to and from the most widely used commercial and open-source databases such as Oracle, PostgreSQL, Microsoft SQL Server, Amazon Redshift, MariaDB, Amazon Aurora, MySQL, and SAP Adaptive Server Enterprise (ASE). The service supports homogeneous migrations such as Oracle to Oracle, as well as heterogeneous migrations between different database platforms, such as Oracle to MySQL or SQL Server to PostgreSQL. For more information about DMS, see What Is Database Migration Service? in the Database Migration Service User Guide.
public struct DatabaseMigrationService: AWSService {
    // MARK: Member variables

    /// Client used for communication with AWS
    public let client: AWSClient
    /// Service configuration
    public let config: AWSServiceConfig

    // MARK: Initialization

    /// Initialize the DatabaseMigrationService client
    /// - parameters:
    ///     - client: AWSClient used to process requests
    ///     - region: Region of server you want to communicate with. This will override the partition parameter.
    ///     - partition: AWS partition where service resides, standard (.aws), china (.awscn), government (.awsusgov).
    ///     - endpoint: Custom endpoint URL to use instead of standard AWS servers
    ///     - middleware: Middleware chain used to edit requests before they are sent and responses before they are decoded 
    ///     - timeout: Timeout value for HTTP requests
    ///     - byteBufferAllocator: Allocator for ByteBuffers
    ///     - options: Service options
    public init(
        client: AWSClient,
        region: SotoCore.Region? = nil,
        partition: AWSPartition = .aws,
        endpoint: String? = nil,
        middleware: AWSMiddlewareProtocol? = nil,
        timeout: TimeAmount? = nil,
        byteBufferAllocator: ByteBufferAllocator = ByteBufferAllocator(),
        options: AWSServiceConfig.Options = []
    ) {
        self.client = client
        self.config = AWSServiceConfig(
            region: region,
            partition: region?.partition ?? partition,
            amzTarget: "AmazonDMSv20160101",
            serviceName: "DatabaseMigrationService",
            serviceIdentifier: "dms",
            serviceProtocol: .json(version: "1.1"),
            apiVersion: "2016-01-01",
            endpoint: endpoint,
            variantEndpoints: Self.variantEndpoints,
            errorType: DatabaseMigrationServiceErrorType.self,
            xmlNamespace: "http://dms.amazonaws.com/doc/2016-01-01/",
            middleware: middleware,
            timeout: timeout,
            byteBufferAllocator: byteBufferAllocator,
            options: options
        )
    }




    /// FIPS and dualstack endpoints
    static var variantEndpoints: [EndpointVariantType: AWSServiceConfig.EndpointVariant] {[
        [.fips]: .init(endpoints: [
            "us-east-1": "dms-fips.us-east-1.amazonaws.com",
            "us-east-2": "dms-fips.us-east-2.amazonaws.com",
            "us-gov-east-1": "dms.us-gov-east-1.amazonaws.com",
            "us-gov-west-1": "dms.us-gov-west-1.amazonaws.com",
            "us-iso-east-1": "dms.us-iso-east-1.c2s.ic.gov",
            "us-iso-west-1": "dms.us-iso-west-1.c2s.ic.gov",
            "us-isob-east-1": "dms.us-isob-east-1.sc2s.sgov.gov",
            "us-west-1": "dms-fips.us-west-1.amazonaws.com",
            "us-west-2": "dms-fips.us-west-2.amazonaws.com"
        ])
    ]}

    // MARK: API Calls

    /// Adds metadata tags to an DMS resource, including replication instance, endpoint, subnet group, and migration task. These tags can also be used with cost allocation reporting to track cost associated with DMS resources, or used in a Condition statement in an IAM policy for DMS. For more information, see  Tag data type description.
    @Sendable
    public func addTagsToResource(_ input: AddTagsToResourceMessage, logger: Logger = AWSClient.loggingDisabled) async throws -> AddTagsToResourceResponse {
        return try await self.client.execute(
            operation: "AddTagsToResource", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }

    /// Applies a pending maintenance action to a resource (for example, to a replication instance).
    @Sendable
    public func applyPendingMaintenanceAction(_ input: ApplyPendingMaintenanceActionMessage, logger: Logger = AWSClient.loggingDisabled) async throws -> ApplyPendingMaintenanceActionResponse {
        return try await self.client.execute(
            operation: "ApplyPendingMaintenanceAction", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }

    /// Starts the analysis of up to 20 source databases to recommend target engines for each source database. This is a batch version of StartRecommendations. The result of analysis of each source database is reported individually in the response. Because the batch request can result in a combination of successful and unsuccessful actions, you should check for batch errors even when the call returns an HTTP status code of 200.
    @Sendable
    public func batchStartRecommendations(_ input: BatchStartRecommendationsRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> BatchStartRecommendationsResponse {
        return try await self.client.execute(
            operation: "BatchStartRecommendations", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }

    /// Cancels a single premigration assessment run. This operation prevents any individual assessments from running if they haven't started running. It also attempts to cancel any individual assessments that are currently running.
    @Sendable
    public func cancelReplicationTaskAssessmentRun(_ input: CancelReplicationTaskAssessmentRunMessage, logger: Logger = AWSClient.loggingDisabled) async throws -> CancelReplicationTaskAssessmentRunResponse {
        return try await self.client.execute(
            operation: "CancelReplicationTaskAssessmentRun", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }

    /// Creates a data provider using the provided settings. A data provider stores  a data store type and location information about your database.
    @Sendable
    public func createDataProvider(_ input: CreateDataProviderMessage, logger: Logger = AWSClient.loggingDisabled) async throws -> CreateDataProviderResponse {
        return try await self.client.execute(
            operation: "CreateDataProvider", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }

    /// Creates an endpoint using the provided settings.  For a MySQL source or target endpoint, don't explicitly specify the database using the DatabaseName request parameter on the CreateEndpoint API call. Specifying DatabaseName when you create a MySQL endpoint replicates all the task tables to this single database. For MySQL endpoints, you specify the database only when you specify the schema in the table-mapping rules of the DMS task.
    @Sendable
    public func createEndpoint(_ input: CreateEndpointMessage, logger: Logger = AWSClient.loggingDisabled) async throws -> CreateEndpointResponse {
        return try await self.client.execute(
            operation: "CreateEndpoint", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }

    ///  Creates an DMS event notification subscription.  You can specify the type of source (SourceType) you want to be notified of, provide a list of DMS source IDs (SourceIds) that triggers the events, and provide a list of event categories (EventCategories) for events you want to be notified of. If you specify both the SourceType and SourceIds, such as SourceType = replication-instance and SourceIdentifier = my-replinstance, you will be notified of all the replication instance events for the specified source. If you specify a SourceType but don't specify a SourceIdentifier, you receive notice of the events for that source type for all your DMS sources. If you don't specify either SourceType nor SourceIdentifier, you will be notified of events generated from all DMS sources belonging to your customer account. For more information about DMS events, see Working with Events and Notifications in the Database Migration Service User Guide.
    @Sendable
    public func createEventSubscription(_ input: CreateEventSubscriptionMessage, logger: Logger = AWSClient.loggingDisabled) async throws -> CreateEventSubscriptionResponse {
        return try await self.client.execute(
            operation: "CreateEventSubscription", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }

    /// Creates a Fleet Advisor collector using the specified parameters.
    @Sendable
    public func createFleetAdvisorCollector(_ input: CreateFleetAdvisorCollectorRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> CreateFleetAdvisorCollectorResponse {
        return try await self.client.execute(
            operation: "CreateFleetAdvisorCollector", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }

    /// Creates the instance profile using the specified parameters.
    @Sendable
    public func createInstanceProfile(_ input: CreateInstanceProfileMessage, logger: Logger = AWSClient.loggingDisabled) async throws -> CreateInstanceProfileResponse {
        return try await self.client.execute(
            operation: "CreateInstanceProfile", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }

    /// Creates the migration project using the specified parameters. You can run this action only after you create an instance profile and data providers   using CreateInstanceProfile and CreateDataProvider.
    @Sendable
    public func createMigrationProject(_ input: CreateMigrationProjectMessage, logger: Logger = AWSClient.loggingDisabled) async throws -> CreateMigrationProjectResponse {
        return try await self.client.execute(
            operation: "CreateMigrationProject", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }

    /// Creates a configuration that you can later provide to configure and start an DMS Serverless replication. You can also provide options to validate the configuration inputs before you start the replication.
    @Sendable
    public func createReplicationConfig(_ input: CreateReplicationConfigMessage, logger: Logger = AWSClient.loggingDisabled) async throws -> CreateReplicationConfigResponse {
        return try await self.client.execute(
            operation: "CreateReplicationConfig", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }

    /// Creates the replication instance using the specified parameters. DMS requires that your account have certain roles with appropriate permissions before you can create a replication instance. For information on the required roles, see Creating the IAM Roles to Use With the CLI and DMS API. For information on the required permissions, see  IAM Permissions Needed to Use DMS.  If you don't specify a version when creating a replication instance, DMS will create the instance using the default engine version. For information about the default engine version, see Release Notes.
    @Sendable
    public func createReplicationInstance(_ input: CreateReplicationInstanceMessage, logger: Logger = AWSClient.loggingDisabled) async throws -> CreateReplicationInstanceResponse {
        return try await self.client.execute(
            operation: "CreateReplicationInstance", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }

    /// Creates a replication subnet group given a list of the subnet IDs in a VPC. The VPC needs to have at least one subnet in at least two availability zones in the Amazon Web Services Region, otherwise the service will throw a ReplicationSubnetGroupDoesNotCoverEnoughAZs exception. If a replication subnet group exists in your Amazon Web Services account, the CreateReplicationSubnetGroup action  returns the following error message: The Replication Subnet Group already exists. In this case, delete  the existing replication subnet group. To do so, use the DeleteReplicationSubnetGroup action. Optionally, choose Subnet groups in the DMS console,  then choose your subnet group. Next, choose Delete from Actions.
    @Sendable
    public func createReplicationSubnetGroup(_ input: CreateReplicationSubnetGroupMessage, logger: Logger = AWSClient.loggingDisabled) async throws -> CreateReplicationSubnetGroupResponse {
        return try await self.client.execute(
            operation: "CreateReplicationSubnetGroup", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }

    /// Creates a replication task using the specified parameters.
    @Sendable
    public func createReplicationTask(_ input: CreateReplicationTaskMessage, logger: Logger = AWSClient.loggingDisabled) async throws -> CreateReplicationTaskResponse {
        return try await self.client.execute(
            operation: "CreateReplicationTask", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }

    /// Deletes the specified certificate.
    @Sendable
    public func deleteCertificate(_ input: DeleteCertificateMessage, logger: Logger = AWSClient.loggingDisabled) async throws -> DeleteCertificateResponse {
        return try await self.client.execute(
            operation: "DeleteCertificate", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }

    /// Deletes the connection between a replication instance and an endpoint.
    @Sendable
    public func deleteConnection(_ input: DeleteConnectionMessage, logger: Logger = AWSClient.loggingDisabled) async throws -> DeleteConnectionResponse {
        return try await self.client.execute(
            operation: "DeleteConnection", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }

    /// Deletes the specified data provider.  All migration projects associated with the data provider must be deleted or modified  before you can delete the data provider.
    @Sendable
    public func deleteDataProvider(_ input: DeleteDataProviderMessage, logger: Logger = AWSClient.loggingDisabled) async throws -> DeleteDataProviderResponse {
        return try await self.client.execute(
            operation: "DeleteDataProvider", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }

    /// Deletes the specified endpoint.  All tasks associated with the endpoint must be deleted before you can delete the endpoint.
    @Sendable
    public func deleteEndpoint(_ input: DeleteEndpointMessage, logger: Logger = AWSClient.loggingDisabled) async throws -> DeleteEndpointResponse {
        return try await self.client.execute(
            operation: "DeleteEndpoint", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }

    ///  Deletes an DMS event subscription.
    @Sendable
    public func deleteEventSubscription(_ input: DeleteEventSubscriptionMessage, logger: Logger = AWSClient.loggingDisabled) async throws -> DeleteEventSubscriptionResponse {
        return try await self.client.execute(
            operation: "DeleteEventSubscription", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }

    /// Deletes the specified Fleet Advisor collector.
    @Sendable
    public func deleteFleetAdvisorCollector(_ input: DeleteCollectorRequest, logger: Logger = AWSClient.loggingDisabled) async throws {
        return try await self.client.execute(
            operation: "DeleteFleetAdvisorCollector", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }

    /// Deletes the specified Fleet Advisor collector databases.
    @Sendable
    public func deleteFleetAdvisorDatabases(_ input: DeleteFleetAdvisorDatabasesRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> DeleteFleetAdvisorDatabasesResponse {
        return try await self.client.execute(
            operation: "DeleteFleetAdvisorDatabases", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }

    /// Deletes the specified instance profile.  All migration projects associated with the instance profile must be deleted or modified  before you can delete the instance profile.
    @Sendable
    public func deleteInstanceProfile(_ input: DeleteInstanceProfileMessage, logger: Logger = AWSClient.loggingDisabled) async throws -> DeleteInstanceProfileResponse {
        return try await self.client.execute(
            operation: "DeleteInstanceProfile", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }

    /// Deletes the specified migration project.  The migration project must be closed before you can delete it.
    @Sendable
    public func deleteMigrationProject(_ input: DeleteMigrationProjectMessage, logger: Logger = AWSClient.loggingDisabled) async throws -> DeleteMigrationProjectResponse {
        return try await self.client.execute(
            operation: "DeleteMigrationProject", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }

    /// Deletes an DMS Serverless replication configuration. This effectively deprovisions any and all replications that use this configuration. You can't delete the configuration for an DMS Serverless replication that is ongoing. You can delete the configuration when the replication is in a non-RUNNING and non-STARTING state.
    @Sendable
    public func deleteReplicationConfig(_ input: DeleteReplicationConfigMessage, logger: Logger = AWSClient.loggingDisabled) async throws -> DeleteReplicationConfigResponse {
        return try await self.client.execute(
            operation: "DeleteReplicationConfig", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }

    /// Deletes the specified replication instance.  You must delete any migration tasks that are associated with the replication instance before you can delete it.
    @Sendable
    public func deleteReplicationInstance(_ input: DeleteReplicationInstanceMessage, logger: Logger = AWSClient.loggingDisabled) async throws -> DeleteReplicationInstanceResponse {
        return try await self.client.execute(
            operation: "DeleteReplicationInstance", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }

    /// Deletes a subnet group.
    @Sendable
    public func deleteReplicationSubnetGroup(_ input: DeleteReplicationSubnetGroupMessage, logger: Logger = AWSClient.loggingDisabled) async throws -> DeleteReplicationSubnetGroupResponse {
        return try await self.client.execute(
            operation: "DeleteReplicationSubnetGroup", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }

    /// Deletes the specified replication task.
    @Sendable
    public func deleteReplicationTask(_ input: DeleteReplicationTaskMessage, logger: Logger = AWSClient.loggingDisabled) async throws -> DeleteReplicationTaskResponse {
        return try await self.client.execute(
            operation: "DeleteReplicationTask", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }

    /// Deletes the record of a single premigration assessment run. This operation removes all metadata that DMS maintains about this assessment run. However, the operation leaves untouched all information about this assessment run that is stored in your Amazon S3 bucket.
    @Sendable
    public func deleteReplicationTaskAssessmentRun(_ input: DeleteReplicationTaskAssessmentRunMessage, logger: Logger = AWSClient.loggingDisabled) async throws -> DeleteReplicationTaskAssessmentRunResponse {
        return try await self.client.execute(
            operation: "DeleteReplicationTaskAssessmentRun", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }

    /// Lists all of the DMS attributes for a customer account. These attributes include DMS quotas for the account and a unique account identifier in a particular DMS region. DMS quotas include a list of resource quotas supported by the account, such as the number of replication instances allowed. The description for each resource quota, includes the quota name, current usage toward that quota, and the quota's maximum value. DMS uses the unique account identifier to name each artifact used by DMS in the given region. This command does not take any parameters.
    @Sendable
    public func describeAccountAttributes(_ input: DescribeAccountAttributesMessage, logger: Logger = AWSClient.loggingDisabled) async throws -> DescribeAccountAttributesResponse {
        return try await self.client.execute(
            operation: "DescribeAccountAttributes", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }

    /// Provides a list of individual assessments that you can specify for a new premigration assessment run, given one or more parameters. If you specify an existing migration task, this operation provides the default individual assessments you can specify for that task. Otherwise, the specified parameters model elements of a possible migration task on which to base a premigration assessment run. To use these migration task modeling parameters, you must specify an existing replication instance, a source database engine, a target database engine, and a migration type. This combination of parameters potentially limits the default individual assessments available for an assessment run created for a corresponding migration task. If you specify no parameters, this operation provides a list of all possible individual assessments that you can specify for an assessment run. If you specify any one of the task modeling parameters, you must specify all of them or the operation cannot provide a list of individual assessments. The only parameter that you can specify alone is for an existing migration task. The specified task definition then determines the default list of individual assessments that you can specify in an assessment run for the task.
    @Sendable
    public func describeApplicableIndividualAssessments(_ input: DescribeApplicableIndividualAssessmentsMessage, logger: Logger = AWSClient.loggingDisabled) async throws -> DescribeApplicableIndividualAssessmentsResponse {
        return try await self.client.execute(
            operation: "DescribeApplicableIndividualAssessments", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }

    /// Provides a description of the certificate.
    @Sendable
    public func describeCertificates(_ input: DescribeCertificatesMessage, logger: Logger = AWSClient.loggingDisabled) async throws -> DescribeCertificatesResponse {
        return try await self.client.execute(
            operation: "DescribeCertificates", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }

    /// Describes the status of the connections that have been made between the replication instance and an endpoint. Connections are created when you test an endpoint.
    @Sendable
    public func describeConnections(_ input: DescribeConnectionsMessage, logger: Logger = AWSClient.loggingDisabled) async throws -> DescribeConnectionsResponse {
        return try await self.client.execute(
            operation: "DescribeConnections", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }

    /// Returns configuration parameters for a schema conversion project.
    @Sendable
    public func describeConversionConfiguration(_ input: DescribeConversionConfigurationMessage, logger: Logger = AWSClient.loggingDisabled) async throws -> DescribeConversionConfigurationResponse {
        return try await self.client.execute(
            operation: "DescribeConversionConfiguration", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }

    /// Returns a paginated list of data providers for your account in the current region.
    @Sendable
    public func describeDataProviders(_ input: DescribeDataProvidersMessage, logger: Logger = AWSClient.loggingDisabled) async throws -> DescribeDataProvidersResponse {
        return try await self.client.execute(
            operation: "DescribeDataProviders", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }

    /// Returns information about the possible endpoint settings available  when you create an endpoint for a specific database engine.
    @Sendable
    public func describeEndpointSettings(_ input: DescribeEndpointSettingsMessage, logger: Logger = AWSClient.loggingDisabled) async throws -> DescribeEndpointSettingsResponse {
        return try await self.client.execute(
            operation: "DescribeEndpointSettings", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }

    /// Returns information about the type of endpoints available.
    @Sendable
    public func describeEndpointTypes(_ input: DescribeEndpointTypesMessage, logger: Logger = AWSClient.loggingDisabled) async throws -> DescribeEndpointTypesResponse {
        return try await self.client.execute(
            operation: "DescribeEndpointTypes", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }

    /// Returns information about the endpoints for your account in the current region.
    @Sendable
    public func describeEndpoints(_ input: DescribeEndpointsMessage, logger: Logger = AWSClient.loggingDisabled) async throws -> DescribeEndpointsResponse {
        return try await self.client.execute(
            operation: "DescribeEndpoints", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }

    /// Returns information about the replication instance versions used in the project.
    @Sendable
    public func describeEngineVersions(_ input: DescribeEngineVersionsMessage, logger: Logger = AWSClient.loggingDisabled) async throws -> DescribeEngineVersionsResponse {
        return try await self.client.execute(
            operation: "DescribeEngineVersions", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }

    /// Lists categories for all event source types, or, if specified, for a specified source type. You can see a list of the event categories and source types in Working with Events and Notifications in the Database Migration Service User Guide.
    @Sendable
    public func describeEventCategories(_ input: DescribeEventCategoriesMessage, logger: Logger = AWSClient.loggingDisabled) async throws -> DescribeEventCategoriesResponse {
        return try await self.client.execute(
            operation: "DescribeEventCategories", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }

    /// Lists all the event subscriptions for a customer account. The description of a subscription includes SubscriptionName, SNSTopicARN, CustomerID, SourceType, SourceID, CreationTime, and Status.  If you specify SubscriptionName, this action lists the description for that subscription.
    @Sendable
    public func describeEventSubscriptions(_ input: DescribeEventSubscriptionsMessage, logger: Logger = AWSClient.loggingDisabled) async throws -> DescribeEventSubscriptionsResponse {
        return try await self.client.execute(
            operation: "DescribeEventSubscriptions", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }

    ///  Lists events for a given source identifier and source type. You can also specify a start and end time. For more information on DMS events, see Working with Events and Notifications in the Database Migration Service User Guide.
    @Sendable
    public func describeEvents(_ input: DescribeEventsMessage, logger: Logger = AWSClient.loggingDisabled) async throws -> DescribeEventsResponse {
        return try await self.client.execute(
            operation: "DescribeEvents", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }

    /// Returns a paginated list of extension pack associations for the specified migration project. An extension pack is an add-on module  that emulates functions present in a source database that are required when converting objects  to the target database.
    @Sendable
    public func describeExtensionPackAssociations(_ input: DescribeExtensionPackAssociationsMessage, logger: Logger = AWSClient.loggingDisabled) async throws -> DescribeExtensionPackAssociationsResponse {
        return try await self.client.execute(
            operation: "DescribeExtensionPackAssociations", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }

    /// Returns a list of the Fleet Advisor collectors in your account.
    @Sendable
    public func describeFleetAdvisorCollectors(_ input: DescribeFleetAdvisorCollectorsRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> DescribeFleetAdvisorCollectorsResponse {
        return try await self.client.execute(
            operation: "DescribeFleetAdvisorCollectors", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }

    /// Returns a list of Fleet Advisor databases in your account.
    @Sendable
    public func describeFleetAdvisorDatabases(_ input: DescribeFleetAdvisorDatabasesRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> DescribeFleetAdvisorDatabasesResponse {
        return try await self.client.execute(
            operation: "DescribeFleetAdvisorDatabases", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }

    /// Provides descriptions of large-scale assessment (LSA) analyses produced by your Fleet Advisor collectors.
    @Sendable
    public func describeFleetAdvisorLsaAnalysis(_ input: DescribeFleetAdvisorLsaAnalysisRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> DescribeFleetAdvisorLsaAnalysisResponse {
        return try await self.client.execute(
            operation: "DescribeFleetAdvisorLsaAnalysis", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }

    /// Provides descriptions of the schemas discovered by your Fleet Advisor collectors.
    @Sendable
    public func describeFleetAdvisorSchemaObjectSummary(_ input: DescribeFleetAdvisorSchemaObjectSummaryRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> DescribeFleetAdvisorSchemaObjectSummaryResponse {
        return try await self.client.execute(
            operation: "DescribeFleetAdvisorSchemaObjectSummary", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }

    /// Returns a list of schemas detected by Fleet Advisor Collectors in your account.
    @Sendable
    public func describeFleetAdvisorSchemas(_ input: DescribeFleetAdvisorSchemasRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> DescribeFleetAdvisorSchemasResponse {
        return try await self.client.execute(
            operation: "DescribeFleetAdvisorSchemas", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }

    /// Returns a paginated list of instance profiles for your account in the current region.
    @Sendable
    public func describeInstanceProfiles(_ input: DescribeInstanceProfilesMessage, logger: Logger = AWSClient.loggingDisabled) async throws -> DescribeInstanceProfilesResponse {
        return try await self.client.execute(
            operation: "DescribeInstanceProfiles", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }

    /// Returns a paginated list of metadata model assessments for your account in the current region.
    @Sendable
    public func describeMetadataModelAssessments(_ input: DescribeMetadataModelAssessmentsMessage, logger: Logger = AWSClient.loggingDisabled) async throws -> DescribeMetadataModelAssessmentsResponse {
        return try await self.client.execute(
            operation: "DescribeMetadataModelAssessments", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }

    /// Returns a paginated list of metadata model conversions for a migration project.
    @Sendable
    public func describeMetadataModelConversions(_ input: DescribeMetadataModelConversionsMessage, logger: Logger = AWSClient.loggingDisabled) async throws -> DescribeMetadataModelConversionsResponse {
        return try await self.client.execute(
            operation: "DescribeMetadataModelConversions", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }

    /// Returns a paginated list of metadata model exports.
    @Sendable
    public func describeMetadataModelExportsAsScript(_ input: DescribeMetadataModelExportsAsScriptMessage, logger: Logger = AWSClient.loggingDisabled) async throws -> DescribeMetadataModelExportsAsScriptResponse {
        return try await self.client.execute(
            operation: "DescribeMetadataModelExportsAsScript", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }

    /// Returns a paginated list of metadata model exports.
    @Sendable
    public func describeMetadataModelExportsToTarget(_ input: DescribeMetadataModelExportsToTargetMessage, logger: Logger = AWSClient.loggingDisabled) async throws -> DescribeMetadataModelExportsToTargetResponse {
        return try await self.client.execute(
            operation: "DescribeMetadataModelExportsToTarget", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }

    /// Returns a paginated list of metadata model imports.
    @Sendable
    public func describeMetadataModelImports(_ input: DescribeMetadataModelImportsMessage, logger: Logger = AWSClient.loggingDisabled) async throws -> DescribeMetadataModelImportsResponse {
        return try await self.client.execute(
            operation: "DescribeMetadataModelImports", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }

    /// Returns a paginated list of migration projects for your account in the current region.
    @Sendable
    public func describeMigrationProjects(_ input: DescribeMigrationProjectsMessage, logger: Logger = AWSClient.loggingDisabled) async throws -> DescribeMigrationProjectsResponse {
        return try await self.client.execute(
            operation: "DescribeMigrationProjects", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }

    /// Returns information about the replication instance types that can be created in the specified region.
    @Sendable
    public func describeOrderableReplicationInstances(_ input: DescribeOrderableReplicationInstancesMessage, logger: Logger = AWSClient.loggingDisabled) async throws -> DescribeOrderableReplicationInstancesResponse {
        return try await self.client.execute(
            operation: "DescribeOrderableReplicationInstances", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }

    /// For internal use only
    @Sendable
    public func describePendingMaintenanceActions(_ input: DescribePendingMaintenanceActionsMessage, logger: Logger = AWSClient.loggingDisabled) async throws -> DescribePendingMaintenanceActionsResponse {
        return try await self.client.execute(
            operation: "DescribePendingMaintenanceActions", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }

    /// Returns a paginated list of limitations for recommendations of target Amazon Web Services engines.
    @Sendable
    public func describeRecommendationLimitations(_ input: DescribeRecommendationLimitationsRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> DescribeRecommendationLimitationsResponse {
        return try await self.client.execute(
            operation: "DescribeRecommendationLimitations", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }

    /// Returns a paginated list of target engine recommendations for your source databases.
    @Sendable
    public func describeRecommendations(_ input: DescribeRecommendationsRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> DescribeRecommendationsResponse {
        return try await self.client.execute(
            operation: "DescribeRecommendations", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }

    /// Returns the status of the RefreshSchemas operation.
    @Sendable
    public func describeRefreshSchemasStatus(_ input: DescribeRefreshSchemasStatusMessage, logger: Logger = AWSClient.loggingDisabled) async throws -> DescribeRefreshSchemasStatusResponse {
        return try await self.client.execute(
            operation: "DescribeRefreshSchemasStatus", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }

    /// Returns one or more existing DMS Serverless replication configurations as a list of structures.
    @Sendable
    public func describeReplicationConfigs(_ input: DescribeReplicationConfigsMessage, logger: Logger = AWSClient.loggingDisabled) async throws -> DescribeReplicationConfigsResponse {
        return try await self.client.execute(
            operation: "DescribeReplicationConfigs", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }

    /// Returns information about the task logs for the specified task.
    @Sendable
    public func describeReplicationInstanceTaskLogs(_ input: DescribeReplicationInstanceTaskLogsMessage, logger: Logger = AWSClient.loggingDisabled) async throws -> DescribeReplicationInstanceTaskLogsResponse {
        return try await self.client.execute(
            operation: "DescribeReplicationInstanceTaskLogs", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }

    /// Returns information about replication instances for your account in the current region.
    @Sendable
    public func describeReplicationInstances(_ input: DescribeReplicationInstancesMessage, logger: Logger = AWSClient.loggingDisabled) async throws -> DescribeReplicationInstancesResponse {
        return try await self.client.execute(
            operation: "DescribeReplicationInstances", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }

    /// Returns information about the replication subnet groups.
    @Sendable
    public func describeReplicationSubnetGroups(_ input: DescribeReplicationSubnetGroupsMessage, logger: Logger = AWSClient.loggingDisabled) async throws -> DescribeReplicationSubnetGroupsResponse {
        return try await self.client.execute(
            operation: "DescribeReplicationSubnetGroups", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }

    /// Returns table and schema statistics for one or more provisioned replications that use a given DMS Serverless replication configuration.
    @Sendable
    public func describeReplicationTableStatistics(_ input: DescribeReplicationTableStatisticsMessage, logger: Logger = AWSClient.loggingDisabled) async throws -> DescribeReplicationTableStatisticsResponse {
        return try await self.client.execute(
            operation: "DescribeReplicationTableStatistics", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }

    /// Returns the task assessment results from the Amazon S3 bucket that DMS creates in your Amazon Web Services account.  This action always returns the latest results. For more information about DMS task assessments, see   Creating a task assessment report in the Database Migration Service User Guide.
    @Sendable
    public func describeReplicationTaskAssessmentResults(_ input: DescribeReplicationTaskAssessmentResultsMessage, logger: Logger = AWSClient.loggingDisabled) async throws -> DescribeReplicationTaskAssessmentResultsResponse {
        return try await self.client.execute(
            operation: "DescribeReplicationTaskAssessmentResults", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }

    /// Returns a paginated list of premigration assessment runs based on filter settings. These filter settings can specify a combination of premigration assessment runs, migration tasks, replication instances, and assessment run status values.  This operation doesn't return information about individual assessments. For this information, see the DescribeReplicationTaskIndividualAssessments operation.
    @Sendable
    public func describeReplicationTaskAssessmentRuns(_ input: DescribeReplicationTaskAssessmentRunsMessage, logger: Logger = AWSClient.loggingDisabled) async throws -> DescribeReplicationTaskAssessmentRunsResponse {
        return try await self.client.execute(
            operation: "DescribeReplicationTaskAssessmentRuns", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }

    /// Returns a paginated list of individual assessments based on filter settings. These filter settings can specify a combination of premigration assessment runs, migration tasks, and assessment status values.
    @Sendable
    public func describeReplicationTaskIndividualAssessments(_ input: DescribeReplicationTaskIndividualAssessmentsMessage, logger: Logger = AWSClient.loggingDisabled) async throws -> DescribeReplicationTaskIndividualAssessmentsResponse {
        return try await self.client.execute(
            operation: "DescribeReplicationTaskIndividualAssessments", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }

    /// Returns information about replication tasks for your account in the current region.
    @Sendable
    public func describeReplicationTasks(_ input: DescribeReplicationTasksMessage, logger: Logger = AWSClient.loggingDisabled) async throws -> DescribeReplicationTasksResponse {
        return try await self.client.execute(
            operation: "DescribeReplicationTasks", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }

    /// Provides details on replication progress by returning status information for one or more provisioned DMS Serverless replications.
    @Sendable
    public func describeReplications(_ input: DescribeReplicationsMessage, logger: Logger = AWSClient.loggingDisabled) async throws -> DescribeReplicationsResponse {
        return try await self.client.execute(
            operation: "DescribeReplications", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }

    /// Returns information about the schema for the specified endpoint.
    @Sendable
    public func describeSchemas(_ input: DescribeSchemasMessage, logger: Logger = AWSClient.loggingDisabled) async throws -> DescribeSchemasResponse {
        return try await self.client.execute(
            operation: "DescribeSchemas", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }

    /// Returns table statistics on the database migration task, including table name, rows inserted, rows updated, and rows deleted. Note that the "last updated" column the DMS console only indicates the time that DMS last updated the table statistics record for a table. It does not indicate the time of the last update to the table.
    @Sendable
    public func describeTableStatistics(_ input: DescribeTableStatisticsMessage, logger: Logger = AWSClient.loggingDisabled) async throws -> DescribeTableStatisticsResponse {
        return try await self.client.execute(
            operation: "DescribeTableStatistics", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }

    /// Saves a copy of a database migration assessment report to your Amazon S3 bucket. DMS can save  your assessment report as a comma-separated value (CSV) or a PDF file.
    @Sendable
    public func exportMetadataModelAssessment(_ input: ExportMetadataModelAssessmentMessage, logger: Logger = AWSClient.loggingDisabled) async throws -> ExportMetadataModelAssessmentResponse {
        return try await self.client.execute(
            operation: "ExportMetadataModelAssessment", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }

    /// Uploads the specified certificate.
    @Sendable
    public func importCertificate(_ input: ImportCertificateMessage, logger: Logger = AWSClient.loggingDisabled) async throws -> ImportCertificateResponse {
        return try await self.client.execute(
            operation: "ImportCertificate", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }

    /// Lists all metadata tags attached to an DMS resource, including  replication instance, endpoint, subnet group, and migration task.  For more information, see  Tag data type description.
    @Sendable
    public func listTagsForResource(_ input: ListTagsForResourceMessage, logger: Logger = AWSClient.loggingDisabled) async throws -> ListTagsForResourceResponse {
        return try await self.client.execute(
            operation: "ListTagsForResource", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }

    /// Modifies the specified schema conversion configuration using the provided parameters.
    @Sendable
    public func modifyConversionConfiguration(_ input: ModifyConversionConfigurationMessage, logger: Logger = AWSClient.loggingDisabled) async throws -> ModifyConversionConfigurationResponse {
        return try await self.client.execute(
            operation: "ModifyConversionConfiguration", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }

    /// Modifies the specified data provider using the provided settings.  You must remove the data provider from all migration projects before you can modify it.
    @Sendable
    public func modifyDataProvider(_ input: ModifyDataProviderMessage, logger: Logger = AWSClient.loggingDisabled) async throws -> ModifyDataProviderResponse {
        return try await self.client.execute(
            operation: "ModifyDataProvider", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }

    /// Modifies the specified endpoint.  For a MySQL source or target endpoint, don't explicitly specify the database using the DatabaseName request parameter on the ModifyEndpoint API call. Specifying DatabaseName when you modify a MySQL endpoint replicates all the task tables to this single database. For MySQL endpoints, you specify the database only when you specify the schema in the table-mapping rules of the DMS task.
    @Sendable
    public func modifyEndpoint(_ input: ModifyEndpointMessage, logger: Logger = AWSClient.loggingDisabled) async throws -> ModifyEndpointResponse {
        return try await self.client.execute(
            operation: "ModifyEndpoint", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }

    /// Modifies an existing DMS event notification subscription.
    @Sendable
    public func modifyEventSubscription(_ input: ModifyEventSubscriptionMessage, logger: Logger = AWSClient.loggingDisabled) async throws -> ModifyEventSubscriptionResponse {
        return try await self.client.execute(
            operation: "ModifyEventSubscription", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }

    /// Modifies the specified instance profile using the provided parameters.  All migration projects associated with the instance profile must be deleted  or modified before you can modify the instance profile.
    @Sendable
    public func modifyInstanceProfile(_ input: ModifyInstanceProfileMessage, logger: Logger = AWSClient.loggingDisabled) async throws -> ModifyInstanceProfileResponse {
        return try await self.client.execute(
            operation: "ModifyInstanceProfile", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }

    /// Modifies the specified migration project using the provided parameters.  The migration project must be closed before you can modify it.
    @Sendable
    public func modifyMigrationProject(_ input: ModifyMigrationProjectMessage, logger: Logger = AWSClient.loggingDisabled) async throws -> ModifyMigrationProjectResponse {
        return try await self.client.execute(
            operation: "ModifyMigrationProject", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }

    /// Modifies an existing DMS Serverless replication configuration that you can use to start a replication. This command includes input validation and logic to check the state of any replication that uses this configuration. You can only modify a replication configuration before any replication that uses it has started. As soon as you have initially started a replication with a given configuiration, you can't modify that configuration, even if you stop it. Other run statuses that allow you to run this command include FAILED and CREATED. A provisioning state that allows you to run this command is FAILED_PROVISION.
    @Sendable
    public func modifyReplicationConfig(_ input: ModifyReplicationConfigMessage, logger: Logger = AWSClient.loggingDisabled) async throws -> ModifyReplicationConfigResponse {
        return try await self.client.execute(
            operation: "ModifyReplicationConfig", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }

    /// Modifies the replication instance to apply new settings. You can change one or more parameters by specifying these parameters and the new values in the request. Some settings are applied during the maintenance window.
    @Sendable
    public func modifyReplicationInstance(_ input: ModifyReplicationInstanceMessage, logger: Logger = AWSClient.loggingDisabled) async throws -> ModifyReplicationInstanceResponse {
        return try await self.client.execute(
            operation: "ModifyReplicationInstance", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }

    /// Modifies the settings for the specified replication subnet group.
    @Sendable
    public func modifyReplicationSubnetGroup(_ input: ModifyReplicationSubnetGroupMessage, logger: Logger = AWSClient.loggingDisabled) async throws -> ModifyReplicationSubnetGroupResponse {
        return try await self.client.execute(
            operation: "ModifyReplicationSubnetGroup", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }

    /// Modifies the specified replication task. You can't modify the task endpoints. The task must be stopped before you can modify it.  For more information about DMS tasks, see Working with Migration Tasks in the Database Migration Service User Guide.
    @Sendable
    public func modifyReplicationTask(_ input: ModifyReplicationTaskMessage, logger: Logger = AWSClient.loggingDisabled) async throws -> ModifyReplicationTaskResponse {
        return try await self.client.execute(
            operation: "ModifyReplicationTask", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }

    /// Moves a replication task from its current replication instance to a different target replication instance using the specified parameters. The target replication instance must be created with the same or later DMS version as the current replication instance.
    @Sendable
    public func moveReplicationTask(_ input: MoveReplicationTaskMessage, logger: Logger = AWSClient.loggingDisabled) async throws -> MoveReplicationTaskResponse {
        return try await self.client.execute(
            operation: "MoveReplicationTask", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }

    /// Reboots a replication instance. Rebooting results in a momentary outage, until the replication instance becomes available again.
    @Sendable
    public func rebootReplicationInstance(_ input: RebootReplicationInstanceMessage, logger: Logger = AWSClient.loggingDisabled) async throws -> RebootReplicationInstanceResponse {
        return try await self.client.execute(
            operation: "RebootReplicationInstance", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }

    /// Populates the schema for the specified endpoint. This is an asynchronous operation and can take several minutes. You can check the status of this operation by calling the DescribeRefreshSchemasStatus operation.
    @Sendable
    public func refreshSchemas(_ input: RefreshSchemasMessage, logger: Logger = AWSClient.loggingDisabled) async throws -> RefreshSchemasResponse {
        return try await self.client.execute(
            operation: "RefreshSchemas", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }

    /// Reloads the target database table with the source data for a given DMS Serverless replication configuration. You can only use this operation with a task in the RUNNING state, otherwise the service will throw an InvalidResourceStateFault exception.
    @Sendable
    public func reloadReplicationTables(_ input: ReloadReplicationTablesMessage, logger: Logger = AWSClient.loggingDisabled) async throws -> ReloadReplicationTablesResponse {
        return try await self.client.execute(
            operation: "ReloadReplicationTables", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }

    /// Reloads the target database table with the source data.  You can only use this operation with a task in the RUNNING state, otherwise the service will throw an InvalidResourceStateFault exception.
    @Sendable
    public func reloadTables(_ input: ReloadTablesMessage, logger: Logger = AWSClient.loggingDisabled) async throws -> ReloadTablesResponse {
        return try await self.client.execute(
            operation: "ReloadTables", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }

    /// Removes metadata tags from an DMS resource, including replication instance,  endpoint, subnet group, and migration task. For more information, see   Tag  data type description.
    @Sendable
    public func removeTagsFromResource(_ input: RemoveTagsFromResourceMessage, logger: Logger = AWSClient.loggingDisabled) async throws -> RemoveTagsFromResourceResponse {
        return try await self.client.execute(
            operation: "RemoveTagsFromResource", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }

    /// Runs large-scale assessment (LSA) analysis on every Fleet Advisor collector in your account.
    @Sendable
    public func runFleetAdvisorLsaAnalysis(logger: Logger = AWSClient.loggingDisabled) async throws -> RunFleetAdvisorLsaAnalysisResponse {
        return try await self.client.execute(
            operation: "RunFleetAdvisorLsaAnalysis", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            logger: logger
        )
    }

    /// Applies the extension pack to your target database. An extension pack is an add-on  module that emulates functions present in a source database that are required when  converting objects to the target database.
    @Sendable
    public func startExtensionPackAssociation(_ input: StartExtensionPackAssociationMessage, logger: Logger = AWSClient.loggingDisabled) async throws -> StartExtensionPackAssociationResponse {
        return try await self.client.execute(
            operation: "StartExtensionPackAssociation", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }

    /// Creates a database migration assessment report by assessing the migration complexity for  your source database. A database migration assessment report summarizes all of the schema  conversion tasks. It also details the action items for database objects that can't be converted  to the database engine of your target database instance.
    @Sendable
    public func startMetadataModelAssessment(_ input: StartMetadataModelAssessmentMessage, logger: Logger = AWSClient.loggingDisabled) async throws -> StartMetadataModelAssessmentResponse {
        return try await self.client.execute(
            operation: "StartMetadataModelAssessment", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }

    /// Converts your source database objects to a format compatible with the target database.
    @Sendable
    public func startMetadataModelConversion(_ input: StartMetadataModelConversionMessage, logger: Logger = AWSClient.loggingDisabled) async throws -> StartMetadataModelConversionResponse {
        return try await self.client.execute(
            operation: "StartMetadataModelConversion", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }

    /// Saves your converted code to a file as a SQL script, and stores this file on your Amazon S3 bucket.
    @Sendable
    public func startMetadataModelExportAsScript(_ input: StartMetadataModelExportAsScriptMessage, logger: Logger = AWSClient.loggingDisabled) async throws -> StartMetadataModelExportAsScriptResponse {
        return try await self.client.execute(
            operation: "StartMetadataModelExportAsScript", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }

    /// Applies converted database objects to your target database.
    @Sendable
    public func startMetadataModelExportToTarget(_ input: StartMetadataModelExportToTargetMessage, logger: Logger = AWSClient.loggingDisabled) async throws -> StartMetadataModelExportToTargetResponse {
        return try await self.client.execute(
            operation: "StartMetadataModelExportToTarget", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }

    /// Loads the metadata for all the dependent database objects of the parent object. This operation uses your project's Amazon S3 bucket as a metadata cache to improve performance.
    @Sendable
    public func startMetadataModelImport(_ input: StartMetadataModelImportMessage, logger: Logger = AWSClient.loggingDisabled) async throws -> StartMetadataModelImportResponse {
        return try await self.client.execute(
            operation: "StartMetadataModelImport", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }

    /// Starts the analysis of your source database to provide recommendations of target engines. You can create recommendations for multiple source databases using BatchStartRecommendations.
    @Sendable
    public func startRecommendations(_ input: StartRecommendationsRequest, logger: Logger = AWSClient.loggingDisabled) async throws {
        return try await self.client.execute(
            operation: "StartRecommendations", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }

    /// For a given DMS Serverless replication configuration, DMS connects to the source endpoint and collects the metadata to analyze the replication workload. Using this metadata, DMS then computes and provisions the required capacity and starts replicating to the target endpoint using the server resources that DMS has provisioned for the DMS Serverless replication.
    @Sendable
    public func startReplication(_ input: StartReplicationMessage, logger: Logger = AWSClient.loggingDisabled) async throws -> StartReplicationResponse {
        return try await self.client.execute(
            operation: "StartReplication", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }

    /// Starts the replication task. For more information about DMS tasks, see Working with Migration Tasks  in the Database Migration Service User Guide.
    @Sendable
    public func startReplicationTask(_ input: StartReplicationTaskMessage, logger: Logger = AWSClient.loggingDisabled) async throws -> StartReplicationTaskResponse {
        return try await self.client.execute(
            operation: "StartReplicationTask", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }

    ///  Starts the replication task assessment for unsupported data types in the source database.  You can only use this operation for a task if the following conditions are true:   The task must be in the stopped state.   The task must have successful connections to the source and target.   If either of these conditions are not met, an InvalidResourceStateFault error will result.  For information about DMS task assessments, see  Creating a task assessment report in the Database Migration Service User Guide.
    @Sendable
    public func startReplicationTaskAssessment(_ input: StartReplicationTaskAssessmentMessage, logger: Logger = AWSClient.loggingDisabled) async throws -> StartReplicationTaskAssessmentResponse {
        return try await self.client.execute(
            operation: "StartReplicationTaskAssessment", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }

    /// Starts a new premigration assessment run for one or more individual assessments of a migration task. The assessments that you can specify depend on the source and target database engine and the migration type defined for the given task. To run this operation, your migration task must already be created. After you run this operation, you can review the status of each individual assessment. You can also run the migration task manually after the assessment run and its individual assessments complete.
    @Sendable
    public func startReplicationTaskAssessmentRun(_ input: StartReplicationTaskAssessmentRunMessage, logger: Logger = AWSClient.loggingDisabled) async throws -> StartReplicationTaskAssessmentRunResponse {
        return try await self.client.execute(
            operation: "StartReplicationTaskAssessmentRun", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }

    /// For a given DMS Serverless replication configuration, DMS stops any and all ongoing DMS Serverless replications. This command doesn't deprovision the stopped replications.
    @Sendable
    public func stopReplication(_ input: StopReplicationMessage, logger: Logger = AWSClient.loggingDisabled) async throws -> StopReplicationResponse {
        return try await self.client.execute(
            operation: "StopReplication", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }

    /// Stops the replication task.
    @Sendable
    public func stopReplicationTask(_ input: StopReplicationTaskMessage, logger: Logger = AWSClient.loggingDisabled) async throws -> StopReplicationTaskResponse {
        return try await self.client.execute(
            operation: "StopReplicationTask", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }

    /// Tests the connection between the replication instance and the endpoint.
    @Sendable
    public func testConnection(_ input: TestConnectionMessage, logger: Logger = AWSClient.loggingDisabled) async throws -> TestConnectionResponse {
        return try await self.client.execute(
            operation: "TestConnection", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }

    /// Migrates 10 active and enabled Amazon SNS subscriptions at a time and converts them to corresponding Amazon EventBridge rules. By default, this operation migrates subscriptions only when all your replication instance versions are 3.4.5 or higher. If any replication instances are from versions earlier than 3.4.5, the operation raises an error and tells you to upgrade these instances to version 3.4.5 or higher. To enable migration regardless of version, set the Force option to true. However, if you don't upgrade instances earlier than version 3.4.5, some types of events might not be available when you use Amazon EventBridge. To call this operation, make sure that you have certain permissions added to your user account. For more information, see Migrating event subscriptions to Amazon EventBridge in the Amazon Web Services Database Migration Service User Guide.
    @Sendable
    public func updateSubscriptionsToEventBridge(_ input: UpdateSubscriptionsToEventBridgeMessage, logger: Logger = AWSClient.loggingDisabled) async throws -> UpdateSubscriptionsToEventBridgeResponse {
        return try await self.client.execute(
            operation: "UpdateSubscriptionsToEventBridge", 
            path: "/", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
}

extension DatabaseMigrationService {
    /// Initializer required by `AWSService.with(middlewares:timeout:byteBufferAllocator:options)`. You are not able to use this initializer directly as there are not public
    /// initializers for `AWSServiceConfig.Patch`. Please use `AWSService.with(middlewares:timeout:byteBufferAllocator:options)` instead.
    public init(from: DatabaseMigrationService, patch: AWSServiceConfig.Patch) {
        self.client = from.client
        self.config = from.config.with(patch: patch)
    }
}

// MARK: Paginators

@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension DatabaseMigrationService {
    /// Provides a list of individual assessments that you can specify for a new premigration assessment run, given one or more parameters. If you specify an existing migration task, this operation provides the default individual assessments you can specify for that task. Otherwise, the specified parameters model elements of a possible migration task on which to base a premigration assessment run. To use these migration task modeling parameters, you must specify an existing replication instance, a source database engine, a target database engine, and a migration type. This combination of parameters potentially limits the default individual assessments available for an assessment run created for a corresponding migration task. If you specify no parameters, this operation provides a list of all possible individual assessments that you can specify for an assessment run. If you specify any one of the task modeling parameters, you must specify all of them or the operation cannot provide a list of individual assessments. The only parameter that you can specify alone is for an existing migration task. The specified task definition then determines the default list of individual assessments that you can specify in an assessment run for the task.
    /// Return PaginatorSequence for operation.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - logger: Logger used flot logging
    public func describeApplicableIndividualAssessmentsPaginator(
        _ input: DescribeApplicableIndividualAssessmentsMessage,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<DescribeApplicableIndividualAssessmentsMessage, DescribeApplicableIndividualAssessmentsResponse> {
        return .init(
            input: input,
            command: self.describeApplicableIndividualAssessments,
            inputKey: \DescribeApplicableIndividualAssessmentsMessage.marker,
            outputKey: \DescribeApplicableIndividualAssessmentsResponse.marker,
            logger: logger
        )
    }

    /// Provides a description of the certificate.
    /// Return PaginatorSequence for operation.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - logger: Logger used flot logging
    public func describeCertificatesPaginator(
        _ input: DescribeCertificatesMessage,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<DescribeCertificatesMessage, DescribeCertificatesResponse> {
        return .init(
            input: input,
            command: self.describeCertificates,
            inputKey: \DescribeCertificatesMessage.marker,
            outputKey: \DescribeCertificatesResponse.marker,
            logger: logger
        )
    }

    /// Describes the status of the connections that have been made between the replication instance and an endpoint. Connections are created when you test an endpoint.
    /// Return PaginatorSequence for operation.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - logger: Logger used flot logging
    public func describeConnectionsPaginator(
        _ input: DescribeConnectionsMessage,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<DescribeConnectionsMessage, DescribeConnectionsResponse> {
        return .init(
            input: input,
            command: self.describeConnections,
            inputKey: \DescribeConnectionsMessage.marker,
            outputKey: \DescribeConnectionsResponse.marker,
            logger: logger
        )
    }

    /// Returns a paginated list of data providers for your account in the current region.
    /// Return PaginatorSequence for operation.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - logger: Logger used flot logging
    public func describeDataProvidersPaginator(
        _ input: DescribeDataProvidersMessage,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<DescribeDataProvidersMessage, DescribeDataProvidersResponse> {
        return .init(
            input: input,
            command: self.describeDataProviders,
            inputKey: \DescribeDataProvidersMessage.marker,
            outputKey: \DescribeDataProvidersResponse.marker,
            logger: logger
        )
    }

    /// Returns information about the possible endpoint settings available  when you create an endpoint for a specific database engine.
    /// Return PaginatorSequence for operation.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - logger: Logger used flot logging
    public func describeEndpointSettingsPaginator(
        _ input: DescribeEndpointSettingsMessage,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<DescribeEndpointSettingsMessage, DescribeEndpointSettingsResponse> {
        return .init(
            input: input,
            command: self.describeEndpointSettings,
            inputKey: \DescribeEndpointSettingsMessage.marker,
            outputKey: \DescribeEndpointSettingsResponse.marker,
            logger: logger
        )
    }

    /// Returns information about the type of endpoints available.
    /// Return PaginatorSequence for operation.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - logger: Logger used flot logging
    public func describeEndpointTypesPaginator(
        _ input: DescribeEndpointTypesMessage,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<DescribeEndpointTypesMessage, DescribeEndpointTypesResponse> {
        return .init(
            input: input,
            command: self.describeEndpointTypes,
            inputKey: \DescribeEndpointTypesMessage.marker,
            outputKey: \DescribeEndpointTypesResponse.marker,
            logger: logger
        )
    }

    /// Returns information about the endpoints for your account in the current region.
    /// Return PaginatorSequence for operation.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - logger: Logger used flot logging
    public func describeEndpointsPaginator(
        _ input: DescribeEndpointsMessage,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<DescribeEndpointsMessage, DescribeEndpointsResponse> {
        return .init(
            input: input,
            command: self.describeEndpoints,
            inputKey: \DescribeEndpointsMessage.marker,
            outputKey: \DescribeEndpointsResponse.marker,
            logger: logger
        )
    }

    /// Returns information about the replication instance versions used in the project.
    /// Return PaginatorSequence for operation.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - logger: Logger used flot logging
    public func describeEngineVersionsPaginator(
        _ input: DescribeEngineVersionsMessage,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<DescribeEngineVersionsMessage, DescribeEngineVersionsResponse> {
        return .init(
            input: input,
            command: self.describeEngineVersions,
            inputKey: \DescribeEngineVersionsMessage.marker,
            outputKey: \DescribeEngineVersionsResponse.marker,
            logger: logger
        )
    }

    /// Lists all the event subscriptions for a customer account. The description of a subscription includes SubscriptionName, SNSTopicARN, CustomerID, SourceType, SourceID, CreationTime, and Status.  If you specify SubscriptionName, this action lists the description for that subscription.
    /// Return PaginatorSequence for operation.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - logger: Logger used flot logging
    public func describeEventSubscriptionsPaginator(
        _ input: DescribeEventSubscriptionsMessage,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<DescribeEventSubscriptionsMessage, DescribeEventSubscriptionsResponse> {
        return .init(
            input: input,
            command: self.describeEventSubscriptions,
            inputKey: \DescribeEventSubscriptionsMessage.marker,
            outputKey: \DescribeEventSubscriptionsResponse.marker,
            logger: logger
        )
    }

    ///  Lists events for a given source identifier and source type. You can also specify a start and end time. For more information on DMS events, see Working with Events and Notifications in the Database Migration Service User Guide.
    /// Return PaginatorSequence for operation.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - logger: Logger used flot logging
    public func describeEventsPaginator(
        _ input: DescribeEventsMessage,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<DescribeEventsMessage, DescribeEventsResponse> {
        return .init(
            input: input,
            command: self.describeEvents,
            inputKey: \DescribeEventsMessage.marker,
            outputKey: \DescribeEventsResponse.marker,
            logger: logger
        )
    }

    /// Returns a paginated list of extension pack associations for the specified migration project. An extension pack is an add-on module  that emulates functions present in a source database that are required when converting objects  to the target database.
    /// Return PaginatorSequence for operation.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - logger: Logger used flot logging
    public func describeExtensionPackAssociationsPaginator(
        _ input: DescribeExtensionPackAssociationsMessage,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<DescribeExtensionPackAssociationsMessage, DescribeExtensionPackAssociationsResponse> {
        return .init(
            input: input,
            command: self.describeExtensionPackAssociations,
            inputKey: \DescribeExtensionPackAssociationsMessage.marker,
            outputKey: \DescribeExtensionPackAssociationsResponse.marker,
            logger: logger
        )
    }

    /// Returns a list of the Fleet Advisor collectors in your account.
    /// Return PaginatorSequence for operation.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - logger: Logger used flot logging
    public func describeFleetAdvisorCollectorsPaginator(
        _ input: DescribeFleetAdvisorCollectorsRequest,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<DescribeFleetAdvisorCollectorsRequest, DescribeFleetAdvisorCollectorsResponse> {
        return .init(
            input: input,
            command: self.describeFleetAdvisorCollectors,
            inputKey: \DescribeFleetAdvisorCollectorsRequest.nextToken,
            outputKey: \DescribeFleetAdvisorCollectorsResponse.nextToken,
            logger: logger
        )
    }

    /// Returns a list of Fleet Advisor databases in your account.
    /// Return PaginatorSequence for operation.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - logger: Logger used flot logging
    public func describeFleetAdvisorDatabasesPaginator(
        _ input: DescribeFleetAdvisorDatabasesRequest,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<DescribeFleetAdvisorDatabasesRequest, DescribeFleetAdvisorDatabasesResponse> {
        return .init(
            input: input,
            command: self.describeFleetAdvisorDatabases,
            inputKey: \DescribeFleetAdvisorDatabasesRequest.nextToken,
            outputKey: \DescribeFleetAdvisorDatabasesResponse.nextToken,
            logger: logger
        )
    }

    /// Provides descriptions of large-scale assessment (LSA) analyses produced by your Fleet Advisor collectors.
    /// Return PaginatorSequence for operation.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - logger: Logger used flot logging
    public func describeFleetAdvisorLsaAnalysisPaginator(
        _ input: DescribeFleetAdvisorLsaAnalysisRequest,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<DescribeFleetAdvisorLsaAnalysisRequest, DescribeFleetAdvisorLsaAnalysisResponse> {
        return .init(
            input: input,
            command: self.describeFleetAdvisorLsaAnalysis,
            inputKey: \DescribeFleetAdvisorLsaAnalysisRequest.nextToken,
            outputKey: \DescribeFleetAdvisorLsaAnalysisResponse.nextToken,
            logger: logger
        )
    }

    /// Provides descriptions of the schemas discovered by your Fleet Advisor collectors.
    /// Return PaginatorSequence for operation.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - logger: Logger used flot logging
    public func describeFleetAdvisorSchemaObjectSummaryPaginator(
        _ input: DescribeFleetAdvisorSchemaObjectSummaryRequest,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<DescribeFleetAdvisorSchemaObjectSummaryRequest, DescribeFleetAdvisorSchemaObjectSummaryResponse> {
        return .init(
            input: input,
            command: self.describeFleetAdvisorSchemaObjectSummary,
            inputKey: \DescribeFleetAdvisorSchemaObjectSummaryRequest.nextToken,
            outputKey: \DescribeFleetAdvisorSchemaObjectSummaryResponse.nextToken,
            logger: logger
        )
    }

    /// Returns a list of schemas detected by Fleet Advisor Collectors in your account.
    /// Return PaginatorSequence for operation.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - logger: Logger used flot logging
    public func describeFleetAdvisorSchemasPaginator(
        _ input: DescribeFleetAdvisorSchemasRequest,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<DescribeFleetAdvisorSchemasRequest, DescribeFleetAdvisorSchemasResponse> {
        return .init(
            input: input,
            command: self.describeFleetAdvisorSchemas,
            inputKey: \DescribeFleetAdvisorSchemasRequest.nextToken,
            outputKey: \DescribeFleetAdvisorSchemasResponse.nextToken,
            logger: logger
        )
    }

    /// Returns a paginated list of instance profiles for your account in the current region.
    /// Return PaginatorSequence for operation.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - logger: Logger used flot logging
    public func describeInstanceProfilesPaginator(
        _ input: DescribeInstanceProfilesMessage,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<DescribeInstanceProfilesMessage, DescribeInstanceProfilesResponse> {
        return .init(
            input: input,
            command: self.describeInstanceProfiles,
            inputKey: \DescribeInstanceProfilesMessage.marker,
            outputKey: \DescribeInstanceProfilesResponse.marker,
            logger: logger
        )
    }

    /// Returns a paginated list of metadata model assessments for your account in the current region.
    /// Return PaginatorSequence for operation.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - logger: Logger used flot logging
    public func describeMetadataModelAssessmentsPaginator(
        _ input: DescribeMetadataModelAssessmentsMessage,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<DescribeMetadataModelAssessmentsMessage, DescribeMetadataModelAssessmentsResponse> {
        return .init(
            input: input,
            command: self.describeMetadataModelAssessments,
            inputKey: \DescribeMetadataModelAssessmentsMessage.marker,
            outputKey: \DescribeMetadataModelAssessmentsResponse.marker,
            logger: logger
        )
    }

    /// Returns a paginated list of metadata model conversions for a migration project.
    /// Return PaginatorSequence for operation.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - logger: Logger used flot logging
    public func describeMetadataModelConversionsPaginator(
        _ input: DescribeMetadataModelConversionsMessage,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<DescribeMetadataModelConversionsMessage, DescribeMetadataModelConversionsResponse> {
        return .init(
            input: input,
            command: self.describeMetadataModelConversions,
            inputKey: \DescribeMetadataModelConversionsMessage.marker,
            outputKey: \DescribeMetadataModelConversionsResponse.marker,
            logger: logger
        )
    }

    /// Returns a paginated list of metadata model exports.
    /// Return PaginatorSequence for operation.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - logger: Logger used flot logging
    public func describeMetadataModelExportsAsScriptPaginator(
        _ input: DescribeMetadataModelExportsAsScriptMessage,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<DescribeMetadataModelExportsAsScriptMessage, DescribeMetadataModelExportsAsScriptResponse> {
        return .init(
            input: input,
            command: self.describeMetadataModelExportsAsScript,
            inputKey: \DescribeMetadataModelExportsAsScriptMessage.marker,
            outputKey: \DescribeMetadataModelExportsAsScriptResponse.marker,
            logger: logger
        )
    }

    /// Returns a paginated list of metadata model exports.
    /// Return PaginatorSequence for operation.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - logger: Logger used flot logging
    public func describeMetadataModelExportsToTargetPaginator(
        _ input: DescribeMetadataModelExportsToTargetMessage,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<DescribeMetadataModelExportsToTargetMessage, DescribeMetadataModelExportsToTargetResponse> {
        return .init(
            input: input,
            command: self.describeMetadataModelExportsToTarget,
            inputKey: \DescribeMetadataModelExportsToTargetMessage.marker,
            outputKey: \DescribeMetadataModelExportsToTargetResponse.marker,
            logger: logger
        )
    }

    /// Returns a paginated list of metadata model imports.
    /// Return PaginatorSequence for operation.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - logger: Logger used flot logging
    public func describeMetadataModelImportsPaginator(
        _ input: DescribeMetadataModelImportsMessage,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<DescribeMetadataModelImportsMessage, DescribeMetadataModelImportsResponse> {
        return .init(
            input: input,
            command: self.describeMetadataModelImports,
            inputKey: \DescribeMetadataModelImportsMessage.marker,
            outputKey: \DescribeMetadataModelImportsResponse.marker,
            logger: logger
        )
    }

    /// Returns a paginated list of migration projects for your account in the current region.
    /// Return PaginatorSequence for operation.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - logger: Logger used flot logging
    public func describeMigrationProjectsPaginator(
        _ input: DescribeMigrationProjectsMessage,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<DescribeMigrationProjectsMessage, DescribeMigrationProjectsResponse> {
        return .init(
            input: input,
            command: self.describeMigrationProjects,
            inputKey: \DescribeMigrationProjectsMessage.marker,
            outputKey: \DescribeMigrationProjectsResponse.marker,
            logger: logger
        )
    }

    /// Returns information about the replication instance types that can be created in the specified region.
    /// Return PaginatorSequence for operation.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - logger: Logger used flot logging
    public func describeOrderableReplicationInstancesPaginator(
        _ input: DescribeOrderableReplicationInstancesMessage,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<DescribeOrderableReplicationInstancesMessage, DescribeOrderableReplicationInstancesResponse> {
        return .init(
            input: input,
            command: self.describeOrderableReplicationInstances,
            inputKey: \DescribeOrderableReplicationInstancesMessage.marker,
            outputKey: \DescribeOrderableReplicationInstancesResponse.marker,
            logger: logger
        )
    }

    /// For internal use only
    /// Return PaginatorSequence for operation.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - logger: Logger used flot logging
    public func describePendingMaintenanceActionsPaginator(
        _ input: DescribePendingMaintenanceActionsMessage,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<DescribePendingMaintenanceActionsMessage, DescribePendingMaintenanceActionsResponse> {
        return .init(
            input: input,
            command: self.describePendingMaintenanceActions,
            inputKey: \DescribePendingMaintenanceActionsMessage.marker,
            outputKey: \DescribePendingMaintenanceActionsResponse.marker,
            logger: logger
        )
    }

    /// Returns a paginated list of limitations for recommendations of target Amazon Web Services engines.
    /// Return PaginatorSequence for operation.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - logger: Logger used flot logging
    public func describeRecommendationLimitationsPaginator(
        _ input: DescribeRecommendationLimitationsRequest,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<DescribeRecommendationLimitationsRequest, DescribeRecommendationLimitationsResponse> {
        return .init(
            input: input,
            command: self.describeRecommendationLimitations,
            inputKey: \DescribeRecommendationLimitationsRequest.nextToken,
            outputKey: \DescribeRecommendationLimitationsResponse.nextToken,
            logger: logger
        )
    }

    /// Returns a paginated list of target engine recommendations for your source databases.
    /// Return PaginatorSequence for operation.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - logger: Logger used flot logging
    public func describeRecommendationsPaginator(
        _ input: DescribeRecommendationsRequest,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<DescribeRecommendationsRequest, DescribeRecommendationsResponse> {
        return .init(
            input: input,
            command: self.describeRecommendations,
            inputKey: \DescribeRecommendationsRequest.nextToken,
            outputKey: \DescribeRecommendationsResponse.nextToken,
            logger: logger
        )
    }

    /// Returns one or more existing DMS Serverless replication configurations as a list of structures.
    /// Return PaginatorSequence for operation.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - logger: Logger used flot logging
    public func describeReplicationConfigsPaginator(
        _ input: DescribeReplicationConfigsMessage,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<DescribeReplicationConfigsMessage, DescribeReplicationConfigsResponse> {
        return .init(
            input: input,
            command: self.describeReplicationConfigs,
            inputKey: \DescribeReplicationConfigsMessage.marker,
            outputKey: \DescribeReplicationConfigsResponse.marker,
            logger: logger
        )
    }

    /// Returns information about the task logs for the specified task.
    /// Return PaginatorSequence for operation.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - logger: Logger used flot logging
    public func describeReplicationInstanceTaskLogsPaginator(
        _ input: DescribeReplicationInstanceTaskLogsMessage,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<DescribeReplicationInstanceTaskLogsMessage, DescribeReplicationInstanceTaskLogsResponse> {
        return .init(
            input: input,
            command: self.describeReplicationInstanceTaskLogs,
            inputKey: \DescribeReplicationInstanceTaskLogsMessage.marker,
            outputKey: \DescribeReplicationInstanceTaskLogsResponse.marker,
            logger: logger
        )
    }

    /// Returns information about replication instances for your account in the current region.
    /// Return PaginatorSequence for operation.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - logger: Logger used flot logging
    public func describeReplicationInstancesPaginator(
        _ input: DescribeReplicationInstancesMessage,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<DescribeReplicationInstancesMessage, DescribeReplicationInstancesResponse> {
        return .init(
            input: input,
            command: self.describeReplicationInstances,
            inputKey: \DescribeReplicationInstancesMessage.marker,
            outputKey: \DescribeReplicationInstancesResponse.marker,
            logger: logger
        )
    }

    /// Returns information about the replication subnet groups.
    /// Return PaginatorSequence for operation.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - logger: Logger used flot logging
    public func describeReplicationSubnetGroupsPaginator(
        _ input: DescribeReplicationSubnetGroupsMessage,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<DescribeReplicationSubnetGroupsMessage, DescribeReplicationSubnetGroupsResponse> {
        return .init(
            input: input,
            command: self.describeReplicationSubnetGroups,
            inputKey: \DescribeReplicationSubnetGroupsMessage.marker,
            outputKey: \DescribeReplicationSubnetGroupsResponse.marker,
            logger: logger
        )
    }

    /// Returns table and schema statistics for one or more provisioned replications that use a given DMS Serverless replication configuration.
    /// Return PaginatorSequence for operation.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - logger: Logger used flot logging
    public func describeReplicationTableStatisticsPaginator(
        _ input: DescribeReplicationTableStatisticsMessage,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<DescribeReplicationTableStatisticsMessage, DescribeReplicationTableStatisticsResponse> {
        return .init(
            input: input,
            command: self.describeReplicationTableStatistics,
            inputKey: \DescribeReplicationTableStatisticsMessage.marker,
            outputKey: \DescribeReplicationTableStatisticsResponse.marker,
            logger: logger
        )
    }

    /// Returns the task assessment results from the Amazon S3 bucket that DMS creates in your Amazon Web Services account.  This action always returns the latest results. For more information about DMS task assessments, see   Creating a task assessment report in the Database Migration Service User Guide.
    /// Return PaginatorSequence for operation.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - logger: Logger used flot logging
    public func describeReplicationTaskAssessmentResultsPaginator(
        _ input: DescribeReplicationTaskAssessmentResultsMessage,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<DescribeReplicationTaskAssessmentResultsMessage, DescribeReplicationTaskAssessmentResultsResponse> {
        return .init(
            input: input,
            command: self.describeReplicationTaskAssessmentResults,
            inputKey: \DescribeReplicationTaskAssessmentResultsMessage.marker,
            outputKey: \DescribeReplicationTaskAssessmentResultsResponse.marker,
            logger: logger
        )
    }

    /// Returns a paginated list of premigration assessment runs based on filter settings. These filter settings can specify a combination of premigration assessment runs, migration tasks, replication instances, and assessment run status values.  This operation doesn't return information about individual assessments. For this information, see the DescribeReplicationTaskIndividualAssessments operation.
    /// Return PaginatorSequence for operation.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - logger: Logger used flot logging
    public func describeReplicationTaskAssessmentRunsPaginator(
        _ input: DescribeReplicationTaskAssessmentRunsMessage,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<DescribeReplicationTaskAssessmentRunsMessage, DescribeReplicationTaskAssessmentRunsResponse> {
        return .init(
            input: input,
            command: self.describeReplicationTaskAssessmentRuns,
            inputKey: \DescribeReplicationTaskAssessmentRunsMessage.marker,
            outputKey: \DescribeReplicationTaskAssessmentRunsResponse.marker,
            logger: logger
        )
    }

    /// Returns a paginated list of individual assessments based on filter settings. These filter settings can specify a combination of premigration assessment runs, migration tasks, and assessment status values.
    /// Return PaginatorSequence for operation.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - logger: Logger used flot logging
    public func describeReplicationTaskIndividualAssessmentsPaginator(
        _ input: DescribeReplicationTaskIndividualAssessmentsMessage,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<DescribeReplicationTaskIndividualAssessmentsMessage, DescribeReplicationTaskIndividualAssessmentsResponse> {
        return .init(
            input: input,
            command: self.describeReplicationTaskIndividualAssessments,
            inputKey: \DescribeReplicationTaskIndividualAssessmentsMessage.marker,
            outputKey: \DescribeReplicationTaskIndividualAssessmentsResponse.marker,
            logger: logger
        )
    }

    /// Returns information about replication tasks for your account in the current region.
    /// Return PaginatorSequence for operation.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - logger: Logger used flot logging
    public func describeReplicationTasksPaginator(
        _ input: DescribeReplicationTasksMessage,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<DescribeReplicationTasksMessage, DescribeReplicationTasksResponse> {
        return .init(
            input: input,
            command: self.describeReplicationTasks,
            inputKey: \DescribeReplicationTasksMessage.marker,
            outputKey: \DescribeReplicationTasksResponse.marker,
            logger: logger
        )
    }

    /// Provides details on replication progress by returning status information for one or more provisioned DMS Serverless replications.
    /// Return PaginatorSequence for operation.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - logger: Logger used flot logging
    public func describeReplicationsPaginator(
        _ input: DescribeReplicationsMessage,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<DescribeReplicationsMessage, DescribeReplicationsResponse> {
        return .init(
            input: input,
            command: self.describeReplications,
            inputKey: \DescribeReplicationsMessage.marker,
            outputKey: \DescribeReplicationsResponse.marker,
            logger: logger
        )
    }

    /// Returns information about the schema for the specified endpoint.
    /// Return PaginatorSequence for operation.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - logger: Logger used flot logging
    public func describeSchemasPaginator(
        _ input: DescribeSchemasMessage,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<DescribeSchemasMessage, DescribeSchemasResponse> {
        return .init(
            input: input,
            command: self.describeSchemas,
            inputKey: \DescribeSchemasMessage.marker,
            outputKey: \DescribeSchemasResponse.marker,
            logger: logger
        )
    }

    /// Returns table statistics on the database migration task, including table name, rows inserted, rows updated, and rows deleted. Note that the "last updated" column the DMS console only indicates the time that DMS last updated the table statistics record for a table. It does not indicate the time of the last update to the table.
    /// Return PaginatorSequence for operation.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - logger: Logger used flot logging
    public func describeTableStatisticsPaginator(
        _ input: DescribeTableStatisticsMessage,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<DescribeTableStatisticsMessage, DescribeTableStatisticsResponse> {
        return .init(
            input: input,
            command: self.describeTableStatistics,
            inputKey: \DescribeTableStatisticsMessage.marker,
            outputKey: \DescribeTableStatisticsResponse.marker,
            logger: logger
        )
    }
}

extension DatabaseMigrationService.DescribeApplicableIndividualAssessmentsMessage: AWSPaginateToken {
    public func usingPaginationToken(_ token: String) -> DatabaseMigrationService.DescribeApplicableIndividualAssessmentsMessage {
        return .init(
            marker: token,
            maxRecords: self.maxRecords,
            migrationType: self.migrationType,
            replicationInstanceArn: self.replicationInstanceArn,
            replicationTaskArn: self.replicationTaskArn,
            sourceEngineName: self.sourceEngineName,
            targetEngineName: self.targetEngineName
        )
    }
}

extension DatabaseMigrationService.DescribeCertificatesMessage: AWSPaginateToken {
    public func usingPaginationToken(_ token: String) -> DatabaseMigrationService.DescribeCertificatesMessage {
        return .init(
            filters: self.filters,
            marker: token,
            maxRecords: self.maxRecords
        )
    }
}

extension DatabaseMigrationService.DescribeConnectionsMessage: AWSPaginateToken {
    public func usingPaginationToken(_ token: String) -> DatabaseMigrationService.DescribeConnectionsMessage {
        return .init(
            filters: self.filters,
            marker: token,
            maxRecords: self.maxRecords
        )
    }
}

extension DatabaseMigrationService.DescribeDataProvidersMessage: AWSPaginateToken {
    public func usingPaginationToken(_ token: String) -> DatabaseMigrationService.DescribeDataProvidersMessage {
        return .init(
            filters: self.filters,
            marker: token,
            maxRecords: self.maxRecords
        )
    }
}

extension DatabaseMigrationService.DescribeEndpointSettingsMessage: AWSPaginateToken {
    public func usingPaginationToken(_ token: String) -> DatabaseMigrationService.DescribeEndpointSettingsMessage {
        return .init(
            engineName: self.engineName,
            marker: token,
            maxRecords: self.maxRecords
        )
    }
}

extension DatabaseMigrationService.DescribeEndpointTypesMessage: AWSPaginateToken {
    public func usingPaginationToken(_ token: String) -> DatabaseMigrationService.DescribeEndpointTypesMessage {
        return .init(
            filters: self.filters,
            marker: token,
            maxRecords: self.maxRecords
        )
    }
}

extension DatabaseMigrationService.DescribeEndpointsMessage: AWSPaginateToken {
    public func usingPaginationToken(_ token: String) -> DatabaseMigrationService.DescribeEndpointsMessage {
        return .init(
            filters: self.filters,
            marker: token,
            maxRecords: self.maxRecords
        )
    }
}

extension DatabaseMigrationService.DescribeEngineVersionsMessage: AWSPaginateToken {
    public func usingPaginationToken(_ token: String) -> DatabaseMigrationService.DescribeEngineVersionsMessage {
        return .init(
            marker: token,
            maxRecords: self.maxRecords
        )
    }
}

extension DatabaseMigrationService.DescribeEventSubscriptionsMessage: AWSPaginateToken {
    public func usingPaginationToken(_ token: String) -> DatabaseMigrationService.DescribeEventSubscriptionsMessage {
        return .init(
            filters: self.filters,
            marker: token,
            maxRecords: self.maxRecords,
            subscriptionName: self.subscriptionName
        )
    }
}

extension DatabaseMigrationService.DescribeEventsMessage: AWSPaginateToken {
    public func usingPaginationToken(_ token: String) -> DatabaseMigrationService.DescribeEventsMessage {
        return .init(
            duration: self.duration,
            endTime: self.endTime,
            eventCategories: self.eventCategories,
            filters: self.filters,
            marker: token,
            maxRecords: self.maxRecords,
            sourceIdentifier: self.sourceIdentifier,
            sourceType: self.sourceType,
            startTime: self.startTime
        )
    }
}

extension DatabaseMigrationService.DescribeExtensionPackAssociationsMessage: AWSPaginateToken {
    public func usingPaginationToken(_ token: String) -> DatabaseMigrationService.DescribeExtensionPackAssociationsMessage {
        return .init(
            filters: self.filters,
            marker: token,
            maxRecords: self.maxRecords,
            migrationProjectIdentifier: self.migrationProjectIdentifier
        )
    }
}

extension DatabaseMigrationService.DescribeFleetAdvisorCollectorsRequest: AWSPaginateToken {
    public func usingPaginationToken(_ token: String) -> DatabaseMigrationService.DescribeFleetAdvisorCollectorsRequest {
        return .init(
            filters: self.filters,
            maxRecords: self.maxRecords,
            nextToken: token
        )
    }
}

extension DatabaseMigrationService.DescribeFleetAdvisorDatabasesRequest: AWSPaginateToken {
    public func usingPaginationToken(_ token: String) -> DatabaseMigrationService.DescribeFleetAdvisorDatabasesRequest {
        return .init(
            filters: self.filters,
            maxRecords: self.maxRecords,
            nextToken: token
        )
    }
}

extension DatabaseMigrationService.DescribeFleetAdvisorLsaAnalysisRequest: AWSPaginateToken {
    public func usingPaginationToken(_ token: String) -> DatabaseMigrationService.DescribeFleetAdvisorLsaAnalysisRequest {
        return .init(
            maxRecords: self.maxRecords,
            nextToken: token
        )
    }
}

extension DatabaseMigrationService.DescribeFleetAdvisorSchemaObjectSummaryRequest: AWSPaginateToken {
    public func usingPaginationToken(_ token: String) -> DatabaseMigrationService.DescribeFleetAdvisorSchemaObjectSummaryRequest {
        return .init(
            filters: self.filters,
            maxRecords: self.maxRecords,
            nextToken: token
        )
    }
}

extension DatabaseMigrationService.DescribeFleetAdvisorSchemasRequest: AWSPaginateToken {
    public func usingPaginationToken(_ token: String) -> DatabaseMigrationService.DescribeFleetAdvisorSchemasRequest {
        return .init(
            filters: self.filters,
            maxRecords: self.maxRecords,
            nextToken: token
        )
    }
}

extension DatabaseMigrationService.DescribeInstanceProfilesMessage: AWSPaginateToken {
    public func usingPaginationToken(_ token: String) -> DatabaseMigrationService.DescribeInstanceProfilesMessage {
        return .init(
            filters: self.filters,
            marker: token,
            maxRecords: self.maxRecords
        )
    }
}

extension DatabaseMigrationService.DescribeMetadataModelAssessmentsMessage: AWSPaginateToken {
    public func usingPaginationToken(_ token: String) -> DatabaseMigrationService.DescribeMetadataModelAssessmentsMessage {
        return .init(
            filters: self.filters,
            marker: token,
            maxRecords: self.maxRecords,
            migrationProjectIdentifier: self.migrationProjectIdentifier
        )
    }
}

extension DatabaseMigrationService.DescribeMetadataModelConversionsMessage: AWSPaginateToken {
    public func usingPaginationToken(_ token: String) -> DatabaseMigrationService.DescribeMetadataModelConversionsMessage {
        return .init(
            filters: self.filters,
            marker: token,
            maxRecords: self.maxRecords,
            migrationProjectIdentifier: self.migrationProjectIdentifier
        )
    }
}

extension DatabaseMigrationService.DescribeMetadataModelExportsAsScriptMessage: AWSPaginateToken {
    public func usingPaginationToken(_ token: String) -> DatabaseMigrationService.DescribeMetadataModelExportsAsScriptMessage {
        return .init(
            filters: self.filters,
            marker: token,
            maxRecords: self.maxRecords,
            migrationProjectIdentifier: self.migrationProjectIdentifier
        )
    }
}

extension DatabaseMigrationService.DescribeMetadataModelExportsToTargetMessage: AWSPaginateToken {
    public func usingPaginationToken(_ token: String) -> DatabaseMigrationService.DescribeMetadataModelExportsToTargetMessage {
        return .init(
            filters: self.filters,
            marker: token,
            maxRecords: self.maxRecords,
            migrationProjectIdentifier: self.migrationProjectIdentifier
        )
    }
}

extension DatabaseMigrationService.DescribeMetadataModelImportsMessage: AWSPaginateToken {
    public func usingPaginationToken(_ token: String) -> DatabaseMigrationService.DescribeMetadataModelImportsMessage {
        return .init(
            filters: self.filters,
            marker: token,
            maxRecords: self.maxRecords,
            migrationProjectIdentifier: self.migrationProjectIdentifier
        )
    }
}

extension DatabaseMigrationService.DescribeMigrationProjectsMessage: AWSPaginateToken {
    public func usingPaginationToken(_ token: String) -> DatabaseMigrationService.DescribeMigrationProjectsMessage {
        return .init(
            filters: self.filters,
            marker: token,
            maxRecords: self.maxRecords
        )
    }
}

extension DatabaseMigrationService.DescribeOrderableReplicationInstancesMessage: AWSPaginateToken {
    public func usingPaginationToken(_ token: String) -> DatabaseMigrationService.DescribeOrderableReplicationInstancesMessage {
        return .init(
            marker: token,
            maxRecords: self.maxRecords
        )
    }
}

extension DatabaseMigrationService.DescribePendingMaintenanceActionsMessage: AWSPaginateToken {
    public func usingPaginationToken(_ token: String) -> DatabaseMigrationService.DescribePendingMaintenanceActionsMessage {
        return .init(
            filters: self.filters,
            marker: token,
            maxRecords: self.maxRecords,
            replicationInstanceArn: self.replicationInstanceArn
        )
    }
}

extension DatabaseMigrationService.DescribeRecommendationLimitationsRequest: AWSPaginateToken {
    public func usingPaginationToken(_ token: String) -> DatabaseMigrationService.DescribeRecommendationLimitationsRequest {
        return .init(
            filters: self.filters,
            maxRecords: self.maxRecords,
            nextToken: token
        )
    }
}

extension DatabaseMigrationService.DescribeRecommendationsRequest: AWSPaginateToken {
    public func usingPaginationToken(_ token: String) -> DatabaseMigrationService.DescribeRecommendationsRequest {
        return .init(
            filters: self.filters,
            maxRecords: self.maxRecords,
            nextToken: token
        )
    }
}

extension DatabaseMigrationService.DescribeReplicationConfigsMessage: AWSPaginateToken {
    public func usingPaginationToken(_ token: String) -> DatabaseMigrationService.DescribeReplicationConfigsMessage {
        return .init(
            filters: self.filters,
            marker: token,
            maxRecords: self.maxRecords
        )
    }
}

extension DatabaseMigrationService.DescribeReplicationInstanceTaskLogsMessage: AWSPaginateToken {
    public func usingPaginationToken(_ token: String) -> DatabaseMigrationService.DescribeReplicationInstanceTaskLogsMessage {
        return .init(
            marker: token,
            maxRecords: self.maxRecords,
            replicationInstanceArn: self.replicationInstanceArn
        )
    }
}

extension DatabaseMigrationService.DescribeReplicationInstancesMessage: AWSPaginateToken {
    public func usingPaginationToken(_ token: String) -> DatabaseMigrationService.DescribeReplicationInstancesMessage {
        return .init(
            filters: self.filters,
            marker: token,
            maxRecords: self.maxRecords
        )
    }
}

extension DatabaseMigrationService.DescribeReplicationSubnetGroupsMessage: AWSPaginateToken {
    public func usingPaginationToken(_ token: String) -> DatabaseMigrationService.DescribeReplicationSubnetGroupsMessage {
        return .init(
            filters: self.filters,
            marker: token,
            maxRecords: self.maxRecords
        )
    }
}

extension DatabaseMigrationService.DescribeReplicationTableStatisticsMessage: AWSPaginateToken {
    public func usingPaginationToken(_ token: String) -> DatabaseMigrationService.DescribeReplicationTableStatisticsMessage {
        return .init(
            filters: self.filters,
            marker: token,
            maxRecords: self.maxRecords,
            replicationConfigArn: self.replicationConfigArn
        )
    }
}

extension DatabaseMigrationService.DescribeReplicationTaskAssessmentResultsMessage: AWSPaginateToken {
    public func usingPaginationToken(_ token: String) -> DatabaseMigrationService.DescribeReplicationTaskAssessmentResultsMessage {
        return .init(
            marker: token,
            maxRecords: self.maxRecords,
            replicationTaskArn: self.replicationTaskArn
        )
    }
}

extension DatabaseMigrationService.DescribeReplicationTaskAssessmentRunsMessage: AWSPaginateToken {
    public func usingPaginationToken(_ token: String) -> DatabaseMigrationService.DescribeReplicationTaskAssessmentRunsMessage {
        return .init(
            filters: self.filters,
            marker: token,
            maxRecords: self.maxRecords
        )
    }
}

extension DatabaseMigrationService.DescribeReplicationTaskIndividualAssessmentsMessage: AWSPaginateToken {
    public func usingPaginationToken(_ token: String) -> DatabaseMigrationService.DescribeReplicationTaskIndividualAssessmentsMessage {
        return .init(
            filters: self.filters,
            marker: token,
            maxRecords: self.maxRecords
        )
    }
}

extension DatabaseMigrationService.DescribeReplicationTasksMessage: AWSPaginateToken {
    public func usingPaginationToken(_ token: String) -> DatabaseMigrationService.DescribeReplicationTasksMessage {
        return .init(
            filters: self.filters,
            marker: token,
            maxRecords: self.maxRecords,
            withoutSettings: self.withoutSettings
        )
    }
}

extension DatabaseMigrationService.DescribeReplicationsMessage: AWSPaginateToken {
    public func usingPaginationToken(_ token: String) -> DatabaseMigrationService.DescribeReplicationsMessage {
        return .init(
            filters: self.filters,
            marker: token,
            maxRecords: self.maxRecords
        )
    }
}

extension DatabaseMigrationService.DescribeSchemasMessage: AWSPaginateToken {
    public func usingPaginationToken(_ token: String) -> DatabaseMigrationService.DescribeSchemasMessage {
        return .init(
            endpointArn: self.endpointArn,
            marker: token,
            maxRecords: self.maxRecords
        )
    }
}

extension DatabaseMigrationService.DescribeTableStatisticsMessage: AWSPaginateToken {
    public func usingPaginationToken(_ token: String) -> DatabaseMigrationService.DescribeTableStatisticsMessage {
        return .init(
            filters: self.filters,
            marker: token,
            maxRecords: self.maxRecords,
            replicationTaskArn: self.replicationTaskArn
        )
    }
}

// MARK: Waiters

@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension DatabaseMigrationService {
    public func waitUntilEndpointDeleted(
        _ input: DescribeEndpointsMessage,
        maxWaitTime: TimeAmount? = nil,
        logger: Logger = AWSClient.loggingDisabled
    ) async throws {
        let waiter = AWSClient.Waiter(
            acceptors: [
                .init(state: .success, matcher: AWSErrorCodeMatcher("ResourceNotFoundFault")),
                .init(state: .failure, matcher: try! JMESAnyPathMatcher("endpoints[].status", expected: "active")),
                .init(state: .failure, matcher: try! JMESAnyPathMatcher("endpoints[].status", expected: "creating")),
            ],
            minDelayTime: .seconds(5),
            command: self.describeEndpoints
        )
        return try await self.client.waitUntil(input, waiter: waiter, maxWaitTime: maxWaitTime, logger: logger)
    }

    public func waitUntilReplicationInstanceAvailable(
        _ input: DescribeReplicationInstancesMessage,
        maxWaitTime: TimeAmount? = nil,
        logger: Logger = AWSClient.loggingDisabled
    ) async throws {
        let waiter = AWSClient.Waiter(
            acceptors: [
                .init(state: .success, matcher: try! JMESAllPathMatcher("replicationInstances[].replicationInstanceStatus", expected: "available")),
                .init(state: .failure, matcher: try! JMESAnyPathMatcher("replicationInstances[].replicationInstanceStatus", expected: "deleting")),
                .init(state: .failure, matcher: try! JMESAnyPathMatcher("replicationInstances[].replicationInstanceStatus", expected: "incompatible-credentials")),
                .init(state: .failure, matcher: try! JMESAnyPathMatcher("replicationInstances[].replicationInstanceStatus", expected: "incompatible-network")),
                .init(state: .failure, matcher: try! JMESAnyPathMatcher("replicationInstances[].replicationInstanceStatus", expected: "inaccessible-encryption-credentials")),
            ],
            minDelayTime: .seconds(60),
            command: self.describeReplicationInstances
        )
        return try await self.client.waitUntil(input, waiter: waiter, maxWaitTime: maxWaitTime, logger: logger)
    }

    public func waitUntilReplicationInstanceDeleted(
        _ input: DescribeReplicationInstancesMessage,
        maxWaitTime: TimeAmount? = nil,
        logger: Logger = AWSClient.loggingDisabled
    ) async throws {
        let waiter = AWSClient.Waiter(
            acceptors: [
                .init(state: .failure, matcher: try! JMESAnyPathMatcher("replicationInstances[].replicationInstanceStatus", expected: "available")),
                .init(state: .success, matcher: AWSErrorCodeMatcher("ResourceNotFoundFault")),
            ],
            minDelayTime: .seconds(15),
            command: self.describeReplicationInstances
        )
        return try await self.client.waitUntil(input, waiter: waiter, maxWaitTime: maxWaitTime, logger: logger)
    }

    public func waitUntilReplicationTaskDeleted(
        _ input: DescribeReplicationTasksMessage,
        maxWaitTime: TimeAmount? = nil,
        logger: Logger = AWSClient.loggingDisabled
    ) async throws {
        let waiter = AWSClient.Waiter(
            acceptors: [
                .init(state: .failure, matcher: try! JMESAnyPathMatcher("replicationTasks[].status", expected: "ready")),
                .init(state: .failure, matcher: try! JMESAnyPathMatcher("replicationTasks[].status", expected: "creating")),
                .init(state: .failure, matcher: try! JMESAnyPathMatcher("replicationTasks[].status", expected: "stopped")),
                .init(state: .failure, matcher: try! JMESAnyPathMatcher("replicationTasks[].status", expected: "running")),
                .init(state: .failure, matcher: try! JMESAnyPathMatcher("replicationTasks[].status", expected: "failed")),
                .init(state: .success, matcher: AWSErrorCodeMatcher("ResourceNotFoundFault")),
            ],
            minDelayTime: .seconds(15),
            command: self.describeReplicationTasks
        )
        return try await self.client.waitUntil(input, waiter: waiter, maxWaitTime: maxWaitTime, logger: logger)
    }

    public func waitUntilReplicationTaskReady(
        _ input: DescribeReplicationTasksMessage,
        maxWaitTime: TimeAmount? = nil,
        logger: Logger = AWSClient.loggingDisabled
    ) async throws {
        let waiter = AWSClient.Waiter(
            acceptors: [
                .init(state: .success, matcher: try! JMESAllPathMatcher("replicationTasks[].status", expected: "ready")),
                .init(state: .failure, matcher: try! JMESAnyPathMatcher("replicationTasks[].status", expected: "starting")),
                .init(state: .failure, matcher: try! JMESAnyPathMatcher("replicationTasks[].status", expected: "running")),
                .init(state: .failure, matcher: try! JMESAnyPathMatcher("replicationTasks[].status", expected: "stopping")),
                .init(state: .failure, matcher: try! JMESAnyPathMatcher("replicationTasks[].status", expected: "stopped")),
                .init(state: .failure, matcher: try! JMESAnyPathMatcher("replicationTasks[].status", expected: "failed")),
                .init(state: .failure, matcher: try! JMESAnyPathMatcher("replicationTasks[].status", expected: "modifying")),
                .init(state: .failure, matcher: try! JMESAnyPathMatcher("replicationTasks[].status", expected: "testing")),
                .init(state: .failure, matcher: try! JMESAnyPathMatcher("replicationTasks[].status", expected: "deleting")),
            ],
            minDelayTime: .seconds(15),
            command: self.describeReplicationTasks
        )
        return try await self.client.waitUntil(input, waiter: waiter, maxWaitTime: maxWaitTime, logger: logger)
    }

    public func waitUntilReplicationTaskRunning(
        _ input: DescribeReplicationTasksMessage,
        maxWaitTime: TimeAmount? = nil,
        logger: Logger = AWSClient.loggingDisabled
    ) async throws {
        let waiter = AWSClient.Waiter(
            acceptors: [
                .init(state: .success, matcher: try! JMESAllPathMatcher("replicationTasks[].status", expected: "running")),
                .init(state: .failure, matcher: try! JMESAnyPathMatcher("replicationTasks[].status", expected: "ready")),
                .init(state: .failure, matcher: try! JMESAnyPathMatcher("replicationTasks[].status", expected: "creating")),
                .init(state: .failure, matcher: try! JMESAnyPathMatcher("replicationTasks[].status", expected: "stopping")),
                .init(state: .failure, matcher: try! JMESAnyPathMatcher("replicationTasks[].status", expected: "stopped")),
                .init(state: .failure, matcher: try! JMESAnyPathMatcher("replicationTasks[].status", expected: "failed")),
                .init(state: .failure, matcher: try! JMESAnyPathMatcher("replicationTasks[].status", expected: "modifying")),
                .init(state: .failure, matcher: try! JMESAnyPathMatcher("replicationTasks[].status", expected: "testing")),
                .init(state: .failure, matcher: try! JMESAnyPathMatcher("replicationTasks[].status", expected: "deleting")),
            ],
            minDelayTime: .seconds(15),
            command: self.describeReplicationTasks
        )
        return try await self.client.waitUntil(input, waiter: waiter, maxWaitTime: maxWaitTime, logger: logger)
    }

    public func waitUntilReplicationTaskStopped(
        _ input: DescribeReplicationTasksMessage,
        maxWaitTime: TimeAmount? = nil,
        logger: Logger = AWSClient.loggingDisabled
    ) async throws {
        let waiter = AWSClient.Waiter(
            acceptors: [
                .init(state: .success, matcher: try! JMESAllPathMatcher("replicationTasks[].status", expected: "stopped")),
                .init(state: .failure, matcher: try! JMESAnyPathMatcher("replicationTasks[].status", expected: "ready")),
                .init(state: .failure, matcher: try! JMESAnyPathMatcher("replicationTasks[].status", expected: "creating")),
                .init(state: .failure, matcher: try! JMESAnyPathMatcher("replicationTasks[].status", expected: "starting")),
                .init(state: .failure, matcher: try! JMESAnyPathMatcher("replicationTasks[].status", expected: "failed")),
                .init(state: .failure, matcher: try! JMESAnyPathMatcher("replicationTasks[].status", expected: "modifying")),
                .init(state: .failure, matcher: try! JMESAnyPathMatcher("replicationTasks[].status", expected: "testing")),
                .init(state: .failure, matcher: try! JMESAnyPathMatcher("replicationTasks[].status", expected: "deleting")),
            ],
            minDelayTime: .seconds(15),
            command: self.describeReplicationTasks
        )
        return try await self.client.waitUntil(input, waiter: waiter, maxWaitTime: maxWaitTime, logger: logger)
    }

    public func waitUntilTestConnectionSucceeds(
        _ input: DescribeConnectionsMessage,
        maxWaitTime: TimeAmount? = nil,
        logger: Logger = AWSClient.loggingDisabled
    ) async throws {
        let waiter = AWSClient.Waiter(
            acceptors: [
                .init(state: .success, matcher: try! JMESAllPathMatcher("connections[].status", expected: "successful")),
                .init(state: .failure, matcher: try! JMESAnyPathMatcher("connections[].status", expected: "failed")),
            ],
            minDelayTime: .seconds(5),
            command: self.describeConnections
        )
        return try await self.client.waitUntil(input, waiter: waiter, maxWaitTime: maxWaitTime, logger: logger)
    }
}
