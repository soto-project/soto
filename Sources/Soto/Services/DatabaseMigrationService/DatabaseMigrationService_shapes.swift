//===----------------------------------------------------------------------===//
//
// This source file is part of the Soto for AWS open source project
//
// Copyright (c) 2017-2024 the Soto project authors
// Licensed under Apache License v2.0
//
// See LICENSE.txt for license information
// See CONTRIBUTORS.txt for the list of Soto project authors
//
// SPDX-License-Identifier: Apache-2.0
//
//===----------------------------------------------------------------------===//

// THIS FILE IS AUTOMATICALLY GENERATED by https://github.com/soto-project/soto-codegenerator.
// DO NOT EDIT.

#if canImport(FoundationEssentials)
import FoundationEssentials
#else
import Foundation
#endif
@_spi(SotoInternal) import SotoCore

extension DatabaseMigrationService {
    // MARK: Enums

    public enum AssessmentReportType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case csv = "csv"
        case pdf = "pdf"
        public var description: String { return self.rawValue }
    }

    public enum AuthMechanismValue: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case `default` = "default"
        case mongodbCr = "mongodb_cr"
        case scramSha1 = "scram_sha_1"
        public var description: String { return self.rawValue }
    }

    public enum AuthTypeValue: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case no = "no"
        case password = "password"
        public var description: String { return self.rawValue }
    }

    public enum CannedAclForObjectsValue: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case `private` = "private"
        case authenticatedRead = "authenticated-read"
        case awsExecRead = "aws-exec-read"
        case bucketOwnerFullControl = "bucket-owner-full-control"
        case bucketOwnerRead = "bucket-owner-read"
        case none = "none"
        case publicRead = "public-read"
        case publicReadWrite = "public-read-write"
        public var description: String { return self.rawValue }
    }

    public enum CharLengthSemantics: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case `default` = "default"
        case byte = "byte"
        case char = "char"
        public var description: String { return self.rawValue }
    }

    public enum CollectorStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case active = "ACTIVE"
        case unregistered = "UNREGISTERED"
        public var description: String { return self.rawValue }
    }

    public enum CompressionTypeValue: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case gzip = "gzip"
        case none = "none"
        public var description: String { return self.rawValue }
    }

    public enum DataFormatValue: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case csv = "csv"
        case parquet = "parquet"
        public var description: String { return self.rawValue }
    }

    public enum DatabaseMode: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case `default` = "default"
        case babelfish = "babelfish"
        public var description: String { return self.rawValue }
    }

    public enum DatePartitionDelimiterValue: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case dash = "DASH"
        case none = "NONE"
        case slash = "SLASH"
        case underscore = "UNDERSCORE"
        public var description: String { return self.rawValue }
    }

    public enum DatePartitionSequenceValue: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case ddmmyyyy = "DDMMYYYY"
        case mmyyyydd = "MMYYYYDD"
        case yyyymm = "YYYYMM"
        case yyyymmdd = "YYYYMMDD"
        case yyyymmddhh = "YYYYMMDDHH"
        public var description: String { return self.rawValue }
    }

    public enum DmsSslModeValue: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case none = "none"
        case require = "require"
        case verifyCa = "verify-ca"
        case verifyFull = "verify-full"
        public var description: String { return self.rawValue }
    }

    public enum EncodingTypeValue: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case plain = "plain"
        case plainDictionary = "plain-dictionary"
        case rleDictionary = "rle-dictionary"
        public var description: String { return self.rawValue }
    }

    public enum EncryptionModeValue: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case sseKms = "sse-kms"
        case sseS3 = "sse-s3"
        public var description: String { return self.rawValue }
    }

    public enum EndpointSettingTypeValue: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case `enum` = "enum"
        case boolean = "boolean"
        case integer = "integer"
        case string = "string"
        public var description: String { return self.rawValue }
    }

    public enum KafkaSaslMechanism: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case plain = "plain"
        case scramSha512 = "scram-sha-512"
        public var description: String { return self.rawValue }
    }

    public enum KafkaSecurityProtocol: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case plaintext = "plaintext"
        case saslSsl = "sasl-ssl"
        case sslAuthentication = "ssl-authentication"
        case sslEncryption = "ssl-encryption"
        public var description: String { return self.rawValue }
    }

    public enum KafkaSslEndpointIdentificationAlgorithm: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case https = "https"
        case none = "none"
        public var description: String { return self.rawValue }
    }

    public enum LongVarcharMappingType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case clob = "clob"
        case nclob = "nclob"
        case wstring = "wstring"
        public var description: String { return self.rawValue }
    }

    public enum MessageFormatValue: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case json = "json"
        case jsonUnformatted = "json-unformatted"
        public var description: String { return self.rawValue }
    }

    public enum MigrationTypeValue: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case cdc = "cdc"
        case fullLoad = "full-load"
        case fullLoadAndCdc = "full-load-and-cdc"
        public var description: String { return self.rawValue }
    }

    public enum NestingLevelValue: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case none = "none"
        case one = "one"
        public var description: String { return self.rawValue }
    }

    public enum OracleAuthenticationMethod: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case kerberos = "kerberos"
        case password = "password"
        public var description: String { return self.rawValue }
    }

    public enum OriginTypeValue: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case source = "SOURCE"
        case target = "TARGET"
        public var description: String { return self.rawValue }
    }

    public enum ParquetVersionValue: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case parquet10 = "parquet-1-0"
        case parquet20 = "parquet-2-0"
        public var description: String { return self.rawValue }
    }

    public enum PluginNameValue: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case noPreference = "no-preference"
        case pglogical = "pglogical"
        case testDecoding = "test-decoding"
        public var description: String { return self.rawValue }
    }

    public enum RedisAuthTypeValue: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case authRole = "auth-role"
        case authToken = "auth-token"
        case none = "none"
        public var description: String { return self.rawValue }
    }

    public enum RefreshSchemasStatusTypeValue: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case failed = "failed"
        case refreshing = "refreshing"
        case successful = "successful"
        public var description: String { return self.rawValue }
    }

    public enum ReleaseStatusValues: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case beta = "beta"
        case prod = "prod"
        public var description: String { return self.rawValue }
    }

    public enum ReloadOptionValue: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case dataReload = "data-reload"
        case validateOnly = "validate-only"
        public var description: String { return self.rawValue }
    }

    public enum ReplicationEndpointTypeValue: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case source = "source"
        case target = "target"
        public var description: String { return self.rawValue }
    }

    public enum SafeguardPolicy: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case exclusiveAutomaticTruncation = "exclusive-automatic-truncation"
        case relyOnSqlServerReplicationAgent = "rely-on-sql-server-replication-agent"
        case sharedAutomaticTruncation = "shared-automatic-truncation"
        public var description: String { return self.rawValue }
    }

    public enum SourceType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case replicationInstance = "replication-instance"
        public var description: String { return self.rawValue }
    }

    public enum SqlServerAuthenticationMethod: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case kerberos = "kerberos"
        case password = "password"
        public var description: String { return self.rawValue }
    }

    public enum SslSecurityProtocolValue: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case plaintext = "plaintext"
        case sslEncryption = "ssl-encryption"
        public var description: String { return self.rawValue }
    }

    public enum StartReplicationMigrationTypeValue: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case reloadTarget = "reload-target"
        case resumeProcessing = "resume-processing"
        case startReplication = "start-replication"
        public var description: String { return self.rawValue }
    }

    public enum StartReplicationTaskTypeValue: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case reloadTarget = "reload-target"
        case resumeProcessing = "resume-processing"
        case startReplication = "start-replication"
        public var description: String { return self.rawValue }
    }

    public enum TablePreparationMode: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case doNothing = "do-nothing"
        case dropTablesOnTarget = "drop-tables-on-target"
        case truncate = "truncate"
        public var description: String { return self.rawValue }
    }

    public enum TargetDbType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case multipleDatabases = "multiple-databases"
        case specificDatabase = "specific-database"
        public var description: String { return self.rawValue }
    }

    public enum TlogAccessMode: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case backupOnly = "BackupOnly"
        case preferBackup = "PreferBackup"
        case preferTlog = "PreferTlog"
        case tlogOnly = "TlogOnly"
        public var description: String { return self.rawValue }
    }

    public enum VersionStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case outdated = "OUTDATED"
        case unsupported = "UNSUPPORTED"
        case upToDate = "UP_TO_DATE"
        public var description: String { return self.rawValue }
    }

    public enum DataProviderSettings: AWSEncodableShape & AWSDecodableShape, Sendable {
        case docDbSettings(DocDbDataProviderSettings)
        /// Provides information that defines an IBM DB2 LUW data provider.
        case ibmDb2LuwSettings(IbmDb2LuwDataProviderSettings)
        /// Provides information that defines an IBM DB2 for z/OS data provider.
        case ibmDb2zOsSettings(IbmDb2zOsDataProviderSettings)
        /// Provides information that defines a MariaDB data provider.
        case mariaDbSettings(MariaDbDataProviderSettings)
        case microsoftSqlServerSettings(MicrosoftSqlServerDataProviderSettings)
        /// Provides information that defines a MongoDB data provider.
        case mongoDbSettings(MongoDbDataProviderSettings)
        case mySqlSettings(MySqlDataProviderSettings)
        case oracleSettings(OracleDataProviderSettings)
        case postgreSqlSettings(PostgreSqlDataProviderSettings)
        case redshiftSettings(RedshiftDataProviderSettings)

        public init(from decoder: Decoder) throws {
            let container = try decoder.container(keyedBy: CodingKeys.self)
            guard container.allKeys.count == 1, let key = container.allKeys.first else {
                let context = DecodingError.Context(
                    codingPath: container.codingPath,
                    debugDescription: "Expected exactly one key, but got \(container.allKeys.count)"
                )
                throw DecodingError.dataCorrupted(context)
            }
            switch key {
            case .docDbSettings:
                let value = try container.decode(DocDbDataProviderSettings.self, forKey: .docDbSettings)
                self = .docDbSettings(value)
            case .ibmDb2LuwSettings:
                let value = try container.decode(IbmDb2LuwDataProviderSettings.self, forKey: .ibmDb2LuwSettings)
                self = .ibmDb2LuwSettings(value)
            case .ibmDb2zOsSettings:
                let value = try container.decode(IbmDb2zOsDataProviderSettings.self, forKey: .ibmDb2zOsSettings)
                self = .ibmDb2zOsSettings(value)
            case .mariaDbSettings:
                let value = try container.decode(MariaDbDataProviderSettings.self, forKey: .mariaDbSettings)
                self = .mariaDbSettings(value)
            case .microsoftSqlServerSettings:
                let value = try container.decode(MicrosoftSqlServerDataProviderSettings.self, forKey: .microsoftSqlServerSettings)
                self = .microsoftSqlServerSettings(value)
            case .mongoDbSettings:
                let value = try container.decode(MongoDbDataProviderSettings.self, forKey: .mongoDbSettings)
                self = .mongoDbSettings(value)
            case .mySqlSettings:
                let value = try container.decode(MySqlDataProviderSettings.self, forKey: .mySqlSettings)
                self = .mySqlSettings(value)
            case .oracleSettings:
                let value = try container.decode(OracleDataProviderSettings.self, forKey: .oracleSettings)
                self = .oracleSettings(value)
            case .postgreSqlSettings:
                let value = try container.decode(PostgreSqlDataProviderSettings.self, forKey: .postgreSqlSettings)
                self = .postgreSqlSettings(value)
            case .redshiftSettings:
                let value = try container.decode(RedshiftDataProviderSettings.self, forKey: .redshiftSettings)
                self = .redshiftSettings(value)
            }
        }

        public func encode(to encoder: Encoder) throws {
            var container = encoder.container(keyedBy: CodingKeys.self)
            switch self {
            case .docDbSettings(let value):
                try container.encode(value, forKey: .docDbSettings)
            case .ibmDb2LuwSettings(let value):
                try container.encode(value, forKey: .ibmDb2LuwSettings)
            case .ibmDb2zOsSettings(let value):
                try container.encode(value, forKey: .ibmDb2zOsSettings)
            case .mariaDbSettings(let value):
                try container.encode(value, forKey: .mariaDbSettings)
            case .microsoftSqlServerSettings(let value):
                try container.encode(value, forKey: .microsoftSqlServerSettings)
            case .mongoDbSettings(let value):
                try container.encode(value, forKey: .mongoDbSettings)
            case .mySqlSettings(let value):
                try container.encode(value, forKey: .mySqlSettings)
            case .oracleSettings(let value):
                try container.encode(value, forKey: .oracleSettings)
            case .postgreSqlSettings(let value):
                try container.encode(value, forKey: .postgreSqlSettings)
            case .redshiftSettings(let value):
                try container.encode(value, forKey: .redshiftSettings)
            }
        }

        private enum CodingKeys: String, CodingKey {
            case docDbSettings = "DocDbSettings"
            case ibmDb2LuwSettings = "IbmDb2LuwSettings"
            case ibmDb2zOsSettings = "IbmDb2zOsSettings"
            case mariaDbSettings = "MariaDbSettings"
            case microsoftSqlServerSettings = "MicrosoftSqlServerSettings"
            case mongoDbSettings = "MongoDbSettings"
            case mySqlSettings = "MySqlSettings"
            case oracleSettings = "OracleSettings"
            case postgreSqlSettings = "PostgreSqlSettings"
            case redshiftSettings = "RedshiftSettings"
        }
    }

    // MARK: Shapes

    public struct AccountQuota: AWSDecodableShape {
        /// The name of the DMS quota for this Amazon Web Services account.
        public let accountQuotaName: String?
        /// The maximum allowed value for the quota.
        public let max: Int64?
        /// The amount currently used toward the quota maximum.
        public let used: Int64?

        @inlinable
        public init(accountQuotaName: String? = nil, max: Int64? = nil, used: Int64? = nil) {
            self.accountQuotaName = accountQuotaName
            self.max = max
            self.used = used
        }

        private enum CodingKeys: String, CodingKey {
            case accountQuotaName = "AccountQuotaName"
            case max = "Max"
            case used = "Used"
        }
    }

    public struct AddTagsToResourceMessage: AWSEncodableShape {
        /// Identifies the DMS resource to which tags should be added. The value for this parameter is an Amazon Resource Name (ARN). For DMS, you can tag a replication instance, an endpoint, or a replication task.
        public let resourceArn: String
        /// One or more tags to be assigned to the resource.
        public let tags: [Tag]

        @inlinable
        public init(resourceArn: String, tags: [Tag]) {
            self.resourceArn = resourceArn
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case resourceArn = "ResourceArn"
            case tags = "Tags"
        }
    }

    public struct AddTagsToResourceResponse: AWSDecodableShape {
        public init() {}
    }

    public struct ApplyPendingMaintenanceActionMessage: AWSEncodableShape {
        /// The pending maintenance action to apply to this resource. Valid values: os-upgrade, system-update, db-upgrade, os-patch
        public let applyAction: String
        /// A value that specifies the type of opt-in request, or undoes an opt-in request. You can't undo an opt-in request of type immediate. Valid values:    immediate - Apply the maintenance action immediately.    next-maintenance - Apply the maintenance action during the next maintenance window for the resource.    undo-opt-in - Cancel any existing next-maintenance opt-in requests.
        public let optInType: String
        /// The Amazon Resource Name (ARN) of the DMS resource that the pending maintenance action applies to.
        public let replicationInstanceArn: String

        @inlinable
        public init(applyAction: String, optInType: String, replicationInstanceArn: String) {
            self.applyAction = applyAction
            self.optInType = optInType
            self.replicationInstanceArn = replicationInstanceArn
        }

        private enum CodingKeys: String, CodingKey {
            case applyAction = "ApplyAction"
            case optInType = "OptInType"
            case replicationInstanceArn = "ReplicationInstanceArn"
        }
    }

    public struct ApplyPendingMaintenanceActionResponse: AWSDecodableShape {
        /// The DMS resource that the pending maintenance action will be applied to.
        public let resourcePendingMaintenanceActions: ResourcePendingMaintenanceActions?

        @inlinable
        public init(resourcePendingMaintenanceActions: ResourcePendingMaintenanceActions? = nil) {
            self.resourcePendingMaintenanceActions = resourcePendingMaintenanceActions
        }

        private enum CodingKeys: String, CodingKey {
            case resourcePendingMaintenanceActions = "ResourcePendingMaintenanceActions"
        }
    }

    public struct AvailabilityZone: AWSDecodableShape {
        /// The name of the Availability Zone.
        public let name: String?

        @inlinable
        public init(name: String? = nil) {
            self.name = name
        }

        private enum CodingKeys: String, CodingKey {
            case name = "Name"
        }
    }

    public struct BatchStartRecommendationsErrorEntry: AWSDecodableShape {
        /// The code of an error that occurred during the analysis of the source database.
        public let code: String?
        /// The identifier of the source database.
        public let databaseId: String?
        /// The information about the error.
        public let message: String?

        @inlinable
        public init(code: String? = nil, databaseId: String? = nil, message: String? = nil) {
            self.code = code
            self.databaseId = databaseId
            self.message = message
        }

        private enum CodingKeys: String, CodingKey {
            case code = "Code"
            case databaseId = "DatabaseId"
            case message = "Message"
        }
    }

    public struct BatchStartRecommendationsRequest: AWSEncodableShape {
        /// Provides information about source databases to analyze. After this analysis, Fleet Advisor recommends target engines for each source database.
        public let data: [StartRecommendationsRequestEntry]?

        @inlinable
        public init(data: [StartRecommendationsRequestEntry]? = nil) {
            self.data = data
        }

        private enum CodingKeys: String, CodingKey {
            case data = "Data"
        }
    }

    public struct BatchStartRecommendationsResponse: AWSDecodableShape {
        /// A list with error details about the analysis of each source database.
        public let errorEntries: [BatchStartRecommendationsErrorEntry]?

        @inlinable
        public init(errorEntries: [BatchStartRecommendationsErrorEntry]? = nil) {
            self.errorEntries = errorEntries
        }

        private enum CodingKeys: String, CodingKey {
            case errorEntries = "ErrorEntries"
        }
    }

    public struct CancelReplicationTaskAssessmentRunMessage: AWSEncodableShape {
        /// Amazon Resource Name (ARN) of the premigration assessment run to be canceled.
        public let replicationTaskAssessmentRunArn: String

        @inlinable
        public init(replicationTaskAssessmentRunArn: String) {
            self.replicationTaskAssessmentRunArn = replicationTaskAssessmentRunArn
        }

        private enum CodingKeys: String, CodingKey {
            case replicationTaskAssessmentRunArn = "ReplicationTaskAssessmentRunArn"
        }
    }

    public struct CancelReplicationTaskAssessmentRunResponse: AWSDecodableShape {
        /// The ReplicationTaskAssessmentRun object for the canceled assessment run.
        public let replicationTaskAssessmentRun: ReplicationTaskAssessmentRun?

        @inlinable
        public init(replicationTaskAssessmentRun: ReplicationTaskAssessmentRun? = nil) {
            self.replicationTaskAssessmentRun = replicationTaskAssessmentRun
        }

        private enum CodingKeys: String, CodingKey {
            case replicationTaskAssessmentRun = "ReplicationTaskAssessmentRun"
        }
    }

    public struct Certificate: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) for the certificate.
        public let certificateArn: String?
        /// The date that the certificate was created.
        public let certificateCreationDate: Date?
        /// A customer-assigned name for the certificate. Identifiers must begin with a letter and must contain only ASCII letters, digits, and hyphens. They can't end with a hyphen or contain two consecutive hyphens.
        public let certificateIdentifier: String?
        /// The owner of the certificate.
        public let certificateOwner: String?
        /// The contents of a .pem file, which contains an X.509 certificate.
        public let certificatePem: String?
        /// The location of an imported Oracle Wallet certificate for use with SSL. Example: filebase64("${path.root}/rds-ca-2019-root.sso")
        public let certificateWallet: AWSBase64Data?
        /// The key length of the cryptographic algorithm being used.
        public let keyLength: Int?
        /// The signing algorithm for the certificate.
        public let signingAlgorithm: String?
        /// The beginning date that the certificate is valid.
        public let validFromDate: Date?
        /// The final date that the certificate is valid.
        public let validToDate: Date?

        @inlinable
        public init(certificateArn: String? = nil, certificateCreationDate: Date? = nil, certificateIdentifier: String? = nil, certificateOwner: String? = nil, certificatePem: String? = nil, certificateWallet: AWSBase64Data? = nil, keyLength: Int? = nil, signingAlgorithm: String? = nil, validFromDate: Date? = nil, validToDate: Date? = nil) {
            self.certificateArn = certificateArn
            self.certificateCreationDate = certificateCreationDate
            self.certificateIdentifier = certificateIdentifier
            self.certificateOwner = certificateOwner
            self.certificatePem = certificatePem
            self.certificateWallet = certificateWallet
            self.keyLength = keyLength
            self.signingAlgorithm = signingAlgorithm
            self.validFromDate = validFromDate
            self.validToDate = validToDate
        }

        private enum CodingKeys: String, CodingKey {
            case certificateArn = "CertificateArn"
            case certificateCreationDate = "CertificateCreationDate"
            case certificateIdentifier = "CertificateIdentifier"
            case certificateOwner = "CertificateOwner"
            case certificatePem = "CertificatePem"
            case certificateWallet = "CertificateWallet"
            case keyLength = "KeyLength"
            case signingAlgorithm = "SigningAlgorithm"
            case validFromDate = "ValidFromDate"
            case validToDate = "ValidToDate"
        }
    }

    public struct CollectorHealthCheck: AWSDecodableShape {
        /// The status of the Fleet Advisor collector.
        public let collectorStatus: CollectorStatus?
        /// Whether the local collector can access its Amazon S3 bucket.
        public let localCollectorS3Access: Bool?
        /// Whether the role that you provided when creating the Fleet Advisor collector has sufficient permissions to access the Fleet Advisor web collector.
        public let webCollectorGrantedRoleBasedAccess: Bool?
        /// Whether the web collector can access its Amazon S3 bucket.
        public let webCollectorS3Access: Bool?

        @inlinable
        public init(collectorStatus: CollectorStatus? = nil, localCollectorS3Access: Bool? = nil, webCollectorGrantedRoleBasedAccess: Bool? = nil, webCollectorS3Access: Bool? = nil) {
            self.collectorStatus = collectorStatus
            self.localCollectorS3Access = localCollectorS3Access
            self.webCollectorGrantedRoleBasedAccess = webCollectorGrantedRoleBasedAccess
            self.webCollectorS3Access = webCollectorS3Access
        }

        private enum CodingKeys: String, CodingKey {
            case collectorStatus = "CollectorStatus"
            case localCollectorS3Access = "LocalCollectorS3Access"
            case webCollectorGrantedRoleBasedAccess = "WebCollectorGrantedRoleBasedAccess"
            case webCollectorS3Access = "WebCollectorS3Access"
        }
    }

    public struct CollectorResponse: AWSDecodableShape {
        public let collectorHealthCheck: CollectorHealthCheck?
        /// The name of the Fleet Advisor collector .
        public let collectorName: String?
        /// The reference ID of the Fleet Advisor collector.
        public let collectorReferencedId: String?
        /// The version of your Fleet Advisor collector, in semantic versioning format, for example 1.0.2
        public let collectorVersion: String?
        /// The timestamp when you created the collector, in the following format: 2022-01-24T19:04:02.596113Z
        public let createdDate: String?
        /// A summary description of the Fleet Advisor collector.
        public let description: String?
        public let inventoryData: InventoryData?
        /// The timestamp of the last time the collector received data, in the following format: 2022-01-24T19:04:02.596113Z
        public let lastDataReceived: String?
        /// The timestamp when DMS last modified the collector, in the following format: 2022-01-24T19:04:02.596113Z
        public let modifiedDate: String?
        /// The timestamp when DMS registered the collector, in the following format: 2022-01-24T19:04:02.596113Z
        public let registeredDate: String?
        /// The Amazon S3 bucket that the Fleet Advisor collector uses to store inventory metadata.
        public let s3BucketName: String?
        /// The IAM role that grants permissions to access the specified Amazon S3 bucket.
        public let serviceAccessRoleArn: String?
        /// Whether the collector version is up to date.
        public let versionStatus: VersionStatus?

        @inlinable
        public init(collectorHealthCheck: CollectorHealthCheck? = nil, collectorName: String? = nil, collectorReferencedId: String? = nil, collectorVersion: String? = nil, createdDate: String? = nil, description: String? = nil, inventoryData: InventoryData? = nil, lastDataReceived: String? = nil, modifiedDate: String? = nil, registeredDate: String? = nil, s3BucketName: String? = nil, serviceAccessRoleArn: String? = nil, versionStatus: VersionStatus? = nil) {
            self.collectorHealthCheck = collectorHealthCheck
            self.collectorName = collectorName
            self.collectorReferencedId = collectorReferencedId
            self.collectorVersion = collectorVersion
            self.createdDate = createdDate
            self.description = description
            self.inventoryData = inventoryData
            self.lastDataReceived = lastDataReceived
            self.modifiedDate = modifiedDate
            self.registeredDate = registeredDate
            self.s3BucketName = s3BucketName
            self.serviceAccessRoleArn = serviceAccessRoleArn
            self.versionStatus = versionStatus
        }

        private enum CodingKeys: String, CodingKey {
            case collectorHealthCheck = "CollectorHealthCheck"
            case collectorName = "CollectorName"
            case collectorReferencedId = "CollectorReferencedId"
            case collectorVersion = "CollectorVersion"
            case createdDate = "CreatedDate"
            case description = "Description"
            case inventoryData = "InventoryData"
            case lastDataReceived = "LastDataReceived"
            case modifiedDate = "ModifiedDate"
            case registeredDate = "RegisteredDate"
            case s3BucketName = "S3BucketName"
            case serviceAccessRoleArn = "ServiceAccessRoleArn"
            case versionStatus = "VersionStatus"
        }
    }

    public struct CollectorShortInfoResponse: AWSDecodableShape {
        /// The name of the Fleet Advisor collector.
        public let collectorName: String?
        /// The reference ID of the Fleet Advisor collector.
        public let collectorReferencedId: String?

        @inlinable
        public init(collectorName: String? = nil, collectorReferencedId: String? = nil) {
            self.collectorName = collectorName
            self.collectorReferencedId = collectorReferencedId
        }

        private enum CodingKeys: String, CodingKey {
            case collectorName = "CollectorName"
            case collectorReferencedId = "CollectorReferencedId"
        }
    }

    public struct ComputeConfig: AWSEncodableShape & AWSDecodableShape {
        /// The Availability Zone where the DMS Serverless replication using this configuration will run. The default value is a random, system-chosen Availability Zone in the configuration's Amazon Web Services Region, for example, "us-west-2". You can't set this parameter if the MultiAZ parameter is set to true.
        public let availabilityZone: String?
        /// A list of custom DNS name servers supported for the DMS Serverless replication to access your source or target database. This list overrides the default name servers supported by the DMS Serverless replication. You can specify a comma-separated list of internet addresses for up to four DNS name servers. For example: "1.1.1.1,2.2.2.2,3.3.3.3,4.4.4.4"
        public let dnsNameServers: String?
        /// An Key Management Service (KMS) key Amazon Resource Name (ARN) that is used to encrypt the data during DMS Serverless replication. If you don't specify a value for the KmsKeyId parameter, DMS uses your default encryption key. KMS creates the default encryption key for your Amazon Web Services account. Your Amazon Web Services account has a different default encryption key for each Amazon Web Services Region.
        public let kmsKeyId: String?
        /// Specifies the maximum value of the DMS capacity units (DCUs) for which a given DMS Serverless replication can be provisioned. A single DCU is 2GB of RAM, with 1 DCU as the minimum value allowed. The list of valid DCU values includes 1, 2, 4, 8, 16, 32, 64, 128, 192, 256, and 384. So, the maximum value that you can specify for DMS Serverless is 384. The MaxCapacityUnits parameter is the only DCU parameter you are required to specify.
        public let maxCapacityUnits: Int?
        /// Specifies the minimum value of the DMS capacity units (DCUs) for which a given DMS Serverless replication can be provisioned. A single DCU is 2GB of RAM, with 1 DCU as the minimum value allowed. The list of valid DCU values includes 1, 2, 4, 8, 16, 32, 64, 128, 192, 256, and 384. So, the minimum DCU value that you can specify for DMS Serverless is 1. If you don't set this value, DMS sets this parameter to the minimum DCU value allowed, 1. If there is no current source activity, DMS scales down your replication until it reaches the value specified in MinCapacityUnits.
        public let minCapacityUnits: Int?
        /// Specifies whether the DMS Serverless replication is a Multi-AZ deployment. You can't set the AvailabilityZone parameter if the MultiAZ parameter is set to true.
        public let multiAZ: Bool?
        /// The weekly time range during which system maintenance can occur for the DMS Serverless replication, in Universal Coordinated Time (UTC). The format is ddd:hh24:mi-ddd:hh24:mi. The default is a 30-minute window selected at random from an 8-hour block of time per Amazon Web Services Region. This maintenance occurs on a random day of the week. Valid values for days of the week include Mon, Tue, Wed, Thu, Fri, Sat, and Sun. Constraints include a minimum 30-minute window.
        public let preferredMaintenanceWindow: String?
        /// Specifies a subnet group identifier to associate with the DMS Serverless replication.
        public let replicationSubnetGroupId: String?
        /// Specifies the virtual private cloud (VPC) security group to use with the DMS Serverless replication. The VPC security group must work with the VPC containing the replication.
        public let vpcSecurityGroupIds: [String]?

        @inlinable
        public init(availabilityZone: String? = nil, dnsNameServers: String? = nil, kmsKeyId: String? = nil, maxCapacityUnits: Int? = nil, minCapacityUnits: Int? = nil, multiAZ: Bool? = nil, preferredMaintenanceWindow: String? = nil, replicationSubnetGroupId: String? = nil, vpcSecurityGroupIds: [String]? = nil) {
            self.availabilityZone = availabilityZone
            self.dnsNameServers = dnsNameServers
            self.kmsKeyId = kmsKeyId
            self.maxCapacityUnits = maxCapacityUnits
            self.minCapacityUnits = minCapacityUnits
            self.multiAZ = multiAZ
            self.preferredMaintenanceWindow = preferredMaintenanceWindow
            self.replicationSubnetGroupId = replicationSubnetGroupId
            self.vpcSecurityGroupIds = vpcSecurityGroupIds
        }

        private enum CodingKeys: String, CodingKey {
            case availabilityZone = "AvailabilityZone"
            case dnsNameServers = "DnsNameServers"
            case kmsKeyId = "KmsKeyId"
            case maxCapacityUnits = "MaxCapacityUnits"
            case minCapacityUnits = "MinCapacityUnits"
            case multiAZ = "MultiAZ"
            case preferredMaintenanceWindow = "PreferredMaintenanceWindow"
            case replicationSubnetGroupId = "ReplicationSubnetGroupId"
            case vpcSecurityGroupIds = "VpcSecurityGroupIds"
        }
    }

    public struct Connection: AWSDecodableShape {
        /// The ARN string that uniquely identifies the endpoint.
        public let endpointArn: String?
        /// The identifier of the endpoint. Identifiers must begin with a letter and must contain only ASCII letters, digits, and hyphens. They can't end with a hyphen or contain two consecutive hyphens.
        public let endpointIdentifier: String?
        /// The error message when the connection last failed.
        public let lastFailureMessage: String?
        /// The ARN of the replication instance.
        public let replicationInstanceArn: String?
        /// The replication instance identifier. This parameter is stored as a lowercase string.
        public let replicationInstanceIdentifier: String?
        /// The connection status. This parameter can return one of the following values:    "successful"     "testing"     "failed"     "deleting"
        public let status: String?

        @inlinable
        public init(endpointArn: String? = nil, endpointIdentifier: String? = nil, lastFailureMessage: String? = nil, replicationInstanceArn: String? = nil, replicationInstanceIdentifier: String? = nil, status: String? = nil) {
            self.endpointArn = endpointArn
            self.endpointIdentifier = endpointIdentifier
            self.lastFailureMessage = lastFailureMessage
            self.replicationInstanceArn = replicationInstanceArn
            self.replicationInstanceIdentifier = replicationInstanceIdentifier
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case endpointArn = "EndpointArn"
            case endpointIdentifier = "EndpointIdentifier"
            case lastFailureMessage = "LastFailureMessage"
            case replicationInstanceArn = "ReplicationInstanceArn"
            case replicationInstanceIdentifier = "ReplicationInstanceIdentifier"
            case status = "Status"
        }
    }

    public struct CreateDataMigrationMessage: AWSEncodableShape {
        /// A user-friendly name for the data migration. Data migration names have the following constraints:   Must begin with a letter, and can only contain ASCII letters, digits, and hyphens.    Can't end with a hyphen or contain two consecutive hyphens.   Length must be from 1 to 255 characters.
        public let dataMigrationName: String?
        /// Specifies if the data migration is full-load only, change data capture (CDC) only, or full-load and CDC.
        public let dataMigrationType: MigrationTypeValue
        /// Specifies whether to enable CloudWatch logs for the data migration.
        public let enableCloudwatchLogs: Bool?
        /// An identifier for the migration project.
        public let migrationProjectIdentifier: String
        /// The number of parallel jobs that trigger parallel threads to unload the tables from the source, and then load them to the target.
        public let numberOfJobs: Int?
        /// An optional JSON string specifying what tables, views, and schemas to include or exclude from the migration.
        public let selectionRules: String?
        /// The Amazon Resource Name (ARN) for the service access role that you want to use to create the data migration.
        public let serviceAccessRoleArn: String
        /// Specifies information about the source data provider.
        public let sourceDataSettings: [SourceDataSetting]?
        /// One or more tags to be assigned to the data migration.
        public let tags: [Tag]?
        /// Specifies information about the target data provider.
        public let targetDataSettings: [TargetDataSetting]?

        @inlinable
        public init(dataMigrationName: String? = nil, dataMigrationType: MigrationTypeValue, enableCloudwatchLogs: Bool? = nil, migrationProjectIdentifier: String, numberOfJobs: Int? = nil, selectionRules: String? = nil, serviceAccessRoleArn: String, sourceDataSettings: [SourceDataSetting]? = nil, tags: [Tag]? = nil, targetDataSettings: [TargetDataSetting]? = nil) {
            self.dataMigrationName = dataMigrationName
            self.dataMigrationType = dataMigrationType
            self.enableCloudwatchLogs = enableCloudwatchLogs
            self.migrationProjectIdentifier = migrationProjectIdentifier
            self.numberOfJobs = numberOfJobs
            self.selectionRules = selectionRules
            self.serviceAccessRoleArn = serviceAccessRoleArn
            self.sourceDataSettings = sourceDataSettings
            self.tags = tags
            self.targetDataSettings = targetDataSettings
        }

        private enum CodingKeys: String, CodingKey {
            case dataMigrationName = "DataMigrationName"
            case dataMigrationType = "DataMigrationType"
            case enableCloudwatchLogs = "EnableCloudwatchLogs"
            case migrationProjectIdentifier = "MigrationProjectIdentifier"
            case numberOfJobs = "NumberOfJobs"
            case selectionRules = "SelectionRules"
            case serviceAccessRoleArn = "ServiceAccessRoleArn"
            case sourceDataSettings = "SourceDataSettings"
            case tags = "Tags"
            case targetDataSettings = "TargetDataSettings"
        }
    }

    public struct CreateDataMigrationResponse: AWSDecodableShape {
        /// Information about the created data migration.
        public let dataMigration: DataMigration?

        @inlinable
        public init(dataMigration: DataMigration? = nil) {
            self.dataMigration = dataMigration
        }

        private enum CodingKeys: String, CodingKey {
            case dataMigration = "DataMigration"
        }
    }

    public struct CreateDataProviderMessage: AWSEncodableShape {
        /// A user-friendly name for the data provider.
        public let dataProviderName: String?
        /// A user-friendly description of the data provider.
        public let description: String?
        /// The type of database engine for the data provider. Valid values include "aurora",  "aurora-postgresql", "mysql", "oracle", "postgres",  "sqlserver", redshift, mariadb, mongodb, db2, db2-zos and docdb. A value of "aurora" represents Amazon Aurora MySQL-Compatible Edition.
        public let engine: String
        /// The settings in JSON format for a data provider.
        public let settings: DataProviderSettings
        /// One or more tags to be assigned to the data provider.
        public let tags: [Tag]?

        @inlinable
        public init(dataProviderName: String? = nil, description: String? = nil, engine: String, settings: DataProviderSettings, tags: [Tag]? = nil) {
            self.dataProviderName = dataProviderName
            self.description = description
            self.engine = engine
            self.settings = settings
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case dataProviderName = "DataProviderName"
            case description = "Description"
            case engine = "Engine"
            case settings = "Settings"
            case tags = "Tags"
        }
    }

    public struct CreateDataProviderResponse: AWSDecodableShape {
        /// The data provider that was created.
        public let dataProvider: DataProvider?

        @inlinable
        public init(dataProvider: DataProvider? = nil) {
            self.dataProvider = dataProvider
        }

        private enum CodingKeys: String, CodingKey {
            case dataProvider = "DataProvider"
        }
    }

    public struct CreateEndpointMessage: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) for the certificate.
        public let certificateArn: String?
        /// The name of the endpoint database. For a MySQL source or target endpoint, do not specify DatabaseName. To migrate to a specific database, use this setting and targetDbType.
        public let databaseName: String?
        /// The settings in JSON format for the DMS transfer type of source endpoint.  Possible settings include the following:    ServiceAccessRoleArn - The Amazon Resource Name (ARN) used by the service access IAM role. The role must allow the iam:PassRole action.    BucketName - The name of the S3 bucket to use.   Shorthand syntax for these settings is as follows: ServiceAccessRoleArn=string,BucketName=string  JSON syntax for these settings is as follows: { "ServiceAccessRoleArn": "string", "BucketName": "string", }
        public let dmsTransferSettings: DmsTransferSettings?
        public let docDbSettings: DocDbSettings?
        /// Settings in JSON format for the target Amazon DynamoDB endpoint. For information about other available settings, see Using Object Mapping to Migrate Data to DynamoDB in the Database Migration Service User Guide.
        public let dynamoDbSettings: DynamoDbSettings?
        /// Settings in JSON format for the target OpenSearch endpoint. For more information about the available settings, see Extra Connection Attributes When Using OpenSearch as a Target for DMS in the Database Migration Service User Guide.
        public let elasticsearchSettings: ElasticsearchSettings?
        /// The database endpoint identifier. Identifiers must begin with a letter and must contain only ASCII letters, digits, and hyphens. They can't end with a hyphen, or contain two consecutive hyphens.
        public let endpointIdentifier: String
        /// The type of endpoint. Valid values are source and target.
        public let endpointType: ReplicationEndpointTypeValue
        /// The type of engine for the endpoint. Valid values, depending on the EndpointType value, include "mysql", "oracle", "postgres", "mariadb", "aurora", "aurora-postgresql", "opensearch", "redshift", "s3", "db2", "db2-zos", "azuredb", "sybase", "dynamodb", "mongodb", "kinesis", "kafka", "elasticsearch", "docdb", "sqlserver", "neptune", "babelfish", redshift-serverless, aurora-serverless, aurora-postgresql-serverless, gcp-mysql, azure-sql-managed-instance, redis, dms-transfer.
        public let engineName: String
        /// The external table definition.
        public let externalTableDefinition: String?
        /// Additional attributes associated with the connection. Each attribute is specified as a name-value pair associated by an equal sign (=). Multiple attributes are separated by a semicolon (;) with no additional white space. For information on the attributes available for connecting your source or target endpoint, see Working with DMS Endpoints in the Database Migration Service User Guide.
        public let extraConnectionAttributes: String?
        /// Settings in JSON format for the source GCP MySQL endpoint.
        public let gcpMySQLSettings: GcpMySQLSettings?
        /// Settings in JSON format for the source IBM Db2 LUW endpoint. For information about other available settings, see Extra connection attributes when using Db2 LUW as a source for DMS in the Database Migration Service User Guide.
        public let ibmDb2Settings: IBMDb2Settings?
        /// Settings in JSON format for the target Apache Kafka endpoint. For more information about the available settings, see Using object mapping to migrate data to a Kafka topic in the Database Migration Service User Guide.
        public let kafkaSettings: KafkaSettings?
        /// Settings in JSON format for the target endpoint for Amazon Kinesis Data Streams. For more information about the available settings, see Using object mapping to migrate data to a Kinesis data stream in the Database Migration Service User Guide.
        public let kinesisSettings: KinesisSettings?
        /// An KMS key identifier that is used to encrypt the connection parameters for the endpoint. If you don't specify a value for the KmsKeyId parameter, then DMS uses your default encryption key. KMS creates the default encryption key for your Amazon Web Services account. Your Amazon Web Services account has a different default encryption key for each Amazon Web Services Region.
        public let kmsKeyId: String?
        /// Settings in JSON format for the source and target Microsoft SQL Server endpoint. For information about other available settings, see Extra connection attributes when using SQL Server as a source for DMS and Extra connection attributes when using SQL Server as a target for DMS in the Database Migration Service User Guide.
        public let microsoftSQLServerSettings: MicrosoftSQLServerSettings?
        /// Settings in JSON format for the source MongoDB endpoint. For more information about the available settings, see Endpoint configuration settings when using MongoDB as a source for Database Migration Service in the Database Migration Service User Guide.
        public let mongoDbSettings: MongoDbSettings?
        /// Settings in JSON format for the source and target MySQL endpoint. For information about other available settings, see Extra connection attributes when using MySQL as a source for DMS and Extra connection attributes when using a MySQL-compatible database as a target for DMS in the Database Migration Service User Guide.
        public let mySQLSettings: MySQLSettings?
        /// Settings in JSON format for the target Amazon Neptune endpoint. For more information about the available settings, see Specifying graph-mapping rules using Gremlin and R2RML for Amazon Neptune as a target in the Database Migration Service User Guide.
        public let neptuneSettings: NeptuneSettings?
        /// Settings in JSON format for the source and target Oracle endpoint. For information about other available settings, see Extra connection attributes when using Oracle as a source for DMS and  Extra connection attributes when using Oracle as a target for DMS in the Database Migration Service User Guide.
        public let oracleSettings: OracleSettings?
        /// The password to be used to log in to the endpoint database.
        public let password: String?
        /// The port used by the endpoint database.
        public let port: Int?
        /// Settings in JSON format for the source and target PostgreSQL endpoint. For information about other available settings, see Extra connection attributes when using PostgreSQL as a source for DMS and Extra connection attributes when using PostgreSQL as a target for DMS in the Database Migration Service User Guide.
        public let postgreSQLSettings: PostgreSQLSettings?
        /// Settings in JSON format for the target Redis endpoint.
        public let redisSettings: RedisSettings?
        public let redshiftSettings: RedshiftSettings?
        /// A friendly name for the resource identifier at the end of the EndpointArn response parameter that is returned in the created Endpoint object. The value for this parameter can have up to 31 characters. It can contain only ASCII letters, digits, and hyphen ('-'). Also, it can't end with a hyphen or contain two consecutive hyphens, and can only begin with a letter, such as Example-App-ARN1. For example, this value might result in the EndpointArn value arn:aws:dms:eu-west-1:012345678901:rep:Example-App-ARN1. If you don't specify a ResourceIdentifier value, DMS generates a default identifier value for the end of EndpointArn.
        public let resourceIdentifier: String?
        /// Settings in JSON format for the target Amazon S3 endpoint. For more information about the available settings, see Extra Connection Attributes When Using Amazon S3 as a Target for DMS in the Database Migration Service User Guide.
        public let s3Settings: S3Settings?
        /// The name of the server where the endpoint database resides.
        public let serverName: String?
        ///  The Amazon Resource Name (ARN) for the service access role that you want to use to create the endpoint. The role must allow the iam:PassRole action.
        public let serviceAccessRoleArn: String?
        /// The Secure Sockets Layer (SSL) mode to use for the SSL connection. The default is none
        public let sslMode: DmsSslModeValue?
        /// Settings in JSON format for the source and target SAP ASE endpoint. For information about other available settings, see Extra connection attributes when using SAP ASE as a source for DMS and Extra connection attributes when using SAP ASE as a target for DMS in the Database Migration Service User Guide.
        public let sybaseSettings: SybaseSettings?
        /// One or more tags to be assigned to the endpoint.
        public let tags: [Tag]?
        /// Settings in JSON format for the target Amazon Timestream endpoint.
        public let timestreamSettings: TimestreamSettings?
        /// The user name to be used to log in to the endpoint database.
        public let username: String?

        @inlinable
        public init(certificateArn: String? = nil, databaseName: String? = nil, dmsTransferSettings: DmsTransferSettings? = nil, docDbSettings: DocDbSettings? = nil, dynamoDbSettings: DynamoDbSettings? = nil, elasticsearchSettings: ElasticsearchSettings? = nil, endpointIdentifier: String, endpointType: ReplicationEndpointTypeValue, engineName: String, externalTableDefinition: String? = nil, extraConnectionAttributes: String? = nil, gcpMySQLSettings: GcpMySQLSettings? = nil, ibmDb2Settings: IBMDb2Settings? = nil, kafkaSettings: KafkaSettings? = nil, kinesisSettings: KinesisSettings? = nil, kmsKeyId: String? = nil, microsoftSQLServerSettings: MicrosoftSQLServerSettings? = nil, mongoDbSettings: MongoDbSettings? = nil, mySQLSettings: MySQLSettings? = nil, neptuneSettings: NeptuneSettings? = nil, oracleSettings: OracleSettings? = nil, password: String? = nil, port: Int? = nil, postgreSQLSettings: PostgreSQLSettings? = nil, redisSettings: RedisSettings? = nil, redshiftSettings: RedshiftSettings? = nil, resourceIdentifier: String? = nil, s3Settings: S3Settings? = nil, serverName: String? = nil, serviceAccessRoleArn: String? = nil, sslMode: DmsSslModeValue? = nil, sybaseSettings: SybaseSettings? = nil, tags: [Tag]? = nil, timestreamSettings: TimestreamSettings? = nil, username: String? = nil) {
            self.certificateArn = certificateArn
            self.databaseName = databaseName
            self.dmsTransferSettings = dmsTransferSettings
            self.docDbSettings = docDbSettings
            self.dynamoDbSettings = dynamoDbSettings
            self.elasticsearchSettings = elasticsearchSettings
            self.endpointIdentifier = endpointIdentifier
            self.endpointType = endpointType
            self.engineName = engineName
            self.externalTableDefinition = externalTableDefinition
            self.extraConnectionAttributes = extraConnectionAttributes
            self.gcpMySQLSettings = gcpMySQLSettings
            self.ibmDb2Settings = ibmDb2Settings
            self.kafkaSettings = kafkaSettings
            self.kinesisSettings = kinesisSettings
            self.kmsKeyId = kmsKeyId
            self.microsoftSQLServerSettings = microsoftSQLServerSettings
            self.mongoDbSettings = mongoDbSettings
            self.mySQLSettings = mySQLSettings
            self.neptuneSettings = neptuneSettings
            self.oracleSettings = oracleSettings
            self.password = password
            self.port = port
            self.postgreSQLSettings = postgreSQLSettings
            self.redisSettings = redisSettings
            self.redshiftSettings = redshiftSettings
            self.resourceIdentifier = resourceIdentifier
            self.s3Settings = s3Settings
            self.serverName = serverName
            self.serviceAccessRoleArn = serviceAccessRoleArn
            self.sslMode = sslMode
            self.sybaseSettings = sybaseSettings
            self.tags = tags
            self.timestreamSettings = timestreamSettings
            self.username = username
        }

        private enum CodingKeys: String, CodingKey {
            case certificateArn = "CertificateArn"
            case databaseName = "DatabaseName"
            case dmsTransferSettings = "DmsTransferSettings"
            case docDbSettings = "DocDbSettings"
            case dynamoDbSettings = "DynamoDbSettings"
            case elasticsearchSettings = "ElasticsearchSettings"
            case endpointIdentifier = "EndpointIdentifier"
            case endpointType = "EndpointType"
            case engineName = "EngineName"
            case externalTableDefinition = "ExternalTableDefinition"
            case extraConnectionAttributes = "ExtraConnectionAttributes"
            case gcpMySQLSettings = "GcpMySQLSettings"
            case ibmDb2Settings = "IBMDb2Settings"
            case kafkaSettings = "KafkaSettings"
            case kinesisSettings = "KinesisSettings"
            case kmsKeyId = "KmsKeyId"
            case microsoftSQLServerSettings = "MicrosoftSQLServerSettings"
            case mongoDbSettings = "MongoDbSettings"
            case mySQLSettings = "MySQLSettings"
            case neptuneSettings = "NeptuneSettings"
            case oracleSettings = "OracleSettings"
            case password = "Password"
            case port = "Port"
            case postgreSQLSettings = "PostgreSQLSettings"
            case redisSettings = "RedisSettings"
            case redshiftSettings = "RedshiftSettings"
            case resourceIdentifier = "ResourceIdentifier"
            case s3Settings = "S3Settings"
            case serverName = "ServerName"
            case serviceAccessRoleArn = "ServiceAccessRoleArn"
            case sslMode = "SslMode"
            case sybaseSettings = "SybaseSettings"
            case tags = "Tags"
            case timestreamSettings = "TimestreamSettings"
            case username = "Username"
        }
    }

    public struct CreateEndpointResponse: AWSDecodableShape {
        /// The endpoint that was created.
        public let endpoint: Endpoint?

        @inlinable
        public init(endpoint: Endpoint? = nil) {
            self.endpoint = endpoint
        }

        private enum CodingKeys: String, CodingKey {
            case endpoint = "Endpoint"
        }
    }

    public struct CreateEventSubscriptionMessage: AWSEncodableShape {
        ///  A Boolean value; set to true to activate the subscription, or set to false to create the subscription but not activate it.
        public let enabled: Bool?
        /// A list of event categories for a source type that you want to subscribe to. For more information, see Working with Events and Notifications in the Database Migration Service User Guide.
        public let eventCategories: [String]?
        ///  The Amazon Resource Name (ARN) of the Amazon SNS topic created for event notification. The ARN is created by Amazon SNS when you create a topic and subscribe to it.
        public let snsTopicArn: String
        /// A list of identifiers for which DMS provides notification events. If you don't specify a value, notifications are provided for all sources. If you specify multiple values, they must be of the same type. For example, if you specify a database instance ID, then all of the other values must be database instance IDs.
        public let sourceIds: [String]?
        ///  The type of DMS resource that generates the events. For example, if you want to be notified of events generated by a replication instance, you set this parameter to replication-instance. If this value isn't specified, all events are returned.  Valid values: replication-instance | replication-task
        public let sourceType: String?
        /// The name of the DMS event notification subscription. This name must be less than 255 characters.
        public let subscriptionName: String
        /// One or more tags to be assigned to the event subscription.
        public let tags: [Tag]?

        @inlinable
        public init(enabled: Bool? = nil, eventCategories: [String]? = nil, snsTopicArn: String, sourceIds: [String]? = nil, sourceType: String? = nil, subscriptionName: String, tags: [Tag]? = nil) {
            self.enabled = enabled
            self.eventCategories = eventCategories
            self.snsTopicArn = snsTopicArn
            self.sourceIds = sourceIds
            self.sourceType = sourceType
            self.subscriptionName = subscriptionName
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case enabled = "Enabled"
            case eventCategories = "EventCategories"
            case snsTopicArn = "SnsTopicArn"
            case sourceIds = "SourceIds"
            case sourceType = "SourceType"
            case subscriptionName = "SubscriptionName"
            case tags = "Tags"
        }
    }

    public struct CreateEventSubscriptionResponse: AWSDecodableShape {
        /// The event subscription that was created.
        public let eventSubscription: EventSubscription?

        @inlinable
        public init(eventSubscription: EventSubscription? = nil) {
            self.eventSubscription = eventSubscription
        }

        private enum CodingKeys: String, CodingKey {
            case eventSubscription = "EventSubscription"
        }
    }

    public struct CreateFleetAdvisorCollectorRequest: AWSEncodableShape {
        /// The name of your Fleet Advisor collector (for example, sample-collector).
        public let collectorName: String
        /// A summary description of your Fleet Advisor collector.
        public let description: String?
        /// The Amazon S3 bucket that the Fleet Advisor collector uses to store inventory metadata.
        public let s3BucketName: String
        /// The IAM role that grants permissions to access the specified Amazon S3 bucket.
        public let serviceAccessRoleArn: String

        @inlinable
        public init(collectorName: String, description: String? = nil, s3BucketName: String, serviceAccessRoleArn: String) {
            self.collectorName = collectorName
            self.description = description
            self.s3BucketName = s3BucketName
            self.serviceAccessRoleArn = serviceAccessRoleArn
        }

        private enum CodingKeys: String, CodingKey {
            case collectorName = "CollectorName"
            case description = "Description"
            case s3BucketName = "S3BucketName"
            case serviceAccessRoleArn = "ServiceAccessRoleArn"
        }
    }

    public struct CreateFleetAdvisorCollectorResponse: AWSDecodableShape {
        /// The name of the new Fleet Advisor collector.
        public let collectorName: String?
        /// The unique ID of the new Fleet Advisor collector, for example: 22fda70c-40d5-4acf-b233-a495bd8eb7f5
        public let collectorReferencedId: String?
        /// A summary description of the Fleet Advisor collector.
        public let description: String?
        /// The Amazon S3 bucket that the collector uses to store inventory metadata.
        public let s3BucketName: String?
        /// The IAM role that grants permissions to access the specified Amazon S3 bucket.
        public let serviceAccessRoleArn: String?

        @inlinable
        public init(collectorName: String? = nil, collectorReferencedId: String? = nil, description: String? = nil, s3BucketName: String? = nil, serviceAccessRoleArn: String? = nil) {
            self.collectorName = collectorName
            self.collectorReferencedId = collectorReferencedId
            self.description = description
            self.s3BucketName = s3BucketName
            self.serviceAccessRoleArn = serviceAccessRoleArn
        }

        private enum CodingKeys: String, CodingKey {
            case collectorName = "CollectorName"
            case collectorReferencedId = "CollectorReferencedId"
            case description = "Description"
            case s3BucketName = "S3BucketName"
            case serviceAccessRoleArn = "ServiceAccessRoleArn"
        }
    }

    public struct CreateInstanceProfileMessage: AWSEncodableShape {
        /// The Availability Zone where the instance profile will be created. The default value is a random, system-chosen Availability Zone in the Amazon Web Services Region where your  data provider is created, for examplem us-east-1d.
        public let availabilityZone: String?
        /// A user-friendly description of the instance profile.
        public let description: String?
        /// A user-friendly name for the instance profile.
        public let instanceProfileName: String?
        /// The Amazon Resource Name (ARN) of the KMS key that is used to encrypt  the connection parameters for the instance profile. If you don't specify a value for the KmsKeyArn parameter, then DMS uses your default encryption key. KMS creates the default encryption key for your Amazon Web Services account. Your Amazon Web Services account has a different default encryption key for each Amazon Web Services Region.
        public let kmsKeyArn: String?
        /// Specifies the network type for the instance profile. A value of IPV4  represents an instance profile with IPv4 network type and only supports IPv4 addressing.  A value of IPV6 represents an instance profile with IPv6 network type  and only supports IPv6 addressing. A value of DUAL represents an instance  profile with dual network type that supports IPv4 and IPv6 addressing.
        public let networkType: String?
        /// Specifies the accessibility options for the instance profile. A value of true represents an instance profile with a public IP address. A value of false represents an instance profile with a private IP address. The default value is true.
        public let publiclyAccessible: Bool?
        /// A subnet group to associate with the instance profile.
        public let subnetGroupIdentifier: String?
        /// One or more tags to be assigned to the instance profile.
        public let tags: [Tag]?
        /// Specifies the VPC security group names to be used with the instance profile.  The VPC security group must work with the VPC containing the instance profile.
        public let vpcSecurityGroups: [String]?

        @inlinable
        public init(availabilityZone: String? = nil, description: String? = nil, instanceProfileName: String? = nil, kmsKeyArn: String? = nil, networkType: String? = nil, publiclyAccessible: Bool? = nil, subnetGroupIdentifier: String? = nil, tags: [Tag]? = nil, vpcSecurityGroups: [String]? = nil) {
            self.availabilityZone = availabilityZone
            self.description = description
            self.instanceProfileName = instanceProfileName
            self.kmsKeyArn = kmsKeyArn
            self.networkType = networkType
            self.publiclyAccessible = publiclyAccessible
            self.subnetGroupIdentifier = subnetGroupIdentifier
            self.tags = tags
            self.vpcSecurityGroups = vpcSecurityGroups
        }

        private enum CodingKeys: String, CodingKey {
            case availabilityZone = "AvailabilityZone"
            case description = "Description"
            case instanceProfileName = "InstanceProfileName"
            case kmsKeyArn = "KmsKeyArn"
            case networkType = "NetworkType"
            case publiclyAccessible = "PubliclyAccessible"
            case subnetGroupIdentifier = "SubnetGroupIdentifier"
            case tags = "Tags"
            case vpcSecurityGroups = "VpcSecurityGroups"
        }
    }

    public struct CreateInstanceProfileResponse: AWSDecodableShape {
        /// The instance profile that was created.
        public let instanceProfile: InstanceProfile?

        @inlinable
        public init(instanceProfile: InstanceProfile? = nil) {
            self.instanceProfile = instanceProfile
        }

        private enum CodingKeys: String, CodingKey {
            case instanceProfile = "InstanceProfile"
        }
    }

    public struct CreateMigrationProjectMessage: AWSEncodableShape {
        /// A user-friendly description of the migration project.
        public let description: String?
        /// The identifier of the associated instance profile. Identifiers must begin with a letter  and must contain only ASCII letters, digits, and hyphens. They can't end with  a hyphen, or contain two consecutive hyphens.
        public let instanceProfileIdentifier: String
        /// A user-friendly name for the migration project.
        public let migrationProjectName: String?
        /// The schema conversion application attributes, including the Amazon S3 bucket name and Amazon S3 role ARN.
        public let schemaConversionApplicationAttributes: SCApplicationAttributes?
        /// Information about the source data provider, including the name, ARN, and Secrets Manager parameters.
        public let sourceDataProviderDescriptors: [DataProviderDescriptorDefinition]
        /// One or more tags to be assigned to the migration project.
        public let tags: [Tag]?
        /// Information about the target data provider, including the name, ARN, and Amazon Web Services Secrets Manager parameters.
        public let targetDataProviderDescriptors: [DataProviderDescriptorDefinition]
        /// The settings in JSON format for migration rules. Migration rules make it possible for you to change  the object names according to the rules that you specify. For example, you can change an object name  to lowercase or uppercase, add or remove a prefix or suffix, or rename objects.
        public let transformationRules: String?

        @inlinable
        public init(description: String? = nil, instanceProfileIdentifier: String, migrationProjectName: String? = nil, schemaConversionApplicationAttributes: SCApplicationAttributes? = nil, sourceDataProviderDescriptors: [DataProviderDescriptorDefinition], tags: [Tag]? = nil, targetDataProviderDescriptors: [DataProviderDescriptorDefinition], transformationRules: String? = nil) {
            self.description = description
            self.instanceProfileIdentifier = instanceProfileIdentifier
            self.migrationProjectName = migrationProjectName
            self.schemaConversionApplicationAttributes = schemaConversionApplicationAttributes
            self.sourceDataProviderDescriptors = sourceDataProviderDescriptors
            self.tags = tags
            self.targetDataProviderDescriptors = targetDataProviderDescriptors
            self.transformationRules = transformationRules
        }

        private enum CodingKeys: String, CodingKey {
            case description = "Description"
            case instanceProfileIdentifier = "InstanceProfileIdentifier"
            case migrationProjectName = "MigrationProjectName"
            case schemaConversionApplicationAttributes = "SchemaConversionApplicationAttributes"
            case sourceDataProviderDescriptors = "SourceDataProviderDescriptors"
            case tags = "Tags"
            case targetDataProviderDescriptors = "TargetDataProviderDescriptors"
            case transformationRules = "TransformationRules"
        }
    }

    public struct CreateMigrationProjectResponse: AWSDecodableShape {
        /// The migration project that was created.
        public let migrationProject: MigrationProject?

        @inlinable
        public init(migrationProject: MigrationProject? = nil) {
            self.migrationProject = migrationProject
        }

        private enum CodingKeys: String, CodingKey {
            case migrationProject = "MigrationProject"
        }
    }

    public struct CreateReplicationConfigMessage: AWSEncodableShape {
        /// Configuration parameters for provisioning an DMS Serverless replication.
        public let computeConfig: ComputeConfig
        /// A unique identifier that you want to use to create a ReplicationConfigArn that is returned as part of the output from this action. You can then pass this output ReplicationConfigArn as the value of the ReplicationConfigArn option for other actions to identify both DMS Serverless replications and replication configurations that you want those actions to operate on. For some actions, you can also use either this unique identifier or a corresponding ARN in action filters to identify the specific replication and replication configuration to operate on.
        public let replicationConfigIdentifier: String
        /// Optional JSON settings for DMS Serverless replications that are provisioned using this replication configuration. For example, see  Change processing tuning settings.
        public let replicationSettings: String?
        /// The type of DMS Serverless replication to provision using this replication configuration. Possible values:    "full-load"     "cdc"     "full-load-and-cdc"
        public let replicationType: MigrationTypeValue
        /// Optional unique value or name that you set for a given resource that can be used to construct an Amazon Resource Name (ARN) for that resource. For more information, see  Fine-grained access control using resource names and tags.
        public let resourceIdentifier: String?
        /// The Amazon Resource Name (ARN) of the source endpoint for this DMS Serverless replication configuration.
        public let sourceEndpointArn: String
        /// Optional JSON settings for specifying supplemental data. For more information, see  Specifying supplemental data for task settings.
        public let supplementalSettings: String?
        /// JSON table mappings for DMS Serverless replications that are provisioned using this replication configuration. For more information, see  Specifying table selection and transformations rules using JSON.
        public let tableMappings: String
        /// One or more optional tags associated with resources used by the DMS Serverless replication. For more information, see  Tagging resources in Database Migration Service.
        public let tags: [Tag]?
        /// The Amazon Resource Name (ARN) of the target endpoint for this DMS serverless replication configuration.
        public let targetEndpointArn: String

        @inlinable
        public init(computeConfig: ComputeConfig, replicationConfigIdentifier: String, replicationSettings: String? = nil, replicationType: MigrationTypeValue, resourceIdentifier: String? = nil, sourceEndpointArn: String, supplementalSettings: String? = nil, tableMappings: String, tags: [Tag]? = nil, targetEndpointArn: String) {
            self.computeConfig = computeConfig
            self.replicationConfigIdentifier = replicationConfigIdentifier
            self.replicationSettings = replicationSettings
            self.replicationType = replicationType
            self.resourceIdentifier = resourceIdentifier
            self.sourceEndpointArn = sourceEndpointArn
            self.supplementalSettings = supplementalSettings
            self.tableMappings = tableMappings
            self.tags = tags
            self.targetEndpointArn = targetEndpointArn
        }

        private enum CodingKeys: String, CodingKey {
            case computeConfig = "ComputeConfig"
            case replicationConfigIdentifier = "ReplicationConfigIdentifier"
            case replicationSettings = "ReplicationSettings"
            case replicationType = "ReplicationType"
            case resourceIdentifier = "ResourceIdentifier"
            case sourceEndpointArn = "SourceEndpointArn"
            case supplementalSettings = "SupplementalSettings"
            case tableMappings = "TableMappings"
            case tags = "Tags"
            case targetEndpointArn = "TargetEndpointArn"
        }
    }

    public struct CreateReplicationConfigResponse: AWSDecodableShape {
        /// Configuration parameters returned from the DMS Serverless replication after it is created.
        public let replicationConfig: ReplicationConfig?

        @inlinable
        public init(replicationConfig: ReplicationConfig? = nil) {
            self.replicationConfig = replicationConfig
        }

        private enum CodingKeys: String, CodingKey {
            case replicationConfig = "ReplicationConfig"
        }
    }

    public struct CreateReplicationInstanceMessage: AWSEncodableShape {
        /// The amount of storage (in gigabytes) to be initially allocated for the replication instance.
        public let allocatedStorage: Int?
        /// A value that indicates whether minor engine upgrades are applied automatically to the replication instance during the maintenance window. This parameter defaults to true. Default: true
        public let autoMinorVersionUpgrade: Bool?
        /// The Availability Zone where the replication instance will be created. The default value is a random, system-chosen Availability Zone in the endpoint's Amazon Web Services Region, for example: us-east-1d.
        public let availabilityZone: String?
        /// A list of custom DNS name servers supported for the replication instance to access your on-premise source or target database. This list overrides the default name servers supported by the replication instance. You can specify a comma-separated list of internet addresses for up to four on-premise DNS name servers. For example: "1.1.1.1,2.2.2.2,3.3.3.3,4.4.4.4"
        public let dnsNameServers: String?
        /// The engine version number of the replication instance. If an engine version number is not specified when a replication instance is created, the default is the latest engine version available.
        public let engineVersion: String?
        /// Specifies the settings required for kerberos authentication when creating the replication instance.
        public let kerberosAuthenticationSettings: KerberosAuthenticationSettings?
        /// An KMS key identifier that is used to encrypt the data on the replication instance. If you don't specify a value for the KmsKeyId parameter, then DMS uses your default encryption key. KMS creates the default encryption key for your Amazon Web Services account. Your Amazon Web Services account has a different default encryption key for each Amazon Web Services Region.
        public let kmsKeyId: String?
        ///  Specifies whether the replication instance is a Multi-AZ deployment. You can't set the AvailabilityZone parameter if the Multi-AZ parameter is set to true.
        public let multiAZ: Bool?
        /// The type of IP address protocol used by a replication instance, such as IPv4 only or Dual-stack that supports both IPv4 and IPv6 addressing. IPv6 only is not yet supported.
        public let networkType: String?
        /// The weekly time range during which system maintenance can occur, in Universal Coordinated Time (UTC). Format: ddd:hh24:mi-ddd:hh24:mi  Default: A 30-minute window selected at random from an 8-hour block of time per Amazon Web Services Region, occurring on a random day of the week. Valid Days: Mon, Tue, Wed, Thu, Fri, Sat, Sun Constraints: Minimum 30-minute window.
        public let preferredMaintenanceWindow: String?
        ///  Specifies the accessibility options for the replication instance. A value of true represents an instance with a public IP address. A value of false represents an instance with a private IP address. The default value is true.
        public let publiclyAccessible: Bool?
        /// The compute and memory capacity of the replication instance as defined for the specified replication instance class. For example to specify the instance class dms.c4.large, set this parameter to "dms.c4.large". For more information on the settings and capacities for the available replication instance classes, see  Choosing the right DMS replication instance; and, Selecting the best size for a replication instance.
        public let replicationInstanceClass: String
        /// The replication instance identifier. This parameter is stored as a lowercase string. Constraints:   Must contain 1-63 alphanumeric characters or hyphens.   First character must be a letter.   Can't end with a hyphen or contain two consecutive hyphens.   Example: myrepinstance
        public let replicationInstanceIdentifier: String
        /// A subnet group to associate with the replication instance.
        public let replicationSubnetGroupIdentifier: String?
        /// A friendly name for the resource identifier at the end of the EndpointArn response parameter that is returned in the created Endpoint object. The value for this parameter can have up to 31 characters. It can contain only ASCII letters, digits, and hyphen ('-'). Also, it can't end with a hyphen or contain two consecutive hyphens, and can only begin with a letter, such as Example-App-ARN1. For example, this value might result in the EndpointArn value arn:aws:dms:eu-west-1:012345678901:rep:Example-App-ARN1. If you don't specify a ResourceIdentifier value, DMS generates a default identifier value for the end of EndpointArn.
        public let resourceIdentifier: String?
        /// One or more tags to be assigned to the replication instance.
        public let tags: [Tag]?
        ///  Specifies the VPC security group to be used with the replication instance. The VPC security group must work with the VPC containing the replication instance.
        public let vpcSecurityGroupIds: [String]?

        @inlinable
        public init(allocatedStorage: Int? = nil, autoMinorVersionUpgrade: Bool? = nil, availabilityZone: String? = nil, dnsNameServers: String? = nil, engineVersion: String? = nil, kerberosAuthenticationSettings: KerberosAuthenticationSettings? = nil, kmsKeyId: String? = nil, multiAZ: Bool? = nil, networkType: String? = nil, preferredMaintenanceWindow: String? = nil, publiclyAccessible: Bool? = nil, replicationInstanceClass: String, replicationInstanceIdentifier: String, replicationSubnetGroupIdentifier: String? = nil, resourceIdentifier: String? = nil, tags: [Tag]? = nil, vpcSecurityGroupIds: [String]? = nil) {
            self.allocatedStorage = allocatedStorage
            self.autoMinorVersionUpgrade = autoMinorVersionUpgrade
            self.availabilityZone = availabilityZone
            self.dnsNameServers = dnsNameServers
            self.engineVersion = engineVersion
            self.kerberosAuthenticationSettings = kerberosAuthenticationSettings
            self.kmsKeyId = kmsKeyId
            self.multiAZ = multiAZ
            self.networkType = networkType
            self.preferredMaintenanceWindow = preferredMaintenanceWindow
            self.publiclyAccessible = publiclyAccessible
            self.replicationInstanceClass = replicationInstanceClass
            self.replicationInstanceIdentifier = replicationInstanceIdentifier
            self.replicationSubnetGroupIdentifier = replicationSubnetGroupIdentifier
            self.resourceIdentifier = resourceIdentifier
            self.tags = tags
            self.vpcSecurityGroupIds = vpcSecurityGroupIds
        }

        public func validate(name: String) throws {
            try self.validate(self.replicationInstanceClass, name: "replicationInstanceClass", parent: name, max: 30)
        }

        private enum CodingKeys: String, CodingKey {
            case allocatedStorage = "AllocatedStorage"
            case autoMinorVersionUpgrade = "AutoMinorVersionUpgrade"
            case availabilityZone = "AvailabilityZone"
            case dnsNameServers = "DnsNameServers"
            case engineVersion = "EngineVersion"
            case kerberosAuthenticationSettings = "KerberosAuthenticationSettings"
            case kmsKeyId = "KmsKeyId"
            case multiAZ = "MultiAZ"
            case networkType = "NetworkType"
            case preferredMaintenanceWindow = "PreferredMaintenanceWindow"
            case publiclyAccessible = "PubliclyAccessible"
            case replicationInstanceClass = "ReplicationInstanceClass"
            case replicationInstanceIdentifier = "ReplicationInstanceIdentifier"
            case replicationSubnetGroupIdentifier = "ReplicationSubnetGroupIdentifier"
            case resourceIdentifier = "ResourceIdentifier"
            case tags = "Tags"
            case vpcSecurityGroupIds = "VpcSecurityGroupIds"
        }
    }

    public struct CreateReplicationInstanceResponse: AWSDecodableShape {
        /// The replication instance that was created.
        public let replicationInstance: ReplicationInstance?

        @inlinable
        public init(replicationInstance: ReplicationInstance? = nil) {
            self.replicationInstance = replicationInstance
        }

        private enum CodingKeys: String, CodingKey {
            case replicationInstance = "ReplicationInstance"
        }
    }

    public struct CreateReplicationSubnetGroupMessage: AWSEncodableShape {
        /// The description for the subnet group.
        public let replicationSubnetGroupDescription: String
        /// The name for the replication subnet group. This value is stored as a lowercase string. Constraints: Must contain no more than 255 alphanumeric characters, periods, underscores, or hyphens. Must not be "default". Example: mySubnetgroup
        public let replicationSubnetGroupIdentifier: String
        /// Two or more subnet IDs to be assigned to the subnet group.
        public let subnetIds: [String]
        /// One or more tags to be assigned to the subnet group.
        public let tags: [Tag]?

        @inlinable
        public init(replicationSubnetGroupDescription: String, replicationSubnetGroupIdentifier: String, subnetIds: [String], tags: [Tag]? = nil) {
            self.replicationSubnetGroupDescription = replicationSubnetGroupDescription
            self.replicationSubnetGroupIdentifier = replicationSubnetGroupIdentifier
            self.subnetIds = subnetIds
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case replicationSubnetGroupDescription = "ReplicationSubnetGroupDescription"
            case replicationSubnetGroupIdentifier = "ReplicationSubnetGroupIdentifier"
            case subnetIds = "SubnetIds"
            case tags = "Tags"
        }
    }

    public struct CreateReplicationSubnetGroupResponse: AWSDecodableShape {
        /// The replication subnet group that was created.
        public let replicationSubnetGroup: ReplicationSubnetGroup?

        @inlinable
        public init(replicationSubnetGroup: ReplicationSubnetGroup? = nil) {
            self.replicationSubnetGroup = replicationSubnetGroup
        }

        private enum CodingKeys: String, CodingKey {
            case replicationSubnetGroup = "ReplicationSubnetGroup"
        }
    }

    public struct CreateReplicationTaskMessage: AWSEncodableShape {
        /// Indicates when you want a change data capture (CDC) operation to start. Use either CdcStartPosition or CdcStartTime to specify when you want a CDC operation to start. Specifying both values results in an error. The value can be in date, checkpoint, or LSN/SCN format. Date Example: --cdc-start-position 2018-03-08T12:12:12 Checkpoint Example: --cdc-start-position "checkpoint:V1#27#mysql-bin-changelog.157832:1975:-1:2002:677883278264080:mysql-bin-changelog.157832:1876#0#0#*#0#93" LSN Example: --cdc-start-position mysql-bin-changelog.000024:373  When you use this task setting with a source PostgreSQL database, a logical replication slot should already be created and associated with the source endpoint. You can verify this by setting the slotName extra connection attribute to the name of this logical replication slot. For more information, see Extra Connection Attributes When Using PostgreSQL as a Source for DMS.
        public let cdcStartPosition: String?
        /// Indicates the start time for a change data capture (CDC) operation. Use either CdcStartTime or CdcStartPosition to specify when you want a CDC operation to start. Specifying both values results in an error. Timestamp Example: --cdc-start-time 2018-03-08T12:12:12
        public let cdcStartTime: Date?
        /// Indicates when you want a change data capture (CDC) operation to stop. The value can be either server time or commit time. Server time example: --cdc-stop-position server_time:2018-02-09T12:12:12 Commit time example: --cdc-stop-position commit_time:2018-02-09T12:12:12
        public let cdcStopPosition: String?
        /// The migration type. Valid values: full-load | cdc | full-load-and-cdc
        public let migrationType: MigrationTypeValue
        /// The Amazon Resource Name (ARN) of a replication instance.
        public let replicationInstanceArn: String
        /// An identifier for the replication task. Constraints:   Must contain 1-255 alphanumeric characters or hyphens.   First character must be a letter.   Cannot end with a hyphen or contain two consecutive hyphens.
        public let replicationTaskIdentifier: String
        /// Overall settings for the task, in JSON format. For more information, see Specifying Task Settings for Database Migration Service Tasks in the Database Migration Service User Guide.
        public let replicationTaskSettings: String?
        /// A friendly name for the resource identifier at the end of the EndpointArn response parameter that is returned in the created Endpoint object. The value for this parameter can have up to 31 characters. It can contain only ASCII letters, digits, and hyphen ('-'). Also, it can't end with a hyphen or contain two consecutive hyphens, and can only begin with a letter, such as Example-App-ARN1. For example, this value might result in the EndpointArn value arn:aws:dms:eu-west-1:012345678901:rep:Example-App-ARN1. If you don't specify a ResourceIdentifier value, DMS generates a default identifier value for the end of EndpointArn.
        public let resourceIdentifier: String?
        /// An Amazon Resource Name (ARN) that uniquely identifies the source endpoint.
        public let sourceEndpointArn: String
        /// The table mappings for the task, in JSON format. For more information, see Using Table Mapping to Specify Task Settings in the Database Migration Service User Guide.
        public let tableMappings: String
        /// One or more tags to be assigned to the replication task.
        public let tags: [Tag]?
        /// An Amazon Resource Name (ARN) that uniquely identifies the target endpoint.
        public let targetEndpointArn: String
        /// Supplemental information that the task requires to migrate the data for certain source and target endpoints. For more information, see Specifying Supplemental Data for Task Settings in the Database Migration Service User Guide.
        public let taskData: String?

        @inlinable
        public init(cdcStartPosition: String? = nil, cdcStartTime: Date? = nil, cdcStopPosition: String? = nil, migrationType: MigrationTypeValue, replicationInstanceArn: String, replicationTaskIdentifier: String, replicationTaskSettings: String? = nil, resourceIdentifier: String? = nil, sourceEndpointArn: String, tableMappings: String, tags: [Tag]? = nil, targetEndpointArn: String, taskData: String? = nil) {
            self.cdcStartPosition = cdcStartPosition
            self.cdcStartTime = cdcStartTime
            self.cdcStopPosition = cdcStopPosition
            self.migrationType = migrationType
            self.replicationInstanceArn = replicationInstanceArn
            self.replicationTaskIdentifier = replicationTaskIdentifier
            self.replicationTaskSettings = replicationTaskSettings
            self.resourceIdentifier = resourceIdentifier
            self.sourceEndpointArn = sourceEndpointArn
            self.tableMappings = tableMappings
            self.tags = tags
            self.targetEndpointArn = targetEndpointArn
            self.taskData = taskData
        }

        private enum CodingKeys: String, CodingKey {
            case cdcStartPosition = "CdcStartPosition"
            case cdcStartTime = "CdcStartTime"
            case cdcStopPosition = "CdcStopPosition"
            case migrationType = "MigrationType"
            case replicationInstanceArn = "ReplicationInstanceArn"
            case replicationTaskIdentifier = "ReplicationTaskIdentifier"
            case replicationTaskSettings = "ReplicationTaskSettings"
            case resourceIdentifier = "ResourceIdentifier"
            case sourceEndpointArn = "SourceEndpointArn"
            case tableMappings = "TableMappings"
            case tags = "Tags"
            case targetEndpointArn = "TargetEndpointArn"
            case taskData = "TaskData"
        }
    }

    public struct CreateReplicationTaskResponse: AWSDecodableShape {
        /// The replication task that was created.
        public let replicationTask: ReplicationTask?

        @inlinable
        public init(replicationTask: ReplicationTask? = nil) {
            self.replicationTask = replicationTask
        }

        private enum CodingKeys: String, CodingKey {
            case replicationTask = "ReplicationTask"
        }
    }

    public struct DataMigration: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) that identifies this replication.
        public let dataMigrationArn: String?
        /// The CIDR blocks of the endpoints for the data migration.
        public let dataMigrationCidrBlocks: [String]?
        /// The UTC time when DMS created the data migration.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var dataMigrationCreateTime: Date?
        /// The UTC time when data migration ended.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var dataMigrationEndTime: Date?
        /// The user-friendly name for the data migration.
        public let dataMigrationName: String?
        /// Specifies CloudWatch settings and selection rules for the data migration.
        public let dataMigrationSettings: DataMigrationSettings?
        /// The UTC time when DMS started the data migration.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var dataMigrationStartTime: Date?
        /// Provides information about the data migration's run, including start and stop time, latency, and data migration progress.
        public let dataMigrationStatistics: DataMigrationStatistics?
        /// The current status of the data migration.
        public let dataMigrationStatus: String?
        /// Specifies whether the data migration is full-load only, change data capture (CDC) only, or full-load and CDC.
        public let dataMigrationType: MigrationTypeValue?
        /// Information about the data migration's most recent error or failure.
        public let lastFailureMessage: String?
        /// The Amazon Resource Name (ARN) of the data migration's associated migration project.
        public let migrationProjectArn: String?
        /// The IP addresses of the endpoints for the data migration.
        public let publicIpAddresses: [String]?
        /// The IAM role that the data migration uses to access Amazon Web Services resources.
        public let serviceAccessRoleArn: String?
        /// Specifies information about the data migration's source data provider.
        public let sourceDataSettings: [SourceDataSetting]?
        /// The reason the data migration last stopped.
        public let stopReason: String?
        /// Specifies information about the data migration's target data provider.
        public let targetDataSettings: [TargetDataSetting]?

        @inlinable
        public init(dataMigrationArn: String? = nil, dataMigrationCidrBlocks: [String]? = nil, dataMigrationCreateTime: Date? = nil, dataMigrationEndTime: Date? = nil, dataMigrationName: String? = nil, dataMigrationSettings: DataMigrationSettings? = nil, dataMigrationStartTime: Date? = nil, dataMigrationStatistics: DataMigrationStatistics? = nil, dataMigrationStatus: String? = nil, dataMigrationType: MigrationTypeValue? = nil, lastFailureMessage: String? = nil, migrationProjectArn: String? = nil, publicIpAddresses: [String]? = nil, serviceAccessRoleArn: String? = nil, sourceDataSettings: [SourceDataSetting]? = nil, stopReason: String? = nil, targetDataSettings: [TargetDataSetting]? = nil) {
            self.dataMigrationArn = dataMigrationArn
            self.dataMigrationCidrBlocks = dataMigrationCidrBlocks
            self.dataMigrationCreateTime = dataMigrationCreateTime
            self.dataMigrationEndTime = dataMigrationEndTime
            self.dataMigrationName = dataMigrationName
            self.dataMigrationSettings = dataMigrationSettings
            self.dataMigrationStartTime = dataMigrationStartTime
            self.dataMigrationStatistics = dataMigrationStatistics
            self.dataMigrationStatus = dataMigrationStatus
            self.dataMigrationType = dataMigrationType
            self.lastFailureMessage = lastFailureMessage
            self.migrationProjectArn = migrationProjectArn
            self.publicIpAddresses = publicIpAddresses
            self.serviceAccessRoleArn = serviceAccessRoleArn
            self.sourceDataSettings = sourceDataSettings
            self.stopReason = stopReason
            self.targetDataSettings = targetDataSettings
        }

        private enum CodingKeys: String, CodingKey {
            case dataMigrationArn = "DataMigrationArn"
            case dataMigrationCidrBlocks = "DataMigrationCidrBlocks"
            case dataMigrationCreateTime = "DataMigrationCreateTime"
            case dataMigrationEndTime = "DataMigrationEndTime"
            case dataMigrationName = "DataMigrationName"
            case dataMigrationSettings = "DataMigrationSettings"
            case dataMigrationStartTime = "DataMigrationStartTime"
            case dataMigrationStatistics = "DataMigrationStatistics"
            case dataMigrationStatus = "DataMigrationStatus"
            case dataMigrationType = "DataMigrationType"
            case lastFailureMessage = "LastFailureMessage"
            case migrationProjectArn = "MigrationProjectArn"
            case publicIpAddresses = "PublicIpAddresses"
            case serviceAccessRoleArn = "ServiceAccessRoleArn"
            case sourceDataSettings = "SourceDataSettings"
            case stopReason = "StopReason"
            case targetDataSettings = "TargetDataSettings"
        }
    }

    public struct DataMigrationSettings: AWSDecodableShape {
        /// Whether to enable CloudWatch logging for the data migration.
        public let cloudwatchLogsEnabled: Bool?
        /// The number of parallel jobs that trigger parallel threads to unload the tables from the source, and then load them to the target.
        public let numberOfJobs: Int?
        /// A JSON-formatted string that defines what objects to include and exclude from the migration.
        public let selectionRules: String?

        @inlinable
        public init(cloudwatchLogsEnabled: Bool? = nil, numberOfJobs: Int? = nil, selectionRules: String? = nil) {
            self.cloudwatchLogsEnabled = cloudwatchLogsEnabled
            self.numberOfJobs = numberOfJobs
            self.selectionRules = selectionRules
        }

        private enum CodingKeys: String, CodingKey {
            case cloudwatchLogsEnabled = "CloudwatchLogsEnabled"
            case numberOfJobs = "NumberOfJobs"
            case selectionRules = "SelectionRules"
        }
    }

    public struct DataMigrationStatistics: AWSDecodableShape {
        /// The current latency of the change data capture (CDC) operation.
        public let cdcLatency: Int?
        /// The elapsed duration of the data migration run.
        public let elapsedTimeMillis: Int64?
        /// The data migration's progress in the full-load migration phase.
        public let fullLoadPercentage: Int?
        /// The time when the migration started.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var startTime: Date?
        /// The time when the migration stopped or failed.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var stopTime: Date?
        /// The number of tables that DMS failed to process.
        public let tablesErrored: Int?
        /// The number of tables loaded in the current data migration run.
        public let tablesLoaded: Int?
        /// The data migration's table loading progress.
        public let tablesLoading: Int?
        /// The number of tables that are waiting for processing.
        public let tablesQueued: Int?

        @inlinable
        public init(cdcLatency: Int? = nil, elapsedTimeMillis: Int64? = nil, fullLoadPercentage: Int? = nil, startTime: Date? = nil, stopTime: Date? = nil, tablesErrored: Int? = nil, tablesLoaded: Int? = nil, tablesLoading: Int? = nil, tablesQueued: Int? = nil) {
            self.cdcLatency = cdcLatency
            self.elapsedTimeMillis = elapsedTimeMillis
            self.fullLoadPercentage = fullLoadPercentage
            self.startTime = startTime
            self.stopTime = stopTime
            self.tablesErrored = tablesErrored
            self.tablesLoaded = tablesLoaded
            self.tablesLoading = tablesLoading
            self.tablesQueued = tablesQueued
        }

        private enum CodingKeys: String, CodingKey {
            case cdcLatency = "CDCLatency"
            case elapsedTimeMillis = "ElapsedTimeMillis"
            case fullLoadPercentage = "FullLoadPercentage"
            case startTime = "StartTime"
            case stopTime = "StopTime"
            case tablesErrored = "TablesErrored"
            case tablesLoaded = "TablesLoaded"
            case tablesLoading = "TablesLoading"
            case tablesQueued = "TablesQueued"
        }
    }

    public struct DataProvider: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) string that uniquely identifies the data provider.
        public let dataProviderArn: String?
        /// The time the data provider was created.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var dataProviderCreationTime: Date?
        /// The name of the data provider.
        public let dataProviderName: String?
        /// A description of the data provider. Descriptions can have up to 31 characters.  A description can contain only ASCII letters, digits, and hyphens ('-'). Also, it can't  end with a hyphen or contain two consecutive hyphens, and can only begin with a letter.
        public let description: String?
        /// The type of database engine for the data provider. Valid values include "aurora",  "aurora-postgresql", "mysql", "oracle", "postgres",  "sqlserver", redshift, mariadb, mongodb, db2, db2-zos and docdb. A value of "aurora" represents Amazon Aurora MySQL-Compatible Edition.
        public let engine: String?
        /// The settings in JSON format for a data provider.
        public let settings: DataProviderSettings?

        @inlinable
        public init(dataProviderArn: String? = nil, dataProviderCreationTime: Date? = nil, dataProviderName: String? = nil, description: String? = nil, engine: String? = nil, settings: DataProviderSettings? = nil) {
            self.dataProviderArn = dataProviderArn
            self.dataProviderCreationTime = dataProviderCreationTime
            self.dataProviderName = dataProviderName
            self.description = description
            self.engine = engine
            self.settings = settings
        }

        private enum CodingKeys: String, CodingKey {
            case dataProviderArn = "DataProviderArn"
            case dataProviderCreationTime = "DataProviderCreationTime"
            case dataProviderName = "DataProviderName"
            case description = "Description"
            case engine = "Engine"
            case settings = "Settings"
        }
    }

    public struct DataProviderDescriptor: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the data provider.
        public let dataProviderArn: String?
        /// The user-friendly name of the data provider.
        public let dataProviderName: String?
        /// The ARN of the role used to access Amazon Web Services Secrets Manager.
        public let secretsManagerAccessRoleArn: String?
        /// The identifier of the Amazon Web Services Secrets Manager Secret used to store access credentials for the data provider.
        public let secretsManagerSecretId: String?

        @inlinable
        public init(dataProviderArn: String? = nil, dataProviderName: String? = nil, secretsManagerAccessRoleArn: String? = nil, secretsManagerSecretId: String? = nil) {
            self.dataProviderArn = dataProviderArn
            self.dataProviderName = dataProviderName
            self.secretsManagerAccessRoleArn = secretsManagerAccessRoleArn
            self.secretsManagerSecretId = secretsManagerSecretId
        }

        private enum CodingKeys: String, CodingKey {
            case dataProviderArn = "DataProviderArn"
            case dataProviderName = "DataProviderName"
            case secretsManagerAccessRoleArn = "SecretsManagerAccessRoleArn"
            case secretsManagerSecretId = "SecretsManagerSecretId"
        }
    }

    public struct DataProviderDescriptorDefinition: AWSEncodableShape {
        /// The name or Amazon Resource Name (ARN) of the data provider.
        public let dataProviderIdentifier: String
        /// The ARN of the role used to access Amazon Web Services Secrets Manager.
        public let secretsManagerAccessRoleArn: String?
        /// The identifier of the Amazon Web Services Secrets Manager Secret used to store access credentials for the data provider.
        public let secretsManagerSecretId: String?

        @inlinable
        public init(dataProviderIdentifier: String, secretsManagerAccessRoleArn: String? = nil, secretsManagerSecretId: String? = nil) {
            self.dataProviderIdentifier = dataProviderIdentifier
            self.secretsManagerAccessRoleArn = secretsManagerAccessRoleArn
            self.secretsManagerSecretId = secretsManagerSecretId
        }

        private enum CodingKeys: String, CodingKey {
            case dataProviderIdentifier = "DataProviderIdentifier"
            case secretsManagerAccessRoleArn = "SecretsManagerAccessRoleArn"
            case secretsManagerSecretId = "SecretsManagerSecretId"
        }
    }

    public struct DatabaseInstanceSoftwareDetailsResponse: AWSDecodableShape {
        /// The database engine of a database in a Fleet Advisor collector inventory, for example Microsoft SQL Server.
        public let engine: String?
        /// The database engine edition of a database in a Fleet Advisor collector inventory, for example Express.
        public let engineEdition: String?
        /// The database engine version of a database in a Fleet Advisor collector inventory, for example 2019.
        public let engineVersion: String?
        /// The operating system architecture of the database.
        public let osArchitecture: Int?
        /// The service pack level of the database.
        public let servicePack: String?
        /// The support level of the database, for example Mainstream support.
        public let supportLevel: String?
        /// Information about the database engine software, for example Mainstream support ends on November 14th, 2024.
        public let tooltip: String?

        @inlinable
        public init(engine: String? = nil, engineEdition: String? = nil, engineVersion: String? = nil, osArchitecture: Int? = nil, servicePack: String? = nil, supportLevel: String? = nil, tooltip: String? = nil) {
            self.engine = engine
            self.engineEdition = engineEdition
            self.engineVersion = engineVersion
            self.osArchitecture = osArchitecture
            self.servicePack = servicePack
            self.supportLevel = supportLevel
            self.tooltip = tooltip
        }

        private enum CodingKeys: String, CodingKey {
            case engine = "Engine"
            case engineEdition = "EngineEdition"
            case engineVersion = "EngineVersion"
            case osArchitecture = "OsArchitecture"
            case servicePack = "ServicePack"
            case supportLevel = "SupportLevel"
            case tooltip = "Tooltip"
        }
    }

    public struct DatabaseResponse: AWSDecodableShape {
        /// A list of collectors associated with the database.
        public let collectors: [CollectorShortInfoResponse]?
        /// The ID of a database in a Fleet Advisor collector inventory.
        public let databaseId: String?
        /// The name of a database in a Fleet Advisor collector inventory.
        public let databaseName: String?
        /// The IP address of a database in a Fleet Advisor collector inventory.
        public let ipAddress: String?
        /// The number of schemas in a Fleet Advisor collector inventory database.
        public let numberOfSchemas: Int64?
        /// The server name of a database in a Fleet Advisor collector inventory.
        public let server: ServerShortInfoResponse?
        /// The software details of a database in a Fleet Advisor collector inventory, such as database engine and version.
        public let softwareDetails: DatabaseInstanceSoftwareDetailsResponse?

        @inlinable
        public init(collectors: [CollectorShortInfoResponse]? = nil, databaseId: String? = nil, databaseName: String? = nil, ipAddress: String? = nil, numberOfSchemas: Int64? = nil, server: ServerShortInfoResponse? = nil, softwareDetails: DatabaseInstanceSoftwareDetailsResponse? = nil) {
            self.collectors = collectors
            self.databaseId = databaseId
            self.databaseName = databaseName
            self.ipAddress = ipAddress
            self.numberOfSchemas = numberOfSchemas
            self.server = server
            self.softwareDetails = softwareDetails
        }

        private enum CodingKeys: String, CodingKey {
            case collectors = "Collectors"
            case databaseId = "DatabaseId"
            case databaseName = "DatabaseName"
            case ipAddress = "IpAddress"
            case numberOfSchemas = "NumberOfSchemas"
            case server = "Server"
            case softwareDetails = "SoftwareDetails"
        }
    }

    public struct DatabaseShortInfoResponse: AWSDecodableShape {
        /// The database engine of a database in a Fleet Advisor collector inventory, for example PostgreSQL.
        public let databaseEngine: String?
        /// The ID of a database in a Fleet Advisor collector inventory.
        public let databaseId: String?
        /// The IP address of a database in a Fleet Advisor collector inventory.
        public let databaseIpAddress: String?
        /// The name of a database in a Fleet Advisor collector inventory.
        public let databaseName: String?

        @inlinable
        public init(databaseEngine: String? = nil, databaseId: String? = nil, databaseIpAddress: String? = nil, databaseName: String? = nil) {
            self.databaseEngine = databaseEngine
            self.databaseId = databaseId
            self.databaseIpAddress = databaseIpAddress
            self.databaseName = databaseName
        }

        private enum CodingKeys: String, CodingKey {
            case databaseEngine = "DatabaseEngine"
            case databaseId = "DatabaseId"
            case databaseIpAddress = "DatabaseIpAddress"
            case databaseName = "DatabaseName"
        }
    }

    public struct DefaultErrorDetails: AWSDecodableShape {
        /// The error message.
        public let message: String?

        @inlinable
        public init(message: String? = nil) {
            self.message = message
        }

        private enum CodingKeys: String, CodingKey {
            case message = "Message"
        }
    }

    public struct DeleteCertificateMessage: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the certificate.
        public let certificateArn: String

        @inlinable
        public init(certificateArn: String) {
            self.certificateArn = certificateArn
        }

        private enum CodingKeys: String, CodingKey {
            case certificateArn = "CertificateArn"
        }
    }

    public struct DeleteCertificateResponse: AWSDecodableShape {
        /// The Secure Sockets Layer (SSL) certificate.
        public let certificate: Certificate?

        @inlinable
        public init(certificate: Certificate? = nil) {
            self.certificate = certificate
        }

        private enum CodingKeys: String, CodingKey {
            case certificate = "Certificate"
        }
    }

    public struct DeleteCollectorRequest: AWSEncodableShape {
        /// The reference ID of the Fleet Advisor collector to delete.
        public let collectorReferencedId: String

        @inlinable
        public init(collectorReferencedId: String) {
            self.collectorReferencedId = collectorReferencedId
        }

        private enum CodingKeys: String, CodingKey {
            case collectorReferencedId = "CollectorReferencedId"
        }
    }

    public struct DeleteConnectionMessage: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) string that uniquely identifies the endpoint.
        public let endpointArn: String
        /// The Amazon Resource Name (ARN) of the replication instance.
        public let replicationInstanceArn: String

        @inlinable
        public init(endpointArn: String, replicationInstanceArn: String) {
            self.endpointArn = endpointArn
            self.replicationInstanceArn = replicationInstanceArn
        }

        private enum CodingKeys: String, CodingKey {
            case endpointArn = "EndpointArn"
            case replicationInstanceArn = "ReplicationInstanceArn"
        }
    }

    public struct DeleteConnectionResponse: AWSDecodableShape {
        /// The connection that is being deleted.
        public let connection: Connection?

        @inlinable
        public init(connection: Connection? = nil) {
            self.connection = connection
        }

        private enum CodingKeys: String, CodingKey {
            case connection = "Connection"
        }
    }

    public struct DeleteDataMigrationMessage: AWSEncodableShape {
        /// The identifier (name or ARN) of the data migration to delete.
        public let dataMigrationIdentifier: String

        @inlinable
        public init(dataMigrationIdentifier: String) {
            self.dataMigrationIdentifier = dataMigrationIdentifier
        }

        private enum CodingKeys: String, CodingKey {
            case dataMigrationIdentifier = "DataMigrationIdentifier"
        }
    }

    public struct DeleteDataMigrationResponse: AWSDecodableShape {
        /// The deleted data migration.
        public let dataMigration: DataMigration?

        @inlinable
        public init(dataMigration: DataMigration? = nil) {
            self.dataMigration = dataMigration
        }

        private enum CodingKeys: String, CodingKey {
            case dataMigration = "DataMigration"
        }
    }

    public struct DeleteDataProviderMessage: AWSEncodableShape {
        /// The identifier of the data provider to delete.
        public let dataProviderIdentifier: String

        @inlinable
        public init(dataProviderIdentifier: String) {
            self.dataProviderIdentifier = dataProviderIdentifier
        }

        private enum CodingKeys: String, CodingKey {
            case dataProviderIdentifier = "DataProviderIdentifier"
        }
    }

    public struct DeleteDataProviderResponse: AWSDecodableShape {
        /// The data provider that was deleted.
        public let dataProvider: DataProvider?

        @inlinable
        public init(dataProvider: DataProvider? = nil) {
            self.dataProvider = dataProvider
        }

        private enum CodingKeys: String, CodingKey {
            case dataProvider = "DataProvider"
        }
    }

    public struct DeleteEndpointMessage: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) string that uniquely identifies the endpoint.
        public let endpointArn: String

        @inlinable
        public init(endpointArn: String) {
            self.endpointArn = endpointArn
        }

        private enum CodingKeys: String, CodingKey {
            case endpointArn = "EndpointArn"
        }
    }

    public struct DeleteEndpointResponse: AWSDecodableShape {
        /// The endpoint that was deleted.
        public let endpoint: Endpoint?

        @inlinable
        public init(endpoint: Endpoint? = nil) {
            self.endpoint = endpoint
        }

        private enum CodingKeys: String, CodingKey {
            case endpoint = "Endpoint"
        }
    }

    public struct DeleteEventSubscriptionMessage: AWSEncodableShape {
        /// The name of the DMS event notification subscription to be deleted.
        public let subscriptionName: String

        @inlinable
        public init(subscriptionName: String) {
            self.subscriptionName = subscriptionName
        }

        private enum CodingKeys: String, CodingKey {
            case subscriptionName = "SubscriptionName"
        }
    }

    public struct DeleteEventSubscriptionResponse: AWSDecodableShape {
        /// The event subscription that was deleted.
        public let eventSubscription: EventSubscription?

        @inlinable
        public init(eventSubscription: EventSubscription? = nil) {
            self.eventSubscription = eventSubscription
        }

        private enum CodingKeys: String, CodingKey {
            case eventSubscription = "EventSubscription"
        }
    }

    public struct DeleteFleetAdvisorDatabasesRequest: AWSEncodableShape {
        /// The IDs of the Fleet Advisor collector databases to delete.
        public let databaseIds: [String]

        @inlinable
        public init(databaseIds: [String]) {
            self.databaseIds = databaseIds
        }

        private enum CodingKeys: String, CodingKey {
            case databaseIds = "DatabaseIds"
        }
    }

    public struct DeleteFleetAdvisorDatabasesResponse: AWSDecodableShape {
        /// The IDs of the databases that the operation deleted.
        public let databaseIds: [String]?

        @inlinable
        public init(databaseIds: [String]? = nil) {
            self.databaseIds = databaseIds
        }

        private enum CodingKeys: String, CodingKey {
            case databaseIds = "DatabaseIds"
        }
    }

    public struct DeleteInstanceProfileMessage: AWSEncodableShape {
        /// The identifier of the instance profile to delete.
        public let instanceProfileIdentifier: String

        @inlinable
        public init(instanceProfileIdentifier: String) {
            self.instanceProfileIdentifier = instanceProfileIdentifier
        }

        private enum CodingKeys: String, CodingKey {
            case instanceProfileIdentifier = "InstanceProfileIdentifier"
        }
    }

    public struct DeleteInstanceProfileResponse: AWSDecodableShape {
        /// The instance profile that was deleted.
        public let instanceProfile: InstanceProfile?

        @inlinable
        public init(instanceProfile: InstanceProfile? = nil) {
            self.instanceProfile = instanceProfile
        }

        private enum CodingKeys: String, CodingKey {
            case instanceProfile = "InstanceProfile"
        }
    }

    public struct DeleteMigrationProjectMessage: AWSEncodableShape {
        /// The name or Amazon Resource Name (ARN) of the migration project to delete.
        public let migrationProjectIdentifier: String

        @inlinable
        public init(migrationProjectIdentifier: String) {
            self.migrationProjectIdentifier = migrationProjectIdentifier
        }

        private enum CodingKeys: String, CodingKey {
            case migrationProjectIdentifier = "MigrationProjectIdentifier"
        }
    }

    public struct DeleteMigrationProjectResponse: AWSDecodableShape {
        /// The migration project that was deleted.
        public let migrationProject: MigrationProject?

        @inlinable
        public init(migrationProject: MigrationProject? = nil) {
            self.migrationProject = migrationProject
        }

        private enum CodingKeys: String, CodingKey {
            case migrationProject = "MigrationProject"
        }
    }

    public struct DeleteReplicationConfigMessage: AWSEncodableShape {
        /// The replication config to delete.
        public let replicationConfigArn: String

        @inlinable
        public init(replicationConfigArn: String) {
            self.replicationConfigArn = replicationConfigArn
        }

        private enum CodingKeys: String, CodingKey {
            case replicationConfigArn = "ReplicationConfigArn"
        }
    }

    public struct DeleteReplicationConfigResponse: AWSDecodableShape {
        /// Configuration parameters returned for the DMS Serverless replication after it is deleted.
        public let replicationConfig: ReplicationConfig?

        @inlinable
        public init(replicationConfig: ReplicationConfig? = nil) {
            self.replicationConfig = replicationConfig
        }

        private enum CodingKeys: String, CodingKey {
            case replicationConfig = "ReplicationConfig"
        }
    }

    public struct DeleteReplicationInstanceMessage: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the replication instance to be deleted.
        public let replicationInstanceArn: String

        @inlinable
        public init(replicationInstanceArn: String) {
            self.replicationInstanceArn = replicationInstanceArn
        }

        private enum CodingKeys: String, CodingKey {
            case replicationInstanceArn = "ReplicationInstanceArn"
        }
    }

    public struct DeleteReplicationInstanceResponse: AWSDecodableShape {
        /// The replication instance that was deleted.
        public let replicationInstance: ReplicationInstance?

        @inlinable
        public init(replicationInstance: ReplicationInstance? = nil) {
            self.replicationInstance = replicationInstance
        }

        private enum CodingKeys: String, CodingKey {
            case replicationInstance = "ReplicationInstance"
        }
    }

    public struct DeleteReplicationSubnetGroupMessage: AWSEncodableShape {
        /// The subnet group name of the replication instance.
        public let replicationSubnetGroupIdentifier: String

        @inlinable
        public init(replicationSubnetGroupIdentifier: String) {
            self.replicationSubnetGroupIdentifier = replicationSubnetGroupIdentifier
        }

        private enum CodingKeys: String, CodingKey {
            case replicationSubnetGroupIdentifier = "ReplicationSubnetGroupIdentifier"
        }
    }

    public struct DeleteReplicationSubnetGroupResponse: AWSDecodableShape {
        public init() {}
    }

    public struct DeleteReplicationTaskAssessmentRunMessage: AWSEncodableShape {
        /// Amazon Resource Name (ARN) of the premigration assessment run to be deleted.
        public let replicationTaskAssessmentRunArn: String

        @inlinable
        public init(replicationTaskAssessmentRunArn: String) {
            self.replicationTaskAssessmentRunArn = replicationTaskAssessmentRunArn
        }

        private enum CodingKeys: String, CodingKey {
            case replicationTaskAssessmentRunArn = "ReplicationTaskAssessmentRunArn"
        }
    }

    public struct DeleteReplicationTaskAssessmentRunResponse: AWSDecodableShape {
        /// The ReplicationTaskAssessmentRun object for the deleted assessment run.
        public let replicationTaskAssessmentRun: ReplicationTaskAssessmentRun?

        @inlinable
        public init(replicationTaskAssessmentRun: ReplicationTaskAssessmentRun? = nil) {
            self.replicationTaskAssessmentRun = replicationTaskAssessmentRun
        }

        private enum CodingKeys: String, CodingKey {
            case replicationTaskAssessmentRun = "ReplicationTaskAssessmentRun"
        }
    }

    public struct DeleteReplicationTaskMessage: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the replication task to be deleted.
        public let replicationTaskArn: String

        @inlinable
        public init(replicationTaskArn: String) {
            self.replicationTaskArn = replicationTaskArn
        }

        private enum CodingKeys: String, CodingKey {
            case replicationTaskArn = "ReplicationTaskArn"
        }
    }

    public struct DeleteReplicationTaskResponse: AWSDecodableShape {
        /// The deleted replication task.
        public let replicationTask: ReplicationTask?

        @inlinable
        public init(replicationTask: ReplicationTask? = nil) {
            self.replicationTask = replicationTask
        }

        private enum CodingKeys: String, CodingKey {
            case replicationTask = "ReplicationTask"
        }
    }

    public struct DescribeAccountAttributesMessage: AWSEncodableShape {
        public init() {}
    }

    public struct DescribeAccountAttributesResponse: AWSDecodableShape {
        /// Account quota information.
        public let accountQuotas: [AccountQuota]?
        /// A unique DMS identifier for an account in a particular Amazon Web Services Region. The value of this identifier has the following format: c99999999999. DMS uses this identifier to name artifacts. For example, DMS uses this identifier to name the default Amazon S3 bucket for storing task assessment reports in a given Amazon Web Services Region. The format of this S3 bucket name is the following: dms-AccountNumber-UniqueAccountIdentifier. Here is an example name for this default S3 bucket: dms-111122223333-c44445555666.  DMS supports the UniqueAccountIdentifier parameter in versions 3.1.4 and later.
        public let uniqueAccountIdentifier: String?

        @inlinable
        public init(accountQuotas: [AccountQuota]? = nil, uniqueAccountIdentifier: String? = nil) {
            self.accountQuotas = accountQuotas
            self.uniqueAccountIdentifier = uniqueAccountIdentifier
        }

        private enum CodingKeys: String, CodingKey {
            case accountQuotas = "AccountQuotas"
            case uniqueAccountIdentifier = "UniqueAccountIdentifier"
        }
    }

    public struct DescribeApplicableIndividualAssessmentsMessage: AWSEncodableShape {
        /// Optional pagination token provided by a previous request. If this parameter is specified, the response includes only records beyond the marker, up to the value specified by MaxRecords.
        public let marker: String?
        /// Maximum number of records to include in the response. If more records exist than the specified MaxRecords value, a pagination token called a marker is included in the response so that the remaining results can be retrieved.
        public let maxRecords: Int?
        /// Name of the migration type that each provided individual assessment must support.
        public let migrationType: MigrationTypeValue?
        /// Amazon Resource Name (ARN) of a serverless replication on which you want to base the default list of individual assessments.
        public let replicationConfigArn: String?
        /// ARN of a replication instance on which you want to base the default list of individual assessments.
        public let replicationInstanceArn: String?
        /// Amazon Resource Name (ARN) of a migration task on which you want to base the default list of individual assessments.
        public let replicationTaskArn: String?
        /// Name of a database engine that the specified replication instance supports as a source.
        public let sourceEngineName: String?
        /// Name of a database engine that the specified replication instance supports as a target.
        public let targetEngineName: String?

        @inlinable
        public init(marker: String? = nil, maxRecords: Int? = nil, migrationType: MigrationTypeValue? = nil, replicationConfigArn: String? = nil, replicationInstanceArn: String? = nil, replicationTaskArn: String? = nil, sourceEngineName: String? = nil, targetEngineName: String? = nil) {
            self.marker = marker
            self.maxRecords = maxRecords
            self.migrationType = migrationType
            self.replicationConfigArn = replicationConfigArn
            self.replicationInstanceArn = replicationInstanceArn
            self.replicationTaskArn = replicationTaskArn
            self.sourceEngineName = sourceEngineName
            self.targetEngineName = targetEngineName
        }

        private enum CodingKeys: String, CodingKey {
            case marker = "Marker"
            case maxRecords = "MaxRecords"
            case migrationType = "MigrationType"
            case replicationConfigArn = "ReplicationConfigArn"
            case replicationInstanceArn = "ReplicationInstanceArn"
            case replicationTaskArn = "ReplicationTaskArn"
            case sourceEngineName = "SourceEngineName"
            case targetEngineName = "TargetEngineName"
        }
    }

    public struct DescribeApplicableIndividualAssessmentsResponse: AWSDecodableShape {
        /// List of names for the individual assessments supported by the premigration assessment run that you start based on the specified request parameters. For more information on the available individual assessments, including compatibility with different migration task configurations, see Working with premigration assessment runs in the Database Migration Service User Guide.
        public let individualAssessmentNames: [String]?
        /// Pagination token returned for you to pass to a subsequent request. If you pass this token as the Marker value in a subsequent request, the response includes only records beyond the marker, up to the value specified in the request by MaxRecords.
        public let marker: String?

        @inlinable
        public init(individualAssessmentNames: [String]? = nil, marker: String? = nil) {
            self.individualAssessmentNames = individualAssessmentNames
            self.marker = marker
        }

        private enum CodingKeys: String, CodingKey {
            case individualAssessmentNames = "IndividualAssessmentNames"
            case marker = "Marker"
        }
    }

    public struct DescribeCertificatesMessage: AWSEncodableShape {
        /// Filters applied to the certificates described in the form of key-value pairs. Valid values are certificate-arn and certificate-id.
        public let filters: [Filter]?
        ///  An optional pagination token provided by a previous request. If this parameter is specified, the response includes only records beyond the marker, up to the value specified by MaxRecords.
        public let marker: String?
        ///  The maximum number of records to include in the response. If more records exist than the specified MaxRecords value, a pagination token called a marker is included in the response so that the remaining results can be retrieved.  Default: 10
        public let maxRecords: Int?

        @inlinable
        public init(filters: [Filter]? = nil, marker: String? = nil, maxRecords: Int? = nil) {
            self.filters = filters
            self.marker = marker
            self.maxRecords = maxRecords
        }

        private enum CodingKeys: String, CodingKey {
            case filters = "Filters"
            case marker = "Marker"
            case maxRecords = "MaxRecords"
        }
    }

    public struct DescribeCertificatesResponse: AWSDecodableShape {
        /// The Secure Sockets Layer (SSL) certificates associated with the replication instance.
        public let certificates: [Certificate]?
        /// The pagination token.
        public let marker: String?

        @inlinable
        public init(certificates: [Certificate]? = nil, marker: String? = nil) {
            self.certificates = certificates
            self.marker = marker
        }

        private enum CodingKeys: String, CodingKey {
            case certificates = "Certificates"
            case marker = "Marker"
        }
    }

    public struct DescribeConnectionsMessage: AWSEncodableShape {
        /// The filters applied to the connection. Valid filter names: endpoint-arn | replication-instance-arn
        public let filters: [Filter]?
        ///  An optional pagination token provided by a previous request. If this parameter is specified, the response includes only records beyond the marker, up to the value specified by MaxRecords.
        public let marker: String?
        ///  The maximum number of records to include in the response. If more records exist than the specified MaxRecords value, a pagination token called a marker is included in the response so that the remaining results can be retrieved.  Default: 100 Constraints: Minimum 20, maximum 100.
        public let maxRecords: Int?

        @inlinable
        public init(filters: [Filter]? = nil, marker: String? = nil, maxRecords: Int? = nil) {
            self.filters = filters
            self.marker = marker
            self.maxRecords = maxRecords
        }

        private enum CodingKeys: String, CodingKey {
            case filters = "Filters"
            case marker = "Marker"
            case maxRecords = "MaxRecords"
        }
    }

    public struct DescribeConnectionsResponse: AWSDecodableShape {
        /// A description of the connections.
        public let connections: [Connection]?
        ///  An optional pagination token provided by a previous request. If this parameter is specified, the response includes only records beyond the marker, up to the value specified by MaxRecords.
        public let marker: String?

        @inlinable
        public init(connections: [Connection]? = nil, marker: String? = nil) {
            self.connections = connections
            self.marker = marker
        }

        private enum CodingKeys: String, CodingKey {
            case connections = "Connections"
            case marker = "Marker"
        }
    }

    public struct DescribeConversionConfigurationMessage: AWSEncodableShape {
        /// The name or Amazon Resource Name (ARN) for the schema conversion project to describe.
        public let migrationProjectIdentifier: String

        @inlinable
        public init(migrationProjectIdentifier: String) {
            self.migrationProjectIdentifier = migrationProjectIdentifier
        }

        private enum CodingKeys: String, CodingKey {
            case migrationProjectIdentifier = "MigrationProjectIdentifier"
        }
    }

    public struct DescribeConversionConfigurationResponse: AWSDecodableShape {
        /// The configuration parameters for the schema conversion project.
        public let conversionConfiguration: String?
        /// The name or Amazon Resource Name (ARN) for the schema conversion project.
        public let migrationProjectIdentifier: String?

        @inlinable
        public init(conversionConfiguration: String? = nil, migrationProjectIdentifier: String? = nil) {
            self.conversionConfiguration = conversionConfiguration
            self.migrationProjectIdentifier = migrationProjectIdentifier
        }

        private enum CodingKeys: String, CodingKey {
            case conversionConfiguration = "ConversionConfiguration"
            case migrationProjectIdentifier = "MigrationProjectIdentifier"
        }
    }

    public struct DescribeDataMigrationsMessage: AWSEncodableShape {
        /// Filters applied to the data migrations.
        public let filters: [Filter]?
        /// An optional pagination token provided by a previous request. If this parameter is specified, the response includes only records beyond the marker, up to the value specified by MaxRecords.
        public let marker: String?
        /// The maximum number of records to include in the response. If more records exist than the specified MaxRecords value, a pagination token called a marker is included in the response so that the remaining results can be retrieved.
        public let maxRecords: Int?
        /// An option to set to avoid returning information about settings. Use this to reduce overhead when setting information is too large. To use this option, choose true; otherwise, choose false (the default).
        public let withoutSettings: Bool?
        /// An option to set to avoid returning information about statistics. Use this to reduce overhead when statistics information is too large. To use this option, choose true; otherwise, choose false (the default).
        public let withoutStatistics: Bool?

        @inlinable
        public init(filters: [Filter]? = nil, marker: String? = nil, maxRecords: Int? = nil, withoutSettings: Bool? = nil, withoutStatistics: Bool? = nil) {
            self.filters = filters
            self.marker = marker
            self.maxRecords = maxRecords
            self.withoutSettings = withoutSettings
            self.withoutStatistics = withoutStatistics
        }

        public func validate(name: String) throws {
            try self.validate(self.marker, name: "marker", parent: name, max: 1024)
        }

        private enum CodingKeys: String, CodingKey {
            case filters = "Filters"
            case marker = "Marker"
            case maxRecords = "MaxRecords"
            case withoutSettings = "WithoutSettings"
            case withoutStatistics = "WithoutStatistics"
        }
    }

    public struct DescribeDataMigrationsResponse: AWSDecodableShape {
        /// Returns information about the data migrations used in the project.
        public let dataMigrations: [DataMigration]?
        /// An optional pagination token provided by a previous request. If this parameter is specified, the response includes only records beyond the marker, up to the value specified by MaxRecords.
        public let marker: String?

        @inlinable
        public init(dataMigrations: [DataMigration]? = nil, marker: String? = nil) {
            self.dataMigrations = dataMigrations
            self.marker = marker
        }

        private enum CodingKeys: String, CodingKey {
            case dataMigrations = "DataMigrations"
            case marker = "Marker"
        }
    }

    public struct DescribeDataProvidersMessage: AWSEncodableShape {
        /// Filters applied to the data providers described in the form of key-value pairs. Valid filter names and values: data-provider-identifier, data provider arn or name
        public let filters: [Filter]?
        /// Specifies the unique pagination token that makes it possible to display the next page of results.  If this parameter is specified, the response includes only records beyond the marker, up to the  value specified by MaxRecords. If Marker is returned by a previous response, there are more results available.  The value of Marker is a unique pagination token for each page. To retrieve the next page,  make the call again using the returned token and keeping all other arguments unchanged.
        public let marker: String?
        /// The maximum number of records to include in the response. If more records exist than  the specified MaxRecords value, DMS includes a pagination token   in the response so that you can retrieve the remaining results.
        public let maxRecords: Int?

        @inlinable
        public init(filters: [Filter]? = nil, marker: String? = nil, maxRecords: Int? = nil) {
            self.filters = filters
            self.marker = marker
            self.maxRecords = maxRecords
        }

        private enum CodingKeys: String, CodingKey {
            case filters = "Filters"
            case marker = "Marker"
            case maxRecords = "MaxRecords"
        }
    }

    public struct DescribeDataProvidersResponse: AWSDecodableShape {
        /// A description of data providers.
        public let dataProviders: [DataProvider]?
        /// Specifies the unique pagination token that makes it possible to display the next page of results.  If this parameter is specified, the response includes only records beyond the marker, up to the  value specified by MaxRecords. If Marker is returned by a previous response, there are more results available.  The value of Marker is a unique pagination token for each page. To retrieve the next page,  make the call again using the returned token and keeping all other arguments unchanged.
        public let marker: String?

        @inlinable
        public init(dataProviders: [DataProvider]? = nil, marker: String? = nil) {
            self.dataProviders = dataProviders
            self.marker = marker
        }

        private enum CodingKeys: String, CodingKey {
            case dataProviders = "DataProviders"
            case marker = "Marker"
        }
    }

    public struct DescribeEndpointSettingsMessage: AWSEncodableShape {
        /// The database engine used for your source or target endpoint.
        public let engineName: String
        /// An optional pagination token provided by a previous request. If this parameter is specified, the response includes only records beyond the marker, up to the value specified by MaxRecords.
        public let marker: String?
        /// The maximum number of records to include in the response. If more records exist than the specified MaxRecords value, a pagination token called a marker is included in the response so that the remaining results can be retrieved.
        public let maxRecords: Int?

        @inlinable
        public init(engineName: String, marker: String? = nil, maxRecords: Int? = nil) {
            self.engineName = engineName
            self.marker = marker
            self.maxRecords = maxRecords
        }

        private enum CodingKeys: String, CodingKey {
            case engineName = "EngineName"
            case marker = "Marker"
            case maxRecords = "MaxRecords"
        }
    }

    public struct DescribeEndpointSettingsResponse: AWSDecodableShape {
        /// Descriptions of the endpoint settings available for your source or target database engine.
        public let endpointSettings: [EndpointSetting]?
        /// An optional pagination token provided by a previous request. If this parameter is specified, the response includes only records beyond the marker, up to the value specified by MaxRecords.
        public let marker: String?

        @inlinable
        public init(endpointSettings: [EndpointSetting]? = nil, marker: String? = nil) {
            self.endpointSettings = endpointSettings
            self.marker = marker
        }

        private enum CodingKeys: String, CodingKey {
            case endpointSettings = "EndpointSettings"
            case marker = "Marker"
        }
    }

    public struct DescribeEndpointTypesMessage: AWSEncodableShape {
        /// Filters applied to the endpoint types. Valid filter names: engine-name | endpoint-type
        public let filters: [Filter]?
        ///  An optional pagination token provided by a previous request. If this parameter is specified, the response includes only records beyond the marker, up to the value specified by MaxRecords.
        public let marker: String?
        ///  The maximum number of records to include in the response. If more records exist than the specified MaxRecords value, a pagination token called a marker is included in the response so that the remaining results can be retrieved.  Default: 100 Constraints: Minimum 20, maximum 100.
        public let maxRecords: Int?

        @inlinable
        public init(filters: [Filter]? = nil, marker: String? = nil, maxRecords: Int? = nil) {
            self.filters = filters
            self.marker = marker
            self.maxRecords = maxRecords
        }

        private enum CodingKeys: String, CodingKey {
            case filters = "Filters"
            case marker = "Marker"
            case maxRecords = "MaxRecords"
        }
    }

    public struct DescribeEndpointTypesResponse: AWSDecodableShape {
        ///  An optional pagination token provided by a previous request. If this parameter is specified, the response includes only records beyond the marker, up to the value specified by MaxRecords.
        public let marker: String?
        /// The types of endpoints that are supported.
        public let supportedEndpointTypes: [SupportedEndpointType]?

        @inlinable
        public init(marker: String? = nil, supportedEndpointTypes: [SupportedEndpointType]? = nil) {
            self.marker = marker
            self.supportedEndpointTypes = supportedEndpointTypes
        }

        private enum CodingKeys: String, CodingKey {
            case marker = "Marker"
            case supportedEndpointTypes = "SupportedEndpointTypes"
        }
    }

    public struct DescribeEndpointsMessage: AWSEncodableShape {
        /// Filters applied to the endpoints. Valid filter names: endpoint-arn | endpoint-type | endpoint-id | engine-name
        public let filters: [Filter]?
        ///  An optional pagination token provided by a previous request. If this parameter is specified, the response includes only records beyond the marker, up to the value specified by MaxRecords.
        public let marker: String?
        ///  The maximum number of records to include in the response. If more records exist than the specified MaxRecords value, a pagination token called a marker is included in the response so that the remaining results can be retrieved.  Default: 100 Constraints: Minimum 20, maximum 100.
        public let maxRecords: Int?

        @inlinable
        public init(filters: [Filter]? = nil, marker: String? = nil, maxRecords: Int? = nil) {
            self.filters = filters
            self.marker = marker
            self.maxRecords = maxRecords
        }

        private enum CodingKeys: String, CodingKey {
            case filters = "Filters"
            case marker = "Marker"
            case maxRecords = "MaxRecords"
        }
    }

    public struct DescribeEndpointsResponse: AWSDecodableShape {
        /// Endpoint description.
        public let endpoints: [Endpoint]?
        ///  An optional pagination token provided by a previous request. If this parameter is specified, the response includes only records beyond the marker, up to the value specified by MaxRecords.
        public let marker: String?

        @inlinable
        public init(endpoints: [Endpoint]? = nil, marker: String? = nil) {
            self.endpoints = endpoints
            self.marker = marker
        }

        private enum CodingKeys: String, CodingKey {
            case endpoints = "Endpoints"
            case marker = "Marker"
        }
    }

    public struct DescribeEngineVersionsMessage: AWSEncodableShape {
        /// An optional pagination token provided by a previous request. If this parameter is specified, the response includes only records beyond the marker, up to the value specified by MaxRecords.
        public let marker: String?
        /// The maximum number of records to include in the response. If more records exist than the specified MaxRecords value, a pagination token called a marker is included in the response so that the remaining results can be retrieved.
        public let maxRecords: Int?

        @inlinable
        public init(marker: String? = nil, maxRecords: Int? = nil) {
            self.marker = marker
            self.maxRecords = maxRecords
        }

        private enum CodingKeys: String, CodingKey {
            case marker = "Marker"
            case maxRecords = "MaxRecords"
        }
    }

    public struct DescribeEngineVersionsResponse: AWSDecodableShape {
        /// Returned EngineVersion objects that describe the replication instance engine versions used in the project.
        public let engineVersions: [EngineVersion]?
        /// An optional pagination token provided by a previous request. If this parameter is specified, the response includes only records beyond the marker, up to the value specified by MaxRecords.
        public let marker: String?

        @inlinable
        public init(engineVersions: [EngineVersion]? = nil, marker: String? = nil) {
            self.engineVersions = engineVersions
            self.marker = marker
        }

        private enum CodingKeys: String, CodingKey {
            case engineVersions = "EngineVersions"
            case marker = "Marker"
        }
    }

    public struct DescribeEventCategoriesMessage: AWSEncodableShape {
        /// Filters applied to the event categories.
        public let filters: [Filter]?
        ///  The type of DMS resource that generates events.  Valid values: replication-instance | replication-task
        public let sourceType: String?

        @inlinable
        public init(filters: [Filter]? = nil, sourceType: String? = nil) {
            self.filters = filters
            self.sourceType = sourceType
        }

        private enum CodingKeys: String, CodingKey {
            case filters = "Filters"
            case sourceType = "SourceType"
        }
    }

    public struct DescribeEventCategoriesResponse: AWSDecodableShape {
        /// A list of event categories.
        public let eventCategoryGroupList: [EventCategoryGroup]?

        @inlinable
        public init(eventCategoryGroupList: [EventCategoryGroup]? = nil) {
            self.eventCategoryGroupList = eventCategoryGroupList
        }

        private enum CodingKeys: String, CodingKey {
            case eventCategoryGroupList = "EventCategoryGroupList"
        }
    }

    public struct DescribeEventSubscriptionsMessage: AWSEncodableShape {
        /// Filters applied to event subscriptions. Valid filter names: event-subscription-arn | event-subscription-id
        public let filters: [Filter]?
        ///  An optional pagination token provided by a previous request. If this parameter is specified, the response includes only records beyond the marker, up to the value specified by MaxRecords.
        public let marker: String?
        ///  The maximum number of records to include in the response. If more records exist than the specified MaxRecords value, a pagination token called a marker is included in the response so that the remaining results can be retrieved.  Default: 100 Constraints: Minimum 20, maximum 100.
        public let maxRecords: Int?
        /// The name of the DMS event subscription to be described.
        public let subscriptionName: String?

        @inlinable
        public init(filters: [Filter]? = nil, marker: String? = nil, maxRecords: Int? = nil, subscriptionName: String? = nil) {
            self.filters = filters
            self.marker = marker
            self.maxRecords = maxRecords
            self.subscriptionName = subscriptionName
        }

        private enum CodingKeys: String, CodingKey {
            case filters = "Filters"
            case marker = "Marker"
            case maxRecords = "MaxRecords"
            case subscriptionName = "SubscriptionName"
        }
    }

    public struct DescribeEventSubscriptionsResponse: AWSDecodableShape {
        /// A list of event subscriptions.
        public let eventSubscriptionsList: [EventSubscription]?
        ///  An optional pagination token provided by a previous request. If this parameter is specified, the response includes only records beyond the marker, up to the value specified by MaxRecords.
        public let marker: String?

        @inlinable
        public init(eventSubscriptionsList: [EventSubscription]? = nil, marker: String? = nil) {
            self.eventSubscriptionsList = eventSubscriptionsList
            self.marker = marker
        }

        private enum CodingKeys: String, CodingKey {
            case eventSubscriptionsList = "EventSubscriptionsList"
            case marker = "Marker"
        }
    }

    public struct DescribeEventsMessage: AWSEncodableShape {
        /// The duration of the events to be listed.
        public let duration: Int?
        /// The end time for the events to be listed.
        public let endTime: Date?
        /// A list of event categories for the source type that you've chosen.
        public let eventCategories: [String]?
        /// Filters applied to events. The only valid filter is replication-instance-id.
        public let filters: [Filter]?
        ///  An optional pagination token provided by a previous request. If this parameter is specified, the response includes only records beyond the marker, up to the value specified by MaxRecords.
        public let marker: String?
        ///  The maximum number of records to include in the response. If more records exist than the specified MaxRecords value, a pagination token called a marker is included in the response so that the remaining results can be retrieved.  Default: 100 Constraints: Minimum 20, maximum 100.
        public let maxRecords: Int?
        ///  The identifier of an event source.
        public let sourceIdentifier: String?
        /// The type of DMS resource that generates events. Valid values: replication-instance | replication-task
        public let sourceType: SourceType?
        /// The start time for the events to be listed.
        public let startTime: Date?

        @inlinable
        public init(duration: Int? = nil, endTime: Date? = nil, eventCategories: [String]? = nil, filters: [Filter]? = nil, marker: String? = nil, maxRecords: Int? = nil, sourceIdentifier: String? = nil, sourceType: SourceType? = nil, startTime: Date? = nil) {
            self.duration = duration
            self.endTime = endTime
            self.eventCategories = eventCategories
            self.filters = filters
            self.marker = marker
            self.maxRecords = maxRecords
            self.sourceIdentifier = sourceIdentifier
            self.sourceType = sourceType
            self.startTime = startTime
        }

        private enum CodingKeys: String, CodingKey {
            case duration = "Duration"
            case endTime = "EndTime"
            case eventCategories = "EventCategories"
            case filters = "Filters"
            case marker = "Marker"
            case maxRecords = "MaxRecords"
            case sourceIdentifier = "SourceIdentifier"
            case sourceType = "SourceType"
            case startTime = "StartTime"
        }
    }

    public struct DescribeEventsResponse: AWSDecodableShape {
        /// The events described.
        public let events: [Event]?
        ///  An optional pagination token provided by a previous request. If this parameter is specified, the response includes only records beyond the marker, up to the value specified by MaxRecords.
        public let marker: String?

        @inlinable
        public init(events: [Event]? = nil, marker: String? = nil) {
            self.events = events
            self.marker = marker
        }

        private enum CodingKeys: String, CodingKey {
            case events = "Events"
            case marker = "Marker"
        }
    }

    public struct DescribeExtensionPackAssociationsMessage: AWSEncodableShape {
        /// Filters applied to the extension pack associations described in the form of key-value pairs.
        public let filters: [Filter]?
        /// Specifies the unique pagination token that makes it possible to display the next page of results.  If this parameter is specified, the response includes only records beyond the marker, up to the  value specified by MaxRecords. If Marker is returned by a previous response, there are more results available.  The value of Marker is a unique pagination token for each page. To retrieve the next page,  make the call again using the returned token and keeping all other arguments unchanged.
        public let marker: String?
        /// The maximum number of records to include in the response. If more records exist than  the specified MaxRecords value, DMS includes a pagination token   in the response so that you can retrieve the remaining results.
        public let maxRecords: Int?
        /// The name or Amazon Resource Name (ARN) for the migration project.
        public let migrationProjectIdentifier: String

        @inlinable
        public init(filters: [Filter]? = nil, marker: String? = nil, maxRecords: Int? = nil, migrationProjectIdentifier: String) {
            self.filters = filters
            self.marker = marker
            self.maxRecords = maxRecords
            self.migrationProjectIdentifier = migrationProjectIdentifier
        }

        private enum CodingKeys: String, CodingKey {
            case filters = "Filters"
            case marker = "Marker"
            case maxRecords = "MaxRecords"
            case migrationProjectIdentifier = "MigrationProjectIdentifier"
        }
    }

    public struct DescribeExtensionPackAssociationsResponse: AWSDecodableShape {
        /// Specifies the unique pagination token that makes it possible to display the next page of results.  If this parameter is specified, the response includes only records beyond the marker, up to the  value specified by MaxRecords. If Marker is returned by a previous response, there are more results available.  The value of Marker is a unique pagination token for each page. To retrieve the next page,  make the call again using the returned token and keeping all other arguments unchanged.
        public let marker: String?
        /// A paginated list of extension pack associations for the specified migration project.
        public let requests: [SchemaConversionRequest]?

        @inlinable
        public init(marker: String? = nil, requests: [SchemaConversionRequest]? = nil) {
            self.marker = marker
            self.requests = requests
        }

        private enum CodingKeys: String, CodingKey {
            case marker = "Marker"
            case requests = "Requests"
        }
    }

    public struct DescribeFleetAdvisorCollectorsRequest: AWSEncodableShape {
        ///  If you specify any of the following filters, the output includes information for only those collectors that meet the filter criteria:    collector-referenced-id  The ID of the collector agent, for example d4610ac5-e323-4ad9-bc50-eaf7249dfe9d.    collector-name  The name of the collector agent.   An example is: describe-fleet-advisor-collectors --filter Name="collector-referenced-id",Values="d4610ac5-e323-4ad9-bc50-eaf7249dfe9d"
        public let filters: [Filter]?
        /// Sets the maximum number of records returned in the response.
        public let maxRecords: Int?
        /// If NextToken is returned by a previous response, there are more results available. The value of NextToken is a unique pagination token for each page. Make the call again using the returned token to retrieve the next page. Keep all other arguments unchanged.
        public let nextToken: String?

        @inlinable
        public init(filters: [Filter]? = nil, maxRecords: Int? = nil, nextToken: String? = nil) {
            self.filters = filters
            self.maxRecords = maxRecords
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case filters = "Filters"
            case maxRecords = "MaxRecords"
            case nextToken = "NextToken"
        }
    }

    public struct DescribeFleetAdvisorCollectorsResponse: AWSDecodableShape {
        /// Provides descriptions of the Fleet Advisor collectors, including the collectors' name and ID, and the latest inventory data.
        public let collectors: [CollectorResponse]?
        /// If NextToken is returned, there are more results available. The value of NextToken is a unique pagination token for each page. Make the call again using the returned token to retrieve the next page. Keep all other arguments unchanged.
        public let nextToken: String?

        @inlinable
        public init(collectors: [CollectorResponse]? = nil, nextToken: String? = nil) {
            self.collectors = collectors
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case collectors = "Collectors"
            case nextToken = "NextToken"
        }
    }

    public struct DescribeFleetAdvisorDatabasesRequest: AWSEncodableShape {
        ///  If you specify any of the following filters, the output includes information for only those databases that meet the filter criteria:     database-id  The ID of the database.    database-name  The name of the database.    database-engine  The name of the database engine.    server-ip-address  The IP address of the database server.    database-ip-address  The IP address of the database.    collector-name  The name of the associated Fleet Advisor collector.   An example is: describe-fleet-advisor-databases --filter Name="database-id",Values="45"
        public let filters: [Filter]?
        /// Sets the maximum number of records returned in the response.
        public let maxRecords: Int?
        /// If NextToken is returned by a previous response, there are more results available. The value of NextToken is a unique pagination token for each page. Make the call again using the returned token to retrieve the next page. Keep all other arguments unchanged.
        public let nextToken: String?

        @inlinable
        public init(filters: [Filter]? = nil, maxRecords: Int? = nil, nextToken: String? = nil) {
            self.filters = filters
            self.maxRecords = maxRecords
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case filters = "Filters"
            case maxRecords = "MaxRecords"
            case nextToken = "NextToken"
        }
    }

    public struct DescribeFleetAdvisorDatabasesResponse: AWSDecodableShape {
        /// Provides descriptions of the Fleet Advisor collector databases, including the database's collector, ID, and name.
        public let databases: [DatabaseResponse]?
        /// If NextToken is returned, there are more results available. The value of NextToken is a unique pagination token for each page. Make the call again using the returned token to retrieve the next page. Keep all other arguments unchanged.
        public let nextToken: String?

        @inlinable
        public init(databases: [DatabaseResponse]? = nil, nextToken: String? = nil) {
            self.databases = databases
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case databases = "Databases"
            case nextToken = "NextToken"
        }
    }

    public struct DescribeFleetAdvisorLsaAnalysisRequest: AWSEncodableShape {
        /// Sets the maximum number of records returned in the response.
        public let maxRecords: Int?
        /// If NextToken is returned by a previous response, there are more results available. The value of NextToken is a unique pagination token for each page. Make the call again using the returned token to retrieve the next page. Keep all other arguments unchanged.
        public let nextToken: String?

        @inlinable
        public init(maxRecords: Int? = nil, nextToken: String? = nil) {
            self.maxRecords = maxRecords
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case maxRecords = "MaxRecords"
            case nextToken = "NextToken"
        }
    }

    public struct DescribeFleetAdvisorLsaAnalysisResponse: AWSDecodableShape {
        /// A list of FleetAdvisorLsaAnalysisResponse objects.
        public let analysis: [FleetAdvisorLsaAnalysisResponse]?
        /// If NextToken is returned, there are more results available. The value of NextToken is a unique pagination token for each page. Make the call again using the returned token to retrieve the next page. Keep all other arguments unchanged.
        public let nextToken: String?

        @inlinable
        public init(analysis: [FleetAdvisorLsaAnalysisResponse]? = nil, nextToken: String? = nil) {
            self.analysis = analysis
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case analysis = "Analysis"
            case nextToken = "NextToken"
        }
    }

    public struct DescribeFleetAdvisorSchemaObjectSummaryRequest: AWSEncodableShape {
        ///  If you specify any of the following filters, the output includes information for only those schema objects that meet the filter criteria:    schema-id  The ID of the schema, for example d4610ac5-e323-4ad9-bc50-eaf7249dfe9d.   Example: describe-fleet-advisor-schema-object-summary --filter Name="schema-id",Values="50"
        public let filters: [Filter]?
        /// Sets the maximum number of records returned in the response.
        public let maxRecords: Int?
        /// If NextToken is returned by a previous response, there are more results available. The value of NextToken is a unique pagination token for each page. Make the call again using the returned token to retrieve the next page. Keep all other arguments unchanged.
        public let nextToken: String?

        @inlinable
        public init(filters: [Filter]? = nil, maxRecords: Int? = nil, nextToken: String? = nil) {
            self.filters = filters
            self.maxRecords = maxRecords
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case filters = "Filters"
            case maxRecords = "MaxRecords"
            case nextToken = "NextToken"
        }
    }

    public struct DescribeFleetAdvisorSchemaObjectSummaryResponse: AWSDecodableShape {
        /// A collection of FleetAdvisorSchemaObjectResponse objects.
        public let fleetAdvisorSchemaObjects: [FleetAdvisorSchemaObjectResponse]?
        /// If NextToken is returned, there are more results available. The value of NextToken is a unique pagination token for each page. Make the call again using the returned token to retrieve the next page. Keep all other arguments unchanged.
        public let nextToken: String?

        @inlinable
        public init(fleetAdvisorSchemaObjects: [FleetAdvisorSchemaObjectResponse]? = nil, nextToken: String? = nil) {
            self.fleetAdvisorSchemaObjects = fleetAdvisorSchemaObjects
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case fleetAdvisorSchemaObjects = "FleetAdvisorSchemaObjects"
            case nextToken = "NextToken"
        }
    }

    public struct DescribeFleetAdvisorSchemasRequest: AWSEncodableShape {
        ///  If you specify any of the following filters, the output includes information for only those schemas that meet the filter criteria:    complexity  The schema's complexity, for example Simple.    database-id  The ID of the schema's database.    database-ip-address  The IP address of the schema's database.    database-name  The name of the schema's database.    database-engine  The name of the schema database's engine.    original-schema-name  The name of the schema's database's main schema.    schema-id  The ID of the schema, for example 15.    schema-name  The name of the schema.    server-ip-address  The IP address of the schema database's server.   An example is: describe-fleet-advisor-schemas --filter Name="schema-id",Values="50"
        public let filters: [Filter]?
        /// Sets the maximum number of records returned in the response.
        public let maxRecords: Int?
        /// If NextToken is returned by a previous response, there are more results available. The value of NextToken is a unique pagination token for each page. Make the call again using the returned token to retrieve the next page. Keep all other arguments unchanged.
        public let nextToken: String?

        @inlinable
        public init(filters: [Filter]? = nil, maxRecords: Int? = nil, nextToken: String? = nil) {
            self.filters = filters
            self.maxRecords = maxRecords
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case filters = "Filters"
            case maxRecords = "MaxRecords"
            case nextToken = "NextToken"
        }
    }

    public struct DescribeFleetAdvisorSchemasResponse: AWSDecodableShape {
        /// A collection of SchemaResponse objects.
        public let fleetAdvisorSchemas: [SchemaResponse]?
        /// If NextToken is returned, there are more results available. The value of NextToken is a unique pagination token for each page. Make the call again using the returned token to retrieve the next page. Keep all other arguments unchanged.
        public let nextToken: String?

        @inlinable
        public init(fleetAdvisorSchemas: [SchemaResponse]? = nil, nextToken: String? = nil) {
            self.fleetAdvisorSchemas = fleetAdvisorSchemas
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case fleetAdvisorSchemas = "FleetAdvisorSchemas"
            case nextToken = "NextToken"
        }
    }

    public struct DescribeInstanceProfilesMessage: AWSEncodableShape {
        /// Filters applied to the instance profiles described in the form of key-value pairs. Valid filter names and values: instance-profile-identifier, instance profile arn or name
        public let filters: [Filter]?
        /// Specifies the unique pagination token that makes it possible to display the next page of results.  If this parameter is specified, the response includes only records beyond the marker, up to the  value specified by MaxRecords. If Marker is returned by a previous response, there are more results available.  The value of Marker is a unique pagination token for each page. To retrieve the next page,  make the call again using the returned token and keeping all other arguments unchanged.
        public let marker: String?
        /// The maximum number of records to include in the response. If more records exist than  the specified MaxRecords value, DMS includes a pagination token   in the response so that you can retrieve the remaining results.
        public let maxRecords: Int?

        @inlinable
        public init(filters: [Filter]? = nil, marker: String? = nil, maxRecords: Int? = nil) {
            self.filters = filters
            self.marker = marker
            self.maxRecords = maxRecords
        }

        private enum CodingKeys: String, CodingKey {
            case filters = "Filters"
            case marker = "Marker"
            case maxRecords = "MaxRecords"
        }
    }

    public struct DescribeInstanceProfilesResponse: AWSDecodableShape {
        /// A description of instance profiles.
        public let instanceProfiles: [InstanceProfile]?
        /// Specifies the unique pagination token that makes it possible to display the next page of results.  If this parameter is specified, the response includes only records beyond the marker, up to the  value specified by MaxRecords. If Marker is returned by a previous response, there are more results available.  The value of Marker is a unique pagination token for each page. To retrieve the next page,  make the call again using the returned token and keeping all other arguments unchanged.
        public let marker: String?

        @inlinable
        public init(instanceProfiles: [InstanceProfile]? = nil, marker: String? = nil) {
            self.instanceProfiles = instanceProfiles
            self.marker = marker
        }

        private enum CodingKeys: String, CodingKey {
            case instanceProfiles = "InstanceProfiles"
            case marker = "Marker"
        }
    }

    public struct DescribeMetadataModelAssessmentsMessage: AWSEncodableShape {
        /// Filters applied to the metadata model assessments described in the form of key-value pairs.
        public let filters: [Filter]?
        /// Specifies the unique pagination token that makes it possible to display the next page of results.  If this parameter is specified, the response includes only records beyond the marker, up to the  value specified by MaxRecords. If Marker is returned by a previous response, there are more results available.  The value of Marker is a unique pagination token for each page. To retrieve the next page,  make the call again using the returned token and keeping all other arguments unchanged.
        public let marker: String?
        /// The maximum number of records to include in the response. If more records exist than  the specified MaxRecords value, DMS includes a pagination token   in the response so that you can retrieve the remaining results.
        public let maxRecords: Int?
        /// The name or Amazon Resource Name (ARN) of the migration project.
        public let migrationProjectIdentifier: String

        @inlinable
        public init(filters: [Filter]? = nil, marker: String? = nil, maxRecords: Int? = nil, migrationProjectIdentifier: String) {
            self.filters = filters
            self.marker = marker
            self.maxRecords = maxRecords
            self.migrationProjectIdentifier = migrationProjectIdentifier
        }

        private enum CodingKeys: String, CodingKey {
            case filters = "Filters"
            case marker = "Marker"
            case maxRecords = "MaxRecords"
            case migrationProjectIdentifier = "MigrationProjectIdentifier"
        }
    }

    public struct DescribeMetadataModelAssessmentsResponse: AWSDecodableShape {
        /// Specifies the unique pagination token that makes it possible to display the next page of results.  If this parameter is specified, the response includes only records beyond the marker, up to the  value specified by MaxRecords. If Marker is returned by a previous response, there are more results available.  The value of Marker is a unique pagination token for each page. To retrieve the next page,  make the call again using the returned token and keeping all other arguments unchanged.
        public let marker: String?
        /// A paginated list of metadata model assessments for the specified migration project.
        public let requests: [SchemaConversionRequest]?

        @inlinable
        public init(marker: String? = nil, requests: [SchemaConversionRequest]? = nil) {
            self.marker = marker
            self.requests = requests
        }

        private enum CodingKeys: String, CodingKey {
            case marker = "Marker"
            case requests = "Requests"
        }
    }

    public struct DescribeMetadataModelConversionsMessage: AWSEncodableShape {
        /// Filters applied to the metadata model conversions described in the form of key-value pairs.
        public let filters: [Filter]?
        /// Specifies the unique pagination token that makes it possible to display the next page of results.  If this parameter is specified, the response includes only records beyond the marker, up to the  value specified by MaxRecords. If Marker is returned by a previous response, there are more results available.  The value of Marker is a unique pagination token for each page. To retrieve the next page,  make the call again using the returned token and keeping all other arguments unchanged.
        public let marker: String?
        /// The maximum number of records to include in the response. If more records exist than  the specified MaxRecords value, DMS includes a pagination token   in the response so that you can retrieve the remaining results.
        public let maxRecords: Int?
        /// The migration project name or Amazon Resource Name (ARN).
        public let migrationProjectIdentifier: String

        @inlinable
        public init(filters: [Filter]? = nil, marker: String? = nil, maxRecords: Int? = nil, migrationProjectIdentifier: String) {
            self.filters = filters
            self.marker = marker
            self.maxRecords = maxRecords
            self.migrationProjectIdentifier = migrationProjectIdentifier
        }

        private enum CodingKeys: String, CodingKey {
            case filters = "Filters"
            case marker = "Marker"
            case maxRecords = "MaxRecords"
            case migrationProjectIdentifier = "MigrationProjectIdentifier"
        }
    }

    public struct DescribeMetadataModelConversionsResponse: AWSDecodableShape {
        /// Specifies the unique pagination token that makes it possible to display the next page of results.  If this parameter is specified, the response includes only records beyond the marker, up to the  value specified by MaxRecords. If Marker is returned by a previous response, there are more results available.  The value of Marker is a unique pagination token for each page. To retrieve the next page,  make the call again using the returned token and keeping all other arguments unchanged.
        public let marker: String?
        /// A paginated list of metadata model conversions.
        public let requests: [SchemaConversionRequest]?

        @inlinable
        public init(marker: String? = nil, requests: [SchemaConversionRequest]? = nil) {
            self.marker = marker
            self.requests = requests
        }

        private enum CodingKeys: String, CodingKey {
            case marker = "Marker"
            case requests = "Requests"
        }
    }

    public struct DescribeMetadataModelExportsAsScriptMessage: AWSEncodableShape {
        /// Filters applied to the metadata model exports described in the form of key-value pairs.
        public let filters: [Filter]?
        /// Specifies the unique pagination token that makes it possible to display the next page of results.  If this parameter is specified, the response includes only records beyond the marker, up to the  value specified by MaxRecords. If Marker is returned by a previous response, there are more results available.  The value of Marker is a unique pagination token for each page. To retrieve the next page,  make the call again using the returned token and keeping all other arguments unchanged.
        public let marker: String?
        /// The maximum number of records to include in the response. If more records exist than  the specified MaxRecords value, DMS includes a pagination token   in the response so that you can retrieve the remaining results.
        public let maxRecords: Int?
        /// The migration project name or Amazon Resource Name (ARN).
        public let migrationProjectIdentifier: String

        @inlinable
        public init(filters: [Filter]? = nil, marker: String? = nil, maxRecords: Int? = nil, migrationProjectIdentifier: String) {
            self.filters = filters
            self.marker = marker
            self.maxRecords = maxRecords
            self.migrationProjectIdentifier = migrationProjectIdentifier
        }

        private enum CodingKeys: String, CodingKey {
            case filters = "Filters"
            case marker = "Marker"
            case maxRecords = "MaxRecords"
            case migrationProjectIdentifier = "MigrationProjectIdentifier"
        }
    }

    public struct DescribeMetadataModelExportsAsScriptResponse: AWSDecodableShape {
        /// Specifies the unique pagination token that makes it possible to display the next page of results.  If this parameter is specified, the response includes only records beyond the marker, up to the  value specified by MaxRecords. If Marker is returned by a previous response, there are more results available.  The value of Marker is a unique pagination token for each page. To retrieve the next page,  make the call again using the returned token and keeping all other arguments unchanged.
        public let marker: String?
        /// A paginated list of metadata model exports.
        public let requests: [SchemaConversionRequest]?

        @inlinable
        public init(marker: String? = nil, requests: [SchemaConversionRequest]? = nil) {
            self.marker = marker
            self.requests = requests
        }

        private enum CodingKeys: String, CodingKey {
            case marker = "Marker"
            case requests = "Requests"
        }
    }

    public struct DescribeMetadataModelExportsToTargetMessage: AWSEncodableShape {
        /// Filters applied to the metadata model exports described in the form of key-value pairs.
        public let filters: [Filter]?
        /// Specifies the unique pagination token that makes it possible to display the next page of results.  If this parameter is specified, the response includes only records beyond the marker, up to the  value specified by MaxRecords. If Marker is returned by a previous response, there are more results available.  The value of Marker is a unique pagination token for each page. To retrieve the next page,  make the call again using the returned token and keeping all other arguments unchanged.
        public let marker: String?
        /// The maximum number of records to include in the response. If more records exist than  the specified MaxRecords value, DMS includes a pagination token   in the response so that you can retrieve the remaining results.
        public let maxRecords: Int?
        /// The migration project name or Amazon Resource Name (ARN).
        public let migrationProjectIdentifier: String

        @inlinable
        public init(filters: [Filter]? = nil, marker: String? = nil, maxRecords: Int? = nil, migrationProjectIdentifier: String) {
            self.filters = filters
            self.marker = marker
            self.maxRecords = maxRecords
            self.migrationProjectIdentifier = migrationProjectIdentifier
        }

        private enum CodingKeys: String, CodingKey {
            case filters = "Filters"
            case marker = "Marker"
            case maxRecords = "MaxRecords"
            case migrationProjectIdentifier = "MigrationProjectIdentifier"
        }
    }

    public struct DescribeMetadataModelExportsToTargetResponse: AWSDecodableShape {
        /// Specifies the unique pagination token that makes it possible to display the next page of results.  If this parameter is specified, the response includes only records beyond the marker, up to the  value specified by MaxRecords. If Marker is returned by a previous response, there are more results available.  The value of Marker is a unique pagination token for each page. To retrieve the next page,  make the call again using the returned token and keeping all other arguments unchanged.
        public let marker: String?
        /// A paginated list of metadata model exports.
        public let requests: [SchemaConversionRequest]?

        @inlinable
        public init(marker: String? = nil, requests: [SchemaConversionRequest]? = nil) {
            self.marker = marker
            self.requests = requests
        }

        private enum CodingKeys: String, CodingKey {
            case marker = "Marker"
            case requests = "Requests"
        }
    }

    public struct DescribeMetadataModelImportsMessage: AWSEncodableShape {
        /// Filters applied to the metadata model imports described in the form of key-value pairs.
        public let filters: [Filter]?
        /// Specifies the unique pagination token that makes it possible to display the next page of results.  If this parameter is specified, the response includes only records beyond the marker, up to the  value specified by MaxRecords. If Marker is returned by a previous response, there are more results available.  The value of Marker is a unique pagination token for each page. To retrieve the next page,  make the call again using the returned token and keeping all other arguments unchanged.
        public let marker: String?
        /// A paginated list of metadata model imports.
        public let maxRecords: Int?
        /// The migration project name or Amazon Resource Name (ARN).
        public let migrationProjectIdentifier: String

        @inlinable
        public init(filters: [Filter]? = nil, marker: String? = nil, maxRecords: Int? = nil, migrationProjectIdentifier: String) {
            self.filters = filters
            self.marker = marker
            self.maxRecords = maxRecords
            self.migrationProjectIdentifier = migrationProjectIdentifier
        }

        private enum CodingKeys: String, CodingKey {
            case filters = "Filters"
            case marker = "Marker"
            case maxRecords = "MaxRecords"
            case migrationProjectIdentifier = "MigrationProjectIdentifier"
        }
    }

    public struct DescribeMetadataModelImportsResponse: AWSDecodableShape {
        /// Specifies the unique pagination token that makes it possible to display the next page of results.  If this parameter is specified, the response includes only records beyond the marker, up to the  value specified by MaxRecords. If Marker is returned by a previous response, there are more results available.  The value of Marker is a unique pagination token for each page. To retrieve the next page,  make the call again using the returned token and keeping all other arguments unchanged.
        public let marker: String?
        /// A paginated list of metadata model imports.
        public let requests: [SchemaConversionRequest]?

        @inlinable
        public init(marker: String? = nil, requests: [SchemaConversionRequest]? = nil) {
            self.marker = marker
            self.requests = requests
        }

        private enum CodingKeys: String, CodingKey {
            case marker = "Marker"
            case requests = "Requests"
        }
    }

    public struct DescribeMigrationProjectsMessage: AWSEncodableShape {
        /// Filters applied to the migration projects described in the form of key-value pairs. Valid filter names and values:   instance-profile-identifier, instance profile arn or name   data-provider-identifier, data provider arn or name   migration-project-identifier, migration project arn or name
        public let filters: [Filter]?
        /// Specifies the unique pagination token that makes it possible to display the next page of results.  If this parameter is specified, the response includes only records beyond the marker, up to the  value specified by MaxRecords. If Marker is returned by a previous response, there are more results available.  The value of Marker is a unique pagination token for each page. To retrieve the next page,  make the call again using the returned token and keeping all other arguments unchanged.
        public let marker: String?
        /// The maximum number of records to include in the response. If more records exist than  the specified MaxRecords value, DMS includes a pagination token   in the response so that you can retrieve the remaining results.
        public let maxRecords: Int?

        @inlinable
        public init(filters: [Filter]? = nil, marker: String? = nil, maxRecords: Int? = nil) {
            self.filters = filters
            self.marker = marker
            self.maxRecords = maxRecords
        }

        private enum CodingKeys: String, CodingKey {
            case filters = "Filters"
            case marker = "Marker"
            case maxRecords = "MaxRecords"
        }
    }

    public struct DescribeMigrationProjectsResponse: AWSDecodableShape {
        /// Specifies the unique pagination token that makes it possible to display the next page of results.  If this parameter is specified, the response includes only records beyond the marker, up to the  value specified by MaxRecords. If Marker is returned by a previous response, there are more results available.  The value of Marker is a unique pagination token for each page. To retrieve the next page,  make the call again using the returned token and keeping all other arguments unchanged.
        public let marker: String?
        /// A description of migration projects.
        public let migrationProjects: [MigrationProject]?

        @inlinable
        public init(marker: String? = nil, migrationProjects: [MigrationProject]? = nil) {
            self.marker = marker
            self.migrationProjects = migrationProjects
        }

        private enum CodingKeys: String, CodingKey {
            case marker = "Marker"
            case migrationProjects = "MigrationProjects"
        }
    }

    public struct DescribeOrderableReplicationInstancesMessage: AWSEncodableShape {
        ///  An optional pagination token provided by a previous request. If this parameter is specified, the response includes only records beyond the marker, up to the value specified by MaxRecords.
        public let marker: String?
        ///  The maximum number of records to include in the response. If more records exist than the specified MaxRecords value, a pagination token called a marker is included in the response so that the remaining results can be retrieved.  Default: 100 Constraints: Minimum 20, maximum 100.
        public let maxRecords: Int?

        @inlinable
        public init(marker: String? = nil, maxRecords: Int? = nil) {
            self.marker = marker
            self.maxRecords = maxRecords
        }

        private enum CodingKeys: String, CodingKey {
            case marker = "Marker"
            case maxRecords = "MaxRecords"
        }
    }

    public struct DescribeOrderableReplicationInstancesResponse: AWSDecodableShape {
        ///  An optional pagination token provided by a previous request. If this parameter is specified, the response includes only records beyond the marker, up to the value specified by MaxRecords.
        public let marker: String?
        /// The order-able replication instances available.
        public let orderableReplicationInstances: [OrderableReplicationInstance]?

        @inlinable
        public init(marker: String? = nil, orderableReplicationInstances: [OrderableReplicationInstance]? = nil) {
            self.marker = marker
            self.orderableReplicationInstances = orderableReplicationInstances
        }

        private enum CodingKeys: String, CodingKey {
            case marker = "Marker"
            case orderableReplicationInstances = "OrderableReplicationInstances"
        }
    }

    public struct DescribePendingMaintenanceActionsMessage: AWSEncodableShape {
        public let filters: [Filter]?
        ///  An optional pagination token provided by a previous request. If this parameter is specified, the response includes only records beyond the marker, up to the value specified by MaxRecords.
        public let marker: String?
        ///  The maximum number of records to include in the response. If more records exist than the specified MaxRecords value, a pagination token called a marker is included in the response so that the remaining results can be retrieved.  Default: 100 Constraints: Minimum 20, maximum 100.
        public let maxRecords: Int?
        /// The Amazon Resource Name (ARN) of the replication instance.
        public let replicationInstanceArn: String?

        @inlinable
        public init(filters: [Filter]? = nil, marker: String? = nil, maxRecords: Int? = nil, replicationInstanceArn: String? = nil) {
            self.filters = filters
            self.marker = marker
            self.maxRecords = maxRecords
            self.replicationInstanceArn = replicationInstanceArn
        }

        private enum CodingKeys: String, CodingKey {
            case filters = "Filters"
            case marker = "Marker"
            case maxRecords = "MaxRecords"
            case replicationInstanceArn = "ReplicationInstanceArn"
        }
    }

    public struct DescribePendingMaintenanceActionsResponse: AWSDecodableShape {
        ///  An optional pagination token provided by a previous request. If this parameter is specified, the response includes only records beyond the marker, up to the value specified by MaxRecords.
        public let marker: String?
        /// The pending maintenance action.
        public let pendingMaintenanceActions: [ResourcePendingMaintenanceActions]?

        @inlinable
        public init(marker: String? = nil, pendingMaintenanceActions: [ResourcePendingMaintenanceActions]? = nil) {
            self.marker = marker
            self.pendingMaintenanceActions = pendingMaintenanceActions
        }

        private enum CodingKeys: String, CodingKey {
            case marker = "Marker"
            case pendingMaintenanceActions = "PendingMaintenanceActions"
        }
    }

    public struct DescribeRecommendationLimitationsRequest: AWSEncodableShape {
        /// Filters applied to the limitations described in the form of key-value pairs.
        public let filters: [Filter]?
        /// The maximum number of records to include in the response. If more records exist than the specified MaxRecords value, Fleet Advisor includes a pagination token in the response so that you can retrieve the remaining results.
        public let maxRecords: Int?
        /// Specifies the unique pagination token that makes it possible to display the next page of results. If this parameter is specified, the response includes only records beyond the marker, up to the value specified by MaxRecords. If NextToken is returned by a previous response, there are more results available. The value of NextToken is a unique pagination token for each page. Make the call again using the returned token to retrieve the next page. Keep all other arguments unchanged.
        public let nextToken: String?

        @inlinable
        public init(filters: [Filter]? = nil, maxRecords: Int? = nil, nextToken: String? = nil) {
            self.filters = filters
            self.maxRecords = maxRecords
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case filters = "Filters"
            case maxRecords = "MaxRecords"
            case nextToken = "NextToken"
        }
    }

    public struct DescribeRecommendationLimitationsResponse: AWSDecodableShape {
        /// The list of limitations for recommendations of target Amazon Web Services engines.
        public let limitations: [Limitation]?
        /// The unique pagination token returned for you to pass to a subsequent request. Fleet Advisor returns this token when the number of records in the response is greater than the MaxRecords value. To retrieve the next page, make the call again using the returned token and keeping all other arguments unchanged.
        public let nextToken: String?

        @inlinable
        public init(limitations: [Limitation]? = nil, nextToken: String? = nil) {
            self.limitations = limitations
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case limitations = "Limitations"
            case nextToken = "NextToken"
        }
    }

    public struct DescribeRecommendationsRequest: AWSEncodableShape {
        /// Filters applied to the target engine recommendations described in the form of key-value pairs.
        public let filters: [Filter]?
        /// The maximum number of records to include in the response. If more records exist than the specified MaxRecords value, Fleet Advisor includes a pagination token in the response so that you can retrieve the remaining results.
        public let maxRecords: Int?
        /// Specifies the unique pagination token that makes it possible to display the next page of results. If this parameter is specified, the response includes only records beyond the marker, up to the value specified by MaxRecords. If NextToken is returned by a previous response, there are more results available. The value of NextToken is a unique pagination token for each page. Make the call again using the returned token to retrieve the next page. Keep all other arguments unchanged.
        public let nextToken: String?

        @inlinable
        public init(filters: [Filter]? = nil, maxRecords: Int? = nil, nextToken: String? = nil) {
            self.filters = filters
            self.maxRecords = maxRecords
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case filters = "Filters"
            case maxRecords = "MaxRecords"
            case nextToken = "NextToken"
        }
    }

    public struct DescribeRecommendationsResponse: AWSDecodableShape {
        /// The unique pagination token returned for you to pass to a subsequent request. Fleet Advisor returns this token when the number of records in the response is greater than the MaxRecords value. To retrieve the next page, make the call again using the returned token and keeping all other arguments unchanged.
        public let nextToken: String?
        /// The list of recommendations of target engines that Fleet Advisor created for the source database.
        public let recommendations: [Recommendation]?

        @inlinable
        public init(nextToken: String? = nil, recommendations: [Recommendation]? = nil) {
            self.nextToken = nextToken
            self.recommendations = recommendations
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "NextToken"
            case recommendations = "Recommendations"
        }
    }

    public struct DescribeRefreshSchemasStatusMessage: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) string that uniquely identifies the endpoint.
        public let endpointArn: String

        @inlinable
        public init(endpointArn: String) {
            self.endpointArn = endpointArn
        }

        private enum CodingKeys: String, CodingKey {
            case endpointArn = "EndpointArn"
        }
    }

    public struct DescribeRefreshSchemasStatusResponse: AWSDecodableShape {
        /// The status of the schema.
        public let refreshSchemasStatus: RefreshSchemasStatus?

        @inlinable
        public init(refreshSchemasStatus: RefreshSchemasStatus? = nil) {
            self.refreshSchemasStatus = refreshSchemasStatus
        }

        private enum CodingKeys: String, CodingKey {
            case refreshSchemasStatus = "RefreshSchemasStatus"
        }
    }

    public struct DescribeReplicationConfigsMessage: AWSEncodableShape {
        /// Filters applied to the replication configs.
        public let filters: [Filter]?
        /// An optional pagination token provided by a previous request. If this parameter is specified, the response includes only records beyond the marker, up to the value specified by MaxRecords.
        public let marker: String?
        /// The maximum number of records to include in the response. If more records exist than the specified MaxRecords value, a pagination token called a marker is included in the response so that the remaining results can be retrieved.
        public let maxRecords: Int?

        @inlinable
        public init(filters: [Filter]? = nil, marker: String? = nil, maxRecords: Int? = nil) {
            self.filters = filters
            self.marker = marker
            self.maxRecords = maxRecords
        }

        private enum CodingKeys: String, CodingKey {
            case filters = "Filters"
            case marker = "Marker"
            case maxRecords = "MaxRecords"
        }
    }

    public struct DescribeReplicationConfigsResponse: AWSDecodableShape {
        /// An optional pagination token provided by a previous request. If this parameter is specified, the response includes only records beyond the marker, up to the value specified by MaxRecords.
        public let marker: String?
        /// Returned configuration parameters that describe each provisioned DMS Serverless replication.
        public let replicationConfigs: [ReplicationConfig]?

        @inlinable
        public init(marker: String? = nil, replicationConfigs: [ReplicationConfig]? = nil) {
            self.marker = marker
            self.replicationConfigs = replicationConfigs
        }

        private enum CodingKeys: String, CodingKey {
            case marker = "Marker"
            case replicationConfigs = "ReplicationConfigs"
        }
    }

    public struct DescribeReplicationInstanceTaskLogsMessage: AWSEncodableShape {
        ///  An optional pagination token provided by a previous request. If this parameter is specified, the response includes only records beyond the marker, up to the value specified by MaxRecords.
        public let marker: String?
        ///  The maximum number of records to include in the response. If more records exist than the specified MaxRecords value, a pagination token called a marker is included in the response so that the remaining results can be retrieved.  Default: 100 Constraints: Minimum 20, maximum 100.
        public let maxRecords: Int?
        /// The Amazon Resource Name (ARN) of the replication instance.
        public let replicationInstanceArn: String

        @inlinable
        public init(marker: String? = nil, maxRecords: Int? = nil, replicationInstanceArn: String) {
            self.marker = marker
            self.maxRecords = maxRecords
            self.replicationInstanceArn = replicationInstanceArn
        }

        private enum CodingKeys: String, CodingKey {
            case marker = "Marker"
            case maxRecords = "MaxRecords"
            case replicationInstanceArn = "ReplicationInstanceArn"
        }
    }

    public struct DescribeReplicationInstanceTaskLogsResponse: AWSDecodableShape {
        ///  An optional pagination token provided by a previous request. If this parameter is specified, the response includes only records beyond the marker, up to the value specified by MaxRecords.
        public let marker: String?
        /// The Amazon Resource Name (ARN) of the replication instance.
        public let replicationInstanceArn: String?
        /// An array of replication task log metadata. Each member of the array contains the replication task name, ARN, and task log size (in bytes).
        public let replicationInstanceTaskLogs: [ReplicationInstanceTaskLog]?

        @inlinable
        public init(marker: String? = nil, replicationInstanceArn: String? = nil, replicationInstanceTaskLogs: [ReplicationInstanceTaskLog]? = nil) {
            self.marker = marker
            self.replicationInstanceArn = replicationInstanceArn
            self.replicationInstanceTaskLogs = replicationInstanceTaskLogs
        }

        private enum CodingKeys: String, CodingKey {
            case marker = "Marker"
            case replicationInstanceArn = "ReplicationInstanceArn"
            case replicationInstanceTaskLogs = "ReplicationInstanceTaskLogs"
        }
    }

    public struct DescribeReplicationInstancesMessage: AWSEncodableShape {
        /// Filters applied to replication instances. Valid filter names: replication-instance-arn | replication-instance-id | replication-instance-class | engine-version
        public let filters: [Filter]?
        ///  An optional pagination token provided by a previous request. If this parameter is specified, the response includes only records beyond the marker, up to the value specified by MaxRecords.
        public let marker: String?
        ///  The maximum number of records to include in the response. If more records exist than the specified MaxRecords value, a pagination token called a marker is included in the response so that the remaining results can be retrieved.  Default: 100 Constraints: Minimum 20, maximum 100.
        public let maxRecords: Int?

        @inlinable
        public init(filters: [Filter]? = nil, marker: String? = nil, maxRecords: Int? = nil) {
            self.filters = filters
            self.marker = marker
            self.maxRecords = maxRecords
        }

        private enum CodingKeys: String, CodingKey {
            case filters = "Filters"
            case marker = "Marker"
            case maxRecords = "MaxRecords"
        }
    }

    public struct DescribeReplicationInstancesResponse: AWSDecodableShape {
        ///  An optional pagination token provided by a previous request. If this parameter is specified, the response includes only records beyond the marker, up to the value specified by MaxRecords.
        public let marker: String?
        /// The replication instances described.
        public let replicationInstances: [ReplicationInstance]?

        @inlinable
        public init(marker: String? = nil, replicationInstances: [ReplicationInstance]? = nil) {
            self.marker = marker
            self.replicationInstances = replicationInstances
        }

        private enum CodingKeys: String, CodingKey {
            case marker = "Marker"
            case replicationInstances = "ReplicationInstances"
        }
    }

    public struct DescribeReplicationSubnetGroupsMessage: AWSEncodableShape {
        /// Filters applied to replication subnet groups. Valid filter names: replication-subnet-group-id
        public let filters: [Filter]?
        ///  An optional pagination token provided by a previous request. If this parameter is specified, the response includes only records beyond the marker, up to the value specified by MaxRecords.
        public let marker: String?
        ///  The maximum number of records to include in the response. If more records exist than the specified MaxRecords value, a pagination token called a marker is included in the response so that the remaining results can be retrieved.  Default: 100 Constraints: Minimum 20, maximum 100.
        public let maxRecords: Int?

        @inlinable
        public init(filters: [Filter]? = nil, marker: String? = nil, maxRecords: Int? = nil) {
            self.filters = filters
            self.marker = marker
            self.maxRecords = maxRecords
        }

        private enum CodingKeys: String, CodingKey {
            case filters = "Filters"
            case marker = "Marker"
            case maxRecords = "MaxRecords"
        }
    }

    public struct DescribeReplicationSubnetGroupsResponse: AWSDecodableShape {
        ///  An optional pagination token provided by a previous request. If this parameter is specified, the response includes only records beyond the marker, up to the value specified by MaxRecords.
        public let marker: String?
        /// A description of the replication subnet groups.
        public let replicationSubnetGroups: [ReplicationSubnetGroup]?

        @inlinable
        public init(marker: String? = nil, replicationSubnetGroups: [ReplicationSubnetGroup]? = nil) {
            self.marker = marker
            self.replicationSubnetGroups = replicationSubnetGroups
        }

        private enum CodingKeys: String, CodingKey {
            case marker = "Marker"
            case replicationSubnetGroups = "ReplicationSubnetGroups"
        }
    }

    public struct DescribeReplicationTableStatisticsMessage: AWSEncodableShape {
        /// Filters applied to the replication table statistics.
        public let filters: [Filter]?
        /// An optional pagination token provided by a previous request. If this parameter is specified, the response includes only records beyond the marker, up to the value specified by MaxRecords.
        public let marker: String?
        /// The maximum number of records to include in the response. If more records exist than the specified MaxRecords value, a pagination token called a marker is included in the response so that the remaining results can be retrieved.
        public let maxRecords: Int?
        /// The replication config to describe.
        public let replicationConfigArn: String

        @inlinable
        public init(filters: [Filter]? = nil, marker: String? = nil, maxRecords: Int? = nil, replicationConfigArn: String) {
            self.filters = filters
            self.marker = marker
            self.maxRecords = maxRecords
            self.replicationConfigArn = replicationConfigArn
        }

        private enum CodingKeys: String, CodingKey {
            case filters = "Filters"
            case marker = "Marker"
            case maxRecords = "MaxRecords"
            case replicationConfigArn = "ReplicationConfigArn"
        }
    }

    public struct DescribeReplicationTableStatisticsResponse: AWSDecodableShape {
        /// An optional pagination token provided by a previous request. If this parameter is specified, the response includes only records beyond the marker, up to the value specified by MaxRecords.
        public let marker: String?
        /// The Amazon Resource Name of the replication config.
        public let replicationConfigArn: String?
        /// Returns table statistics on the replication, including table name, rows inserted, rows updated, and rows deleted.
        public let replicationTableStatistics: [TableStatistics]?

        @inlinable
        public init(marker: String? = nil, replicationConfigArn: String? = nil, replicationTableStatistics: [TableStatistics]? = nil) {
            self.marker = marker
            self.replicationConfigArn = replicationConfigArn
            self.replicationTableStatistics = replicationTableStatistics
        }

        private enum CodingKeys: String, CodingKey {
            case marker = "Marker"
            case replicationConfigArn = "ReplicationConfigArn"
            case replicationTableStatistics = "ReplicationTableStatistics"
        }
    }

    public struct DescribeReplicationTaskAssessmentResultsMessage: AWSEncodableShape {
        ///  An optional pagination token provided by a previous request. If this parameter is specified, the response includes only records beyond the marker, up to the value specified by MaxRecords.
        public let marker: String?
        ///  The maximum number of records to include in the response. If more records exist than the specified MaxRecords value, a pagination token called a marker is included in the response so that the remaining results can be retrieved.  Default: 100 Constraints: Minimum 20, maximum 100.
        public let maxRecords: Int?
        /// The Amazon Resource Name (ARN) string that uniquely identifies the task. When this input parameter is specified, the API returns only one result and ignore the values of the MaxRecords and Marker parameters.
        public let replicationTaskArn: String?

        @inlinable
        public init(marker: String? = nil, maxRecords: Int? = nil, replicationTaskArn: String? = nil) {
            self.marker = marker
            self.maxRecords = maxRecords
            self.replicationTaskArn = replicationTaskArn
        }

        private enum CodingKeys: String, CodingKey {
            case marker = "Marker"
            case maxRecords = "MaxRecords"
            case replicationTaskArn = "ReplicationTaskArn"
        }
    }

    public struct DescribeReplicationTaskAssessmentResultsResponse: AWSDecodableShape {
        /// - The Amazon S3 bucket where the task assessment report is located.
        public let bucketName: String?
        ///  An optional pagination token provided by a previous request. If this parameter is specified, the response includes only records beyond the marker, up to the value specified by MaxRecords.
        public let marker: String?
        ///  The task assessment report.
        public let replicationTaskAssessmentResults: [ReplicationTaskAssessmentResult]?

        @inlinable
        public init(bucketName: String? = nil, marker: String? = nil, replicationTaskAssessmentResults: [ReplicationTaskAssessmentResult]? = nil) {
            self.bucketName = bucketName
            self.marker = marker
            self.replicationTaskAssessmentResults = replicationTaskAssessmentResults
        }

        private enum CodingKeys: String, CodingKey {
            case bucketName = "BucketName"
            case marker = "Marker"
            case replicationTaskAssessmentResults = "ReplicationTaskAssessmentResults"
        }
    }

    public struct DescribeReplicationTaskAssessmentRunsMessage: AWSEncodableShape {
        /// Filters applied to the premigration assessment runs described in the form of key-value pairs. Valid filter names: replication-task-assessment-run-arn, replication-task-arn, replication-instance-arn, status
        public let filters: [Filter]?
        /// An optional pagination token provided by a previous request. If this parameter is specified, the response includes only records beyond the marker, up to the value specified by MaxRecords.
        public let marker: String?
        /// The maximum number of records to include in the response. If more records exist than the specified MaxRecords value, a pagination token called a marker is included in the response so that the remaining results can be retrieved.
        public let maxRecords: Int?

        @inlinable
        public init(filters: [Filter]? = nil, marker: String? = nil, maxRecords: Int? = nil) {
            self.filters = filters
            self.marker = marker
            self.maxRecords = maxRecords
        }

        private enum CodingKeys: String, CodingKey {
            case filters = "Filters"
            case marker = "Marker"
            case maxRecords = "MaxRecords"
        }
    }

    public struct DescribeReplicationTaskAssessmentRunsResponse: AWSDecodableShape {
        /// A pagination token returned for you to pass to a subsequent request. If you pass this token as the Marker value in a subsequent request, the response includes only records beyond the marker, up to the value specified in the request by MaxRecords.
        public let marker: String?
        /// One or more premigration assessment runs as specified by Filters.
        public let replicationTaskAssessmentRuns: [ReplicationTaskAssessmentRun]?

        @inlinable
        public init(marker: String? = nil, replicationTaskAssessmentRuns: [ReplicationTaskAssessmentRun]? = nil) {
            self.marker = marker
            self.replicationTaskAssessmentRuns = replicationTaskAssessmentRuns
        }

        private enum CodingKeys: String, CodingKey {
            case marker = "Marker"
            case replicationTaskAssessmentRuns = "ReplicationTaskAssessmentRuns"
        }
    }

    public struct DescribeReplicationTaskIndividualAssessmentsMessage: AWSEncodableShape {
        /// Filters applied to the individual assessments described in the form of key-value pairs. Valid filter names: replication-task-assessment-run-arn, replication-task-arn, status
        public let filters: [Filter]?
        /// An optional pagination token provided by a previous request. If this parameter is specified, the response includes only records beyond the marker, up to the value specified by MaxRecords.
        public let marker: String?
        /// The maximum number of records to include in the response. If more records exist than the specified MaxRecords value, a pagination token called a marker is included in the response so that the remaining results can be retrieved.
        public let maxRecords: Int?

        @inlinable
        public init(filters: [Filter]? = nil, marker: String? = nil, maxRecords: Int? = nil) {
            self.filters = filters
            self.marker = marker
            self.maxRecords = maxRecords
        }

        private enum CodingKeys: String, CodingKey {
            case filters = "Filters"
            case marker = "Marker"
            case maxRecords = "MaxRecords"
        }
    }

    public struct DescribeReplicationTaskIndividualAssessmentsResponse: AWSDecodableShape {
        /// A pagination token returned for you to pass to a subsequent request. If you pass this token as the Marker value in a subsequent request, the response includes only records beyond the marker, up to the value specified in the request by MaxRecords.
        public let marker: String?
        /// One or more individual assessments as specified by Filters.
        public let replicationTaskIndividualAssessments: [ReplicationTaskIndividualAssessment]?

        @inlinable
        public init(marker: String? = nil, replicationTaskIndividualAssessments: [ReplicationTaskIndividualAssessment]? = nil) {
            self.marker = marker
            self.replicationTaskIndividualAssessments = replicationTaskIndividualAssessments
        }

        private enum CodingKeys: String, CodingKey {
            case marker = "Marker"
            case replicationTaskIndividualAssessments = "ReplicationTaskIndividualAssessments"
        }
    }

    public struct DescribeReplicationTasksMessage: AWSEncodableShape {
        /// Filters applied to replication tasks. Valid filter names: replication-task-arn | replication-task-id | migration-type | endpoint-arn | replication-instance-arn
        public let filters: [Filter]?
        ///  An optional pagination token provided by a previous request. If this parameter is specified, the response includes only records beyond the marker, up to the value specified by MaxRecords.
        public let marker: String?
        ///  The maximum number of records to include in the response. If more records exist than the specified MaxRecords value, a pagination token called a marker is included in the response so that the remaining results can be retrieved.  Default: 100 Constraints: Minimum 20, maximum 100.
        public let maxRecords: Int?
        /// An option to set to avoid returning information about settings. Use this to reduce overhead when setting information is too large. To use this option, choose true; otherwise, choose false (the default).
        public let withoutSettings: Bool?

        @inlinable
        public init(filters: [Filter]? = nil, marker: String? = nil, maxRecords: Int? = nil, withoutSettings: Bool? = nil) {
            self.filters = filters
            self.marker = marker
            self.maxRecords = maxRecords
            self.withoutSettings = withoutSettings
        }

        private enum CodingKeys: String, CodingKey {
            case filters = "Filters"
            case marker = "Marker"
            case maxRecords = "MaxRecords"
            case withoutSettings = "WithoutSettings"
        }
    }

    public struct DescribeReplicationTasksResponse: AWSDecodableShape {
        ///  An optional pagination token provided by a previous request. If this parameter is specified, the response includes only records beyond the marker, up to the value specified by MaxRecords.
        public let marker: String?
        /// A description of the replication tasks.
        public let replicationTasks: [ReplicationTask]?

        @inlinable
        public init(marker: String? = nil, replicationTasks: [ReplicationTask]? = nil) {
            self.marker = marker
            self.replicationTasks = replicationTasks
        }

        private enum CodingKeys: String, CodingKey {
            case marker = "Marker"
            case replicationTasks = "ReplicationTasks"
        }
    }

    public struct DescribeReplicationsMessage: AWSEncodableShape {
        /// Filters applied to the replications.
        public let filters: [Filter]?
        /// An optional pagination token provided by a previous request. If this parameter is specified, the response includes only records beyond the marker, up to the value specified by MaxRecords.
        public let marker: String?
        /// The maximum number of records to include in the response. If more records exist than the specified MaxRecords value, a pagination token called a marker is included in the response so that the remaining results can be retrieved.
        public let maxRecords: Int?

        @inlinable
        public init(filters: [Filter]? = nil, marker: String? = nil, maxRecords: Int? = nil) {
            self.filters = filters
            self.marker = marker
            self.maxRecords = maxRecords
        }

        private enum CodingKeys: String, CodingKey {
            case filters = "Filters"
            case marker = "Marker"
            case maxRecords = "MaxRecords"
        }
    }

    public struct DescribeReplicationsResponse: AWSDecodableShape {
        /// An optional pagination token provided by a previous request. If this parameter is specified, the response includes only records beyond the marker, up to the value specified by MaxRecords.
        public let marker: String?
        /// The replication descriptions.
        public let replications: [Replication]?

        @inlinable
        public init(marker: String? = nil, replications: [Replication]? = nil) {
            self.marker = marker
            self.replications = replications
        }

        private enum CodingKeys: String, CodingKey {
            case marker = "Marker"
            case replications = "Replications"
        }
    }

    public struct DescribeSchemasMessage: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) string that uniquely identifies the endpoint.
        public let endpointArn: String
        ///  An optional pagination token provided by a previous request. If this parameter is specified, the response includes only records beyond the marker, up to the value specified by MaxRecords.
        public let marker: String?
        ///  The maximum number of records to include in the response. If more records exist than the specified MaxRecords value, a pagination token called a marker is included in the response so that the remaining results can be retrieved.  Default: 100 Constraints: Minimum 20, maximum 100.
        public let maxRecords: Int?

        @inlinable
        public init(endpointArn: String, marker: String? = nil, maxRecords: Int? = nil) {
            self.endpointArn = endpointArn
            self.marker = marker
            self.maxRecords = maxRecords
        }

        private enum CodingKeys: String, CodingKey {
            case endpointArn = "EndpointArn"
            case marker = "Marker"
            case maxRecords = "MaxRecords"
        }
    }

    public struct DescribeSchemasResponse: AWSDecodableShape {
        ///  An optional pagination token provided by a previous request. If this parameter is specified, the response includes only records beyond the marker, up to the value specified by MaxRecords.
        public let marker: String?
        /// The described schema.
        public let schemas: [String]?

        @inlinable
        public init(marker: String? = nil, schemas: [String]? = nil) {
            self.marker = marker
            self.schemas = schemas
        }

        private enum CodingKeys: String, CodingKey {
            case marker = "Marker"
            case schemas = "Schemas"
        }
    }

    public struct DescribeTableStatisticsMessage: AWSEncodableShape {
        /// Filters applied to table statistics. Valid filter names: schema-name | table-name | table-state A combination of filters creates an AND condition where each record matches all specified filters.
        public let filters: [Filter]?
        ///  An optional pagination token provided by a previous request. If this parameter is specified, the response includes only records beyond the marker, up to the value specified by MaxRecords.
        public let marker: String?
        ///  The maximum number of records to include in the response. If more records exist than the specified MaxRecords value, a pagination token called a marker is included in the response so that the remaining results can be retrieved.  Default: 100 Constraints: Minimum 20, maximum 500.
        public let maxRecords: Int?
        /// The Amazon Resource Name (ARN) of the replication task.
        public let replicationTaskArn: String

        @inlinable
        public init(filters: [Filter]? = nil, marker: String? = nil, maxRecords: Int? = nil, replicationTaskArn: String) {
            self.filters = filters
            self.marker = marker
            self.maxRecords = maxRecords
            self.replicationTaskArn = replicationTaskArn
        }

        private enum CodingKeys: String, CodingKey {
            case filters = "Filters"
            case marker = "Marker"
            case maxRecords = "MaxRecords"
            case replicationTaskArn = "ReplicationTaskArn"
        }
    }

    public struct DescribeTableStatisticsResponse: AWSDecodableShape {
        ///  An optional pagination token provided by a previous request. If this parameter is specified, the response includes only records beyond the marker, up to the value specified by MaxRecords.
        public let marker: String?
        /// The Amazon Resource Name (ARN) of the replication task.
        public let replicationTaskArn: String?
        /// The table statistics.
        public let tableStatistics: [TableStatistics]?

        @inlinable
        public init(marker: String? = nil, replicationTaskArn: String? = nil, tableStatistics: [TableStatistics]? = nil) {
            self.marker = marker
            self.replicationTaskArn = replicationTaskArn
            self.tableStatistics = tableStatistics
        }

        private enum CodingKeys: String, CodingKey {
            case marker = "Marker"
            case replicationTaskArn = "ReplicationTaskArn"
            case tableStatistics = "TableStatistics"
        }
    }

    public struct DmsTransferSettings: AWSEncodableShape & AWSDecodableShape {
        ///  The name of the S3 bucket to use.
        public let bucketName: String?
        /// The Amazon Resource Name (ARN) used by the service access IAM role. The role must allow the iam:PassRole action.
        public let serviceAccessRoleArn: String?

        @inlinable
        public init(bucketName: String? = nil, serviceAccessRoleArn: String? = nil) {
            self.bucketName = bucketName
            self.serviceAccessRoleArn = serviceAccessRoleArn
        }

        private enum CodingKeys: String, CodingKey {
            case bucketName = "BucketName"
            case serviceAccessRoleArn = "ServiceAccessRoleArn"
        }
    }

    public struct DocDbDataProviderSettings: AWSEncodableShape & AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the certificate used for SSL connection.
        public let certificateArn: String?
        /// The database name on the DocumentDB data provider.
        public let databaseName: String?
        /// The port value for the DocumentDB data provider.
        public let port: Int?
        /// The name of the source DocumentDB server.
        public let serverName: String?
        /// The SSL mode used to connect to the DocumentDB data provider.  The default value is none.
        public let sslMode: DmsSslModeValue?

        @inlinable
        public init(certificateArn: String? = nil, databaseName: String? = nil, port: Int? = nil, serverName: String? = nil, sslMode: DmsSslModeValue? = nil) {
            self.certificateArn = certificateArn
            self.databaseName = databaseName
            self.port = port
            self.serverName = serverName
            self.sslMode = sslMode
        }

        private enum CodingKeys: String, CodingKey {
            case certificateArn = "CertificateArn"
            case databaseName = "DatabaseName"
            case port = "Port"
            case serverName = "ServerName"
            case sslMode = "SslMode"
        }
    }

    public struct DocDbSettings: AWSEncodableShape & AWSDecodableShape {
        ///  The database name on the DocumentDB source endpoint.
        public let databaseName: String?
        ///  Indicates the number of documents to preview to determine the document organization. Use this setting when NestingLevel is set to "one".  Must be a positive value greater than 0. Default value is 1000.
        public let docsToInvestigate: Int?
        ///  Specifies the document ID. Use this setting when NestingLevel is set to "none".  Default value is "false".
        public let extractDocId: Bool?
        /// The KMS key identifier that is used to encrypt the content on the replication instance. If you don't specify a value for the KmsKeyId parameter, then DMS uses your default encryption key. KMS creates the default encryption key for your Amazon Web Services account. Your Amazon Web Services account has a different default encryption key for each Amazon Web Services Region.
        public let kmsKeyId: String?
        ///  Specifies either document or table mode.  Default value is "none". Specify "none" to use document mode. Specify "one" to use table mode.
        public let nestingLevel: NestingLevelValue?
        ///  The password for the user account you use to access the DocumentDB source endpoint.
        public let password: String?
        ///  The port value for the DocumentDB source endpoint.
        public let port: Int?
        /// If true, DMS replicates data to shard collections. DMS only uses this setting if the target endpoint is a DocumentDB elastic cluster. When this setting is true, note the following:   You must set TargetTablePrepMode to nothing.   DMS automatically sets useUpdateLookup to false.
        public let replicateShardCollections: Bool?
        /// The full Amazon Resource Name (ARN) of the IAM role that specifies DMS as the trusted entity and grants the required permissions to access the value in SecretsManagerSecret. The role must allow the iam:PassRole action. SecretsManagerSecret has the value of the Amazon Web Services Secrets Manager secret that allows access to the DocumentDB endpoint.  You can specify one of two sets of values for these permissions. You can specify the values for this setting and SecretsManagerSecretId. Or you can specify clear-text values for UserName, Password, ServerName, and Port. You can't specify both. For more information on creating this SecretsManagerSecret and the SecretsManagerAccessRoleArn and SecretsManagerSecretId required to access it, see Using secrets to access Database Migration Service resources in the Database Migration Service User Guide.
        public let secretsManagerAccessRoleArn: String?
        /// The full ARN, partial ARN, or friendly name of the SecretsManagerSecret that contains the DocumentDB endpoint connection details.
        public let secretsManagerSecretId: String?
        ///  The name of the server on the DocumentDB source endpoint.
        public let serverName: String?
        /// The user name you use to access the DocumentDB source endpoint.
        public let username: String?
        /// If true, DMS retrieves the entire document from the DocumentDB source during migration. This may cause a migration failure if the server response exceeds bandwidth limits. To fetch only updates and deletes during migration, set this parameter to false.
        public let useUpdateLookUp: Bool?

        @inlinable
        public init(databaseName: String? = nil, docsToInvestigate: Int? = nil, extractDocId: Bool? = nil, kmsKeyId: String? = nil, nestingLevel: NestingLevelValue? = nil, password: String? = nil, port: Int? = nil, replicateShardCollections: Bool? = nil, secretsManagerAccessRoleArn: String? = nil, secretsManagerSecretId: String? = nil, serverName: String? = nil, username: String? = nil, useUpdateLookUp: Bool? = nil) {
            self.databaseName = databaseName
            self.docsToInvestigate = docsToInvestigate
            self.extractDocId = extractDocId
            self.kmsKeyId = kmsKeyId
            self.nestingLevel = nestingLevel
            self.password = password
            self.port = port
            self.replicateShardCollections = replicateShardCollections
            self.secretsManagerAccessRoleArn = secretsManagerAccessRoleArn
            self.secretsManagerSecretId = secretsManagerSecretId
            self.serverName = serverName
            self.username = username
            self.useUpdateLookUp = useUpdateLookUp
        }

        private enum CodingKeys: String, CodingKey {
            case databaseName = "DatabaseName"
            case docsToInvestigate = "DocsToInvestigate"
            case extractDocId = "ExtractDocId"
            case kmsKeyId = "KmsKeyId"
            case nestingLevel = "NestingLevel"
            case password = "Password"
            case port = "Port"
            case replicateShardCollections = "ReplicateShardCollections"
            case secretsManagerAccessRoleArn = "SecretsManagerAccessRoleArn"
            case secretsManagerSecretId = "SecretsManagerSecretId"
            case serverName = "ServerName"
            case username = "Username"
            case useUpdateLookUp = "UseUpdateLookUp"
        }
    }

    public struct DynamoDbSettings: AWSEncodableShape & AWSDecodableShape {
        ///  The Amazon Resource Name (ARN) used by the service to access the IAM role. The role must allow the iam:PassRole action.
        public let serviceAccessRoleArn: String

        @inlinable
        public init(serviceAccessRoleArn: String) {
            self.serviceAccessRoleArn = serviceAccessRoleArn
        }

        private enum CodingKeys: String, CodingKey {
            case serviceAccessRoleArn = "ServiceAccessRoleArn"
        }
    }

    public struct ElasticsearchSettings: AWSEncodableShape & AWSDecodableShape {
        /// The endpoint for the OpenSearch cluster. DMS uses HTTPS if a transport protocol (http/https) is not specified.
        public let endpointUri: String
        /// The maximum number of seconds for which DMS retries failed API requests to the OpenSearch cluster.
        public let errorRetryDuration: Int?
        /// The maximum percentage of records that can fail to be written before a full load operation stops. To avoid early failure, this counter is only effective after 1000 records are transferred. OpenSearch also has the concept of error monitoring during the last 10 minutes of an Observation Window. If transfer of all records fail in the last 10 minutes, the full load operation stops.
        public let fullLoadErrorPercentage: Int?
        /// The Amazon Resource Name (ARN) used by the service to access the IAM role. The role must allow the iam:PassRole action.
        public let serviceAccessRoleArn: String
        /// Set this option to true for DMS to migrate documentation using the documentation type _doc. OpenSearch and an Elasticsearch cluster only support the _doc documentation type in versions 7. x and later. The default value is false.
        public let useNewMappingType: Bool?

        @inlinable
        public init(endpointUri: String, errorRetryDuration: Int? = nil, fullLoadErrorPercentage: Int? = nil, serviceAccessRoleArn: String, useNewMappingType: Bool? = nil) {
            self.endpointUri = endpointUri
            self.errorRetryDuration = errorRetryDuration
            self.fullLoadErrorPercentage = fullLoadErrorPercentage
            self.serviceAccessRoleArn = serviceAccessRoleArn
            self.useNewMappingType = useNewMappingType
        }

        private enum CodingKeys: String, CodingKey {
            case endpointUri = "EndpointUri"
            case errorRetryDuration = "ErrorRetryDuration"
            case fullLoadErrorPercentage = "FullLoadErrorPercentage"
            case serviceAccessRoleArn = "ServiceAccessRoleArn"
            case useNewMappingType = "UseNewMappingType"
        }
    }

    public struct Endpoint: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) used for SSL connection to the endpoint.
        public let certificateArn: String?
        /// The name of the database at the endpoint.
        public let databaseName: String?
        /// The settings for the DMS Transfer type source. For more information, see the DmsTransferSettings structure.
        public let dmsTransferSettings: DmsTransferSettings?
        public let docDbSettings: DocDbSettings?
        /// The settings for the DynamoDB target endpoint. For more information, see the DynamoDBSettings structure.
        public let dynamoDbSettings: DynamoDbSettings?
        /// The settings for the OpenSearch source endpoint. For more information, see the ElasticsearchSettings structure.
        public let elasticsearchSettings: ElasticsearchSettings?
        /// The Amazon Resource Name (ARN) string that uniquely identifies the endpoint.
        public let endpointArn: String?
        /// The database endpoint identifier. Identifiers must begin with a letter and must contain only ASCII letters, digits, and hyphens. They can't end with a hyphen or contain two consecutive hyphens.
        public let endpointIdentifier: String?
        /// The type of endpoint. Valid values are source and target.
        public let endpointType: ReplicationEndpointTypeValue?
        /// The expanded name for the engine name. For example, if the EngineName parameter is "aurora", this value would be "Amazon Aurora MySQL".
        public let engineDisplayName: String?
        /// The database engine name. Valid values, depending on the EndpointType, include "mysql", "oracle", "postgres", "mariadb", "aurora", "aurora-postgresql", "redshift", "redshift-serverless", "s3", "db2", "db2-zos", "azuredb", "sybase", "dynamodb", "mongodb", "kinesis", "kafka", "elasticsearch", "documentdb", "sqlserver", "neptune", and "babelfish".
        public let engineName: String?
        ///  Value returned by a call to CreateEndpoint that can be used for cross-account validation. Use it on a subsequent call to CreateEndpoint to create the endpoint with a cross-account.
        public let externalId: String?
        /// The external table definition.
        public let externalTableDefinition: String?
        /// Additional connection attributes used to connect to the endpoint.
        public let extraConnectionAttributes: String?
        /// Settings in JSON format for the source GCP MySQL endpoint.
        public let gcpMySQLSettings: GcpMySQLSettings?
        /// The settings for the IBM Db2 LUW source endpoint. For more information, see the IBMDb2Settings structure.
        public let ibmDb2Settings: IBMDb2Settings?
        /// The settings for the Apache Kafka target endpoint. For more information, see the KafkaSettings structure.
        public let kafkaSettings: KafkaSettings?
        /// The settings for the Amazon Kinesis target endpoint. For more information, see the KinesisSettings structure.
        public let kinesisSettings: KinesisSettings?
        /// An KMS key identifier that is used to encrypt the connection parameters for the endpoint. If you don't specify a value for the KmsKeyId parameter, then DMS uses your default encryption key. KMS creates the default encryption key for your Amazon Web Services account. Your Amazon Web Services account has a different default encryption key for each Amazon Web Services Region.
        public let kmsKeyId: String?
        /// The settings for the Microsoft SQL Server source and target endpoint. For more information, see the MicrosoftSQLServerSettings structure.
        public let microsoftSQLServerSettings: MicrosoftSQLServerSettings?
        /// The settings for the MongoDB source endpoint. For more information, see the MongoDbSettings structure.
        public let mongoDbSettings: MongoDbSettings?
        /// The settings for the MySQL source and target endpoint. For more information, see the MySQLSettings structure.
        public let mySQLSettings: MySQLSettings?
        /// The settings for the Amazon Neptune target endpoint. For more information, see the NeptuneSettings structure.
        public let neptuneSettings: NeptuneSettings?
        /// The settings for the Oracle source and target endpoint. For more information, see the OracleSettings structure.
        public let oracleSettings: OracleSettings?
        /// The port value used to access the endpoint.
        public let port: Int?
        /// The settings for the PostgreSQL source and target endpoint. For more information, see the PostgreSQLSettings structure.
        public let postgreSQLSettings: PostgreSQLSettings?
        /// The settings for the Redis target endpoint. For more information, see the RedisSettings structure.
        public let redisSettings: RedisSettings?
        /// Settings for the Amazon Redshift endpoint.
        public let redshiftSettings: RedshiftSettings?
        /// The settings for the S3 target endpoint. For more information, see the S3Settings structure.
        public let s3Settings: S3Settings?
        /// The name of the server at the endpoint.
        public let serverName: String?
        /// The Amazon Resource Name (ARN) used by the service to access the IAM role. The role must allow the iam:PassRole action.
        public let serviceAccessRoleArn: String?
        /// The SSL mode used to connect to the endpoint. The default value is none.
        public let sslMode: DmsSslModeValue?
        /// The status of the endpoint.
        public let status: String?
        /// The settings for the SAP ASE source and target endpoint. For more information, see the SybaseSettings structure.
        public let sybaseSettings: SybaseSettings?
        /// The settings for the Amazon Timestream target endpoint. For more information, see the TimestreamSettings structure.
        public let timestreamSettings: TimestreamSettings?
        /// The user name used to connect to the endpoint.
        public let username: String?

        @inlinable
        public init(certificateArn: String? = nil, databaseName: String? = nil, dmsTransferSettings: DmsTransferSettings? = nil, docDbSettings: DocDbSettings? = nil, dynamoDbSettings: DynamoDbSettings? = nil, elasticsearchSettings: ElasticsearchSettings? = nil, endpointArn: String? = nil, endpointIdentifier: String? = nil, endpointType: ReplicationEndpointTypeValue? = nil, engineDisplayName: String? = nil, engineName: String? = nil, externalId: String? = nil, externalTableDefinition: String? = nil, extraConnectionAttributes: String? = nil, gcpMySQLSettings: GcpMySQLSettings? = nil, ibmDb2Settings: IBMDb2Settings? = nil, kafkaSettings: KafkaSettings? = nil, kinesisSettings: KinesisSettings? = nil, kmsKeyId: String? = nil, microsoftSQLServerSettings: MicrosoftSQLServerSettings? = nil, mongoDbSettings: MongoDbSettings? = nil, mySQLSettings: MySQLSettings? = nil, neptuneSettings: NeptuneSettings? = nil, oracleSettings: OracleSettings? = nil, port: Int? = nil, postgreSQLSettings: PostgreSQLSettings? = nil, redisSettings: RedisSettings? = nil, redshiftSettings: RedshiftSettings? = nil, s3Settings: S3Settings? = nil, serverName: String? = nil, serviceAccessRoleArn: String? = nil, sslMode: DmsSslModeValue? = nil, status: String? = nil, sybaseSettings: SybaseSettings? = nil, timestreamSettings: TimestreamSettings? = nil, username: String? = nil) {
            self.certificateArn = certificateArn
            self.databaseName = databaseName
            self.dmsTransferSettings = dmsTransferSettings
            self.docDbSettings = docDbSettings
            self.dynamoDbSettings = dynamoDbSettings
            self.elasticsearchSettings = elasticsearchSettings
            self.endpointArn = endpointArn
            self.endpointIdentifier = endpointIdentifier
            self.endpointType = endpointType
            self.engineDisplayName = engineDisplayName
            self.engineName = engineName
            self.externalId = externalId
            self.externalTableDefinition = externalTableDefinition
            self.extraConnectionAttributes = extraConnectionAttributes
            self.gcpMySQLSettings = gcpMySQLSettings
            self.ibmDb2Settings = ibmDb2Settings
            self.kafkaSettings = kafkaSettings
            self.kinesisSettings = kinesisSettings
            self.kmsKeyId = kmsKeyId
            self.microsoftSQLServerSettings = microsoftSQLServerSettings
            self.mongoDbSettings = mongoDbSettings
            self.mySQLSettings = mySQLSettings
            self.neptuneSettings = neptuneSettings
            self.oracleSettings = oracleSettings
            self.port = port
            self.postgreSQLSettings = postgreSQLSettings
            self.redisSettings = redisSettings
            self.redshiftSettings = redshiftSettings
            self.s3Settings = s3Settings
            self.serverName = serverName
            self.serviceAccessRoleArn = serviceAccessRoleArn
            self.sslMode = sslMode
            self.status = status
            self.sybaseSettings = sybaseSettings
            self.timestreamSettings = timestreamSettings
            self.username = username
        }

        private enum CodingKeys: String, CodingKey {
            case certificateArn = "CertificateArn"
            case databaseName = "DatabaseName"
            case dmsTransferSettings = "DmsTransferSettings"
            case docDbSettings = "DocDbSettings"
            case dynamoDbSettings = "DynamoDbSettings"
            case elasticsearchSettings = "ElasticsearchSettings"
            case endpointArn = "EndpointArn"
            case endpointIdentifier = "EndpointIdentifier"
            case endpointType = "EndpointType"
            case engineDisplayName = "EngineDisplayName"
            case engineName = "EngineName"
            case externalId = "ExternalId"
            case externalTableDefinition = "ExternalTableDefinition"
            case extraConnectionAttributes = "ExtraConnectionAttributes"
            case gcpMySQLSettings = "GcpMySQLSettings"
            case ibmDb2Settings = "IBMDb2Settings"
            case kafkaSettings = "KafkaSettings"
            case kinesisSettings = "KinesisSettings"
            case kmsKeyId = "KmsKeyId"
            case microsoftSQLServerSettings = "MicrosoftSQLServerSettings"
            case mongoDbSettings = "MongoDbSettings"
            case mySQLSettings = "MySQLSettings"
            case neptuneSettings = "NeptuneSettings"
            case oracleSettings = "OracleSettings"
            case port = "Port"
            case postgreSQLSettings = "PostgreSQLSettings"
            case redisSettings = "RedisSettings"
            case redshiftSettings = "RedshiftSettings"
            case s3Settings = "S3Settings"
            case serverName = "ServerName"
            case serviceAccessRoleArn = "ServiceAccessRoleArn"
            case sslMode = "SslMode"
            case status = "Status"
            case sybaseSettings = "SybaseSettings"
            case timestreamSettings = "TimestreamSettings"
            case username = "Username"
        }
    }

    public struct EndpointSetting: AWSDecodableShape {
        /// The relevance or validity of an endpoint setting for an engine name and its endpoint type.
        public let applicability: String?
        /// The default value of the endpoint setting if no value is specified using CreateEndpoint or ModifyEndpoint.
        public let defaultValue: String?
        /// Enumerated values to use for this endpoint.
        public let enumValues: [String]?
        /// The maximum value of an endpoint setting that is of type int.
        public let intValueMax: Int?
        /// The minimum value of an endpoint setting that is of type int.
        public let intValueMin: Int?
        /// The name that you want to give the endpoint settings.
        public let name: String?
        /// A value that marks this endpoint setting as sensitive.
        public let sensitive: Bool?
        /// The type of endpoint. Valid values are source and target.
        public let type: EndpointSettingTypeValue?
        /// The unit of measure for this endpoint setting.
        public let units: String?

        @inlinable
        public init(applicability: String? = nil, defaultValue: String? = nil, enumValues: [String]? = nil, intValueMax: Int? = nil, intValueMin: Int? = nil, name: String? = nil, sensitive: Bool? = nil, type: EndpointSettingTypeValue? = nil, units: String? = nil) {
            self.applicability = applicability
            self.defaultValue = defaultValue
            self.enumValues = enumValues
            self.intValueMax = intValueMax
            self.intValueMin = intValueMin
            self.name = name
            self.sensitive = sensitive
            self.type = type
            self.units = units
        }

        private enum CodingKeys: String, CodingKey {
            case applicability = "Applicability"
            case defaultValue = "DefaultValue"
            case enumValues = "EnumValues"
            case intValueMax = "IntValueMax"
            case intValueMin = "IntValueMin"
            case name = "Name"
            case sensitive = "Sensitive"
            case type = "Type"
            case units = "Units"
        }
    }

    public struct EngineVersion: AWSDecodableShape {
        /// The date when the replication instance will be automatically upgraded. This setting only applies if the auto-minor-version setting is enabled.
        public let autoUpgradeDate: Date?
        /// The list of valid replication instance versions that you can upgrade to.
        public let availableUpgrades: [String]?
        /// The date when the replication instance version will be deprecated and can no longer be requested.
        public let deprecationDate: Date?
        /// The date when the replication instance will have a version upgrade forced.
        public let forceUpgradeDate: Date?
        /// The date when the replication instance version became publicly available.
        public let launchDate: Date?
        /// The lifecycle status of the replication instance version. Valid values are DEPRECATED, DEFAULT_VERSION, and ACTIVE.
        public let lifecycle: String?
        /// The release status of the replication instance version.
        public let releaseStatus: ReleaseStatusValues?
        /// The version number of the replication instance.
        public let version: String?

        @inlinable
        public init(autoUpgradeDate: Date? = nil, availableUpgrades: [String]? = nil, deprecationDate: Date? = nil, forceUpgradeDate: Date? = nil, launchDate: Date? = nil, lifecycle: String? = nil, releaseStatus: ReleaseStatusValues? = nil, version: String? = nil) {
            self.autoUpgradeDate = autoUpgradeDate
            self.availableUpgrades = availableUpgrades
            self.deprecationDate = deprecationDate
            self.forceUpgradeDate = forceUpgradeDate
            self.launchDate = launchDate
            self.lifecycle = lifecycle
            self.releaseStatus = releaseStatus
            self.version = version
        }

        private enum CodingKeys: String, CodingKey {
            case autoUpgradeDate = "AutoUpgradeDate"
            case availableUpgrades = "AvailableUpgrades"
            case deprecationDate = "DeprecationDate"
            case forceUpgradeDate = "ForceUpgradeDate"
            case launchDate = "LaunchDate"
            case lifecycle = "Lifecycle"
            case releaseStatus = "ReleaseStatus"
            case version = "Version"
        }
    }

    public struct Event: AWSDecodableShape {
        /// The date of the event.
        public let date: Date?
        /// The event categories available for the specified source type.
        public let eventCategories: [String]?
        /// The event message.
        public let message: String?
        ///  The identifier of an event source.
        public let sourceIdentifier: String?
        ///  The type of DMS resource that generates events.  Valid values: replication-instance | endpoint | replication-task
        public let sourceType: SourceType?

        @inlinable
        public init(date: Date? = nil, eventCategories: [String]? = nil, message: String? = nil, sourceIdentifier: String? = nil, sourceType: SourceType? = nil) {
            self.date = date
            self.eventCategories = eventCategories
            self.message = message
            self.sourceIdentifier = sourceIdentifier
            self.sourceType = sourceType
        }

        private enum CodingKeys: String, CodingKey {
            case date = "Date"
            case eventCategories = "EventCategories"
            case message = "Message"
            case sourceIdentifier = "SourceIdentifier"
            case sourceType = "SourceType"
        }
    }

    public struct EventCategoryGroup: AWSDecodableShape {
        ///  A list of event categories from a source type that you've chosen.
        public let eventCategories: [String]?
        ///  The type of DMS resource that generates events.  Valid values: replication-instance | replication-server | security-group | replication-task
        public let sourceType: String?

        @inlinable
        public init(eventCategories: [String]? = nil, sourceType: String? = nil) {
            self.eventCategories = eventCategories
            self.sourceType = sourceType
        }

        private enum CodingKeys: String, CodingKey {
            case eventCategories = "EventCategories"
            case sourceType = "SourceType"
        }
    }

    public struct EventSubscription: AWSDecodableShape {
        /// The Amazon Web Services customer account associated with the DMS event notification subscription.
        public let customerAwsId: String?
        /// The DMS event notification subscription Id.
        public let custSubscriptionId: String?
        /// Boolean value that indicates if the event subscription is enabled.
        public let enabled: Bool?
        /// A lists of event categories.
        public let eventCategoriesList: [String]?
        /// The topic ARN of the DMS event notification subscription.
        public let snsTopicArn: String?
        /// A list of source Ids for the event subscription.
        public let sourceIdsList: [String]?
        ///  The type of DMS resource that generates events.  Valid values: replication-instance | replication-server | security-group | replication-task
        public let sourceType: String?
        /// The status of the DMS event notification subscription. Constraints: Can be one of the following: creating | modifying | deleting | active | no-permission | topic-not-exist The status "no-permission" indicates that DMS no longer has permission to post to the SNS topic. The status "topic-not-exist" indicates that the topic was deleted after the subscription was created.
        public let status: String?
        /// The time the DMS event notification subscription was created.
        public let subscriptionCreationTime: String?

        @inlinable
        public init(customerAwsId: String? = nil, custSubscriptionId: String? = nil, enabled: Bool? = nil, eventCategoriesList: [String]? = nil, snsTopicArn: String? = nil, sourceIdsList: [String]? = nil, sourceType: String? = nil, status: String? = nil, subscriptionCreationTime: String? = nil) {
            self.customerAwsId = customerAwsId
            self.custSubscriptionId = custSubscriptionId
            self.enabled = enabled
            self.eventCategoriesList = eventCategoriesList
            self.snsTopicArn = snsTopicArn
            self.sourceIdsList = sourceIdsList
            self.sourceType = sourceType
            self.status = status
            self.subscriptionCreationTime = subscriptionCreationTime
        }

        private enum CodingKeys: String, CodingKey {
            case customerAwsId = "CustomerAwsId"
            case custSubscriptionId = "CustSubscriptionId"
            case enabled = "Enabled"
            case eventCategoriesList = "EventCategoriesList"
            case snsTopicArn = "SnsTopicArn"
            case sourceIdsList = "SourceIdsList"
            case sourceType = "SourceType"
            case status = "Status"
            case subscriptionCreationTime = "SubscriptionCreationTime"
        }
    }

    public struct ExportMetadataModelAssessmentMessage: AWSEncodableShape {
        /// The file format of the assessment file.
        public let assessmentReportTypes: [AssessmentReportType]?
        /// The name of the assessment file to create in your Amazon S3 bucket.
        public let fileName: String?
        /// The migration project name or Amazon Resource Name (ARN).
        public let migrationProjectIdentifier: String
        /// A value that specifies the database objects to assess.
        public let selectionRules: String

        @inlinable
        public init(assessmentReportTypes: [AssessmentReportType]? = nil, fileName: String? = nil, migrationProjectIdentifier: String, selectionRules: String) {
            self.assessmentReportTypes = assessmentReportTypes
            self.fileName = fileName
            self.migrationProjectIdentifier = migrationProjectIdentifier
            self.selectionRules = selectionRules
        }

        public func validate(name: String) throws {
            try self.validate(self.assessmentReportTypes, name: "assessmentReportTypes", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case assessmentReportTypes = "AssessmentReportTypes"
            case fileName = "FileName"
            case migrationProjectIdentifier = "MigrationProjectIdentifier"
            case selectionRules = "SelectionRules"
        }
    }

    public struct ExportMetadataModelAssessmentResponse: AWSDecodableShape {
        /// The Amazon S3 details for an assessment exported in CSV format.
        public let csvReport: ExportMetadataModelAssessmentResultEntry?
        /// The Amazon S3 details for an assessment exported in PDF format.
        public let pdfReport: ExportMetadataModelAssessmentResultEntry?

        @inlinable
        public init(csvReport: ExportMetadataModelAssessmentResultEntry? = nil, pdfReport: ExportMetadataModelAssessmentResultEntry? = nil) {
            self.csvReport = csvReport
            self.pdfReport = pdfReport
        }

        private enum CodingKeys: String, CodingKey {
            case csvReport = "CsvReport"
            case pdfReport = "PdfReport"
        }
    }

    public struct ExportMetadataModelAssessmentResultEntry: AWSDecodableShape {
        /// The URL for the object containing the exported metadata model assessment.
        public let objectURL: String?
        /// The object key for the object containing the exported metadata model assessment.
        public let s3ObjectKey: String?

        @inlinable
        public init(objectURL: String? = nil, s3ObjectKey: String? = nil) {
            self.objectURL = objectURL
            self.s3ObjectKey = s3ObjectKey
        }

        private enum CodingKeys: String, CodingKey {
            case objectURL = "ObjectURL"
            case s3ObjectKey = "S3ObjectKey"
        }
    }

    public struct ExportSqlDetails: AWSDecodableShape {
        /// The URL for the object containing the exported metadata model assessment.
        public let objectURL: String?
        /// The Amazon S3 object key for the object containing the exported metadata model assessment.
        public let s3ObjectKey: String?

        @inlinable
        public init(objectURL: String? = nil, s3ObjectKey: String? = nil) {
            self.objectURL = objectURL
            self.s3ObjectKey = s3ObjectKey
        }

        private enum CodingKeys: String, CodingKey {
            case objectURL = "ObjectURL"
            case s3ObjectKey = "S3ObjectKey"
        }
    }

    public struct Filter: AWSEncodableShape {
        /// The name of the filter as specified for a Describe* or similar operation.
        public let name: String
        /// The filter value, which can specify one or more values used to narrow the returned results.
        public let values: [String]

        @inlinable
        public init(name: String, values: [String]) {
            self.name = name
            self.values = values
        }

        private enum CodingKeys: String, CodingKey {
            case name = "Name"
            case values = "Values"
        }
    }

    public struct FleetAdvisorLsaAnalysisResponse: AWSDecodableShape {
        /// The ID of an LSA analysis run by a Fleet Advisor collector.
        public let lsaAnalysisId: String?
        /// The status of an LSA analysis run by a Fleet Advisor collector.
        public let status: String?

        @inlinable
        public init(lsaAnalysisId: String? = nil, status: String? = nil) {
            self.lsaAnalysisId = lsaAnalysisId
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case lsaAnalysisId = "LsaAnalysisId"
            case status = "Status"
        }
    }

    public struct FleetAdvisorSchemaObjectResponse: AWSDecodableShape {
        /// The number of lines of code in a schema object in a Fleet Advisor collector inventory.
        public let codeLineCount: Int64?
        /// The size level of the code in a schema object in a Fleet Advisor collector inventory.
        public let codeSize: Int64?
        /// The number of objects in a schema object in a Fleet Advisor collector inventory.
        public let numberOfObjects: Int64?
        /// The type of the schema object, as reported by the database engine. Examples include the following:    function     trigger     SYSTEM_TABLE     QUEUE
        public let objectType: String?
        /// The ID of a schema object in a Fleet Advisor collector inventory.
        public let schemaId: String?

        @inlinable
        public init(codeLineCount: Int64? = nil, codeSize: Int64? = nil, numberOfObjects: Int64? = nil, objectType: String? = nil, schemaId: String? = nil) {
            self.codeLineCount = codeLineCount
            self.codeSize = codeSize
            self.numberOfObjects = numberOfObjects
            self.objectType = objectType
            self.schemaId = schemaId
        }

        private enum CodingKeys: String, CodingKey {
            case codeLineCount = "CodeLineCount"
            case codeSize = "CodeSize"
            case numberOfObjects = "NumberOfObjects"
            case objectType = "ObjectType"
            case schemaId = "SchemaId"
        }
    }

    public struct GcpMySQLSettings: AWSEncodableShape & AWSDecodableShape {
        /// Specifies a script to run immediately after DMS connects to the endpoint. The migration task continues running regardless if the SQL statement succeeds or fails. For this parameter, provide the code of the script itself, not the name of a file containing the script.
        public let afterConnectScript: String?
        /// Cleans and recreates table metadata information on the replication instance when a mismatch occurs. For example, in a situation where running an alter DDL on the table could result in different information about the table cached in the replication instance.
        public let cleanSourceMetadataOnMismatch: Bool?
        /// Database name for the endpoint. For a MySQL source or target endpoint, don't explicitly specify the database using the DatabaseName request parameter on either the CreateEndpoint or ModifyEndpoint API call. Specifying DatabaseName when you create or modify a MySQL endpoint replicates all the task tables to this single database. For MySQL endpoints, you specify the database only when you specify the schema in the table-mapping rules of the DMS task.
        public let databaseName: String?
        /// Specifies how often to check the binary log for new changes/events when the database is idle. The default is five seconds. Example: eventsPollInterval=5;  In the example, DMS checks for changes in the binary logs every five seconds.
        public let eventsPollInterval: Int?
        /// Specifies the maximum size (in KB) of any .csv file used to transfer data to a MySQL-compatible database. Example: maxFileSize=512
        public let maxFileSize: Int?
        /// Improves performance when loading data into the MySQL-compatible target database. Specifies how many threads to use to load the data into the MySQL-compatible target database. Setting a large number of threads can have an adverse effect on database performance, because a separate connection is required for each thread. The default is one. Example: parallelLoadThreads=1
        public let parallelLoadThreads: Int?
        /// Endpoint connection password.
        public let password: String?
        /// Endpoint TCP port.
        public let port: Int?
        /// The full Amazon Resource Name (ARN) of the IAM role that specifies DMS as the trusted entity and grants the required permissions to access the value in SecretsManagerSecret. The role must allow the iam:PassRole action. SecretsManagerSecret has the value of the Amazon Web Services Secrets Manager secret that allows access to the MySQL endpoint.  You can specify one of two sets of values for these permissions. You can specify the values for this setting and SecretsManagerSecretId. Or you can specify clear-text values for UserName, Password, ServerName, and Port. You can't specify both. For more information on creating this SecretsManagerSecret and the SecretsManagerAccessRoleArn and SecretsManagerSecretId required to access it, see Using secrets to access Database Migration Service resources in the Database Migration Service User Guide.
        public let secretsManagerAccessRoleArn: String?
        /// The full ARN, partial ARN, or friendly name of the SecretsManagerSecret that contains the MySQL endpoint connection details.
        public let secretsManagerSecretId: String?
        /// The MySQL host name.
        public let serverName: String?
        /// Specifies the time zone for the source MySQL database. Example: serverTimezone=US/Pacific;  Note: Do not enclose time zones in single quotes.
        public let serverTimezone: String?
        /// Specifies where to migrate source tables on the target, either to a single database or multiple databases. Example: targetDbType=MULTIPLE_DATABASES
        public let targetDbType: TargetDbType?
        /// Endpoint connection user name.
        public let username: String?

        @inlinable
        public init(afterConnectScript: String? = nil, cleanSourceMetadataOnMismatch: Bool? = nil, databaseName: String? = nil, eventsPollInterval: Int? = nil, maxFileSize: Int? = nil, parallelLoadThreads: Int? = nil, password: String? = nil, port: Int? = nil, secretsManagerAccessRoleArn: String? = nil, secretsManagerSecretId: String? = nil, serverName: String? = nil, serverTimezone: String? = nil, targetDbType: TargetDbType? = nil, username: String? = nil) {
            self.afterConnectScript = afterConnectScript
            self.cleanSourceMetadataOnMismatch = cleanSourceMetadataOnMismatch
            self.databaseName = databaseName
            self.eventsPollInterval = eventsPollInterval
            self.maxFileSize = maxFileSize
            self.parallelLoadThreads = parallelLoadThreads
            self.password = password
            self.port = port
            self.secretsManagerAccessRoleArn = secretsManagerAccessRoleArn
            self.secretsManagerSecretId = secretsManagerSecretId
            self.serverName = serverName
            self.serverTimezone = serverTimezone
            self.targetDbType = targetDbType
            self.username = username
        }

        private enum CodingKeys: String, CodingKey {
            case afterConnectScript = "AfterConnectScript"
            case cleanSourceMetadataOnMismatch = "CleanSourceMetadataOnMismatch"
            case databaseName = "DatabaseName"
            case eventsPollInterval = "EventsPollInterval"
            case maxFileSize = "MaxFileSize"
            case parallelLoadThreads = "ParallelLoadThreads"
            case password = "Password"
            case port = "Port"
            case secretsManagerAccessRoleArn = "SecretsManagerAccessRoleArn"
            case secretsManagerSecretId = "SecretsManagerSecretId"
            case serverName = "ServerName"
            case serverTimezone = "ServerTimezone"
            case targetDbType = "TargetDbType"
            case username = "Username"
        }
    }

    public struct IBMDb2Settings: AWSEncodableShape & AWSDecodableShape {
        /// For ongoing replication (CDC), use CurrentLSN to specify a log sequence number (LSN) where you want the replication to start.
        public let currentLsn: String?
        /// Database name for the endpoint.
        public let databaseName: String?
        /// If true, DMS saves any .csv files to the Db2 LUW target that were used to replicate data. DMS uses these files for analysis and troubleshooting. The default value is false.
        public let keepCsvFiles: Bool?
        /// The amount of time (in milliseconds) before DMS times out operations performed by DMS on the Db2 target. The default value is 1200 (20 minutes).
        public let loadTimeout: Int?
        /// Specifies the maximum size (in KB) of .csv files used to transfer data to Db2 LUW.
        public let maxFileSize: Int?
        /// Maximum number of bytes per read, as a NUMBER value. The default is 64 KB.
        public let maxKBytesPerRead: Int?
        /// Endpoint connection password.
        public let password: String?
        /// Endpoint TCP port. The default value is 50000.
        public let port: Int?
        /// The full Amazon Resource Name (ARN) of the IAM role that specifies DMS as the trusted entity and grants the required permissions to access the value in SecretsManagerSecret. The role must allow the iam:PassRole action. SecretsManagerSecret has the value of the Amazon Web Services Secrets Manager secret that allows access to the Db2 LUW endpoint.   You can specify one of two sets of values for these permissions. You can specify the values for this setting and SecretsManagerSecretId. Or you can specify clear-text values for UserName, Password, ServerName, and Port. You can't specify both. For more information on creating this SecretsManagerSecret and the SecretsManagerAccessRoleArn and SecretsManagerSecretId required to access it, see Using secrets to access Database Migration Service resources in the Database Migration Service User Guide.
        public let secretsManagerAccessRoleArn: String?
        /// The full ARN, partial ARN, or friendly name of the SecretsManagerSecret that contains the Db2 LUW endpoint connection details.
        public let secretsManagerSecretId: String?
        /// Fully qualified domain name of the endpoint.
        public let serverName: String?
        /// Enables ongoing replication (CDC) as a BOOLEAN value. The default is true.
        public let setDataCaptureChanges: Bool?
        /// Endpoint connection user name.
        public let username: String?
        /// The size (in KB) of the in-memory file write buffer used when generating .csv files on the local disk on the DMS replication instance. The default value is 1024 (1 MB).
        public let writeBufferSize: Int?

        @inlinable
        public init(currentLsn: String? = nil, databaseName: String? = nil, keepCsvFiles: Bool? = nil, loadTimeout: Int? = nil, maxFileSize: Int? = nil, maxKBytesPerRead: Int? = nil, password: String? = nil, port: Int? = nil, secretsManagerAccessRoleArn: String? = nil, secretsManagerSecretId: String? = nil, serverName: String? = nil, setDataCaptureChanges: Bool? = nil, username: String? = nil, writeBufferSize: Int? = nil) {
            self.currentLsn = currentLsn
            self.databaseName = databaseName
            self.keepCsvFiles = keepCsvFiles
            self.loadTimeout = loadTimeout
            self.maxFileSize = maxFileSize
            self.maxKBytesPerRead = maxKBytesPerRead
            self.password = password
            self.port = port
            self.secretsManagerAccessRoleArn = secretsManagerAccessRoleArn
            self.secretsManagerSecretId = secretsManagerSecretId
            self.serverName = serverName
            self.setDataCaptureChanges = setDataCaptureChanges
            self.username = username
            self.writeBufferSize = writeBufferSize
        }

        private enum CodingKeys: String, CodingKey {
            case currentLsn = "CurrentLsn"
            case databaseName = "DatabaseName"
            case keepCsvFiles = "KeepCsvFiles"
            case loadTimeout = "LoadTimeout"
            case maxFileSize = "MaxFileSize"
            case maxKBytesPerRead = "MaxKBytesPerRead"
            case password = "Password"
            case port = "Port"
            case secretsManagerAccessRoleArn = "SecretsManagerAccessRoleArn"
            case secretsManagerSecretId = "SecretsManagerSecretId"
            case serverName = "ServerName"
            case setDataCaptureChanges = "SetDataCaptureChanges"
            case username = "Username"
            case writeBufferSize = "WriteBufferSize"
        }
    }

    public struct IbmDb2LuwDataProviderSettings: AWSEncodableShape & AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the certificate used for SSL connection.
        public let certificateArn: String?
        /// The database name on the DB2 LUW data provider.
        public let databaseName: String?
        /// The port value for the DB2 LUW data provider.
        public let port: Int?
        /// The name of the DB2 LUW server.
        public let serverName: String?
        /// The SSL mode used to connect to the DB2 LUW data provider. The default value is none. Valid Values: none and verify-ca.
        public let sslMode: DmsSslModeValue?

        @inlinable
        public init(certificateArn: String? = nil, databaseName: String? = nil, port: Int? = nil, serverName: String? = nil, sslMode: DmsSslModeValue? = nil) {
            self.certificateArn = certificateArn
            self.databaseName = databaseName
            self.port = port
            self.serverName = serverName
            self.sslMode = sslMode
        }

        private enum CodingKeys: String, CodingKey {
            case certificateArn = "CertificateArn"
            case databaseName = "DatabaseName"
            case port = "Port"
            case serverName = "ServerName"
            case sslMode = "SslMode"
        }
    }

    public struct IbmDb2zOsDataProviderSettings: AWSEncodableShape & AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the certificate used for SSL connection.
        public let certificateArn: String?
        /// The database name on the DB2 for z/OS data provider.
        public let databaseName: String?
        /// The port value for the DB2 for z/OS data provider.
        public let port: Int?
        /// The name of the DB2 for z/OS server.
        public let serverName: String?
        /// The SSL mode used to connect to the DB2 for z/OS data provider. The default value is none. Valid Values: none and verify-ca.
        public let sslMode: DmsSslModeValue?

        @inlinable
        public init(certificateArn: String? = nil, databaseName: String? = nil, port: Int? = nil, serverName: String? = nil, sslMode: DmsSslModeValue? = nil) {
            self.certificateArn = certificateArn
            self.databaseName = databaseName
            self.port = port
            self.serverName = serverName
            self.sslMode = sslMode
        }

        private enum CodingKeys: String, CodingKey {
            case certificateArn = "CertificateArn"
            case databaseName = "DatabaseName"
            case port = "Port"
            case serverName = "ServerName"
            case sslMode = "SslMode"
        }
    }

    public struct ImportCertificateMessage: AWSEncodableShape {
        /// A customer-assigned name for the certificate. Identifiers must begin with a letter and must contain only ASCII letters, digits, and hyphens. They can't end with a hyphen or contain two consecutive hyphens.
        public let certificateIdentifier: String
        /// The contents of a .pem file, which contains an X.509 certificate.
        public let certificatePem: String?
        /// The location of an imported Oracle Wallet certificate for use with SSL. Provide the name of a .sso file using the fileb:// prefix. You can't provide the certificate inline. Example: filebase64("${path.root}/rds-ca-2019-root.sso")
        public let certificateWallet: AWSBase64Data?
        /// The tags associated with the certificate.
        public let tags: [Tag]?

        @inlinable
        public init(certificateIdentifier: String, certificatePem: String? = nil, certificateWallet: AWSBase64Data? = nil, tags: [Tag]? = nil) {
            self.certificateIdentifier = certificateIdentifier
            self.certificatePem = certificatePem
            self.certificateWallet = certificateWallet
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case certificateIdentifier = "CertificateIdentifier"
            case certificatePem = "CertificatePem"
            case certificateWallet = "CertificateWallet"
            case tags = "Tags"
        }
    }

    public struct ImportCertificateResponse: AWSDecodableShape {
        /// The certificate to be uploaded.
        public let certificate: Certificate?

        @inlinable
        public init(certificate: Certificate? = nil) {
            self.certificate = certificate
        }

        private enum CodingKeys: String, CodingKey {
            case certificate = "Certificate"
        }
    }

    public struct InstanceProfile: AWSDecodableShape {
        /// The Availability Zone where the instance profile runs.
        public let availabilityZone: String?
        /// A description of the instance profile. Descriptions can have up to 31 characters.  A description can contain only ASCII letters, digits, and hyphens ('-'). Also, it can't  end with a hyphen or contain two consecutive hyphens, and can only begin with a letter.
        public let description: String?
        /// The Amazon Resource Name (ARN) string that uniquely identifies the instance profile.
        public let instanceProfileArn: String?
        /// The time the instance profile was created.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var instanceProfileCreationTime: Date?
        /// The user-friendly name for the instance profile.
        public let instanceProfileName: String?
        /// The Amazon Resource Name (ARN) of the KMS key that is used to encrypt  the connection parameters for the instance profile. If you don't specify a value for the KmsKeyArn parameter, then DMS uses your default encryption key. KMS creates the default encryption key for your Amazon Web Services account. Your Amazon Web Services account  has a different default encryption key for each Amazon Web Services Region.
        public let kmsKeyArn: String?
        /// Specifies the network type for the instance profile. A value of IPV4  represents an instance profile with IPv4 network type and only supports IPv4 addressing.  A value of IPV6 represents an instance profile with IPv6 network type  and only supports IPv6 addressing. A value of DUAL represents an instance  profile with dual network type that supports IPv4 and IPv6 addressing.
        public let networkType: String?
        /// Specifies the accessibility options for the instance profile. A value of true represents an instance profile with a public IP address. A value of false represents an instance profile with a private IP address. The default value is true.
        public let publiclyAccessible: Bool?
        /// The identifier of the subnet group that is associated with the instance profile.
        public let subnetGroupIdentifier: String?
        /// The VPC security groups that are used with the instance profile.  The VPC security group must work with the VPC containing the instance profile.
        public let vpcSecurityGroups: [String]?

        @inlinable
        public init(availabilityZone: String? = nil, description: String? = nil, instanceProfileArn: String? = nil, instanceProfileCreationTime: Date? = nil, instanceProfileName: String? = nil, kmsKeyArn: String? = nil, networkType: String? = nil, publiclyAccessible: Bool? = nil, subnetGroupIdentifier: String? = nil, vpcSecurityGroups: [String]? = nil) {
            self.availabilityZone = availabilityZone
            self.description = description
            self.instanceProfileArn = instanceProfileArn
            self.instanceProfileCreationTime = instanceProfileCreationTime
            self.instanceProfileName = instanceProfileName
            self.kmsKeyArn = kmsKeyArn
            self.networkType = networkType
            self.publiclyAccessible = publiclyAccessible
            self.subnetGroupIdentifier = subnetGroupIdentifier
            self.vpcSecurityGroups = vpcSecurityGroups
        }

        private enum CodingKeys: String, CodingKey {
            case availabilityZone = "AvailabilityZone"
            case description = "Description"
            case instanceProfileArn = "InstanceProfileArn"
            case instanceProfileCreationTime = "InstanceProfileCreationTime"
            case instanceProfileName = "InstanceProfileName"
            case kmsKeyArn = "KmsKeyArn"
            case networkType = "NetworkType"
            case publiclyAccessible = "PubliclyAccessible"
            case subnetGroupIdentifier = "SubnetGroupIdentifier"
            case vpcSecurityGroups = "VpcSecurityGroups"
        }
    }

    public struct InventoryData: AWSDecodableShape {
        /// The number of databases in the Fleet Advisor collector inventory.
        public let numberOfDatabases: Int?
        /// The number of schemas in the Fleet Advisor collector inventory.
        public let numberOfSchemas: Int?

        @inlinable
        public init(numberOfDatabases: Int? = nil, numberOfSchemas: Int? = nil) {
            self.numberOfDatabases = numberOfDatabases
            self.numberOfSchemas = numberOfSchemas
        }

        private enum CodingKeys: String, CodingKey {
            case numberOfDatabases = "NumberOfDatabases"
            case numberOfSchemas = "NumberOfSchemas"
        }
    }

    public struct KafkaSettings: AWSEncodableShape & AWSDecodableShape {
        /// A comma-separated list of one or more broker locations in your Kafka cluster that host your Kafka instance. Specify each broker location in the form  broker-hostname-or-ip:port . For example, "ec2-12-345-678-901.compute-1.amazonaws.com:2345". For more information and examples of specifying a list of broker locations, see Using Apache Kafka as a target for Database Migration Service in the Database Migration Service User Guide.
        public let broker: String?
        /// Shows detailed control information for table definition, column definition, and table and column changes in the Kafka message output. The default is false.
        public let includeControlDetails: Bool?
        /// Include NULL and empty columns for records migrated to the endpoint. The default is false.
        public let includeNullAndEmpty: Bool?
        /// Shows the partition value within the Kafka message output unless the partition type is schema-table-type. The default is false.
        public let includePartitionValue: Bool?
        /// Includes any data definition language (DDL) operations that change the table in the control data, such as rename-table, drop-table, add-column, drop-column, and rename-column. The default is false.
        public let includeTableAlterOperations: Bool?
        /// Provides detailed transaction information from the source database. This information includes a commit timestamp, a log position, and values for transaction_id, previous transaction_id, and transaction_record_id (the record offset within a transaction). The default is false.
        public let includeTransactionDetails: Bool?
        /// The output format for the records created on the endpoint. The message format is JSON (default) or JSON_UNFORMATTED (a single line with no tab).
        public let messageFormat: MessageFormatValue?
        /// The maximum size in bytes for records created on the endpoint The default is 1,000,000.
        public let messageMaxBytes: Int?
        /// Set this optional parameter to true to avoid adding a '0x' prefix to raw data in hexadecimal format. For example, by default, DMS adds a '0x' prefix to the LOB column type in hexadecimal format moving from an Oracle source to a Kafka target. Use the NoHexPrefix endpoint setting to enable migration of RAW data type columns without adding the '0x' prefix.
        public let noHexPrefix: Bool?
        /// Prefixes schema and table names to partition values, when the partition type is primary-key-type. Doing this increases data distribution among Kafka partitions. For example, suppose that a SysBench schema has thousands of tables and each table has only limited range for a primary key. In this case, the same primary key is sent from thousands of tables to the same partition, which causes throttling. The default is false.
        public let partitionIncludeSchemaTable: Bool?
        /// For SASL/SSL authentication, DMS supports the SCRAM-SHA-512 mechanism by default. DMS versions 3.5.0 and later also support the PLAIN mechanism. To use the PLAIN mechanism, set this parameter to PLAIN.
        public let saslMechanism: KafkaSaslMechanism?
        /// The secure password you created when you first set up your MSK cluster to validate a client identity and make an encrypted connection between server and client using SASL-SSL authentication.
        public let saslPassword: String?
        ///  The secure user name you created when you first set up your MSK cluster to validate a client identity and make an encrypted connection between server and client using SASL-SSL authentication.
        public let saslUsername: String?
        /// Set secure connection to a Kafka target endpoint using Transport Layer Security (TLS). Options include ssl-encryption, ssl-authentication, and sasl-ssl. sasl-ssl requires SaslUsername and SaslPassword.
        public let securityProtocol: KafkaSecurityProtocol?
        ///  The Amazon Resource Name (ARN) for the private certificate authority (CA) cert that DMS uses to securely connect to your Kafka target endpoint.
        public let sslCaCertificateArn: String?
        /// The Amazon Resource Name (ARN) of the client certificate used to securely connect to a Kafka target endpoint.
        public let sslClientCertificateArn: String?
        /// The Amazon Resource Name (ARN) for the client private key used to securely connect to a Kafka target endpoint.
        public let sslClientKeyArn: String?
        ///  The password for the client private key used to securely connect to a Kafka target endpoint.
        public let sslClientKeyPassword: String?
        /// Sets hostname verification for the certificate. This setting is supported in DMS version 3.5.1 and later.
        public let sslEndpointIdentificationAlgorithm: KafkaSslEndpointIdentificationAlgorithm?
        /// The topic to which you migrate the data. If you don't specify a topic, DMS specifies "kafka-default-topic" as the migration topic.
        public let topic: String?
        /// Specifies using the large integer value with Kafka.
        public let useLargeIntegerValue: Bool?

        @inlinable
        public init(broker: String? = nil, includeControlDetails: Bool? = nil, includeNullAndEmpty: Bool? = nil, includePartitionValue: Bool? = nil, includeTableAlterOperations: Bool? = nil, includeTransactionDetails: Bool? = nil, messageFormat: MessageFormatValue? = nil, messageMaxBytes: Int? = nil, noHexPrefix: Bool? = nil, partitionIncludeSchemaTable: Bool? = nil, saslMechanism: KafkaSaslMechanism? = nil, saslPassword: String? = nil, saslUsername: String? = nil, securityProtocol: KafkaSecurityProtocol? = nil, sslCaCertificateArn: String? = nil, sslClientCertificateArn: String? = nil, sslClientKeyArn: String? = nil, sslClientKeyPassword: String? = nil, sslEndpointIdentificationAlgorithm: KafkaSslEndpointIdentificationAlgorithm? = nil, topic: String? = nil, useLargeIntegerValue: Bool? = nil) {
            self.broker = broker
            self.includeControlDetails = includeControlDetails
            self.includeNullAndEmpty = includeNullAndEmpty
            self.includePartitionValue = includePartitionValue
            self.includeTableAlterOperations = includeTableAlterOperations
            self.includeTransactionDetails = includeTransactionDetails
            self.messageFormat = messageFormat
            self.messageMaxBytes = messageMaxBytes
            self.noHexPrefix = noHexPrefix
            self.partitionIncludeSchemaTable = partitionIncludeSchemaTable
            self.saslMechanism = saslMechanism
            self.saslPassword = saslPassword
            self.saslUsername = saslUsername
            self.securityProtocol = securityProtocol
            self.sslCaCertificateArn = sslCaCertificateArn
            self.sslClientCertificateArn = sslClientCertificateArn
            self.sslClientKeyArn = sslClientKeyArn
            self.sslClientKeyPassword = sslClientKeyPassword
            self.sslEndpointIdentificationAlgorithm = sslEndpointIdentificationAlgorithm
            self.topic = topic
            self.useLargeIntegerValue = useLargeIntegerValue
        }

        private enum CodingKeys: String, CodingKey {
            case broker = "Broker"
            case includeControlDetails = "IncludeControlDetails"
            case includeNullAndEmpty = "IncludeNullAndEmpty"
            case includePartitionValue = "IncludePartitionValue"
            case includeTableAlterOperations = "IncludeTableAlterOperations"
            case includeTransactionDetails = "IncludeTransactionDetails"
            case messageFormat = "MessageFormat"
            case messageMaxBytes = "MessageMaxBytes"
            case noHexPrefix = "NoHexPrefix"
            case partitionIncludeSchemaTable = "PartitionIncludeSchemaTable"
            case saslMechanism = "SaslMechanism"
            case saslPassword = "SaslPassword"
            case saslUsername = "SaslUsername"
            case securityProtocol = "SecurityProtocol"
            case sslCaCertificateArn = "SslCaCertificateArn"
            case sslClientCertificateArn = "SslClientCertificateArn"
            case sslClientKeyArn = "SslClientKeyArn"
            case sslClientKeyPassword = "SslClientKeyPassword"
            case sslEndpointIdentificationAlgorithm = "SslEndpointIdentificationAlgorithm"
            case topic = "Topic"
            case useLargeIntegerValue = "UseLargeIntegerValue"
        }
    }

    public struct KerberosAuthenticationSettings: AWSEncodableShape & AWSDecodableShape {
        /// Specifies the Amazon Resource Name (ARN) of the IAM role that grants Amazon Web Services DMS access to the secret containing key cache file for the kerberos authentication.
        public let keyCacheSecretIamArn: String?
        /// Specifies the ID of the secret that stores the key cache file required for kerberos authentication.
        public let keyCacheSecretId: String?
        /// Specifies the contents of krb5 configuration file required for kerberos authentication.
        public let krb5FileContents: String?

        @inlinable
        public init(keyCacheSecretIamArn: String? = nil, keyCacheSecretId: String? = nil, krb5FileContents: String? = nil) {
            self.keyCacheSecretIamArn = keyCacheSecretIamArn
            self.keyCacheSecretId = keyCacheSecretId
            self.krb5FileContents = krb5FileContents
        }

        private enum CodingKeys: String, CodingKey {
            case keyCacheSecretIamArn = "KeyCacheSecretIamArn"
            case keyCacheSecretId = "KeyCacheSecretId"
            case krb5FileContents = "Krb5FileContents"
        }
    }

    public struct KinesisSettings: AWSEncodableShape & AWSDecodableShape {
        /// Shows detailed control information for table definition, column definition, and table and column changes in the Kinesis message output. The default is false.
        public let includeControlDetails: Bool?
        /// Include NULL and empty columns for records migrated to the endpoint. The default is false.
        public let includeNullAndEmpty: Bool?
        /// Shows the partition value within the Kinesis message output, unless the partition type is schema-table-type. The default is false.
        public let includePartitionValue: Bool?
        /// Includes any data definition language (DDL) operations that change the table in the control data, such as rename-table, drop-table, add-column, drop-column, and rename-column. The default is false.
        public let includeTableAlterOperations: Bool?
        /// Provides detailed transaction information from the source database. This information includes a commit timestamp, a log position, and values for transaction_id, previous transaction_id, and transaction_record_id (the record offset within a transaction). The default is false.
        public let includeTransactionDetails: Bool?
        /// The output format for the records created on the endpoint. The message format is JSON (default) or JSON_UNFORMATTED (a single line with no tab).
        public let messageFormat: MessageFormatValue?
        /// Set this optional parameter to true to avoid adding a '0x' prefix to raw data in hexadecimal format. For example, by default, DMS adds a '0x' prefix to the LOB column type in hexadecimal format moving from an Oracle source to an Amazon Kinesis target. Use the NoHexPrefix endpoint setting to enable migration of RAW data type columns without adding the '0x' prefix.
        public let noHexPrefix: Bool?
        /// Prefixes schema and table names to partition values, when the partition type is primary-key-type. Doing this increases data distribution among Kinesis shards. For example, suppose that a SysBench schema has thousands of tables and each table has only limited range for a primary key. In this case, the same primary key is sent from thousands of tables to the same shard, which causes throttling. The default is false.
        public let partitionIncludeSchemaTable: Bool?
        /// The Amazon Resource Name (ARN) for the IAM role that DMS uses to write to the Kinesis data stream. The role must allow the iam:PassRole action.
        public let serviceAccessRoleArn: String?
        /// The Amazon Resource Name (ARN) for the Amazon Kinesis Data Streams endpoint.
        public let streamArn: String?
        /// Specifies using the large integer value with Kinesis.
        public let useLargeIntegerValue: Bool?

        @inlinable
        public init(includeControlDetails: Bool? = nil, includeNullAndEmpty: Bool? = nil, includePartitionValue: Bool? = nil, includeTableAlterOperations: Bool? = nil, includeTransactionDetails: Bool? = nil, messageFormat: MessageFormatValue? = nil, noHexPrefix: Bool? = nil, partitionIncludeSchemaTable: Bool? = nil, serviceAccessRoleArn: String? = nil, streamArn: String? = nil, useLargeIntegerValue: Bool? = nil) {
            self.includeControlDetails = includeControlDetails
            self.includeNullAndEmpty = includeNullAndEmpty
            self.includePartitionValue = includePartitionValue
            self.includeTableAlterOperations = includeTableAlterOperations
            self.includeTransactionDetails = includeTransactionDetails
            self.messageFormat = messageFormat
            self.noHexPrefix = noHexPrefix
            self.partitionIncludeSchemaTable = partitionIncludeSchemaTable
            self.serviceAccessRoleArn = serviceAccessRoleArn
            self.streamArn = streamArn
            self.useLargeIntegerValue = useLargeIntegerValue
        }

        private enum CodingKeys: String, CodingKey {
            case includeControlDetails = "IncludeControlDetails"
            case includeNullAndEmpty = "IncludeNullAndEmpty"
            case includePartitionValue = "IncludePartitionValue"
            case includeTableAlterOperations = "IncludeTableAlterOperations"
            case includeTransactionDetails = "IncludeTransactionDetails"
            case messageFormat = "MessageFormat"
            case noHexPrefix = "NoHexPrefix"
            case partitionIncludeSchemaTable = "PartitionIncludeSchemaTable"
            case serviceAccessRoleArn = "ServiceAccessRoleArn"
            case streamArn = "StreamArn"
            case useLargeIntegerValue = "UseLargeIntegerValue"
        }
    }

    public struct Limitation: AWSDecodableShape {
        /// The identifier of the source database.
        public let databaseId: String?
        /// A description of the limitation. Provides additional information about the limitation, and includes recommended actions that you can take to address or avoid this limitation.
        public let description: String?
        /// The name of the target engine that Fleet Advisor should use in the target engine recommendation. Valid values include "rds-aurora-mysql", "rds-aurora-postgresql", "rds-mysql", "rds-oracle", "rds-sql-server", and "rds-postgresql".
        public let engineName: String?
        /// The impact of the limitation. You can use this parameter to prioritize limitations that you want to address. Valid values include "Blocker", "High", "Medium", and "Low".
        public let impact: String?
        /// The name of the limitation. Describes unsupported database features, migration action items, and other limitations.
        public let name: String?
        /// The type of the limitation, such as action required, upgrade required, and limited feature.
        public let type: String?

        @inlinable
        public init(databaseId: String? = nil, description: String? = nil, engineName: String? = nil, impact: String? = nil, name: String? = nil, type: String? = nil) {
            self.databaseId = databaseId
            self.description = description
            self.engineName = engineName
            self.impact = impact
            self.name = name
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case databaseId = "DatabaseId"
            case description = "Description"
            case engineName = "EngineName"
            case impact = "Impact"
            case name = "Name"
            case type = "Type"
        }
    }

    public struct ListTagsForResourceMessage: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) string that uniquely identifies the DMS resource to list tags for. This returns a list of keys (names of tags) created for the resource and their associated tag values.
        public let resourceArn: String?
        /// List of ARNs that identify multiple DMS resources that you want to list tags for. This returns a list of keys (tag names) and their associated tag values. It also returns each tag's associated ResourceArn value, which is the ARN of the resource for which each listed tag is created.
        public let resourceArnList: [String]?

        @inlinable
        public init(resourceArn: String? = nil, resourceArnList: [String]? = nil) {
            self.resourceArn = resourceArn
            self.resourceArnList = resourceArnList
        }

        private enum CodingKeys: String, CodingKey {
            case resourceArn = "ResourceArn"
            case resourceArnList = "ResourceArnList"
        }
    }

    public struct ListTagsForResourceResponse: AWSDecodableShape {
        /// A list of tags for the resource.
        public let tagList: [Tag]?

        @inlinable
        public init(tagList: [Tag]? = nil) {
            self.tagList = tagList
        }

        private enum CodingKeys: String, CodingKey {
            case tagList = "TagList"
        }
    }

    public struct MariaDbDataProviderSettings: AWSEncodableShape & AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the certificate used for SSL connection.
        public let certificateArn: String?
        /// The port value for the MariaDB data provider
        public let port: Int?
        /// The name of the MariaDB server.
        public let serverName: String?
        /// The SSL mode used to connect to the MariaDB data provider.  The default value is none.
        public let sslMode: DmsSslModeValue?

        @inlinable
        public init(certificateArn: String? = nil, port: Int? = nil, serverName: String? = nil, sslMode: DmsSslModeValue? = nil) {
            self.certificateArn = certificateArn
            self.port = port
            self.serverName = serverName
            self.sslMode = sslMode
        }

        private enum CodingKeys: String, CodingKey {
            case certificateArn = "CertificateArn"
            case port = "Port"
            case serverName = "ServerName"
            case sslMode = "SslMode"
        }
    }

    public struct MicrosoftSQLServerSettings: AWSEncodableShape & AWSDecodableShape {
        /// Specifies the authentication method to be used with Microsoft SQL Server.
        public let authenticationMethod: SqlServerAuthenticationMethod?
        /// The maximum size of the packets (in bytes) used to transfer data using BCP.
        public let bcpPacketSize: Int?
        /// Specifies a file group for the DMS internal tables. When the replication task starts, all the internal DMS control tables (awsdms_ apply_exception, awsdms_apply, awsdms_changes) are created for the specified file group.
        public let controlTablesFileGroup: String?
        /// Database name for the endpoint.
        public let databaseName: String?
        /// Forces LOB lookup on inline LOB.
        public let forceLobLookup: Bool?
        /// Endpoint connection password.
        public let password: String?
        /// Endpoint TCP port.
        public let port: Int?
        /// Cleans and recreates table metadata information on the replication instance when a mismatch occurs. An example is a situation where running an alter DDL statement on a table might result in different information about the table cached in the replication instance.
        public let querySingleAlwaysOnNode: Bool?
        /// When this attribute is set to Y, DMS only reads changes from transaction log backups and doesn't read from the active transaction log file during ongoing replication. Setting this parameter to Y enables you to control active transaction log file growth during full load and ongoing replication tasks. However, it can add some source latency to ongoing replication.
        public let readBackupOnly: Bool?
        /// Use this attribute to minimize the need to access the backup log and enable DMS to prevent truncation using one of the following two methods.  Start transactions in the database: This is the default method. When this method is used, DMS prevents TLOG truncation by mimicking a transaction in the database. As long as such a transaction is open, changes that appear after the transaction started aren't truncated. If you need Microsoft Replication to be enabled in your database, then you must choose this method.  Exclusively use sp_repldone within a single task: When this method is used, DMS reads the changes and then uses sp_repldone to mark the TLOG transactions as ready for truncation. Although this method doesn't involve any transactional activities, it can only be used when Microsoft Replication isn't running. Also, when using this method, only one DMS task can access the database at any given time. Therefore, if you need to run parallel DMS tasks against the same database, use the default method.
        public let safeguardPolicy: SafeguardPolicy?
        /// The full Amazon Resource Name (ARN) of the IAM role that specifies DMS as the trusted entity and grants the required permissions to access the value in SecretsManagerSecret. The role must allow the iam:PassRole action. SecretsManagerSecret has the value of the Amazon Web Services Secrets Manager secret that allows access to the SQL Server endpoint.  You can specify one of two sets of values for these permissions. You can specify the values for this setting and SecretsManagerSecretId. Or you can specify clear-text values for UserName, Password, ServerName, and Port. You can't specify both. For more information on creating this SecretsManagerSecret and the SecretsManagerAccessRoleArn and SecretsManagerSecretId required to access it, see Using secrets to access Database Migration Service resources in the Database Migration Service User Guide.
        public let secretsManagerAccessRoleArn: String?
        /// The full ARN, partial ARN, or friendly name of the SecretsManagerSecret that contains the SQL Server endpoint connection details.
        public let secretsManagerSecretId: String?
        /// Fully qualified domain name of the endpoint. For an Amazon RDS SQL Server instance, this is the output of DescribeDBInstances, in the  Endpoint.Address field.
        public let serverName: String?
        /// Indicates the mode used to fetch CDC data.
        public let tlogAccessMode: TlogAccessMode?
        /// Use the TrimSpaceInChar source endpoint setting to right-trim data on CHAR and NCHAR data types during migration. Setting TrimSpaceInChar does not left-trim data. The default value is true.
        public let trimSpaceInChar: Bool?
        /// Use this to attribute to transfer data for full-load operations using BCP. When the target table contains an identity column that does not exist in the source table, you must disable the use BCP for loading table option.
        public let useBcpFullLoad: Bool?
        /// Endpoint connection user name.
        public let username: String?
        /// When this attribute is set to Y, DMS processes third-party transaction log backups if they are created in native format.
        public let useThirdPartyBackupDevice: Bool?

        @inlinable
        public init(authenticationMethod: SqlServerAuthenticationMethod? = nil, bcpPacketSize: Int? = nil, controlTablesFileGroup: String? = nil, databaseName: String? = nil, forceLobLookup: Bool? = nil, password: String? = nil, port: Int? = nil, querySingleAlwaysOnNode: Bool? = nil, readBackupOnly: Bool? = nil, safeguardPolicy: SafeguardPolicy? = nil, secretsManagerAccessRoleArn: String? = nil, secretsManagerSecretId: String? = nil, serverName: String? = nil, tlogAccessMode: TlogAccessMode? = nil, trimSpaceInChar: Bool? = nil, useBcpFullLoad: Bool? = nil, username: String? = nil, useThirdPartyBackupDevice: Bool? = nil) {
            self.authenticationMethod = authenticationMethod
            self.bcpPacketSize = bcpPacketSize
            self.controlTablesFileGroup = controlTablesFileGroup
            self.databaseName = databaseName
            self.forceLobLookup = forceLobLookup
            self.password = password
            self.port = port
            self.querySingleAlwaysOnNode = querySingleAlwaysOnNode
            self.readBackupOnly = readBackupOnly
            self.safeguardPolicy = safeguardPolicy
            self.secretsManagerAccessRoleArn = secretsManagerAccessRoleArn
            self.secretsManagerSecretId = secretsManagerSecretId
            self.serverName = serverName
            self.tlogAccessMode = tlogAccessMode
            self.trimSpaceInChar = trimSpaceInChar
            self.useBcpFullLoad = useBcpFullLoad
            self.username = username
            self.useThirdPartyBackupDevice = useThirdPartyBackupDevice
        }

        private enum CodingKeys: String, CodingKey {
            case authenticationMethod = "AuthenticationMethod"
            case bcpPacketSize = "BcpPacketSize"
            case controlTablesFileGroup = "ControlTablesFileGroup"
            case databaseName = "DatabaseName"
            case forceLobLookup = "ForceLobLookup"
            case password = "Password"
            case port = "Port"
            case querySingleAlwaysOnNode = "QuerySingleAlwaysOnNode"
            case readBackupOnly = "ReadBackupOnly"
            case safeguardPolicy = "SafeguardPolicy"
            case secretsManagerAccessRoleArn = "SecretsManagerAccessRoleArn"
            case secretsManagerSecretId = "SecretsManagerSecretId"
            case serverName = "ServerName"
            case tlogAccessMode = "TlogAccessMode"
            case trimSpaceInChar = "TrimSpaceInChar"
            case useBcpFullLoad = "UseBcpFullLoad"
            case username = "Username"
            case useThirdPartyBackupDevice = "UseThirdPartyBackupDevice"
        }
    }

    public struct MicrosoftSqlServerDataProviderSettings: AWSEncodableShape & AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the certificate used for SSL connection.
        public let certificateArn: String?
        /// The database name on the Microsoft SQL Server data provider.
        public let databaseName: String?
        /// The port value for the Microsoft SQL Server data provider.
        public let port: Int?
        /// The name of the Microsoft SQL Server server.
        public let serverName: String?
        /// The SSL mode used to connect to the Microsoft SQL Server data provider.  The default value is none.
        public let sslMode: DmsSslModeValue?

        @inlinable
        public init(certificateArn: String? = nil, databaseName: String? = nil, port: Int? = nil, serverName: String? = nil, sslMode: DmsSslModeValue? = nil) {
            self.certificateArn = certificateArn
            self.databaseName = databaseName
            self.port = port
            self.serverName = serverName
            self.sslMode = sslMode
        }

        private enum CodingKeys: String, CodingKey {
            case certificateArn = "CertificateArn"
            case databaseName = "DatabaseName"
            case port = "Port"
            case serverName = "ServerName"
            case sslMode = "SslMode"
        }
    }

    public struct MigrationProject: AWSDecodableShape {
        /// A user-friendly description of the migration project.
        public let description: String?
        /// The Amazon Resource Name (ARN) of the instance profile for your migration project.
        public let instanceProfileArn: String?
        /// The name of the associated instance profile.
        public let instanceProfileName: String?
        /// The ARN string that uniquely identifies the migration project.
        public let migrationProjectArn: String?
        /// The time when the migration project was created.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var migrationProjectCreationTime: Date?
        /// The name of the migration project.
        public let migrationProjectName: String?
        /// The schema conversion application attributes, including the Amazon S3 bucket name and Amazon S3 role ARN.
        public let schemaConversionApplicationAttributes: SCApplicationAttributes?
        /// Information about the source data provider, including the name or ARN, and Secrets Manager parameters.
        public let sourceDataProviderDescriptors: [DataProviderDescriptor]?
        /// Information about the target data provider, including the name or ARN, and Secrets Manager parameters.
        public let targetDataProviderDescriptors: [DataProviderDescriptor]?
        /// The settings in JSON format for migration rules. Migration rules make it possible for you to change  the object names according to the rules that you specify. For example, you can change an object name  to lowercase or uppercase, add or remove a prefix or suffix, or rename objects.
        public let transformationRules: String?

        @inlinable
        public init(description: String? = nil, instanceProfileArn: String? = nil, instanceProfileName: String? = nil, migrationProjectArn: String? = nil, migrationProjectCreationTime: Date? = nil, migrationProjectName: String? = nil, schemaConversionApplicationAttributes: SCApplicationAttributes? = nil, sourceDataProviderDescriptors: [DataProviderDescriptor]? = nil, targetDataProviderDescriptors: [DataProviderDescriptor]? = nil, transformationRules: String? = nil) {
            self.description = description
            self.instanceProfileArn = instanceProfileArn
            self.instanceProfileName = instanceProfileName
            self.migrationProjectArn = migrationProjectArn
            self.migrationProjectCreationTime = migrationProjectCreationTime
            self.migrationProjectName = migrationProjectName
            self.schemaConversionApplicationAttributes = schemaConversionApplicationAttributes
            self.sourceDataProviderDescriptors = sourceDataProviderDescriptors
            self.targetDataProviderDescriptors = targetDataProviderDescriptors
            self.transformationRules = transformationRules
        }

        private enum CodingKeys: String, CodingKey {
            case description = "Description"
            case instanceProfileArn = "InstanceProfileArn"
            case instanceProfileName = "InstanceProfileName"
            case migrationProjectArn = "MigrationProjectArn"
            case migrationProjectCreationTime = "MigrationProjectCreationTime"
            case migrationProjectName = "MigrationProjectName"
            case schemaConversionApplicationAttributes = "SchemaConversionApplicationAttributes"
            case sourceDataProviderDescriptors = "SourceDataProviderDescriptors"
            case targetDataProviderDescriptors = "TargetDataProviderDescriptors"
            case transformationRules = "TransformationRules"
        }
    }

    public struct ModifyConversionConfigurationMessage: AWSEncodableShape {
        /// The new conversion configuration.
        public let conversionConfiguration: String
        /// The migration project name or Amazon Resource Name (ARN).
        public let migrationProjectIdentifier: String

        @inlinable
        public init(conversionConfiguration: String, migrationProjectIdentifier: String) {
            self.conversionConfiguration = conversionConfiguration
            self.migrationProjectIdentifier = migrationProjectIdentifier
        }

        private enum CodingKeys: String, CodingKey {
            case conversionConfiguration = "ConversionConfiguration"
            case migrationProjectIdentifier = "MigrationProjectIdentifier"
        }
    }

    public struct ModifyConversionConfigurationResponse: AWSDecodableShape {
        /// The name or Amazon Resource Name (ARN) of  the modified configuration.
        public let migrationProjectIdentifier: String?

        @inlinable
        public init(migrationProjectIdentifier: String? = nil) {
            self.migrationProjectIdentifier = migrationProjectIdentifier
        }

        private enum CodingKeys: String, CodingKey {
            case migrationProjectIdentifier = "MigrationProjectIdentifier"
        }
    }

    public struct ModifyDataMigrationMessage: AWSEncodableShape {
        /// The identifier (name or ARN) of the data migration to modify.
        public let dataMigrationIdentifier: String
        /// The new name for the data migration.
        public let dataMigrationName: String?
        /// The new migration type for the data migration.
        public let dataMigrationType: MigrationTypeValue?
        /// Whether to enable Cloudwatch logs for the data migration.
        public let enableCloudwatchLogs: Bool?
        /// The number of parallel jobs that trigger parallel threads to unload the tables from the source, and then load them to the target.
        public let numberOfJobs: Int?
        /// A JSON-formatted string that defines what objects to include and exclude from the migration.
        public let selectionRules: String?
        /// The new service access role ARN for the data migration.
        public let serviceAccessRoleArn: String?
        /// The new information about the source data provider for the data migration.
        public let sourceDataSettings: [SourceDataSetting]?
        /// The new information about the target data provider for the data migration.
        public let targetDataSettings: [TargetDataSetting]?

        @inlinable
        public init(dataMigrationIdentifier: String, dataMigrationName: String? = nil, dataMigrationType: MigrationTypeValue? = nil, enableCloudwatchLogs: Bool? = nil, numberOfJobs: Int? = nil, selectionRules: String? = nil, serviceAccessRoleArn: String? = nil, sourceDataSettings: [SourceDataSetting]? = nil, targetDataSettings: [TargetDataSetting]? = nil) {
            self.dataMigrationIdentifier = dataMigrationIdentifier
            self.dataMigrationName = dataMigrationName
            self.dataMigrationType = dataMigrationType
            self.enableCloudwatchLogs = enableCloudwatchLogs
            self.numberOfJobs = numberOfJobs
            self.selectionRules = selectionRules
            self.serviceAccessRoleArn = serviceAccessRoleArn
            self.sourceDataSettings = sourceDataSettings
            self.targetDataSettings = targetDataSettings
        }

        private enum CodingKeys: String, CodingKey {
            case dataMigrationIdentifier = "DataMigrationIdentifier"
            case dataMigrationName = "DataMigrationName"
            case dataMigrationType = "DataMigrationType"
            case enableCloudwatchLogs = "EnableCloudwatchLogs"
            case numberOfJobs = "NumberOfJobs"
            case selectionRules = "SelectionRules"
            case serviceAccessRoleArn = "ServiceAccessRoleArn"
            case sourceDataSettings = "SourceDataSettings"
            case targetDataSettings = "TargetDataSettings"
        }
    }

    public struct ModifyDataMigrationResponse: AWSDecodableShape {
        /// Information about the modified data migration.
        public let dataMigration: DataMigration?

        @inlinable
        public init(dataMigration: DataMigration? = nil) {
            self.dataMigration = dataMigration
        }

        private enum CodingKeys: String, CodingKey {
            case dataMigration = "DataMigration"
        }
    }

    public struct ModifyDataProviderMessage: AWSEncodableShape {
        /// The identifier of the data provider. Identifiers must begin with a letter  and must contain only ASCII letters, digits, and hyphens. They can't end with  a hyphen, or contain two consecutive hyphens.
        public let dataProviderIdentifier: String
        /// The name of the data provider.
        public let dataProviderName: String?
        /// A user-friendly description of the data provider.
        public let description: String?
        /// The type of database engine for the data provider. Valid values include "aurora",  "aurora-postgresql", "mysql", "oracle", "postgres",  "sqlserver", redshift, mariadb, mongodb, db2, db2-zos and docdb. A value of "aurora" represents Amazon Aurora MySQL-Compatible Edition.
        public let engine: String?
        /// If this attribute is Y, the current call to ModifyDataProvider replaces all existing data provider settings with the exact settings that you specify in this call. If this attribute is N, the current call to ModifyDataProvider does two things:    It replaces any data provider settings that already exist with new values,  for settings with the same names.   It creates new data provider settings that you specify in the call,  for settings with different names.
        public let exactSettings: Bool?
        /// The settings in JSON format for a data provider.
        public let settings: DataProviderSettings?

        @inlinable
        public init(dataProviderIdentifier: String, dataProviderName: String? = nil, description: String? = nil, engine: String? = nil, exactSettings: Bool? = nil, settings: DataProviderSettings? = nil) {
            self.dataProviderIdentifier = dataProviderIdentifier
            self.dataProviderName = dataProviderName
            self.description = description
            self.engine = engine
            self.exactSettings = exactSettings
            self.settings = settings
        }

        private enum CodingKeys: String, CodingKey {
            case dataProviderIdentifier = "DataProviderIdentifier"
            case dataProviderName = "DataProviderName"
            case description = "Description"
            case engine = "Engine"
            case exactSettings = "ExactSettings"
            case settings = "Settings"
        }
    }

    public struct ModifyDataProviderResponse: AWSDecodableShape {
        /// The data provider that was modified.
        public let dataProvider: DataProvider?

        @inlinable
        public init(dataProvider: DataProvider? = nil) {
            self.dataProvider = dataProvider
        }

        private enum CodingKeys: String, CodingKey {
            case dataProvider = "DataProvider"
        }
    }

    public struct ModifyEndpointMessage: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the certificate used for SSL connection.
        public let certificateArn: String?
        /// The name of the endpoint database. For a MySQL source or target endpoint, do not specify DatabaseName.
        public let databaseName: String?
        /// The settings in JSON format for the DMS transfer type of source endpoint.  Attributes include the following:   serviceAccessRoleArn - The Amazon Resource Name (ARN) used by the service access IAM role. The role must allow the iam:PassRole action.   BucketName - The name of the S3 bucket to use.   Shorthand syntax for these settings is as follows: ServiceAccessRoleArn=string ,BucketName=string  JSON syntax for these settings is as follows: { "ServiceAccessRoleArn": "string", "BucketName": "string"}
        public let dmsTransferSettings: DmsTransferSettings?
        /// Settings in JSON format for the source DocumentDB endpoint. For more information about the available settings, see the configuration properties section in  Using DocumentDB as a Target for Database Migration Service  in the Database Migration Service User Guide.
        public let docDbSettings: DocDbSettings?
        /// Settings in JSON format for the target Amazon DynamoDB endpoint. For information about other available settings, see Using Object Mapping to Migrate Data to DynamoDB in the Database Migration Service User Guide.
        public let dynamoDbSettings: DynamoDbSettings?
        /// Settings in JSON format for the target OpenSearch endpoint. For more information about the available settings, see Extra Connection Attributes When Using OpenSearch as a Target for DMS in the Database Migration Service User Guide.
        public let elasticsearchSettings: ElasticsearchSettings?
        /// The Amazon Resource Name (ARN) string that uniquely identifies the endpoint.
        public let endpointArn: String
        /// The database endpoint identifier. Identifiers must begin with a letter and must contain only ASCII letters, digits, and hyphens. They can't end with a hyphen or contain two consecutive hyphens.
        public let endpointIdentifier: String?
        /// The type of endpoint. Valid values are source and target.
        public let endpointType: ReplicationEndpointTypeValue?
        /// The database engine name. Valid values, depending on the EndpointType, include "mysql", "oracle", "postgres", "mariadb", "aurora", "aurora-postgresql", "redshift", "s3", "db2", "db2-zos", "azuredb", "sybase", "dynamodb", "mongodb", "kinesis", "kafka", "elasticsearch", "documentdb", "sqlserver", "neptune", and "babelfish".
        public let engineName: String?
        /// If this attribute is Y, the current call to ModifyEndpoint replaces all existing endpoint settings with the exact settings that you specify in this call. If this attribute is N, the current call to ModifyEndpoint does two things:    It replaces any endpoint settings that already exist with new values, for settings with the same names.   It creates new endpoint settings that you specify in the call, for settings with different names.    For example, if you call create-endpoint ... --endpoint-settings '{"a":1}' ..., the endpoint has the following endpoint settings: '{"a":1}'. If you then call modify-endpoint ... --endpoint-settings '{"b":2}' ... for the same endpoint, the endpoint has the following settings: '{"a":1,"b":2}'.  However, suppose that you follow this with a call to modify-endpoint ... --endpoint-settings '{"b":2}' --exact-settings ... for that same endpoint again. Then the endpoint has the following settings: '{"b":2}'. All existing settings are replaced with the exact settings that you specify.
        public let exactSettings: Bool?
        /// The external table definition.
        public let externalTableDefinition: String?
        /// Additional attributes associated with the connection. To reset this parameter, pass the empty string ("") as an argument.
        public let extraConnectionAttributes: String?
        /// Settings in JSON format for the source GCP MySQL endpoint.
        public let gcpMySQLSettings: GcpMySQLSettings?
        /// Settings in JSON format for the source IBM Db2 LUW endpoint. For information about other available settings, see Extra connection attributes when using Db2 LUW as a source for DMS in the Database Migration Service User Guide.
        public let ibmDb2Settings: IBMDb2Settings?
        /// Settings in JSON format for the target Apache Kafka endpoint. For more information about the available settings, see Using object mapping to migrate data to a Kafka topic in the Database Migration Service User Guide.
        public let kafkaSettings: KafkaSettings?
        /// Settings in JSON format for the target endpoint for Amazon Kinesis Data Streams. For more information about the available settings, see Using object mapping to migrate data to a Kinesis data stream in the Database Migration Service User Guide.
        public let kinesisSettings: KinesisSettings?
        /// Settings in JSON format for the source and target Microsoft SQL Server endpoint. For information about other available settings, see Extra connection attributes when using SQL Server as a source for DMS and Extra connection attributes when using SQL Server as a target for DMS in the Database Migration Service User Guide.
        public let microsoftSQLServerSettings: MicrosoftSQLServerSettings?
        /// Settings in JSON format for the source MongoDB endpoint. For more information about the available settings, see the configuration properties section in Endpoint configuration settings when using MongoDB as a source for Database Migration Service in the Database Migration Service User Guide.
        public let mongoDbSettings: MongoDbSettings?
        /// Settings in JSON format for the source and target MySQL endpoint. For information about other available settings, see Extra connection attributes when using MySQL as a source for DMS and Extra connection attributes when using a MySQL-compatible database as a target for DMS in the Database Migration Service User Guide.
        public let mySQLSettings: MySQLSettings?
        /// Settings in JSON format for the target Amazon Neptune endpoint. For more information about the available settings, see Specifying graph-mapping rules using Gremlin and R2RML for Amazon Neptune as a target in the Database Migration Service User Guide.
        public let neptuneSettings: NeptuneSettings?
        /// Settings in JSON format for the source and target Oracle endpoint. For information about other available settings, see Extra connection attributes when using Oracle as a source for DMS and  Extra connection attributes when using Oracle as a target for DMS in the Database Migration Service User Guide.
        public let oracleSettings: OracleSettings?
        /// The password to be used to login to the endpoint database.
        public let password: String?
        /// The port used by the endpoint database.
        public let port: Int?
        /// Settings in JSON format for the source and target PostgreSQL endpoint. For information about other available settings, see Extra connection attributes when using PostgreSQL as a source for DMS and Extra connection attributes when using PostgreSQL as a target for DMS in the Database Migration Service User Guide.
        public let postgreSQLSettings: PostgreSQLSettings?
        /// Settings in JSON format for the Redis target endpoint.
        public let redisSettings: RedisSettings?
        public let redshiftSettings: RedshiftSettings?
        /// Settings in JSON format for the target Amazon S3 endpoint. For more information about the available settings, see Extra Connection Attributes When Using Amazon S3 as a Target for DMS in the Database Migration Service User Guide.
        public let s3Settings: S3Settings?
        /// The name of the server where the endpoint database resides.
        public let serverName: String?
        ///  The Amazon Resource Name (ARN) for the IAM role you want to use to modify the endpoint. The role must allow the iam:PassRole action.
        public let serviceAccessRoleArn: String?
        /// The SSL mode used to connect to the endpoint. The default value is none.
        public let sslMode: DmsSslModeValue?
        /// Settings in JSON format for the source and target SAP ASE endpoint. For information about other available settings, see Extra connection attributes when using SAP ASE as a source for DMS and Extra connection attributes when using SAP ASE as a target for DMS in the Database Migration Service User Guide.
        public let sybaseSettings: SybaseSettings?
        /// Settings in JSON format for the target Amazon Timestream endpoint.
        public let timestreamSettings: TimestreamSettings?
        /// The user name to be used to login to the endpoint database.
        public let username: String?

        @inlinable
        public init(certificateArn: String? = nil, databaseName: String? = nil, dmsTransferSettings: DmsTransferSettings? = nil, docDbSettings: DocDbSettings? = nil, dynamoDbSettings: DynamoDbSettings? = nil, elasticsearchSettings: ElasticsearchSettings? = nil, endpointArn: String, endpointIdentifier: String? = nil, endpointType: ReplicationEndpointTypeValue? = nil, engineName: String? = nil, exactSettings: Bool? = nil, externalTableDefinition: String? = nil, extraConnectionAttributes: String? = nil, gcpMySQLSettings: GcpMySQLSettings? = nil, ibmDb2Settings: IBMDb2Settings? = nil, kafkaSettings: KafkaSettings? = nil, kinesisSettings: KinesisSettings? = nil, microsoftSQLServerSettings: MicrosoftSQLServerSettings? = nil, mongoDbSettings: MongoDbSettings? = nil, mySQLSettings: MySQLSettings? = nil, neptuneSettings: NeptuneSettings? = nil, oracleSettings: OracleSettings? = nil, password: String? = nil, port: Int? = nil, postgreSQLSettings: PostgreSQLSettings? = nil, redisSettings: RedisSettings? = nil, redshiftSettings: RedshiftSettings? = nil, s3Settings: S3Settings? = nil, serverName: String? = nil, serviceAccessRoleArn: String? = nil, sslMode: DmsSslModeValue? = nil, sybaseSettings: SybaseSettings? = nil, timestreamSettings: TimestreamSettings? = nil, username: String? = nil) {
            self.certificateArn = certificateArn
            self.databaseName = databaseName
            self.dmsTransferSettings = dmsTransferSettings
            self.docDbSettings = docDbSettings
            self.dynamoDbSettings = dynamoDbSettings
            self.elasticsearchSettings = elasticsearchSettings
            self.endpointArn = endpointArn
            self.endpointIdentifier = endpointIdentifier
            self.endpointType = endpointType
            self.engineName = engineName
            self.exactSettings = exactSettings
            self.externalTableDefinition = externalTableDefinition
            self.extraConnectionAttributes = extraConnectionAttributes
            self.gcpMySQLSettings = gcpMySQLSettings
            self.ibmDb2Settings = ibmDb2Settings
            self.kafkaSettings = kafkaSettings
            self.kinesisSettings = kinesisSettings
            self.microsoftSQLServerSettings = microsoftSQLServerSettings
            self.mongoDbSettings = mongoDbSettings
            self.mySQLSettings = mySQLSettings
            self.neptuneSettings = neptuneSettings
            self.oracleSettings = oracleSettings
            self.password = password
            self.port = port
            self.postgreSQLSettings = postgreSQLSettings
            self.redisSettings = redisSettings
            self.redshiftSettings = redshiftSettings
            self.s3Settings = s3Settings
            self.serverName = serverName
            self.serviceAccessRoleArn = serviceAccessRoleArn
            self.sslMode = sslMode
            self.sybaseSettings = sybaseSettings
            self.timestreamSettings = timestreamSettings
            self.username = username
        }

        private enum CodingKeys: String, CodingKey {
            case certificateArn = "CertificateArn"
            case databaseName = "DatabaseName"
            case dmsTransferSettings = "DmsTransferSettings"
            case docDbSettings = "DocDbSettings"
            case dynamoDbSettings = "DynamoDbSettings"
            case elasticsearchSettings = "ElasticsearchSettings"
            case endpointArn = "EndpointArn"
            case endpointIdentifier = "EndpointIdentifier"
            case endpointType = "EndpointType"
            case engineName = "EngineName"
            case exactSettings = "ExactSettings"
            case externalTableDefinition = "ExternalTableDefinition"
            case extraConnectionAttributes = "ExtraConnectionAttributes"
            case gcpMySQLSettings = "GcpMySQLSettings"
            case ibmDb2Settings = "IBMDb2Settings"
            case kafkaSettings = "KafkaSettings"
            case kinesisSettings = "KinesisSettings"
            case microsoftSQLServerSettings = "MicrosoftSQLServerSettings"
            case mongoDbSettings = "MongoDbSettings"
            case mySQLSettings = "MySQLSettings"
            case neptuneSettings = "NeptuneSettings"
            case oracleSettings = "OracleSettings"
            case password = "Password"
            case port = "Port"
            case postgreSQLSettings = "PostgreSQLSettings"
            case redisSettings = "RedisSettings"
            case redshiftSettings = "RedshiftSettings"
            case s3Settings = "S3Settings"
            case serverName = "ServerName"
            case serviceAccessRoleArn = "ServiceAccessRoleArn"
            case sslMode = "SslMode"
            case sybaseSettings = "SybaseSettings"
            case timestreamSettings = "TimestreamSettings"
            case username = "Username"
        }
    }

    public struct ModifyEndpointResponse: AWSDecodableShape {
        /// The modified endpoint.
        public let endpoint: Endpoint?

        @inlinable
        public init(endpoint: Endpoint? = nil) {
            self.endpoint = endpoint
        }

        private enum CodingKeys: String, CodingKey {
            case endpoint = "Endpoint"
        }
    }

    public struct ModifyEventSubscriptionMessage: AWSEncodableShape {
        ///  A Boolean value; set to true to activate the subscription.
        public let enabled: Bool?
        ///  A list of event categories for a source type that you want to subscribe to. Use the DescribeEventCategories action to see a list of event categories.
        public let eventCategories: [String]?
        ///  The Amazon Resource Name (ARN) of the Amazon SNS topic created for event notification. The ARN is created by Amazon SNS when you create a topic and subscribe to it.
        public let snsTopicArn: String?
        ///  The type of DMS resource that generates the events you want to subscribe to.  Valid values: replication-instance | replication-task
        public let sourceType: String?
        /// The name of the DMS event notification subscription to be modified.
        public let subscriptionName: String

        @inlinable
        public init(enabled: Bool? = nil, eventCategories: [String]? = nil, snsTopicArn: String? = nil, sourceType: String? = nil, subscriptionName: String) {
            self.enabled = enabled
            self.eventCategories = eventCategories
            self.snsTopicArn = snsTopicArn
            self.sourceType = sourceType
            self.subscriptionName = subscriptionName
        }

        private enum CodingKeys: String, CodingKey {
            case enabled = "Enabled"
            case eventCategories = "EventCategories"
            case snsTopicArn = "SnsTopicArn"
            case sourceType = "SourceType"
            case subscriptionName = "SubscriptionName"
        }
    }

    public struct ModifyEventSubscriptionResponse: AWSDecodableShape {
        /// The modified event subscription.
        public let eventSubscription: EventSubscription?

        @inlinable
        public init(eventSubscription: EventSubscription? = nil) {
            self.eventSubscription = eventSubscription
        }

        private enum CodingKeys: String, CodingKey {
            case eventSubscription = "EventSubscription"
        }
    }

    public struct ModifyInstanceProfileMessage: AWSEncodableShape {
        /// The Availability Zone where the instance profile runs.
        public let availabilityZone: String?
        /// A user-friendly description for the instance profile.
        public let description: String?
        /// The identifier of the instance profile. Identifiers must begin with a letter and must contain  only ASCII letters, digits, and hyphens. They can't end with a hyphen, or contain two consecutive  hyphens.
        public let instanceProfileIdentifier: String
        /// A user-friendly name for the instance profile.
        public let instanceProfileName: String?
        /// The Amazon Resource Name (ARN) of the KMS key that is used to encrypt  the connection parameters for the instance profile. If you don't specify a value for the KmsKeyArn parameter, then DMS uses your default encryption key. KMS creates the default encryption key for your Amazon Web Services account. Your Amazon Web Services account has a different default encryption key for each Amazon Web Services Region.
        public let kmsKeyArn: String?
        /// Specifies the network type for the instance profile. A value of IPV4  represents an instance profile with IPv4 network type and only supports IPv4 addressing.  A value of IPV6 represents an instance profile with IPv6 network type  and only supports IPv6 addressing. A value of DUAL represents an instance  profile with dual network type that supports IPv4 and IPv6 addressing.
        public let networkType: String?
        /// Specifies the accessibility options for the instance profile. A value of true represents an instance profile with a public IP address. A value of false represents an instance profile with a private IP address. The default value is true.
        public let publiclyAccessible: Bool?
        /// A subnet group to associate with the instance profile.
        public let subnetGroupIdentifier: String?
        /// Specifies the VPC security groups to be used with the instance profile.  The VPC security group must work with the VPC containing the instance profile.
        public let vpcSecurityGroups: [String]?

        @inlinable
        public init(availabilityZone: String? = nil, description: String? = nil, instanceProfileIdentifier: String, instanceProfileName: String? = nil, kmsKeyArn: String? = nil, networkType: String? = nil, publiclyAccessible: Bool? = nil, subnetGroupIdentifier: String? = nil, vpcSecurityGroups: [String]? = nil) {
            self.availabilityZone = availabilityZone
            self.description = description
            self.instanceProfileIdentifier = instanceProfileIdentifier
            self.instanceProfileName = instanceProfileName
            self.kmsKeyArn = kmsKeyArn
            self.networkType = networkType
            self.publiclyAccessible = publiclyAccessible
            self.subnetGroupIdentifier = subnetGroupIdentifier
            self.vpcSecurityGroups = vpcSecurityGroups
        }

        private enum CodingKeys: String, CodingKey {
            case availabilityZone = "AvailabilityZone"
            case description = "Description"
            case instanceProfileIdentifier = "InstanceProfileIdentifier"
            case instanceProfileName = "InstanceProfileName"
            case kmsKeyArn = "KmsKeyArn"
            case networkType = "NetworkType"
            case publiclyAccessible = "PubliclyAccessible"
            case subnetGroupIdentifier = "SubnetGroupIdentifier"
            case vpcSecurityGroups = "VpcSecurityGroups"
        }
    }

    public struct ModifyInstanceProfileResponse: AWSDecodableShape {
        /// The instance profile that was modified.
        public let instanceProfile: InstanceProfile?

        @inlinable
        public init(instanceProfile: InstanceProfile? = nil) {
            self.instanceProfile = instanceProfile
        }

        private enum CodingKeys: String, CodingKey {
            case instanceProfile = "InstanceProfile"
        }
    }

    public struct ModifyMigrationProjectMessage: AWSEncodableShape {
        /// A user-friendly description of the migration project.
        public let description: String?
        /// The name or Amazon Resource Name (ARN) for the instance profile.
        public let instanceProfileIdentifier: String?
        /// The identifier of the migration project. Identifiers must begin with a letter  and must contain only ASCII letters, digits, and hyphens. They can't end with  a hyphen, or contain two consecutive hyphens.
        public let migrationProjectIdentifier: String
        /// A user-friendly name for the migration project.
        public let migrationProjectName: String?
        /// The schema conversion application attributes, including the Amazon S3 bucket name and Amazon S3 role ARN.
        public let schemaConversionApplicationAttributes: SCApplicationAttributes?
        /// Information about the source data provider, including the name, ARN, and Amazon Web Services Secrets Manager parameters.
        public let sourceDataProviderDescriptors: [DataProviderDescriptorDefinition]?
        /// Information about the target data provider, including the name, ARN, and Amazon Web Services Secrets Manager parameters.
        public let targetDataProviderDescriptors: [DataProviderDescriptorDefinition]?
        /// The settings in JSON format for migration rules. Migration rules make it possible for you to change  the object names according to the rules that you specify. For example, you can change an object name  to lowercase or uppercase, add or remove a prefix or suffix, or rename objects.
        public let transformationRules: String?

        @inlinable
        public init(description: String? = nil, instanceProfileIdentifier: String? = nil, migrationProjectIdentifier: String, migrationProjectName: String? = nil, schemaConversionApplicationAttributes: SCApplicationAttributes? = nil, sourceDataProviderDescriptors: [DataProviderDescriptorDefinition]? = nil, targetDataProviderDescriptors: [DataProviderDescriptorDefinition]? = nil, transformationRules: String? = nil) {
            self.description = description
            self.instanceProfileIdentifier = instanceProfileIdentifier
            self.migrationProjectIdentifier = migrationProjectIdentifier
            self.migrationProjectName = migrationProjectName
            self.schemaConversionApplicationAttributes = schemaConversionApplicationAttributes
            self.sourceDataProviderDescriptors = sourceDataProviderDescriptors
            self.targetDataProviderDescriptors = targetDataProviderDescriptors
            self.transformationRules = transformationRules
        }

        private enum CodingKeys: String, CodingKey {
            case description = "Description"
            case instanceProfileIdentifier = "InstanceProfileIdentifier"
            case migrationProjectIdentifier = "MigrationProjectIdentifier"
            case migrationProjectName = "MigrationProjectName"
            case schemaConversionApplicationAttributes = "SchemaConversionApplicationAttributes"
            case sourceDataProviderDescriptors = "SourceDataProviderDescriptors"
            case targetDataProviderDescriptors = "TargetDataProviderDescriptors"
            case transformationRules = "TransformationRules"
        }
    }

    public struct ModifyMigrationProjectResponse: AWSDecodableShape {
        /// The migration project that was modified.
        public let migrationProject: MigrationProject?

        @inlinable
        public init(migrationProject: MigrationProject? = nil) {
            self.migrationProject = migrationProject
        }

        private enum CodingKeys: String, CodingKey {
            case migrationProject = "MigrationProject"
        }
    }

    public struct ModifyReplicationConfigMessage: AWSEncodableShape {
        /// Configuration parameters for provisioning an DMS Serverless replication.
        public let computeConfig: ComputeConfig?
        /// The Amazon Resource Name of the replication to modify.
        public let replicationConfigArn: String
        /// The new replication config to apply to the replication.
        public let replicationConfigIdentifier: String?
        /// The settings for the replication.
        public let replicationSettings: String?
        /// The type of replication.
        public let replicationType: MigrationTypeValue?
        /// The Amazon Resource Name (ARN) of the source endpoint for this DMS serverless replication configuration.
        public let sourceEndpointArn: String?
        /// Additional settings for the replication.
        public let supplementalSettings: String?
        /// Table mappings specified in the replication.
        public let tableMappings: String?
        /// The Amazon Resource Name (ARN) of the target endpoint for this DMS serverless replication configuration.
        public let targetEndpointArn: String?

        @inlinable
        public init(computeConfig: ComputeConfig? = nil, replicationConfigArn: String, replicationConfigIdentifier: String? = nil, replicationSettings: String? = nil, replicationType: MigrationTypeValue? = nil, sourceEndpointArn: String? = nil, supplementalSettings: String? = nil, tableMappings: String? = nil, targetEndpointArn: String? = nil) {
            self.computeConfig = computeConfig
            self.replicationConfigArn = replicationConfigArn
            self.replicationConfigIdentifier = replicationConfigIdentifier
            self.replicationSettings = replicationSettings
            self.replicationType = replicationType
            self.sourceEndpointArn = sourceEndpointArn
            self.supplementalSettings = supplementalSettings
            self.tableMappings = tableMappings
            self.targetEndpointArn = targetEndpointArn
        }

        private enum CodingKeys: String, CodingKey {
            case computeConfig = "ComputeConfig"
            case replicationConfigArn = "ReplicationConfigArn"
            case replicationConfigIdentifier = "ReplicationConfigIdentifier"
            case replicationSettings = "ReplicationSettings"
            case replicationType = "ReplicationType"
            case sourceEndpointArn = "SourceEndpointArn"
            case supplementalSettings = "SupplementalSettings"
            case tableMappings = "TableMappings"
            case targetEndpointArn = "TargetEndpointArn"
        }
    }

    public struct ModifyReplicationConfigResponse: AWSDecodableShape {
        /// Information about the serverless replication config that was modified.
        public let replicationConfig: ReplicationConfig?

        @inlinable
        public init(replicationConfig: ReplicationConfig? = nil) {
            self.replicationConfig = replicationConfig
        }

        private enum CodingKeys: String, CodingKey {
            case replicationConfig = "ReplicationConfig"
        }
    }

    public struct ModifyReplicationInstanceMessage: AWSEncodableShape {
        /// The amount of storage (in gigabytes) to be allocated for the replication instance.
        public let allocatedStorage: Int?
        /// Indicates that major version upgrades are allowed. Changing this parameter does not result in an outage, and the change is asynchronously applied as soon as possible. This parameter must be set to true when specifying a value for the EngineVersion parameter that is a different major version than the replication instance's current version.
        public let allowMajorVersionUpgrade: Bool?
        /// Indicates whether the changes should be applied immediately or during the next maintenance window.
        public let applyImmediately: Bool?
        /// A value that indicates that minor version upgrades are applied automatically to the replication instance during the maintenance window. Changing this parameter doesn't result in an outage, except in the case described following. The change is asynchronously applied as soon as possible.  An outage does result if these factors apply:    This parameter is set to true during the maintenance window.   A newer minor version is available.    DMS has enabled automatic patching for the given engine version.
        public let autoMinorVersionUpgrade: Bool?
        /// The engine version number of the replication instance. When modifying a major engine version of an instance, also set AllowMajorVersionUpgrade to true.
        public let engineVersion: String?
        /// Specifies the settings required for kerberos authentication when modifying a replication instance.
        public let kerberosAuthenticationSettings: KerberosAuthenticationSettings?
        ///  Specifies whether the replication instance is a Multi-AZ deployment. You can't set the AvailabilityZone parameter if the Multi-AZ parameter is set to true.
        public let multiAZ: Bool?
        /// The type of IP address protocol used by a replication instance, such as IPv4 only or Dual-stack that supports both IPv4 and IPv6 addressing. IPv6 only is not yet supported.
        public let networkType: String?
        /// The weekly time range (in UTC) during which system maintenance can occur, which might result in an outage. Changing this parameter does not result in an outage, except in the following situation, and the change is asynchronously applied as soon as possible. If moving this window to the current time, there must be at least 30 minutes between the current time and end of the window to ensure pending changes are applied. Default: Uses existing setting Format: ddd:hh24:mi-ddd:hh24:mi Valid Days: Mon | Tue | Wed | Thu | Fri | Sat | Sun Constraints: Must be at least 30 minutes
        public let preferredMaintenanceWindow: String?
        /// The Amazon Resource Name (ARN) of the replication instance.
        public let replicationInstanceArn: String
        /// The compute and memory capacity of the replication instance as defined for the specified replication instance class. For example to specify the instance class dms.c4.large, set this parameter to "dms.c4.large". For more information on the settings and capacities for the available replication instance classes, see  Selecting the right DMS replication instance for your migration.
        public let replicationInstanceClass: String?
        /// The replication instance identifier. This parameter is stored as a lowercase string.
        public let replicationInstanceIdentifier: String?
        ///  Specifies the VPC security group to be used with the replication instance. The VPC security group must work with the VPC containing the replication instance.
        public let vpcSecurityGroupIds: [String]?

        @inlinable
        public init(allocatedStorage: Int? = nil, allowMajorVersionUpgrade: Bool? = nil, applyImmediately: Bool? = nil, autoMinorVersionUpgrade: Bool? = nil, engineVersion: String? = nil, kerberosAuthenticationSettings: KerberosAuthenticationSettings? = nil, multiAZ: Bool? = nil, networkType: String? = nil, preferredMaintenanceWindow: String? = nil, replicationInstanceArn: String, replicationInstanceClass: String? = nil, replicationInstanceIdentifier: String? = nil, vpcSecurityGroupIds: [String]? = nil) {
            self.allocatedStorage = allocatedStorage
            self.allowMajorVersionUpgrade = allowMajorVersionUpgrade
            self.applyImmediately = applyImmediately
            self.autoMinorVersionUpgrade = autoMinorVersionUpgrade
            self.engineVersion = engineVersion
            self.kerberosAuthenticationSettings = kerberosAuthenticationSettings
            self.multiAZ = multiAZ
            self.networkType = networkType
            self.preferredMaintenanceWindow = preferredMaintenanceWindow
            self.replicationInstanceArn = replicationInstanceArn
            self.replicationInstanceClass = replicationInstanceClass
            self.replicationInstanceIdentifier = replicationInstanceIdentifier
            self.vpcSecurityGroupIds = vpcSecurityGroupIds
        }

        public func validate(name: String) throws {
            try self.validate(self.replicationInstanceClass, name: "replicationInstanceClass", parent: name, max: 30)
        }

        private enum CodingKeys: String, CodingKey {
            case allocatedStorage = "AllocatedStorage"
            case allowMajorVersionUpgrade = "AllowMajorVersionUpgrade"
            case applyImmediately = "ApplyImmediately"
            case autoMinorVersionUpgrade = "AutoMinorVersionUpgrade"
            case engineVersion = "EngineVersion"
            case kerberosAuthenticationSettings = "KerberosAuthenticationSettings"
            case multiAZ = "MultiAZ"
            case networkType = "NetworkType"
            case preferredMaintenanceWindow = "PreferredMaintenanceWindow"
            case replicationInstanceArn = "ReplicationInstanceArn"
            case replicationInstanceClass = "ReplicationInstanceClass"
            case replicationInstanceIdentifier = "ReplicationInstanceIdentifier"
            case vpcSecurityGroupIds = "VpcSecurityGroupIds"
        }
    }

    public struct ModifyReplicationInstanceResponse: AWSDecodableShape {
        /// The modified replication instance.
        public let replicationInstance: ReplicationInstance?

        @inlinable
        public init(replicationInstance: ReplicationInstance? = nil) {
            self.replicationInstance = replicationInstance
        }

        private enum CodingKeys: String, CodingKey {
            case replicationInstance = "ReplicationInstance"
        }
    }

    public struct ModifyReplicationSubnetGroupMessage: AWSEncodableShape {
        /// A description for the replication instance subnet group.
        public let replicationSubnetGroupDescription: String?
        /// The name of the replication instance subnet group.
        public let replicationSubnetGroupIdentifier: String
        /// A list of subnet IDs.
        public let subnetIds: [String]

        @inlinable
        public init(replicationSubnetGroupDescription: String? = nil, replicationSubnetGroupIdentifier: String, subnetIds: [String]) {
            self.replicationSubnetGroupDescription = replicationSubnetGroupDescription
            self.replicationSubnetGroupIdentifier = replicationSubnetGroupIdentifier
            self.subnetIds = subnetIds
        }

        private enum CodingKeys: String, CodingKey {
            case replicationSubnetGroupDescription = "ReplicationSubnetGroupDescription"
            case replicationSubnetGroupIdentifier = "ReplicationSubnetGroupIdentifier"
            case subnetIds = "SubnetIds"
        }
    }

    public struct ModifyReplicationSubnetGroupResponse: AWSDecodableShape {
        /// The modified replication subnet group.
        public let replicationSubnetGroup: ReplicationSubnetGroup?

        @inlinable
        public init(replicationSubnetGroup: ReplicationSubnetGroup? = nil) {
            self.replicationSubnetGroup = replicationSubnetGroup
        }

        private enum CodingKeys: String, CodingKey {
            case replicationSubnetGroup = "ReplicationSubnetGroup"
        }
    }

    public struct ModifyReplicationTaskMessage: AWSEncodableShape {
        /// Indicates when you want a change data capture (CDC) operation to start. Use either CdcStartPosition or CdcStartTime to specify when you want a CDC operation to start. Specifying both values results in an error. The value can be in date, checkpoint, or LSN/SCN format. Date Example: --cdc-start-position 2018-03-08T12:12:12 Checkpoint Example: --cdc-start-position "checkpoint:V1#27#mysql-bin-changelog.157832:1975:-1:2002:677883278264080:mysql-bin-changelog.157832:1876#0#0#*#0#93" LSN Example: --cdc-start-position mysql-bin-changelog.000024:373  When you use this task setting with a source PostgreSQL database, a logical replication slot should already be created and associated with the source endpoint. You can verify this by setting the slotName extra connection attribute to the name of this logical replication slot. For more information, see Extra Connection Attributes When Using PostgreSQL as a Source for DMS.
        public let cdcStartPosition: String?
        /// Indicates the start time for a change data capture (CDC) operation. Use either CdcStartTime or CdcStartPosition to specify when you want a CDC operation to start. Specifying both values results in an error. Timestamp Example: --cdc-start-time 2018-03-08T12:12:12
        public let cdcStartTime: Date?
        /// Indicates when you want a change data capture (CDC) operation to stop. The value can be either server time or commit time. Server time example: --cdc-stop-position server_time:2018-02-09T12:12:12 Commit time example: --cdc-stop-position commit_time:2018-02-09T12:12:12
        public let cdcStopPosition: String?
        /// The migration type. Valid values: full-load | cdc | full-load-and-cdc
        public let migrationType: MigrationTypeValue?
        /// The Amazon Resource Name (ARN) of the replication task.
        public let replicationTaskArn: String
        /// The replication task identifier. Constraints:   Must contain 1-255 alphanumeric characters or hyphens.   First character must be a letter.   Cannot end with a hyphen or contain two consecutive hyphens.
        public let replicationTaskIdentifier: String?
        /// JSON file that contains settings for the task, such as task metadata settings.
        public let replicationTaskSettings: String?
        /// When using the CLI or boto3, provide the path of the JSON file that contains the table mappings. Precede the path with file://. For example, --table-mappings file://mappingfile.json. When working with the DMS API, provide the JSON as the parameter value.
        public let tableMappings: String?
        /// Supplemental information that the task requires to migrate the data for certain source and target endpoints. For more information, see Specifying Supplemental Data for Task Settings in the Database Migration Service User Guide.
        public let taskData: String?

        @inlinable
        public init(cdcStartPosition: String? = nil, cdcStartTime: Date? = nil, cdcStopPosition: String? = nil, migrationType: MigrationTypeValue? = nil, replicationTaskArn: String, replicationTaskIdentifier: String? = nil, replicationTaskSettings: String? = nil, tableMappings: String? = nil, taskData: String? = nil) {
            self.cdcStartPosition = cdcStartPosition
            self.cdcStartTime = cdcStartTime
            self.cdcStopPosition = cdcStopPosition
            self.migrationType = migrationType
            self.replicationTaskArn = replicationTaskArn
            self.replicationTaskIdentifier = replicationTaskIdentifier
            self.replicationTaskSettings = replicationTaskSettings
            self.tableMappings = tableMappings
            self.taskData = taskData
        }

        private enum CodingKeys: String, CodingKey {
            case cdcStartPosition = "CdcStartPosition"
            case cdcStartTime = "CdcStartTime"
            case cdcStopPosition = "CdcStopPosition"
            case migrationType = "MigrationType"
            case replicationTaskArn = "ReplicationTaskArn"
            case replicationTaskIdentifier = "ReplicationTaskIdentifier"
            case replicationTaskSettings = "ReplicationTaskSettings"
            case tableMappings = "TableMappings"
            case taskData = "TaskData"
        }
    }

    public struct ModifyReplicationTaskResponse: AWSDecodableShape {
        /// The replication task that was modified.
        public let replicationTask: ReplicationTask?

        @inlinable
        public init(replicationTask: ReplicationTask? = nil) {
            self.replicationTask = replicationTask
        }

        private enum CodingKeys: String, CodingKey {
            case replicationTask = "ReplicationTask"
        }
    }

    public struct MongoDbDataProviderSettings: AWSEncodableShape & AWSDecodableShape {
        /// The authentication method for connecting to the data provider. Valid values are DEFAULT, MONGODB_CR, or SCRAM_SHA_1.
        public let authMechanism: AuthMechanismValue?
        ///  The MongoDB database name. This setting isn't used when AuthType is set to "no".  The default is "admin".
        public let authSource: String?
        /// The authentication type for the database connection. Valid values are PASSWORD or NO.
        public let authType: AuthTypeValue?
        /// The Amazon Resource Name (ARN) of the certificate used for SSL connection.
        public let certificateArn: String?
        /// The database name on the MongoDB data provider.
        public let databaseName: String?
        /// The port value for the MongoDB data provider.
        public let port: Int?
        /// The name of the MongoDB server.
        public let serverName: String?
        /// The SSL mode used to connect to the MongoDB data provider.  The default value is none.
        public let sslMode: DmsSslModeValue?

        @inlinable
        public init(authMechanism: AuthMechanismValue? = nil, authSource: String? = nil, authType: AuthTypeValue? = nil, certificateArn: String? = nil, databaseName: String? = nil, port: Int? = nil, serverName: String? = nil, sslMode: DmsSslModeValue? = nil) {
            self.authMechanism = authMechanism
            self.authSource = authSource
            self.authType = authType
            self.certificateArn = certificateArn
            self.databaseName = databaseName
            self.port = port
            self.serverName = serverName
            self.sslMode = sslMode
        }

        private enum CodingKeys: String, CodingKey {
            case authMechanism = "AuthMechanism"
            case authSource = "AuthSource"
            case authType = "AuthType"
            case certificateArn = "CertificateArn"
            case databaseName = "DatabaseName"
            case port = "Port"
            case serverName = "ServerName"
            case sslMode = "SslMode"
        }
    }

    public struct MongoDbSettings: AWSEncodableShape & AWSDecodableShape {
        ///  The authentication mechanism you use to access the MongoDB source endpoint. For the default value, in MongoDB version 2.x, "default" is "mongodb_cr". For MongoDB version 3.x or later, "default" is "scram_sha_1". This setting isn't used when AuthType is set to "no".
        public let authMechanism: AuthMechanismValue?
        ///  The MongoDB database name. This setting isn't used when AuthType is set to "no".  The default is "admin".
        public let authSource: String?
        ///  The authentication type you use to access the MongoDB source endpoint. When when set to "no", user name and password parameters are not used and can be empty.
        public let authType: AuthTypeValue?
        ///  The database name on the MongoDB source endpoint.
        public let databaseName: String?
        ///  Indicates the number of documents to preview to determine the document organization. Use this setting when NestingLevel is set to "one".  Must be a positive value greater than 0. Default value is 1000.
        public let docsToInvestigate: String?
        ///  Specifies the document ID. Use this setting when NestingLevel is set to "none".  Default value is "false".
        public let extractDocId: String?
        /// The KMS key identifier that is used to encrypt the content on the replication instance. If you don't specify a value for the KmsKeyId parameter, then DMS uses your default encryption key. KMS creates the default encryption key for your Amazon Web Services account. Your Amazon Web Services account has a different default encryption key for each Amazon Web Services Region.
        public let kmsKeyId: String?
        ///  Specifies either document or table mode.  Default value is "none". Specify "none" to use document mode. Specify "one" to use table mode.
        public let nestingLevel: NestingLevelValue?
        ///  The password for the user account you use to access the MongoDB source endpoint.
        public let password: String?
        ///  The port value for the MongoDB source endpoint.
        public let port: Int?
        /// If true, DMS replicates data to shard collections. DMS only uses this setting if the target endpoint is a DocumentDB elastic cluster. When this setting is true, note the following:   You must set TargetTablePrepMode to nothing.   DMS automatically sets useUpdateLookup to false.
        public let replicateShardCollections: Bool?
        /// The full Amazon Resource Name (ARN) of the IAM role that specifies DMS as the trusted entity and grants the required permissions to access the value in SecretsManagerSecret. The role must allow the iam:PassRole action. SecretsManagerSecret has the value of the Amazon Web Services Secrets Manager secret that allows access to the MongoDB endpoint.  You can specify one of two sets of values for these permissions. You can specify the values for this setting and SecretsManagerSecretId. Or you can specify clear-text values for UserName, Password, ServerName, and Port. You can't specify both. For more information on creating this SecretsManagerSecret and the SecretsManagerAccessRoleArn and SecretsManagerSecretId required to access it, see Using secrets to access Database Migration Service resources in the Database Migration Service User Guide.
        public let secretsManagerAccessRoleArn: String?
        /// The full ARN, partial ARN, or friendly name of the SecretsManagerSecret that contains the MongoDB endpoint connection details.
        public let secretsManagerSecretId: String?
        ///  The name of the server on the MongoDB source endpoint. For MongoDB Atlas, provide the server name for any of the servers in the replication set.
        public let serverName: String?
        /// The user name you use to access the MongoDB source endpoint.
        public let username: String?
        /// If true, DMS retrieves the entire document from the MongoDB source during migration. This may cause a migration failure if the server response exceeds bandwidth limits. To fetch only updates and deletes during migration, set this parameter to false.
        public let useUpdateLookUp: Bool?

        @inlinable
        public init(authMechanism: AuthMechanismValue? = nil, authSource: String? = nil, authType: AuthTypeValue? = nil, databaseName: String? = nil, docsToInvestigate: String? = nil, extractDocId: String? = nil, kmsKeyId: String? = nil, nestingLevel: NestingLevelValue? = nil, password: String? = nil, port: Int? = nil, replicateShardCollections: Bool? = nil, secretsManagerAccessRoleArn: String? = nil, secretsManagerSecretId: String? = nil, serverName: String? = nil, username: String? = nil, useUpdateLookUp: Bool? = nil) {
            self.authMechanism = authMechanism
            self.authSource = authSource
            self.authType = authType
            self.databaseName = databaseName
            self.docsToInvestigate = docsToInvestigate
            self.extractDocId = extractDocId
            self.kmsKeyId = kmsKeyId
            self.nestingLevel = nestingLevel
            self.password = password
            self.port = port
            self.replicateShardCollections = replicateShardCollections
            self.secretsManagerAccessRoleArn = secretsManagerAccessRoleArn
            self.secretsManagerSecretId = secretsManagerSecretId
            self.serverName = serverName
            self.username = username
            self.useUpdateLookUp = useUpdateLookUp
        }

        private enum CodingKeys: String, CodingKey {
            case authMechanism = "AuthMechanism"
            case authSource = "AuthSource"
            case authType = "AuthType"
            case databaseName = "DatabaseName"
            case docsToInvestigate = "DocsToInvestigate"
            case extractDocId = "ExtractDocId"
            case kmsKeyId = "KmsKeyId"
            case nestingLevel = "NestingLevel"
            case password = "Password"
            case port = "Port"
            case replicateShardCollections = "ReplicateShardCollections"
            case secretsManagerAccessRoleArn = "SecretsManagerAccessRoleArn"
            case secretsManagerSecretId = "SecretsManagerSecretId"
            case serverName = "ServerName"
            case username = "Username"
            case useUpdateLookUp = "UseUpdateLookUp"
        }
    }

    public struct MoveReplicationTaskMessage: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the task that you want to move.
        public let replicationTaskArn: String
        /// The ARN of the replication instance where you want to move the task to.
        public let targetReplicationInstanceArn: String

        @inlinable
        public init(replicationTaskArn: String, targetReplicationInstanceArn: String) {
            self.replicationTaskArn = replicationTaskArn
            self.targetReplicationInstanceArn = targetReplicationInstanceArn
        }

        private enum CodingKeys: String, CodingKey {
            case replicationTaskArn = "ReplicationTaskArn"
            case targetReplicationInstanceArn = "TargetReplicationInstanceArn"
        }
    }

    public struct MoveReplicationTaskResponse: AWSDecodableShape {
        /// The replication task that was moved.
        public let replicationTask: ReplicationTask?

        @inlinable
        public init(replicationTask: ReplicationTask? = nil) {
            self.replicationTask = replicationTask
        }

        private enum CodingKeys: String, CodingKey {
            case replicationTask = "ReplicationTask"
        }
    }

    public struct MySQLSettings: AWSEncodableShape & AWSDecodableShape {
        /// Specifies a script to run immediately after DMS connects to the endpoint. The migration task continues running regardless if the SQL statement succeeds or fails. For this parameter, provide the code of the script itself, not the name of a file containing the script.
        public let afterConnectScript: String?
        /// Cleans and recreates table metadata information on the replication instance when a mismatch occurs. For example, in a situation where running an alter DDL on the table could result in different information about the table cached in the replication instance.
        public let cleanSourceMetadataOnMismatch: Bool?
        /// Database name for the endpoint. For a MySQL source or target endpoint, don't explicitly specify the database using the DatabaseName request parameter on either the CreateEndpoint or ModifyEndpoint API call. Specifying DatabaseName when you create or modify a MySQL endpoint replicates all the task tables to this single database. For MySQL endpoints, you specify the database only when you specify the schema in the table-mapping rules of the DMS task.
        public let databaseName: String?
        /// Specifies how often to check the binary log for new changes/events when the database is idle. The default is five seconds. Example: eventsPollInterval=5;  In the example, DMS checks for changes in the binary logs every five seconds.
        public let eventsPollInterval: Int?
        /// Sets the client statement timeout (in seconds) for a MySQL source endpoint.
        public let executeTimeout: Int?
        /// Specifies the maximum size (in KB) of any .csv file used to transfer data to a MySQL-compatible database. Example: maxFileSize=512
        public let maxFileSize: Int?
        /// Improves performance when loading data into the MySQL-compatible target database. Specifies how many threads to use to load the data into the MySQL-compatible target database. Setting a large number of threads can have an adverse effect on database performance, because a separate connection is required for each thread. The default is one. Example: parallelLoadThreads=1
        public let parallelLoadThreads: Int?
        /// Endpoint connection password.
        public let password: String?
        /// Endpoint TCP port.
        public let port: Int?
        /// The full Amazon Resource Name (ARN) of the IAM role that specifies DMS as the trusted entity and grants the required permissions to access the value in SecretsManagerSecret. The role must allow the iam:PassRole action. SecretsManagerSecret has the value of the Amazon Web Services Secrets Manager secret that allows access to the MySQL endpoint.  You can specify one of two sets of values for these permissions. You can specify the values for this setting and SecretsManagerSecretId. Or you can specify clear-text values for UserName, Password, ServerName, and Port. You can't specify both. For more information on creating this SecretsManagerSecret and the SecretsManagerAccessRoleArn and SecretsManagerSecretId required to access it, see Using secrets to access Database Migration Service resources in the Database Migration Service User Guide.
        public let secretsManagerAccessRoleArn: String?
        /// The full ARN, partial ARN, or friendly name of the SecretsManagerSecret that contains the MySQL endpoint connection details.
        public let secretsManagerSecretId: String?
        /// The host name of the endpoint database.  For an Amazon RDS MySQL instance, this is the output of DescribeDBInstances, in the  Endpoint.Address field. For an Aurora MySQL instance, this is the output of DescribeDBClusters, in the Endpoint field.
        public let serverName: String?
        /// Specifies the time zone for the source MySQL database. Example: serverTimezone=US/Pacific;  Note: Do not enclose time zones in single quotes.
        public let serverTimezone: String?
        /// Specifies where to migrate source tables on the target, either to a single database or multiple databases. If you specify SPECIFIC_DATABASE, specify the database name using the DatabaseName parameter of the Endpoint object. Example: targetDbType=MULTIPLE_DATABASES
        public let targetDbType: TargetDbType?
        /// Endpoint connection user name.
        public let username: String?

        @inlinable
        public init(afterConnectScript: String? = nil, cleanSourceMetadataOnMismatch: Bool? = nil, databaseName: String? = nil, eventsPollInterval: Int? = nil, executeTimeout: Int? = nil, maxFileSize: Int? = nil, parallelLoadThreads: Int? = nil, password: String? = nil, port: Int? = nil, secretsManagerAccessRoleArn: String? = nil, secretsManagerSecretId: String? = nil, serverName: String? = nil, serverTimezone: String? = nil, targetDbType: TargetDbType? = nil, username: String? = nil) {
            self.afterConnectScript = afterConnectScript
            self.cleanSourceMetadataOnMismatch = cleanSourceMetadataOnMismatch
            self.databaseName = databaseName
            self.eventsPollInterval = eventsPollInterval
            self.executeTimeout = executeTimeout
            self.maxFileSize = maxFileSize
            self.parallelLoadThreads = parallelLoadThreads
            self.password = password
            self.port = port
            self.secretsManagerAccessRoleArn = secretsManagerAccessRoleArn
            self.secretsManagerSecretId = secretsManagerSecretId
            self.serverName = serverName
            self.serverTimezone = serverTimezone
            self.targetDbType = targetDbType
            self.username = username
        }

        private enum CodingKeys: String, CodingKey {
            case afterConnectScript = "AfterConnectScript"
            case cleanSourceMetadataOnMismatch = "CleanSourceMetadataOnMismatch"
            case databaseName = "DatabaseName"
            case eventsPollInterval = "EventsPollInterval"
            case executeTimeout = "ExecuteTimeout"
            case maxFileSize = "MaxFileSize"
            case parallelLoadThreads = "ParallelLoadThreads"
            case password = "Password"
            case port = "Port"
            case secretsManagerAccessRoleArn = "SecretsManagerAccessRoleArn"
            case secretsManagerSecretId = "SecretsManagerSecretId"
            case serverName = "ServerName"
            case serverTimezone = "ServerTimezone"
            case targetDbType = "TargetDbType"
            case username = "Username"
        }
    }

    public struct MySqlDataProviderSettings: AWSEncodableShape & AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the certificate used for SSL connection.
        public let certificateArn: String?
        /// The port value for the MySQL data provider.
        public let port: Int?
        /// The name of the MySQL server.
        public let serverName: String?
        /// The SSL mode used to connect to the MySQL data provider.  The default value is none.
        public let sslMode: DmsSslModeValue?

        @inlinable
        public init(certificateArn: String? = nil, port: Int? = nil, serverName: String? = nil, sslMode: DmsSslModeValue? = nil) {
            self.certificateArn = certificateArn
            self.port = port
            self.serverName = serverName
            self.sslMode = sslMode
        }

        private enum CodingKeys: String, CodingKey {
            case certificateArn = "CertificateArn"
            case port = "Port"
            case serverName = "ServerName"
            case sslMode = "SslMode"
        }
    }

    public struct NeptuneSettings: AWSEncodableShape & AWSDecodableShape {
        /// The number of milliseconds for DMS to wait to retry a bulk-load of migrated graph data to the Neptune target database before raising an error. The default is 250.
        public let errorRetryDuration: Int?
        /// If you want Identity and Access Management (IAM) authorization enabled for this endpoint, set this parameter to true. Then attach the appropriate IAM policy document to your service role specified by ServiceAccessRoleArn. The default is false.
        public let iamAuthEnabled: Bool?
        /// The maximum size in kilobytes of migrated graph data stored in a .csv file before DMS bulk-loads the data to the Neptune target database. The default is 1,048,576 KB. If the bulk load is successful, DMS clears the bucket, ready to store the next batch of migrated graph data.
        public let maxFileSize: Int?
        /// The number of times for DMS to retry a bulk load of migrated graph data to the Neptune target database before raising an error. The default is 5.
        public let maxRetryCount: Int?
        /// A folder path where you want DMS to store migrated graph data in the S3 bucket specified by S3BucketName
        public let s3BucketFolder: String
        /// The name of the Amazon S3 bucket where DMS can temporarily store migrated graph data in .csv files before bulk-loading it to the Neptune target database. DMS maps the SQL source data to graph data before storing it in these .csv files.
        public let s3BucketName: String
        /// The Amazon Resource Name (ARN) of the service role that you created for the Neptune target endpoint. The role must allow the iam:PassRole action. For more information, see Creating an IAM Service Role for Accessing Amazon Neptune as a Target in the Database Migration Service User Guide.
        public let serviceAccessRoleArn: String?

        @inlinable
        public init(errorRetryDuration: Int? = nil, iamAuthEnabled: Bool? = nil, maxFileSize: Int? = nil, maxRetryCount: Int? = nil, s3BucketFolder: String, s3BucketName: String, serviceAccessRoleArn: String? = nil) {
            self.errorRetryDuration = errorRetryDuration
            self.iamAuthEnabled = iamAuthEnabled
            self.maxFileSize = maxFileSize
            self.maxRetryCount = maxRetryCount
            self.s3BucketFolder = s3BucketFolder
            self.s3BucketName = s3BucketName
            self.serviceAccessRoleArn = serviceAccessRoleArn
        }

        private enum CodingKeys: String, CodingKey {
            case errorRetryDuration = "ErrorRetryDuration"
            case iamAuthEnabled = "IamAuthEnabled"
            case maxFileSize = "MaxFileSize"
            case maxRetryCount = "MaxRetryCount"
            case s3BucketFolder = "S3BucketFolder"
            case s3BucketName = "S3BucketName"
            case serviceAccessRoleArn = "ServiceAccessRoleArn"
        }
    }

    public struct OracleDataProviderSettings: AWSEncodableShape & AWSDecodableShape {
        /// The address of your Oracle Automatic Storage Management (ASM) server. You can set  this value from the asm_server value. You set asm_server as part  of the extra connection attribute string to access an Oracle server with Binary Reader that  uses ASM. For more information, see Configuration for change data capture (CDC) on an Oracle source database.
        public let asmServer: String?
        /// The Amazon Resource Name (ARN) of the certificate used for SSL connection.
        public let certificateArn: String?
        /// The database name on the Oracle data provider.
        public let databaseName: String?
        /// The port value for the Oracle data provider.
        public let port: Int?
        /// The ARN of the IAM role that provides access to the secret in Secrets Manager  that contains the Oracle ASM connection details.
        public let secretsManagerOracleAsmAccessRoleArn: String?
        /// The identifier of the secret in Secrets Manager that contains the Oracle ASM connection details. Required only if your data provider uses the Oracle ASM server.
        public let secretsManagerOracleAsmSecretId: String?
        /// The ARN of the IAM role that provides access to the secret in Secrets Manager  that contains the TDE password.
        public let secretsManagerSecurityDbEncryptionAccessRoleArn: String?
        /// The identifier of the secret in Secrets Manager that contains the transparent data encryption (TDE)  password. DMS requires this password to access Oracle redo logs encrypted by TDE  using Binary Reader.
        public let secretsManagerSecurityDbEncryptionSecretId: String?
        /// The name of the Oracle server.
        public let serverName: String?
        /// The SSL mode used to connect to the Oracle data provider.  The default value is none.
        public let sslMode: DmsSslModeValue?

        @inlinable
        public init(asmServer: String? = nil, certificateArn: String? = nil, databaseName: String? = nil, port: Int? = nil, secretsManagerOracleAsmAccessRoleArn: String? = nil, secretsManagerOracleAsmSecretId: String? = nil, secretsManagerSecurityDbEncryptionAccessRoleArn: String? = nil, secretsManagerSecurityDbEncryptionSecretId: String? = nil, serverName: String? = nil, sslMode: DmsSslModeValue? = nil) {
            self.asmServer = asmServer
            self.certificateArn = certificateArn
            self.databaseName = databaseName
            self.port = port
            self.secretsManagerOracleAsmAccessRoleArn = secretsManagerOracleAsmAccessRoleArn
            self.secretsManagerOracleAsmSecretId = secretsManagerOracleAsmSecretId
            self.secretsManagerSecurityDbEncryptionAccessRoleArn = secretsManagerSecurityDbEncryptionAccessRoleArn
            self.secretsManagerSecurityDbEncryptionSecretId = secretsManagerSecurityDbEncryptionSecretId
            self.serverName = serverName
            self.sslMode = sslMode
        }

        private enum CodingKeys: String, CodingKey {
            case asmServer = "AsmServer"
            case certificateArn = "CertificateArn"
            case databaseName = "DatabaseName"
            case port = "Port"
            case secretsManagerOracleAsmAccessRoleArn = "SecretsManagerOracleAsmAccessRoleArn"
            case secretsManagerOracleAsmSecretId = "SecretsManagerOracleAsmSecretId"
            case secretsManagerSecurityDbEncryptionAccessRoleArn = "SecretsManagerSecurityDbEncryptionAccessRoleArn"
            case secretsManagerSecurityDbEncryptionSecretId = "SecretsManagerSecurityDbEncryptionSecretId"
            case serverName = "ServerName"
            case sslMode = "SslMode"
        }
    }

    public struct OracleSettings: AWSEncodableShape & AWSDecodableShape {
        /// Set this attribute to false in order to use the Binary Reader to capture change data for an Amazon RDS for Oracle as the source. This tells the DMS instance to not access redo logs through any specified path prefix replacement using direct file access.
        public let accessAlternateDirectly: Bool?
        /// Set this attribute with ArchivedLogDestId in a primary/ standby setup. This attribute is useful in the case of a switchover. In this case, DMS needs to know which destination to get archive redo logs from to read changes. This need arises because the previous primary instance is now a standby instance after switchover. Although DMS supports the use of the Oracle RESETLOGS option to open the database, never use RESETLOGS unless necessary. For additional information about RESETLOGS, see RMAN Data Repair Concepts in the Oracle Database Backup and Recovery User's Guide.
        public let additionalArchivedLogDestId: Int?
        /// Set this attribute to set up table-level supplemental logging for the Oracle database. This attribute enables PRIMARY KEY supplemental logging on all tables selected for a migration task. If you use this option, you still need to enable database-level supplemental logging.
        public let addSupplementalLogging: Bool?
        /// Set this attribute to true to enable replication of Oracle tables containing columns that are nested tables or defined types.
        public let allowSelectNestedTables: Bool?
        /// Specifies the ID of the destination for the archived redo logs. This value should be the same as a number in the dest_id column of the v$archived_log view. If you work with an additional redo log destination, use the AdditionalArchivedLogDestId option to specify the additional destination ID. Doing this improves performance by ensuring that the correct logs are accessed from the outset.
        public let archivedLogDestId: Int?
        /// When this field is set to True, DMS only accesses the archived redo logs. If the archived redo logs are stored on Automatic Storage Management (ASM) only, the DMS user account needs to be granted ASM privileges.
        public let archivedLogsOnly: Bool?
        /// For an Oracle source endpoint, your Oracle Automatic Storage Management (ASM) password. You can set this value from the  asm_user_password value. You set this value as part of the comma-separated value that you set to the Password request parameter when you create the endpoint to access transaction logs using Binary Reader. For more information, see Configuration for change data capture (CDC) on an Oracle source database.
        public let asmPassword: String?
        /// For an Oracle source endpoint, your ASM server address. You can set this value from the asm_server value. You set asm_server as part of the extra connection attribute string to access an Oracle server with Binary Reader that uses ASM. For more information, see Configuration for change data capture (CDC) on an Oracle source database.
        public let asmServer: String?
        /// For an Oracle source endpoint, your ASM user name. You can set this value from the asm_user value. You set asm_user as part of the extra connection attribute string to access an Oracle server with Binary Reader that uses ASM. For more information, see Configuration for change data capture (CDC) on an Oracle source database.
        public let asmUser: String?
        /// Specifies the authentication method to be used with Oracle.
        public let authenticationMethod: OracleAuthenticationMethod?
        /// Specifies whether the length of a character column is in bytes or in characters. To indicate that the character column length is in characters, set this attribute to CHAR. Otherwise, the character column length is in bytes. Example: charLengthSemantics=CHAR;
        public let charLengthSemantics: CharLengthSemantics?
        /// When true, converts timestamps with the timezone datatype to their UTC value.
        public let convertTimestampWithZoneToUTC: Bool?
        /// Database name for the endpoint.
        public let databaseName: String?
        /// When set to true, this attribute helps to increase the commit rate on the Oracle target database by writing directly to tables and not writing a trail to database logs.
        public let directPathNoLog: Bool?
        /// When set to true, this attribute specifies a parallel load when useDirectPathFullLoad is set to Y. This attribute also only applies when you use the DMS parallel load feature. Note that the target table cannot have any constraints or indexes.
        public let directPathParallelLoad: Bool?
        /// Set this attribute to enable homogenous tablespace replication and create existing tables or indexes under the same tablespace on the target.
        public let enableHomogenousTablespace: Bool?
        /// Specifies the IDs of one more destinations for one or more archived redo logs. These IDs are the values of the dest_id column in the v$archived_log view. Use this setting with the archivedLogDestId extra connection attribute in a primary-to-single setup or a primary-to-multiple-standby setup.  This setting is useful in a switchover when you use an Oracle Data Guard database as a source. In this case, DMS needs information about what destination to get archive redo logs from to read changes. DMS needs this because after the switchover the previous primary is a standby instance. For example, in a primary-to-single standby setup you might apply the following settings.   archivedLogDestId=1; ExtraArchivedLogDestIds=[2]  In a primary-to-multiple-standby setup, you might apply the following settings.  archivedLogDestId=1; ExtraArchivedLogDestIds=[2,3,4]  Although DMS supports the use of the Oracle RESETLOGS option to open the database, never use RESETLOGS unless it's necessary. For more information about RESETLOGS, see  RMAN Data Repair Concepts in the Oracle Database Backup and Recovery User's Guide.
        public let extraArchivedLogDestIds: [Int]?
        /// When set to true, this attribute causes a task to fail if the actual size of an LOB column is greater than the specified LobMaxSize. If a task is set to limited LOB mode and this option is set to true, the task fails instead of truncating the LOB data.
        public let failTasksOnLobTruncation: Bool?
        /// Specifies the number scale. You can select a scale up to 38, or you can select FLOAT. By default, the NUMBER data type is converted to precision 38, scale 10. Example: numberDataTypeScale=12
        public let numberDatatypeScale: Int?
        /// The timeframe in minutes to check for open transactions for a CDC-only task. You can specify an integer value between 0 (the default) and 240 (the maximum).   This parameter is only valid in DMS version 3.5.0 and later.
        public let openTransactionWindow: Int?
        /// Set this string attribute to the required value in order to use the Binary Reader to capture change data for an Amazon RDS for Oracle as the source. This value specifies the default Oracle root used to access the redo logs.
        public let oraclePathPrefix: String?
        /// Set this attribute to change the number of threads that DMS configures to perform a change data capture (CDC) load using Oracle Automatic Storage Management (ASM). You can specify an integer value between 2 (the default) and 8 (the maximum). Use this attribute together with the readAheadBlocks attribute.
        public let parallelAsmReadThreads: Int?
        /// Endpoint connection password.
        public let password: String?
        /// Endpoint TCP port.
        public let port: Int?
        /// Set this attribute to change the number of read-ahead blocks that DMS configures to perform a change data capture (CDC) load using Oracle Automatic Storage Management (ASM). You can specify an integer value between 1000 (the default) and 200,000 (the maximum).
        public let readAheadBlocks: Int?
        /// When set to true, this attribute supports tablespace replication.
        public let readTableSpaceName: Bool?
        /// Set this attribute to true in order to use the Binary Reader to capture change data for an Amazon RDS for Oracle as the source. This setting tells DMS instance to replace the default Oracle root with the specified usePathPrefix setting to access the redo logs.
        public let replacePathPrefix: Bool?
        /// Specifies the number of seconds that the system waits before resending a query. Example: retryInterval=6;
        public let retryInterval: Int?
        /// The full Amazon Resource Name (ARN) of the IAM role that specifies DMS as the trusted entity and grants the required permissions to access the value in SecretsManagerSecret. The role must allow the iam:PassRole action. SecretsManagerSecret has the value of the Amazon Web Services Secrets Manager secret that allows access to the Oracle endpoint.  You can specify one of two sets of values for these permissions. You can specify the values for this setting and SecretsManagerSecretId. Or you can specify clear-text values for UserName, Password, ServerName, and Port. You can't specify both. For more information on creating this SecretsManagerSecret and the SecretsManagerAccessRoleArn and SecretsManagerSecretId required to access it, see Using secrets to access Database Migration Service resources in the Database Migration Service User Guide.
        public let secretsManagerAccessRoleArn: String?
        /// Required only if your Oracle endpoint uses Automatic Storage Management (ASM). The full ARN of the IAM role that specifies DMS as the trusted entity and grants the required permissions to access the SecretsManagerOracleAsmSecret. This SecretsManagerOracleAsmSecret has the secret value that allows access to the Oracle ASM of the endpoint.  You can specify one of two sets of values for these permissions. You can specify the values for this setting and SecretsManagerOracleAsmSecretId. Or you can specify clear-text values for AsmUser, AsmPassword, and AsmServerName. You can't specify both. For more information on creating this SecretsManagerOracleAsmSecret and the SecretsManagerOracleAsmAccessRoleArn and SecretsManagerOracleAsmSecretId required to access it, see Using secrets to access Database Migration Service resources in the Database Migration Service User Guide.
        public let secretsManagerOracleAsmAccessRoleArn: String?
        /// Required only if your Oracle endpoint uses Automatic Storage Management (ASM). The full ARN, partial ARN, or friendly name of the SecretsManagerOracleAsmSecret that contains the Oracle ASM connection details for the Oracle endpoint.
        public let secretsManagerOracleAsmSecretId: String?
        /// The full ARN, partial ARN, or friendly name of the SecretsManagerSecret that contains the Oracle endpoint connection details.
        public let secretsManagerSecretId: String?
        /// For an Oracle source endpoint, the transparent data encryption (TDE) password required by AWM DMS to access Oracle redo logs encrypted by TDE using Binary Reader. It is also the  TDE_Password part of the comma-separated value you set to the Password request parameter when you create the endpoint. The SecurityDbEncryptian setting is related to this SecurityDbEncryptionName setting. For more information, see  Supported encryption methods for using Oracle as a source for DMS  in the Database Migration Service User Guide.
        public let securityDbEncryption: String?
        /// For an Oracle source endpoint, the name of a key used for the transparent data encryption (TDE) of the columns and tablespaces in an Oracle source database that is encrypted using TDE. The key value is the value of the SecurityDbEncryption setting. For more information on setting the key name value of SecurityDbEncryptionName, see the information and example for setting the securityDbEncryptionName extra connection attribute in  Supported encryption methods for using Oracle as a source for DMS  in the Database Migration Service User Guide.
        public let securityDbEncryptionName: String?
        /// Fully qualified domain name of the endpoint. For an Amazon RDS Oracle instance, this is the output of DescribeDBInstances, in the  Endpoint.Address field.
        public let serverName: String?
        /// Use this attribute to convert SDO_GEOMETRY to GEOJSON format. By default, DMS calls the SDO2GEOJSON custom function if present and accessible. Or you can create your own custom function that mimics the operation of SDOGEOJSON and set SpatialDataOptionToGeoJsonFunctionName to call it instead.
        public let spatialDataOptionToGeoJsonFunctionName: String?
        /// Use this attribute to specify a time in minutes for the delay in standby sync. If the source is an Oracle Active Data Guard standby database, use this attribute to specify the time lag between primary and standby databases. In DMS, you can create an Oracle CDC task that uses an Active Data Guard standby instance as a source for replicating ongoing changes. Doing this eliminates the need to connect to an active database that might be in production.
        public let standbyDelayTime: Int?
        /// Use the TrimSpaceInChar source endpoint setting to trim data on CHAR and NCHAR data types during migration. The default value is true.
        public let trimSpaceInChar: Bool?
        /// Set this attribute to true in order to use the Binary Reader to capture change data for an Amazon RDS for Oracle as the source. This tells the DMS instance to use any specified prefix replacement to access all online redo logs.
        public let useAlternateFolderForOnline: Bool?
        /// Set this attribute to True to capture change data using the Binary Reader utility. Set UseLogminerReader to False to set this attribute to True. To use Binary Reader with Amazon RDS for Oracle as the source, you set additional attributes. For more information about using this setting with Oracle Automatic Storage Management (ASM), see Using Oracle LogMiner or DMS Binary Reader for CDC.
        public let useBFile: Bool?
        /// Set this attribute to True to have DMS use a direct path full load. Specify this value to use the direct path protocol in the Oracle Call Interface (OCI). By using this OCI protocol, you can bulk-load Oracle target tables during a full load.
        public let useDirectPathFullLoad: Bool?
        /// Set this attribute to True to capture change data using the Oracle LogMiner utility (the default). Set this attribute to False if you want to access the redo logs as a binary file. When you set UseLogminerReader to False, also set UseBfile to True. For more information on this setting and using Oracle ASM, see  Using Oracle LogMiner or DMS Binary Reader for CDC in the DMS User Guide.
        public let useLogminerReader: Bool?
        /// Set this string attribute to the required value in order to use the Binary Reader to capture change data for an Amazon RDS for Oracle as the source. This value specifies the path prefix used to replace the default Oracle root to access the redo logs.
        public let usePathPrefix: String?
        /// Endpoint connection user name.
        public let username: String?

        @inlinable
        public init(accessAlternateDirectly: Bool? = nil, additionalArchivedLogDestId: Int? = nil, addSupplementalLogging: Bool? = nil, allowSelectNestedTables: Bool? = nil, archivedLogDestId: Int? = nil, archivedLogsOnly: Bool? = nil, asmPassword: String? = nil, asmServer: String? = nil, asmUser: String? = nil, authenticationMethod: OracleAuthenticationMethod? = nil, charLengthSemantics: CharLengthSemantics? = nil, convertTimestampWithZoneToUTC: Bool? = nil, databaseName: String? = nil, directPathNoLog: Bool? = nil, directPathParallelLoad: Bool? = nil, enableHomogenousTablespace: Bool? = nil, extraArchivedLogDestIds: [Int]? = nil, failTasksOnLobTruncation: Bool? = nil, numberDatatypeScale: Int? = nil, openTransactionWindow: Int? = nil, oraclePathPrefix: String? = nil, parallelAsmReadThreads: Int? = nil, password: String? = nil, port: Int? = nil, readAheadBlocks: Int? = nil, readTableSpaceName: Bool? = nil, replacePathPrefix: Bool? = nil, retryInterval: Int? = nil, secretsManagerAccessRoleArn: String? = nil, secretsManagerOracleAsmAccessRoleArn: String? = nil, secretsManagerOracleAsmSecretId: String? = nil, secretsManagerSecretId: String? = nil, securityDbEncryption: String? = nil, securityDbEncryptionName: String? = nil, serverName: String? = nil, spatialDataOptionToGeoJsonFunctionName: String? = nil, standbyDelayTime: Int? = nil, trimSpaceInChar: Bool? = nil, useAlternateFolderForOnline: Bool? = nil, useBFile: Bool? = nil, useDirectPathFullLoad: Bool? = nil, useLogminerReader: Bool? = nil, usePathPrefix: String? = nil, username: String? = nil) {
            self.accessAlternateDirectly = accessAlternateDirectly
            self.additionalArchivedLogDestId = additionalArchivedLogDestId
            self.addSupplementalLogging = addSupplementalLogging
            self.allowSelectNestedTables = allowSelectNestedTables
            self.archivedLogDestId = archivedLogDestId
            self.archivedLogsOnly = archivedLogsOnly
            self.asmPassword = asmPassword
            self.asmServer = asmServer
            self.asmUser = asmUser
            self.authenticationMethod = authenticationMethod
            self.charLengthSemantics = charLengthSemantics
            self.convertTimestampWithZoneToUTC = convertTimestampWithZoneToUTC
            self.databaseName = databaseName
            self.directPathNoLog = directPathNoLog
            self.directPathParallelLoad = directPathParallelLoad
            self.enableHomogenousTablespace = enableHomogenousTablespace
            self.extraArchivedLogDestIds = extraArchivedLogDestIds
            self.failTasksOnLobTruncation = failTasksOnLobTruncation
            self.numberDatatypeScale = numberDatatypeScale
            self.openTransactionWindow = openTransactionWindow
            self.oraclePathPrefix = oraclePathPrefix
            self.parallelAsmReadThreads = parallelAsmReadThreads
            self.password = password
            self.port = port
            self.readAheadBlocks = readAheadBlocks
            self.readTableSpaceName = readTableSpaceName
            self.replacePathPrefix = replacePathPrefix
            self.retryInterval = retryInterval
            self.secretsManagerAccessRoleArn = secretsManagerAccessRoleArn
            self.secretsManagerOracleAsmAccessRoleArn = secretsManagerOracleAsmAccessRoleArn
            self.secretsManagerOracleAsmSecretId = secretsManagerOracleAsmSecretId
            self.secretsManagerSecretId = secretsManagerSecretId
            self.securityDbEncryption = securityDbEncryption
            self.securityDbEncryptionName = securityDbEncryptionName
            self.serverName = serverName
            self.spatialDataOptionToGeoJsonFunctionName = spatialDataOptionToGeoJsonFunctionName
            self.standbyDelayTime = standbyDelayTime
            self.trimSpaceInChar = trimSpaceInChar
            self.useAlternateFolderForOnline = useAlternateFolderForOnline
            self.useBFile = useBFile
            self.useDirectPathFullLoad = useDirectPathFullLoad
            self.useLogminerReader = useLogminerReader
            self.usePathPrefix = usePathPrefix
            self.username = username
        }

        private enum CodingKeys: String, CodingKey {
            case accessAlternateDirectly = "AccessAlternateDirectly"
            case additionalArchivedLogDestId = "AdditionalArchivedLogDestId"
            case addSupplementalLogging = "AddSupplementalLogging"
            case allowSelectNestedTables = "AllowSelectNestedTables"
            case archivedLogDestId = "ArchivedLogDestId"
            case archivedLogsOnly = "ArchivedLogsOnly"
            case asmPassword = "AsmPassword"
            case asmServer = "AsmServer"
            case asmUser = "AsmUser"
            case authenticationMethod = "AuthenticationMethod"
            case charLengthSemantics = "CharLengthSemantics"
            case convertTimestampWithZoneToUTC = "ConvertTimestampWithZoneToUTC"
            case databaseName = "DatabaseName"
            case directPathNoLog = "DirectPathNoLog"
            case directPathParallelLoad = "DirectPathParallelLoad"
            case enableHomogenousTablespace = "EnableHomogenousTablespace"
            case extraArchivedLogDestIds = "ExtraArchivedLogDestIds"
            case failTasksOnLobTruncation = "FailTasksOnLobTruncation"
            case numberDatatypeScale = "NumberDatatypeScale"
            case openTransactionWindow = "OpenTransactionWindow"
            case oraclePathPrefix = "OraclePathPrefix"
            case parallelAsmReadThreads = "ParallelAsmReadThreads"
            case password = "Password"
            case port = "Port"
            case readAheadBlocks = "ReadAheadBlocks"
            case readTableSpaceName = "ReadTableSpaceName"
            case replacePathPrefix = "ReplacePathPrefix"
            case retryInterval = "RetryInterval"
            case secretsManagerAccessRoleArn = "SecretsManagerAccessRoleArn"
            case secretsManagerOracleAsmAccessRoleArn = "SecretsManagerOracleAsmAccessRoleArn"
            case secretsManagerOracleAsmSecretId = "SecretsManagerOracleAsmSecretId"
            case secretsManagerSecretId = "SecretsManagerSecretId"
            case securityDbEncryption = "SecurityDbEncryption"
            case securityDbEncryptionName = "SecurityDbEncryptionName"
            case serverName = "ServerName"
            case spatialDataOptionToGeoJsonFunctionName = "SpatialDataOptionToGeoJsonFunctionName"
            case standbyDelayTime = "StandbyDelayTime"
            case trimSpaceInChar = "TrimSpaceInChar"
            case useAlternateFolderForOnline = "UseAlternateFolderForOnline"
            case useBFile = "UseBFile"
            case useDirectPathFullLoad = "UseDirectPathFullLoad"
            case useLogminerReader = "UseLogminerReader"
            case usePathPrefix = "UsePathPrefix"
            case username = "Username"
        }
    }

    public struct OrderableReplicationInstance: AWSDecodableShape {
        /// List of Availability Zones for this replication instance.
        public let availabilityZones: [String]?
        /// The default amount of storage (in gigabytes) that is allocated for the replication instance.
        public let defaultAllocatedStorage: Int?
        /// The version of the replication engine.
        public let engineVersion: String?
        /// The amount of storage (in gigabytes) that is allocated for the replication instance.
        public let includedAllocatedStorage: Int?
        /// The minimum amount of storage (in gigabytes) that can be allocated for the replication instance.
        public let maxAllocatedStorage: Int?
        /// The minimum amount of storage (in gigabytes) that can be allocated for the replication instance.
        public let minAllocatedStorage: Int?
        /// The value returned when the specified EngineVersion of the replication instance is in Beta or test mode. This indicates some features might not work as expected.  DMS supports the ReleaseStatus parameter in versions 3.1.4 and later.
        public let releaseStatus: ReleaseStatusValues?
        /// The compute and memory capacity of the replication instance as defined for the specified replication instance class. For example to specify the instance class dms.c4.large, set this parameter to "dms.c4.large". For more information on the settings and capacities for the available replication instance classes, see  Selecting the right DMS replication instance for your migration.
        public let replicationInstanceClass: String?
        /// The type of storage used by the replication instance.
        public let storageType: String?

        @inlinable
        public init(availabilityZones: [String]? = nil, defaultAllocatedStorage: Int? = nil, engineVersion: String? = nil, includedAllocatedStorage: Int? = nil, maxAllocatedStorage: Int? = nil, minAllocatedStorage: Int? = nil, releaseStatus: ReleaseStatusValues? = nil, replicationInstanceClass: String? = nil, storageType: String? = nil) {
            self.availabilityZones = availabilityZones
            self.defaultAllocatedStorage = defaultAllocatedStorage
            self.engineVersion = engineVersion
            self.includedAllocatedStorage = includedAllocatedStorage
            self.maxAllocatedStorage = maxAllocatedStorage
            self.minAllocatedStorage = minAllocatedStorage
            self.releaseStatus = releaseStatus
            self.replicationInstanceClass = replicationInstanceClass
            self.storageType = storageType
        }

        private enum CodingKeys: String, CodingKey {
            case availabilityZones = "AvailabilityZones"
            case defaultAllocatedStorage = "DefaultAllocatedStorage"
            case engineVersion = "EngineVersion"
            case includedAllocatedStorage = "IncludedAllocatedStorage"
            case maxAllocatedStorage = "MaxAllocatedStorage"
            case minAllocatedStorage = "MinAllocatedStorage"
            case releaseStatus = "ReleaseStatus"
            case replicationInstanceClass = "ReplicationInstanceClass"
            case storageType = "StorageType"
        }
    }

    public struct PendingMaintenanceAction: AWSDecodableShape {
        /// The type of pending maintenance action that is available for the resource.
        public let action: String?
        /// The date of the maintenance window when the action is to be applied. The maintenance action is applied to the resource during its first maintenance window after this date. If this date is specified, any next-maintenance opt-in requests are ignored.
        public let autoAppliedAfterDate: Date?
        /// The effective date when the pending maintenance action will be applied to the resource. This date takes into account opt-in requests received from the ApplyPendingMaintenanceAction API operation, and also the AutoAppliedAfterDate and ForcedApplyDate parameter values. This value is blank if an opt-in request has not been received and nothing has been specified for AutoAppliedAfterDate or ForcedApplyDate.
        public let currentApplyDate: Date?
        /// A description providing more detail about the maintenance action.
        public let description: String?
        /// The date when the maintenance action will be automatically applied. The maintenance action is applied to the resource on this date regardless of the maintenance window for the resource. If this date is specified, any immediate opt-in requests are ignored.
        public let forcedApplyDate: Date?
        /// The type of opt-in request that has been received for the resource.
        public let optInStatus: String?

        @inlinable
        public init(action: String? = nil, autoAppliedAfterDate: Date? = nil, currentApplyDate: Date? = nil, description: String? = nil, forcedApplyDate: Date? = nil, optInStatus: String? = nil) {
            self.action = action
            self.autoAppliedAfterDate = autoAppliedAfterDate
            self.currentApplyDate = currentApplyDate
            self.description = description
            self.forcedApplyDate = forcedApplyDate
            self.optInStatus = optInStatus
        }

        private enum CodingKeys: String, CodingKey {
            case action = "Action"
            case autoAppliedAfterDate = "AutoAppliedAfterDate"
            case currentApplyDate = "CurrentApplyDate"
            case description = "Description"
            case forcedApplyDate = "ForcedApplyDate"
            case optInStatus = "OptInStatus"
        }
    }

    public struct PostgreSQLSettings: AWSEncodableShape & AWSDecodableShape {
        /// For use with change data capture (CDC) only, this attribute has DMS bypass foreign keys and user triggers to reduce the time it takes to bulk load data. Example: afterConnectScript=SET session_replication_role='replica'
        public let afterConnectScript: String?
        /// The Babelfish for Aurora PostgreSQL database name for the endpoint.
        public let babelfishDatabaseName: String?
        /// To capture DDL events, DMS creates various artifacts in the PostgreSQL database when the task starts. You can later remove these artifacts. The default value is true. If this value is set to N, you don't have to create tables or triggers on the source database.
        public let captureDdls: Bool?
        /// Specifies the default behavior of the replication's handling of PostgreSQL- compatible endpoints that require some additional configuration, such as Babelfish endpoints.
        public let databaseMode: DatabaseMode?
        /// Database name for the endpoint.
        public let databaseName: String?
        /// The schema in which the operational DDL database artifacts are created. The default value is public. Example: ddlArtifactsSchema=xyzddlschema;
        public let ddlArtifactsSchema: String?
        /// Disables the Unicode source filter with PostgreSQL, for values passed into the Selection rule filter on Source Endpoint column values. By default DMS performs source filter comparisons using a Unicode string which can cause look ups to ignore the indexes in the text columns and slow down migrations. Unicode support should only be disabled when using a selection rule filter is on a text column in the Source database that is indexed.
        public let disableUnicodeSourceFilter: Bool?
        /// Sets the client statement timeout for the PostgreSQL instance, in seconds. The default value is 60 seconds. Example: executeTimeout=100;
        public let executeTimeout: Int?
        /// When set to true, this value causes a task to fail if the actual size of a LOB column is greater than the specified LobMaxSize. The default value is false. If task is set to Limited LOB mode and this option is set to true, the task fails instead of truncating the LOB data.
        public let failTasksOnLobTruncation: Bool?
        /// The write-ahead log (WAL) heartbeat feature mimics a dummy transaction. By doing this, it prevents idle logical replication slots from holding onto old WAL logs, which can result in storage full situations on the source. This heartbeat keeps restart_lsn moving and prevents storage full scenarios. The default value is false.
        public let heartbeatEnable: Bool?
        /// Sets the WAL heartbeat frequency (in minutes). The default value is 5 minutes.
        public let heartbeatFrequency: Int?
        /// Sets the schema in which the heartbeat artifacts are created. The default value is public.
        public let heartbeatSchema: String?
        /// When true, lets PostgreSQL migrate the boolean type as boolean. By default, PostgreSQL migrates booleans as varchar(5). You must set this setting on both the source and target endpoints for it to take effect. The default value is false.
        public let mapBooleanAsBoolean: Bool?
        /// When true, DMS migrates JSONB values as CLOB. The default value is false.
        public let mapJsonbAsClob: Bool?
        /// Sets what datatype to map LONG values as. The default value is wstring.
        public let mapLongVarcharAs: LongVarcharMappingType?
        /// Specifies the maximum size (in KB) of any .csv file used to transfer data to PostgreSQL. The default value is 32,768 KB (32 MB). Example: maxFileSize=512
        public let maxFileSize: Int?
        /// Endpoint connection password.
        public let password: String?
        /// Specifies the plugin to use to create a replication slot. The default value is pglogical.
        public let pluginName: PluginNameValue?
        /// Endpoint TCP port. The default is 5432.
        public let port: Int?
        /// The full Amazon Resource Name (ARN) of the IAM role that specifies DMS as the trusted entity and grants the required permissions to access the value in SecretsManagerSecret. The role must allow the iam:PassRole action. SecretsManagerSecret has the value of the Amazon Web Services Secrets Manager secret that allows access to the PostgreSQL endpoint.  You can specify one of two sets of values for these permissions. You can specify the values for this setting and SecretsManagerSecretId. Or you can specify clear-text values for UserName, Password, ServerName, and Port. You can't specify both. For more information on creating this SecretsManagerSecret and the SecretsManagerAccessRoleArn and SecretsManagerSecretId required to access it, see Using secrets to access Database Migration Service resources in the Database Migration Service User Guide.
        public let secretsManagerAccessRoleArn: String?
        /// The full ARN, partial ARN, or friendly name of the SecretsManagerSecret that contains the PostgreSQL endpoint connection details.
        public let secretsManagerSecretId: String?
        /// The host name of the endpoint database.  For an Amazon RDS PostgreSQL instance, this is the output of DescribeDBInstances, in the  Endpoint.Address field. For an Aurora PostgreSQL instance, this is the output of DescribeDBClusters, in the Endpoint field.
        public let serverName: String?
        /// Sets the name of a previously created logical replication slot for a change data capture (CDC) load of the PostgreSQL source instance.  When used with the CdcStartPosition request parameter for the DMS API , this attribute also makes it possible to use native CDC start points. DMS verifies that the specified logical replication slot exists before starting the CDC load task. It also verifies that the task was created with a valid setting of CdcStartPosition. If the specified slot doesn't exist or the task doesn't have a valid CdcStartPosition setting, DMS raises an error. For more information about setting the CdcStartPosition request parameter, see Determining a CDC native start point in the Database Migration Service User Guide. For more information about using CdcStartPosition, see CreateReplicationTask, StartReplicationTask, and ModifyReplicationTask.
        public let slotName: String?
        /// Use the TrimSpaceInChar source endpoint setting to trim data on CHAR and NCHAR data types during migration. The default value is true.
        public let trimSpaceInChar: Bool?
        /// Endpoint connection user name.
        public let username: String?

        @inlinable
        public init(afterConnectScript: String? = nil, babelfishDatabaseName: String? = nil, captureDdls: Bool? = nil, databaseMode: DatabaseMode? = nil, databaseName: String? = nil, ddlArtifactsSchema: String? = nil, disableUnicodeSourceFilter: Bool? = nil, executeTimeout: Int? = nil, failTasksOnLobTruncation: Bool? = nil, heartbeatEnable: Bool? = nil, heartbeatFrequency: Int? = nil, heartbeatSchema: String? = nil, mapBooleanAsBoolean: Bool? = nil, mapJsonbAsClob: Bool? = nil, mapLongVarcharAs: LongVarcharMappingType? = nil, maxFileSize: Int? = nil, password: String? = nil, pluginName: PluginNameValue? = nil, port: Int? = nil, secretsManagerAccessRoleArn: String? = nil, secretsManagerSecretId: String? = nil, serverName: String? = nil, slotName: String? = nil, trimSpaceInChar: Bool? = nil, username: String? = nil) {
            self.afterConnectScript = afterConnectScript
            self.babelfishDatabaseName = babelfishDatabaseName
            self.captureDdls = captureDdls
            self.databaseMode = databaseMode
            self.databaseName = databaseName
            self.ddlArtifactsSchema = ddlArtifactsSchema
            self.disableUnicodeSourceFilter = disableUnicodeSourceFilter
            self.executeTimeout = executeTimeout
            self.failTasksOnLobTruncation = failTasksOnLobTruncation
            self.heartbeatEnable = heartbeatEnable
            self.heartbeatFrequency = heartbeatFrequency
            self.heartbeatSchema = heartbeatSchema
            self.mapBooleanAsBoolean = mapBooleanAsBoolean
            self.mapJsonbAsClob = mapJsonbAsClob
            self.mapLongVarcharAs = mapLongVarcharAs
            self.maxFileSize = maxFileSize
            self.password = password
            self.pluginName = pluginName
            self.port = port
            self.secretsManagerAccessRoleArn = secretsManagerAccessRoleArn
            self.secretsManagerSecretId = secretsManagerSecretId
            self.serverName = serverName
            self.slotName = slotName
            self.trimSpaceInChar = trimSpaceInChar
            self.username = username
        }

        private enum CodingKeys: String, CodingKey {
            case afterConnectScript = "AfterConnectScript"
            case babelfishDatabaseName = "BabelfishDatabaseName"
            case captureDdls = "CaptureDdls"
            case databaseMode = "DatabaseMode"
            case databaseName = "DatabaseName"
            case ddlArtifactsSchema = "DdlArtifactsSchema"
            case disableUnicodeSourceFilter = "DisableUnicodeSourceFilter"
            case executeTimeout = "ExecuteTimeout"
            case failTasksOnLobTruncation = "FailTasksOnLobTruncation"
            case heartbeatEnable = "HeartbeatEnable"
            case heartbeatFrequency = "HeartbeatFrequency"
            case heartbeatSchema = "HeartbeatSchema"
            case mapBooleanAsBoolean = "MapBooleanAsBoolean"
            case mapJsonbAsClob = "MapJsonbAsClob"
            case mapLongVarcharAs = "MapLongVarcharAs"
            case maxFileSize = "MaxFileSize"
            case password = "Password"
            case pluginName = "PluginName"
            case port = "Port"
            case secretsManagerAccessRoleArn = "SecretsManagerAccessRoleArn"
            case secretsManagerSecretId = "SecretsManagerSecretId"
            case serverName = "ServerName"
            case slotName = "SlotName"
            case trimSpaceInChar = "TrimSpaceInChar"
            case username = "Username"
        }
    }

    public struct PostgreSqlDataProviderSettings: AWSEncodableShape & AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the certificate used for SSL connection.
        public let certificateArn: String?
        /// The database name on the PostgreSQL data provider.
        public let databaseName: String?
        /// The port value for the PostgreSQL data provider.
        public let port: Int?
        /// The name of the PostgreSQL server.
        public let serverName: String?
        /// The SSL mode used to connect to the PostgreSQL data provider.  The default value is none.
        public let sslMode: DmsSslModeValue?

        @inlinable
        public init(certificateArn: String? = nil, databaseName: String? = nil, port: Int? = nil, serverName: String? = nil, sslMode: DmsSslModeValue? = nil) {
            self.certificateArn = certificateArn
            self.databaseName = databaseName
            self.port = port
            self.serverName = serverName
            self.sslMode = sslMode
        }

        private enum CodingKeys: String, CodingKey {
            case certificateArn = "CertificateArn"
            case databaseName = "DatabaseName"
            case port = "Port"
            case serverName = "ServerName"
            case sslMode = "SslMode"
        }
    }

    public struct PremigrationAssessmentStatus: AWSDecodableShape {
        public let assessmentProgress: ReplicationTaskAssessmentRunProgress?
        /// A configurable setting you can set to true (the defualt setting) or false. Use this setting to to stop the replication from starting automatically if the assessment fails. This can help you evaluate the issue that is preventing the replication from running successfully.
        public let failOnAssessmentFailure: Bool?
        /// The last message generated by an individual assessment failure.
        public let lastFailureMessage: String?
        /// The Amazon Resource Name (ARN) of this assessment run.
        public let premigrationAssessmentRunArn: String?
        /// The date which the assessment run was created.
        public let premigrationAssessmentRunCreationDate: Date?
        /// The supported values are SSE_KMS and SSE_S3. If these values are not provided, then the files are not encrypted at rest. For more information, see Creating Amazon Web Services KMS keys to encrypt Amazon S3 target objects.
        public let resultEncryptionMode: String?
        /// The ARN of a custom KMS encryption key that you specify when you set ResultEncryptionMode to SSE_KMS.
        public let resultKmsKeyArn: String?
        /// The Amazon S3 bucket that Database Migration Service Serverless created to store the results of this assessment run.
        public let resultLocationBucket: String?
        /// The folder within an Amazon S3 bucket where you want Database Migration Service to store the results of this assessment run.
        public let resultLocationFolder: String?
        public let resultStatistic: ReplicationTaskAssessmentRunResultStatistic?
        /// This describes the assessment run status. The status can be one of the following values:    cancelling: The assessment run was canceled.    deleting: The assessment run was deleted.    failed: At least one individual assessment completed with a failed status.     error-provisioning: An internal error occurred while resources were provisioned (during the provisioning status).    error-executing An internal error occurred while individual assessments ran (during the running status).    invalid state: The assessment run is in an unknown state.     passed: All individual assessments have completed and none have a failed status.    provisioning: The resources required to run individual assessments are being provisioned.     running: Individual assessments are being run.     starting: The assessment run is starting, but resources are not yet being provisioned for individual assessments.     warning: At least one individual assessment completed with a warning status.
        public let status: String?

        @inlinable
        public init(assessmentProgress: ReplicationTaskAssessmentRunProgress? = nil, failOnAssessmentFailure: Bool? = nil, lastFailureMessage: String? = nil, premigrationAssessmentRunArn: String? = nil, premigrationAssessmentRunCreationDate: Date? = nil, resultEncryptionMode: String? = nil, resultKmsKeyArn: String? = nil, resultLocationBucket: String? = nil, resultLocationFolder: String? = nil, resultStatistic: ReplicationTaskAssessmentRunResultStatistic? = nil, status: String? = nil) {
            self.assessmentProgress = assessmentProgress
            self.failOnAssessmentFailure = failOnAssessmentFailure
            self.lastFailureMessage = lastFailureMessage
            self.premigrationAssessmentRunArn = premigrationAssessmentRunArn
            self.premigrationAssessmentRunCreationDate = premigrationAssessmentRunCreationDate
            self.resultEncryptionMode = resultEncryptionMode
            self.resultKmsKeyArn = resultKmsKeyArn
            self.resultLocationBucket = resultLocationBucket
            self.resultLocationFolder = resultLocationFolder
            self.resultStatistic = resultStatistic
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case assessmentProgress = "AssessmentProgress"
            case failOnAssessmentFailure = "FailOnAssessmentFailure"
            case lastFailureMessage = "LastFailureMessage"
            case premigrationAssessmentRunArn = "PremigrationAssessmentRunArn"
            case premigrationAssessmentRunCreationDate = "PremigrationAssessmentRunCreationDate"
            case resultEncryptionMode = "ResultEncryptionMode"
            case resultKmsKeyArn = "ResultKmsKeyArn"
            case resultLocationBucket = "ResultLocationBucket"
            case resultLocationFolder = "ResultLocationFolder"
            case resultStatistic = "ResultStatistic"
            case status = "Status"
        }
    }

    public struct ProvisionData: AWSDecodableShape {
        /// The timestamp when provisioning became available.
        public let dateNewProvisioningDataAvailable: Date?
        /// The timestamp when DMS provisioned replication resources.
        public let dateProvisioned: Date?
        /// Whether the new provisioning is available to the replication.
        public let isNewProvisioningAvailable: Bool?
        /// The number of capacity units the replication is using.
        public let provisionedCapacityUnits: Int?
        /// The current provisioning state
        public let provisionState: String?
        /// A message describing the reason that DMS provisioned new resources for the serverless replication.
        public let reasonForNewProvisioningData: String?

        @inlinable
        public init(dateNewProvisioningDataAvailable: Date? = nil, dateProvisioned: Date? = nil, isNewProvisioningAvailable: Bool? = nil, provisionedCapacityUnits: Int? = nil, provisionState: String? = nil, reasonForNewProvisioningData: String? = nil) {
            self.dateNewProvisioningDataAvailable = dateNewProvisioningDataAvailable
            self.dateProvisioned = dateProvisioned
            self.isNewProvisioningAvailable = isNewProvisioningAvailable
            self.provisionedCapacityUnits = provisionedCapacityUnits
            self.provisionState = provisionState
            self.reasonForNewProvisioningData = reasonForNewProvisioningData
        }

        private enum CodingKeys: String, CodingKey {
            case dateNewProvisioningDataAvailable = "DateNewProvisioningDataAvailable"
            case dateProvisioned = "DateProvisioned"
            case isNewProvisioningAvailable = "IsNewProvisioningAvailable"
            case provisionedCapacityUnits = "ProvisionedCapacityUnits"
            case provisionState = "ProvisionState"
            case reasonForNewProvisioningData = "ReasonForNewProvisioningData"
        }
    }

    public struct RdsConfiguration: AWSDecodableShape {
        /// Describes the deployment option for the recommended Amazon RDS DB instance. The deployment options include Multi-AZ and Single-AZ deployments. Valid values include "MULTI_AZ" and "SINGLE_AZ".
        public let deploymentOption: String?
        /// Describes the recommended target Amazon RDS engine edition.
        public let engineEdition: String?
        /// Describes the recommended target Amazon RDS engine version.
        public let engineVersion: String?
        /// Describes the memory on the recommended Amazon RDS DB instance that meets your requirements.
        public let instanceMemory: Double?
        /// Describes the recommended target Amazon RDS instance type.
        public let instanceType: String?
        /// Describes the number of virtual CPUs (vCPU) on the recommended Amazon RDS DB instance that meets your requirements.
        public let instanceVcpu: Double?
        /// Describes the number of I/O operations completed each second (IOPS) on the recommended Amazon RDS DB instance that meets your requirements.
        public let storageIops: Int?
        /// Describes the storage size of the recommended Amazon RDS DB instance that meets your requirements.
        public let storageSize: Int?
        /// Describes the storage type of the recommended Amazon RDS DB instance that meets your requirements. Amazon RDS provides three storage types: General Purpose SSD (also known as gp2 and gp3), Provisioned IOPS SSD (also known as io1), and magnetic (also known as standard).
        public let storageType: String?

        @inlinable
        public init(deploymentOption: String? = nil, engineEdition: String? = nil, engineVersion: String? = nil, instanceMemory: Double? = nil, instanceType: String? = nil, instanceVcpu: Double? = nil, storageIops: Int? = nil, storageSize: Int? = nil, storageType: String? = nil) {
            self.deploymentOption = deploymentOption
            self.engineEdition = engineEdition
            self.engineVersion = engineVersion
            self.instanceMemory = instanceMemory
            self.instanceType = instanceType
            self.instanceVcpu = instanceVcpu
            self.storageIops = storageIops
            self.storageSize = storageSize
            self.storageType = storageType
        }

        private enum CodingKeys: String, CodingKey {
            case deploymentOption = "DeploymentOption"
            case engineEdition = "EngineEdition"
            case engineVersion = "EngineVersion"
            case instanceMemory = "InstanceMemory"
            case instanceType = "InstanceType"
            case instanceVcpu = "InstanceVcpu"
            case storageIops = "StorageIops"
            case storageSize = "StorageSize"
            case storageType = "StorageType"
        }
    }

    public struct RdsRecommendation: AWSDecodableShape {
        /// Supplemental information about the requirements to the recommended target database on Amazon RDS.
        public let requirementsToTarget: RdsRequirements?
        /// Supplemental information about the configuration of the recommended target database on Amazon RDS.
        public let targetConfiguration: RdsConfiguration?

        @inlinable
        public init(requirementsToTarget: RdsRequirements? = nil, targetConfiguration: RdsConfiguration? = nil) {
            self.requirementsToTarget = requirementsToTarget
            self.targetConfiguration = targetConfiguration
        }

        private enum CodingKeys: String, CodingKey {
            case requirementsToTarget = "RequirementsToTarget"
            case targetConfiguration = "TargetConfiguration"
        }
    }

    public struct RdsRequirements: AWSDecodableShape {
        /// The required deployment option for the Amazon RDS DB instance. Valid values include "MULTI_AZ" for Multi-AZ deployments and "SINGLE_AZ" for Single-AZ deployments.
        public let deploymentOption: String?
        /// The required target Amazon RDS engine edition.
        public let engineEdition: String?
        /// The required target Amazon RDS engine version.
        public let engineVersion: String?
        /// The required memory on the Amazon RDS DB instance.
        public let instanceMemory: Double?
        /// The required number of virtual CPUs (vCPU) on the Amazon RDS DB instance.
        public let instanceVcpu: Double?
        /// The required number of I/O operations completed each second (IOPS) on your Amazon RDS DB instance.
        public let storageIops: Int?
        /// The required Amazon RDS DB instance storage size.
        public let storageSize: Int?

        @inlinable
        public init(deploymentOption: String? = nil, engineEdition: String? = nil, engineVersion: String? = nil, instanceMemory: Double? = nil, instanceVcpu: Double? = nil, storageIops: Int? = nil, storageSize: Int? = nil) {
            self.deploymentOption = deploymentOption
            self.engineEdition = engineEdition
            self.engineVersion = engineVersion
            self.instanceMemory = instanceMemory
            self.instanceVcpu = instanceVcpu
            self.storageIops = storageIops
            self.storageSize = storageSize
        }

        private enum CodingKeys: String, CodingKey {
            case deploymentOption = "DeploymentOption"
            case engineEdition = "EngineEdition"
            case engineVersion = "EngineVersion"
            case instanceMemory = "InstanceMemory"
            case instanceVcpu = "InstanceVcpu"
            case storageIops = "StorageIops"
            case storageSize = "StorageSize"
        }
    }

    public struct RebootReplicationInstanceMessage: AWSEncodableShape {
        /// If this parameter is true, the reboot is conducted through a Multi-AZ failover. If the instance isn't configured for Multi-AZ, then you can't specify true. ( --force-planned-failover and --force-failover can't both be set to true.)
        public let forceFailover: Bool?
        /// If this parameter is true, the reboot is conducted through a planned Multi-AZ failover where resources are released and cleaned up prior to conducting the failover. If the instance isn''t configured for Multi-AZ, then you can't specify true. ( --force-planned-failover and --force-failover can't both be set to true.)
        public let forcePlannedFailover: Bool?
        /// The Amazon Resource Name (ARN) of the replication instance.
        public let replicationInstanceArn: String

        @inlinable
        public init(forceFailover: Bool? = nil, forcePlannedFailover: Bool? = nil, replicationInstanceArn: String) {
            self.forceFailover = forceFailover
            self.forcePlannedFailover = forcePlannedFailover
            self.replicationInstanceArn = replicationInstanceArn
        }

        private enum CodingKeys: String, CodingKey {
            case forceFailover = "ForceFailover"
            case forcePlannedFailover = "ForcePlannedFailover"
            case replicationInstanceArn = "ReplicationInstanceArn"
        }
    }

    public struct RebootReplicationInstanceResponse: AWSDecodableShape {
        /// The replication instance that is being rebooted.
        public let replicationInstance: ReplicationInstance?

        @inlinable
        public init(replicationInstance: ReplicationInstance? = nil) {
            self.replicationInstance = replicationInstance
        }

        private enum CodingKeys: String, CodingKey {
            case replicationInstance = "ReplicationInstance"
        }
    }

    public struct Recommendation: AWSDecodableShape {
        /// The date when Fleet Advisor created the target engine recommendation.
        public let createdDate: String?
        /// The recommendation of a target engine for the specified source database.
        public let data: RecommendationData?
        /// The identifier of the source database for which Fleet Advisor provided this recommendation.
        public let databaseId: String?
        /// The name of the target engine. Valid values include "rds-aurora-mysql", "rds-aurora-postgresql", "rds-mysql", "rds-oracle", "rds-sql-server", and "rds-postgresql".
        public let engineName: String?
        /// Indicates that this target is the rightsized migration destination.
        public let preferred: Bool?
        /// The settings in JSON format for the preferred target engine parameters. These parameters include capacity, resource utilization, and the usage type (production, development, or testing).
        public let settings: RecommendationSettings?
        /// The status of the target engine recommendation. Valid values include "alternate", "in-progress", "not-viable", and "recommended".
        public let status: String?

        @inlinable
        public init(createdDate: String? = nil, data: RecommendationData? = nil, databaseId: String? = nil, engineName: String? = nil, preferred: Bool? = nil, settings: RecommendationSettings? = nil, status: String? = nil) {
            self.createdDate = createdDate
            self.data = data
            self.databaseId = databaseId
            self.engineName = engineName
            self.preferred = preferred
            self.settings = settings
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case createdDate = "CreatedDate"
            case data = "Data"
            case databaseId = "DatabaseId"
            case engineName = "EngineName"
            case preferred = "Preferred"
            case settings = "Settings"
            case status = "Status"
        }
    }

    public struct RecommendationData: AWSDecodableShape {
        /// The recommendation of a target Amazon RDS database engine.
        public let rdsEngine: RdsRecommendation?

        @inlinable
        public init(rdsEngine: RdsRecommendation? = nil) {
            self.rdsEngine = rdsEngine
        }

        private enum CodingKeys: String, CodingKey {
            case rdsEngine = "RdsEngine"
        }
    }

    public struct RecommendationSettings: AWSEncodableShape & AWSDecodableShape {
        /// The size of your target instance. Fleet Advisor calculates this value based on your data collection type, such as total capacity and resource utilization. Valid values include "total-capacity" and "utilization".
        public let instanceSizingType: String
        /// The deployment option for your target engine. For production databases, Fleet Advisor chooses Multi-AZ deployment. For development or test databases, Fleet Advisor chooses Single-AZ deployment. Valid values include "development" and "production".
        public let workloadType: String

        @inlinable
        public init(instanceSizingType: String, workloadType: String) {
            self.instanceSizingType = instanceSizingType
            self.workloadType = workloadType
        }

        private enum CodingKeys: String, CodingKey {
            case instanceSizingType = "InstanceSizingType"
            case workloadType = "WorkloadType"
        }
    }

    public struct RedisSettings: AWSEncodableShape & AWSDecodableShape {
        /// The password provided with the auth-role and auth-token options of the AuthType setting for a Redis target endpoint.
        public let authPassword: String?
        /// The type of authentication to perform when connecting to a Redis target. Options include none, auth-token, and auth-role. The auth-token option requires an AuthPassword value to be provided. The auth-role option requires AuthUserName and AuthPassword values to be provided.
        public let authType: RedisAuthTypeValue?
        /// The user name provided with the auth-role option of the AuthType setting for a Redis target endpoint.
        public let authUserName: String?
        /// Transmission Control Protocol (TCP) port for the endpoint.
        public let port: Int
        /// Fully qualified domain name of the endpoint.
        public let serverName: String
        /// The Amazon Resource Name (ARN) for the certificate authority (CA) that DMS uses to connect to your Redis target endpoint.
        public let sslCaCertificateArn: String?
        /// The connection to a Redis target endpoint using Transport Layer Security (TLS). Valid values include plaintext and ssl-encryption. The default is ssl-encryption. The ssl-encryption option makes an encrypted connection. Optionally, you can identify an Amazon Resource Name (ARN) for an SSL certificate authority (CA) using the SslCaCertificateArn setting. If an ARN isn't given for a CA, DMS uses the Amazon root CA. The plaintext option doesn't provide Transport Layer Security (TLS) encryption for traffic between endpoint and database.
        public let sslSecurityProtocol: SslSecurityProtocolValue?

        @inlinable
        public init(authPassword: String? = nil, authType: RedisAuthTypeValue? = nil, authUserName: String? = nil, port: Int, serverName: String, sslCaCertificateArn: String? = nil, sslSecurityProtocol: SslSecurityProtocolValue? = nil) {
            self.authPassword = authPassword
            self.authType = authType
            self.authUserName = authUserName
            self.port = port
            self.serverName = serverName
            self.sslCaCertificateArn = sslCaCertificateArn
            self.sslSecurityProtocol = sslSecurityProtocol
        }

        private enum CodingKeys: String, CodingKey {
            case authPassword = "AuthPassword"
            case authType = "AuthType"
            case authUserName = "AuthUserName"
            case port = "Port"
            case serverName = "ServerName"
            case sslCaCertificateArn = "SslCaCertificateArn"
            case sslSecurityProtocol = "SslSecurityProtocol"
        }
    }

    public struct RedshiftDataProviderSettings: AWSEncodableShape & AWSDecodableShape {
        /// The database name on the Amazon Redshift data provider.
        public let databaseName: String?
        /// The port value for the Amazon Redshift data provider.
        public let port: Int?
        /// The name of the Amazon Redshift server.
        public let serverName: String?

        @inlinable
        public init(databaseName: String? = nil, port: Int? = nil, serverName: String? = nil) {
            self.databaseName = databaseName
            self.port = port
            self.serverName = serverName
        }

        private enum CodingKeys: String, CodingKey {
            case databaseName = "DatabaseName"
            case port = "Port"
            case serverName = "ServerName"
        }
    }

    public struct RedshiftSettings: AWSEncodableShape & AWSDecodableShape {
        /// A value that indicates to allow any date format, including invalid formats such as 00/00/00 00:00:00, to be loaded without generating an error. You can choose true or false (the default). This parameter applies only to TIMESTAMP and DATE columns. Always use ACCEPTANYDATE with the DATEFORMAT parameter. If the date format for the data doesn't match the DATEFORMAT specification, Amazon Redshift inserts a NULL value into that field.
        public let acceptAnyDate: Bool?
        /// Code to run after connecting. This parameter should contain the code itself, not the name of a file containing the code.
        public let afterConnectScript: String?
        /// An S3 folder where the comma-separated-value (.csv) files are stored before being uploaded to the target Redshift cluster.  For full load mode, DMS converts source records into .csv files and loads them to the BucketFolder/TableID path. DMS uses the Redshift COPY command to upload the .csv files to the target table. The files are deleted once the COPY operation has finished. For more information, see COPY in the Amazon Redshift Database Developer Guide. For change-data-capture (CDC) mode, DMS creates a NetChanges table, and loads the .csv files to this BucketFolder/NetChangesTableID path.
        public let bucketFolder: String?
        /// The name of the intermediate S3 bucket used to store .csv files before uploading data to Redshift.
        public let bucketName: String?
        /// If Amazon Redshift is configured to support case sensitive schema names, set CaseSensitiveNames to true. The default is false.
        public let caseSensitiveNames: Bool?
        /// If you set CompUpdate to true Amazon Redshift applies automatic compression if the table is empty. This applies even if the table columns already have encodings other than RAW. If you set CompUpdate to false, automatic compression is disabled and existing column encodings aren't changed. The default is true.
        public let compUpdate: Bool?
        /// A value that sets the amount of time to wait (in milliseconds) before timing out, beginning from when you initially establish a connection.
        public let connectionTimeout: Int?
        /// The name of the Amazon Redshift data warehouse (service) that you are working with.
        public let databaseName: String?
        /// The date format that you are using. Valid values are auto (case-sensitive), your date format string enclosed in quotes, or NULL. If this parameter is left unset (NULL), it defaults to a format of 'YYYY-MM-DD'. Using auto recognizes most strings, even some that aren't supported when you use a date format string.  If your date and time values use formats different from each other, set this to auto.
        public let dateFormat: String?
        /// A value that specifies whether DMS should migrate empty CHAR and VARCHAR fields as NULL. A value of true sets empty CHAR and VARCHAR fields to null. The default is false.
        public let emptyAsNull: Bool?
        /// The type of server-side encryption that you want to use for your data. This encryption type is part of the endpoint settings or the extra connections attributes for Amazon S3. You can choose either SSE_S3 (the default) or SSE_KMS.   For the ModifyEndpoint operation, you can change the existing value of the EncryptionMode parameter from SSE_KMS to SSE_S3. But you cant change the existing value from SSE_S3 to SSE_KMS.  To use SSE_S3, create an Identity and Access Management (IAM) role with a policy that allows "arn:aws:s3:::*" to use the following actions: "s3:PutObject", "s3:ListBucket"
        public let encryptionMode: EncryptionModeValue?
        /// This setting is only valid for a full-load migration task. Set ExplicitIds to true to have tables with IDENTITY columns override their auto-generated values with explicit values loaded from the source data files used to populate the tables. The default is false.
        public let explicitIds: Bool?
        /// The number of threads used to upload a single file. This parameter accepts a value from 1 through 64. It defaults to 10. The number of parallel streams used to upload a single .csv file to an S3 bucket using S3 Multipart Upload. For more information, see Multipart upload overview.   FileTransferUploadStreams accepts a value from 1 through 64. It defaults to 10.
        public let fileTransferUploadStreams: Int?
        /// The amount of time to wait (in milliseconds) before timing out of operations performed by DMS on a Redshift cluster, such as Redshift COPY, INSERT, DELETE, and UPDATE.
        public let loadTimeout: Int?
        /// When true, lets Redshift migrate the boolean type as boolean. By default, Redshift migrates booleans as varchar(1). You must set this setting on both the source and target endpoints for it to take effect.
        public let mapBooleanAsBoolean: Bool?
        /// The maximum size (in KB) of any .csv file used to load data on an S3 bucket and transfer data to Amazon Redshift. It defaults to 1048576KB (1 GB).
        public let maxFileSize: Int?
        /// The password for the user named in the username property.
        public let password: String?
        /// The port number for Amazon Redshift. The default value is 5439.
        public let port: Int?
        /// A value that specifies to remove surrounding quotation marks from strings in the incoming data. All characters within the quotation marks, including delimiters, are retained. Choose true to remove quotation marks. The default is false.
        public let removeQuotes: Bool?
        /// A value that specifies to replaces the invalid characters specified in ReplaceInvalidChars, substituting the specified characters instead. The default is "?".
        public let replaceChars: String?
        /// A list of characters that you want to replace. Use with ReplaceChars.
        public let replaceInvalidChars: String?
        /// The full Amazon Resource Name (ARN) of the IAM role that specifies DMS as the trusted entity and grants the required permissions to access the value in SecretsManagerSecret. The role must allow the iam:PassRole action. SecretsManagerSecret has the value of the Amazon Web Services Secrets Manager secret that allows access to the Amazon Redshift endpoint.  You can specify one of two sets of values for these permissions. You can specify the values for this setting and SecretsManagerSecretId. Or you can specify clear-text values for UserName, Password, ServerName, and Port. You can't specify both. For more information on creating this SecretsManagerSecret and the SecretsManagerAccessRoleArn and SecretsManagerSecretId required to access it, see Using secrets to access Database Migration Service resources in the Database Migration Service User Guide.
        public let secretsManagerAccessRoleArn: String?
        /// The full ARN, partial ARN, or friendly name of the SecretsManagerSecret that contains the Amazon Redshift endpoint connection details.
        public let secretsManagerSecretId: String?
        /// The name of the Amazon Redshift cluster you are using.
        public let serverName: String?
        /// The KMS key ID. If you are using SSE_KMS for the EncryptionMode, provide this key ID. The key that you use needs an attached policy that enables IAM user permissions and allows use of the key.
        public let serverSideEncryptionKmsKeyId: String?
        /// The Amazon Resource Name (ARN) of the IAM role that has access to the Amazon Redshift service. The role must allow the iam:PassRole action.
        public let serviceAccessRoleArn: String?
        /// The time format that you want to use. Valid values are auto (case-sensitive), 'timeformat_string', 'epochsecs', or 'epochmillisecs'. It defaults to 10. Using auto recognizes most strings, even some that aren't supported when you use a time format string.  If your date and time values use formats different from each other, set this parameter to auto.
        public let timeFormat: String?
        /// A value that specifies to remove the trailing white space characters from a VARCHAR string. This parameter applies only to columns with a VARCHAR data type. Choose true to remove unneeded white space. The default is false.
        public let trimBlanks: Bool?
        /// A value that specifies to truncate data in columns to the appropriate number of characters, so that the data fits in the column. This parameter applies only to columns with a VARCHAR or CHAR data type, and rows with a size of 4 MB or less. Choose true to truncate data. The default is false.
        public let truncateColumns: Bool?
        /// An Amazon Redshift user name for a registered user.
        public let username: String?
        /// The size (in KB) of the in-memory file write buffer used when generating .csv files on the local disk at the DMS replication instance. The default value is 1000 (buffer size is 1000KB).
        public let writeBufferSize: Int?

        @inlinable
        public init(acceptAnyDate: Bool? = nil, afterConnectScript: String? = nil, bucketFolder: String? = nil, bucketName: String? = nil, caseSensitiveNames: Bool? = nil, compUpdate: Bool? = nil, connectionTimeout: Int? = nil, databaseName: String? = nil, dateFormat: String? = nil, emptyAsNull: Bool? = nil, encryptionMode: EncryptionModeValue? = nil, explicitIds: Bool? = nil, fileTransferUploadStreams: Int? = nil, loadTimeout: Int? = nil, mapBooleanAsBoolean: Bool? = nil, maxFileSize: Int? = nil, password: String? = nil, port: Int? = nil, removeQuotes: Bool? = nil, replaceChars: String? = nil, replaceInvalidChars: String? = nil, secretsManagerAccessRoleArn: String? = nil, secretsManagerSecretId: String? = nil, serverName: String? = nil, serverSideEncryptionKmsKeyId: String? = nil, serviceAccessRoleArn: String? = nil, timeFormat: String? = nil, trimBlanks: Bool? = nil, truncateColumns: Bool? = nil, username: String? = nil, writeBufferSize: Int? = nil) {
            self.acceptAnyDate = acceptAnyDate
            self.afterConnectScript = afterConnectScript
            self.bucketFolder = bucketFolder
            self.bucketName = bucketName
            self.caseSensitiveNames = caseSensitiveNames
            self.compUpdate = compUpdate
            self.connectionTimeout = connectionTimeout
            self.databaseName = databaseName
            self.dateFormat = dateFormat
            self.emptyAsNull = emptyAsNull
            self.encryptionMode = encryptionMode
            self.explicitIds = explicitIds
            self.fileTransferUploadStreams = fileTransferUploadStreams
            self.loadTimeout = loadTimeout
            self.mapBooleanAsBoolean = mapBooleanAsBoolean
            self.maxFileSize = maxFileSize
            self.password = password
            self.port = port
            self.removeQuotes = removeQuotes
            self.replaceChars = replaceChars
            self.replaceInvalidChars = replaceInvalidChars
            self.secretsManagerAccessRoleArn = secretsManagerAccessRoleArn
            self.secretsManagerSecretId = secretsManagerSecretId
            self.serverName = serverName
            self.serverSideEncryptionKmsKeyId = serverSideEncryptionKmsKeyId
            self.serviceAccessRoleArn = serviceAccessRoleArn
            self.timeFormat = timeFormat
            self.trimBlanks = trimBlanks
            self.truncateColumns = truncateColumns
            self.username = username
            self.writeBufferSize = writeBufferSize
        }

        private enum CodingKeys: String, CodingKey {
            case acceptAnyDate = "AcceptAnyDate"
            case afterConnectScript = "AfterConnectScript"
            case bucketFolder = "BucketFolder"
            case bucketName = "BucketName"
            case caseSensitiveNames = "CaseSensitiveNames"
            case compUpdate = "CompUpdate"
            case connectionTimeout = "ConnectionTimeout"
            case databaseName = "DatabaseName"
            case dateFormat = "DateFormat"
            case emptyAsNull = "EmptyAsNull"
            case encryptionMode = "EncryptionMode"
            case explicitIds = "ExplicitIds"
            case fileTransferUploadStreams = "FileTransferUploadStreams"
            case loadTimeout = "LoadTimeout"
            case mapBooleanAsBoolean = "MapBooleanAsBoolean"
            case maxFileSize = "MaxFileSize"
            case password = "Password"
            case port = "Port"
            case removeQuotes = "RemoveQuotes"
            case replaceChars = "ReplaceChars"
            case replaceInvalidChars = "ReplaceInvalidChars"
            case secretsManagerAccessRoleArn = "SecretsManagerAccessRoleArn"
            case secretsManagerSecretId = "SecretsManagerSecretId"
            case serverName = "ServerName"
            case serverSideEncryptionKmsKeyId = "ServerSideEncryptionKmsKeyId"
            case serviceAccessRoleArn = "ServiceAccessRoleArn"
            case timeFormat = "TimeFormat"
            case trimBlanks = "TrimBlanks"
            case truncateColumns = "TruncateColumns"
            case username = "Username"
            case writeBufferSize = "WriteBufferSize"
        }
    }

    public struct RefreshSchemasMessage: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) string that uniquely identifies the endpoint.
        public let endpointArn: String
        /// The Amazon Resource Name (ARN) of the replication instance.
        public let replicationInstanceArn: String

        @inlinable
        public init(endpointArn: String, replicationInstanceArn: String) {
            self.endpointArn = endpointArn
            self.replicationInstanceArn = replicationInstanceArn
        }

        private enum CodingKeys: String, CodingKey {
            case endpointArn = "EndpointArn"
            case replicationInstanceArn = "ReplicationInstanceArn"
        }
    }

    public struct RefreshSchemasResponse: AWSDecodableShape {
        /// The status of the refreshed schema.
        public let refreshSchemasStatus: RefreshSchemasStatus?

        @inlinable
        public init(refreshSchemasStatus: RefreshSchemasStatus? = nil) {
            self.refreshSchemasStatus = refreshSchemasStatus
        }

        private enum CodingKeys: String, CodingKey {
            case refreshSchemasStatus = "RefreshSchemasStatus"
        }
    }

    public struct RefreshSchemasStatus: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) string that uniquely identifies the endpoint.
        public let endpointArn: String?
        /// The last failure message for the schema.
        public let lastFailureMessage: String?
        /// The date the schema was last refreshed.
        public let lastRefreshDate: Date?
        /// The Amazon Resource Name (ARN) of the replication instance.
        public let replicationInstanceArn: String?
        /// The status of the schema.
        public let status: RefreshSchemasStatusTypeValue?

        @inlinable
        public init(endpointArn: String? = nil, lastFailureMessage: String? = nil, lastRefreshDate: Date? = nil, replicationInstanceArn: String? = nil, status: RefreshSchemasStatusTypeValue? = nil) {
            self.endpointArn = endpointArn
            self.lastFailureMessage = lastFailureMessage
            self.lastRefreshDate = lastRefreshDate
            self.replicationInstanceArn = replicationInstanceArn
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case endpointArn = "EndpointArn"
            case lastFailureMessage = "LastFailureMessage"
            case lastRefreshDate = "LastRefreshDate"
            case replicationInstanceArn = "ReplicationInstanceArn"
            case status = "Status"
        }
    }

    public struct ReloadReplicationTablesMessage: AWSEncodableShape {
        /// Options for reload. Specify data-reload to reload the data and re-validate it if validation is enabled. Specify validate-only to re-validate the table. This option applies only when validation is enabled for the replication.
        public let reloadOption: ReloadOptionValue?
        /// The Amazon Resource Name of the replication config for which to reload tables.
        public let replicationConfigArn: String
        /// The list of tables to reload.
        public let tablesToReload: [TableToReload]

        @inlinable
        public init(reloadOption: ReloadOptionValue? = nil, replicationConfigArn: String, tablesToReload: [TableToReload]) {
            self.reloadOption = reloadOption
            self.replicationConfigArn = replicationConfigArn
            self.tablesToReload = tablesToReload
        }

        private enum CodingKeys: String, CodingKey {
            case reloadOption = "ReloadOption"
            case replicationConfigArn = "ReplicationConfigArn"
            case tablesToReload = "TablesToReload"
        }
    }

    public struct ReloadReplicationTablesResponse: AWSDecodableShape {
        /// The Amazon Resource Name of the replication config for which to reload tables.
        public let replicationConfigArn: String?

        @inlinable
        public init(replicationConfigArn: String? = nil) {
            self.replicationConfigArn = replicationConfigArn
        }

        private enum CodingKeys: String, CodingKey {
            case replicationConfigArn = "ReplicationConfigArn"
        }
    }

    public struct ReloadTablesMessage: AWSEncodableShape {
        /// Options for reload. Specify data-reload to reload the data and re-validate it if validation is enabled. Specify validate-only to re-validate the table. This option applies only when validation is enabled for the task.  Valid values: data-reload, validate-only Default value is data-reload.
        public let reloadOption: ReloadOptionValue?
        /// The Amazon Resource Name (ARN) of the replication task.
        public let replicationTaskArn: String
        /// The name and schema of the table to be reloaded.
        public let tablesToReload: [TableToReload]

        @inlinable
        public init(reloadOption: ReloadOptionValue? = nil, replicationTaskArn: String, tablesToReload: [TableToReload]) {
            self.reloadOption = reloadOption
            self.replicationTaskArn = replicationTaskArn
            self.tablesToReload = tablesToReload
        }

        private enum CodingKeys: String, CodingKey {
            case reloadOption = "ReloadOption"
            case replicationTaskArn = "ReplicationTaskArn"
            case tablesToReload = "TablesToReload"
        }
    }

    public struct ReloadTablesResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the replication task.
        public let replicationTaskArn: String?

        @inlinable
        public init(replicationTaskArn: String? = nil) {
            self.replicationTaskArn = replicationTaskArn
        }

        private enum CodingKeys: String, CodingKey {
            case replicationTaskArn = "ReplicationTaskArn"
        }
    }

    public struct RemoveTagsFromResourceMessage: AWSEncodableShape {
        /// An DMS resource from which you want to remove tag(s). The value for this parameter is an Amazon Resource Name (ARN).
        public let resourceArn: String
        /// The tag key (name) of the tag to be removed.
        public let tagKeys: [String]

        @inlinable
        public init(resourceArn: String, tagKeys: [String]) {
            self.resourceArn = resourceArn
            self.tagKeys = tagKeys
        }

        private enum CodingKeys: String, CodingKey {
            case resourceArn = "ResourceArn"
            case tagKeys = "TagKeys"
        }
    }

    public struct RemoveTagsFromResourceResponse: AWSDecodableShape {
        public init() {}
    }

    public struct Replication: AWSDecodableShape {
        /// Indicates the start time for a change data capture (CDC) operation. Use either CdcStartTime or CdcStartPosition to specify when you want a CDC operation to start. Specifying both values results in an error.
        public let cdcStartPosition: String?
        /// Indicates the start time for a change data capture (CDC) operation. Use either CdcStartTime or CdcStartPosition to specify when you want a CDC operation to start. Specifying both values results in an error.
        public let cdcStartTime: Date?
        /// Indicates when you want a change data capture (CDC) operation to stop. The value can be either server time or commit time.
        public let cdcStopPosition: String?
        /// Error and other information about why a serverless replication failed.
        public let failureMessages: [String]?
        /// The status output of premigration assessment in describe-replications.
        public let premigrationAssessmentStatuses: [PremigrationAssessmentStatus]?
        /// Information about provisioning resources for an DMS serverless replication.
        public let provisionData: ProvisionData?
        /// Indicates the last checkpoint that occurred during a change data capture (CDC) operation. You can provide this value to the CdcStartPosition parameter to start a CDC operation that begins at that checkpoint.
        public let recoveryCheckpoint: String?
        /// The Amazon Resource Name for the ReplicationConfig associated with the replication.
        public let replicationConfigArn: String?
        /// The identifier for the ReplicationConfig associated with the replication.
        public let replicationConfigIdentifier: String?
        /// The time the serverless replication was created.
        public let replicationCreateTime: Date?
        /// The timestamp when DMS will deprovision the replication.
        public let replicationDeprovisionTime: Date?
        /// The timestamp when replication was last stopped.
        public let replicationLastStopTime: Date?
        /// This object provides a collection of statistics about a serverless replication.
        public let replicationStats: ReplicationStats?
        /// The type of the serverless replication.
        public let replicationType: MigrationTypeValue?
        /// The time the serverless replication was updated.
        public let replicationUpdateTime: Date?
        /// The Amazon Resource Name for an existing Endpoint the serverless replication uses for its data source.
        public let sourceEndpointArn: String?
        /// The type of replication to start.
        public let startReplicationType: String?
        /// The current status of the serverless replication.
        public let status: String?
        /// The reason the replication task was stopped. This response parameter can return one of the following values:    "Stop Reason NORMAL"     "Stop Reason RECOVERABLE_ERROR"     "Stop Reason FATAL_ERROR"     "Stop Reason FULL_LOAD_ONLY_FINISHED"     "Stop Reason STOPPED_AFTER_FULL_LOAD"  Full load completed, with cached changes not applied    "Stop Reason STOPPED_AFTER_CACHED_EVENTS"  Full load completed, with cached changes applied    "Stop Reason EXPRESS_LICENSE_LIMITS_REACHED"     "Stop Reason STOPPED_AFTER_DDL_APPLY"  User-defined stop task after DDL applied    "Stop Reason STOPPED_DUE_TO_LOW_MEMORY"     "Stop Reason STOPPED_DUE_TO_LOW_DISK"     "Stop Reason STOPPED_AT_SERVER_TIME"  User-defined server time for stopping task    "Stop Reason STOPPED_AT_COMMIT_TIME"  User-defined commit time for stopping task    "Stop Reason RECONFIGURATION_RESTART"     "Stop Reason RECYCLE_TASK"
        public let stopReason: String?
        /// The Amazon Resource Name for an existing Endpoint the serverless replication uses for its data target.
        public let targetEndpointArn: String?

        @inlinable
        public init(cdcStartPosition: String? = nil, cdcStartTime: Date? = nil, cdcStopPosition: String? = nil, failureMessages: [String]? = nil, premigrationAssessmentStatuses: [PremigrationAssessmentStatus]? = nil, provisionData: ProvisionData? = nil, recoveryCheckpoint: String? = nil, replicationConfigArn: String? = nil, replicationConfigIdentifier: String? = nil, replicationCreateTime: Date? = nil, replicationDeprovisionTime: Date? = nil, replicationLastStopTime: Date? = nil, replicationStats: ReplicationStats? = nil, replicationType: MigrationTypeValue? = nil, replicationUpdateTime: Date? = nil, sourceEndpointArn: String? = nil, startReplicationType: String? = nil, status: String? = nil, stopReason: String? = nil, targetEndpointArn: String? = nil) {
            self.cdcStartPosition = cdcStartPosition
            self.cdcStartTime = cdcStartTime
            self.cdcStopPosition = cdcStopPosition
            self.failureMessages = failureMessages
            self.premigrationAssessmentStatuses = premigrationAssessmentStatuses
            self.provisionData = provisionData
            self.recoveryCheckpoint = recoveryCheckpoint
            self.replicationConfigArn = replicationConfigArn
            self.replicationConfigIdentifier = replicationConfigIdentifier
            self.replicationCreateTime = replicationCreateTime
            self.replicationDeprovisionTime = replicationDeprovisionTime
            self.replicationLastStopTime = replicationLastStopTime
            self.replicationStats = replicationStats
            self.replicationType = replicationType
            self.replicationUpdateTime = replicationUpdateTime
            self.sourceEndpointArn = sourceEndpointArn
            self.startReplicationType = startReplicationType
            self.status = status
            self.stopReason = stopReason
            self.targetEndpointArn = targetEndpointArn
        }

        private enum CodingKeys: String, CodingKey {
            case cdcStartPosition = "CdcStartPosition"
            case cdcStartTime = "CdcStartTime"
            case cdcStopPosition = "CdcStopPosition"
            case failureMessages = "FailureMessages"
            case premigrationAssessmentStatuses = "PremigrationAssessmentStatuses"
            case provisionData = "ProvisionData"
            case recoveryCheckpoint = "RecoveryCheckpoint"
            case replicationConfigArn = "ReplicationConfigArn"
            case replicationConfigIdentifier = "ReplicationConfigIdentifier"
            case replicationCreateTime = "ReplicationCreateTime"
            case replicationDeprovisionTime = "ReplicationDeprovisionTime"
            case replicationLastStopTime = "ReplicationLastStopTime"
            case replicationStats = "ReplicationStats"
            case replicationType = "ReplicationType"
            case replicationUpdateTime = "ReplicationUpdateTime"
            case sourceEndpointArn = "SourceEndpointArn"
            case startReplicationType = "StartReplicationType"
            case status = "Status"
            case stopReason = "StopReason"
            case targetEndpointArn = "TargetEndpointArn"
        }
    }

    public struct ReplicationConfig: AWSDecodableShape {
        /// Configuration parameters for provisioning an DMS serverless replication.
        public let computeConfig: ComputeConfig?
        /// The Amazon Resource Name (ARN) of this DMS Serverless replication configuration.
        public let replicationConfigArn: String?
        /// The time the serverless replication config was created.
        public let replicationConfigCreateTime: Date?
        /// The identifier for the ReplicationConfig associated with the replication.
        public let replicationConfigIdentifier: String?
        /// The time the serverless replication config was updated.
        public let replicationConfigUpdateTime: Date?
        /// Configuration parameters for an DMS serverless replication.
        public let replicationSettings: String?
        /// The type of the replication.
        public let replicationType: MigrationTypeValue?
        /// The Amazon Resource Name (ARN) of the source endpoint for this DMS serverless replication configuration.
        public let sourceEndpointArn: String?
        /// Additional parameters for an DMS serverless replication.
        public let supplementalSettings: String?
        /// Table mappings specified in the replication.
        public let tableMappings: String?
        /// The Amazon Resource Name (ARN) of the target endpoint for this DMS serverless replication configuration.
        public let targetEndpointArn: String?

        @inlinable
        public init(computeConfig: ComputeConfig? = nil, replicationConfigArn: String? = nil, replicationConfigCreateTime: Date? = nil, replicationConfigIdentifier: String? = nil, replicationConfigUpdateTime: Date? = nil, replicationSettings: String? = nil, replicationType: MigrationTypeValue? = nil, sourceEndpointArn: String? = nil, supplementalSettings: String? = nil, tableMappings: String? = nil, targetEndpointArn: String? = nil) {
            self.computeConfig = computeConfig
            self.replicationConfigArn = replicationConfigArn
            self.replicationConfigCreateTime = replicationConfigCreateTime
            self.replicationConfigIdentifier = replicationConfigIdentifier
            self.replicationConfigUpdateTime = replicationConfigUpdateTime
            self.replicationSettings = replicationSettings
            self.replicationType = replicationType
            self.sourceEndpointArn = sourceEndpointArn
            self.supplementalSettings = supplementalSettings
            self.tableMappings = tableMappings
            self.targetEndpointArn = targetEndpointArn
        }

        private enum CodingKeys: String, CodingKey {
            case computeConfig = "ComputeConfig"
            case replicationConfigArn = "ReplicationConfigArn"
            case replicationConfigCreateTime = "ReplicationConfigCreateTime"
            case replicationConfigIdentifier = "ReplicationConfigIdentifier"
            case replicationConfigUpdateTime = "ReplicationConfigUpdateTime"
            case replicationSettings = "ReplicationSettings"
            case replicationType = "ReplicationType"
            case sourceEndpointArn = "SourceEndpointArn"
            case supplementalSettings = "SupplementalSettings"
            case tableMappings = "TableMappings"
            case targetEndpointArn = "TargetEndpointArn"
        }
    }

    public struct ReplicationInstance: AWSDecodableShape {
        /// The amount of storage (in gigabytes) that is allocated for the replication instance.
        public let allocatedStorage: Int?
        /// Boolean value indicating if minor version upgrades will be automatically applied to the instance.
        public let autoMinorVersionUpgrade: Bool?
        /// The Availability Zone for the instance.
        public let availabilityZone: String?
        /// The DNS name servers supported for the replication instance to access your on-premise source or target database.
        public let dnsNameServers: String?
        /// The engine version number of the replication instance. If an engine version number is not specified when a replication instance is created, the default is the latest engine version available. When modifying a major engine version of an instance, also set AllowMajorVersionUpgrade to true.
        public let engineVersion: String?
        ///  The expiration date of the free replication instance that is part of the Free DMS program.
        public let freeUntil: Date?
        /// The time the replication instance was created.
        public let instanceCreateTime: Date?
        /// Specifies the settings required for kerberos authentication when replicating an instance.
        public let kerberosAuthenticationSettings: KerberosAuthenticationSettings?
        /// An KMS key identifier that is used to encrypt the data on the replication instance. If you don't specify a value for the KmsKeyId parameter, then DMS uses your default encryption key. KMS creates the default encryption key for your Amazon Web Services account. Your Amazon Web Services account has a different default encryption key for each Amazon Web Services Region.
        public let kmsKeyId: String?
        ///  Specifies whether the replication instance is a Multi-AZ deployment. You can't set the AvailabilityZone parameter if the Multi-AZ parameter is set to true.
        public let multiAZ: Bool?
        /// The type of IP address protocol used by a replication instance, such as IPv4 only or Dual-stack that supports both IPv4 and IPv6 addressing. IPv6 only is not yet supported.
        public let networkType: String?
        /// The pending modification values.
        public let pendingModifiedValues: ReplicationPendingModifiedValues?
        /// The maintenance window times for the replication instance. Any pending upgrades to the replication instance are performed during this time.
        public let preferredMaintenanceWindow: String?
        ///  Specifies the accessibility options for the replication instance. A value of true represents an instance with a public IP address. A value of false represents an instance with a private IP address. The default value is true.
        public let publiclyAccessible: Bool?
        /// The Amazon Resource Name (ARN) of the replication instance.
        public let replicationInstanceArn: String?
        /// The compute and memory capacity of the replication instance as defined for the specified replication instance class. It is a required parameter, although a default value is pre-selected in the DMS console. For more information on the settings and capacities for the available replication instance classes, see  Selecting the right DMS replication instance for your migration.
        public let replicationInstanceClass: String?
        /// The replication instance identifier is a required parameter. This parameter is stored as a lowercase string. Constraints:   Must contain 1-63 alphanumeric characters or hyphens.   First character must be a letter.   Cannot end with a hyphen or contain two consecutive hyphens.   Example: myrepinstance
        public let replicationInstanceIdentifier: String?
        /// One or more IPv6 addresses for the replication instance.
        public let replicationInstanceIpv6Addresses: [String]?
        /// The private IP address of the replication instance.
        public let replicationInstancePrivateIpAddress: String?
        /// One or more private IP addresses for the replication instance.
        public let replicationInstancePrivateIpAddresses: [String]?
        /// The public IP address of the replication instance.
        public let replicationInstancePublicIpAddress: String?
        /// One or more public IP addresses for the replication instance.
        public let replicationInstancePublicIpAddresses: [String]?
        /// The status of the replication instance. The possible return values include:    "available"     "creating"     "deleted"     "deleting"     "failed"     "modifying"     "upgrading"     "rebooting"     "resetting-master-credentials"     "storage-full"     "incompatible-credentials"     "incompatible-network"     "maintenance"
        public let replicationInstanceStatus: String?
        /// The subnet group for the replication instance.
        public let replicationSubnetGroup: ReplicationSubnetGroup?
        /// The Availability Zone of the standby replication instance in a Multi-AZ deployment.
        public let secondaryAvailabilityZone: String?
        /// The VPC security group for the instance.
        public let vpcSecurityGroups: [VpcSecurityGroupMembership]?

        @inlinable
        public init(allocatedStorage: Int? = nil, autoMinorVersionUpgrade: Bool? = nil, availabilityZone: String? = nil, dnsNameServers: String? = nil, engineVersion: String? = nil, freeUntil: Date? = nil, instanceCreateTime: Date? = nil, kerberosAuthenticationSettings: KerberosAuthenticationSettings? = nil, kmsKeyId: String? = nil, multiAZ: Bool? = nil, networkType: String? = nil, pendingModifiedValues: ReplicationPendingModifiedValues? = nil, preferredMaintenanceWindow: String? = nil, publiclyAccessible: Bool? = nil, replicationInstanceArn: String? = nil, replicationInstanceClass: String? = nil, replicationInstanceIdentifier: String? = nil, replicationInstanceIpv6Addresses: [String]? = nil, replicationInstancePrivateIpAddresses: [String]? = nil, replicationInstancePublicIpAddresses: [String]? = nil, replicationInstanceStatus: String? = nil, replicationSubnetGroup: ReplicationSubnetGroup? = nil, secondaryAvailabilityZone: String? = nil, vpcSecurityGroups: [VpcSecurityGroupMembership]? = nil) {
            self.allocatedStorage = allocatedStorage
            self.autoMinorVersionUpgrade = autoMinorVersionUpgrade
            self.availabilityZone = availabilityZone
            self.dnsNameServers = dnsNameServers
            self.engineVersion = engineVersion
            self.freeUntil = freeUntil
            self.instanceCreateTime = instanceCreateTime
            self.kerberosAuthenticationSettings = kerberosAuthenticationSettings
            self.kmsKeyId = kmsKeyId
            self.multiAZ = multiAZ
            self.networkType = networkType
            self.pendingModifiedValues = pendingModifiedValues
            self.preferredMaintenanceWindow = preferredMaintenanceWindow
            self.publiclyAccessible = publiclyAccessible
            self.replicationInstanceArn = replicationInstanceArn
            self.replicationInstanceClass = replicationInstanceClass
            self.replicationInstanceIdentifier = replicationInstanceIdentifier
            self.replicationInstanceIpv6Addresses = replicationInstanceIpv6Addresses
            self.replicationInstancePrivateIpAddress = nil
            self.replicationInstancePrivateIpAddresses = replicationInstancePrivateIpAddresses
            self.replicationInstancePublicIpAddress = nil
            self.replicationInstancePublicIpAddresses = replicationInstancePublicIpAddresses
            self.replicationInstanceStatus = replicationInstanceStatus
            self.replicationSubnetGroup = replicationSubnetGroup
            self.secondaryAvailabilityZone = secondaryAvailabilityZone
            self.vpcSecurityGroups = vpcSecurityGroups
        }

        @available(*, deprecated, message: "Members replicationInstancePrivateIpAddress, replicationInstancePublicIpAddress have been deprecated")
        @inlinable
        public init(allocatedStorage: Int? = nil, autoMinorVersionUpgrade: Bool? = nil, availabilityZone: String? = nil, dnsNameServers: String? = nil, engineVersion: String? = nil, freeUntil: Date? = nil, instanceCreateTime: Date? = nil, kerberosAuthenticationSettings: KerberosAuthenticationSettings? = nil, kmsKeyId: String? = nil, multiAZ: Bool? = nil, networkType: String? = nil, pendingModifiedValues: ReplicationPendingModifiedValues? = nil, preferredMaintenanceWindow: String? = nil, publiclyAccessible: Bool? = nil, replicationInstanceArn: String? = nil, replicationInstanceClass: String? = nil, replicationInstanceIdentifier: String? = nil, replicationInstanceIpv6Addresses: [String]? = nil, replicationInstancePrivateIpAddress: String? = nil, replicationInstancePrivateIpAddresses: [String]? = nil, replicationInstancePublicIpAddress: String? = nil, replicationInstancePublicIpAddresses: [String]? = nil, replicationInstanceStatus: String? = nil, replicationSubnetGroup: ReplicationSubnetGroup? = nil, secondaryAvailabilityZone: String? = nil, vpcSecurityGroups: [VpcSecurityGroupMembership]? = nil) {
            self.allocatedStorage = allocatedStorage
            self.autoMinorVersionUpgrade = autoMinorVersionUpgrade
            self.availabilityZone = availabilityZone
            self.dnsNameServers = dnsNameServers
            self.engineVersion = engineVersion
            self.freeUntil = freeUntil
            self.instanceCreateTime = instanceCreateTime
            self.kerberosAuthenticationSettings = kerberosAuthenticationSettings
            self.kmsKeyId = kmsKeyId
            self.multiAZ = multiAZ
            self.networkType = networkType
            self.pendingModifiedValues = pendingModifiedValues
            self.preferredMaintenanceWindow = preferredMaintenanceWindow
            self.publiclyAccessible = publiclyAccessible
            self.replicationInstanceArn = replicationInstanceArn
            self.replicationInstanceClass = replicationInstanceClass
            self.replicationInstanceIdentifier = replicationInstanceIdentifier
            self.replicationInstanceIpv6Addresses = replicationInstanceIpv6Addresses
            self.replicationInstancePrivateIpAddress = replicationInstancePrivateIpAddress
            self.replicationInstancePrivateIpAddresses = replicationInstancePrivateIpAddresses
            self.replicationInstancePublicIpAddress = replicationInstancePublicIpAddress
            self.replicationInstancePublicIpAddresses = replicationInstancePublicIpAddresses
            self.replicationInstanceStatus = replicationInstanceStatus
            self.replicationSubnetGroup = replicationSubnetGroup
            self.secondaryAvailabilityZone = secondaryAvailabilityZone
            self.vpcSecurityGroups = vpcSecurityGroups
        }

        private enum CodingKeys: String, CodingKey {
            case allocatedStorage = "AllocatedStorage"
            case autoMinorVersionUpgrade = "AutoMinorVersionUpgrade"
            case availabilityZone = "AvailabilityZone"
            case dnsNameServers = "DnsNameServers"
            case engineVersion = "EngineVersion"
            case freeUntil = "FreeUntil"
            case instanceCreateTime = "InstanceCreateTime"
            case kerberosAuthenticationSettings = "KerberosAuthenticationSettings"
            case kmsKeyId = "KmsKeyId"
            case multiAZ = "MultiAZ"
            case networkType = "NetworkType"
            case pendingModifiedValues = "PendingModifiedValues"
            case preferredMaintenanceWindow = "PreferredMaintenanceWindow"
            case publiclyAccessible = "PubliclyAccessible"
            case replicationInstanceArn = "ReplicationInstanceArn"
            case replicationInstanceClass = "ReplicationInstanceClass"
            case replicationInstanceIdentifier = "ReplicationInstanceIdentifier"
            case replicationInstanceIpv6Addresses = "ReplicationInstanceIpv6Addresses"
            case replicationInstancePrivateIpAddress = "ReplicationInstancePrivateIpAddress"
            case replicationInstancePrivateIpAddresses = "ReplicationInstancePrivateIpAddresses"
            case replicationInstancePublicIpAddress = "ReplicationInstancePublicIpAddress"
            case replicationInstancePublicIpAddresses = "ReplicationInstancePublicIpAddresses"
            case replicationInstanceStatus = "ReplicationInstanceStatus"
            case replicationSubnetGroup = "ReplicationSubnetGroup"
            case secondaryAvailabilityZone = "SecondaryAvailabilityZone"
            case vpcSecurityGroups = "VpcSecurityGroups"
        }
    }

    public struct ReplicationInstanceTaskLog: AWSDecodableShape {
        /// The size, in bytes, of the replication task log.
        public let replicationInstanceTaskLogSize: Int64?
        /// The Amazon Resource Name (ARN) of the replication task.
        public let replicationTaskArn: String?
        /// The name of the replication task.
        public let replicationTaskName: String?

        @inlinable
        public init(replicationInstanceTaskLogSize: Int64? = nil, replicationTaskArn: String? = nil, replicationTaskName: String? = nil) {
            self.replicationInstanceTaskLogSize = replicationInstanceTaskLogSize
            self.replicationTaskArn = replicationTaskArn
            self.replicationTaskName = replicationTaskName
        }

        private enum CodingKeys: String, CodingKey {
            case replicationInstanceTaskLogSize = "ReplicationInstanceTaskLogSize"
            case replicationTaskArn = "ReplicationTaskArn"
            case replicationTaskName = "ReplicationTaskName"
        }
    }

    public struct ReplicationPendingModifiedValues: AWSDecodableShape {
        /// The amount of storage (in gigabytes) that is allocated for the replication instance.
        public let allocatedStorage: Int?
        /// The engine version number of the replication instance.
        public let engineVersion: String?
        ///  Specifies whether the replication instance is a Multi-AZ deployment. You can't set the AvailabilityZone parameter if the Multi-AZ parameter is set to true.
        public let multiAZ: Bool?
        /// The type of IP address protocol used by a replication instance, such as IPv4 only or Dual-stack that supports both IPv4 and IPv6 addressing. IPv6 only is not yet supported.
        public let networkType: String?
        /// The compute and memory capacity of the replication instance as defined for the specified replication instance class. For more information on the settings and capacities for the available replication instance classes, see  Selecting the right DMS replication instance for your migration.
        public let replicationInstanceClass: String?

        @inlinable
        public init(allocatedStorage: Int? = nil, engineVersion: String? = nil, multiAZ: Bool? = nil, networkType: String? = nil, replicationInstanceClass: String? = nil) {
            self.allocatedStorage = allocatedStorage
            self.engineVersion = engineVersion
            self.multiAZ = multiAZ
            self.networkType = networkType
            self.replicationInstanceClass = replicationInstanceClass
        }

        private enum CodingKeys: String, CodingKey {
            case allocatedStorage = "AllocatedStorage"
            case engineVersion = "EngineVersion"
            case multiAZ = "MultiAZ"
            case networkType = "NetworkType"
            case replicationInstanceClass = "ReplicationInstanceClass"
        }
    }

    public struct ReplicationStats: AWSDecodableShape {
        /// The elapsed time of the replication, in milliseconds.
        public let elapsedTimeMillis: Int64?
        /// The date the replication was started either with a fresh start or a target reload.
        public let freshStartDate: Date?
        /// The date the replication full load was finished.
        public let fullLoadFinishDate: Date?
        /// The percent complete for the full load serverless replication.
        public let fullLoadProgressPercent: Int?
        /// The date the replication full load was started.
        public let fullLoadStartDate: Date?
        /// The date the replication is scheduled to start.
        public let startDate: Date?
        /// The date the replication was stopped.
        public let stopDate: Date?
        /// The number of errors that have occured for this replication.
        public let tablesErrored: Int?
        /// The number of tables loaded for this replication.
        public let tablesLoaded: Int?
        /// The number of tables currently loading for this replication.
        public let tablesLoading: Int?
        /// The number of tables queued for this replication.
        public let tablesQueued: Int?

        @inlinable
        public init(elapsedTimeMillis: Int64? = nil, freshStartDate: Date? = nil, fullLoadFinishDate: Date? = nil, fullLoadProgressPercent: Int? = nil, fullLoadStartDate: Date? = nil, startDate: Date? = nil, stopDate: Date? = nil, tablesErrored: Int? = nil, tablesLoaded: Int? = nil, tablesLoading: Int? = nil, tablesQueued: Int? = nil) {
            self.elapsedTimeMillis = elapsedTimeMillis
            self.freshStartDate = freshStartDate
            self.fullLoadFinishDate = fullLoadFinishDate
            self.fullLoadProgressPercent = fullLoadProgressPercent
            self.fullLoadStartDate = fullLoadStartDate
            self.startDate = startDate
            self.stopDate = stopDate
            self.tablesErrored = tablesErrored
            self.tablesLoaded = tablesLoaded
            self.tablesLoading = tablesLoading
            self.tablesQueued = tablesQueued
        }

        private enum CodingKeys: String, CodingKey {
            case elapsedTimeMillis = "ElapsedTimeMillis"
            case freshStartDate = "FreshStartDate"
            case fullLoadFinishDate = "FullLoadFinishDate"
            case fullLoadProgressPercent = "FullLoadProgressPercent"
            case fullLoadStartDate = "FullLoadStartDate"
            case startDate = "StartDate"
            case stopDate = "StopDate"
            case tablesErrored = "TablesErrored"
            case tablesLoaded = "TablesLoaded"
            case tablesLoading = "TablesLoading"
            case tablesQueued = "TablesQueued"
        }
    }

    public struct ReplicationSubnetGroup: AWSDecodableShape {
        /// A description for the replication subnet group.
        public let replicationSubnetGroupDescription: String?
        /// The identifier of the replication instance subnet group.
        public let replicationSubnetGroupIdentifier: String?
        /// The status of the subnet group.
        public let subnetGroupStatus: String?
        /// The subnets that are in the subnet group.
        public let subnets: [Subnet]?
        /// The IP addressing protocol supported by the subnet group. This is used by a replication instance with values such as IPv4 only or Dual-stack that supports both IPv4 and IPv6 addressing. IPv6 only is not yet supported.
        public let supportedNetworkTypes: [String]?
        /// The ID of the VPC.
        public let vpcId: String?

        @inlinable
        public init(replicationSubnetGroupDescription: String? = nil, replicationSubnetGroupIdentifier: String? = nil, subnetGroupStatus: String? = nil, subnets: [Subnet]? = nil, supportedNetworkTypes: [String]? = nil, vpcId: String? = nil) {
            self.replicationSubnetGroupDescription = replicationSubnetGroupDescription
            self.replicationSubnetGroupIdentifier = replicationSubnetGroupIdentifier
            self.subnetGroupStatus = subnetGroupStatus
            self.subnets = subnets
            self.supportedNetworkTypes = supportedNetworkTypes
            self.vpcId = vpcId
        }

        private enum CodingKeys: String, CodingKey {
            case replicationSubnetGroupDescription = "ReplicationSubnetGroupDescription"
            case replicationSubnetGroupIdentifier = "ReplicationSubnetGroupIdentifier"
            case subnetGroupStatus = "SubnetGroupStatus"
            case subnets = "Subnets"
            case supportedNetworkTypes = "SupportedNetworkTypes"
            case vpcId = "VpcId"
        }
    }

    public struct ReplicationTask: AWSDecodableShape {
        /// Indicates when you want a change data capture (CDC) operation to start. Use either CdcStartPosition or CdcStartTime to specify when you want the CDC operation to start. Specifying both values results in an error. The value can be in date, checkpoint, or LSN/SCN format. Date Example: --cdc-start-position 2018-03-08T12:12:12 Checkpoint Example: --cdc-start-position "checkpoint:V1#27#mysql-bin-changelog.157832:1975:-1:2002:677883278264080:mysql-bin-changelog.157832:1876#0#0#*#0#93" LSN Example: --cdc-start-position mysql-bin-changelog.000024:373
        public let cdcStartPosition: String?
        /// Indicates when you want a change data capture (CDC) operation to stop. The value can be either server time or commit time. Server time example: --cdc-stop-position server_time:2018-02-09T12:12:12 Commit time example: --cdc-stop-position commit_time:2018-02-09T12:12:12
        public let cdcStopPosition: String?
        /// The last error (failure) message generated for the replication task.
        public let lastFailureMessage: String?
        /// The type of migration.
        public let migrationType: MigrationTypeValue?
        /// Indicates the last checkpoint that occurred during a change data capture (CDC) operation. You can provide this value to the CdcStartPosition parameter to start a CDC operation that begins at that checkpoint.
        public let recoveryCheckpoint: String?
        /// The ARN of the replication instance.
        public let replicationInstanceArn: String?
        /// The Amazon Resource Name (ARN) of the replication task.
        public let replicationTaskArn: String?
        /// The date the replication task was created.
        public let replicationTaskCreationDate: Date?
        /// The user-assigned replication task identifier or name. Constraints:   Must contain 1-255 alphanumeric characters or hyphens.   First character must be a letter.   Cannot end with a hyphen or contain two consecutive hyphens.
        public let replicationTaskIdentifier: String?
        /// The settings for the replication task.
        public let replicationTaskSettings: String?
        /// The date the replication task is scheduled to start.
        public let replicationTaskStartDate: Date?
        /// The statistics for the task, including elapsed time, tables loaded, and table errors.
        public let replicationTaskStats: ReplicationTaskStats?
        /// The Amazon Resource Name (ARN) that uniquely identifies the endpoint.
        public let sourceEndpointArn: String?
        /// The status of the replication task. This response parameter can return one of the following values:    "moving"  The task is being moved in response to running the  MoveReplicationTask operation.    "creating"  The task is being created in response to running the  CreateReplicationTask operation.    "deleting"  The task is being deleted in response to running the  DeleteReplicationTask operation.    "failed"  The task failed to successfully complete the database migration in response to running the  StartReplicationTask operation.    "failed-move"  The task failed to move in response to running the  MoveReplicationTask operation.    "modifying"  The task definition is being modified in response to running the  ModifyReplicationTask operation.    "ready"  The task is in a ready state where it can respond to other task operations, such as  StartReplicationTask or  DeleteReplicationTask .     "running"  The task is performing a database migration in response to running the  StartReplicationTask operation.    "starting"  The task is preparing to perform a database migration in response to running the  StartReplicationTask operation.    "stopped"  The task has stopped in response to running the  StopReplicationTask operation.    "stopping"  The task is preparing to stop in response to running the  StopReplicationTask operation.    "testing"  The database migration specified for this task is being tested in response to running either the  StartReplicationTaskAssessmentRun or the  StartReplicationTaskAssessment  operation.    StartReplicationTaskAssessmentRun is an improved premigration task assessment operation. The  StartReplicationTaskAssessment  operation assesses data type compatibility only between the source and target database of a given migration task. In contrast,  StartReplicationTaskAssessmentRun  enables you to specify a variety of premigration task assessments in addition to data type compatibility. These assessments include ones for the validity of primary key definitions and likely issues with database migration performance, among others.
        public let status: String?
        /// The reason the replication task was stopped. This response parameter can return one of the following values:    "Stop Reason NORMAL"  The task completed successfully with no additional information returned.    "Stop Reason RECOVERABLE_ERROR"     "Stop Reason FATAL_ERROR"     "Stop Reason FULL_LOAD_ONLY_FINISHED"  The task completed the full load phase. DMS applied cached changes if you set StopTaskCachedChangesApplied to true.    "Stop Reason STOPPED_AFTER_FULL_LOAD"  Full load completed, with cached changes not applied    "Stop Reason STOPPED_AFTER_CACHED_EVENTS"  Full load completed, with cached changes applied    "Stop Reason EXPRESS_LICENSE_LIMITS_REACHED"     "Stop Reason STOPPED_AFTER_DDL_APPLY"  User-defined stop task after DDL applied    "Stop Reason STOPPED_DUE_TO_LOW_MEMORY"     "Stop Reason STOPPED_DUE_TO_LOW_DISK"     "Stop Reason STOPPED_AT_SERVER_TIME"  User-defined server time for stopping task    "Stop Reason STOPPED_AT_COMMIT_TIME"  User-defined commit time for stopping task    "Stop Reason RECONFIGURATION_RESTART"     "Stop Reason RECYCLE_TASK"
        public let stopReason: String?
        /// Table mappings specified in the task.
        public let tableMappings: String?
        /// The ARN that uniquely identifies the endpoint.
        public let targetEndpointArn: String?
        /// The ARN of the replication instance to which this task is moved in response to running the  MoveReplicationTask operation. Otherwise, this response parameter isn't a member of the ReplicationTask object.
        public let targetReplicationInstanceArn: String?
        /// Supplemental information that the task requires to migrate the data for certain source and target endpoints. For more information, see Specifying Supplemental Data for Task Settings in the Database Migration Service User Guide.
        public let taskData: String?

        @inlinable
        public init(cdcStartPosition: String? = nil, cdcStopPosition: String? = nil, lastFailureMessage: String? = nil, migrationType: MigrationTypeValue? = nil, recoveryCheckpoint: String? = nil, replicationInstanceArn: String? = nil, replicationTaskArn: String? = nil, replicationTaskCreationDate: Date? = nil, replicationTaskIdentifier: String? = nil, replicationTaskSettings: String? = nil, replicationTaskStartDate: Date? = nil, replicationTaskStats: ReplicationTaskStats? = nil, sourceEndpointArn: String? = nil, status: String? = nil, stopReason: String? = nil, tableMappings: String? = nil, targetEndpointArn: String? = nil, targetReplicationInstanceArn: String? = nil, taskData: String? = nil) {
            self.cdcStartPosition = cdcStartPosition
            self.cdcStopPosition = cdcStopPosition
            self.lastFailureMessage = lastFailureMessage
            self.migrationType = migrationType
            self.recoveryCheckpoint = recoveryCheckpoint
            self.replicationInstanceArn = replicationInstanceArn
            self.replicationTaskArn = replicationTaskArn
            self.replicationTaskCreationDate = replicationTaskCreationDate
            self.replicationTaskIdentifier = replicationTaskIdentifier
            self.replicationTaskSettings = replicationTaskSettings
            self.replicationTaskStartDate = replicationTaskStartDate
            self.replicationTaskStats = replicationTaskStats
            self.sourceEndpointArn = sourceEndpointArn
            self.status = status
            self.stopReason = stopReason
            self.tableMappings = tableMappings
            self.targetEndpointArn = targetEndpointArn
            self.targetReplicationInstanceArn = targetReplicationInstanceArn
            self.taskData = taskData
        }

        private enum CodingKeys: String, CodingKey {
            case cdcStartPosition = "CdcStartPosition"
            case cdcStopPosition = "CdcStopPosition"
            case lastFailureMessage = "LastFailureMessage"
            case migrationType = "MigrationType"
            case recoveryCheckpoint = "RecoveryCheckpoint"
            case replicationInstanceArn = "ReplicationInstanceArn"
            case replicationTaskArn = "ReplicationTaskArn"
            case replicationTaskCreationDate = "ReplicationTaskCreationDate"
            case replicationTaskIdentifier = "ReplicationTaskIdentifier"
            case replicationTaskSettings = "ReplicationTaskSettings"
            case replicationTaskStartDate = "ReplicationTaskStartDate"
            case replicationTaskStats = "ReplicationTaskStats"
            case sourceEndpointArn = "SourceEndpointArn"
            case status = "Status"
            case stopReason = "StopReason"
            case tableMappings = "TableMappings"
            case targetEndpointArn = "TargetEndpointArn"
            case targetReplicationInstanceArn = "TargetReplicationInstanceArn"
            case taskData = "TaskData"
        }
    }

    public struct ReplicationTaskAssessmentResult: AWSDecodableShape {
        ///  The task assessment results in JSON format.  The response object only contains this field if you provide DescribeReplicationTaskAssessmentResultsMessage$ReplicationTaskArn in the request.
        public let assessmentResults: String?
        ///  The file containing the results of the task assessment.
        public let assessmentResultsFile: String?
        ///  The status of the task assessment.
        public let assessmentStatus: String?
        /// The Amazon Resource Name (ARN) of the replication task.
        public let replicationTaskArn: String?
        ///  The replication task identifier of the task on which the task assessment was run.
        public let replicationTaskIdentifier: String?
        /// The date the task assessment was completed.
        public let replicationTaskLastAssessmentDate: Date?
        ///  The URL of the S3 object containing the task assessment results.  The response object only contains this field if you provide DescribeReplicationTaskAssessmentResultsMessage$ReplicationTaskArn in the request.
        public let s3ObjectUrl: String?

        @inlinable
        public init(assessmentResults: String? = nil, assessmentResultsFile: String? = nil, assessmentStatus: String? = nil, replicationTaskArn: String? = nil, replicationTaskIdentifier: String? = nil, replicationTaskLastAssessmentDate: Date? = nil, s3ObjectUrl: String? = nil) {
            self.assessmentResults = assessmentResults
            self.assessmentResultsFile = assessmentResultsFile
            self.assessmentStatus = assessmentStatus
            self.replicationTaskArn = replicationTaskArn
            self.replicationTaskIdentifier = replicationTaskIdentifier
            self.replicationTaskLastAssessmentDate = replicationTaskLastAssessmentDate
            self.s3ObjectUrl = s3ObjectUrl
        }

        private enum CodingKeys: String, CodingKey {
            case assessmentResults = "AssessmentResults"
            case assessmentResultsFile = "AssessmentResultsFile"
            case assessmentStatus = "AssessmentStatus"
            case replicationTaskArn = "ReplicationTaskArn"
            case replicationTaskIdentifier = "ReplicationTaskIdentifier"
            case replicationTaskLastAssessmentDate = "ReplicationTaskLastAssessmentDate"
            case s3ObjectUrl = "S3ObjectUrl"
        }
    }

    public struct ReplicationTaskAssessmentRun: AWSDecodableShape {
        /// Indication of the completion progress for the individual assessments specified to run.
        public let assessmentProgress: ReplicationTaskAssessmentRunProgress?
        /// Unique name of the assessment run.
        public let assessmentRunName: String?
        /// Indicates that the following PreflightAssessmentRun is the latest for the ReplicationTask. The status is either true or false.
        public let isLatestTaskAssessmentRun: Bool?
        /// Last message generated by an individual assessment failure.
        public let lastFailureMessage: String?
        /// ARN of the migration task associated with this premigration assessment run.
        public let replicationTaskArn: String?
        /// Amazon Resource Name (ARN) of this assessment run.
        public let replicationTaskAssessmentRunArn: String?
        /// Date on which the assessment run was created using the StartReplicationTaskAssessmentRun operation.
        public let replicationTaskAssessmentRunCreationDate: Date?
        /// Encryption mode used to encrypt the assessment run results.
        public let resultEncryptionMode: String?
        /// ARN of the KMS encryption key used to encrypt the assessment run results.
        public let resultKmsKeyArn: String?
        /// Amazon S3 bucket where DMS stores the results of this assessment run.
        public let resultLocationBucket: String?
        /// Folder in an Amazon S3 bucket where DMS stores the results of this assessment run.
        public let resultLocationFolder: String?
        ///  Result statistics for a completed assessment run, showing aggregated statistics of IndividualAssessments for how many assessments were passed, failed, or encountered issues such as errors or warnings.
        public let resultStatistic: ReplicationTaskAssessmentRunResultStatistic?
        /// ARN of the service role used to start the assessment run using the StartReplicationTaskAssessmentRun operation. The role must allow the iam:PassRole action.
        public let serviceAccessRoleArn: String?
        /// Assessment run status.  This status can have one of the following values:    "cancelling"  The assessment run was canceled by the CancelReplicationTaskAssessmentRun operation.    "deleting"  The assessment run was deleted by the DeleteReplicationTaskAssessmentRun operation.    "failed"  At least one individual assessment completed with a failed status.    "error-provisioning"  An internal error occurred while resources were provisioned (during provisioning status).    "error-executing"  An internal error occurred while individual assessments ran (during running status).    "invalid state"  The assessment run is in an unknown state.    "passed"  All individual assessments have completed, and none has a failed status.    "provisioning"  Resources required to run individual assessments are being provisioned.    "running"  Individual assessments are being run.    "starting"  The assessment run is starting, but resources are not yet being provisioned for individual assessments.    "warning"  At least one individual assessment completed with a warning status or all individual assessments were skipped (completed with a skipped status).
        public let status: String?

        @inlinable
        public init(assessmentProgress: ReplicationTaskAssessmentRunProgress? = nil, assessmentRunName: String? = nil, isLatestTaskAssessmentRun: Bool? = nil, lastFailureMessage: String? = nil, replicationTaskArn: String? = nil, replicationTaskAssessmentRunArn: String? = nil, replicationTaskAssessmentRunCreationDate: Date? = nil, resultEncryptionMode: String? = nil, resultKmsKeyArn: String? = nil, resultLocationBucket: String? = nil, resultLocationFolder: String? = nil, resultStatistic: ReplicationTaskAssessmentRunResultStatistic? = nil, serviceAccessRoleArn: String? = nil, status: String? = nil) {
            self.assessmentProgress = assessmentProgress
            self.assessmentRunName = assessmentRunName
            self.isLatestTaskAssessmentRun = isLatestTaskAssessmentRun
            self.lastFailureMessage = lastFailureMessage
            self.replicationTaskArn = replicationTaskArn
            self.replicationTaskAssessmentRunArn = replicationTaskAssessmentRunArn
            self.replicationTaskAssessmentRunCreationDate = replicationTaskAssessmentRunCreationDate
            self.resultEncryptionMode = resultEncryptionMode
            self.resultKmsKeyArn = resultKmsKeyArn
            self.resultLocationBucket = resultLocationBucket
            self.resultLocationFolder = resultLocationFolder
            self.resultStatistic = resultStatistic
            self.serviceAccessRoleArn = serviceAccessRoleArn
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case assessmentProgress = "AssessmentProgress"
            case assessmentRunName = "AssessmentRunName"
            case isLatestTaskAssessmentRun = "IsLatestTaskAssessmentRun"
            case lastFailureMessage = "LastFailureMessage"
            case replicationTaskArn = "ReplicationTaskArn"
            case replicationTaskAssessmentRunArn = "ReplicationTaskAssessmentRunArn"
            case replicationTaskAssessmentRunCreationDate = "ReplicationTaskAssessmentRunCreationDate"
            case resultEncryptionMode = "ResultEncryptionMode"
            case resultKmsKeyArn = "ResultKmsKeyArn"
            case resultLocationBucket = "ResultLocationBucket"
            case resultLocationFolder = "ResultLocationFolder"
            case resultStatistic = "ResultStatistic"
            case serviceAccessRoleArn = "ServiceAccessRoleArn"
            case status = "Status"
        }
    }

    public struct ReplicationTaskAssessmentRunProgress: AWSDecodableShape {
        /// The number of individual assessments that have completed, successfully or not.
        public let individualAssessmentCompletedCount: Int?
        /// The number of individual assessments that are specified to run.
        public let individualAssessmentCount: Int?

        @inlinable
        public init(individualAssessmentCompletedCount: Int? = nil, individualAssessmentCount: Int? = nil) {
            self.individualAssessmentCompletedCount = individualAssessmentCompletedCount
            self.individualAssessmentCount = individualAssessmentCount
        }

        private enum CodingKeys: String, CodingKey {
            case individualAssessmentCompletedCount = "IndividualAssessmentCompletedCount"
            case individualAssessmentCount = "IndividualAssessmentCount"
        }
    }

    public struct ReplicationTaskAssessmentRunResultStatistic: AWSDecodableShape {
        ///  The number of individual assessments that were cancelled during the assessment run.
        public let cancelled: Int?
        /// The number of individual assessments that encountered a critical error and could not complete properly.
        public let error: Int?
        /// The number of individual assessments that failed to meet the criteria defined in the assessment run.
        public let failed: Int?
        /// The number of individual assessments that successfully passed all checks in the assessment run.
        public let passed: Int?
        /// The number of individual assessments that were skipped during the assessment run.
        public let skipped: Int?
        /// Indicates that the recent completed AssessmentRun triggered a warning.
        public let warning: Int?

        @inlinable
        public init(cancelled: Int? = nil, error: Int? = nil, failed: Int? = nil, passed: Int? = nil, skipped: Int? = nil, warning: Int? = nil) {
            self.cancelled = cancelled
            self.error = error
            self.failed = failed
            self.passed = passed
            self.skipped = skipped
            self.warning = warning
        }

        private enum CodingKeys: String, CodingKey {
            case cancelled = "Cancelled"
            case error = "Error"
            case failed = "Failed"
            case passed = "Passed"
            case skipped = "Skipped"
            case warning = "Warning"
        }
    }

    public struct ReplicationTaskIndividualAssessment: AWSDecodableShape {
        /// Name of this individual assessment.
        public let individualAssessmentName: String?
        /// ARN of the premigration assessment run that is created to run this individual assessment.
        public let replicationTaskAssessmentRunArn: String?
        /// Amazon Resource Name (ARN) of this individual assessment.
        public let replicationTaskIndividualAssessmentArn: String?
        /// Date when this individual assessment was started as part of running the StartReplicationTaskAssessmentRun operation.
        public let replicationTaskIndividualAssessmentStartDate: Date?
        /// Individual assessment status. This status can have one of the following values:    "cancelled"     "error"     "failed"     "passed"     "pending"     "skipped"     "running"
        public let status: String?

        @inlinable
        public init(individualAssessmentName: String? = nil, replicationTaskAssessmentRunArn: String? = nil, replicationTaskIndividualAssessmentArn: String? = nil, replicationTaskIndividualAssessmentStartDate: Date? = nil, status: String? = nil) {
            self.individualAssessmentName = individualAssessmentName
            self.replicationTaskAssessmentRunArn = replicationTaskAssessmentRunArn
            self.replicationTaskIndividualAssessmentArn = replicationTaskIndividualAssessmentArn
            self.replicationTaskIndividualAssessmentStartDate = replicationTaskIndividualAssessmentStartDate
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case individualAssessmentName = "IndividualAssessmentName"
            case replicationTaskAssessmentRunArn = "ReplicationTaskAssessmentRunArn"
            case replicationTaskIndividualAssessmentArn = "ReplicationTaskIndividualAssessmentArn"
            case replicationTaskIndividualAssessmentStartDate = "ReplicationTaskIndividualAssessmentStartDate"
            case status = "Status"
        }
    }

    public struct ReplicationTaskStats: AWSDecodableShape {
        /// The elapsed time of the task, in milliseconds.
        public let elapsedTimeMillis: Int64?
        /// The date the replication task was started either with a fresh start or a target reload.
        public let freshStartDate: Date?
        /// The date the replication task full load was completed.
        public let fullLoadFinishDate: Date?
        /// The percent complete for the full load migration task.
        public let fullLoadProgressPercent: Int?
        /// The date the replication task full load was started.
        public let fullLoadStartDate: Date?
        /// The date the replication task was started either with a fresh start or a resume. For more information, see StartReplicationTaskType.
        public let startDate: Date?
        /// The date the replication task was stopped.
        public let stopDate: Date?
        /// The number of errors that have occurred during this task.
        public let tablesErrored: Int?
        /// The number of tables loaded for this task.
        public let tablesLoaded: Int?
        /// The number of tables currently loading for this task.
        public let tablesLoading: Int?
        /// The number of tables queued for this task.
        public let tablesQueued: Int?

        @inlinable
        public init(elapsedTimeMillis: Int64? = nil, freshStartDate: Date? = nil, fullLoadFinishDate: Date? = nil, fullLoadProgressPercent: Int? = nil, fullLoadStartDate: Date? = nil, startDate: Date? = nil, stopDate: Date? = nil, tablesErrored: Int? = nil, tablesLoaded: Int? = nil, tablesLoading: Int? = nil, tablesQueued: Int? = nil) {
            self.elapsedTimeMillis = elapsedTimeMillis
            self.freshStartDate = freshStartDate
            self.fullLoadFinishDate = fullLoadFinishDate
            self.fullLoadProgressPercent = fullLoadProgressPercent
            self.fullLoadStartDate = fullLoadStartDate
            self.startDate = startDate
            self.stopDate = stopDate
            self.tablesErrored = tablesErrored
            self.tablesLoaded = tablesLoaded
            self.tablesLoading = tablesLoading
            self.tablesQueued = tablesQueued
        }

        private enum CodingKeys: String, CodingKey {
            case elapsedTimeMillis = "ElapsedTimeMillis"
            case freshStartDate = "FreshStartDate"
            case fullLoadFinishDate = "FullLoadFinishDate"
            case fullLoadProgressPercent = "FullLoadProgressPercent"
            case fullLoadStartDate = "FullLoadStartDate"
            case startDate = "StartDate"
            case stopDate = "StopDate"
            case tablesErrored = "TablesErrored"
            case tablesLoaded = "TablesLoaded"
            case tablesLoading = "TablesLoading"
            case tablesQueued = "TablesQueued"
        }
    }

    public struct ResourceAlreadyExistsFault: AWSErrorShape {
        public let message: String?
        public let resourceArn: String?

        @inlinable
        public init(message: String? = nil, resourceArn: String? = nil) {
            self.message = message
            self.resourceArn = resourceArn
        }

        private enum CodingKeys: String, CodingKey {
            case message = "message"
            case resourceArn = "resourceArn"
        }
    }

    public struct ResourcePendingMaintenanceActions: AWSDecodableShape {
        /// Detailed information about the pending maintenance action.
        public let pendingMaintenanceActionDetails: [PendingMaintenanceAction]?
        /// The Amazon Resource Name (ARN) of the DMS resource that the pending maintenance action applies to. For information about creating an ARN, see  Constructing an Amazon Resource Name (ARN) for DMS in the DMS documentation.
        public let resourceIdentifier: String?

        @inlinable
        public init(pendingMaintenanceActionDetails: [PendingMaintenanceAction]? = nil, resourceIdentifier: String? = nil) {
            self.pendingMaintenanceActionDetails = pendingMaintenanceActionDetails
            self.resourceIdentifier = resourceIdentifier
        }

        private enum CodingKeys: String, CodingKey {
            case pendingMaintenanceActionDetails = "PendingMaintenanceActionDetails"
            case resourceIdentifier = "ResourceIdentifier"
        }
    }

    public struct RunFleetAdvisorLsaAnalysisResponse: AWSDecodableShape {
        /// The ID of the LSA analysis run.
        public let lsaAnalysisId: String?
        /// The status of the LSA analysis, for example COMPLETED.
        public let status: String?

        @inlinable
        public init(lsaAnalysisId: String? = nil, status: String? = nil) {
            self.lsaAnalysisId = lsaAnalysisId
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case lsaAnalysisId = "LsaAnalysisId"
            case status = "Status"
        }
    }

    public struct S3Settings: AWSEncodableShape & AWSDecodableShape {
        /// An optional parameter that, when set to true or y, you can use to add column name information to the .csv output file. The default value is false. Valid values are true, false, y, and n.
        public let addColumnName: Bool?
        /// Use the S3 target endpoint setting AddTrailingPaddingCharacter to add padding on string data. The default value is false.
        public let addTrailingPaddingCharacter: Bool?
        ///  An optional parameter to set a folder name in the S3 bucket. If provided, tables are created in the path  bucketFolder/schema_name/table_name/. If this parameter isn't specified, then the path used is  schema_name/table_name/.
        public let bucketFolder: String?
        ///  The name of the S3 bucket.
        public let bucketName: String?
        /// A value that enables DMS to specify a predefined (canned) access control list for objects created in an Amazon S3 bucket as .csv or .parquet files. For more information about Amazon S3 canned ACLs, see Canned ACL in the Amazon S3 Developer Guide.  The default value is NONE. Valid values include NONE, PRIVATE, PUBLIC_READ, PUBLIC_READ_WRITE, AUTHENTICATED_READ, AWS_EXEC_READ, BUCKET_OWNER_READ, and BUCKET_OWNER_FULL_CONTROL.
        public let cannedAclForObjects: CannedAclForObjectsValue?
        /// A value that enables a change data capture (CDC) load to write INSERT and UPDATE operations to .csv or .parquet (columnar storage) output files. The default setting is false, but when CdcInsertsAndUpdates is set to true or y, only INSERTs and UPDATEs from the source database are migrated to the .csv or .parquet file.  DMS supports the use of the .parquet files in versions 3.4.7 and later.  How these INSERTs and UPDATEs are recorded depends on the value of the IncludeOpForFullLoad parameter. If IncludeOpForFullLoad is set to true, the first field of every CDC record is set to either I or U to indicate INSERT and UPDATE operations at the source. But if IncludeOpForFullLoad is set to false, CDC records are written without an indication of INSERT or UPDATE operations at the source. For more information about how these settings work together, see Indicating Source DB Operations in Migrated S3 Data in the Database Migration Service User Guide..  DMS supports the use of the CdcInsertsAndUpdates parameter in versions 3.3.1 and later.  CdcInsertsOnly and CdcInsertsAndUpdates can't both be set to true for the same endpoint. Set either CdcInsertsOnly or CdcInsertsAndUpdates to true for the same endpoint, but not both.
        public let cdcInsertsAndUpdates: Bool?
        /// A value that enables a change data capture (CDC) load to write only INSERT operations to .csv or columnar storage (.parquet) output files. By default (the false setting), the first field in a .csv or .parquet record contains the letter I (INSERT), U (UPDATE), or D (DELETE). These values indicate whether the row was inserted, updated, or deleted at the source database for a CDC load to the target. If CdcInsertsOnly is set to true or y, only INSERTs from the source database are migrated to the .csv or .parquet file. For .csv format only, how these INSERTs are recorded depends on the value of IncludeOpForFullLoad. If IncludeOpForFullLoad is set to true, the first field of every CDC record is set to I to indicate the INSERT operation at the source. If IncludeOpForFullLoad is set to false, every CDC record is written without a first field to indicate the INSERT operation at the source. For more information about how these settings work together, see Indicating Source DB Operations in Migrated S3 Data in the Database Migration Service User Guide..  DMS supports the interaction described preceding between the CdcInsertsOnly and IncludeOpForFullLoad parameters in versions 3.1.4 and later.   CdcInsertsOnly and CdcInsertsAndUpdates can't both be set to true for the same endpoint. Set either CdcInsertsOnly or CdcInsertsAndUpdates to true for the same endpoint, but not both.
        public let cdcInsertsOnly: Bool?
        /// Maximum length of the interval, defined in seconds, after which to output a file to Amazon S3. When CdcMaxBatchInterval and CdcMinFileSize are both specified, the file write is triggered by whichever parameter condition is met first within an DMS CloudFormation template. The default value is 60 seconds.
        public let cdcMaxBatchInterval: Int?
        /// Minimum file size, defined in kilobytes, to reach for a file output to Amazon S3. When CdcMinFileSize and CdcMaxBatchInterval are both specified, the file write is triggered by whichever parameter condition is met first within an DMS CloudFormation template. The default value is 32 MB.
        public let cdcMinFileSize: Int?
        /// Specifies the folder path of CDC files. For an S3 source, this setting is required if a task captures change data; otherwise, it's optional. If CdcPath is set, DMS reads CDC files from this path and replicates the data changes to the target endpoint. For an S3 target if you set  PreserveTransactions to true, DMS verifies that you have set this parameter to a folder path on your S3 target where DMS can save the transaction order for the CDC load. DMS creates this CDC folder path in either your S3 target working directory or the S3 target location specified by  BucketFolder and  BucketName . For example, if you specify CdcPath as MyChangedData, and you specify BucketName as MyTargetBucket but do not specify BucketFolder, DMS creates the CDC folder path following: MyTargetBucket/MyChangedData. If you specify the same CdcPath, and you specify BucketName as MyTargetBucket and BucketFolder as MyTargetData, DMS creates the CDC folder path following: MyTargetBucket/MyTargetData/MyChangedData. For more information on CDC including transaction order on an S3 target, see Capturing data changes (CDC) including transaction order on the S3 target.  This setting is supported in DMS versions 3.4.2 and later.
        public let cdcPath: String?
        /// An optional parameter to use GZIP to compress the target files. Set to GZIP to compress the target files. Either set this parameter to NONE (the default) or don't use it to leave the files uncompressed. This parameter applies to both .csv and .parquet file formats.
        public let compressionType: CompressionTypeValue?
        ///  The delimiter used to separate columns in the .csv file for both source and target. The default is a comma.
        public let csvDelimiter: String?
        /// This setting only applies if your Amazon S3 output files during a change data capture (CDC) load are written in .csv format. If  UseCsvNoSupValue is set to true, specify a string value that you want DMS to use for all columns not included in the supplemental log. If you do not specify a string value, DMS uses the null value for these columns regardless of the UseCsvNoSupValue setting.  This setting is supported in DMS versions 3.4.1 and later.
        public let csvNoSupValue: String?
        /// An optional parameter that specifies how DMS treats null values. While handling the null value, you can use this parameter to pass a user-defined string as null when writing to the target. For example, when target columns are nullable, you can use this option to differentiate between the empty string value and the null value. So, if you set this parameter value to the empty string ("" or ''), DMS treats the empty string as the null value instead of NULL. The default value is NULL. Valid values include any valid string.
        public let csvNullValue: String?
        ///  The delimiter used to separate rows in the .csv file for both source and target. The default is a carriage return (\n).
        public let csvRowDelimiter: String?
        /// The format of the data that you want to use for output. You can choose one of the following:     csv : This is a row-based file format with comma-separated values (.csv).     parquet : Apache Parquet (.parquet) is a columnar storage file format that features efficient compression and provides faster query response.
        public let dataFormat: DataFormatValue?
        /// The size of one data page in bytes. This parameter defaults to 1024 * 1024 bytes (1 MiB). This number is used for .parquet file format only.
        public let dataPageSize: Int?
        /// Specifies a date separating delimiter to use during folder partitioning. The default value is SLASH. Use this parameter when DatePartitionedEnabled is set to true.
        public let datePartitionDelimiter: DatePartitionDelimiterValue?
        /// When set to true, this parameter partitions S3 bucket folders based on transaction commit dates. The default value is false. For more information about date-based folder partitioning, see Using date-based folder partitioning.
        public let datePartitionEnabled: Bool?
        /// Identifies the sequence of the date format to use during folder partitioning. The default value is YYYYMMDD. Use this parameter when DatePartitionedEnabled is set to true.
        public let datePartitionSequence: DatePartitionSequenceValue?
        /// When creating an S3 target endpoint, set DatePartitionTimezone to convert the current UTC time into a specified time zone. The conversion occurs when a date partition folder is created and a CDC filename is generated. The time zone format is Area/Location. Use this parameter when DatePartitionedEnabled is set to true, as shown in the following example.  s3-settings='{"DatePartitionEnabled": true, "DatePartitionSequence": "YYYYMMDDHH", "DatePartitionDelimiter": "SLASH", "DatePartitionTimezone":"Asia/Seoul", "BucketName": "dms-nattarat-test"}'
        public let datePartitionTimezone: String?
        /// The maximum size of an encoded dictionary page of a column. If the dictionary page exceeds this, this column is stored using an encoding type of PLAIN. This parameter defaults to 1024 * 1024 bytes (1 MiB), the maximum size of a dictionary page before it reverts to PLAIN encoding. This size is used for .parquet file format only.
        public let dictPageSizeLimit: Int?
        /// A value that enables statistics for Parquet pages and row groups. Choose true to enable statistics, false to disable. Statistics include NULL, DISTINCT, MAX, and MIN values. This parameter defaults to true. This value is used for .parquet file format only.
        public let enableStatistics: Bool?
        /// The type of encoding you are using:     RLE_DICTIONARY uses a combination of bit-packing and run-length encoding to store repeated values more efficiently. This is the default.    PLAIN doesn't use encoding at all. Values are stored as they are.    PLAIN_DICTIONARY builds a dictionary of the values encountered in a given column. The dictionary is stored in a dictionary page for each column chunk.
        public let encodingType: EncodingTypeValue?
        /// The type of server-side encryption that you want to use for your data. This encryption type is part of the endpoint settings or the extra connections attributes for Amazon S3. You can choose either SSE_S3 (the default) or SSE_KMS.   For the ModifyEndpoint operation, you can change the existing value of the EncryptionMode parameter from SSE_KMS to SSE_S3. But you cant change the existing value from SSE_S3 to SSE_KMS.  To use SSE_S3, you need an Identity and Access Management (IAM) role with permission to allow "arn:aws:s3:::dms-*" to use the following actions:    s3:CreateBucket     s3:ListBucket     s3:DeleteBucket     s3:GetBucketLocation     s3:GetObject     s3:PutObject     s3:DeleteObject     s3:GetObjectVersion     s3:GetBucketPolicy     s3:PutBucketPolicy     s3:DeleteBucketPolicy
        public let encryptionMode: EncryptionModeValue?
        /// To specify a bucket owner and prevent sniping, you can use the ExpectedBucketOwner endpoint setting.  Example: --s3-settings='{"ExpectedBucketOwner": "AWS_Account_ID"}'  When you make a request to test a connection or perform a migration, S3 checks the account ID of the bucket owner against the specified parameter.
        public let expectedBucketOwner: String?
        ///  Specifies how tables are defined in the S3 source files only.
        public let externalTableDefinition: String?
        /// When true, allows Glue to catalog your S3 bucket. Creating an Glue catalog lets you use Athena to query your data.
        public let glueCatalogGeneration: Bool?
        /// When this value is set to 1, DMS ignores the first row header in a .csv file. A value of 1 turns on the feature; a value of 0 turns off the feature. The default is 0.
        public let ignoreHeaderRows: Int?
        /// A value that enables a full load to write INSERT operations to the comma-separated value (.csv) or .parquet output files only to indicate how the rows were added to the source database.  DMS supports the IncludeOpForFullLoad parameter in versions 3.1.4 and later. DMS supports the use of the .parquet files with the IncludeOpForFullLoad parameter in versions 3.4.7 and later.  For full load, records can only be inserted. By default (the false setting), no information is recorded in these output files for a full load to indicate that the rows were inserted at the source database. If IncludeOpForFullLoad is set to true or y, the INSERT is recorded as an I annotation in the first field of the .csv file. This allows the format of your target records from a full load to be consistent with the target records from a CDC load.  This setting works together with the CdcInsertsOnly and the CdcInsertsAndUpdates parameters for output to .csv files only. For more information about how these settings work together, see Indicating Source DB Operations in Migrated S3 Data in the Database Migration Service User Guide..
        public let includeOpForFullLoad: Bool?
        /// A value that specifies the maximum size (in KB) of any .csv file to be created while migrating to an S3 target during full load. The default value is 1,048,576 KB (1 GB). Valid values include 1 to 1,048,576.
        public let maxFileSize: Int?
        /// A value that specifies the precision of any TIMESTAMP column values that are written to an Amazon S3 object file in .parquet format.  DMS supports the ParquetTimestampInMillisecond parameter in versions 3.1.4 and later.  When ParquetTimestampInMillisecond is set to true or y, DMS writes all TIMESTAMP columns in a .parquet formatted file with millisecond precision. Otherwise, DMS writes them with microsecond precision. Currently, Amazon Athena and Glue can handle only millisecond precision for TIMESTAMP values. Set this parameter to true for S3 endpoint object files that are .parquet formatted only if you plan to query or process the data with Athena or Glue.  DMS writes any TIMESTAMP column values written to an S3 file in .csv format with microsecond precision. Setting ParquetTimestampInMillisecond has no effect on the string format of the timestamp column value that is inserted by setting the TimestampColumnName parameter.
        public let parquetTimestampInMillisecond: Bool?
        /// The version of the Apache Parquet format that you want to use: parquet_1_0 (the default) or parquet_2_0.
        public let parquetVersion: ParquetVersionValue?
        /// If set to true, DMS saves the transaction order for a change data capture (CDC) load on the Amazon S3 target specified by  CdcPath . For more information, see Capturing data changes (CDC) including transaction order on the S3 target.  This setting is supported in DMS versions 3.4.2 and later.
        public let preserveTransactions: Bool?
        /// For an S3 source, when this value is set to true or y, each leading double quotation mark has to be followed by an ending double quotation mark. This formatting complies with RFC 4180. When this value is set to false or n, string literals are copied to the target as is. In this case, a delimiter (row or column) signals the end of the field. Thus, you can't use a delimiter as part of the string, because it signals the end of the value. For an S3 target, an optional parameter used to set behavior to comply with RFC 4180 for data migrated to Amazon S3 using .csv file format only. When this value is set to true or y using Amazon S3 as a target, if the data has quotation marks or newline characters in it, DMS encloses the entire column with an additional pair of double quotation marks ("). Every quotation mark within the data is repeated twice. The default value is true. Valid values include true, false, y, and n.
        public let rfc4180: Bool?
        /// The number of rows in a row group. A smaller row group size provides faster reads. But as the number of row groups grows, the slower writes become. This parameter defaults to 10,000 rows. This number is used for .parquet file format only.  If you choose a value larger than the maximum, RowGroupLength is set to the max row group length in bytes (64 * 1024 * 1024).
        public let rowGroupLength: Int?
        /// If you are using SSE_KMS for the EncryptionMode, provide the KMS key ID. The key that you use needs an attached policy that enables Identity and Access Management (IAM) user permissions and allows use of the key. Here is a CLI example: aws dms create-endpoint --endpoint-identifier value --endpoint-type target --engine-name s3 --s3-settings ServiceAccessRoleArn=value,BucketFolder=value,BucketName=value,EncryptionMode=SSE_KMS,ServerSideEncryptionKmsKeyId=value
        public let serverSideEncryptionKmsKeyId: String?
        ///  The Amazon Resource Name (ARN) used by the service to access the IAM role. The role must allow the iam:PassRole action. It is a required parameter that enables DMS to write and read objects from an S3 bucket.
        public let serviceAccessRoleArn: String?
        /// A value that when nonblank causes DMS to add a column with timestamp information to the endpoint data for an Amazon S3 target.  DMS supports the TimestampColumnName parameter in versions 3.1.4 and later.  DMS includes an additional STRING column in the .csv or .parquet object files of your migrated data when you set TimestampColumnName to a nonblank value. For a full load, each row of this timestamp column contains a timestamp for when the data was transferred from the source to the target by DMS.  For a change data capture (CDC) load, each row of the timestamp column contains the timestamp for the commit of that row in the source database. The string format for this timestamp column value is yyyy-MM-dd HH:mm:ss.SSSSSS. By default, the precision of this value is in microseconds. For a CDC load, the rounding of the precision depends on the commit timestamp supported by DMS for the source database. When the AddColumnName parameter is set to true, DMS also includes a name for the timestamp column that you set with TimestampColumnName.
        public let timestampColumnName: String?
        /// This setting applies if the S3 output files during a change data capture (CDC) load are written in .csv format. If set to true for columns not included in the supplemental log, DMS uses the value specified by  CsvNoSupValue . If not set or set to false, DMS uses the null value for these columns.  This setting is supported in DMS versions 3.4.1 and later.
        public let useCsvNoSupValue: Bool?
        /// When set to true, this parameter uses the task start time as the timestamp column value instead of the time data is written to target. For full load, when useTaskStartTimeForFullLoadTimestamp is set to true, each row of the timestamp column contains the task start time. For CDC loads, each row of the timestamp column contains the transaction commit time. When useTaskStartTimeForFullLoadTimestamp is set to false, the full load timestamp in the timestamp column increments with the time data arrives at the target.
        public let useTaskStartTimeForFullLoadTimestamp: Bool?

        @inlinable
        public init(addColumnName: Bool? = nil, addTrailingPaddingCharacter: Bool? = nil, bucketFolder: String? = nil, bucketName: String? = nil, cannedAclForObjects: CannedAclForObjectsValue? = nil, cdcInsertsAndUpdates: Bool? = nil, cdcInsertsOnly: Bool? = nil, cdcMaxBatchInterval: Int? = nil, cdcMinFileSize: Int? = nil, cdcPath: String? = nil, compressionType: CompressionTypeValue? = nil, csvDelimiter: String? = nil, csvNoSupValue: String? = nil, csvNullValue: String? = nil, csvRowDelimiter: String? = nil, dataFormat: DataFormatValue? = nil, dataPageSize: Int? = nil, datePartitionDelimiter: DatePartitionDelimiterValue? = nil, datePartitionEnabled: Bool? = nil, datePartitionSequence: DatePartitionSequenceValue? = nil, datePartitionTimezone: String? = nil, dictPageSizeLimit: Int? = nil, enableStatistics: Bool? = nil, encodingType: EncodingTypeValue? = nil, encryptionMode: EncryptionModeValue? = nil, expectedBucketOwner: String? = nil, externalTableDefinition: String? = nil, glueCatalogGeneration: Bool? = nil, ignoreHeaderRows: Int? = nil, includeOpForFullLoad: Bool? = nil, maxFileSize: Int? = nil, parquetTimestampInMillisecond: Bool? = nil, parquetVersion: ParquetVersionValue? = nil, preserveTransactions: Bool? = nil, rfc4180: Bool? = nil, rowGroupLength: Int? = nil, serverSideEncryptionKmsKeyId: String? = nil, serviceAccessRoleArn: String? = nil, timestampColumnName: String? = nil, useCsvNoSupValue: Bool? = nil, useTaskStartTimeForFullLoadTimestamp: Bool? = nil) {
            self.addColumnName = addColumnName
            self.addTrailingPaddingCharacter = addTrailingPaddingCharacter
            self.bucketFolder = bucketFolder
            self.bucketName = bucketName
            self.cannedAclForObjects = cannedAclForObjects
            self.cdcInsertsAndUpdates = cdcInsertsAndUpdates
            self.cdcInsertsOnly = cdcInsertsOnly
            self.cdcMaxBatchInterval = cdcMaxBatchInterval
            self.cdcMinFileSize = cdcMinFileSize
            self.cdcPath = cdcPath
            self.compressionType = compressionType
            self.csvDelimiter = csvDelimiter
            self.csvNoSupValue = csvNoSupValue
            self.csvNullValue = csvNullValue
            self.csvRowDelimiter = csvRowDelimiter
            self.dataFormat = dataFormat
            self.dataPageSize = dataPageSize
            self.datePartitionDelimiter = datePartitionDelimiter
            self.datePartitionEnabled = datePartitionEnabled
            self.datePartitionSequence = datePartitionSequence
            self.datePartitionTimezone = datePartitionTimezone
            self.dictPageSizeLimit = dictPageSizeLimit
            self.enableStatistics = enableStatistics
            self.encodingType = encodingType
            self.encryptionMode = encryptionMode
            self.expectedBucketOwner = expectedBucketOwner
            self.externalTableDefinition = externalTableDefinition
            self.glueCatalogGeneration = glueCatalogGeneration
            self.ignoreHeaderRows = ignoreHeaderRows
            self.includeOpForFullLoad = includeOpForFullLoad
            self.maxFileSize = maxFileSize
            self.parquetTimestampInMillisecond = parquetTimestampInMillisecond
            self.parquetVersion = parquetVersion
            self.preserveTransactions = preserveTransactions
            self.rfc4180 = rfc4180
            self.rowGroupLength = rowGroupLength
            self.serverSideEncryptionKmsKeyId = serverSideEncryptionKmsKeyId
            self.serviceAccessRoleArn = serviceAccessRoleArn
            self.timestampColumnName = timestampColumnName
            self.useCsvNoSupValue = useCsvNoSupValue
            self.useTaskStartTimeForFullLoadTimestamp = useTaskStartTimeForFullLoadTimestamp
        }

        private enum CodingKeys: String, CodingKey {
            case addColumnName = "AddColumnName"
            case addTrailingPaddingCharacter = "AddTrailingPaddingCharacter"
            case bucketFolder = "BucketFolder"
            case bucketName = "BucketName"
            case cannedAclForObjects = "CannedAclForObjects"
            case cdcInsertsAndUpdates = "CdcInsertsAndUpdates"
            case cdcInsertsOnly = "CdcInsertsOnly"
            case cdcMaxBatchInterval = "CdcMaxBatchInterval"
            case cdcMinFileSize = "CdcMinFileSize"
            case cdcPath = "CdcPath"
            case compressionType = "CompressionType"
            case csvDelimiter = "CsvDelimiter"
            case csvNoSupValue = "CsvNoSupValue"
            case csvNullValue = "CsvNullValue"
            case csvRowDelimiter = "CsvRowDelimiter"
            case dataFormat = "DataFormat"
            case dataPageSize = "DataPageSize"
            case datePartitionDelimiter = "DatePartitionDelimiter"
            case datePartitionEnabled = "DatePartitionEnabled"
            case datePartitionSequence = "DatePartitionSequence"
            case datePartitionTimezone = "DatePartitionTimezone"
            case dictPageSizeLimit = "DictPageSizeLimit"
            case enableStatistics = "EnableStatistics"
            case encodingType = "EncodingType"
            case encryptionMode = "EncryptionMode"
            case expectedBucketOwner = "ExpectedBucketOwner"
            case externalTableDefinition = "ExternalTableDefinition"
            case glueCatalogGeneration = "GlueCatalogGeneration"
            case ignoreHeaderRows = "IgnoreHeaderRows"
            case includeOpForFullLoad = "IncludeOpForFullLoad"
            case maxFileSize = "MaxFileSize"
            case parquetTimestampInMillisecond = "ParquetTimestampInMillisecond"
            case parquetVersion = "ParquetVersion"
            case preserveTransactions = "PreserveTransactions"
            case rfc4180 = "Rfc4180"
            case rowGroupLength = "RowGroupLength"
            case serverSideEncryptionKmsKeyId = "ServerSideEncryptionKmsKeyId"
            case serviceAccessRoleArn = "ServiceAccessRoleArn"
            case timestampColumnName = "TimestampColumnName"
            case useCsvNoSupValue = "UseCsvNoSupValue"
            case useTaskStartTimeForFullLoadTimestamp = "UseTaskStartTimeForFullLoadTimestamp"
        }
    }

    public struct SCApplicationAttributes: AWSEncodableShape & AWSDecodableShape {
        /// The path for the Amazon S3 bucket that the application uses for exporting assessment reports.
        public let s3BucketPath: String?
        /// The ARN for the role the application uses to access its Amazon S3 bucket.
        public let s3BucketRoleArn: String?

        @inlinable
        public init(s3BucketPath: String? = nil, s3BucketRoleArn: String? = nil) {
            self.s3BucketPath = s3BucketPath
            self.s3BucketRoleArn = s3BucketRoleArn
        }

        private enum CodingKeys: String, CodingKey {
            case s3BucketPath = "S3BucketPath"
            case s3BucketRoleArn = "S3BucketRoleArn"
        }
    }

    public struct SchemaConversionRequest: AWSDecodableShape {
        public let error: ErrorDetails?
        public let exportSqlDetails: ExportSqlDetails?
        /// The migration project ARN.
        public let migrationProjectArn: String?
        /// The identifier for the schema conversion action.
        public let requestIdentifier: String?
        /// The schema conversion action status.
        public let status: String?

        @inlinable
        public init(error: ErrorDetails? = nil, exportSqlDetails: ExportSqlDetails? = nil, migrationProjectArn: String? = nil, requestIdentifier: String? = nil, status: String? = nil) {
            self.error = error
            self.exportSqlDetails = exportSqlDetails
            self.migrationProjectArn = migrationProjectArn
            self.requestIdentifier = requestIdentifier
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case error = "Error"
            case exportSqlDetails = "ExportSqlDetails"
            case migrationProjectArn = "MigrationProjectArn"
            case requestIdentifier = "RequestIdentifier"
            case status = "Status"
        }
    }

    public struct SchemaResponse: AWSDecodableShape {
        /// The number of lines of code in a schema in a Fleet Advisor collector inventory.
        public let codeLineCount: Int64?
        /// The size level of the code in a schema in a Fleet Advisor collector inventory.
        public let codeSize: Int64?
        /// The complexity level of the code in a schema in a Fleet Advisor collector inventory.
        public let complexity: String?
        /// The database for a schema in a Fleet Advisor collector inventory.
        public let databaseInstance: DatabaseShortInfoResponse?
        public let originalSchema: SchemaShortInfoResponse?
        /// The ID of a schema in a Fleet Advisor collector inventory.
        public let schemaId: String?
        /// The name of a schema in a Fleet Advisor collector inventory.
        public let schemaName: String?
        /// The database server for a schema in a Fleet Advisor collector inventory.
        public let server: ServerShortInfoResponse?
        /// The similarity value for a schema in a Fleet Advisor collector inventory. A higher similarity value indicates that a schema is likely to be a duplicate.
        public let similarity: Double?

        @inlinable
        public init(codeLineCount: Int64? = nil, codeSize: Int64? = nil, complexity: String? = nil, databaseInstance: DatabaseShortInfoResponse? = nil, originalSchema: SchemaShortInfoResponse? = nil, schemaId: String? = nil, schemaName: String? = nil, server: ServerShortInfoResponse? = nil, similarity: Double? = nil) {
            self.codeLineCount = codeLineCount
            self.codeSize = codeSize
            self.complexity = complexity
            self.databaseInstance = databaseInstance
            self.originalSchema = originalSchema
            self.schemaId = schemaId
            self.schemaName = schemaName
            self.server = server
            self.similarity = similarity
        }

        private enum CodingKeys: String, CodingKey {
            case codeLineCount = "CodeLineCount"
            case codeSize = "CodeSize"
            case complexity = "Complexity"
            case databaseInstance = "DatabaseInstance"
            case originalSchema = "OriginalSchema"
            case schemaId = "SchemaId"
            case schemaName = "SchemaName"
            case server = "Server"
            case similarity = "Similarity"
        }
    }

    public struct SchemaShortInfoResponse: AWSDecodableShape {
        /// The ID of a database in a Fleet Advisor collector inventory.
        public let databaseId: String?
        /// The IP address of a database in a Fleet Advisor collector inventory.
        public let databaseIpAddress: String?
        /// The name of a database in a Fleet Advisor collector inventory.
        public let databaseName: String?
        /// The ID of a schema in a Fleet Advisor collector inventory.
        public let schemaId: String?
        /// The name of a schema in a Fleet Advisor collector inventory.
        public let schemaName: String?

        @inlinable
        public init(databaseId: String? = nil, databaseIpAddress: String? = nil, databaseName: String? = nil, schemaId: String? = nil, schemaName: String? = nil) {
            self.databaseId = databaseId
            self.databaseIpAddress = databaseIpAddress
            self.databaseName = databaseName
            self.schemaId = schemaId
            self.schemaName = schemaName
        }

        private enum CodingKeys: String, CodingKey {
            case databaseId = "DatabaseId"
            case databaseIpAddress = "DatabaseIpAddress"
            case databaseName = "DatabaseName"
            case schemaId = "SchemaId"
            case schemaName = "SchemaName"
        }
    }

    public struct ServerShortInfoResponse: AWSDecodableShape {
        /// The IP address of a server in a Fleet Advisor collector inventory.
        public let ipAddress: String?
        /// The ID of a server in a Fleet Advisor collector inventory.
        public let serverId: String?
        /// The name address of a server in a Fleet Advisor collector inventory.
        public let serverName: String?

        @inlinable
        public init(ipAddress: String? = nil, serverId: String? = nil, serverName: String? = nil) {
            self.ipAddress = ipAddress
            self.serverId = serverId
            self.serverName = serverName
        }

        private enum CodingKeys: String, CodingKey {
            case ipAddress = "IpAddress"
            case serverId = "ServerId"
            case serverName = "ServerName"
        }
    }

    public struct SourceDataSetting: AWSEncodableShape & AWSDecodableShape {
        /// The change data capture (CDC) start position for the source data provider.
        public let cdcStartPosition: String?
        /// The change data capture (CDC) start time for the source data provider.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var cdcStartTime: Date?
        /// The change data capture (CDC) stop time for the source data provider.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var cdcStopTime: Date?
        /// The name of the replication slot on the source data provider. This attribute is only valid for a PostgreSQL or Aurora PostgreSQL source.
        public let slotName: String?

        @inlinable
        public init(cdcStartPosition: String? = nil, cdcStartTime: Date? = nil, cdcStopTime: Date? = nil, slotName: String? = nil) {
            self.cdcStartPosition = cdcStartPosition
            self.cdcStartTime = cdcStartTime
            self.cdcStopTime = cdcStopTime
            self.slotName = slotName
        }

        private enum CodingKeys: String, CodingKey {
            case cdcStartPosition = "CDCStartPosition"
            case cdcStartTime = "CDCStartTime"
            case cdcStopTime = "CDCStopTime"
            case slotName = "SlotName"
        }
    }

    public struct StartDataMigrationMessage: AWSEncodableShape {
        /// The identifier (name or ARN) of the data migration to start.
        public let dataMigrationIdentifier: String
        /// Specifies the start type for the data migration. Valid values include start-replication, reload-target, and resume-processing.
        public let startType: StartReplicationMigrationTypeValue

        @inlinable
        public init(dataMigrationIdentifier: String, startType: StartReplicationMigrationTypeValue) {
            self.dataMigrationIdentifier = dataMigrationIdentifier
            self.startType = startType
        }

        private enum CodingKeys: String, CodingKey {
            case dataMigrationIdentifier = "DataMigrationIdentifier"
            case startType = "StartType"
        }
    }

    public struct StartDataMigrationResponse: AWSDecodableShape {
        /// The data migration that DMS started.
        public let dataMigration: DataMigration?

        @inlinable
        public init(dataMigration: DataMigration? = nil) {
            self.dataMigration = dataMigration
        }

        private enum CodingKeys: String, CodingKey {
            case dataMigration = "DataMigration"
        }
    }

    public struct StartExtensionPackAssociationMessage: AWSEncodableShape {
        /// The migration project name or Amazon Resource Name (ARN).
        public let migrationProjectIdentifier: String

        @inlinable
        public init(migrationProjectIdentifier: String) {
            self.migrationProjectIdentifier = migrationProjectIdentifier
        }

        private enum CodingKeys: String, CodingKey {
            case migrationProjectIdentifier = "MigrationProjectIdentifier"
        }
    }

    public struct StartExtensionPackAssociationResponse: AWSDecodableShape {
        /// The identifier for the request operation.
        public let requestIdentifier: String?

        @inlinable
        public init(requestIdentifier: String? = nil) {
            self.requestIdentifier = requestIdentifier
        }

        private enum CodingKeys: String, CodingKey {
            case requestIdentifier = "RequestIdentifier"
        }
    }

    public struct StartMetadataModelAssessmentMessage: AWSEncodableShape {
        /// The migration project name or Amazon Resource Name (ARN).
        public let migrationProjectIdentifier: String
        /// A value that specifies the database objects to assess.
        public let selectionRules: String

        @inlinable
        public init(migrationProjectIdentifier: String, selectionRules: String) {
            self.migrationProjectIdentifier = migrationProjectIdentifier
            self.selectionRules = selectionRules
        }

        private enum CodingKeys: String, CodingKey {
            case migrationProjectIdentifier = "MigrationProjectIdentifier"
            case selectionRules = "SelectionRules"
        }
    }

    public struct StartMetadataModelAssessmentResponse: AWSDecodableShape {
        /// The identifier for the assessment operation.
        public let requestIdentifier: String?

        @inlinable
        public init(requestIdentifier: String? = nil) {
            self.requestIdentifier = requestIdentifier
        }

        private enum CodingKeys: String, CodingKey {
            case requestIdentifier = "RequestIdentifier"
        }
    }

    public struct StartMetadataModelConversionMessage: AWSEncodableShape {
        /// The migration project name or Amazon Resource Name (ARN).
        public let migrationProjectIdentifier: String
        /// A value that specifies the database objects to convert.
        public let selectionRules: String

        @inlinable
        public init(migrationProjectIdentifier: String, selectionRules: String) {
            self.migrationProjectIdentifier = migrationProjectIdentifier
            self.selectionRules = selectionRules
        }

        private enum CodingKeys: String, CodingKey {
            case migrationProjectIdentifier = "MigrationProjectIdentifier"
            case selectionRules = "SelectionRules"
        }
    }

    public struct StartMetadataModelConversionResponse: AWSDecodableShape {
        /// The identifier for the conversion operation.
        public let requestIdentifier: String?

        @inlinable
        public init(requestIdentifier: String? = nil) {
            self.requestIdentifier = requestIdentifier
        }

        private enum CodingKeys: String, CodingKey {
            case requestIdentifier = "RequestIdentifier"
        }
    }

    public struct StartMetadataModelExportAsScriptMessage: AWSEncodableShape {
        /// The name of the model file to create in the Amazon S3 bucket.
        public let fileName: String?
        /// The migration project name or Amazon Resource Name (ARN).
        public let migrationProjectIdentifier: String
        /// Whether to export the metadata model from the source or the target.
        public let origin: OriginTypeValue
        /// A value that specifies the database objects to export.
        public let selectionRules: String

        @inlinable
        public init(fileName: String? = nil, migrationProjectIdentifier: String, origin: OriginTypeValue, selectionRules: String) {
            self.fileName = fileName
            self.migrationProjectIdentifier = migrationProjectIdentifier
            self.origin = origin
            self.selectionRules = selectionRules
        }

        private enum CodingKeys: String, CodingKey {
            case fileName = "FileName"
            case migrationProjectIdentifier = "MigrationProjectIdentifier"
            case origin = "Origin"
            case selectionRules = "SelectionRules"
        }
    }

    public struct StartMetadataModelExportAsScriptResponse: AWSDecodableShape {
        /// The identifier for the export operation.
        public let requestIdentifier: String?

        @inlinable
        public init(requestIdentifier: String? = nil) {
            self.requestIdentifier = requestIdentifier
        }

        private enum CodingKeys: String, CodingKey {
            case requestIdentifier = "RequestIdentifier"
        }
    }

    public struct StartMetadataModelExportToTargetMessage: AWSEncodableShape {
        /// The migration project name or Amazon Resource Name (ARN).
        public let migrationProjectIdentifier: String
        /// Whether to overwrite the migration project extension pack. An extension pack is an add-on module  that emulates functions present in a source database that are required when converting objects  to the target database.
        public let overwriteExtensionPack: Bool?
        /// A value that specifies the database objects to export.
        public let selectionRules: String

        @inlinable
        public init(migrationProjectIdentifier: String, overwriteExtensionPack: Bool? = nil, selectionRules: String) {
            self.migrationProjectIdentifier = migrationProjectIdentifier
            self.overwriteExtensionPack = overwriteExtensionPack
            self.selectionRules = selectionRules
        }

        private enum CodingKeys: String, CodingKey {
            case migrationProjectIdentifier = "MigrationProjectIdentifier"
            case overwriteExtensionPack = "OverwriteExtensionPack"
            case selectionRules = "SelectionRules"
        }
    }

    public struct StartMetadataModelExportToTargetResponse: AWSDecodableShape {
        /// The identifier for the export operation.
        public let requestIdentifier: String?

        @inlinable
        public init(requestIdentifier: String? = nil) {
            self.requestIdentifier = requestIdentifier
        }

        private enum CodingKeys: String, CodingKey {
            case requestIdentifier = "RequestIdentifier"
        }
    }

    public struct StartMetadataModelImportMessage: AWSEncodableShape {
        /// The migration project name or Amazon Resource Name (ARN).
        public let migrationProjectIdentifier: String
        /// Whether to load metadata to the source or target database.
        public let origin: OriginTypeValue
        /// If true, DMS loads metadata for the specified objects from the source database.
        public let refresh: Bool?
        /// A value that specifies the database objects to import.
        public let selectionRules: String

        @inlinable
        public init(migrationProjectIdentifier: String, origin: OriginTypeValue, refresh: Bool? = nil, selectionRules: String) {
            self.migrationProjectIdentifier = migrationProjectIdentifier
            self.origin = origin
            self.refresh = refresh
            self.selectionRules = selectionRules
        }

        private enum CodingKeys: String, CodingKey {
            case migrationProjectIdentifier = "MigrationProjectIdentifier"
            case origin = "Origin"
            case refresh = "Refresh"
            case selectionRules = "SelectionRules"
        }
    }

    public struct StartMetadataModelImportResponse: AWSDecodableShape {
        /// The identifier for the import operation.
        public let requestIdentifier: String?

        @inlinable
        public init(requestIdentifier: String? = nil) {
            self.requestIdentifier = requestIdentifier
        }

        private enum CodingKeys: String, CodingKey {
            case requestIdentifier = "RequestIdentifier"
        }
    }

    public struct StartRecommendationsRequest: AWSEncodableShape {
        /// The identifier of the source database to analyze and provide recommendations for.
        public let databaseId: String
        /// The settings in JSON format that Fleet Advisor uses to determine target engine recommendations. These parameters include target instance sizing and availability and durability settings. For target instance sizing, Fleet Advisor supports the following two options: total capacity and resource utilization. For availability and durability, Fleet Advisor supports the following two options: production (Multi-AZ deployments) and Dev/Test (Single-AZ deployments).
        public let settings: RecommendationSettings

        @inlinable
        public init(databaseId: String, settings: RecommendationSettings) {
            self.databaseId = databaseId
            self.settings = settings
        }

        private enum CodingKeys: String, CodingKey {
            case databaseId = "DatabaseId"
            case settings = "Settings"
        }
    }

    public struct StartRecommendationsRequestEntry: AWSEncodableShape {
        /// The identifier of the source database.
        public let databaseId: String
        /// The required target engine settings.
        public let settings: RecommendationSettings

        @inlinable
        public init(databaseId: String, settings: RecommendationSettings) {
            self.databaseId = databaseId
            self.settings = settings
        }

        private enum CodingKeys: String, CodingKey {
            case databaseId = "DatabaseId"
            case settings = "Settings"
        }
    }

    public struct StartReplicationMessage: AWSEncodableShape {
        /// Indicates when you want a change data capture (CDC) operation to start. Use either CdcStartPosition or CdcStartTime to specify when you want a CDC operation to start. Specifying both values results in an error. The value can be in date, checkpoint, or LSN/SCN format.
        public let cdcStartPosition: String?
        /// Indicates the start time for a change data capture (CDC) operation. Use either CdcStartTime or CdcStartPosition to specify when you want a CDC operation to start. Specifying both values results in an error.
        public let cdcStartTime: Date?
        /// Indicates when you want a change data capture (CDC) operation to stop. The value can be either server time or commit time.
        public let cdcStopPosition: String?
        /// User-defined settings for the premigration assessment. The possible values are:    ResultLocationFolder: The folder within an Amazon S3 bucket where you want DMS to store the results of this assessment run.    ResultEncryptionMode: The supported values are SSE_KMS and SSE_S3. If these values are not provided, then the files are not encrypted at rest. For more information, see Creating Amazon Web Services KMS keys to encrypt Amazon S3 target objects.    ResultKmsKeyArn: The ARN of a customer KMS encryption key that you specify when you set ResultEncryptionMode to SSE_KMS.    IncludeOnly: A space-separated list of names for specific individual assessments that you want to include. These names come from the default list of individual assessments that Database Migration Service supports for the associated migration.    Exclude: A space-separated list of names for specific individual assessments that you want to exclude. These names come from the default list of individual assessments that Database Migration Service supports for the associated migration.    FailOnAssessmentFailure: A configurable setting you can set to true (the default setting) or false. Use this setting to to stop the replication from starting automatically if the assessment fails. This can help you evaluate the issue that is preventing the replication from running successfully.
        public let premigrationAssessmentSettings: String?
        /// The Amazon Resource Name of the replication for which to start replication.
        public let replicationConfigArn: String
        /// The replication type. When the replication type is full-load or full-load-and-cdc, the only valid value for the first run of the replication is start-replication. This option will start the replication. You can also use ReloadTables to reload specific tables that failed during replication instead of restarting the replication. The resume-processing option isn't applicable for a full-load replication, because you can't resume partially loaded tables during the full load phase. For a full-load-and-cdc replication, DMS migrates table data, and then applies data changes that occur on the source. To load all the tables again, and start capturing source changes, use reload-target. Otherwise use resume-processing, to replicate the changes from the last stop position.
        public let startReplicationType: String

        @inlinable
        public init(cdcStartPosition: String? = nil, cdcStartTime: Date? = nil, cdcStopPosition: String? = nil, premigrationAssessmentSettings: String? = nil, replicationConfigArn: String, startReplicationType: String) {
            self.cdcStartPosition = cdcStartPosition
            self.cdcStartTime = cdcStartTime
            self.cdcStopPosition = cdcStopPosition
            self.premigrationAssessmentSettings = premigrationAssessmentSettings
            self.replicationConfigArn = replicationConfigArn
            self.startReplicationType = startReplicationType
        }

        private enum CodingKeys: String, CodingKey {
            case cdcStartPosition = "CdcStartPosition"
            case cdcStartTime = "CdcStartTime"
            case cdcStopPosition = "CdcStopPosition"
            case premigrationAssessmentSettings = "PremigrationAssessmentSettings"
            case replicationConfigArn = "ReplicationConfigArn"
            case startReplicationType = "StartReplicationType"
        }
    }

    public struct StartReplicationResponse: AWSDecodableShape {
        /// The replication that DMS started.
        public let replication: Replication?

        @inlinable
        public init(replication: Replication? = nil) {
            self.replication = replication
        }

        private enum CodingKeys: String, CodingKey {
            case replication = "Replication"
        }
    }

    public struct StartReplicationTaskAssessmentMessage: AWSEncodableShape {
        ///  The Amazon Resource Name (ARN) of the replication task.
        public let replicationTaskArn: String

        @inlinable
        public init(replicationTaskArn: String) {
            self.replicationTaskArn = replicationTaskArn
        }

        private enum CodingKeys: String, CodingKey {
            case replicationTaskArn = "ReplicationTaskArn"
        }
    }

    public struct StartReplicationTaskAssessmentResponse: AWSDecodableShape {
        ///  The assessed replication task.
        public let replicationTask: ReplicationTask?

        @inlinable
        public init(replicationTask: ReplicationTask? = nil) {
            self.replicationTask = replicationTask
        }

        private enum CodingKeys: String, CodingKey {
            case replicationTask = "ReplicationTask"
        }
    }

    public struct StartReplicationTaskAssessmentRunMessage: AWSEncodableShape {
        /// Unique name to identify the assessment run.
        public let assessmentRunName: String
        /// Space-separated list of names for specific individual assessments that you want to exclude. These names come from the default list of individual assessments that DMS supports for the associated migration task. This task is specified by ReplicationTaskArn.  You can't set a value for Exclude if you also set a value for IncludeOnly in the API operation. To identify the names of the default individual assessments that DMS supports for the associated migration task, run the DescribeApplicableIndividualAssessments operation using its own ReplicationTaskArn request parameter.
        public let exclude: [String]?
        /// Space-separated list of names for specific individual assessments that you want to include. These names come from the default list of individual assessments that DMS supports for the associated migration task. This task is specified by ReplicationTaskArn.  You can't set a value for IncludeOnly if you also set a value for Exclude in the API operation.  To identify the names of the default individual assessments that DMS supports for the associated migration task, run the DescribeApplicableIndividualAssessments operation using its own ReplicationTaskArn request parameter.
        public let includeOnly: [String]?
        /// Amazon Resource Name (ARN) of the migration task associated with the premigration assessment run that you want to start.
        public let replicationTaskArn: String
        /// Encryption mode that you can specify to encrypt the results of this assessment run. If you don't specify this request parameter, DMS stores the assessment run results without encryption. You can specify one of the options following:    "SSE_S3"  The server-side encryption provided as a default by Amazon S3.    "SSE_KMS"  Key Management Service (KMS) encryption. This encryption can use either a custom KMS encryption key that you specify or the default KMS encryption key that DMS provides.
        public let resultEncryptionMode: String?
        /// ARN of a custom KMS encryption key that you specify when you set ResultEncryptionMode to "SSE_KMS".
        public let resultKmsKeyArn: String?
        /// Amazon S3 bucket where you want DMS to store the results of this assessment run.
        public let resultLocationBucket: String
        /// Folder within an Amazon S3 bucket where you want DMS to store the results of this assessment run.
        public let resultLocationFolder: String?
        /// ARN of the service role needed to start the assessment run. The role must allow the iam:PassRole action.
        public let serviceAccessRoleArn: String
        /// One or more tags to be assigned to the premigration assessment run that you want to start.
        public let tags: [Tag]?

        @inlinable
        public init(assessmentRunName: String, exclude: [String]? = nil, includeOnly: [String]? = nil, replicationTaskArn: String, resultEncryptionMode: String? = nil, resultKmsKeyArn: String? = nil, resultLocationBucket: String, resultLocationFolder: String? = nil, serviceAccessRoleArn: String, tags: [Tag]? = nil) {
            self.assessmentRunName = assessmentRunName
            self.exclude = exclude
            self.includeOnly = includeOnly
            self.replicationTaskArn = replicationTaskArn
            self.resultEncryptionMode = resultEncryptionMode
            self.resultKmsKeyArn = resultKmsKeyArn
            self.resultLocationBucket = resultLocationBucket
            self.resultLocationFolder = resultLocationFolder
            self.serviceAccessRoleArn = serviceAccessRoleArn
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case assessmentRunName = "AssessmentRunName"
            case exclude = "Exclude"
            case includeOnly = "IncludeOnly"
            case replicationTaskArn = "ReplicationTaskArn"
            case resultEncryptionMode = "ResultEncryptionMode"
            case resultKmsKeyArn = "ResultKmsKeyArn"
            case resultLocationBucket = "ResultLocationBucket"
            case resultLocationFolder = "ResultLocationFolder"
            case serviceAccessRoleArn = "ServiceAccessRoleArn"
            case tags = "Tags"
        }
    }

    public struct StartReplicationTaskAssessmentRunResponse: AWSDecodableShape {
        /// The premigration assessment run that was started.
        public let replicationTaskAssessmentRun: ReplicationTaskAssessmentRun?

        @inlinable
        public init(replicationTaskAssessmentRun: ReplicationTaskAssessmentRun? = nil) {
            self.replicationTaskAssessmentRun = replicationTaskAssessmentRun
        }

        private enum CodingKeys: String, CodingKey {
            case replicationTaskAssessmentRun = "ReplicationTaskAssessmentRun"
        }
    }

    public struct StartReplicationTaskMessage: AWSEncodableShape {
        /// Indicates when you want a change data capture (CDC) operation to start. Use either CdcStartPosition or CdcStartTime to specify when you want a CDC operation to start. Specifying both values results in an error. The value can be in date, checkpoint, or LSN/SCN format. Date Example: --cdc-start-position 2018-03-08T12:12:12 Checkpoint Example: --cdc-start-position "checkpoint:V1#27#mysql-bin-changelog.157832:1975:-1:2002:677883278264080:mysql-bin-changelog.157832:1876#0#0#*#0#93" LSN Example: --cdc-start-position mysql-bin-changelog.000024:373  When you use this task setting with a source PostgreSQL database, a logical replication slot should already be created and associated with the source endpoint. You can verify this by setting the slotName extra connection attribute to the name of this logical replication slot. For more information, see Extra Connection Attributes When Using PostgreSQL as a Source for DMS.
        public let cdcStartPosition: String?
        /// Indicates the start time for a change data capture (CDC) operation. Use either CdcStartTime or CdcStartPosition to specify when you want a CDC operation to start. Specifying both values results in an error. Timestamp Example: --cdc-start-time 2018-03-08T12:12:12
        public let cdcStartTime: Date?
        /// Indicates when you want a change data capture (CDC) operation to stop. The value can be either server time or commit time. Server time example: --cdc-stop-position server_time:2018-02-09T12:12:12 Commit time example: --cdc-stop-position commit_time:2018-02-09T12:12:12
        public let cdcStopPosition: String?
        /// The Amazon Resource Name (ARN) of the replication task to be started.
        public let replicationTaskArn: String
        /// The type of replication task to start. When the migration type is full-load or full-load-and-cdc, the only valid value for the first run of the task is start-replication. This option will start the migration. You can also use ReloadTables to reload specific tables that failed during migration instead of restarting the task. The resume-processing option isn't applicable for a full-load task, because you can't resume partially loaded tables during the full load phase. For a full-load-and-cdc task, DMS migrates table data, and then applies data changes that occur on the source. To load all the tables again, and start capturing source changes, use reload-target. Otherwise use resume-processing, to replicate the changes from the last stop position.
        public let startReplicationTaskType: StartReplicationTaskTypeValue

        @inlinable
        public init(cdcStartPosition: String? = nil, cdcStartTime: Date? = nil, cdcStopPosition: String? = nil, replicationTaskArn: String, startReplicationTaskType: StartReplicationTaskTypeValue) {
            self.cdcStartPosition = cdcStartPosition
            self.cdcStartTime = cdcStartTime
            self.cdcStopPosition = cdcStopPosition
            self.replicationTaskArn = replicationTaskArn
            self.startReplicationTaskType = startReplicationTaskType
        }

        private enum CodingKeys: String, CodingKey {
            case cdcStartPosition = "CdcStartPosition"
            case cdcStartTime = "CdcStartTime"
            case cdcStopPosition = "CdcStopPosition"
            case replicationTaskArn = "ReplicationTaskArn"
            case startReplicationTaskType = "StartReplicationTaskType"
        }
    }

    public struct StartReplicationTaskResponse: AWSDecodableShape {
        /// The replication task started.
        public let replicationTask: ReplicationTask?

        @inlinable
        public init(replicationTask: ReplicationTask? = nil) {
            self.replicationTask = replicationTask
        }

        private enum CodingKeys: String, CodingKey {
            case replicationTask = "ReplicationTask"
        }
    }

    public struct StopDataMigrationMessage: AWSEncodableShape {
        /// The identifier (name or ARN) of the data migration to stop.
        public let dataMigrationIdentifier: String

        @inlinable
        public init(dataMigrationIdentifier: String) {
            self.dataMigrationIdentifier = dataMigrationIdentifier
        }

        private enum CodingKeys: String, CodingKey {
            case dataMigrationIdentifier = "DataMigrationIdentifier"
        }
    }

    public struct StopDataMigrationResponse: AWSDecodableShape {
        /// The data migration that DMS stopped.
        public let dataMigration: DataMigration?

        @inlinable
        public init(dataMigration: DataMigration? = nil) {
            self.dataMigration = dataMigration
        }

        private enum CodingKeys: String, CodingKey {
            case dataMigration = "DataMigration"
        }
    }

    public struct StopReplicationMessage: AWSEncodableShape {
        /// The Amazon Resource Name of the replication to stop.
        public let replicationConfigArn: String

        @inlinable
        public init(replicationConfigArn: String) {
            self.replicationConfigArn = replicationConfigArn
        }

        private enum CodingKeys: String, CodingKey {
            case replicationConfigArn = "ReplicationConfigArn"
        }
    }

    public struct StopReplicationResponse: AWSDecodableShape {
        /// The replication that DMS stopped.
        public let replication: Replication?

        @inlinable
        public init(replication: Replication? = nil) {
            self.replication = replication
        }

        private enum CodingKeys: String, CodingKey {
            case replication = "Replication"
        }
    }

    public struct StopReplicationTaskMessage: AWSEncodableShape {
        /// The Amazon Resource Name(ARN) of the replication task to be stopped.
        public let replicationTaskArn: String

        @inlinable
        public init(replicationTaskArn: String) {
            self.replicationTaskArn = replicationTaskArn
        }

        private enum CodingKeys: String, CodingKey {
            case replicationTaskArn = "ReplicationTaskArn"
        }
    }

    public struct StopReplicationTaskResponse: AWSDecodableShape {
        /// The replication task stopped.
        public let replicationTask: ReplicationTask?

        @inlinable
        public init(replicationTask: ReplicationTask? = nil) {
            self.replicationTask = replicationTask
        }

        private enum CodingKeys: String, CodingKey {
            case replicationTask = "ReplicationTask"
        }
    }

    public struct Subnet: AWSDecodableShape {
        /// The Availability Zone of the subnet.
        public let subnetAvailabilityZone: AvailabilityZone?
        /// The subnet identifier.
        public let subnetIdentifier: String?
        /// The status of the subnet.
        public let subnetStatus: String?

        @inlinable
        public init(subnetAvailabilityZone: AvailabilityZone? = nil, subnetIdentifier: String? = nil, subnetStatus: String? = nil) {
            self.subnetAvailabilityZone = subnetAvailabilityZone
            self.subnetIdentifier = subnetIdentifier
            self.subnetStatus = subnetStatus
        }

        private enum CodingKeys: String, CodingKey {
            case subnetAvailabilityZone = "SubnetAvailabilityZone"
            case subnetIdentifier = "SubnetIdentifier"
            case subnetStatus = "SubnetStatus"
        }
    }

    public struct SupportedEndpointType: AWSDecodableShape {
        /// The type of endpoint. Valid values are source and target.
        public let endpointType: ReplicationEndpointTypeValue?
        /// The expanded name for the engine name. For example, if the EngineName parameter is "aurora", this value would be "Amazon Aurora MySQL".
        public let engineDisplayName: String?
        /// The database engine name. Valid values, depending on the EndpointType, include "mysql", "oracle", "postgres", "mariadb", "aurora", "aurora-postgresql", "redshift", "s3", "db2", "db2-zos", "azuredb", "sybase", "dynamodb", "mongodb", "kinesis", "kafka", "elasticsearch", "documentdb", "sqlserver", "neptune", and "babelfish".
        public let engineName: String?
        /// The earliest DMS engine version that supports this endpoint engine. Note that endpoint engines released with DMS versions earlier than 3.1.1 do not return a value for this parameter.
        public let replicationInstanceEngineMinimumVersion: String?
        /// Indicates if change data capture (CDC) is supported.
        public let supportsCDC: Bool?

        @inlinable
        public init(endpointType: ReplicationEndpointTypeValue? = nil, engineDisplayName: String? = nil, engineName: String? = nil, replicationInstanceEngineMinimumVersion: String? = nil, supportsCDC: Bool? = nil) {
            self.endpointType = endpointType
            self.engineDisplayName = engineDisplayName
            self.engineName = engineName
            self.replicationInstanceEngineMinimumVersion = replicationInstanceEngineMinimumVersion
            self.supportsCDC = supportsCDC
        }

        private enum CodingKeys: String, CodingKey {
            case endpointType = "EndpointType"
            case engineDisplayName = "EngineDisplayName"
            case engineName = "EngineName"
            case replicationInstanceEngineMinimumVersion = "ReplicationInstanceEngineMinimumVersion"
            case supportsCDC = "SupportsCDC"
        }
    }

    public struct SybaseSettings: AWSEncodableShape & AWSDecodableShape {
        /// Database name for the endpoint.
        public let databaseName: String?
        /// Endpoint connection password.
        public let password: String?
        /// Endpoint TCP port. The default is 5000.
        public let port: Int?
        /// The full Amazon Resource Name (ARN) of the IAM role that specifies DMS as the trusted entity and grants the required permissions to access the value in SecretsManagerSecret. The role must allow the iam:PassRole action. SecretsManagerSecret has the value of the Amazon Web Services Secrets Manager secret that allows access to the SAP ASE endpoint.  You can specify one of two sets of values for these permissions. You can specify the values for this setting and SecretsManagerSecretId. Or you can specify clear-text values for UserName, Password, ServerName, and Port. You can't specify both. For more information on creating this SecretsManagerSecret and the SecretsManagerAccessRoleArn and SecretsManagerSecretId required to access it, see Using secrets to access Database Migration Service resources in the Database Migration Service User Guide.
        public let secretsManagerAccessRoleArn: String?
        /// The full ARN, partial ARN, or friendly name of the SecretsManagerSecret that contains the SAP SAE endpoint connection details.
        public let secretsManagerSecretId: String?
        /// Fully qualified domain name of the endpoint.
        public let serverName: String?
        /// Endpoint connection user name.
        public let username: String?

        @inlinable
        public init(databaseName: String? = nil, password: String? = nil, port: Int? = nil, secretsManagerAccessRoleArn: String? = nil, secretsManagerSecretId: String? = nil, serverName: String? = nil, username: String? = nil) {
            self.databaseName = databaseName
            self.password = password
            self.port = port
            self.secretsManagerAccessRoleArn = secretsManagerAccessRoleArn
            self.secretsManagerSecretId = secretsManagerSecretId
            self.serverName = serverName
            self.username = username
        }

        private enum CodingKeys: String, CodingKey {
            case databaseName = "DatabaseName"
            case password = "Password"
            case port = "Port"
            case secretsManagerAccessRoleArn = "SecretsManagerAccessRoleArn"
            case secretsManagerSecretId = "SecretsManagerSecretId"
            case serverName = "ServerName"
            case username = "Username"
        }
    }

    public struct TableStatistics: AWSDecodableShape {
        /// The number of data definition language (DDL) statements used to build and modify the structure of your tables applied on the target.
        public let appliedDdls: Int64?
        /// The number of delete actions applied on a target table.
        public let appliedDeletes: Int64?
        /// The number of insert actions applied on a target table.
        public let appliedInserts: Int64?
        /// The number of update actions applied on a target table.
        public let appliedUpdates: Int64?
        /// The data definition language (DDL) used to build and modify the structure of your tables.
        public let ddls: Int64?
        /// The number of delete actions performed on a table.
        public let deletes: Int64?
        /// The number of rows that failed conditional checks during the full load operation (valid only for migrations where DynamoDB is the target).
        public let fullLoadCondtnlChkFailedRows: Int64?
        /// The time when the full load operation completed.
        public let fullLoadEndTime: Date?
        /// The number of rows that failed to load during the full load operation (valid only for migrations where DynamoDB is the target).
        public let fullLoadErrorRows: Int64?
        /// A value that indicates if the table was reloaded (true) or loaded as part of a new full load operation (false).
        public let fullLoadReloaded: Bool?
        /// The number of rows added during the full load operation.
        public let fullLoadRows: Int64?
        /// The time when the full load operation started.
        public let fullLoadStartTime: Date?
        /// The number of insert actions performed on a table.
        public let inserts: Int64?
        /// The last time a table was updated.
        public let lastUpdateTime: Date?
        /// The schema name.
        public let schemaName: String?
        /// The name of the table.
        public let tableName: String?
        /// The state of the tables described. Valid states: Table does not exist | Before load | Full load | Table completed | Table cancelled | Table error | Table is being reloaded
        public let tableState: String?
        /// The number of update actions performed on a table.
        public let updates: Int64?
        /// The number of records that failed validation.
        public let validationFailedRecords: Int64?
        /// The number of records that have yet to be validated.
        public let validationPendingRecords: Int64?
        /// The validation state of the table. This parameter can have the following values:   Not enabled  Validation isn't enabled for the table in the migration task.   Pending records  Some records in the table are waiting for validation.   Mismatched records  Some records in the table don't match between the source and target.   Suspended records  Some records in the table couldn't be validated.   No primary key The table couldn't be validated because it has no primary key.   Table error  The table wasn't validated because it's in an error state and some data wasn't migrated.   Validated  All rows in the table are validated. If the table is updated, the status can change from Validated.   Error  The table couldn't be validated because of an unexpected error.   Pending validation  The table is waiting validation.   Preparing table  Preparing the table enabled in the migration task for validation.   Pending revalidation  All rows in the table are pending validation after the table was updated.
        public let validationState: String?
        /// Additional details about the state of validation.
        public let validationStateDetails: String?
        /// The number of records that couldn't be validated.
        public let validationSuspendedRecords: Int64?

        @inlinable
        public init(appliedDdls: Int64? = nil, appliedDeletes: Int64? = nil, appliedInserts: Int64? = nil, appliedUpdates: Int64? = nil, ddls: Int64? = nil, deletes: Int64? = nil, fullLoadCondtnlChkFailedRows: Int64? = nil, fullLoadEndTime: Date? = nil, fullLoadErrorRows: Int64? = nil, fullLoadReloaded: Bool? = nil, fullLoadRows: Int64? = nil, fullLoadStartTime: Date? = nil, inserts: Int64? = nil, lastUpdateTime: Date? = nil, schemaName: String? = nil, tableName: String? = nil, tableState: String? = nil, updates: Int64? = nil, validationFailedRecords: Int64? = nil, validationPendingRecords: Int64? = nil, validationState: String? = nil, validationStateDetails: String? = nil, validationSuspendedRecords: Int64? = nil) {
            self.appliedDdls = appliedDdls
            self.appliedDeletes = appliedDeletes
            self.appliedInserts = appliedInserts
            self.appliedUpdates = appliedUpdates
            self.ddls = ddls
            self.deletes = deletes
            self.fullLoadCondtnlChkFailedRows = fullLoadCondtnlChkFailedRows
            self.fullLoadEndTime = fullLoadEndTime
            self.fullLoadErrorRows = fullLoadErrorRows
            self.fullLoadReloaded = fullLoadReloaded
            self.fullLoadRows = fullLoadRows
            self.fullLoadStartTime = fullLoadStartTime
            self.inserts = inserts
            self.lastUpdateTime = lastUpdateTime
            self.schemaName = schemaName
            self.tableName = tableName
            self.tableState = tableState
            self.updates = updates
            self.validationFailedRecords = validationFailedRecords
            self.validationPendingRecords = validationPendingRecords
            self.validationState = validationState
            self.validationStateDetails = validationStateDetails
            self.validationSuspendedRecords = validationSuspendedRecords
        }

        private enum CodingKeys: String, CodingKey {
            case appliedDdls = "AppliedDdls"
            case appliedDeletes = "AppliedDeletes"
            case appliedInserts = "AppliedInserts"
            case appliedUpdates = "AppliedUpdates"
            case ddls = "Ddls"
            case deletes = "Deletes"
            case fullLoadCondtnlChkFailedRows = "FullLoadCondtnlChkFailedRows"
            case fullLoadEndTime = "FullLoadEndTime"
            case fullLoadErrorRows = "FullLoadErrorRows"
            case fullLoadReloaded = "FullLoadReloaded"
            case fullLoadRows = "FullLoadRows"
            case fullLoadStartTime = "FullLoadStartTime"
            case inserts = "Inserts"
            case lastUpdateTime = "LastUpdateTime"
            case schemaName = "SchemaName"
            case tableName = "TableName"
            case tableState = "TableState"
            case updates = "Updates"
            case validationFailedRecords = "ValidationFailedRecords"
            case validationPendingRecords = "ValidationPendingRecords"
            case validationState = "ValidationState"
            case validationStateDetails = "ValidationStateDetails"
            case validationSuspendedRecords = "ValidationSuspendedRecords"
        }
    }

    public struct TableToReload: AWSEncodableShape {
        /// The schema name of the table to be reloaded.
        public let schemaName: String
        /// The table name of the table to be reloaded.
        public let tableName: String

        @inlinable
        public init(schemaName: String, tableName: String) {
            self.schemaName = schemaName
            self.tableName = tableName
        }

        private enum CodingKeys: String, CodingKey {
            case schemaName = "SchemaName"
            case tableName = "TableName"
        }
    }

    public struct Tag: AWSEncodableShape & AWSDecodableShape {
        /// A key is the required name of the tag. The string value can be 1-128 Unicode characters in length and can't be prefixed with "aws:" or "dms:". The string can only contain only the set of Unicode letters, digits, white-space, '_', '.', '/', '=', '+', '-' (Java regular expressions: "^([\\p{L}\\p{Z}\\p{N}_.:/=+\\-]*)$").
        public let key: String?
        /// The Amazon Resource Name (ARN) string that uniquely identifies the resource for which the tag is created.
        public let resourceArn: String?
        /// A value is the optional value of the tag. The string value can be 1-256 Unicode characters in length and can't be prefixed with "aws:" or "dms:". The string can only contain only the set of Unicode letters, digits, white-space, '_', '.', '/', '=', '+', '-' (Java regular expressions: "^([\\p{L}\\p{Z}\\p{N}_.:/=+\\-]*)$").
        public let value: String?

        @inlinable
        public init(key: String? = nil, resourceArn: String? = nil, value: String? = nil) {
            self.key = key
            self.resourceArn = resourceArn
            self.value = value
        }

        private enum CodingKeys: String, CodingKey {
            case key = "Key"
            case resourceArn = "ResourceArn"
            case value = "Value"
        }
    }

    public struct TargetDataSetting: AWSEncodableShape & AWSDecodableShape {
        /// This setting determines how DMS handles the target tables before starting a data migration, either by leaving them untouched, dropping and recreating them, or truncating the existing data in the target tables.
        public let tablePreparationMode: TablePreparationMode?

        @inlinable
        public init(tablePreparationMode: TablePreparationMode? = nil) {
            self.tablePreparationMode = tablePreparationMode
        }

        private enum CodingKeys: String, CodingKey {
            case tablePreparationMode = "TablePreparationMode"
        }
    }

    public struct TestConnectionMessage: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) string that uniquely identifies the endpoint.
        public let endpointArn: String
        /// The Amazon Resource Name (ARN) of the replication instance.
        public let replicationInstanceArn: String

        @inlinable
        public init(endpointArn: String, replicationInstanceArn: String) {
            self.endpointArn = endpointArn
            self.replicationInstanceArn = replicationInstanceArn
        }

        private enum CodingKeys: String, CodingKey {
            case endpointArn = "EndpointArn"
            case replicationInstanceArn = "ReplicationInstanceArn"
        }
    }

    public struct TestConnectionResponse: AWSDecodableShape {
        /// The connection tested.
        public let connection: Connection?

        @inlinable
        public init(connection: Connection? = nil) {
            self.connection = connection
        }

        private enum CodingKeys: String, CodingKey {
            case connection = "Connection"
        }
    }

    public struct TimestreamSettings: AWSEncodableShape & AWSDecodableShape {
        /// Set this attribute to true to specify that DMS only applies inserts and updates, and not deletes. Amazon Timestream does not allow deleting records, so if this value is false, DMS nulls out the corresponding record in the Timestream database rather than deleting it.
        public let cdcInsertsAndUpdates: Bool?
        /// Database name for the endpoint.
        public let databaseName: String
        /// Set this attribute to true to enable memory store writes. When this value is false, DMS does not write records that are older in days than the value specified in MagneticDuration, because Amazon Timestream does not allow memory writes by default. For more information, see Storage in the Amazon Timestream Developer Guide.
        public let enableMagneticStoreWrites: Bool?
        /// Set this attribute to specify the default magnetic duration applied to the Amazon Timestream tables in days. This is the number of days that records remain in magnetic store before being discarded. For more information, see Storage in the Amazon Timestream Developer Guide.
        public let magneticDuration: Int
        /// Set this attribute to specify the length of time to store all of the tables in memory that are migrated into Amazon Timestream from the source database. Time is measured in units of hours. When Timestream data comes in, it first resides in memory for the specified duration, which allows quick access to it.
        public let memoryDuration: Int

        @inlinable
        public init(cdcInsertsAndUpdates: Bool? = nil, databaseName: String, enableMagneticStoreWrites: Bool? = nil, magneticDuration: Int, memoryDuration: Int) {
            self.cdcInsertsAndUpdates = cdcInsertsAndUpdates
            self.databaseName = databaseName
            self.enableMagneticStoreWrites = enableMagneticStoreWrites
            self.magneticDuration = magneticDuration
            self.memoryDuration = memoryDuration
        }

        private enum CodingKeys: String, CodingKey {
            case cdcInsertsAndUpdates = "CdcInsertsAndUpdates"
            case databaseName = "DatabaseName"
            case enableMagneticStoreWrites = "EnableMagneticStoreWrites"
            case magneticDuration = "MagneticDuration"
            case memoryDuration = "MemoryDuration"
        }
    }

    public struct UpdateSubscriptionsToEventBridgeMessage: AWSEncodableShape {
        /// When set to true, this operation migrates DMS subscriptions for Amazon SNS notifications no matter what your replication instance version is. If not set or set to false, this operation runs only when all your replication instances are from DMS version 3.4.5 or higher.
        public let forceMove: Bool?

        @inlinable
        public init(forceMove: Bool? = nil) {
            self.forceMove = forceMove
        }

        private enum CodingKeys: String, CodingKey {
            case forceMove = "ForceMove"
        }
    }

    public struct UpdateSubscriptionsToEventBridgeResponse: AWSDecodableShape {
        /// A string that indicates how many event subscriptions were migrated and how many remain to be migrated.
        public let result: String?

        @inlinable
        public init(result: String? = nil) {
            self.result = result
        }

        private enum CodingKeys: String, CodingKey {
            case result = "Result"
        }
    }

    public struct VpcSecurityGroupMembership: AWSDecodableShape {
        /// The status of the VPC security group.
        public let status: String?
        /// The VPC security group ID.
        public let vpcSecurityGroupId: String?

        @inlinable
        public init(status: String? = nil, vpcSecurityGroupId: String? = nil) {
            self.status = status
            self.vpcSecurityGroupId = vpcSecurityGroupId
        }

        private enum CodingKeys: String, CodingKey {
            case status = "Status"
            case vpcSecurityGroupId = "VpcSecurityGroupId"
        }
    }

    public struct ErrorDetails: AWSDecodableShape {
        /// Error information about a project.
        public let defaultErrorDetails: DefaultErrorDetails?

        @inlinable
        public init(defaultErrorDetails: DefaultErrorDetails? = nil) {
            self.defaultErrorDetails = defaultErrorDetails
        }

        private enum CodingKeys: String, CodingKey {
            case defaultErrorDetails = "defaultErrorDetails"
        }
    }
}

// MARK: - Errors

/// Error enum for DatabaseMigrationService
public struct DatabaseMigrationServiceErrorType: AWSErrorType {
    enum Code: String {
        case accessDeniedFault = "AccessDeniedFault"
        case collectorNotFoundFault = "CollectorNotFoundFault"
        case failedDependencyFault = "FailedDependencyFault"
        case insufficientResourceCapacityFault = "InsufficientResourceCapacityFault"
        case invalidCertificateFault = "InvalidCertificateFault"
        case invalidOperationFault = "InvalidOperationFault"
        case invalidResourceStateFault = "InvalidResourceStateFault"
        case invalidSubnet = "InvalidSubnet"
        case kmsAccessDeniedFault = "KMSAccessDeniedFault"
        case kmsDisabledFault = "KMSDisabledFault"
        case kmsFault = "KMSFault"
        case kmsInvalidStateFault = "KMSInvalidStateFault"
        case kmsKeyNotAccessibleFault = "KMSKeyNotAccessibleFault"
        case kmsNotFoundFault = "KMSNotFoundFault"
        case kmsThrottlingFault = "KMSThrottlingFault"
        case replicationSubnetGroupDoesNotCoverEnoughAZs = "ReplicationSubnetGroupDoesNotCoverEnoughAZs"
        case resourceAlreadyExistsFault = "ResourceAlreadyExistsFault"
        case resourceNotFoundFault = "ResourceNotFoundFault"
        case resourceQuotaExceededFault = "ResourceQuotaExceededFault"
        case s3AccessDeniedFault = "S3AccessDeniedFault"
        case s3ResourceNotFoundFault = "S3ResourceNotFoundFault"
        case snsInvalidTopicFault = "SNSInvalidTopicFault"
        case snsNoAuthorizationFault = "SNSNoAuthorizationFault"
        case storageQuotaExceededFault = "StorageQuotaExceededFault"
        case subnetAlreadyInUse = "SubnetAlreadyInUse"
        case upgradeDependencyFailureFault = "UpgradeDependencyFailureFault"
    }

    private let error: Code
    public let context: AWSErrorContext?

    /// initialize DatabaseMigrationService
    public init?(errorCode: String, context: AWSErrorContext) {
        guard let error = Code(rawValue: errorCode) else { return nil }
        self.error = error
        self.context = context
    }

    internal init(_ error: Code) {
        self.error = error
        self.context = nil
    }

    /// return error code string
    public var errorCode: String { self.error.rawValue }

    /// DMS was denied access to the endpoint. Check that the  role is correctly configured.
    public static var accessDeniedFault: Self { .init(.accessDeniedFault) }
    /// The specified collector doesn't exist.
    public static var collectorNotFoundFault: Self { .init(.collectorNotFoundFault) }
    /// A dependency threw an exception.
    public static var failedDependencyFault: Self { .init(.failedDependencyFault) }
    /// There are not enough resources allocated to the database migration.
    public static var insufficientResourceCapacityFault: Self { .init(.insufficientResourceCapacityFault) }
    /// The certificate was not valid.
    public static var invalidCertificateFault: Self { .init(.invalidCertificateFault) }
    /// The action or operation requested isn't valid.
    public static var invalidOperationFault: Self { .init(.invalidOperationFault) }
    /// The resource is in a state that prevents it from being used for database migration.
    public static var invalidResourceStateFault: Self { .init(.invalidResourceStateFault) }
    /// The subnet provided isn't valid.
    public static var invalidSubnet: Self { .init(.invalidSubnet) }
    /// The ciphertext references a key that doesn't exist or that the DMS account doesn't have access to.
    public static var kmsAccessDeniedFault: Self { .init(.kmsAccessDeniedFault) }
    /// The specified KMS key isn't enabled.
    public static var kmsDisabledFault: Self { .init(.kmsDisabledFault) }
    /// An Key Management Service (KMS) error is preventing access to KMS.
    public static var kmsFault: Self { .init(.kmsFault) }
    /// The state of the specified KMS resource isn't valid for this request.
    public static var kmsInvalidStateFault: Self { .init(.kmsInvalidStateFault) }
    /// DMS cannot access the KMS key.
    public static var kmsKeyNotAccessibleFault: Self { .init(.kmsKeyNotAccessibleFault) }
    /// The specified KMS entity or resource can't be found.
    public static var kmsNotFoundFault: Self { .init(.kmsNotFoundFault) }
    /// This request triggered KMS request throttling.
    public static var kmsThrottlingFault: Self { .init(.kmsThrottlingFault) }
    /// The replication subnet group does not cover enough Availability Zones (AZs). Edit the replication subnet group and add more AZs.
    public static var replicationSubnetGroupDoesNotCoverEnoughAZs: Self { .init(.replicationSubnetGroupDoesNotCoverEnoughAZs) }
    /// The resource you are attempting to create already exists.
    public static var resourceAlreadyExistsFault: Self { .init(.resourceAlreadyExistsFault) }
    /// The resource could not be found.
    public static var resourceNotFoundFault: Self { .init(.resourceNotFoundFault) }
    /// The quota for this resource quota has been exceeded.
    public static var resourceQuotaExceededFault: Self { .init(.resourceQuotaExceededFault) }
    /// Insufficient privileges are preventing access to an Amazon S3 object.
    public static var s3AccessDeniedFault: Self { .init(.s3AccessDeniedFault) }
    /// A specified Amazon S3 bucket, bucket folder, or other object can't be found.
    public static var s3ResourceNotFoundFault: Self { .init(.s3ResourceNotFoundFault) }
    /// The SNS topic is invalid.
    public static var snsInvalidTopicFault: Self { .init(.snsInvalidTopicFault) }
    /// You are not authorized for the SNS subscription.
    public static var snsNoAuthorizationFault: Self { .init(.snsNoAuthorizationFault) }
    /// The storage quota has been exceeded.
    public static var storageQuotaExceededFault: Self { .init(.storageQuotaExceededFault) }
    /// The specified subnet is already in use.
    public static var subnetAlreadyInUse: Self { .init(.subnetAlreadyInUse) }
    /// An upgrade dependency is preventing the database migration.
    public static var upgradeDependencyFailureFault: Self { .init(.upgradeDependencyFailureFault) }
}

extension DatabaseMigrationServiceErrorType: AWSServiceErrorType {
    public static let errorCodeMap: [String: AWSErrorShape.Type] = [
        "ResourceAlreadyExistsFault": DatabaseMigrationService.ResourceAlreadyExistsFault.self
    ]
}

extension DatabaseMigrationServiceErrorType: Equatable {
    public static func == (lhs: DatabaseMigrationServiceErrorType, rhs: DatabaseMigrationServiceErrorType) -> Bool {
        lhs.error == rhs.error
    }
}

extension DatabaseMigrationServiceErrorType: CustomStringConvertible {
    public var description: String {
        return "\(self.error.rawValue): \(self.message ?? "")"
    }
}
