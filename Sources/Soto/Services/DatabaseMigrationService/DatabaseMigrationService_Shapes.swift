//===----------------------------------------------------------------------===//
//
// This source file is part of the Soto for AWS open source project
//
// Copyright (c) 2017-2021 the Soto project authors
// Licensed under Apache License v2.0
//
// See LICENSE.txt for license information
// See CONTRIBUTORS.txt for the list of Soto project authors
//
// SPDX-License-Identifier: Apache-2.0
//
//===----------------------------------------------------------------------===//

// THIS FILE IS AUTOMATICALLY GENERATED by https://github.com/soto-project/soto/tree/main/CodeGenerator. DO NOT EDIT.

import Foundation
import SotoCore

extension DatabaseMigrationService {
    // MARK: Enums

    public enum AuthMechanismValue: String, CustomStringConvertible, Codable {
        case `default`
        case mongodbCr = "mongodb_cr"
        case scramSha1 = "scram_sha_1"
        public var description: String { return self.rawValue }
    }

    public enum AuthTypeValue: String, CustomStringConvertible, Codable {
        case no
        case password
        public var description: String { return self.rawValue }
    }

    public enum CharLengthSemantics: String, CustomStringConvertible, Codable {
        case byte
        case char
        case `default`
        public var description: String { return self.rawValue }
    }

    public enum CompressionTypeValue: String, CustomStringConvertible, Codable {
        case gzip
        case none
        public var description: String { return self.rawValue }
    }

    public enum DataFormatValue: String, CustomStringConvertible, Codable {
        case csv
        case parquet
        public var description: String { return self.rawValue }
    }

    public enum DatePartitionDelimiterValue: String, CustomStringConvertible, Codable {
        case dash = "DASH"
        case none = "NONE"
        case slash = "SLASH"
        case underscore = "UNDERSCORE"
        public var description: String { return self.rawValue }
    }

    public enum DatePartitionSequenceValue: String, CustomStringConvertible, Codable {
        case ddmmyyyy = "DDMMYYYY"
        case mmyyyydd = "MMYYYYDD"
        case yyyymm = "YYYYMM"
        case yyyymmdd = "YYYYMMDD"
        case yyyymmddhh = "YYYYMMDDHH"
        public var description: String { return self.rawValue }
    }

    public enum DmsSslModeValue: String, CustomStringConvertible, Codable {
        case none
        case require
        case verifyCa = "verify-ca"
        case verifyFull = "verify-full"
        public var description: String { return self.rawValue }
    }

    public enum EncodingTypeValue: String, CustomStringConvertible, Codable {
        case plain
        case plainDictionary = "plain-dictionary"
        case rleDictionary = "rle-dictionary"
        public var description: String { return self.rawValue }
    }

    public enum EncryptionModeValue: String, CustomStringConvertible, Codable {
        case sseKms = "sse-kms"
        case sseS3 = "sse-s3"
        public var description: String { return self.rawValue }
    }

    public enum EndpointSettingTypeValue: String, CustomStringConvertible, Codable {
        case boolean
        case `enum`
        case integer
        case string
        public var description: String { return self.rawValue }
    }

    public enum KafkaSecurityProtocol: String, CustomStringConvertible, Codable {
        case plaintext
        case saslSsl = "sasl-ssl"
        case sslAuthentication = "ssl-authentication"
        case sslEncryption = "ssl-encryption"
        public var description: String { return self.rawValue }
    }

    public enum MessageFormatValue: String, CustomStringConvertible, Codable {
        case json
        case jsonUnformatted = "json-unformatted"
        public var description: String { return self.rawValue }
    }

    public enum MigrationTypeValue: String, CustomStringConvertible, Codable {
        case cdc
        case fullLoad = "full-load"
        case fullLoadAndCdc = "full-load-and-cdc"
        public var description: String { return self.rawValue }
    }

    public enum NestingLevelValue: String, CustomStringConvertible, Codable {
        case none
        case one
        public var description: String { return self.rawValue }
    }

    public enum ParquetVersionValue: String, CustomStringConvertible, Codable {
        case parquet10 = "parquet-1-0"
        case parquet20 = "parquet-2-0"
        public var description: String { return self.rawValue }
    }

    public enum PluginNameValue: String, CustomStringConvertible, Codable {
        case noPreference = "no-preference"
        case pglogical
        case testDecoding = "test-decoding"
        public var description: String { return self.rawValue }
    }

    public enum RefreshSchemasStatusTypeValue: String, CustomStringConvertible, Codable {
        case failed
        case refreshing
        case successful
        public var description: String { return self.rawValue }
    }

    public enum ReleaseStatusValues: String, CustomStringConvertible, Codable {
        case beta
        public var description: String { return self.rawValue }
    }

    public enum ReloadOptionValue: String, CustomStringConvertible, Codable {
        case dataReload = "data-reload"
        case validateOnly = "validate-only"
        public var description: String { return self.rawValue }
    }

    public enum ReplicationEndpointTypeValue: String, CustomStringConvertible, Codable {
        case source
        case target
        public var description: String { return self.rawValue }
    }

    public enum SafeguardPolicy: String, CustomStringConvertible, Codable {
        case exclusiveAutomaticTruncation = "exclusive-automatic-truncation"
        case relyOnSqlServerReplicationAgent = "rely-on-sql-server-replication-agent"
        case sharedAutomaticTruncation = "shared-automatic-truncation"
        public var description: String { return self.rawValue }
    }

    public enum SourceType: String, CustomStringConvertible, Codable {
        case replicationInstance = "replication-instance"
        public var description: String { return self.rawValue }
    }

    public enum StartReplicationTaskTypeValue: String, CustomStringConvertible, Codable {
        case reloadTarget = "reload-target"
        case resumeProcessing = "resume-processing"
        case startReplication = "start-replication"
        public var description: String { return self.rawValue }
    }

    public enum TargetDbType: String, CustomStringConvertible, Codable {
        case multipleDatabases = "multiple-databases"
        case specificDatabase = "specific-database"
        public var description: String { return self.rawValue }
    }

    // MARK: Shapes

    public struct AccountQuota: AWSDecodableShape {
        /// The name of the DMS quota for this account.
        public let accountQuotaName: String?
        /// The maximum allowed value for the quota.
        public let max: Int64?
        /// The amount currently used toward the quota maximum.
        public let used: Int64?

        public init(accountQuotaName: String? = nil, max: Int64? = nil, used: Int64? = nil) {
            self.accountQuotaName = accountQuotaName
            self.max = max
            self.used = used
        }

        private enum CodingKeys: String, CodingKey {
            case accountQuotaName = "AccountQuotaName"
            case max = "Max"
            case used = "Used"
        }
    }

    public struct AddTagsToResourceMessage: AWSEncodableShape {
        /// Identifies the DMS resource to which tags should be added. The value for this parameter is an Amazon Resource Name (ARN). For DMS, you can tag a replication instance, an endpoint, or a replication task.
        public let resourceArn: String
        /// One or more tags to be assigned to the resource.
        public let tags: [Tag]

        public init(resourceArn: String, tags: [Tag]) {
            self.resourceArn = resourceArn
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case resourceArn = "ResourceArn"
            case tags = "Tags"
        }
    }

    public struct AddTagsToResourceResponse: AWSDecodableShape {
        public init() {}
    }

    public struct ApplyPendingMaintenanceActionMessage: AWSEncodableShape {
        /// The pending maintenance action to apply to this resource.
        public let applyAction: String
        /// A value that specifies the type of opt-in request, or undoes an opt-in request. You can't undo an opt-in request of type immediate. Valid values:    immediate - Apply the maintenance action immediately.    next-maintenance - Apply the maintenance action during the next maintenance window for the resource.    undo-opt-in - Cancel any existing next-maintenance opt-in requests.
        public let optInType: String
        /// The Amazon Resource Name (ARN) of the DMS resource that the pending maintenance action applies to.
        public let replicationInstanceArn: String

        public init(applyAction: String, optInType: String, replicationInstanceArn: String) {
            self.applyAction = applyAction
            self.optInType = optInType
            self.replicationInstanceArn = replicationInstanceArn
        }

        private enum CodingKeys: String, CodingKey {
            case applyAction = "ApplyAction"
            case optInType = "OptInType"
            case replicationInstanceArn = "ReplicationInstanceArn"
        }
    }

    public struct ApplyPendingMaintenanceActionResponse: AWSDecodableShape {
        /// The DMS resource that the pending maintenance action will be applied to.
        public let resourcePendingMaintenanceActions: ResourcePendingMaintenanceActions?

        public init(resourcePendingMaintenanceActions: ResourcePendingMaintenanceActions? = nil) {
            self.resourcePendingMaintenanceActions = resourcePendingMaintenanceActions
        }

        private enum CodingKeys: String, CodingKey {
            case resourcePendingMaintenanceActions = "ResourcePendingMaintenanceActions"
        }
    }

    public struct AvailabilityZone: AWSDecodableShape {
        /// The name of the Availability Zone.
        public let name: String?

        public init(name: String? = nil) {
            self.name = name
        }

        private enum CodingKeys: String, CodingKey {
            case name = "Name"
        }
    }

    public struct CancelReplicationTaskAssessmentRunMessage: AWSEncodableShape {
        /// Amazon Resource Name (ARN) of the premigration assessment run to be canceled.
        public let replicationTaskAssessmentRunArn: String

        public init(replicationTaskAssessmentRunArn: String) {
            self.replicationTaskAssessmentRunArn = replicationTaskAssessmentRunArn
        }

        private enum CodingKeys: String, CodingKey {
            case replicationTaskAssessmentRunArn = "ReplicationTaskAssessmentRunArn"
        }
    }

    public struct CancelReplicationTaskAssessmentRunResponse: AWSDecodableShape {
        /// The ReplicationTaskAssessmentRun object for the canceled assessment run.
        public let replicationTaskAssessmentRun: ReplicationTaskAssessmentRun?

        public init(replicationTaskAssessmentRun: ReplicationTaskAssessmentRun? = nil) {
            self.replicationTaskAssessmentRun = replicationTaskAssessmentRun
        }

        private enum CodingKeys: String, CodingKey {
            case replicationTaskAssessmentRun = "ReplicationTaskAssessmentRun"
        }
    }

    public struct Certificate: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) for the certificate.
        public let certificateArn: String?
        /// The date that the certificate was created.
        public let certificateCreationDate: Date?
        /// A customer-assigned name for the certificate. Identifiers must begin with a letter and must contain only ASCII letters, digits, and hyphens. They can't end with a hyphen or contain two consecutive hyphens.
        public let certificateIdentifier: String?
        /// The owner of the certificate.
        public let certificateOwner: String?
        /// The contents of a .pem file, which contains an X.509 certificate.
        public let certificatePem: String?
        /// The location of an imported Oracle Wallet certificate for use with SSL.
        public let certificateWallet: Data?
        /// The key length of the cryptographic algorithm being used.
        public let keyLength: Int?
        /// The signing algorithm for the certificate.
        public let signingAlgorithm: String?
        /// The beginning date that the certificate is valid.
        public let validFromDate: Date?
        /// The final date that the certificate is valid.
        public let validToDate: Date?

        public init(certificateArn: String? = nil, certificateCreationDate: Date? = nil, certificateIdentifier: String? = nil, certificateOwner: String? = nil, certificatePem: String? = nil, certificateWallet: Data? = nil, keyLength: Int? = nil, signingAlgorithm: String? = nil, validFromDate: Date? = nil, validToDate: Date? = nil) {
            self.certificateArn = certificateArn
            self.certificateCreationDate = certificateCreationDate
            self.certificateIdentifier = certificateIdentifier
            self.certificateOwner = certificateOwner
            self.certificatePem = certificatePem
            self.certificateWallet = certificateWallet
            self.keyLength = keyLength
            self.signingAlgorithm = signingAlgorithm
            self.validFromDate = validFromDate
            self.validToDate = validToDate
        }

        private enum CodingKeys: String, CodingKey {
            case certificateArn = "CertificateArn"
            case certificateCreationDate = "CertificateCreationDate"
            case certificateIdentifier = "CertificateIdentifier"
            case certificateOwner = "CertificateOwner"
            case certificatePem = "CertificatePem"
            case certificateWallet = "CertificateWallet"
            case keyLength = "KeyLength"
            case signingAlgorithm = "SigningAlgorithm"
            case validFromDate = "ValidFromDate"
            case validToDate = "ValidToDate"
        }
    }

    public struct Connection: AWSDecodableShape {
        /// The ARN string that uniquely identifies the endpoint.
        public let endpointArn: String?
        /// The identifier of the endpoint. Identifiers must begin with a letter and must contain only ASCII letters, digits, and hyphens. They can't end with a hyphen or contain two consecutive hyphens.
        public let endpointIdentifier: String?
        /// The error message when the connection last failed.
        public let lastFailureMessage: String?
        /// The ARN of the replication instance.
        public let replicationInstanceArn: String?
        /// The replication instance identifier. This parameter is stored as a lowercase string.
        public let replicationInstanceIdentifier: String?
        /// The connection status. This parameter can return one of the following values:    "successful"     "testing"     "failed"     "deleting"
        public let status: String?

        public init(endpointArn: String? = nil, endpointIdentifier: String? = nil, lastFailureMessage: String? = nil, replicationInstanceArn: String? = nil, replicationInstanceIdentifier: String? = nil, status: String? = nil) {
            self.endpointArn = endpointArn
            self.endpointIdentifier = endpointIdentifier
            self.lastFailureMessage = lastFailureMessage
            self.replicationInstanceArn = replicationInstanceArn
            self.replicationInstanceIdentifier = replicationInstanceIdentifier
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case endpointArn = "EndpointArn"
            case endpointIdentifier = "EndpointIdentifier"
            case lastFailureMessage = "LastFailureMessage"
            case replicationInstanceArn = "ReplicationInstanceArn"
            case replicationInstanceIdentifier = "ReplicationInstanceIdentifier"
            case status = "Status"
        }
    }

    public struct CreateEndpointMessage: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) for the certificate.
        public let certificateArn: String?
        /// The name of the endpoint database. For a MySQL source or target endpoint, do not specify DatabaseName.
        public let databaseName: String?
        /// The settings in JSON format for the DMS transfer type of source endpoint.  Possible settings include the following:    ServiceAccessRoleArn - The IAM role that has permission to access the Amazon S3 bucket. The role must allow the iam:PassRole action.    BucketName - The name of the S3 bucket to use.   Shorthand syntax for these settings is as follows: ServiceAccessRoleArn=string,BucketName=string  JSON syntax for these settings is as follows: { "ServiceAccessRoleArn": "string", "BucketName": "string", }
        public let dmsTransferSettings: DmsTransferSettings?
        public let docDbSettings: DocDbSettings?
        /// Settings in JSON format for the target Amazon DynamoDB endpoint. For information about other available settings, see Using Object Mapping to Migrate Data to DynamoDB in the Database Migration Service User Guide.
        public let dynamoDbSettings: DynamoDbSettings?
        /// Settings in JSON format for the target Elasticsearch endpoint. For more information about the available settings, see Extra Connection Attributes When Using Elasticsearch as a Target for DMS in the Database Migration Service User Guide.
        public let elasticsearchSettings: ElasticsearchSettings?
        /// The database endpoint identifier. Identifiers must begin with a letter and must contain only ASCII letters, digits, and hyphens. They can't end with a hyphen, or contain two consecutive hyphens.
        public let endpointIdentifier: String
        /// The type of endpoint. Valid values are source and target.
        public let endpointType: ReplicationEndpointTypeValue
        /// The type of engine for the endpoint. Valid values, depending on the EndpointType value, include "mysql", "oracle", "postgres", "mariadb", "aurora", "aurora-postgresql", "redshift", "s3", "db2", "azuredb", "sybase", "dynamodb", "mongodb", "kinesis", "kafka", "elasticsearch", "docdb", "sqlserver", and "neptune".
        public let engineName: String
        /// The external table definition.
        public let externalTableDefinition: String?
        /// Additional attributes associated with the connection. Each attribute is specified as a name-value pair associated by an equal sign (=). Multiple attributes are separated by a semicolon (;) with no additional white space. For information on the attributes available for connecting your source or target endpoint, see Working with DMS Endpoints in the Database Migration Service User Guide.
        public let extraConnectionAttributes: String?
        /// Settings in JSON format for the source IBM Db2 LUW endpoint. For information about other available settings, see Extra connection attributes when using Db2 LUW as a source for DMS in the Database Migration Service User Guide.
        public let iBMDb2Settings: IBMDb2Settings?
        /// Settings in JSON format for the target Apache Kafka endpoint. For more information about the available settings, see Using object mapping to migrate data to a Kafka topic in the Database Migration Service User Guide.
        public let kafkaSettings: KafkaSettings?
        /// Settings in JSON format for the target endpoint for Amazon Kinesis Data Streams. For more information about the available settings, see Using object mapping to migrate data to a Kinesis data stream in the Database Migration Service User Guide.
        public let kinesisSettings: KinesisSettings?
        /// An KMS key identifier that is used to encrypt the connection parameters for the endpoint. If you don't specify a value for the KmsKeyId parameter, then DMS uses your default encryption key. KMS creates the default encryption key for your account. Your account has a different default encryption key for each Region.
        public let kmsKeyId: String?
        /// Settings in JSON format for the source and target Microsoft SQL Server endpoint. For information about other available settings, see Extra connection attributes when using SQL Server as a source for DMS and  Extra connection attributes when using SQL Server as a target for DMS in the Database Migration Service User Guide.
        public let microsoftSQLServerSettings: MicrosoftSQLServerSettings?
        /// Settings in JSON format for the source MongoDB endpoint. For more information about the available settings, see Endpoint configuration settings when using MongoDB as a source for Database Migration Service in the Database Migration Service User Guide.
        public let mongoDbSettings: MongoDbSettings?
        /// Settings in JSON format for the source and target MySQL endpoint. For information about other available settings, see Extra connection attributes when using MySQL as a source for DMS and Extra connection attributes when using a MySQL-compatible database as a target for DMS in the Database Migration Service User Guide.
        public let mySQLSettings: MySQLSettings?
        /// Settings in JSON format for the target Amazon Neptune endpoint. For more information about the available settings, see Specifying graph-mapping rules using Gremlin and R2RML for Amazon Neptune as a target in the Database Migration Service User Guide.
        public let neptuneSettings: NeptuneSettings?
        /// Settings in JSON format for the source and target Oracle endpoint. For information about other available settings, see Extra connection attributes when using Oracle as a source for DMS and  Extra connection attributes when using Oracle as a target for DMS in the Database Migration Service User Guide.
        public let oracleSettings: OracleSettings?
        /// The password to be used to log in to the endpoint database.
        public let password: String?
        /// The port used by the endpoint database.
        public let port: Int?
        /// Settings in JSON format for the source and target PostgreSQL endpoint. For information about other available settings, see Extra connection attributes when using PostgreSQL as a source for DMS and  Extra connection attributes when using PostgreSQL as a target for DMS in the Database Migration Service User Guide.
        public let postgreSQLSettings: PostgreSQLSettings?
        public let redshiftSettings: RedshiftSettings?
        /// A friendly name for the resource identifier at the end of the EndpointArn response parameter that is returned in the created Endpoint object. The value for this parameter can have up to 31 characters. It can contain only ASCII letters, digits, and hyphen ('-'). Also, it can't end with a hyphen or contain two consecutive hyphens, and can only begin with a letter, such as Example-App-ARN1. For example, this value might result in the EndpointArn value arn:aws:dms:eu-west-1:012345678901:rep:Example-App-ARN1. If you don't specify a ResourceIdentifier value, DMS generates a default identifier value for the end of EndpointArn.
        public let resourceIdentifier: String?
        /// Settings in JSON format for the target Amazon S3 endpoint. For more information about the available settings, see Extra Connection Attributes When Using Amazon S3 as a Target for DMS in the Database Migration Service User Guide.
        public let s3Settings: S3Settings?
        /// The name of the server where the endpoint database resides.
        public let serverName: String?
        ///  The Amazon Resource Name (ARN) for the service access role that you want to use to create the endpoint. The role must allow the iam:PassRole action.
        public let serviceAccessRoleArn: String?
        /// The Secure Sockets Layer (SSL) mode to use for the SSL connection. The default is none
        public let sslMode: DmsSslModeValue?
        /// Settings in JSON format for the source and target SAP ASE endpoint. For information about other available settings, see Extra connection attributes when using SAP ASE as a source for DMS and Extra connection attributes when using SAP ASE as a target for DMS in the Database Migration Service User Guide.
        public let sybaseSettings: SybaseSettings?
        /// One or more tags to be assigned to the endpoint.
        public let tags: [Tag]?
        /// The user name to be used to log in to the endpoint database.
        public let username: String?

        public init(certificateArn: String? = nil, databaseName: String? = nil, dmsTransferSettings: DmsTransferSettings? = nil, docDbSettings: DocDbSettings? = nil, dynamoDbSettings: DynamoDbSettings? = nil, elasticsearchSettings: ElasticsearchSettings? = nil, endpointIdentifier: String, endpointType: ReplicationEndpointTypeValue, engineName: String, externalTableDefinition: String? = nil, extraConnectionAttributes: String? = nil, iBMDb2Settings: IBMDb2Settings? = nil, kafkaSettings: KafkaSettings? = nil, kinesisSettings: KinesisSettings? = nil, kmsKeyId: String? = nil, microsoftSQLServerSettings: MicrosoftSQLServerSettings? = nil, mongoDbSettings: MongoDbSettings? = nil, mySQLSettings: MySQLSettings? = nil, neptuneSettings: NeptuneSettings? = nil, oracleSettings: OracleSettings? = nil, password: String? = nil, port: Int? = nil, postgreSQLSettings: PostgreSQLSettings? = nil, redshiftSettings: RedshiftSettings? = nil, resourceIdentifier: String? = nil, s3Settings: S3Settings? = nil, serverName: String? = nil, serviceAccessRoleArn: String? = nil, sslMode: DmsSslModeValue? = nil, sybaseSettings: SybaseSettings? = nil, tags: [Tag]? = nil, username: String? = nil) {
            self.certificateArn = certificateArn
            self.databaseName = databaseName
            self.dmsTransferSettings = dmsTransferSettings
            self.docDbSettings = docDbSettings
            self.dynamoDbSettings = dynamoDbSettings
            self.elasticsearchSettings = elasticsearchSettings
            self.endpointIdentifier = endpointIdentifier
            self.endpointType = endpointType
            self.engineName = engineName
            self.externalTableDefinition = externalTableDefinition
            self.extraConnectionAttributes = extraConnectionAttributes
            self.iBMDb2Settings = iBMDb2Settings
            self.kafkaSettings = kafkaSettings
            self.kinesisSettings = kinesisSettings
            self.kmsKeyId = kmsKeyId
            self.microsoftSQLServerSettings = microsoftSQLServerSettings
            self.mongoDbSettings = mongoDbSettings
            self.mySQLSettings = mySQLSettings
            self.neptuneSettings = neptuneSettings
            self.oracleSettings = oracleSettings
            self.password = password
            self.port = port
            self.postgreSQLSettings = postgreSQLSettings
            self.redshiftSettings = redshiftSettings
            self.resourceIdentifier = resourceIdentifier
            self.s3Settings = s3Settings
            self.serverName = serverName
            self.serviceAccessRoleArn = serviceAccessRoleArn
            self.sslMode = sslMode
            self.sybaseSettings = sybaseSettings
            self.tags = tags
            self.username = username
        }

        private enum CodingKeys: String, CodingKey {
            case certificateArn = "CertificateArn"
            case databaseName = "DatabaseName"
            case dmsTransferSettings = "DmsTransferSettings"
            case docDbSettings = "DocDbSettings"
            case dynamoDbSettings = "DynamoDbSettings"
            case elasticsearchSettings = "ElasticsearchSettings"
            case endpointIdentifier = "EndpointIdentifier"
            case endpointType = "EndpointType"
            case engineName = "EngineName"
            case externalTableDefinition = "ExternalTableDefinition"
            case extraConnectionAttributes = "ExtraConnectionAttributes"
            case iBMDb2Settings = "IBMDb2Settings"
            case kafkaSettings = "KafkaSettings"
            case kinesisSettings = "KinesisSettings"
            case kmsKeyId = "KmsKeyId"
            case microsoftSQLServerSettings = "MicrosoftSQLServerSettings"
            case mongoDbSettings = "MongoDbSettings"
            case mySQLSettings = "MySQLSettings"
            case neptuneSettings = "NeptuneSettings"
            case oracleSettings = "OracleSettings"
            case password = "Password"
            case port = "Port"
            case postgreSQLSettings = "PostgreSQLSettings"
            case redshiftSettings = "RedshiftSettings"
            case resourceIdentifier = "ResourceIdentifier"
            case s3Settings = "S3Settings"
            case serverName = "ServerName"
            case serviceAccessRoleArn = "ServiceAccessRoleArn"
            case sslMode = "SslMode"
            case sybaseSettings = "SybaseSettings"
            case tags = "Tags"
            case username = "Username"
        }
    }

    public struct CreateEndpointResponse: AWSDecodableShape {
        /// The endpoint that was created.
        public let endpoint: Endpoint?

        public init(endpoint: Endpoint? = nil) {
            self.endpoint = endpoint
        }

        private enum CodingKeys: String, CodingKey {
            case endpoint = "Endpoint"
        }
    }

    public struct CreateEventSubscriptionMessage: AWSEncodableShape {
        ///  A Boolean value; set to true to activate the subscription, or set to false to create the subscription but not activate it.
        public let enabled: Bool?
        /// A list of event categories for a source type that you want to subscribe to. For more information, see Working with Events and Notifications in the Database Migration Service User Guide.
        public let eventCategories: [String]?
        ///  The Amazon Resource Name (ARN) of the Amazon SNS topic created for event notification. The ARN is created by Amazon SNS when you create a topic and subscribe to it.
        public let snsTopicArn: String
        /// A list of identifiers for which DMS provides notification events. If you don't specify a value, notifications are provided for all sources. If you specify multiple values, they must be of the same type. For example, if you specify a database instance ID, then all of the other values must be database instance IDs.
        public let sourceIds: [String]?
        ///  The type of DMS resource that generates the events. For example, if you want to be notified of events generated by a replication instance, you set this parameter to replication-instance. If this value isn't specified, all events are returned.  Valid values: replication-instance | replication-task
        public let sourceType: String?
        /// The name of the DMS event notification subscription. This name must be less than 255 characters.
        public let subscriptionName: String
        /// One or more tags to be assigned to the event subscription.
        public let tags: [Tag]?

        public init(enabled: Bool? = nil, eventCategories: [String]? = nil, snsTopicArn: String, sourceIds: [String]? = nil, sourceType: String? = nil, subscriptionName: String, tags: [Tag]? = nil) {
            self.enabled = enabled
            self.eventCategories = eventCategories
            self.snsTopicArn = snsTopicArn
            self.sourceIds = sourceIds
            self.sourceType = sourceType
            self.subscriptionName = subscriptionName
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case enabled = "Enabled"
            case eventCategories = "EventCategories"
            case snsTopicArn = "SnsTopicArn"
            case sourceIds = "SourceIds"
            case sourceType = "SourceType"
            case subscriptionName = "SubscriptionName"
            case tags = "Tags"
        }
    }

    public struct CreateEventSubscriptionResponse: AWSDecodableShape {
        /// The event subscription that was created.
        public let eventSubscription: EventSubscription?

        public init(eventSubscription: EventSubscription? = nil) {
            self.eventSubscription = eventSubscription
        }

        private enum CodingKeys: String, CodingKey {
            case eventSubscription = "EventSubscription"
        }
    }

    public struct CreateReplicationInstanceMessage: AWSEncodableShape {
        /// The amount of storage (in gigabytes) to be initially allocated for the replication instance.
        public let allocatedStorage: Int?
        /// A value that indicates whether minor engine upgrades are applied automatically to the replication instance during the maintenance window. This parameter defaults to true. Default: true
        public let autoMinorVersionUpgrade: Bool?
        /// The Availability Zone where the replication instance will be created. The default value is a random, system-chosen Availability Zone in the endpoint's Region, for example: us-east-1d
        public let availabilityZone: String?
        /// A list of custom DNS name servers supported for the replication instance to access your on-premise source or target database. This list overrides the default name servers supported by the replication instance. You can specify a comma-separated list of internet addresses for up to four on-premise DNS name servers. For example: "1.1.1.1,2.2.2.2,3.3.3.3,4.4.4.4"
        public let dnsNameServers: String?
        /// The engine version number of the replication instance. If an engine version number is not specified when a replication instance is created, the default is the latest engine version available.
        public let engineVersion: String?
        /// An KMS key identifier that is used to encrypt the data on the replication instance. If you don't specify a value for the KmsKeyId parameter, then DMS uses your default encryption key. KMS creates the default encryption key for your account. Your account has a different default encryption key for each Region.
        public let kmsKeyId: String?
        ///  Specifies whether the replication instance is a Multi-AZ deployment. You can't set the AvailabilityZone parameter if the Multi-AZ parameter is set to true.
        public let multiAZ: Bool?
        /// The weekly time range during which system maintenance can occur, in Universal Coordinated Time (UTC).  Format: ddd:hh24:mi-ddd:hh24:mi  Default: A 30-minute window selected at random from an 8-hour block of time per Region, occurring on a random day of the week. Valid Days: Mon, Tue, Wed, Thu, Fri, Sat, Sun Constraints: Minimum 30-minute window.
        public let preferredMaintenanceWindow: String?
        ///  Specifies the accessibility options for the replication instance. A value of true represents an instance with a public IP address. A value of false represents an instance with a private IP address. The default value is true.
        public let publiclyAccessible: Bool?
        /// The compute and memory capacity of the replication instance as defined for the specified replication instance class. For example to specify the instance class dms.c4.large, set this parameter to "dms.c4.large". For more information on the settings and capacities for the available replication instance classes, see  Selecting the right DMS replication instance for your migration.
        public let replicationInstanceClass: String
        /// The replication instance identifier. This parameter is stored as a lowercase string. Constraints:   Must contain 1-63 alphanumeric characters or hyphens.   First character must be a letter.   Can't end with a hyphen or contain two consecutive hyphens.   Example: myrepinstance
        public let replicationInstanceIdentifier: String
        /// A subnet group to associate with the replication instance.
        public let replicationSubnetGroupIdentifier: String?
        /// A friendly name for the resource identifier at the end of the EndpointArn response parameter that is returned in the created Endpoint object. The value for this parameter can have up to 31 characters. It can contain only ASCII letters, digits, and hyphen ('-'). Also, it can't end with a hyphen or contain two consecutive hyphens, and can only begin with a letter, such as Example-App-ARN1. For example, this value might result in the EndpointArn value arn:aws:dms:eu-west-1:012345678901:rep:Example-App-ARN1. If you don't specify a ResourceIdentifier value, DMS generates a default identifier value for the end of EndpointArn.
        public let resourceIdentifier: String?
        /// One or more tags to be assigned to the replication instance.
        public let tags: [Tag]?
        ///  Specifies the VPC security group to be used with the replication instance. The VPC security group must work with the VPC containing the replication instance.
        public let vpcSecurityGroupIds: [String]?

        public init(allocatedStorage: Int? = nil, autoMinorVersionUpgrade: Bool? = nil, availabilityZone: String? = nil, dnsNameServers: String? = nil, engineVersion: String? = nil, kmsKeyId: String? = nil, multiAZ: Bool? = nil, preferredMaintenanceWindow: String? = nil, publiclyAccessible: Bool? = nil, replicationInstanceClass: String, replicationInstanceIdentifier: String, replicationSubnetGroupIdentifier: String? = nil, resourceIdentifier: String? = nil, tags: [Tag]? = nil, vpcSecurityGroupIds: [String]? = nil) {
            self.allocatedStorage = allocatedStorage
            self.autoMinorVersionUpgrade = autoMinorVersionUpgrade
            self.availabilityZone = availabilityZone
            self.dnsNameServers = dnsNameServers
            self.engineVersion = engineVersion
            self.kmsKeyId = kmsKeyId
            self.multiAZ = multiAZ
            self.preferredMaintenanceWindow = preferredMaintenanceWindow
            self.publiclyAccessible = publiclyAccessible
            self.replicationInstanceClass = replicationInstanceClass
            self.replicationInstanceIdentifier = replicationInstanceIdentifier
            self.replicationSubnetGroupIdentifier = replicationSubnetGroupIdentifier
            self.resourceIdentifier = resourceIdentifier
            self.tags = tags
            self.vpcSecurityGroupIds = vpcSecurityGroupIds
        }

        private enum CodingKeys: String, CodingKey {
            case allocatedStorage = "AllocatedStorage"
            case autoMinorVersionUpgrade = "AutoMinorVersionUpgrade"
            case availabilityZone = "AvailabilityZone"
            case dnsNameServers = "DnsNameServers"
            case engineVersion = "EngineVersion"
            case kmsKeyId = "KmsKeyId"
            case multiAZ = "MultiAZ"
            case preferredMaintenanceWindow = "PreferredMaintenanceWindow"
            case publiclyAccessible = "PubliclyAccessible"
            case replicationInstanceClass = "ReplicationInstanceClass"
            case replicationInstanceIdentifier = "ReplicationInstanceIdentifier"
            case replicationSubnetGroupIdentifier = "ReplicationSubnetGroupIdentifier"
            case resourceIdentifier = "ResourceIdentifier"
            case tags = "Tags"
            case vpcSecurityGroupIds = "VpcSecurityGroupIds"
        }
    }

    public struct CreateReplicationInstanceResponse: AWSDecodableShape {
        /// The replication instance that was created.
        public let replicationInstance: ReplicationInstance?

        public init(replicationInstance: ReplicationInstance? = nil) {
            self.replicationInstance = replicationInstance
        }

        private enum CodingKeys: String, CodingKey {
            case replicationInstance = "ReplicationInstance"
        }
    }

    public struct CreateReplicationSubnetGroupMessage: AWSEncodableShape {
        /// The description for the subnet group.
        public let replicationSubnetGroupDescription: String
        /// The name for the replication subnet group. This value is stored as a lowercase string. Constraints: Must contain no more than 255 alphanumeric characters, periods, spaces, underscores, or hyphens. Must not be "default". Example: mySubnetgroup
        public let replicationSubnetGroupIdentifier: String
        /// One or more subnet IDs to be assigned to the subnet group.
        public let subnetIds: [String]
        /// One or more tags to be assigned to the subnet group.
        public let tags: [Tag]?

        public init(replicationSubnetGroupDescription: String, replicationSubnetGroupIdentifier: String, subnetIds: [String], tags: [Tag]? = nil) {
            self.replicationSubnetGroupDescription = replicationSubnetGroupDescription
            self.replicationSubnetGroupIdentifier = replicationSubnetGroupIdentifier
            self.subnetIds = subnetIds
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case replicationSubnetGroupDescription = "ReplicationSubnetGroupDescription"
            case replicationSubnetGroupIdentifier = "ReplicationSubnetGroupIdentifier"
            case subnetIds = "SubnetIds"
            case tags = "Tags"
        }
    }

    public struct CreateReplicationSubnetGroupResponse: AWSDecodableShape {
        /// The replication subnet group that was created.
        public let replicationSubnetGroup: ReplicationSubnetGroup?

        public init(replicationSubnetGroup: ReplicationSubnetGroup? = nil) {
            self.replicationSubnetGroup = replicationSubnetGroup
        }

        private enum CodingKeys: String, CodingKey {
            case replicationSubnetGroup = "ReplicationSubnetGroup"
        }
    }

    public struct CreateReplicationTaskMessage: AWSEncodableShape {
        /// Indicates when you want a change data capture (CDC) operation to start. Use either CdcStartPosition or CdcStartTime to specify when you want a CDC operation to start. Specifying both values results in an error.  The value can be in date, checkpoint, or LSN/SCN format. Date Example: --cdc-start-position “2018-03-08T12:12:12” Checkpoint Example: --cdc-start-position "checkpoint:V1#27#mysql-bin-changelog.157832:1975:-1:2002:677883278264080:mysql-bin-changelog.157832:1876#0#0#*#0#93" LSN Example: --cdc-start-position “mysql-bin-changelog.000024:373”  When you use this task setting with a source PostgreSQL database, a logical replication slot should already be created and associated with the source endpoint. You can verify this by setting the slotName extra connection attribute to the name of this logical replication slot. For more information, see Extra Connection Attributes When Using PostgreSQL as a Source for DMS.
        public let cdcStartPosition: String?
        /// Indicates the start time for a change data capture (CDC) operation. Use either CdcStartTime or CdcStartPosition to specify when you want a CDC operation to start. Specifying both values results in an error. Timestamp Example: --cdc-start-time “2018-03-08T12:12:12”
        public let cdcStartTime: Date?
        /// Indicates when you want a change data capture (CDC) operation to stop. The value can be either server time or commit time. Server time example: --cdc-stop-position “server_time:2018-02-09T12:12:12” Commit time example: --cdc-stop-position “commit_time: 2018-02-09T12:12:12 “
        public let cdcStopPosition: String?
        /// The migration type. Valid values: full-load | cdc | full-load-and-cdc
        public let migrationType: MigrationTypeValue
        /// The Amazon Resource Name (ARN) of a replication instance.
        public let replicationInstanceArn: String
        /// An identifier for the replication task. Constraints:   Must contain 1-255 alphanumeric characters or hyphens.   First character must be a letter.   Cannot end with a hyphen or contain two consecutive hyphens.
        public let replicationTaskIdentifier: String
        /// Overall settings for the task, in JSON format. For more information, see Specifying Task Settings for Database Migration Service Tasks in the Database Migration Service User Guide.
        public let replicationTaskSettings: String?
        /// A friendly name for the resource identifier at the end of the EndpointArn response parameter that is returned in the created Endpoint object. The value for this parameter can have up to 31 characters. It can contain only ASCII letters, digits, and hyphen ('-'). Also, it can't end with a hyphen or contain two consecutive hyphens, and can only begin with a letter, such as Example-App-ARN1. For example, this value might result in the EndpointArn value arn:aws:dms:eu-west-1:012345678901:rep:Example-App-ARN1. If you don't specify a ResourceIdentifier value, DMS generates a default identifier value for the end of EndpointArn.
        public let resourceIdentifier: String?
        /// An Amazon Resource Name (ARN) that uniquely identifies the source endpoint.
        public let sourceEndpointArn: String
        /// The table mappings for the task, in JSON format. For more information, see Using Table Mapping to Specify Task Settings in the Database Migration Service User Guide.
        public let tableMappings: String
        /// One or more tags to be assigned to the replication task.
        public let tags: [Tag]?
        /// An Amazon Resource Name (ARN) that uniquely identifies the target endpoint.
        public let targetEndpointArn: String
        /// Supplemental information that the task requires to migrate the data for certain source and target endpoints. For more information, see Specifying Supplemental Data for Task Settings in the Database Migration Service User Guide.
        public let taskData: String?

        public init(cdcStartPosition: String? = nil, cdcStartTime: Date? = nil, cdcStopPosition: String? = nil, migrationType: MigrationTypeValue, replicationInstanceArn: String, replicationTaskIdentifier: String, replicationTaskSettings: String? = nil, resourceIdentifier: String? = nil, sourceEndpointArn: String, tableMappings: String, tags: [Tag]? = nil, targetEndpointArn: String, taskData: String? = nil) {
            self.cdcStartPosition = cdcStartPosition
            self.cdcStartTime = cdcStartTime
            self.cdcStopPosition = cdcStopPosition
            self.migrationType = migrationType
            self.replicationInstanceArn = replicationInstanceArn
            self.replicationTaskIdentifier = replicationTaskIdentifier
            self.replicationTaskSettings = replicationTaskSettings
            self.resourceIdentifier = resourceIdentifier
            self.sourceEndpointArn = sourceEndpointArn
            self.tableMappings = tableMappings
            self.tags = tags
            self.targetEndpointArn = targetEndpointArn
            self.taskData = taskData
        }

        private enum CodingKeys: String, CodingKey {
            case cdcStartPosition = "CdcStartPosition"
            case cdcStartTime = "CdcStartTime"
            case cdcStopPosition = "CdcStopPosition"
            case migrationType = "MigrationType"
            case replicationInstanceArn = "ReplicationInstanceArn"
            case replicationTaskIdentifier = "ReplicationTaskIdentifier"
            case replicationTaskSettings = "ReplicationTaskSettings"
            case resourceIdentifier = "ResourceIdentifier"
            case sourceEndpointArn = "SourceEndpointArn"
            case tableMappings = "TableMappings"
            case tags = "Tags"
            case targetEndpointArn = "TargetEndpointArn"
            case taskData = "TaskData"
        }
    }

    public struct CreateReplicationTaskResponse: AWSDecodableShape {
        /// The replication task that was created.
        public let replicationTask: ReplicationTask?

        public init(replicationTask: ReplicationTask? = nil) {
            self.replicationTask = replicationTask
        }

        private enum CodingKeys: String, CodingKey {
            case replicationTask = "ReplicationTask"
        }
    }

    public struct DeleteCertificateMessage: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the deleted certificate.
        public let certificateArn: String

        public init(certificateArn: String) {
            self.certificateArn = certificateArn
        }

        private enum CodingKeys: String, CodingKey {
            case certificateArn = "CertificateArn"
        }
    }

    public struct DeleteCertificateResponse: AWSDecodableShape {
        /// The Secure Sockets Layer (SSL) certificate.
        public let certificate: Certificate?

        public init(certificate: Certificate? = nil) {
            self.certificate = certificate
        }

        private enum CodingKeys: String, CodingKey {
            case certificate = "Certificate"
        }
    }

    public struct DeleteConnectionMessage: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) string that uniquely identifies the endpoint.
        public let endpointArn: String
        /// The Amazon Resource Name (ARN) of the replication instance.
        public let replicationInstanceArn: String

        public init(endpointArn: String, replicationInstanceArn: String) {
            self.endpointArn = endpointArn
            self.replicationInstanceArn = replicationInstanceArn
        }

        private enum CodingKeys: String, CodingKey {
            case endpointArn = "EndpointArn"
            case replicationInstanceArn = "ReplicationInstanceArn"
        }
    }

    public struct DeleteConnectionResponse: AWSDecodableShape {
        /// The connection that is being deleted.
        public let connection: Connection?

        public init(connection: Connection? = nil) {
            self.connection = connection
        }

        private enum CodingKeys: String, CodingKey {
            case connection = "Connection"
        }
    }

    public struct DeleteEndpointMessage: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) string that uniquely identifies the endpoint.
        public let endpointArn: String

        public init(endpointArn: String) {
            self.endpointArn = endpointArn
        }

        private enum CodingKeys: String, CodingKey {
            case endpointArn = "EndpointArn"
        }
    }

    public struct DeleteEndpointResponse: AWSDecodableShape {
        /// The endpoint that was deleted.
        public let endpoint: Endpoint?

        public init(endpoint: Endpoint? = nil) {
            self.endpoint = endpoint
        }

        private enum CodingKeys: String, CodingKey {
            case endpoint = "Endpoint"
        }
    }

    public struct DeleteEventSubscriptionMessage: AWSEncodableShape {
        /// The name of the DMS event notification subscription to be deleted.
        public let subscriptionName: String

        public init(subscriptionName: String) {
            self.subscriptionName = subscriptionName
        }

        private enum CodingKeys: String, CodingKey {
            case subscriptionName = "SubscriptionName"
        }
    }

    public struct DeleteEventSubscriptionResponse: AWSDecodableShape {
        /// The event subscription that was deleted.
        public let eventSubscription: EventSubscription?

        public init(eventSubscription: EventSubscription? = nil) {
            self.eventSubscription = eventSubscription
        }

        private enum CodingKeys: String, CodingKey {
            case eventSubscription = "EventSubscription"
        }
    }

    public struct DeleteReplicationInstanceMessage: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the replication instance to be deleted.
        public let replicationInstanceArn: String

        public init(replicationInstanceArn: String) {
            self.replicationInstanceArn = replicationInstanceArn
        }

        private enum CodingKeys: String, CodingKey {
            case replicationInstanceArn = "ReplicationInstanceArn"
        }
    }

    public struct DeleteReplicationInstanceResponse: AWSDecodableShape {
        /// The replication instance that was deleted.
        public let replicationInstance: ReplicationInstance?

        public init(replicationInstance: ReplicationInstance? = nil) {
            self.replicationInstance = replicationInstance
        }

        private enum CodingKeys: String, CodingKey {
            case replicationInstance = "ReplicationInstance"
        }
    }

    public struct DeleteReplicationSubnetGroupMessage: AWSEncodableShape {
        /// The subnet group name of the replication instance.
        public let replicationSubnetGroupIdentifier: String

        public init(replicationSubnetGroupIdentifier: String) {
            self.replicationSubnetGroupIdentifier = replicationSubnetGroupIdentifier
        }

        private enum CodingKeys: String, CodingKey {
            case replicationSubnetGroupIdentifier = "ReplicationSubnetGroupIdentifier"
        }
    }

    public struct DeleteReplicationSubnetGroupResponse: AWSDecodableShape {
        public init() {}
    }

    public struct DeleteReplicationTaskAssessmentRunMessage: AWSEncodableShape {
        /// Amazon Resource Name (ARN) of the premigration assessment run to be deleted.
        public let replicationTaskAssessmentRunArn: String

        public init(replicationTaskAssessmentRunArn: String) {
            self.replicationTaskAssessmentRunArn = replicationTaskAssessmentRunArn
        }

        private enum CodingKeys: String, CodingKey {
            case replicationTaskAssessmentRunArn = "ReplicationTaskAssessmentRunArn"
        }
    }

    public struct DeleteReplicationTaskAssessmentRunResponse: AWSDecodableShape {
        /// The ReplicationTaskAssessmentRun object for the deleted assessment run.
        public let replicationTaskAssessmentRun: ReplicationTaskAssessmentRun?

        public init(replicationTaskAssessmentRun: ReplicationTaskAssessmentRun? = nil) {
            self.replicationTaskAssessmentRun = replicationTaskAssessmentRun
        }

        private enum CodingKeys: String, CodingKey {
            case replicationTaskAssessmentRun = "ReplicationTaskAssessmentRun"
        }
    }

    public struct DeleteReplicationTaskMessage: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the replication task to be deleted.
        public let replicationTaskArn: String

        public init(replicationTaskArn: String) {
            self.replicationTaskArn = replicationTaskArn
        }

        private enum CodingKeys: String, CodingKey {
            case replicationTaskArn = "ReplicationTaskArn"
        }
    }

    public struct DeleteReplicationTaskResponse: AWSDecodableShape {
        /// The deleted replication task.
        public let replicationTask: ReplicationTask?

        public init(replicationTask: ReplicationTask? = nil) {
            self.replicationTask = replicationTask
        }

        private enum CodingKeys: String, CodingKey {
            case replicationTask = "ReplicationTask"
        }
    }

    public struct DescribeAccountAttributesMessage: AWSEncodableShape {
        public init() {}
    }

    public struct DescribeAccountAttributesResponse: AWSDecodableShape {
        /// Account quota information.
        public let accountQuotas: [AccountQuota]?
        /// A unique DMS identifier for an account in a particular Region. The value of this identifier has the following format: c99999999999. DMS uses this identifier to name artifacts. For example, DMS uses this identifier to name the default Amazon S3 bucket for storing task assessment reports in a given Region. The format of this S3 bucket name is the following: dms-AccountNumber-UniqueAccountIdentifier. Here is an example name for this default S3 bucket: dms-111122223333-c44445555666.  DMS supports the UniqueAccountIdentifier parameter in versions 3.1.4 and later.
        public let uniqueAccountIdentifier: String?

        public init(accountQuotas: [AccountQuota]? = nil, uniqueAccountIdentifier: String? = nil) {
            self.accountQuotas = accountQuotas
            self.uniqueAccountIdentifier = uniqueAccountIdentifier
        }

        private enum CodingKeys: String, CodingKey {
            case accountQuotas = "AccountQuotas"
            case uniqueAccountIdentifier = "UniqueAccountIdentifier"
        }
    }

    public struct DescribeApplicableIndividualAssessmentsMessage: AWSEncodableShape {
        /// Optional pagination token provided by a previous request. If this parameter is specified, the response includes only records beyond the marker, up to the value specified by MaxRecords.
        public let marker: String?
        /// Maximum number of records to include in the response. If more records exist than the specified MaxRecords value, a pagination token called a marker is included in the response so that the remaining results can be retrieved.
        public let maxRecords: Int?
        /// Name of the migration type that each provided individual assessment must support.
        public let migrationType: MigrationTypeValue?
        /// ARN of a replication instance on which you want to base the default list of individual assessments.
        public let replicationInstanceArn: String?
        /// Amazon Resource Name (ARN) of a migration task on which you want to base the default list of individual assessments.
        public let replicationTaskArn: String?
        /// Name of a database engine that the specified replication instance supports as a source.
        public let sourceEngineName: String?
        /// Name of a database engine that the specified replication instance supports as a target.
        public let targetEngineName: String?

        public init(marker: String? = nil, maxRecords: Int? = nil, migrationType: MigrationTypeValue? = nil, replicationInstanceArn: String? = nil, replicationTaskArn: String? = nil, sourceEngineName: String? = nil, targetEngineName: String? = nil) {
            self.marker = marker
            self.maxRecords = maxRecords
            self.migrationType = migrationType
            self.replicationInstanceArn = replicationInstanceArn
            self.replicationTaskArn = replicationTaskArn
            self.sourceEngineName = sourceEngineName
            self.targetEngineName = targetEngineName
        }

        private enum CodingKeys: String, CodingKey {
            case marker = "Marker"
            case maxRecords = "MaxRecords"
            case migrationType = "MigrationType"
            case replicationInstanceArn = "ReplicationInstanceArn"
            case replicationTaskArn = "ReplicationTaskArn"
            case sourceEngineName = "SourceEngineName"
            case targetEngineName = "TargetEngineName"
        }
    }

    public struct DescribeApplicableIndividualAssessmentsResponse: AWSDecodableShape {
        /// List of names for the individual assessments supported by the premigration assessment run that you start based on the specified request parameters. For more information on the available individual assessments, including compatibility with different migration task configurations, see Working with premigration assessment runs in the Database Migration Service User Guide.
        public let individualAssessmentNames: [String]?
        /// Pagination token returned for you to pass to a subsequent request. If you pass this token as the Marker value in a subsequent request, the response includes only records beyond the marker, up to the value specified in the request by MaxRecords.
        public let marker: String?

        public init(individualAssessmentNames: [String]? = nil, marker: String? = nil) {
            self.individualAssessmentNames = individualAssessmentNames
            self.marker = marker
        }

        private enum CodingKeys: String, CodingKey {
            case individualAssessmentNames = "IndividualAssessmentNames"
            case marker = "Marker"
        }
    }

    public struct DescribeCertificatesMessage: AWSEncodableShape {
        /// Filters applied to the certificates described in the form of key-value pairs.
        public let filters: [Filter]?
        ///  An optional pagination token provided by a previous request. If this parameter is specified, the response includes only records beyond the marker, up to the value specified by MaxRecords.
        public let marker: String?
        ///  The maximum number of records to include in the response. If more records exist than the specified MaxRecords value, a pagination token called a marker is included in the response so that the remaining results can be retrieved.  Default: 10
        public let maxRecords: Int?

        public init(filters: [Filter]? = nil, marker: String? = nil, maxRecords: Int? = nil) {
            self.filters = filters
            self.marker = marker
            self.maxRecords = maxRecords
        }

        private enum CodingKeys: String, CodingKey {
            case filters = "Filters"
            case marker = "Marker"
            case maxRecords = "MaxRecords"
        }
    }

    public struct DescribeCertificatesResponse: AWSDecodableShape {
        /// The Secure Sockets Layer (SSL) certificates associated with the replication instance.
        public let certificates: [Certificate]?
        /// The pagination token.
        public let marker: String?

        public init(certificates: [Certificate]? = nil, marker: String? = nil) {
            self.certificates = certificates
            self.marker = marker
        }

        private enum CodingKeys: String, CodingKey {
            case certificates = "Certificates"
            case marker = "Marker"
        }
    }

    public struct DescribeConnectionsMessage: AWSEncodableShape {
        /// The filters applied to the connection. Valid filter names: endpoint-arn | replication-instance-arn
        public let filters: [Filter]?
        ///  An optional pagination token provided by a previous request. If this parameter is specified, the response includes only records beyond the marker, up to the value specified by MaxRecords.
        public let marker: String?
        ///  The maximum number of records to include in the response. If more records exist than the specified MaxRecords value, a pagination token called a marker is included in the response so that the remaining results can be retrieved.  Default: 100 Constraints: Minimum 20, maximum 100.
        public let maxRecords: Int?

        public init(filters: [Filter]? = nil, marker: String? = nil, maxRecords: Int? = nil) {
            self.filters = filters
            self.marker = marker
            self.maxRecords = maxRecords
        }

        private enum CodingKeys: String, CodingKey {
            case filters = "Filters"
            case marker = "Marker"
            case maxRecords = "MaxRecords"
        }
    }

    public struct DescribeConnectionsResponse: AWSDecodableShape {
        /// A description of the connections.
        public let connections: [Connection]?
        ///  An optional pagination token provided by a previous request. If this parameter is specified, the response includes only records beyond the marker, up to the value specified by MaxRecords.
        public let marker: String?

        public init(connections: [Connection]? = nil, marker: String? = nil) {
            self.connections = connections
            self.marker = marker
        }

        private enum CodingKeys: String, CodingKey {
            case connections = "Connections"
            case marker = "Marker"
        }
    }

    public struct DescribeEndpointSettingsMessage: AWSEncodableShape {
        /// The databse engine used for your source or target endpoint.
        public let engineName: String
        /// An optional pagination token provided by a previous request. If this parameter is specified, the response includes only records beyond the marker, up to the value specified by MaxRecords.
        public let marker: String?
        /// The maximum number of records to include in the response. If more records exist than the specified MaxRecords value, a pagination token called a marker is included in the response so that the remaining results can be retrieved.
        public let maxRecords: Int?

        public init(engineName: String, marker: String? = nil, maxRecords: Int? = nil) {
            self.engineName = engineName
            self.marker = marker
            self.maxRecords = maxRecords
        }

        private enum CodingKeys: String, CodingKey {
            case engineName = "EngineName"
            case marker = "Marker"
            case maxRecords = "MaxRecords"
        }
    }

    public struct DescribeEndpointSettingsResponse: AWSDecodableShape {
        /// Descriptions of the endpoint settings available for your source or target database engine.
        public let endpointSettings: [EndpointSetting]?
        /// An optional pagination token provided by a previous request. If this parameter is specified, the response includes only records beyond the marker, up to the value specified by MaxRecords.
        public let marker: String?

        public init(endpointSettings: [EndpointSetting]? = nil, marker: String? = nil) {
            self.endpointSettings = endpointSettings
            self.marker = marker
        }

        private enum CodingKeys: String, CodingKey {
            case endpointSettings = "EndpointSettings"
            case marker = "Marker"
        }
    }

    public struct DescribeEndpointTypesMessage: AWSEncodableShape {
        /// Filters applied to the endpoint types. Valid filter names: engine-name | endpoint-type
        public let filters: [Filter]?
        ///  An optional pagination token provided by a previous request. If this parameter is specified, the response includes only records beyond the marker, up to the value specified by MaxRecords.
        public let marker: String?
        ///  The maximum number of records to include in the response. If more records exist than the specified MaxRecords value, a pagination token called a marker is included in the response so that the remaining results can be retrieved.  Default: 100 Constraints: Minimum 20, maximum 100.
        public let maxRecords: Int?

        public init(filters: [Filter]? = nil, marker: String? = nil, maxRecords: Int? = nil) {
            self.filters = filters
            self.marker = marker
            self.maxRecords = maxRecords
        }

        private enum CodingKeys: String, CodingKey {
            case filters = "Filters"
            case marker = "Marker"
            case maxRecords = "MaxRecords"
        }
    }

    public struct DescribeEndpointTypesResponse: AWSDecodableShape {
        ///  An optional pagination token provided by a previous request. If this parameter is specified, the response includes only records beyond the marker, up to the value specified by MaxRecords.
        public let marker: String?
        /// The types of endpoints that are supported.
        public let supportedEndpointTypes: [SupportedEndpointType]?

        public init(marker: String? = nil, supportedEndpointTypes: [SupportedEndpointType]? = nil) {
            self.marker = marker
            self.supportedEndpointTypes = supportedEndpointTypes
        }

        private enum CodingKeys: String, CodingKey {
            case marker = "Marker"
            case supportedEndpointTypes = "SupportedEndpointTypes"
        }
    }

    public struct DescribeEndpointsMessage: AWSEncodableShape {
        /// Filters applied to the endpoints. Valid filter names: endpoint-arn | endpoint-type | endpoint-id | engine-name
        public let filters: [Filter]?
        ///  An optional pagination token provided by a previous request. If this parameter is specified, the response includes only records beyond the marker, up to the value specified by MaxRecords.
        public let marker: String?
        ///  The maximum number of records to include in the response. If more records exist than the specified MaxRecords value, a pagination token called a marker is included in the response so that the remaining results can be retrieved.  Default: 100 Constraints: Minimum 20, maximum 100.
        public let maxRecords: Int?

        public init(filters: [Filter]? = nil, marker: String? = nil, maxRecords: Int? = nil) {
            self.filters = filters
            self.marker = marker
            self.maxRecords = maxRecords
        }

        private enum CodingKeys: String, CodingKey {
            case filters = "Filters"
            case marker = "Marker"
            case maxRecords = "MaxRecords"
        }
    }

    public struct DescribeEndpointsResponse: AWSDecodableShape {
        /// Endpoint description.
        public let endpoints: [Endpoint]?
        ///  An optional pagination token provided by a previous request. If this parameter is specified, the response includes only records beyond the marker, up to the value specified by MaxRecords.
        public let marker: String?

        public init(endpoints: [Endpoint]? = nil, marker: String? = nil) {
            self.endpoints = endpoints
            self.marker = marker
        }

        private enum CodingKeys: String, CodingKey {
            case endpoints = "Endpoints"
            case marker = "Marker"
        }
    }

    public struct DescribeEventCategoriesMessage: AWSEncodableShape {
        /// Filters applied to the event categories.
        public let filters: [Filter]?
        ///  The type of DMS resource that generates events.  Valid values: replication-instance | replication-task
        public let sourceType: String?

        public init(filters: [Filter]? = nil, sourceType: String? = nil) {
            self.filters = filters
            self.sourceType = sourceType
        }

        private enum CodingKeys: String, CodingKey {
            case filters = "Filters"
            case sourceType = "SourceType"
        }
    }

    public struct DescribeEventCategoriesResponse: AWSDecodableShape {
        /// A list of event categories.
        public let eventCategoryGroupList: [EventCategoryGroup]?

        public init(eventCategoryGroupList: [EventCategoryGroup]? = nil) {
            self.eventCategoryGroupList = eventCategoryGroupList
        }

        private enum CodingKeys: String, CodingKey {
            case eventCategoryGroupList = "EventCategoryGroupList"
        }
    }

    public struct DescribeEventSubscriptionsMessage: AWSEncodableShape {
        /// Filters applied to event subscriptions.
        public let filters: [Filter]?
        ///  An optional pagination token provided by a previous request. If this parameter is specified, the response includes only records beyond the marker, up to the value specified by MaxRecords.
        public let marker: String?
        ///  The maximum number of records to include in the response. If more records exist than the specified MaxRecords value, a pagination token called a marker is included in the response so that the remaining results can be retrieved.  Default: 100 Constraints: Minimum 20, maximum 100.
        public let maxRecords: Int?
        /// The name of the DMS event subscription to be described.
        public let subscriptionName: String?

        public init(filters: [Filter]? = nil, marker: String? = nil, maxRecords: Int? = nil, subscriptionName: String? = nil) {
            self.filters = filters
            self.marker = marker
            self.maxRecords = maxRecords
            self.subscriptionName = subscriptionName
        }

        private enum CodingKeys: String, CodingKey {
            case filters = "Filters"
            case marker = "Marker"
            case maxRecords = "MaxRecords"
            case subscriptionName = "SubscriptionName"
        }
    }

    public struct DescribeEventSubscriptionsResponse: AWSDecodableShape {
        /// A list of event subscriptions.
        public let eventSubscriptionsList: [EventSubscription]?
        ///  An optional pagination token provided by a previous request. If this parameter is specified, the response includes only records beyond the marker, up to the value specified by MaxRecords.
        public let marker: String?

        public init(eventSubscriptionsList: [EventSubscription]? = nil, marker: String? = nil) {
            self.eventSubscriptionsList = eventSubscriptionsList
            self.marker = marker
        }

        private enum CodingKeys: String, CodingKey {
            case eventSubscriptionsList = "EventSubscriptionsList"
            case marker = "Marker"
        }
    }

    public struct DescribeEventsMessage: AWSEncodableShape {
        /// The duration of the events to be listed.
        public let duration: Int?
        /// The end time for the events to be listed.
        public let endTime: Date?
        /// A list of event categories for the source type that you've chosen.
        public let eventCategories: [String]?
        /// Filters applied to events.
        public let filters: [Filter]?
        ///  An optional pagination token provided by a previous request. If this parameter is specified, the response includes only records beyond the marker, up to the value specified by MaxRecords.
        public let marker: String?
        ///  The maximum number of records to include in the response. If more records exist than the specified MaxRecords value, a pagination token called a marker is included in the response so that the remaining results can be retrieved.  Default: 100 Constraints: Minimum 20, maximum 100.
        public let maxRecords: Int?
        ///  The identifier of an event source.
        public let sourceIdentifier: String?
        /// The type of DMS resource that generates events. Valid values: replication-instance | replication-task
        public let sourceType: SourceType?
        /// The start time for the events to be listed.
        public let startTime: Date?

        public init(duration: Int? = nil, endTime: Date? = nil, eventCategories: [String]? = nil, filters: [Filter]? = nil, marker: String? = nil, maxRecords: Int? = nil, sourceIdentifier: String? = nil, sourceType: SourceType? = nil, startTime: Date? = nil) {
            self.duration = duration
            self.endTime = endTime
            self.eventCategories = eventCategories
            self.filters = filters
            self.marker = marker
            self.maxRecords = maxRecords
            self.sourceIdentifier = sourceIdentifier
            self.sourceType = sourceType
            self.startTime = startTime
        }

        private enum CodingKeys: String, CodingKey {
            case duration = "Duration"
            case endTime = "EndTime"
            case eventCategories = "EventCategories"
            case filters = "Filters"
            case marker = "Marker"
            case maxRecords = "MaxRecords"
            case sourceIdentifier = "SourceIdentifier"
            case sourceType = "SourceType"
            case startTime = "StartTime"
        }
    }

    public struct DescribeEventsResponse: AWSDecodableShape {
        /// The events described.
        public let events: [Event]?
        ///  An optional pagination token provided by a previous request. If this parameter is specified, the response includes only records beyond the marker, up to the value specified by MaxRecords.
        public let marker: String?

        public init(events: [Event]? = nil, marker: String? = nil) {
            self.events = events
            self.marker = marker
        }

        private enum CodingKeys: String, CodingKey {
            case events = "Events"
            case marker = "Marker"
        }
    }

    public struct DescribeOrderableReplicationInstancesMessage: AWSEncodableShape {
        ///  An optional pagination token provided by a previous request. If this parameter is specified, the response includes only records beyond the marker, up to the value specified by MaxRecords.
        public let marker: String?
        ///  The maximum number of records to include in the response. If more records exist than the specified MaxRecords value, a pagination token called a marker is included in the response so that the remaining results can be retrieved.  Default: 100 Constraints: Minimum 20, maximum 100.
        public let maxRecords: Int?

        public init(marker: String? = nil, maxRecords: Int? = nil) {
            self.marker = marker
            self.maxRecords = maxRecords
        }

        private enum CodingKeys: String, CodingKey {
            case marker = "Marker"
            case maxRecords = "MaxRecords"
        }
    }

    public struct DescribeOrderableReplicationInstancesResponse: AWSDecodableShape {
        ///  An optional pagination token provided by a previous request. If this parameter is specified, the response includes only records beyond the marker, up to the value specified by MaxRecords.
        public let marker: String?
        /// The order-able replication instances available.
        public let orderableReplicationInstances: [OrderableReplicationInstance]?

        public init(marker: String? = nil, orderableReplicationInstances: [OrderableReplicationInstance]? = nil) {
            self.marker = marker
            self.orderableReplicationInstances = orderableReplicationInstances
        }

        private enum CodingKeys: String, CodingKey {
            case marker = "Marker"
            case orderableReplicationInstances = "OrderableReplicationInstances"
        }
    }

    public struct DescribePendingMaintenanceActionsMessage: AWSEncodableShape {
        public let filters: [Filter]?
        ///  An optional pagination token provided by a previous request. If this parameter is specified, the response includes only records beyond the marker, up to the value specified by MaxRecords.
        public let marker: String?
        ///  The maximum number of records to include in the response. If more records exist than the specified MaxRecords value, a pagination token called a marker is included in the response so that the remaining results can be retrieved.  Default: 100 Constraints: Minimum 20, maximum 100.
        public let maxRecords: Int?
        /// The Amazon Resource Name (ARN) of the replication instance.
        public let replicationInstanceArn: String?

        public init(filters: [Filter]? = nil, marker: String? = nil, maxRecords: Int? = nil, replicationInstanceArn: String? = nil) {
            self.filters = filters
            self.marker = marker
            self.maxRecords = maxRecords
            self.replicationInstanceArn = replicationInstanceArn
        }

        private enum CodingKeys: String, CodingKey {
            case filters = "Filters"
            case marker = "Marker"
            case maxRecords = "MaxRecords"
            case replicationInstanceArn = "ReplicationInstanceArn"
        }
    }

    public struct DescribePendingMaintenanceActionsResponse: AWSDecodableShape {
        ///  An optional pagination token provided by a previous request. If this parameter is specified, the response includes only records beyond the marker, up to the value specified by MaxRecords.
        public let marker: String?
        /// The pending maintenance action.
        public let pendingMaintenanceActions: [ResourcePendingMaintenanceActions]?

        public init(marker: String? = nil, pendingMaintenanceActions: [ResourcePendingMaintenanceActions]? = nil) {
            self.marker = marker
            self.pendingMaintenanceActions = pendingMaintenanceActions
        }

        private enum CodingKeys: String, CodingKey {
            case marker = "Marker"
            case pendingMaintenanceActions = "PendingMaintenanceActions"
        }
    }

    public struct DescribeRefreshSchemasStatusMessage: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) string that uniquely identifies the endpoint.
        public let endpointArn: String

        public init(endpointArn: String) {
            self.endpointArn = endpointArn
        }

        private enum CodingKeys: String, CodingKey {
            case endpointArn = "EndpointArn"
        }
    }

    public struct DescribeRefreshSchemasStatusResponse: AWSDecodableShape {
        /// The status of the schema.
        public let refreshSchemasStatus: RefreshSchemasStatus?

        public init(refreshSchemasStatus: RefreshSchemasStatus? = nil) {
            self.refreshSchemasStatus = refreshSchemasStatus
        }

        private enum CodingKeys: String, CodingKey {
            case refreshSchemasStatus = "RefreshSchemasStatus"
        }
    }

    public struct DescribeReplicationInstanceTaskLogsMessage: AWSEncodableShape {
        ///  An optional pagination token provided by a previous request. If this parameter is specified, the response includes only records beyond the marker, up to the value specified by MaxRecords.
        public let marker: String?
        ///  The maximum number of records to include in the response. If more records exist than the specified MaxRecords value, a pagination token called a marker is included in the response so that the remaining results can be retrieved.  Default: 100 Constraints: Minimum 20, maximum 100.
        public let maxRecords: Int?
        /// The Amazon Resource Name (ARN) of the replication instance.
        public let replicationInstanceArn: String

        public init(marker: String? = nil, maxRecords: Int? = nil, replicationInstanceArn: String) {
            self.marker = marker
            self.maxRecords = maxRecords
            self.replicationInstanceArn = replicationInstanceArn
        }

        private enum CodingKeys: String, CodingKey {
            case marker = "Marker"
            case maxRecords = "MaxRecords"
            case replicationInstanceArn = "ReplicationInstanceArn"
        }
    }

    public struct DescribeReplicationInstanceTaskLogsResponse: AWSDecodableShape {
        ///  An optional pagination token provided by a previous request. If this parameter is specified, the response includes only records beyond the marker, up to the value specified by MaxRecords.
        public let marker: String?
        /// The Amazon Resource Name (ARN) of the replication instance.
        public let replicationInstanceArn: String?
        /// An array of replication task log metadata. Each member of the array contains the replication task name, ARN, and task log size (in bytes).
        public let replicationInstanceTaskLogs: [ReplicationInstanceTaskLog]?

        public init(marker: String? = nil, replicationInstanceArn: String? = nil, replicationInstanceTaskLogs: [ReplicationInstanceTaskLog]? = nil) {
            self.marker = marker
            self.replicationInstanceArn = replicationInstanceArn
            self.replicationInstanceTaskLogs = replicationInstanceTaskLogs
        }

        private enum CodingKeys: String, CodingKey {
            case marker = "Marker"
            case replicationInstanceArn = "ReplicationInstanceArn"
            case replicationInstanceTaskLogs = "ReplicationInstanceTaskLogs"
        }
    }

    public struct DescribeReplicationInstancesMessage: AWSEncodableShape {
        /// Filters applied to replication instances. Valid filter names: replication-instance-arn | replication-instance-id | replication-instance-class | engine-version
        public let filters: [Filter]?
        ///  An optional pagination token provided by a previous request. If this parameter is specified, the response includes only records beyond the marker, up to the value specified by MaxRecords.
        public let marker: String?
        ///  The maximum number of records to include in the response. If more records exist than the specified MaxRecords value, a pagination token called a marker is included in the response so that the remaining results can be retrieved.  Default: 100 Constraints: Minimum 20, maximum 100.
        public let maxRecords: Int?

        public init(filters: [Filter]? = nil, marker: String? = nil, maxRecords: Int? = nil) {
            self.filters = filters
            self.marker = marker
            self.maxRecords = maxRecords
        }

        private enum CodingKeys: String, CodingKey {
            case filters = "Filters"
            case marker = "Marker"
            case maxRecords = "MaxRecords"
        }
    }

    public struct DescribeReplicationInstancesResponse: AWSDecodableShape {
        ///  An optional pagination token provided by a previous request. If this parameter is specified, the response includes only records beyond the marker, up to the value specified by MaxRecords.
        public let marker: String?
        /// The replication instances described.
        public let replicationInstances: [ReplicationInstance]?

        public init(marker: String? = nil, replicationInstances: [ReplicationInstance]? = nil) {
            self.marker = marker
            self.replicationInstances = replicationInstances
        }

        private enum CodingKeys: String, CodingKey {
            case marker = "Marker"
            case replicationInstances = "ReplicationInstances"
        }
    }

    public struct DescribeReplicationSubnetGroupsMessage: AWSEncodableShape {
        /// Filters applied to replication subnet groups. Valid filter names: replication-subnet-group-id
        public let filters: [Filter]?
        ///  An optional pagination token provided by a previous request. If this parameter is specified, the response includes only records beyond the marker, up to the value specified by MaxRecords.
        public let marker: String?
        ///  The maximum number of records to include in the response. If more records exist than the specified MaxRecords value, a pagination token called a marker is included in the response so that the remaining results can be retrieved.  Default: 100 Constraints: Minimum 20, maximum 100.
        public let maxRecords: Int?

        public init(filters: [Filter]? = nil, marker: String? = nil, maxRecords: Int? = nil) {
            self.filters = filters
            self.marker = marker
            self.maxRecords = maxRecords
        }

        private enum CodingKeys: String, CodingKey {
            case filters = "Filters"
            case marker = "Marker"
            case maxRecords = "MaxRecords"
        }
    }

    public struct DescribeReplicationSubnetGroupsResponse: AWSDecodableShape {
        ///  An optional pagination token provided by a previous request. If this parameter is specified, the response includes only records beyond the marker, up to the value specified by MaxRecords.
        public let marker: String?
        /// A description of the replication subnet groups.
        public let replicationSubnetGroups: [ReplicationSubnetGroup]?

        public init(marker: String? = nil, replicationSubnetGroups: [ReplicationSubnetGroup]? = nil) {
            self.marker = marker
            self.replicationSubnetGroups = replicationSubnetGroups
        }

        private enum CodingKeys: String, CodingKey {
            case marker = "Marker"
            case replicationSubnetGroups = "ReplicationSubnetGroups"
        }
    }

    public struct DescribeReplicationTaskAssessmentResultsMessage: AWSEncodableShape {
        ///  An optional pagination token provided by a previous request. If this parameter is specified, the response includes only records beyond the marker, up to the value specified by MaxRecords.
        public let marker: String?
        ///  The maximum number of records to include in the response. If more records exist than the specified MaxRecords value, a pagination token called a marker is included in the response so that the remaining results can be retrieved.  Default: 100 Constraints: Minimum 20, maximum 100.
        public let maxRecords: Int?
        /// The Amazon Resource Name (ARN) string that uniquely identifies the task. When this input parameter is specified, the API returns only one result and ignore the values of the MaxRecords and Marker parameters.
        public let replicationTaskArn: String?

        public init(marker: String? = nil, maxRecords: Int? = nil, replicationTaskArn: String? = nil) {
            self.marker = marker
            self.maxRecords = maxRecords
            self.replicationTaskArn = replicationTaskArn
        }

        private enum CodingKeys: String, CodingKey {
            case marker = "Marker"
            case maxRecords = "MaxRecords"
            case replicationTaskArn = "ReplicationTaskArn"
        }
    }

    public struct DescribeReplicationTaskAssessmentResultsResponse: AWSDecodableShape {
        /// - The Amazon S3 bucket where the task assessment report is located.
        public let bucketName: String?
        ///  An optional pagination token provided by a previous request. If this parameter is specified, the response includes only records beyond the marker, up to the value specified by MaxRecords.
        public let marker: String?
        ///  The task assessment report.
        public let replicationTaskAssessmentResults: [ReplicationTaskAssessmentResult]?

        public init(bucketName: String? = nil, marker: String? = nil, replicationTaskAssessmentResults: [ReplicationTaskAssessmentResult]? = nil) {
            self.bucketName = bucketName
            self.marker = marker
            self.replicationTaskAssessmentResults = replicationTaskAssessmentResults
        }

        private enum CodingKeys: String, CodingKey {
            case bucketName = "BucketName"
            case marker = "Marker"
            case replicationTaskAssessmentResults = "ReplicationTaskAssessmentResults"
        }
    }

    public struct DescribeReplicationTaskAssessmentRunsMessage: AWSEncodableShape {
        /// Filters applied to the premigration assessment runs described in the form of key-value pairs. Valid filter names: replication-task-assessment-run-arn, replication-task-arn, replication-instance-arn, status
        public let filters: [Filter]?
        /// An optional pagination token provided by a previous request. If this parameter is specified, the response includes only records beyond the marker, up to the value specified by MaxRecords.
        public let marker: String?
        /// The maximum number of records to include in the response. If more records exist than the specified MaxRecords value, a pagination token called a marker is included in the response so that the remaining results can be retrieved.
        public let maxRecords: Int?

        public init(filters: [Filter]? = nil, marker: String? = nil, maxRecords: Int? = nil) {
            self.filters = filters
            self.marker = marker
            self.maxRecords = maxRecords
        }

        private enum CodingKeys: String, CodingKey {
            case filters = "Filters"
            case marker = "Marker"
            case maxRecords = "MaxRecords"
        }
    }

    public struct DescribeReplicationTaskAssessmentRunsResponse: AWSDecodableShape {
        /// A pagination token returned for you to pass to a subsequent request. If you pass this token as the Marker value in a subsequent request, the response includes only records beyond the marker, up to the value specified in the request by MaxRecords.
        public let marker: String?
        /// One or more premigration assessment runs as specified by Filters.
        public let replicationTaskAssessmentRuns: [ReplicationTaskAssessmentRun]?

        public init(marker: String? = nil, replicationTaskAssessmentRuns: [ReplicationTaskAssessmentRun]? = nil) {
            self.marker = marker
            self.replicationTaskAssessmentRuns = replicationTaskAssessmentRuns
        }

        private enum CodingKeys: String, CodingKey {
            case marker = "Marker"
            case replicationTaskAssessmentRuns = "ReplicationTaskAssessmentRuns"
        }
    }

    public struct DescribeReplicationTaskIndividualAssessmentsMessage: AWSEncodableShape {
        /// Filters applied to the individual assessments described in the form of key-value pairs. Valid filter names: replication-task-assessment-run-arn, replication-task-arn, status
        public let filters: [Filter]?
        /// An optional pagination token provided by a previous request. If this parameter is specified, the response includes only records beyond the marker, up to the value specified by MaxRecords.
        public let marker: String?
        /// The maximum number of records to include in the response. If more records exist than the specified MaxRecords value, a pagination token called a marker is included in the response so that the remaining results can be retrieved.
        public let maxRecords: Int?

        public init(filters: [Filter]? = nil, marker: String? = nil, maxRecords: Int? = nil) {
            self.filters = filters
            self.marker = marker
            self.maxRecords = maxRecords
        }

        private enum CodingKeys: String, CodingKey {
            case filters = "Filters"
            case marker = "Marker"
            case maxRecords = "MaxRecords"
        }
    }

    public struct DescribeReplicationTaskIndividualAssessmentsResponse: AWSDecodableShape {
        /// A pagination token returned for you to pass to a subsequent request. If you pass this token as the Marker value in a subsequent request, the response includes only records beyond the marker, up to the value specified in the request by MaxRecords.
        public let marker: String?
        /// One or more individual assessments as specified by Filters.
        public let replicationTaskIndividualAssessments: [ReplicationTaskIndividualAssessment]?

        public init(marker: String? = nil, replicationTaskIndividualAssessments: [ReplicationTaskIndividualAssessment]? = nil) {
            self.marker = marker
            self.replicationTaskIndividualAssessments = replicationTaskIndividualAssessments
        }

        private enum CodingKeys: String, CodingKey {
            case marker = "Marker"
            case replicationTaskIndividualAssessments = "ReplicationTaskIndividualAssessments"
        }
    }

    public struct DescribeReplicationTasksMessage: AWSEncodableShape {
        /// Filters applied to replication tasks. Valid filter names: replication-task-arn | replication-task-id | migration-type | endpoint-arn | replication-instance-arn
        public let filters: [Filter]?
        ///  An optional pagination token provided by a previous request. If this parameter is specified, the response includes only records beyond the marker, up to the value specified by MaxRecords.
        public let marker: String?
        ///  The maximum number of records to include in the response. If more records exist than the specified MaxRecords value, a pagination token called a marker is included in the response so that the remaining results can be retrieved.  Default: 100 Constraints: Minimum 20, maximum 100.
        public let maxRecords: Int?
        /// An option to set to avoid returning information about settings. Use this to reduce overhead when setting information is too large. To use this option, choose true; otherwise, choose false (the default).
        public let withoutSettings: Bool?

        public init(filters: [Filter]? = nil, marker: String? = nil, maxRecords: Int? = nil, withoutSettings: Bool? = nil) {
            self.filters = filters
            self.marker = marker
            self.maxRecords = maxRecords
            self.withoutSettings = withoutSettings
        }

        private enum CodingKeys: String, CodingKey {
            case filters = "Filters"
            case marker = "Marker"
            case maxRecords = "MaxRecords"
            case withoutSettings = "WithoutSettings"
        }
    }

    public struct DescribeReplicationTasksResponse: AWSDecodableShape {
        ///  An optional pagination token provided by a previous request. If this parameter is specified, the response includes only records beyond the marker, up to the value specified by MaxRecords.
        public let marker: String?
        /// A description of the replication tasks.
        public let replicationTasks: [ReplicationTask]?

        public init(marker: String? = nil, replicationTasks: [ReplicationTask]? = nil) {
            self.marker = marker
            self.replicationTasks = replicationTasks
        }

        private enum CodingKeys: String, CodingKey {
            case marker = "Marker"
            case replicationTasks = "ReplicationTasks"
        }
    }

    public struct DescribeSchemasMessage: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) string that uniquely identifies the endpoint.
        public let endpointArn: String
        ///  An optional pagination token provided by a previous request. If this parameter is specified, the response includes only records beyond the marker, up to the value specified by MaxRecords.
        public let marker: String?
        ///  The maximum number of records to include in the response. If more records exist than the specified MaxRecords value, a pagination token called a marker is included in the response so that the remaining results can be retrieved.  Default: 100 Constraints: Minimum 20, maximum 100.
        public let maxRecords: Int?

        public init(endpointArn: String, marker: String? = nil, maxRecords: Int? = nil) {
            self.endpointArn = endpointArn
            self.marker = marker
            self.maxRecords = maxRecords
        }

        private enum CodingKeys: String, CodingKey {
            case endpointArn = "EndpointArn"
            case marker = "Marker"
            case maxRecords = "MaxRecords"
        }
    }

    public struct DescribeSchemasResponse: AWSDecodableShape {
        ///  An optional pagination token provided by a previous request. If this parameter is specified, the response includes only records beyond the marker, up to the value specified by MaxRecords.
        public let marker: String?
        /// The described schema.
        public let schemas: [String]?

        public init(marker: String? = nil, schemas: [String]? = nil) {
            self.marker = marker
            self.schemas = schemas
        }

        private enum CodingKeys: String, CodingKey {
            case marker = "Marker"
            case schemas = "Schemas"
        }
    }

    public struct DescribeTableStatisticsMessage: AWSEncodableShape {
        /// Filters applied to table statistics. Valid filter names: schema-name | table-name | table-state A combination of filters creates an AND condition where each record matches all specified filters.
        public let filters: [Filter]?
        ///  An optional pagination token provided by a previous request. If this parameter is specified, the response includes only records beyond the marker, up to the value specified by MaxRecords.
        public let marker: String?
        ///  The maximum number of records to include in the response. If more records exist than the specified MaxRecords value, a pagination token called a marker is included in the response so that the remaining results can be retrieved.  Default: 100 Constraints: Minimum 20, maximum 500.
        public let maxRecords: Int?
        /// The Amazon Resource Name (ARN) of the replication task.
        public let replicationTaskArn: String

        public init(filters: [Filter]? = nil, marker: String? = nil, maxRecords: Int? = nil, replicationTaskArn: String) {
            self.filters = filters
            self.marker = marker
            self.maxRecords = maxRecords
            self.replicationTaskArn = replicationTaskArn
        }

        private enum CodingKeys: String, CodingKey {
            case filters = "Filters"
            case marker = "Marker"
            case maxRecords = "MaxRecords"
            case replicationTaskArn = "ReplicationTaskArn"
        }
    }

    public struct DescribeTableStatisticsResponse: AWSDecodableShape {
        ///  An optional pagination token provided by a previous request. If this parameter is specified, the response includes only records beyond the marker, up to the value specified by MaxRecords.
        public let marker: String?
        /// The Amazon Resource Name (ARN) of the replication task.
        public let replicationTaskArn: String?
        /// The table statistics.
        public let tableStatistics: [TableStatistics]?

        public init(marker: String? = nil, replicationTaskArn: String? = nil, tableStatistics: [TableStatistics]? = nil) {
            self.marker = marker
            self.replicationTaskArn = replicationTaskArn
            self.tableStatistics = tableStatistics
        }

        private enum CodingKeys: String, CodingKey {
            case marker = "Marker"
            case replicationTaskArn = "ReplicationTaskArn"
            case tableStatistics = "TableStatistics"
        }
    }

    public struct DmsTransferSettings: AWSEncodableShape & AWSDecodableShape {
        ///  The name of the S3 bucket to use.
        public let bucketName: String?
        ///  The IAM role that has permission to access the Amazon S3 bucket. When specified as part of request syntax, such as for the CreateEndpoint and ModifyEndpoint actions, the role must allow the iam:PassRole action.
        public let serviceAccessRoleArn: String?

        public init(bucketName: String? = nil, serviceAccessRoleArn: String? = nil) {
            self.bucketName = bucketName
            self.serviceAccessRoleArn = serviceAccessRoleArn
        }

        private enum CodingKeys: String, CodingKey {
            case bucketName = "BucketName"
            case serviceAccessRoleArn = "ServiceAccessRoleArn"
        }
    }

    public struct DocDbSettings: AWSEncodableShape & AWSDecodableShape {
        ///  The database name on the DocumentDB source endpoint.
        public let databaseName: String?
        ///  Indicates the number of documents to preview to determine the document organization. Use this setting when NestingLevel is set to "one".  Must be a positive value greater than 0. Default value is 1000.
        public let docsToInvestigate: Int?
        ///  Specifies the document ID. Use this setting when NestingLevel is set to "none".  Default value is "false".
        public let extractDocId: Bool?
        /// The KMS key identifier that is used to encrypt the content on the replication instance. If you don't specify a value for the KmsKeyId parameter, then DMS uses your default encryption key. KMS creates the default encryption key for your account. Your account has a different default encryption key for each Region.
        public let kmsKeyId: String?
        ///  Specifies either document or table mode.  Default value is "none". Specify "none" to use document mode. Specify "one" to use table mode.
        public let nestingLevel: NestingLevelValue?
        ///  The password for the user account you use to access the DocumentDB source endpoint.
        public let password: String?
        ///  The port value for the DocumentDB source endpoint.
        public let port: Int?
        /// The full Amazon Resource Name (ARN) of the IAM role that specifies DMS as the trusted entity and grants the required permissions to access the value in SecretsManagerSecret. The role must allow the iam:PassRole action. SecretsManagerSecret has the value of the Amazon Web Services Secrets Manager secret that allows access to the DocumentDB endpoint.  You can specify one of two sets of values for these permissions. You can specify the values for this setting and SecretsManagerSecretId. Or you can specify clear-text values for UserName, Password, ServerName, and Port. You can't specify both. For more information on creating this SecretsManagerSecret and the SecretsManagerAccessRoleArn and SecretsManagerSecretId required to access it, see Using secrets to access Database Migration Service resources in the Database Migration Service User Guide.
        public let secretsManagerAccessRoleArn: String?
        /// The full ARN, partial ARN, or friendly name of the SecretsManagerSecret that contains the DocumentDB endpoint connection details.
        public let secretsManagerSecretId: String?
        ///  The name of the server on the DocumentDB source endpoint.
        public let serverName: String?
        /// The user name you use to access the DocumentDB source endpoint.
        public let username: String?

        public init(databaseName: String? = nil, docsToInvestigate: Int? = nil, extractDocId: Bool? = nil, kmsKeyId: String? = nil, nestingLevel: NestingLevelValue? = nil, password: String? = nil, port: Int? = nil, secretsManagerAccessRoleArn: String? = nil, secretsManagerSecretId: String? = nil, serverName: String? = nil, username: String? = nil) {
            self.databaseName = databaseName
            self.docsToInvestigate = docsToInvestigate
            self.extractDocId = extractDocId
            self.kmsKeyId = kmsKeyId
            self.nestingLevel = nestingLevel
            self.password = password
            self.port = port
            self.secretsManagerAccessRoleArn = secretsManagerAccessRoleArn
            self.secretsManagerSecretId = secretsManagerSecretId
            self.serverName = serverName
            self.username = username
        }

        private enum CodingKeys: String, CodingKey {
            case databaseName = "DatabaseName"
            case docsToInvestigate = "DocsToInvestigate"
            case extractDocId = "ExtractDocId"
            case kmsKeyId = "KmsKeyId"
            case nestingLevel = "NestingLevel"
            case password = "Password"
            case port = "Port"
            case secretsManagerAccessRoleArn = "SecretsManagerAccessRoleArn"
            case secretsManagerSecretId = "SecretsManagerSecretId"
            case serverName = "ServerName"
            case username = "Username"
        }
    }

    public struct DynamoDbSettings: AWSEncodableShape & AWSDecodableShape {
        ///  The Amazon Resource Name (ARN) used by the service to access the IAM role. The role must allow the iam:PassRole action.
        public let serviceAccessRoleArn: String

        public init(serviceAccessRoleArn: String) {
            self.serviceAccessRoleArn = serviceAccessRoleArn
        }

        private enum CodingKeys: String, CodingKey {
            case serviceAccessRoleArn = "ServiceAccessRoleArn"
        }
    }

    public struct ElasticsearchSettings: AWSEncodableShape & AWSDecodableShape {
        /// The endpoint for the Elasticsearch cluster. DMS uses HTTPS if a transport protocol (http/https) is not specified.
        public let endpointUri: String
        /// The maximum number of seconds for which DMS retries failed API requests to the Elasticsearch cluster.
        public let errorRetryDuration: Int?
        /// The maximum percentage of records that can fail to be written before a full load operation stops. To avoid early failure, this counter is only effective after 1000 records are transferred. Elasticsearch also has the concept of error monitoring during the last 10 minutes of an Observation Window. If transfer of all records fail in the last 10 minutes, the full load operation stops.
        public let fullLoadErrorPercentage: Int?
        /// The Amazon Resource Name (ARN) used by the service to access the IAM role. The role must allow the iam:PassRole action.
        public let serviceAccessRoleArn: String

        public init(endpointUri: String, errorRetryDuration: Int? = nil, fullLoadErrorPercentage: Int? = nil, serviceAccessRoleArn: String) {
            self.endpointUri = endpointUri
            self.errorRetryDuration = errorRetryDuration
            self.fullLoadErrorPercentage = fullLoadErrorPercentage
            self.serviceAccessRoleArn = serviceAccessRoleArn
        }

        private enum CodingKeys: String, CodingKey {
            case endpointUri = "EndpointUri"
            case errorRetryDuration = "ErrorRetryDuration"
            case fullLoadErrorPercentage = "FullLoadErrorPercentage"
            case serviceAccessRoleArn = "ServiceAccessRoleArn"
        }
    }

    public struct Endpoint: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) used for SSL connection to the endpoint.
        public let certificateArn: String?
        /// The name of the database at the endpoint.
        public let databaseName: String?
        /// The settings in JSON format for the DMS transfer type of source endpoint.  Possible settings include the following:    ServiceAccessRoleArn - The IAM role that has permission to access the Amazon S3 bucket. The role must allow the iam:PassRole action.    BucketName - The name of the S3 bucket to use.   Shorthand syntax for these settings is as follows: ServiceAccessRoleArn=string,BucketName=string,  JSON syntax for these settings is as follows: { "ServiceAccessRoleArn": "string", "BucketName": "string"}
        public let dmsTransferSettings: DmsTransferSettings?
        public let docDbSettings: DocDbSettings?
        /// The settings for the DynamoDB target endpoint. For more information, see the DynamoDBSettings structure.
        public let dynamoDbSettings: DynamoDbSettings?
        /// The settings for the Elasticsearch source endpoint. For more information, see the ElasticsearchSettings structure.
        public let elasticsearchSettings: ElasticsearchSettings?
        /// The Amazon Resource Name (ARN) string that uniquely identifies the endpoint.
        public let endpointArn: String?
        /// The database endpoint identifier. Identifiers must begin with a letter and must contain only ASCII letters, digits, and hyphens. They can't end with a hyphen or contain two consecutive hyphens.
        public let endpointIdentifier: String?
        /// The type of endpoint. Valid values are source and target.
        public let endpointType: ReplicationEndpointTypeValue?
        /// The expanded name for the engine name. For example, if the EngineName parameter is "aurora," this value would be "Amazon Aurora MySQL."
        public let engineDisplayName: String?
        /// The database engine name. Valid values, depending on the EndpointType, include "mysql", "oracle", "postgres", "mariadb", "aurora", "aurora-postgresql", "redshift", "s3", "db2", "azuredb", "sybase", "dynamodb", "mongodb", "kinesis", "kafka", "elasticsearch", "documentdb", "sqlserver", and "neptune".
        public let engineName: String?
        ///  Value returned by a call to CreateEndpoint that can be used for cross-account validation. Use it on a subsequent call to CreateEndpoint to create the endpoint with a cross-account.
        public let externalId: String?
        /// The external table definition.
        public let externalTableDefinition: String?
        /// Additional connection attributes used to connect to the endpoint.
        public let extraConnectionAttributes: String?
        /// The settings for the IBM Db2 LUW source endpoint. For more information, see the IBMDb2Settings structure.
        public let iBMDb2Settings: IBMDb2Settings?
        /// The settings for the Apache Kafka target endpoint. For more information, see the KafkaSettings structure.
        public let kafkaSettings: KafkaSettings?
        /// The settings for the Amazon Kinesis target endpoint. For more information, see the KinesisSettings structure.
        public let kinesisSettings: KinesisSettings?
        /// An KMS key identifier that is used to encrypt the connection parameters for the endpoint. If you don't specify a value for the KmsKeyId parameter, then DMS uses your default encryption key. KMS creates the default encryption key for your account. Your account has a different default encryption key for each Region.
        public let kmsKeyId: String?
        /// The settings for the Microsoft SQL Server source and target endpoint. For more information, see the MicrosoftSQLServerSettings structure.
        public let microsoftSQLServerSettings: MicrosoftSQLServerSettings?
        /// The settings for the MongoDB source endpoint. For more information, see the MongoDbSettings structure.
        public let mongoDbSettings: MongoDbSettings?
        /// The settings for the MySQL source and target endpoint. For more information, see the MySQLSettings structure.
        public let mySQLSettings: MySQLSettings?
        /// The settings for the Amazon Neptune target endpoint. For more information, see the NeptuneSettings structure.
        public let neptuneSettings: NeptuneSettings?
        /// The settings for the Oracle source and target endpoint. For more information, see the OracleSettings structure.
        public let oracleSettings: OracleSettings?
        /// The port value used to access the endpoint.
        public let port: Int?
        /// The settings for the PostgreSQL source and target endpoint. For more information, see the PostgreSQLSettings structure.
        public let postgreSQLSettings: PostgreSQLSettings?
        /// Settings for the Amazon Redshift endpoint.
        public let redshiftSettings: RedshiftSettings?
        /// The settings for the S3 target endpoint. For more information, see the S3Settings structure.
        public let s3Settings: S3Settings?
        /// The name of the server at the endpoint.
        public let serverName: String?
        /// The Amazon Resource Name (ARN) used by the service to access the IAM role. The role must allow the iam:PassRole action.
        public let serviceAccessRoleArn: String?
        /// The SSL mode used to connect to the endpoint. The default value is none.
        public let sslMode: DmsSslModeValue?
        /// The status of the endpoint.
        public let status: String?
        /// The settings for the SAP ASE source and target endpoint. For more information, see the SybaseSettings structure.
        public let sybaseSettings: SybaseSettings?
        /// The user name used to connect to the endpoint.
        public let username: String?

        public init(certificateArn: String? = nil, databaseName: String? = nil, dmsTransferSettings: DmsTransferSettings? = nil, docDbSettings: DocDbSettings? = nil, dynamoDbSettings: DynamoDbSettings? = nil, elasticsearchSettings: ElasticsearchSettings? = nil, endpointArn: String? = nil, endpointIdentifier: String? = nil, endpointType: ReplicationEndpointTypeValue? = nil, engineDisplayName: String? = nil, engineName: String? = nil, externalId: String? = nil, externalTableDefinition: String? = nil, extraConnectionAttributes: String? = nil, iBMDb2Settings: IBMDb2Settings? = nil, kafkaSettings: KafkaSettings? = nil, kinesisSettings: KinesisSettings? = nil, kmsKeyId: String? = nil, microsoftSQLServerSettings: MicrosoftSQLServerSettings? = nil, mongoDbSettings: MongoDbSettings? = nil, mySQLSettings: MySQLSettings? = nil, neptuneSettings: NeptuneSettings? = nil, oracleSettings: OracleSettings? = nil, port: Int? = nil, postgreSQLSettings: PostgreSQLSettings? = nil, redshiftSettings: RedshiftSettings? = nil, s3Settings: S3Settings? = nil, serverName: String? = nil, serviceAccessRoleArn: String? = nil, sslMode: DmsSslModeValue? = nil, status: String? = nil, sybaseSettings: SybaseSettings? = nil, username: String? = nil) {
            self.certificateArn = certificateArn
            self.databaseName = databaseName
            self.dmsTransferSettings = dmsTransferSettings
            self.docDbSettings = docDbSettings
            self.dynamoDbSettings = dynamoDbSettings
            self.elasticsearchSettings = elasticsearchSettings
            self.endpointArn = endpointArn
            self.endpointIdentifier = endpointIdentifier
            self.endpointType = endpointType
            self.engineDisplayName = engineDisplayName
            self.engineName = engineName
            self.externalId = externalId
            self.externalTableDefinition = externalTableDefinition
            self.extraConnectionAttributes = extraConnectionAttributes
            self.iBMDb2Settings = iBMDb2Settings
            self.kafkaSettings = kafkaSettings
            self.kinesisSettings = kinesisSettings
            self.kmsKeyId = kmsKeyId
            self.microsoftSQLServerSettings = microsoftSQLServerSettings
            self.mongoDbSettings = mongoDbSettings
            self.mySQLSettings = mySQLSettings
            self.neptuneSettings = neptuneSettings
            self.oracleSettings = oracleSettings
            self.port = port
            self.postgreSQLSettings = postgreSQLSettings
            self.redshiftSettings = redshiftSettings
            self.s3Settings = s3Settings
            self.serverName = serverName
            self.serviceAccessRoleArn = serviceAccessRoleArn
            self.sslMode = sslMode
            self.status = status
            self.sybaseSettings = sybaseSettings
            self.username = username
        }

        private enum CodingKeys: String, CodingKey {
            case certificateArn = "CertificateArn"
            case databaseName = "DatabaseName"
            case dmsTransferSettings = "DmsTransferSettings"
            case docDbSettings = "DocDbSettings"
            case dynamoDbSettings = "DynamoDbSettings"
            case elasticsearchSettings = "ElasticsearchSettings"
            case endpointArn = "EndpointArn"
            case endpointIdentifier = "EndpointIdentifier"
            case endpointType = "EndpointType"
            case engineDisplayName = "EngineDisplayName"
            case engineName = "EngineName"
            case externalId = "ExternalId"
            case externalTableDefinition = "ExternalTableDefinition"
            case extraConnectionAttributes = "ExtraConnectionAttributes"
            case iBMDb2Settings = "IBMDb2Settings"
            case kafkaSettings = "KafkaSettings"
            case kinesisSettings = "KinesisSettings"
            case kmsKeyId = "KmsKeyId"
            case microsoftSQLServerSettings = "MicrosoftSQLServerSettings"
            case mongoDbSettings = "MongoDbSettings"
            case mySQLSettings = "MySQLSettings"
            case neptuneSettings = "NeptuneSettings"
            case oracleSettings = "OracleSettings"
            case port = "Port"
            case postgreSQLSettings = "PostgreSQLSettings"
            case redshiftSettings = "RedshiftSettings"
            case s3Settings = "S3Settings"
            case serverName = "ServerName"
            case serviceAccessRoleArn = "ServiceAccessRoleArn"
            case sslMode = "SslMode"
            case status = "Status"
            case sybaseSettings = "SybaseSettings"
            case username = "Username"
        }
    }

    public struct EndpointSetting: AWSDecodableShape {
        /// The relevance or validity of an endpoint setting for an engine name and its endpoint type.
        public let applicability: String?
        /// The default value of the endpoint setting if no value is specified using CreateEndpoint or ModifyEndpoint.
        public let defaultValue: String?
        /// Enumerated values to use for this endpoint.
        public let enumValues: [String]?
        /// The maximum value of an endpoint setting that is of type int.
        public let intValueMax: Int?
        /// The minimum value of an endpoint setting that is of type int.
        public let intValueMin: Int?
        /// The name that you want to give the endpoint settings.
        public let name: String?
        /// A value that marks this endpoint setting as sensitive.
        public let sensitive: Bool?
        /// The type of endpoint. Valid values are source and target.
        public let type: EndpointSettingTypeValue?
        /// The unit of measure for this endpoint setting.
        public let units: String?

        public init(applicability: String? = nil, defaultValue: String? = nil, enumValues: [String]? = nil, intValueMax: Int? = nil, intValueMin: Int? = nil, name: String? = nil, sensitive: Bool? = nil, type: EndpointSettingTypeValue? = nil, units: String? = nil) {
            self.applicability = applicability
            self.defaultValue = defaultValue
            self.enumValues = enumValues
            self.intValueMax = intValueMax
            self.intValueMin = intValueMin
            self.name = name
            self.sensitive = sensitive
            self.type = type
            self.units = units
        }

        private enum CodingKeys: String, CodingKey {
            case applicability = "Applicability"
            case defaultValue = "DefaultValue"
            case enumValues = "EnumValues"
            case intValueMax = "IntValueMax"
            case intValueMin = "IntValueMin"
            case name = "Name"
            case sensitive = "Sensitive"
            case type = "Type"
            case units = "Units"
        }
    }

    public struct Event: AWSDecodableShape {
        /// The date of the event.
        public let date: Date?
        /// The event categories available for the specified source type.
        public let eventCategories: [String]?
        /// The event message.
        public let message: String?
        ///  The identifier of an event source.
        public let sourceIdentifier: String?
        ///  The type of DMS resource that generates events.  Valid values: replication-instance | endpoint | replication-task
        public let sourceType: SourceType?

        public init(date: Date? = nil, eventCategories: [String]? = nil, message: String? = nil, sourceIdentifier: String? = nil, sourceType: SourceType? = nil) {
            self.date = date
            self.eventCategories = eventCategories
            self.message = message
            self.sourceIdentifier = sourceIdentifier
            self.sourceType = sourceType
        }

        private enum CodingKeys: String, CodingKey {
            case date = "Date"
            case eventCategories = "EventCategories"
            case message = "Message"
            case sourceIdentifier = "SourceIdentifier"
            case sourceType = "SourceType"
        }
    }

    public struct EventCategoryGroup: AWSDecodableShape {
        ///  A list of event categories from a source type that you've chosen.
        public let eventCategories: [String]?
        ///  The type of DMS resource that generates events.  Valid values: replication-instance | replication-server | security-group | replication-task
        public let sourceType: String?

        public init(eventCategories: [String]? = nil, sourceType: String? = nil) {
            self.eventCategories = eventCategories
            self.sourceType = sourceType
        }

        private enum CodingKeys: String, CodingKey {
            case eventCategories = "EventCategories"
            case sourceType = "SourceType"
        }
    }

    public struct EventSubscription: AWSDecodableShape {
        /// The Amazon Web Services customer account associated with the DMS event notification subscription.
        public let customerAwsId: String?
        /// The DMS event notification subscription Id.
        public let custSubscriptionId: String?
        /// Boolean value that indicates if the event subscription is enabled.
        public let enabled: Bool?
        /// A lists of event categories.
        public let eventCategoriesList: [String]?
        /// The topic ARN of the DMS event notification subscription.
        public let snsTopicArn: String?
        /// A list of source Ids for the event subscription.
        public let sourceIdsList: [String]?
        ///  The type of DMS resource that generates events.  Valid values: replication-instance | replication-server | security-group | replication-task
        public let sourceType: String?
        /// The status of the DMS event notification subscription. Constraints: Can be one of the following: creating | modifying | deleting | active | no-permission | topic-not-exist The status "no-permission" indicates that DMS no longer has permission to post to the SNS topic. The status "topic-not-exist" indicates that the topic was deleted after the subscription was created.
        public let status: String?
        /// The time the DMS event notification subscription was created.
        public let subscriptionCreationTime: String?

        public init(customerAwsId: String? = nil, custSubscriptionId: String? = nil, enabled: Bool? = nil, eventCategoriesList: [String]? = nil, snsTopicArn: String? = nil, sourceIdsList: [String]? = nil, sourceType: String? = nil, status: String? = nil, subscriptionCreationTime: String? = nil) {
            self.customerAwsId = customerAwsId
            self.custSubscriptionId = custSubscriptionId
            self.enabled = enabled
            self.eventCategoriesList = eventCategoriesList
            self.snsTopicArn = snsTopicArn
            self.sourceIdsList = sourceIdsList
            self.sourceType = sourceType
            self.status = status
            self.subscriptionCreationTime = subscriptionCreationTime
        }

        private enum CodingKeys: String, CodingKey {
            case customerAwsId = "CustomerAwsId"
            case custSubscriptionId = "CustSubscriptionId"
            case enabled = "Enabled"
            case eventCategoriesList = "EventCategoriesList"
            case snsTopicArn = "SnsTopicArn"
            case sourceIdsList = "SourceIdsList"
            case sourceType = "SourceType"
            case status = "Status"
            case subscriptionCreationTime = "SubscriptionCreationTime"
        }
    }

    public struct Filter: AWSEncodableShape {
        /// The name of the filter as specified for a Describe* or similar operation.
        public let name: String
        /// The filter value, which can specify one or more values used to narrow the returned results.
        public let values: [String]

        public init(name: String, values: [String]) {
            self.name = name
            self.values = values
        }

        private enum CodingKeys: String, CodingKey {
            case name = "Name"
            case values = "Values"
        }
    }

    public struct IBMDb2Settings: AWSEncodableShape & AWSDecodableShape {
        /// For ongoing replication (CDC), use CurrentLSN to specify a log sequence number (LSN) where you want the replication to start.
        public let currentLsn: String?
        /// Database name for the endpoint.
        public let databaseName: String?
        /// Maximum number of bytes per read, as a NUMBER value. The default is 64 KB.
        public let maxKBytesPerRead: Int?
        /// Endpoint connection password.
        public let password: String?
        /// Endpoint TCP port. The default value is 50000.
        public let port: Int?
        /// The full Amazon Resource Name (ARN) of the IAM role that specifies DMS as the trusted entity and grants the required permissions to access the value in SecretsManagerSecret. The role must allow the iam:PassRole action. SecretsManagerSecret has the value of the Amazon Web Services Secrets Manager secret that allows access to the Db2 LUW endpoint.   You can specify one of two sets of values for these permissions. You can specify the values for this setting and SecretsManagerSecretId. Or you can specify clear-text values for UserName, Password, ServerName, and Port. You can't specify both. For more information on creating this SecretsManagerSecret and the SecretsManagerAccessRoleArn and SecretsManagerSecretId required to access it, see Using secrets to access Database Migration Service resources in the Database Migration Service User Guide.
        public let secretsManagerAccessRoleArn: String?
        /// The full ARN, partial ARN, or friendly name of the SecretsManagerSecret that contains the Db2 LUW endpoint connection details.
        public let secretsManagerSecretId: String?
        /// Fully qualified domain name of the endpoint.
        public let serverName: String?
        /// Enables ongoing replication (CDC) as a BOOLEAN value. The default is true.
        public let setDataCaptureChanges: Bool?
        /// Endpoint connection user name.
        public let username: String?

        public init(currentLsn: String? = nil, databaseName: String? = nil, maxKBytesPerRead: Int? = nil, password: String? = nil, port: Int? = nil, secretsManagerAccessRoleArn: String? = nil, secretsManagerSecretId: String? = nil, serverName: String? = nil, setDataCaptureChanges: Bool? = nil, username: String? = nil) {
            self.currentLsn = currentLsn
            self.databaseName = databaseName
            self.maxKBytesPerRead = maxKBytesPerRead
            self.password = password
            self.port = port
            self.secretsManagerAccessRoleArn = secretsManagerAccessRoleArn
            self.secretsManagerSecretId = secretsManagerSecretId
            self.serverName = serverName
            self.setDataCaptureChanges = setDataCaptureChanges
            self.username = username
        }

        private enum CodingKeys: String, CodingKey {
            case currentLsn = "CurrentLsn"
            case databaseName = "DatabaseName"
            case maxKBytesPerRead = "MaxKBytesPerRead"
            case password = "Password"
            case port = "Port"
            case secretsManagerAccessRoleArn = "SecretsManagerAccessRoleArn"
            case secretsManagerSecretId = "SecretsManagerSecretId"
            case serverName = "ServerName"
            case setDataCaptureChanges = "SetDataCaptureChanges"
            case username = "Username"
        }
    }

    public struct ImportCertificateMessage: AWSEncodableShape {
        /// A customer-assigned name for the certificate. Identifiers must begin with a letter and must contain only ASCII letters, digits, and hyphens. They can't end with a hyphen or contain two consecutive hyphens.
        public let certificateIdentifier: String
        /// The contents of a .pem file, which contains an X.509 certificate.
        public let certificatePem: String?
        /// The location of an imported Oracle Wallet certificate for use with SSL. Provide the name of a .sso file using the fileb:// prefix. You can't provide the certificate inline.
        public let certificateWallet: Data?
        /// The tags associated with the certificate.
        public let tags: [Tag]?

        public init(certificateIdentifier: String, certificatePem: String? = nil, certificateWallet: Data? = nil, tags: [Tag]? = nil) {
            self.certificateIdentifier = certificateIdentifier
            self.certificatePem = certificatePem
            self.certificateWallet = certificateWallet
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case certificateIdentifier = "CertificateIdentifier"
            case certificatePem = "CertificatePem"
            case certificateWallet = "CertificateWallet"
            case tags = "Tags"
        }
    }

    public struct ImportCertificateResponse: AWSDecodableShape {
        /// The certificate to be uploaded.
        public let certificate: Certificate?

        public init(certificate: Certificate? = nil) {
            self.certificate = certificate
        }

        private enum CodingKeys: String, CodingKey {
            case certificate = "Certificate"
        }
    }

    public struct KafkaSettings: AWSEncodableShape & AWSDecodableShape {
        /// A comma-separated list of one or more broker locations in your Kafka cluster that host your Kafka instance. Specify each broker location in the form  broker-hostname-or-ip:port . For example, "ec2-12-345-678-901.compute-1.amazonaws.com:2345". For more information and examples of specifying a list of broker locations, see Using Apache Kafka as a target for Database Migration Service in the Database Migration Service User Guide.
        public let broker: String?
        /// Shows detailed control information for table definition, column definition, and table and column changes in the Kafka message output. The default is false.
        public let includeControlDetails: Bool?
        /// Include NULL and empty columns for records migrated to the endpoint. The default is false.
        public let includeNullAndEmpty: Bool?
        /// Shows the partition value within the Kafka message output unless the partition type is schema-table-type. The default is false.
        public let includePartitionValue: Bool?
        /// Includes any data definition language (DDL) operations that change the table in the control data, such as rename-table, drop-table, add-column, drop-column, and rename-column. The default is false.
        public let includeTableAlterOperations: Bool?
        /// Provides detailed transaction information from the source database. This information includes a commit timestamp, a log position, and values for transaction_id, previous transaction_id, and transaction_record_id (the record offset within a transaction). The default is false.
        public let includeTransactionDetails: Bool?
        /// The output format for the records created on the endpoint. The message format is JSON (default) or JSON_UNFORMATTED (a single line with no tab).
        public let messageFormat: MessageFormatValue?
        /// The maximum size in bytes for records created on the endpoint The default is 1,000,000.
        public let messageMaxBytes: Int?
        /// If this attribute is Y, it allows hexadecimal values that don't have the 0x prefix when migrated to a Kafka target. If this attribute is N, all hexadecimal values include this prefix when migrated to Kafka.
        public let noHexPrefix: Bool?
        /// Prefixes schema and table names to partition values, when the partition type is primary-key-type. Doing this increases data distribution among Kafka partitions. For example, suppose that a SysBench schema has thousands of tables and each table has only limited range for a primary key. In this case, the same primary key is sent from thousands of tables to the same partition, which causes throttling. The default is false.
        public let partitionIncludeSchemaTable: Bool?
        /// The secure password you created when you first set up your MSK cluster to validate a client identity and make an encrypted connection between server and client using SASL-SSL authentication.
        public let saslPassword: String?
        ///  The secure user name you created when you first set up your MSK cluster to validate a client identity and make an encrypted connection between server and client using SASL-SSL authentication.
        public let saslUsername: String?
        /// Set secure connection to a Kafka target endpoint using Transport Layer Security (TLS). Options include ssl-encryption, ssl-authentication, and sasl-ssl. sasl-ssl requires SaslUsername and SaslPassword.
        public let securityProtocol: KafkaSecurityProtocol?
        ///  The Amazon Resource Name (ARN) for the private Certification Authority (CA) cert that DMS uses to securely connect to your Kafka target endpoint.
        public let sslCaCertificateArn: String?
        /// The Amazon Resource Name (ARN) of the client certificate used to securely connect to a Kafka target endpoint.
        public let sslClientCertificateArn: String?
        /// The Amazon Resource Name (ARN) for the client private key used to securely connect to a Kafka target endpoint.
        public let sslClientKeyArn: String?
        ///  The password for the client private key used to securely connect to a Kafka target endpoint.
        public let sslClientKeyPassword: String?
        /// The topic to which you migrate the data. If you don't specify a topic, DMS specifies "kafka-default-topic" as the migration topic.
        public let topic: String?

        public init(broker: String? = nil, includeControlDetails: Bool? = nil, includeNullAndEmpty: Bool? = nil, includePartitionValue: Bool? = nil, includeTableAlterOperations: Bool? = nil, includeTransactionDetails: Bool? = nil, messageFormat: MessageFormatValue? = nil, messageMaxBytes: Int? = nil, noHexPrefix: Bool? = nil, partitionIncludeSchemaTable: Bool? = nil, saslPassword: String? = nil, saslUsername: String? = nil, securityProtocol: KafkaSecurityProtocol? = nil, sslCaCertificateArn: String? = nil, sslClientCertificateArn: String? = nil, sslClientKeyArn: String? = nil, sslClientKeyPassword: String? = nil, topic: String? = nil) {
            self.broker = broker
            self.includeControlDetails = includeControlDetails
            self.includeNullAndEmpty = includeNullAndEmpty
            self.includePartitionValue = includePartitionValue
            self.includeTableAlterOperations = includeTableAlterOperations
            self.includeTransactionDetails = includeTransactionDetails
            self.messageFormat = messageFormat
            self.messageMaxBytes = messageMaxBytes
            self.noHexPrefix = noHexPrefix
            self.partitionIncludeSchemaTable = partitionIncludeSchemaTable
            self.saslPassword = saslPassword
            self.saslUsername = saslUsername
            self.securityProtocol = securityProtocol
            self.sslCaCertificateArn = sslCaCertificateArn
            self.sslClientCertificateArn = sslClientCertificateArn
            self.sslClientKeyArn = sslClientKeyArn
            self.sslClientKeyPassword = sslClientKeyPassword
            self.topic = topic
        }

        private enum CodingKeys: String, CodingKey {
            case broker = "Broker"
            case includeControlDetails = "IncludeControlDetails"
            case includeNullAndEmpty = "IncludeNullAndEmpty"
            case includePartitionValue = "IncludePartitionValue"
            case includeTableAlterOperations = "IncludeTableAlterOperations"
            case includeTransactionDetails = "IncludeTransactionDetails"
            case messageFormat = "MessageFormat"
            case messageMaxBytes = "MessageMaxBytes"
            case noHexPrefix = "NoHexPrefix"
            case partitionIncludeSchemaTable = "PartitionIncludeSchemaTable"
            case saslPassword = "SaslPassword"
            case saslUsername = "SaslUsername"
            case securityProtocol = "SecurityProtocol"
            case sslCaCertificateArn = "SslCaCertificateArn"
            case sslClientCertificateArn = "SslClientCertificateArn"
            case sslClientKeyArn = "SslClientKeyArn"
            case sslClientKeyPassword = "SslClientKeyPassword"
            case topic = "Topic"
        }
    }

    public struct KinesisSettings: AWSEncodableShape & AWSDecodableShape {
        /// Shows detailed control information for table definition, column definition, and table and column changes in the Kinesis message output. The default is false.
        public let includeControlDetails: Bool?
        /// Include NULL and empty columns for records migrated to the endpoint. The default is false.
        public let includeNullAndEmpty: Bool?
        /// Shows the partition value within the Kinesis message output, unless the partition type is schema-table-type. The default is false.
        public let includePartitionValue: Bool?
        /// Includes any data definition language (DDL) operations that change the table in the control data, such as rename-table, drop-table, add-column, drop-column, and rename-column. The default is false.
        public let includeTableAlterOperations: Bool?
        /// Provides detailed transaction information from the source database. This information includes a commit timestamp, a log position, and values for transaction_id, previous transaction_id, and transaction_record_id (the record offset within a transaction). The default is false.
        public let includeTransactionDetails: Bool?
        /// The output format for the records created on the endpoint. The message format is JSON (default) or JSON_UNFORMATTED (a single line with no tab).
        public let messageFormat: MessageFormatValue?
        /// If this attribute is Y, it allows hexadecimal values that don't have the 0x prefix when migrated to a Kinesis target. If this attribute is N, all hexadecimal values include this prefix when migrated to Kinesis.
        public let noHexPrefix: Bool?
        /// Prefixes schema and table names to partition values, when the partition type is primary-key-type. Doing this increases data distribution among Kinesis shards. For example, suppose that a SysBench schema has thousands of tables and each table has only limited range for a primary key. In this case, the same primary key is sent from thousands of tables to the same shard, which causes throttling. The default is false.
        public let partitionIncludeSchemaTable: Bool?
        /// The Amazon Resource Name (ARN) for the IAM role that DMS uses to write to the Kinesis data stream. The role must allow the iam:PassRole action.
        public let serviceAccessRoleArn: String?
        /// The Amazon Resource Name (ARN) for the Amazon Kinesis Data Streams endpoint.
        public let streamArn: String?

        public init(includeControlDetails: Bool? = nil, includeNullAndEmpty: Bool? = nil, includePartitionValue: Bool? = nil, includeTableAlterOperations: Bool? = nil, includeTransactionDetails: Bool? = nil, messageFormat: MessageFormatValue? = nil, noHexPrefix: Bool? = nil, partitionIncludeSchemaTable: Bool? = nil, serviceAccessRoleArn: String? = nil, streamArn: String? = nil) {
            self.includeControlDetails = includeControlDetails
            self.includeNullAndEmpty = includeNullAndEmpty
            self.includePartitionValue = includePartitionValue
            self.includeTableAlterOperations = includeTableAlterOperations
            self.includeTransactionDetails = includeTransactionDetails
            self.messageFormat = messageFormat
            self.noHexPrefix = noHexPrefix
            self.partitionIncludeSchemaTable = partitionIncludeSchemaTable
            self.serviceAccessRoleArn = serviceAccessRoleArn
            self.streamArn = streamArn
        }

        private enum CodingKeys: String, CodingKey {
            case includeControlDetails = "IncludeControlDetails"
            case includeNullAndEmpty = "IncludeNullAndEmpty"
            case includePartitionValue = "IncludePartitionValue"
            case includeTableAlterOperations = "IncludeTableAlterOperations"
            case includeTransactionDetails = "IncludeTransactionDetails"
            case messageFormat = "MessageFormat"
            case noHexPrefix = "NoHexPrefix"
            case partitionIncludeSchemaTable = "PartitionIncludeSchemaTable"
            case serviceAccessRoleArn = "ServiceAccessRoleArn"
            case streamArn = "StreamArn"
        }
    }

    public struct ListTagsForResourceMessage: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) string that uniquely identifies the DMS resource.
        public let resourceArn: String

        public init(resourceArn: String) {
            self.resourceArn = resourceArn
        }

        private enum CodingKeys: String, CodingKey {
            case resourceArn = "ResourceArn"
        }
    }

    public struct ListTagsForResourceResponse: AWSDecodableShape {
        /// A list of tags for the resource.
        public let tagList: [Tag]?

        public init(tagList: [Tag]? = nil) {
            self.tagList = tagList
        }

        private enum CodingKeys: String, CodingKey {
            case tagList = "TagList"
        }
    }

    public struct MicrosoftSQLServerSettings: AWSEncodableShape & AWSDecodableShape {
        /// The maximum size of the packets (in bytes) used to transfer data using BCP.
        public let bcpPacketSize: Int?
        /// Specifies a file group for the DMS internal tables. When the replication task starts, all the internal DMS control tables (awsdms_ apply_exception, awsdms_apply, awsdms_changes) are created for the specified file group.
        public let controlTablesFileGroup: String?
        /// Database name for the endpoint.
        public let databaseName: String?
        /// Endpoint connection password.
        public let password: String?
        /// Endpoint TCP port.
        public let port: Int?
        /// Cleans and recreates table metadata information on the replication instance when a mismatch occurs. An example is a situation where running an alter DDL statement on a table might result in different information about the table cached in the replication instance.
        public let querySingleAlwaysOnNode: Bool?
        /// When this attribute is set to Y, DMS only reads changes from transaction log backups and doesn't read from the active transaction log file during ongoing replication. Setting this parameter to Y enables you to control active transaction log file growth during full load and ongoing replication tasks. However, it can add some source latency to ongoing replication.
        public let readBackupOnly: Bool?
        /// Use this attribute to minimize the need to access the backup log and enable DMS to prevent truncation using one of the following two methods.  Start transactions in the database: This is the default method. When this method is used, DMS prevents TLOG truncation by mimicking a transaction in the database. As long as such a transaction is open, changes that appear after the transaction started aren't truncated. If you need Microsoft Replication to be enabled in your database, then you must choose this method.  Exclusively use sp_repldone within a single task: When this method is used, DMS reads the changes and then uses sp_repldone to mark the TLOG transactions as ready for truncation. Although this method doesn't involve any transactional activities, it can only be used when Microsoft Replication isn't running. Also, when using this method, only one DMS task can access the database at any given time. Therefore, if you need to run parallel DMS tasks against the same database, use the default method.
        public let safeguardPolicy: SafeguardPolicy?
        /// The full Amazon Resource Name (ARN) of the IAM role that specifies DMS as the trusted entity and grants the required permissions to access the value in SecretsManagerSecret. The role must allow the iam:PassRole action. SecretsManagerSecret has the value of the Amazon Web Services Secrets Manager secret that allows access to the SQL Server endpoint.  You can specify one of two sets of values for these permissions. You can specify the values for this setting and SecretsManagerSecretId. Or you can specify clear-text values for UserName, Password, ServerName, and Port. You can't specify both. For more information on creating this SecretsManagerSecret and the SecretsManagerAccessRoleArn and SecretsManagerSecretId required to access it, see Using secrets to access Database Migration Service resources in the Database Migration Service User Guide.
        public let secretsManagerAccessRoleArn: String?
        /// The full ARN, partial ARN, or friendly name of the SecretsManagerSecret that contains the SQL Server endpoint connection details.
        public let secretsManagerSecretId: String?
        /// Fully qualified domain name of the endpoint.
        public let serverName: String?
        /// Use this to attribute to transfer data for full-load operations using BCP. When the target table contains an identity column that does not exist in the source table, you must disable the use BCP for loading table option.
        public let useBcpFullLoad: Bool?
        /// Endpoint connection user name.
        public let username: String?
        /// When this attribute is set to Y, DMS processes third-party transaction log backups if they are created in native format.
        public let useThirdPartyBackupDevice: Bool?

        public init(bcpPacketSize: Int? = nil, controlTablesFileGroup: String? = nil, databaseName: String? = nil, password: String? = nil, port: Int? = nil, querySingleAlwaysOnNode: Bool? = nil, readBackupOnly: Bool? = nil, safeguardPolicy: SafeguardPolicy? = nil, secretsManagerAccessRoleArn: String? = nil, secretsManagerSecretId: String? = nil, serverName: String? = nil, useBcpFullLoad: Bool? = nil, username: String? = nil, useThirdPartyBackupDevice: Bool? = nil) {
            self.bcpPacketSize = bcpPacketSize
            self.controlTablesFileGroup = controlTablesFileGroup
            self.databaseName = databaseName
            self.password = password
            self.port = port
            self.querySingleAlwaysOnNode = querySingleAlwaysOnNode
            self.readBackupOnly = readBackupOnly
            self.safeguardPolicy = safeguardPolicy
            self.secretsManagerAccessRoleArn = secretsManagerAccessRoleArn
            self.secretsManagerSecretId = secretsManagerSecretId
            self.serverName = serverName
            self.useBcpFullLoad = useBcpFullLoad
            self.username = username
            self.useThirdPartyBackupDevice = useThirdPartyBackupDevice
        }

        private enum CodingKeys: String, CodingKey {
            case bcpPacketSize = "BcpPacketSize"
            case controlTablesFileGroup = "ControlTablesFileGroup"
            case databaseName = "DatabaseName"
            case password = "Password"
            case port = "Port"
            case querySingleAlwaysOnNode = "QuerySingleAlwaysOnNode"
            case readBackupOnly = "ReadBackupOnly"
            case safeguardPolicy = "SafeguardPolicy"
            case secretsManagerAccessRoleArn = "SecretsManagerAccessRoleArn"
            case secretsManagerSecretId = "SecretsManagerSecretId"
            case serverName = "ServerName"
            case useBcpFullLoad = "UseBcpFullLoad"
            case username = "Username"
            case useThirdPartyBackupDevice = "UseThirdPartyBackupDevice"
        }
    }

    public struct ModifyEndpointMessage: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the certificate used for SSL connection.
        public let certificateArn: String?
        /// The name of the endpoint database. For a MySQL source or target endpoint, do not specify DatabaseName.
        public let databaseName: String?
        /// The settings in JSON format for the DMS transfer type of source endpoint.  Attributes include the following:   serviceAccessRoleArn - The Identity and Access Management (IAM) role that has permission to access the Amazon S3 bucket. The role must allow the iam:PassRole action.   BucketName - The name of the S3 bucket to use.   Shorthand syntax for these settings is as follows: ServiceAccessRoleArn=string ,BucketName=string  JSON syntax for these settings is as follows: { "ServiceAccessRoleArn": "string", "BucketName": "string"}
        public let dmsTransferSettings: DmsTransferSettings?
        /// Settings in JSON format for the source DocumentDB endpoint. For more information about the available settings, see the configuration properties section in  Using DocumentDB as a Target for Database Migration Service  in the Database Migration Service User Guide.
        public let docDbSettings: DocDbSettings?
        /// Settings in JSON format for the target Amazon DynamoDB endpoint. For information about other available settings, see Using Object Mapping to Migrate Data to DynamoDB in the Database Migration Service User Guide.
        public let dynamoDbSettings: DynamoDbSettings?
        /// Settings in JSON format for the target Elasticsearch endpoint. For more information about the available settings, see Extra Connection Attributes When Using Elasticsearch as a Target for DMS in the Database Migration Service User Guide.
        public let elasticsearchSettings: ElasticsearchSettings?
        /// The Amazon Resource Name (ARN) string that uniquely identifies the endpoint.
        public let endpointArn: String
        /// The database endpoint identifier. Identifiers must begin with a letter and must contain only ASCII letters, digits, and hyphens. They can't end with a hyphen or contain two consecutive hyphens.
        public let endpointIdentifier: String?
        /// The type of endpoint. Valid values are source and target.
        public let endpointType: ReplicationEndpointTypeValue?
        /// The type of engine for the endpoint. Valid values, depending on the EndpointType, include "mysql", "oracle", "postgres", "mariadb", "aurora", "aurora-postgresql", "redshift", "s3", "db2", "azuredb", "sybase", "dynamodb", "mongodb", "kinesis", "kafka", "elasticsearch", "documentdb", "sqlserver", and "neptune".
        public let engineName: String?
        /// If this attribute is Y, the current call to ModifyEndpoint replaces all existing endpoint settings with the exact settings that you specify in this call. If this attribute is N, the current call to ModifyEndpoint does two things:    It replaces any endpoint settings that already exist with new values, for settings with the same names.   It creates new endpoint settings that you specify in the call, for settings with different names.    For example, if you call create-endpoint ... --endpoint-settings '{"a":1}' ..., the endpoint has the following endpoint settings: '{"a":1}'. If you then call modify-endpoint ... --endpoint-settings '{"b":2}' ... for the same endpoint, the endpoint has the following settings: '{"a":1,"b":2}'.  However, suppose that you follow this with a call to modify-endpoint ... --endpoint-settings '{"b":2}' --exact-settings ... for that same endpoint again. Then the endpoint has the following settings: '{"b":2}'. All existing settings are replaced with the exact settings that you specify.
        public let exactSettings: Bool?
        /// The external table definition.
        public let externalTableDefinition: String?
        /// Additional attributes associated with the connection. To reset this parameter, pass the empty string ("") as an argument.
        public let extraConnectionAttributes: String?
        /// Settings in JSON format for the source IBM Db2 LUW endpoint. For information about other available settings, see Extra connection attributes when using Db2 LUW as a source for DMS in the Database Migration Service User Guide.
        public let iBMDb2Settings: IBMDb2Settings?
        /// Settings in JSON format for the target Apache Kafka endpoint. For more information about the available settings, see Using object mapping to migrate data to a Kafka topic in the Database Migration Service User Guide.
        public let kafkaSettings: KafkaSettings?
        /// Settings in JSON format for the target endpoint for Amazon Kinesis Data Streams. For more information about the available settings, see Using object mapping to migrate data to a Kinesis data stream in the Database Migration Service User Guide.
        public let kinesisSettings: KinesisSettings?
        /// Settings in JSON format for the source and target Microsoft SQL Server endpoint. For information about other available settings, see Extra connection attributes when using SQL Server as a source for DMS and  Extra connection attributes when using SQL Server as a target for DMS in the Database Migration Service User Guide.
        public let microsoftSQLServerSettings: MicrosoftSQLServerSettings?
        /// Settings in JSON format for the source MongoDB endpoint. For more information about the available settings, see the configuration properties section in Endpoint configuration settings when using MongoDB as a source for Database Migration Service in the Database Migration Service User Guide.
        public let mongoDbSettings: MongoDbSettings?
        /// Settings in JSON format for the source and target MySQL endpoint. For information about other available settings, see Extra connection attributes when using MySQL as a source for DMS and Extra connection attributes when using a MySQL-compatible database as a target for DMS in the Database Migration Service User Guide.
        public let mySQLSettings: MySQLSettings?
        /// Settings in JSON format for the target Amazon Neptune endpoint. For more information about the available settings, see Specifying graph-mapping rules using Gremlin and R2RML for Amazon Neptune as a target in the Database Migration Service User Guide.
        public let neptuneSettings: NeptuneSettings?
        /// Settings in JSON format for the source and target Oracle endpoint. For information about other available settings, see Extra connection attributes when using Oracle as a source for DMS and  Extra connection attributes when using Oracle as a target for DMS in the Database Migration Service User Guide.
        public let oracleSettings: OracleSettings?
        /// The password to be used to login to the endpoint database.
        public let password: String?
        /// The port used by the endpoint database.
        public let port: Int?
        /// Settings in JSON format for the source and target PostgreSQL endpoint. For information about other available settings, see Extra connection attributes when using PostgreSQL as a source for DMS and  Extra connection attributes when using PostgreSQL as a target for DMS in the Database Migration Service User Guide.
        public let postgreSQLSettings: PostgreSQLSettings?
        public let redshiftSettings: RedshiftSettings?
        /// Settings in JSON format for the target Amazon S3 endpoint. For more information about the available settings, see Extra Connection Attributes When Using Amazon S3 as a Target for DMS in the Database Migration Service User Guide.
        public let s3Settings: S3Settings?
        /// The name of the server where the endpoint database resides.
        public let serverName: String?
        ///  The Amazon Resource Name (ARN) for the IAM role you want to use to modify the endpoint. The role must allow the iam:PassRole action.
        public let serviceAccessRoleArn: String?
        /// The SSL mode used to connect to the endpoint. The default value is none.
        public let sslMode: DmsSslModeValue?
        /// Settings in JSON format for the source and target SAP ASE endpoint. For information about other available settings, see Extra connection attributes when using SAP ASE as a source for DMS and Extra connection attributes when using SAP ASE as a target for DMS in the Database Migration Service User Guide.
        public let sybaseSettings: SybaseSettings?
        /// The user name to be used to login to the endpoint database.
        public let username: String?

        public init(certificateArn: String? = nil, databaseName: String? = nil, dmsTransferSettings: DmsTransferSettings? = nil, docDbSettings: DocDbSettings? = nil, dynamoDbSettings: DynamoDbSettings? = nil, elasticsearchSettings: ElasticsearchSettings? = nil, endpointArn: String, endpointIdentifier: String? = nil, endpointType: ReplicationEndpointTypeValue? = nil, engineName: String? = nil, exactSettings: Bool? = nil, externalTableDefinition: String? = nil, extraConnectionAttributes: String? = nil, iBMDb2Settings: IBMDb2Settings? = nil, kafkaSettings: KafkaSettings? = nil, kinesisSettings: KinesisSettings? = nil, microsoftSQLServerSettings: MicrosoftSQLServerSettings? = nil, mongoDbSettings: MongoDbSettings? = nil, mySQLSettings: MySQLSettings? = nil, neptuneSettings: NeptuneSettings? = nil, oracleSettings: OracleSettings? = nil, password: String? = nil, port: Int? = nil, postgreSQLSettings: PostgreSQLSettings? = nil, redshiftSettings: RedshiftSettings? = nil, s3Settings: S3Settings? = nil, serverName: String? = nil, serviceAccessRoleArn: String? = nil, sslMode: DmsSslModeValue? = nil, sybaseSettings: SybaseSettings? = nil, username: String? = nil) {
            self.certificateArn = certificateArn
            self.databaseName = databaseName
            self.dmsTransferSettings = dmsTransferSettings
            self.docDbSettings = docDbSettings
            self.dynamoDbSettings = dynamoDbSettings
            self.elasticsearchSettings = elasticsearchSettings
            self.endpointArn = endpointArn
            self.endpointIdentifier = endpointIdentifier
            self.endpointType = endpointType
            self.engineName = engineName
            self.exactSettings = exactSettings
            self.externalTableDefinition = externalTableDefinition
            self.extraConnectionAttributes = extraConnectionAttributes
            self.iBMDb2Settings = iBMDb2Settings
            self.kafkaSettings = kafkaSettings
            self.kinesisSettings = kinesisSettings
            self.microsoftSQLServerSettings = microsoftSQLServerSettings
            self.mongoDbSettings = mongoDbSettings
            self.mySQLSettings = mySQLSettings
            self.neptuneSettings = neptuneSettings
            self.oracleSettings = oracleSettings
            self.password = password
            self.port = port
            self.postgreSQLSettings = postgreSQLSettings
            self.redshiftSettings = redshiftSettings
            self.s3Settings = s3Settings
            self.serverName = serverName
            self.serviceAccessRoleArn = serviceAccessRoleArn
            self.sslMode = sslMode
            self.sybaseSettings = sybaseSettings
            self.username = username
        }

        private enum CodingKeys: String, CodingKey {
            case certificateArn = "CertificateArn"
            case databaseName = "DatabaseName"
            case dmsTransferSettings = "DmsTransferSettings"
            case docDbSettings = "DocDbSettings"
            case dynamoDbSettings = "DynamoDbSettings"
            case elasticsearchSettings = "ElasticsearchSettings"
            case endpointArn = "EndpointArn"
            case endpointIdentifier = "EndpointIdentifier"
            case endpointType = "EndpointType"
            case engineName = "EngineName"
            case exactSettings = "ExactSettings"
            case externalTableDefinition = "ExternalTableDefinition"
            case extraConnectionAttributes = "ExtraConnectionAttributes"
            case iBMDb2Settings = "IBMDb2Settings"
            case kafkaSettings = "KafkaSettings"
            case kinesisSettings = "KinesisSettings"
            case microsoftSQLServerSettings = "MicrosoftSQLServerSettings"
            case mongoDbSettings = "MongoDbSettings"
            case mySQLSettings = "MySQLSettings"
            case neptuneSettings = "NeptuneSettings"
            case oracleSettings = "OracleSettings"
            case password = "Password"
            case port = "Port"
            case postgreSQLSettings = "PostgreSQLSettings"
            case redshiftSettings = "RedshiftSettings"
            case s3Settings = "S3Settings"
            case serverName = "ServerName"
            case serviceAccessRoleArn = "ServiceAccessRoleArn"
            case sslMode = "SslMode"
            case sybaseSettings = "SybaseSettings"
            case username = "Username"
        }
    }

    public struct ModifyEndpointResponse: AWSDecodableShape {
        /// The modified endpoint.
        public let endpoint: Endpoint?

        public init(endpoint: Endpoint? = nil) {
            self.endpoint = endpoint
        }

        private enum CodingKeys: String, CodingKey {
            case endpoint = "Endpoint"
        }
    }

    public struct ModifyEventSubscriptionMessage: AWSEncodableShape {
        ///  A Boolean value; set to true to activate the subscription.
        public let enabled: Bool?
        ///  A list of event categories for a source type that you want to subscribe to. Use the DescribeEventCategories action to see a list of event categories.
        public let eventCategories: [String]?
        ///  The Amazon Resource Name (ARN) of the Amazon SNS topic created for event notification. The ARN is created by Amazon SNS when you create a topic and subscribe to it.
        public let snsTopicArn: String?
        ///  The type of DMS resource that generates the events you want to subscribe to.  Valid values: replication-instance | replication-task
        public let sourceType: String?
        /// The name of the DMS event notification subscription to be modified.
        public let subscriptionName: String

        public init(enabled: Bool? = nil, eventCategories: [String]? = nil, snsTopicArn: String? = nil, sourceType: String? = nil, subscriptionName: String) {
            self.enabled = enabled
            self.eventCategories = eventCategories
            self.snsTopicArn = snsTopicArn
            self.sourceType = sourceType
            self.subscriptionName = subscriptionName
        }

        private enum CodingKeys: String, CodingKey {
            case enabled = "Enabled"
            case eventCategories = "EventCategories"
            case snsTopicArn = "SnsTopicArn"
            case sourceType = "SourceType"
            case subscriptionName = "SubscriptionName"
        }
    }

    public struct ModifyEventSubscriptionResponse: AWSDecodableShape {
        /// The modified event subscription.
        public let eventSubscription: EventSubscription?

        public init(eventSubscription: EventSubscription? = nil) {
            self.eventSubscription = eventSubscription
        }

        private enum CodingKeys: String, CodingKey {
            case eventSubscription = "EventSubscription"
        }
    }

    public struct ModifyReplicationInstanceMessage: AWSEncodableShape {
        /// The amount of storage (in gigabytes) to be allocated for the replication instance.
        public let allocatedStorage: Int?
        /// Indicates that major version upgrades are allowed. Changing this parameter does not result in an outage, and the change is asynchronously applied as soon as possible. This parameter must be set to true when specifying a value for the EngineVersion parameter that is a different major version than the replication instance's current version.
        public let allowMajorVersionUpgrade: Bool?
        /// Indicates whether the changes should be applied immediately or during the next maintenance window.
        public let applyImmediately: Bool?
        /// A value that indicates that minor version upgrades are applied automatically to the replication instance during the maintenance window. Changing this parameter doesn't result in an outage, except in the case described following. The change is asynchronously applied as soon as possible.  An outage does result if these factors apply:    This parameter is set to true during the maintenance window.   A newer minor version is available.    DMS has enabled automatic patching for the given engine version.
        public let autoMinorVersionUpgrade: Bool?
        /// The engine version number of the replication instance. When modifying a major engine version of an instance, also set AllowMajorVersionUpgrade to true.
        public let engineVersion: String?
        ///  Specifies whether the replication instance is a Multi-AZ deployment. You can't set the AvailabilityZone parameter if the Multi-AZ parameter is set to true.
        public let multiAZ: Bool?
        /// The weekly time range (in UTC) during which system maintenance can occur, which might result in an outage. Changing this parameter does not result in an outage, except in the following situation, and the change is asynchronously applied as soon as possible. If moving this window to the current time, there must be at least 30 minutes between the current time and end of the window to ensure pending changes are applied. Default: Uses existing setting Format: ddd:hh24:mi-ddd:hh24:mi Valid Days: Mon | Tue | Wed | Thu | Fri | Sat | Sun Constraints: Must be at least 30 minutes
        public let preferredMaintenanceWindow: String?
        /// The Amazon Resource Name (ARN) of the replication instance.
        public let replicationInstanceArn: String
        /// The compute and memory capacity of the replication instance as defined for the specified replication instance class. For example to specify the instance class dms.c4.large, set this parameter to "dms.c4.large". For more information on the settings and capacities for the available replication instance classes, see  Selecting the right DMS replication instance for your migration.
        public let replicationInstanceClass: String?
        /// The replication instance identifier. This parameter is stored as a lowercase string.
        public let replicationInstanceIdentifier: String?
        ///  Specifies the VPC security group to be used with the replication instance. The VPC security group must work with the VPC containing the replication instance.
        public let vpcSecurityGroupIds: [String]?

        public init(allocatedStorage: Int? = nil, allowMajorVersionUpgrade: Bool? = nil, applyImmediately: Bool? = nil, autoMinorVersionUpgrade: Bool? = nil, engineVersion: String? = nil, multiAZ: Bool? = nil, preferredMaintenanceWindow: String? = nil, replicationInstanceArn: String, replicationInstanceClass: String? = nil, replicationInstanceIdentifier: String? = nil, vpcSecurityGroupIds: [String]? = nil) {
            self.allocatedStorage = allocatedStorage
            self.allowMajorVersionUpgrade = allowMajorVersionUpgrade
            self.applyImmediately = applyImmediately
            self.autoMinorVersionUpgrade = autoMinorVersionUpgrade
            self.engineVersion = engineVersion
            self.multiAZ = multiAZ
            self.preferredMaintenanceWindow = preferredMaintenanceWindow
            self.replicationInstanceArn = replicationInstanceArn
            self.replicationInstanceClass = replicationInstanceClass
            self.replicationInstanceIdentifier = replicationInstanceIdentifier
            self.vpcSecurityGroupIds = vpcSecurityGroupIds
        }

        private enum CodingKeys: String, CodingKey {
            case allocatedStorage = "AllocatedStorage"
            case allowMajorVersionUpgrade = "AllowMajorVersionUpgrade"
            case applyImmediately = "ApplyImmediately"
            case autoMinorVersionUpgrade = "AutoMinorVersionUpgrade"
            case engineVersion = "EngineVersion"
            case multiAZ = "MultiAZ"
            case preferredMaintenanceWindow = "PreferredMaintenanceWindow"
            case replicationInstanceArn = "ReplicationInstanceArn"
            case replicationInstanceClass = "ReplicationInstanceClass"
            case replicationInstanceIdentifier = "ReplicationInstanceIdentifier"
            case vpcSecurityGroupIds = "VpcSecurityGroupIds"
        }
    }

    public struct ModifyReplicationInstanceResponse: AWSDecodableShape {
        /// The modified replication instance.
        public let replicationInstance: ReplicationInstance?

        public init(replicationInstance: ReplicationInstance? = nil) {
            self.replicationInstance = replicationInstance
        }

        private enum CodingKeys: String, CodingKey {
            case replicationInstance = "ReplicationInstance"
        }
    }

    public struct ModifyReplicationSubnetGroupMessage: AWSEncodableShape {
        /// A description for the replication instance subnet group.
        public let replicationSubnetGroupDescription: String?
        /// The name of the replication instance subnet group.
        public let replicationSubnetGroupIdentifier: String
        /// A list of subnet IDs.
        public let subnetIds: [String]

        public init(replicationSubnetGroupDescription: String? = nil, replicationSubnetGroupIdentifier: String, subnetIds: [String]) {
            self.replicationSubnetGroupDescription = replicationSubnetGroupDescription
            self.replicationSubnetGroupIdentifier = replicationSubnetGroupIdentifier
            self.subnetIds = subnetIds
        }

        private enum CodingKeys: String, CodingKey {
            case replicationSubnetGroupDescription = "ReplicationSubnetGroupDescription"
            case replicationSubnetGroupIdentifier = "ReplicationSubnetGroupIdentifier"
            case subnetIds = "SubnetIds"
        }
    }

    public struct ModifyReplicationSubnetGroupResponse: AWSDecodableShape {
        /// The modified replication subnet group.
        public let replicationSubnetGroup: ReplicationSubnetGroup?

        public init(replicationSubnetGroup: ReplicationSubnetGroup? = nil) {
            self.replicationSubnetGroup = replicationSubnetGroup
        }

        private enum CodingKeys: String, CodingKey {
            case replicationSubnetGroup = "ReplicationSubnetGroup"
        }
    }

    public struct ModifyReplicationTaskMessage: AWSEncodableShape {
        /// Indicates when you want a change data capture (CDC) operation to start. Use either CdcStartPosition or CdcStartTime to specify when you want a CDC operation to start. Specifying both values results in an error.  The value can be in date, checkpoint, or LSN/SCN format. Date Example: --cdc-start-position “2018-03-08T12:12:12” Checkpoint Example: --cdc-start-position "checkpoint:V1#27#mysql-bin-changelog.157832:1975:-1:2002:677883278264080:mysql-bin-changelog.157832:1876#0#0#*#0#93" LSN Example: --cdc-start-position “mysql-bin-changelog.000024:373”  When you use this task setting with a source PostgreSQL database, a logical replication slot should already be created and associated with the source endpoint. You can verify this by setting the slotName extra connection attribute to the name of this logical replication slot. For more information, see Extra Connection Attributes When Using PostgreSQL as a Source for DMS.
        public let cdcStartPosition: String?
        /// Indicates the start time for a change data capture (CDC) operation. Use either CdcStartTime or CdcStartPosition to specify when you want a CDC operation to start. Specifying both values results in an error. Timestamp Example: --cdc-start-time “2018-03-08T12:12:12”
        public let cdcStartTime: Date?
        /// Indicates when you want a change data capture (CDC) operation to stop. The value can be either server time or commit time. Server time example: --cdc-stop-position “server_time:2018-02-09T12:12:12” Commit time example: --cdc-stop-position “commit_time: 2018-02-09T12:12:12 “
        public let cdcStopPosition: String?
        /// The migration type. Valid values: full-load | cdc | full-load-and-cdc
        public let migrationType: MigrationTypeValue?
        /// The Amazon Resource Name (ARN) of the replication task.
        public let replicationTaskArn: String
        /// The replication task identifier. Constraints:   Must contain 1-255 alphanumeric characters or hyphens.   First character must be a letter.   Cannot end with a hyphen or contain two consecutive hyphens.
        public let replicationTaskIdentifier: String?
        /// JSON file that contains settings for the task, such as task metadata settings.
        public let replicationTaskSettings: String?
        /// When using the CLI or boto3, provide the path of the JSON file that contains the table mappings. Precede the path with file://. For example, --table-mappings file://mappingfile.json. When working with the DMS API, provide the JSON as the parameter value.
        public let tableMappings: String?
        /// Supplemental information that the task requires to migrate the data for certain source and target endpoints. For more information, see Specifying Supplemental Data for Task Settings in the Database Migration Service User Guide.
        public let taskData: String?

        public init(cdcStartPosition: String? = nil, cdcStartTime: Date? = nil, cdcStopPosition: String? = nil, migrationType: MigrationTypeValue? = nil, replicationTaskArn: String, replicationTaskIdentifier: String? = nil, replicationTaskSettings: String? = nil, tableMappings: String? = nil, taskData: String? = nil) {
            self.cdcStartPosition = cdcStartPosition
            self.cdcStartTime = cdcStartTime
            self.cdcStopPosition = cdcStopPosition
            self.migrationType = migrationType
            self.replicationTaskArn = replicationTaskArn
            self.replicationTaskIdentifier = replicationTaskIdentifier
            self.replicationTaskSettings = replicationTaskSettings
            self.tableMappings = tableMappings
            self.taskData = taskData
        }

        private enum CodingKeys: String, CodingKey {
            case cdcStartPosition = "CdcStartPosition"
            case cdcStartTime = "CdcStartTime"
            case cdcStopPosition = "CdcStopPosition"
            case migrationType = "MigrationType"
            case replicationTaskArn = "ReplicationTaskArn"
            case replicationTaskIdentifier = "ReplicationTaskIdentifier"
            case replicationTaskSettings = "ReplicationTaskSettings"
            case tableMappings = "TableMappings"
            case taskData = "TaskData"
        }
    }

    public struct ModifyReplicationTaskResponse: AWSDecodableShape {
        /// The replication task that was modified.
        public let replicationTask: ReplicationTask?

        public init(replicationTask: ReplicationTask? = nil) {
            self.replicationTask = replicationTask
        }

        private enum CodingKeys: String, CodingKey {
            case replicationTask = "ReplicationTask"
        }
    }

    public struct MongoDbSettings: AWSEncodableShape & AWSDecodableShape {
        ///  The authentication mechanism you use to access the MongoDB source endpoint. For the default value, in MongoDB version 2.x, "default" is "mongodb_cr". For MongoDB version 3.x or later, "default" is "scram_sha_1". This setting isn't used when AuthType is set to "no".
        public let authMechanism: AuthMechanismValue?
        ///  The MongoDB database name. This setting isn't used when AuthType is set to "no".  The default is "admin".
        public let authSource: String?
        ///  The authentication type you use to access the MongoDB source endpoint. When when set to "no", user name and password parameters are not used and can be empty.
        public let authType: AuthTypeValue?
        ///  The database name on the MongoDB source endpoint.
        public let databaseName: String?
        ///  Indicates the number of documents to preview to determine the document organization. Use this setting when NestingLevel is set to "one".  Must be a positive value greater than 0. Default value is 1000.
        public let docsToInvestigate: String?
        ///  Specifies the document ID. Use this setting when NestingLevel is set to "none".  Default value is "false".
        public let extractDocId: String?
        /// The KMS key identifier that is used to encrypt the content on the replication instance. If you don't specify a value for the KmsKeyId parameter, then DMS uses your default encryption key. KMS creates the default encryption key for your account. Your account has a different default encryption key for each Region.
        public let kmsKeyId: String?
        ///  Specifies either document or table mode.  Default value is "none". Specify "none" to use document mode. Specify "one" to use table mode.
        public let nestingLevel: NestingLevelValue?
        ///  The password for the user account you use to access the MongoDB source endpoint.
        public let password: String?
        ///  The port value for the MongoDB source endpoint.
        public let port: Int?
        /// The full Amazon Resource Name (ARN) of the IAM role that specifies DMS as the trusted entity and grants the required permissions to access the value in SecretsManagerSecret. The role must allow the iam:PassRole action. SecretsManagerSecret has the value of the Amazon Web Services Secrets Manager secret that allows access to the MongoDB endpoint.  You can specify one of two sets of values for these permissions. You can specify the values for this setting and SecretsManagerSecretId. Or you can specify clear-text values for UserName, Password, ServerName, and Port. You can't specify both. For more information on creating this SecretsManagerSecret and the SecretsManagerAccessRoleArn and SecretsManagerSecretId required to access it, see Using secrets to access Database Migration Service resources in the Database Migration Service User Guide.
        public let secretsManagerAccessRoleArn: String?
        /// The full ARN, partial ARN, or friendly name of the SecretsManagerSecret that contains the MongoDB endpoint connection details.
        public let secretsManagerSecretId: String?
        ///  The name of the server on the MongoDB source endpoint.
        public let serverName: String?
        /// The user name you use to access the MongoDB source endpoint.
        public let username: String?

        public init(authMechanism: AuthMechanismValue? = nil, authSource: String? = nil, authType: AuthTypeValue? = nil, databaseName: String? = nil, docsToInvestigate: String? = nil, extractDocId: String? = nil, kmsKeyId: String? = nil, nestingLevel: NestingLevelValue? = nil, password: String? = nil, port: Int? = nil, secretsManagerAccessRoleArn: String? = nil, secretsManagerSecretId: String? = nil, serverName: String? = nil, username: String? = nil) {
            self.authMechanism = authMechanism
            self.authSource = authSource
            self.authType = authType
            self.databaseName = databaseName
            self.docsToInvestigate = docsToInvestigate
            self.extractDocId = extractDocId
            self.kmsKeyId = kmsKeyId
            self.nestingLevel = nestingLevel
            self.password = password
            self.port = port
            self.secretsManagerAccessRoleArn = secretsManagerAccessRoleArn
            self.secretsManagerSecretId = secretsManagerSecretId
            self.serverName = serverName
            self.username = username
        }

        private enum CodingKeys: String, CodingKey {
            case authMechanism = "AuthMechanism"
            case authSource = "AuthSource"
            case authType = "AuthType"
            case databaseName = "DatabaseName"
            case docsToInvestigate = "DocsToInvestigate"
            case extractDocId = "ExtractDocId"
            case kmsKeyId = "KmsKeyId"
            case nestingLevel = "NestingLevel"
            case password = "Password"
            case port = "Port"
            case secretsManagerAccessRoleArn = "SecretsManagerAccessRoleArn"
            case secretsManagerSecretId = "SecretsManagerSecretId"
            case serverName = "ServerName"
            case username = "Username"
        }
    }

    public struct MoveReplicationTaskMessage: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the task that you want to move.
        public let replicationTaskArn: String
        /// The ARN of the replication instance where you want to move the task to.
        public let targetReplicationInstanceArn: String

        public init(replicationTaskArn: String, targetReplicationInstanceArn: String) {
            self.replicationTaskArn = replicationTaskArn
            self.targetReplicationInstanceArn = targetReplicationInstanceArn
        }

        private enum CodingKeys: String, CodingKey {
            case replicationTaskArn = "ReplicationTaskArn"
            case targetReplicationInstanceArn = "TargetReplicationInstanceArn"
        }
    }

    public struct MoveReplicationTaskResponse: AWSDecodableShape {
        /// The replication task that was moved.
        public let replicationTask: ReplicationTask?

        public init(replicationTask: ReplicationTask? = nil) {
            self.replicationTask = replicationTask
        }

        private enum CodingKeys: String, CodingKey {
            case replicationTask = "ReplicationTask"
        }
    }

    public struct MySQLSettings: AWSEncodableShape & AWSDecodableShape {
        /// Specifies a script to run immediately after DMS connects to the endpoint. The migration task continues running regardless if the SQL statement succeeds or fails. For this parameter, provide the code of the script itself, not the name of a file containing the script.
        public let afterConnectScript: String?
        /// Adjusts the behavior of DMS when migrating from an SQL Server source database that is hosted as part of an Always On availability group cluster. If you need DMS to poll all the nodes in the Always On cluster for transaction backups, set this attribute to false.
        public let cleanSourceMetadataOnMismatch: Bool?
        /// Database name for the endpoint. For a MySQL source or target endpoint, don't explicitly specify the database using the DatabaseName request parameter on either the CreateEndpoint or ModifyEndpoint API call. Specifying DatabaseName when you create or modify a MySQL endpoint replicates all the task tables to this single database. For MySQL endpoints, you specify the database only when you specify the schema in the table-mapping rules of the DMS task.
        public let databaseName: String?
        /// Specifies how often to check the binary log for new changes/events when the database is idle. Example: eventsPollInterval=5;  In the example, DMS checks for changes in the binary logs every five seconds.
        public let eventsPollInterval: Int?
        /// Specifies the maximum size (in KB) of any .csv file used to transfer data to a MySQL-compatible database. Example: maxFileSize=512
        public let maxFileSize: Int?
        /// Improves performance when loading data into the MySQL-compatible target database. Specifies how many threads to use to load the data into the MySQL-compatible target database. Setting a large number of threads can have an adverse effect on database performance, because a separate connection is required for each thread. Example: parallelLoadThreads=1
        public let parallelLoadThreads: Int?
        /// Endpoint connection password.
        public let password: String?
        /// Endpoint TCP port.
        public let port: Int?
        /// The full Amazon Resource Name (ARN) of the IAM role that specifies DMS as the trusted entity and grants the required permissions to access the value in SecretsManagerSecret. The role must allow the iam:PassRole action. SecretsManagerSecret has the value of the Amazon Web Services Secrets Manager secret that allows access to the MySQL endpoint.  You can specify one of two sets of values for these permissions. You can specify the values for this setting and SecretsManagerSecretId. Or you can specify clear-text values for UserName, Password, ServerName, and Port. You can't specify both. For more information on creating this SecretsManagerSecret and the SecretsManagerAccessRoleArn and SecretsManagerSecretId required to access it, see Using secrets to access Database Migration Service resources in the Database Migration Service User Guide.
        public let secretsManagerAccessRoleArn: String?
        /// The full ARN, partial ARN, or friendly name of the SecretsManagerSecret that contains the MySQL endpoint connection details.
        public let secretsManagerSecretId: String?
        /// Fully qualified domain name of the endpoint.
        public let serverName: String?
        /// Specifies the time zone for the source MySQL database. Example: serverTimezone=US/Pacific;  Note: Do not enclose time zones in single quotes.
        public let serverTimezone: String?
        /// Specifies where to migrate source tables on the target, either to a single database or multiple databases. Example: targetDbType=MULTIPLE_DATABASES
        public let targetDbType: TargetDbType?
        /// Endpoint connection user name.
        public let username: String?

        public init(afterConnectScript: String? = nil, cleanSourceMetadataOnMismatch: Bool? = nil, databaseName: String? = nil, eventsPollInterval: Int? = nil, maxFileSize: Int? = nil, parallelLoadThreads: Int? = nil, password: String? = nil, port: Int? = nil, secretsManagerAccessRoleArn: String? = nil, secretsManagerSecretId: String? = nil, serverName: String? = nil, serverTimezone: String? = nil, targetDbType: TargetDbType? = nil, username: String? = nil) {
            self.afterConnectScript = afterConnectScript
            self.cleanSourceMetadataOnMismatch = cleanSourceMetadataOnMismatch
            self.databaseName = databaseName
            self.eventsPollInterval = eventsPollInterval
            self.maxFileSize = maxFileSize
            self.parallelLoadThreads = parallelLoadThreads
            self.password = password
            self.port = port
            self.secretsManagerAccessRoleArn = secretsManagerAccessRoleArn
            self.secretsManagerSecretId = secretsManagerSecretId
            self.serverName = serverName
            self.serverTimezone = serverTimezone
            self.targetDbType = targetDbType
            self.username = username
        }

        private enum CodingKeys: String, CodingKey {
            case afterConnectScript = "AfterConnectScript"
            case cleanSourceMetadataOnMismatch = "CleanSourceMetadataOnMismatch"
            case databaseName = "DatabaseName"
            case eventsPollInterval = "EventsPollInterval"
            case maxFileSize = "MaxFileSize"
            case parallelLoadThreads = "ParallelLoadThreads"
            case password = "Password"
            case port = "Port"
            case secretsManagerAccessRoleArn = "SecretsManagerAccessRoleArn"
            case secretsManagerSecretId = "SecretsManagerSecretId"
            case serverName = "ServerName"
            case serverTimezone = "ServerTimezone"
            case targetDbType = "TargetDbType"
            case username = "Username"
        }
    }

    public struct NeptuneSettings: AWSEncodableShape & AWSDecodableShape {
        /// The number of milliseconds for DMS to wait to retry a bulk-load of migrated graph data to the Neptune target database before raising an error. The default is 250.
        public let errorRetryDuration: Int?
        /// If you want Identity and Access Management (IAM) authorization enabled for this endpoint, set this parameter to true. Then attach the appropriate IAM policy document to your service role specified by ServiceAccessRoleArn. The default is false.
        public let iamAuthEnabled: Bool?
        /// The maximum size in kilobytes of migrated graph data stored in a .csv file before DMS bulk-loads the data to the Neptune target database. The default is 1,048,576 KB. If the bulk load is successful, DMS clears the bucket, ready to store the next batch of migrated graph data.
        public let maxFileSize: Int?
        /// The number of times for DMS to retry a bulk load of migrated graph data to the Neptune target database before raising an error. The default is 5.
        public let maxRetryCount: Int?
        /// A folder path where you want DMS to store migrated graph data in the S3 bucket specified by S3BucketName
        public let s3BucketFolder: String
        /// The name of the Amazon S3 bucket where DMS can temporarily store migrated graph data in .csv files before bulk-loading it to the Neptune target database. DMS maps the SQL source data to graph data before storing it in these .csv files.
        public let s3BucketName: String
        /// The Amazon Resource Name (ARN) of the service role that you created for the Neptune target endpoint. The role must allow the iam:PassRole action. For more information, see Creating an IAM Service Role for Accessing Amazon Neptune as a Target in the Database Migration Service User Guide.
        public let serviceAccessRoleArn: String?

        public init(errorRetryDuration: Int? = nil, iamAuthEnabled: Bool? = nil, maxFileSize: Int? = nil, maxRetryCount: Int? = nil, s3BucketFolder: String, s3BucketName: String, serviceAccessRoleArn: String? = nil) {
            self.errorRetryDuration = errorRetryDuration
            self.iamAuthEnabled = iamAuthEnabled
            self.maxFileSize = maxFileSize
            self.maxRetryCount = maxRetryCount
            self.s3BucketFolder = s3BucketFolder
            self.s3BucketName = s3BucketName
            self.serviceAccessRoleArn = serviceAccessRoleArn
        }

        private enum CodingKeys: String, CodingKey {
            case errorRetryDuration = "ErrorRetryDuration"
            case iamAuthEnabled = "IamAuthEnabled"
            case maxFileSize = "MaxFileSize"
            case maxRetryCount = "MaxRetryCount"
            case s3BucketFolder = "S3BucketFolder"
            case s3BucketName = "S3BucketName"
            case serviceAccessRoleArn = "ServiceAccessRoleArn"
        }
    }

    public struct OracleSettings: AWSEncodableShape & AWSDecodableShape {
        /// Set this attribute to false in order to use the Binary Reader to capture change data for an Amazon RDS for Oracle as the source. This tells the DMS instance to not access redo logs through any specified path prefix replacement using direct file access.
        public let accessAlternateDirectly: Bool?
        /// Set this attribute with ArchivedLogDestId in a primary/ standby setup. This attribute is useful in the case of a switchover. In this case, DMS needs to know which destination to get archive redo logs from to read changes. This need arises because the previous primary instance is now a standby instance after switchover. Although DMS supports the use of the Oracle RESETLOGS option to open the database, never use RESETLOGS unless necessary. For additional information about RESETLOGS, see RMAN Data Repair Concepts in the Oracle Database Backup and Recovery User's Guide.
        public let additionalArchivedLogDestId: Int?
        /// Set this attribute to set up table-level supplemental logging for the Oracle database. This attribute enables PRIMARY KEY supplemental logging on all tables selected for a migration task. If you use this option, you still need to enable database-level supplemental logging.
        public let addSupplementalLogging: Bool?
        /// Set this attribute to true to enable replication of Oracle tables containing columns that are nested tables or defined types.
        public let allowSelectNestedTables: Bool?
        /// Specifies the ID of the destination for the archived redo logs. This value should be the same as a number in the dest_id column of the v$archived_log view. If you work with an additional redo log destination, use the AdditionalArchivedLogDestId option to specify the additional destination ID. Doing this improves performance by ensuring that the correct logs are accessed from the outset.
        public let archivedLogDestId: Int?
        /// When this field is set to Y, DMS only accesses the archived redo logs. If the archived redo logs are stored on Oracle ASM only, the DMS user account needs to be granted ASM privileges.
        public let archivedLogsOnly: Bool?
        /// For an Oracle source endpoint, your Oracle Automatic Storage Management (ASM) password. You can set this value from the  asm_user_password  value. You set this value as part of the comma-separated value that you set to the Password request parameter when you create the endpoint to access transaction logs using Binary Reader. For more information, see Configuration for change data capture (CDC) on an Oracle source database.
        public let asmPassword: String?
        /// For an Oracle source endpoint, your ASM server address. You can set this value from the asm_server value. You set asm_server as part of the extra connection attribute string to access an Oracle server with Binary Reader that uses ASM. For more information, see Configuration for change data capture (CDC) on an Oracle source database.
        public let asmServer: String?
        /// For an Oracle source endpoint, your ASM user name. You can set this value from the asm_user value. You set asm_user as part of the extra connection attribute string to access an Oracle server with Binary Reader that uses ASM. For more information, see Configuration for change data capture (CDC) on an Oracle source database.
        public let asmUser: String?
        /// Specifies whether the length of a character column is in bytes or in characters. To indicate that the character column length is in characters, set this attribute to CHAR. Otherwise, the character column length is in bytes. Example: charLengthSemantics=CHAR;
        public let charLengthSemantics: CharLengthSemantics?
        /// Database name for the endpoint.
        public let databaseName: String?
        /// When set to true, this attribute helps to increase the commit rate on the Oracle target database by writing directly to tables and not writing a trail to database logs.
        public let directPathNoLog: Bool?
        /// When set to true, this attribute specifies a parallel load when useDirectPathFullLoad is set to Y. This attribute also only applies when you use the DMS parallel load feature. Note that the target table cannot have any constraints or indexes.
        public let directPathParallelLoad: Bool?
        /// Set this attribute to enable homogenous tablespace replication and create existing tables or indexes under the same tablespace on the target.
        public let enableHomogenousTablespace: Bool?
        /// When set to true, this attribute causes a task to fail if the actual size of an LOB column is greater than the specified LobMaxSize. If a task is set to limited LOB mode and this option is set to true, the task fails instead of truncating the LOB data.
        public let failTasksOnLobTruncation: Bool?
        /// Specifies the number scale. You can select a scale up to 38, or you can select FLOAT. By default, the NUMBER data type is converted to precision 38, scale 10. Example: numberDataTypeScale=12
        public let numberDatatypeScale: Int?
        /// Set this string attribute to the required value in order to use the Binary Reader to capture change data for an Amazon RDS for Oracle as the source. This value specifies the default Oracle root used to access the redo logs.
        public let oraclePathPrefix: String?
        /// Set this attribute to change the number of threads that DMS configures to perform a change data capture (CDC) load using Oracle Automatic Storage Management (ASM). You can specify an integer value between 2 (the default) and 8 (the maximum). Use this attribute together with the readAheadBlocks attribute.
        public let parallelAsmReadThreads: Int?
        /// Endpoint connection password.
        public let password: String?
        /// Endpoint TCP port.
        public let port: Int?
        /// Set this attribute to change the number of read-ahead blocks that DMS configures to perform a change data capture (CDC) load using Oracle Automatic Storage Management (ASM). You can specify an integer value between 1000 (the default) and 200,000 (the maximum).
        public let readAheadBlocks: Int?
        /// When set to true, this attribute supports tablespace replication.
        public let readTableSpaceName: Bool?
        /// Set this attribute to true in order to use the Binary Reader to capture change data for an Amazon RDS for Oracle as the source. This setting tells DMS instance to replace the default Oracle root with the specified usePathPrefix setting to access the redo logs.
        public let replacePathPrefix: Bool?
        /// Specifies the number of seconds that the system waits before resending a query. Example: retryInterval=6;
        public let retryInterval: Int?
        /// The full Amazon Resource Name (ARN) of the IAM role that specifies DMS as the trusted entity and grants the required permissions to access the value in SecretsManagerSecret. The role must allow the iam:PassRole action. SecretsManagerSecret has the value of the Amazon Web Services Secrets Manager secret that allows access to the Oracle endpoint.  You can specify one of two sets of values for these permissions. You can specify the values for this setting and SecretsManagerSecretId. Or you can specify clear-text values for UserName, Password, ServerName, and Port. You can't specify both. For more information on creating this SecretsManagerSecret and the SecretsManagerAccessRoleArn and SecretsManagerSecretId required to access it, see Using secrets to access Database Migration Service resources in the Database Migration Service User Guide.
        public let secretsManagerAccessRoleArn: String?
        /// Required only if your Oracle endpoint uses Advanced Storage Manager (ASM). The full ARN of the IAM role that specifies DMS as the trusted entity and grants the required permissions to access the SecretsManagerOracleAsmSecret. This SecretsManagerOracleAsmSecret has the secret value that allows access to the Oracle ASM of the endpoint.  You can specify one of two sets of values for these permissions. You can specify the values for this setting and SecretsManagerOracleAsmSecretId. Or you can specify clear-text values for AsmUserName, AsmPassword, and AsmServerName. You can't specify both. For more information on creating this SecretsManagerOracleAsmSecret and the SecretsManagerOracleAsmAccessRoleArn and SecretsManagerOracleAsmSecretId required to access it, see Using secrets to access Database Migration Service resources in the Database Migration Service User Guide.
        public let secretsManagerOracleAsmAccessRoleArn: String?
        /// Required only if your Oracle endpoint uses Advanced Storage Manager (ASM). The full ARN, partial ARN, or friendly name of the SecretsManagerOracleAsmSecret that contains the Oracle ASM connection details for the Oracle endpoint.
        public let secretsManagerOracleAsmSecretId: String?
        /// The full ARN, partial ARN, or friendly name of the SecretsManagerSecret that contains the Oracle endpoint connection details.
        public let secretsManagerSecretId: String?
        /// For an Oracle source endpoint, the transparent data encryption (TDE) password required by AWM DMS to access Oracle redo logs encrypted by TDE using Binary Reader. It is also the  TDE_Password  part of the comma-separated value you set to the Password request parameter when you create the endpoint. The SecurityDbEncryptian setting is related to this SecurityDbEncryptionName setting. For more information, see  Supported encryption methods for using Oracle as a source for DMS  in the Database Migration Service User Guide.
        public let securityDbEncryption: String?
        /// For an Oracle source endpoint, the name of a key used for the transparent data encryption (TDE) of the columns and tablespaces in an Oracle source database that is encrypted using TDE. The key value is the value of the SecurityDbEncryption setting. For more information on setting the key name value of SecurityDbEncryptionName, see the information and example for setting the securityDbEncryptionName extra connection attribute in  Supported encryption methods for using Oracle as a source for DMS  in the Database Migration Service User Guide.
        public let securityDbEncryptionName: String?
        /// Fully qualified domain name of the endpoint.
        public let serverName: String?
        /// Use this attribute to convert SDO_GEOMETRY to GEOJSON format. By default, DMS calls the SDO2GEOJSON custom function if present and accessible. Or you can create your own custom function that mimics the operation of SDOGEOJSON and set SpatialDataOptionToGeoJsonFunctionName to call it instead.
        public let spatialDataOptionToGeoJsonFunctionName: String?
        /// Use this attribute to specify a time in minutes for the delay in standby sync. If the source is an Oracle Active Data Guard standby database, use this attribute to specify the time lag between primary and standby databases. In DMS, you can create an Oracle CDC task that uses an Active Data Guard standby instance as a source for replicating ongoing changes. Doing this eliminates the need to connect to an active database that might be in production.
        public let standbyDelayTime: Int?
        /// Set this attribute to true in order to use the Binary Reader to capture change data for an Amazon RDS for Oracle as the source. This tells the DMS instance to use any specified prefix replacement to access all online redo logs.
        public let useAlternateFolderForOnline: Bool?
        /// Set this attribute to Y to capture change data using the Binary Reader utility. Set UseLogminerReader to N to set this attribute to Y. To use Binary Reader with Amazon RDS for Oracle as the source, you set additional attributes. For more information about using this setting with Oracle Automatic Storage Management (ASM), see  Using Oracle LogMiner or DMS Binary Reader for CDC.
        public let useBFile: Bool?
        /// Set this attribute to Y to have DMS use a direct path full load. Specify this value to use the direct path protocol in the Oracle Call Interface (OCI). By using this OCI protocol, you can bulk-load Oracle target tables during a full load.
        public let useDirectPathFullLoad: Bool?
        /// Set this attribute to Y to capture change data using the Oracle LogMiner utility (the default). Set this attribute to N if you want to access the redo logs as a binary file. When you set UseLogminerReader to N, also set UseBfile to Y. For more information on this setting and using Oracle ASM, see  Using Oracle LogMiner or DMS Binary Reader for CDC in the DMS User Guide.
        public let useLogminerReader: Bool?
        /// Set this string attribute to the required value in order to use the Binary Reader to capture change data for an Amazon RDS for Oracle as the source. This value specifies the path prefix used to replace the default Oracle root to access the redo logs.
        public let usePathPrefix: String?
        /// Endpoint connection user name.
        public let username: String?

        public init(accessAlternateDirectly: Bool? = nil, additionalArchivedLogDestId: Int? = nil, addSupplementalLogging: Bool? = nil, allowSelectNestedTables: Bool? = nil, archivedLogDestId: Int? = nil, archivedLogsOnly: Bool? = nil, asmPassword: String? = nil, asmServer: String? = nil, asmUser: String? = nil, charLengthSemantics: CharLengthSemantics? = nil, databaseName: String? = nil, directPathNoLog: Bool? = nil, directPathParallelLoad: Bool? = nil, enableHomogenousTablespace: Bool? = nil, failTasksOnLobTruncation: Bool? = nil, numberDatatypeScale: Int? = nil, oraclePathPrefix: String? = nil, parallelAsmReadThreads: Int? = nil, password: String? = nil, port: Int? = nil, readAheadBlocks: Int? = nil, readTableSpaceName: Bool? = nil, replacePathPrefix: Bool? = nil, retryInterval: Int? = nil, secretsManagerAccessRoleArn: String? = nil, secretsManagerOracleAsmAccessRoleArn: String? = nil, secretsManagerOracleAsmSecretId: String? = nil, secretsManagerSecretId: String? = nil, securityDbEncryption: String? = nil, securityDbEncryptionName: String? = nil, serverName: String? = nil, spatialDataOptionToGeoJsonFunctionName: String? = nil, standbyDelayTime: Int? = nil, useAlternateFolderForOnline: Bool? = nil, useBFile: Bool? = nil, useDirectPathFullLoad: Bool? = nil, useLogminerReader: Bool? = nil, usePathPrefix: String? = nil, username: String? = nil) {
            self.accessAlternateDirectly = accessAlternateDirectly
            self.additionalArchivedLogDestId = additionalArchivedLogDestId
            self.addSupplementalLogging = addSupplementalLogging
            self.allowSelectNestedTables = allowSelectNestedTables
            self.archivedLogDestId = archivedLogDestId
            self.archivedLogsOnly = archivedLogsOnly
            self.asmPassword = asmPassword
            self.asmServer = asmServer
            self.asmUser = asmUser
            self.charLengthSemantics = charLengthSemantics
            self.databaseName = databaseName
            self.directPathNoLog = directPathNoLog
            self.directPathParallelLoad = directPathParallelLoad
            self.enableHomogenousTablespace = enableHomogenousTablespace
            self.failTasksOnLobTruncation = failTasksOnLobTruncation
            self.numberDatatypeScale = numberDatatypeScale
            self.oraclePathPrefix = oraclePathPrefix
            self.parallelAsmReadThreads = parallelAsmReadThreads
            self.password = password
            self.port = port
            self.readAheadBlocks = readAheadBlocks
            self.readTableSpaceName = readTableSpaceName
            self.replacePathPrefix = replacePathPrefix
            self.retryInterval = retryInterval
            self.secretsManagerAccessRoleArn = secretsManagerAccessRoleArn
            self.secretsManagerOracleAsmAccessRoleArn = secretsManagerOracleAsmAccessRoleArn
            self.secretsManagerOracleAsmSecretId = secretsManagerOracleAsmSecretId
            self.secretsManagerSecretId = secretsManagerSecretId
            self.securityDbEncryption = securityDbEncryption
            self.securityDbEncryptionName = securityDbEncryptionName
            self.serverName = serverName
            self.spatialDataOptionToGeoJsonFunctionName = spatialDataOptionToGeoJsonFunctionName
            self.standbyDelayTime = standbyDelayTime
            self.useAlternateFolderForOnline = useAlternateFolderForOnline
            self.useBFile = useBFile
            self.useDirectPathFullLoad = useDirectPathFullLoad
            self.useLogminerReader = useLogminerReader
            self.usePathPrefix = usePathPrefix
            self.username = username
        }

        private enum CodingKeys: String, CodingKey {
            case accessAlternateDirectly = "AccessAlternateDirectly"
            case additionalArchivedLogDestId = "AdditionalArchivedLogDestId"
            case addSupplementalLogging = "AddSupplementalLogging"
            case allowSelectNestedTables = "AllowSelectNestedTables"
            case archivedLogDestId = "ArchivedLogDestId"
            case archivedLogsOnly = "ArchivedLogsOnly"
            case asmPassword = "AsmPassword"
            case asmServer = "AsmServer"
            case asmUser = "AsmUser"
            case charLengthSemantics = "CharLengthSemantics"
            case databaseName = "DatabaseName"
            case directPathNoLog = "DirectPathNoLog"
            case directPathParallelLoad = "DirectPathParallelLoad"
            case enableHomogenousTablespace = "EnableHomogenousTablespace"
            case failTasksOnLobTruncation = "FailTasksOnLobTruncation"
            case numberDatatypeScale = "NumberDatatypeScale"
            case oraclePathPrefix = "OraclePathPrefix"
            case parallelAsmReadThreads = "ParallelAsmReadThreads"
            case password = "Password"
            case port = "Port"
            case readAheadBlocks = "ReadAheadBlocks"
            case readTableSpaceName = "ReadTableSpaceName"
            case replacePathPrefix = "ReplacePathPrefix"
            case retryInterval = "RetryInterval"
            case secretsManagerAccessRoleArn = "SecretsManagerAccessRoleArn"
            case secretsManagerOracleAsmAccessRoleArn = "SecretsManagerOracleAsmAccessRoleArn"
            case secretsManagerOracleAsmSecretId = "SecretsManagerOracleAsmSecretId"
            case secretsManagerSecretId = "SecretsManagerSecretId"
            case securityDbEncryption = "SecurityDbEncryption"
            case securityDbEncryptionName = "SecurityDbEncryptionName"
            case serverName = "ServerName"
            case spatialDataOptionToGeoJsonFunctionName = "SpatialDataOptionToGeoJsonFunctionName"
            case standbyDelayTime = "StandbyDelayTime"
            case useAlternateFolderForOnline = "UseAlternateFolderForOnline"
            case useBFile = "UseBFile"
            case useDirectPathFullLoad = "UseDirectPathFullLoad"
            case useLogminerReader = "UseLogminerReader"
            case usePathPrefix = "UsePathPrefix"
            case username = "Username"
        }
    }

    public struct OrderableReplicationInstance: AWSDecodableShape {
        /// List of Availability Zones for this replication instance.
        public let availabilityZones: [String]?
        /// The default amount of storage (in gigabytes) that is allocated for the replication instance.
        public let defaultAllocatedStorage: Int?
        /// The version of the replication engine.
        public let engineVersion: String?
        /// The amount of storage (in gigabytes) that is allocated for the replication instance.
        public let includedAllocatedStorage: Int?
        /// The minimum amount of storage (in gigabytes) that can be allocated for the replication instance.
        public let maxAllocatedStorage: Int?
        /// The minimum amount of storage (in gigabytes) that can be allocated for the replication instance.
        public let minAllocatedStorage: Int?
        /// The value returned when the specified EngineVersion of the replication instance is in Beta or test mode. This indicates some features might not work as expected.  DMS supports the ReleaseStatus parameter in versions 3.1.4 and later.
        public let releaseStatus: ReleaseStatusValues?
        /// The compute and memory capacity of the replication instance as defined for the specified replication instance class. For example to specify the instance class dms.c4.large, set this parameter to "dms.c4.large". For more information on the settings and capacities for the available replication instance classes, see  Selecting the right DMS replication instance for your migration.
        public let replicationInstanceClass: String?
        /// The type of storage used by the replication instance.
        public let storageType: String?

        public init(availabilityZones: [String]? = nil, defaultAllocatedStorage: Int? = nil, engineVersion: String? = nil, includedAllocatedStorage: Int? = nil, maxAllocatedStorage: Int? = nil, minAllocatedStorage: Int? = nil, releaseStatus: ReleaseStatusValues? = nil, replicationInstanceClass: String? = nil, storageType: String? = nil) {
            self.availabilityZones = availabilityZones
            self.defaultAllocatedStorage = defaultAllocatedStorage
            self.engineVersion = engineVersion
            self.includedAllocatedStorage = includedAllocatedStorage
            self.maxAllocatedStorage = maxAllocatedStorage
            self.minAllocatedStorage = minAllocatedStorage
            self.releaseStatus = releaseStatus
            self.replicationInstanceClass = replicationInstanceClass
            self.storageType = storageType
        }

        private enum CodingKeys: String, CodingKey {
            case availabilityZones = "AvailabilityZones"
            case defaultAllocatedStorage = "DefaultAllocatedStorage"
            case engineVersion = "EngineVersion"
            case includedAllocatedStorage = "IncludedAllocatedStorage"
            case maxAllocatedStorage = "MaxAllocatedStorage"
            case minAllocatedStorage = "MinAllocatedStorage"
            case releaseStatus = "ReleaseStatus"
            case replicationInstanceClass = "ReplicationInstanceClass"
            case storageType = "StorageType"
        }
    }

    public struct PendingMaintenanceAction: AWSDecodableShape {
        /// The type of pending maintenance action that is available for the resource.
        public let action: String?
        /// The date of the maintenance window when the action is to be applied. The maintenance action is applied to the resource during its first maintenance window after this date. If this date is specified, any next-maintenance opt-in requests are ignored.
        public let autoAppliedAfterDate: Date?
        /// The effective date when the pending maintenance action will be applied to the resource. This date takes into account opt-in requests received from the ApplyPendingMaintenanceAction API operation, and also the AutoAppliedAfterDate and ForcedApplyDate parameter values. This value is blank if an opt-in request has not been received and nothing has been specified for AutoAppliedAfterDate or ForcedApplyDate.
        public let currentApplyDate: Date?
        /// A description providing more detail about the maintenance action.
        public let description: String?
        /// The date when the maintenance action will be automatically applied. The maintenance action is applied to the resource on this date regardless of the maintenance window for the resource. If this date is specified, any immediate opt-in requests are ignored.
        public let forcedApplyDate: Date?
        /// The type of opt-in request that has been received for the resource.
        public let optInStatus: String?

        public init(action: String? = nil, autoAppliedAfterDate: Date? = nil, currentApplyDate: Date? = nil, description: String? = nil, forcedApplyDate: Date? = nil, optInStatus: String? = nil) {
            self.action = action
            self.autoAppliedAfterDate = autoAppliedAfterDate
            self.currentApplyDate = currentApplyDate
            self.description = description
            self.forcedApplyDate = forcedApplyDate
            self.optInStatus = optInStatus
        }

        private enum CodingKeys: String, CodingKey {
            case action = "Action"
            case autoAppliedAfterDate = "AutoAppliedAfterDate"
            case currentApplyDate = "CurrentApplyDate"
            case description = "Description"
            case forcedApplyDate = "ForcedApplyDate"
            case optInStatus = "OptInStatus"
        }
    }

    public struct PostgreSQLSettings: AWSEncodableShape & AWSDecodableShape {
        /// For use with change data capture (CDC) only, this attribute has DMS bypass foreign keys and user triggers to reduce the time it takes to bulk load data. Example: afterConnectScript=SET session_replication_role='replica'
        public let afterConnectScript: String?
        /// To capture DDL events, DMS creates various artifacts in the PostgreSQL database when the task starts. You can later remove these artifacts. If this value is set to N, you don't have to create tables or triggers on the source database.
        public let captureDdls: Bool?
        /// Database name for the endpoint.
        public let databaseName: String?
        /// The schema in which the operational DDL database artifacts are created. Example: ddlArtifactsSchema=xyzddlschema;
        public let ddlArtifactsSchema: String?
        /// Sets the client statement timeout for the PostgreSQL instance, in seconds. The default value is 60 seconds. Example: executeTimeout=100;
        public let executeTimeout: Int?
        /// When set to true, this value causes a task to fail if the actual size of a LOB column is greater than the specified LobMaxSize. If task is set to Limited LOB mode and this option is set to true, the task fails instead of truncating the LOB data.
        public let failTasksOnLobTruncation: Bool?
        /// If this attribute is set to true, the write-ahead log (WAL) heartbeat keeps restart_lsn moving and prevents storage full scenarios. The WAL heartbeat mimics a dummy transaction, so that idle logical replication slots don't hold onto old WAL logs that result in storage full situations on the source.
        public let heartbeatEnable: Bool?
        /// Sets the WAL heartbeat frequency (in minutes).
        public let heartbeatFrequency: Int?
        /// Sets the schema in which the heartbeat artifacts are created.
        public let heartbeatSchema: String?
        /// Specifies the maximum size (in KB) of any .csv file used to transfer data to PostgreSQL. Example: maxFileSize=512
        public let maxFileSize: Int?
        /// Endpoint connection password.
        public let password: String?
        /// Specifies the plugin to use to create a replication slot.
        public let pluginName: PluginNameValue?
        /// Endpoint TCP port.
        public let port: Int?
        /// The full Amazon Resource Name (ARN) of the IAM role that specifies DMS as the trusted entity and grants the required permissions to access the value in SecretsManagerSecret. The role must allow the iam:PassRole action. SecretsManagerSecret has the value of the Amazon Web Services Secrets Manager secret that allows access to the PostgreSQL endpoint.  You can specify one of two sets of values for these permissions. You can specify the values for this setting and SecretsManagerSecretId. Or you can specify clear-text values for UserName, Password, ServerName, and Port. You can't specify both. For more information on creating this SecretsManagerSecret and the SecretsManagerAccessRoleArn and SecretsManagerSecretId required to access it, see Using secrets to access Database Migration Service resources in the Database Migration Service User Guide.
        public let secretsManagerAccessRoleArn: String?
        /// The full ARN, partial ARN, or friendly name of the SecretsManagerSecret that contains the PostgreSQL endpoint connection details.
        public let secretsManagerSecretId: String?
        /// Fully qualified domain name of the endpoint.
        public let serverName: String?
        /// Sets the name of a previously created logical replication slot for a CDC load of the PostgreSQL source instance. When used with the DMS API CdcStartPosition request parameter, this attribute also enables using native CDC start points.
        public let slotName: String?
        /// Endpoint connection user name.
        public let username: String?

        public init(afterConnectScript: String? = nil, captureDdls: Bool? = nil, databaseName: String? = nil, ddlArtifactsSchema: String? = nil, executeTimeout: Int? = nil, failTasksOnLobTruncation: Bool? = nil, heartbeatEnable: Bool? = nil, heartbeatFrequency: Int? = nil, heartbeatSchema: String? = nil, maxFileSize: Int? = nil, password: String? = nil, pluginName: PluginNameValue? = nil, port: Int? = nil, secretsManagerAccessRoleArn: String? = nil, secretsManagerSecretId: String? = nil, serverName: String? = nil, slotName: String? = nil, username: String? = nil) {
            self.afterConnectScript = afterConnectScript
            self.captureDdls = captureDdls
            self.databaseName = databaseName
            self.ddlArtifactsSchema = ddlArtifactsSchema
            self.executeTimeout = executeTimeout
            self.failTasksOnLobTruncation = failTasksOnLobTruncation
            self.heartbeatEnable = heartbeatEnable
            self.heartbeatFrequency = heartbeatFrequency
            self.heartbeatSchema = heartbeatSchema
            self.maxFileSize = maxFileSize
            self.password = password
            self.pluginName = pluginName
            self.port = port
            self.secretsManagerAccessRoleArn = secretsManagerAccessRoleArn
            self.secretsManagerSecretId = secretsManagerSecretId
            self.serverName = serverName
            self.slotName = slotName
            self.username = username
        }

        private enum CodingKeys: String, CodingKey {
            case afterConnectScript = "AfterConnectScript"
            case captureDdls = "CaptureDdls"
            case databaseName = "DatabaseName"
            case ddlArtifactsSchema = "DdlArtifactsSchema"
            case executeTimeout = "ExecuteTimeout"
            case failTasksOnLobTruncation = "FailTasksOnLobTruncation"
            case heartbeatEnable = "HeartbeatEnable"
            case heartbeatFrequency = "HeartbeatFrequency"
            case heartbeatSchema = "HeartbeatSchema"
            case maxFileSize = "MaxFileSize"
            case password = "Password"
            case pluginName = "PluginName"
            case port = "Port"
            case secretsManagerAccessRoleArn = "SecretsManagerAccessRoleArn"
            case secretsManagerSecretId = "SecretsManagerSecretId"
            case serverName = "ServerName"
            case slotName = "SlotName"
            case username = "Username"
        }
    }

    public struct RebootReplicationInstanceMessage: AWSEncodableShape {
        /// If this parameter is true, the reboot is conducted through a Multi-AZ failover. (If the instance isn't configured for Multi-AZ, then you can't specify true.)
        public let forceFailover: Bool?
        /// The Amazon Resource Name (ARN) of the replication instance.
        public let replicationInstanceArn: String

        public init(forceFailover: Bool? = nil, replicationInstanceArn: String) {
            self.forceFailover = forceFailover
            self.replicationInstanceArn = replicationInstanceArn
        }

        private enum CodingKeys: String, CodingKey {
            case forceFailover = "ForceFailover"
            case replicationInstanceArn = "ReplicationInstanceArn"
        }
    }

    public struct RebootReplicationInstanceResponse: AWSDecodableShape {
        /// The replication instance that is being rebooted.
        public let replicationInstance: ReplicationInstance?

        public init(replicationInstance: ReplicationInstance? = nil) {
            self.replicationInstance = replicationInstance
        }

        private enum CodingKeys: String, CodingKey {
            case replicationInstance = "ReplicationInstance"
        }
    }

    public struct RedshiftSettings: AWSEncodableShape & AWSDecodableShape {
        /// A value that indicates to allow any date format, including invalid formats such as 00/00/00 00:00:00, to be loaded without generating an error. You can choose true or false (the default). This parameter applies only to TIMESTAMP and DATE columns. Always use ACCEPTANYDATE with the DATEFORMAT parameter. If the date format for the data doesn't match the DATEFORMAT specification, Amazon Redshift inserts a NULL value into that field.
        public let acceptAnyDate: Bool?
        /// Code to run after connecting. This parameter should contain the code itself, not the name of a file containing the code.
        public let afterConnectScript: String?
        /// An S3 folder where the comma-separated-value (.csv) files are stored before being uploaded to the target Redshift cluster.  For full load mode, DMS converts source records into .csv files and loads them to the BucketFolder/TableID path. DMS uses the Redshift COPY command to upload the .csv files to the target table. The files are deleted once the COPY operation has finished. For more information, see COPY in the Amazon Redshift Database Developer Guide. For change-data-capture (CDC) mode, DMS creates a NetChanges table, and loads the .csv files to this BucketFolder/NetChangesTableID path.
        public let bucketFolder: String?
        /// The name of the intermediate S3 bucket used to store .csv files before uploading data to Redshift.
        public let bucketName: String?
        /// If Amazon Redshift is configured to support case sensitive schema names, set CaseSensitiveNames to true. The default is false.
        public let caseSensitiveNames: Bool?
        /// If you set CompUpdate to true Amazon Redshift applies automatic compression if the table is empty. This applies even if the table columns already have encodings other than RAW. If you set CompUpdate to false, automatic compression is disabled and existing column encodings aren't changed. The default is true.
        public let compUpdate: Bool?
        /// A value that sets the amount of time to wait (in milliseconds) before timing out, beginning from when you initially establish a connection.
        public let connectionTimeout: Int?
        /// The name of the Amazon Redshift data warehouse (service) that you are working with.
        public let databaseName: String?
        /// The date format that you are using. Valid values are auto (case-sensitive), your date format string enclosed in quotes, or NULL. If this parameter is left unset (NULL), it defaults to a format of 'YYYY-MM-DD'. Using auto recognizes most strings, even some that aren't supported when you use a date format string.  If your date and time values use formats different from each other, set this to auto.
        public let dateFormat: String?
        /// A value that specifies whether DMS should migrate empty CHAR and VARCHAR fields as NULL. A value of true sets empty CHAR and VARCHAR fields to null. The default is false.
        public let emptyAsNull: Bool?
        /// The type of server-side encryption that you want to use for your data. This encryption type is part of the endpoint settings or the extra connections attributes for Amazon S3. You can choose either SSE_S3 (the default) or SSE_KMS.   For the ModifyEndpoint operation, you can change the existing value of the EncryptionMode parameter from SSE_KMS to SSE_S3. But you can’t change the existing value from SSE_S3 to SSE_KMS.  To use SSE_S3, create an Identity and Access Management (IAM) role with a policy that allows "arn:aws:s3:::*" to use the following actions: "s3:PutObject", "s3:ListBucket"
        public let encryptionMode: EncryptionModeValue?
        /// This setting is only valid for a full-load migration task. Set ExplicitIds to true to have tables with IDENTITY columns override their auto-generated values with explicit values loaded from the source data files used to populate the tables. The default is false.
        public let explicitIds: Bool?
        /// The number of threads used to upload a single file. This parameter accepts a value from 1 through 64. It defaults to 10. The number of parallel streams used to upload a single .csv file to an S3 bucket using S3 Multipart Upload. For more information, see Multipart upload overview.   FileTransferUploadStreams accepts a value from 1 through 64. It defaults to 10.
        public let fileTransferUploadStreams: Int?
        /// The amount of time to wait (in milliseconds) before timing out of operations performed by DMS on a Redshift cluster, such as Redshift COPY, INSERT, DELETE, and UPDATE.
        public let loadTimeout: Int?
        /// The maximum size (in KB) of any .csv file used to load data on an S3 bucket and transfer data to Amazon Redshift. It defaults to 1048576KB (1 GB).
        public let maxFileSize: Int?
        /// The password for the user named in the username property.
        public let password: String?
        /// The port number for Amazon Redshift. The default value is 5439.
        public let port: Int?
        /// A value that specifies to remove surrounding quotation marks from strings in the incoming data. All characters within the quotation marks, including delimiters, are retained. Choose true to remove quotation marks. The default is false.
        public let removeQuotes: Bool?
        /// A value that specifies to replaces the invalid characters specified in ReplaceInvalidChars, substituting the specified characters instead. The default is "?".
        public let replaceChars: String?
        /// A list of characters that you want to replace. Use with ReplaceChars.
        public let replaceInvalidChars: String?
        /// The full Amazon Resource Name (ARN) of the IAM role that specifies DMS as the trusted entity and grants the required permissions to access the value in SecretsManagerSecret. The role must allow the iam:PassRole action. SecretsManagerSecret has the value of the Amazon Web Services Secrets Manager secret that allows access to the Amazon Redshift endpoint.  You can specify one of two sets of values for these permissions. You can specify the values for this setting and SecretsManagerSecretId. Or you can specify clear-text values for UserName, Password, ServerName, and Port. You can't specify both. For more information on creating this SecretsManagerSecret and the SecretsManagerAccessRoleArn and SecretsManagerSecretId required to access it, see Using secrets to access Database Migration Service resources in the Database Migration Service User Guide.
        public let secretsManagerAccessRoleArn: String?
        /// The full ARN, partial ARN, or friendly name of the SecretsManagerSecret that contains the Amazon Redshift endpoint connection details.
        public let secretsManagerSecretId: String?
        /// The name of the Amazon Redshift cluster you are using.
        public let serverName: String?
        /// The KMS key ID. If you are using SSE_KMS for the EncryptionMode, provide this key ID. The key that you use needs an attached policy that enables IAM user permissions and allows use of the key.
        public let serverSideEncryptionKmsKeyId: String?
        /// The Amazon Resource Name (ARN) of the IAM role that has access to the Amazon Redshift service. The role must allow the iam:PassRole action.
        public let serviceAccessRoleArn: String?
        /// The time format that you want to use. Valid values are auto (case-sensitive), 'timeformat_string', 'epochsecs', or 'epochmillisecs'. It defaults to 10. Using auto recognizes most strings, even some that aren't supported when you use a time format string.  If your date and time values use formats different from each other, set this parameter to auto.
        public let timeFormat: String?
        /// A value that specifies to remove the trailing white space characters from a VARCHAR string. This parameter applies only to columns with a VARCHAR data type. Choose true to remove unneeded white space. The default is false.
        public let trimBlanks: Bool?
        /// A value that specifies to truncate data in columns to the appropriate number of characters, so that the data fits in the column. This parameter applies only to columns with a VARCHAR or CHAR data type, and rows with a size of 4 MB or less. Choose true to truncate data. The default is false.
        public let truncateColumns: Bool?
        /// An Amazon Redshift user name for a registered user.
        public let username: String?
        /// The size (in KB) of the in-memory file write buffer used when generating .csv files on the local disk at the DMS replication instance. The default value is 1000 (buffer size is 1000KB).
        public let writeBufferSize: Int?

        public init(acceptAnyDate: Bool? = nil, afterConnectScript: String? = nil, bucketFolder: String? = nil, bucketName: String? = nil, caseSensitiveNames: Bool? = nil, compUpdate: Bool? = nil, connectionTimeout: Int? = nil, databaseName: String? = nil, dateFormat: String? = nil, emptyAsNull: Bool? = nil, encryptionMode: EncryptionModeValue? = nil, explicitIds: Bool? = nil, fileTransferUploadStreams: Int? = nil, loadTimeout: Int? = nil, maxFileSize: Int? = nil, password: String? = nil, port: Int? = nil, removeQuotes: Bool? = nil, replaceChars: String? = nil, replaceInvalidChars: String? = nil, secretsManagerAccessRoleArn: String? = nil, secretsManagerSecretId: String? = nil, serverName: String? = nil, serverSideEncryptionKmsKeyId: String? = nil, serviceAccessRoleArn: String? = nil, timeFormat: String? = nil, trimBlanks: Bool? = nil, truncateColumns: Bool? = nil, username: String? = nil, writeBufferSize: Int? = nil) {
            self.acceptAnyDate = acceptAnyDate
            self.afterConnectScript = afterConnectScript
            self.bucketFolder = bucketFolder
            self.bucketName = bucketName
            self.caseSensitiveNames = caseSensitiveNames
            self.compUpdate = compUpdate
            self.connectionTimeout = connectionTimeout
            self.databaseName = databaseName
            self.dateFormat = dateFormat
            self.emptyAsNull = emptyAsNull
            self.encryptionMode = encryptionMode
            self.explicitIds = explicitIds
            self.fileTransferUploadStreams = fileTransferUploadStreams
            self.loadTimeout = loadTimeout
            self.maxFileSize = maxFileSize
            self.password = password
            self.port = port
            self.removeQuotes = removeQuotes
            self.replaceChars = replaceChars
            self.replaceInvalidChars = replaceInvalidChars
            self.secretsManagerAccessRoleArn = secretsManagerAccessRoleArn
            self.secretsManagerSecretId = secretsManagerSecretId
            self.serverName = serverName
            self.serverSideEncryptionKmsKeyId = serverSideEncryptionKmsKeyId
            self.serviceAccessRoleArn = serviceAccessRoleArn
            self.timeFormat = timeFormat
            self.trimBlanks = trimBlanks
            self.truncateColumns = truncateColumns
            self.username = username
            self.writeBufferSize = writeBufferSize
        }

        private enum CodingKeys: String, CodingKey {
            case acceptAnyDate = "AcceptAnyDate"
            case afterConnectScript = "AfterConnectScript"
            case bucketFolder = "BucketFolder"
            case bucketName = "BucketName"
            case caseSensitiveNames = "CaseSensitiveNames"
            case compUpdate = "CompUpdate"
            case connectionTimeout = "ConnectionTimeout"
            case databaseName = "DatabaseName"
            case dateFormat = "DateFormat"
            case emptyAsNull = "EmptyAsNull"
            case encryptionMode = "EncryptionMode"
            case explicitIds = "ExplicitIds"
            case fileTransferUploadStreams = "FileTransferUploadStreams"
            case loadTimeout = "LoadTimeout"
            case maxFileSize = "MaxFileSize"
            case password = "Password"
            case port = "Port"
            case removeQuotes = "RemoveQuotes"
            case replaceChars = "ReplaceChars"
            case replaceInvalidChars = "ReplaceInvalidChars"
            case secretsManagerAccessRoleArn = "SecretsManagerAccessRoleArn"
            case secretsManagerSecretId = "SecretsManagerSecretId"
            case serverName = "ServerName"
            case serverSideEncryptionKmsKeyId = "ServerSideEncryptionKmsKeyId"
            case serviceAccessRoleArn = "ServiceAccessRoleArn"
            case timeFormat = "TimeFormat"
            case trimBlanks = "TrimBlanks"
            case truncateColumns = "TruncateColumns"
            case username = "Username"
            case writeBufferSize = "WriteBufferSize"
        }
    }

    public struct RefreshSchemasMessage: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) string that uniquely identifies the endpoint.
        public let endpointArn: String
        /// The Amazon Resource Name (ARN) of the replication instance.
        public let replicationInstanceArn: String

        public init(endpointArn: String, replicationInstanceArn: String) {
            self.endpointArn = endpointArn
            self.replicationInstanceArn = replicationInstanceArn
        }

        private enum CodingKeys: String, CodingKey {
            case endpointArn = "EndpointArn"
            case replicationInstanceArn = "ReplicationInstanceArn"
        }
    }

    public struct RefreshSchemasResponse: AWSDecodableShape {
        /// The status of the refreshed schema.
        public let refreshSchemasStatus: RefreshSchemasStatus?

        public init(refreshSchemasStatus: RefreshSchemasStatus? = nil) {
            self.refreshSchemasStatus = refreshSchemasStatus
        }

        private enum CodingKeys: String, CodingKey {
            case refreshSchemasStatus = "RefreshSchemasStatus"
        }
    }

    public struct RefreshSchemasStatus: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) string that uniquely identifies the endpoint.
        public let endpointArn: String?
        /// The last failure message for the schema.
        public let lastFailureMessage: String?
        /// The date the schema was last refreshed.
        public let lastRefreshDate: Date?
        /// The Amazon Resource Name (ARN) of the replication instance.
        public let replicationInstanceArn: String?
        /// The status of the schema.
        public let status: RefreshSchemasStatusTypeValue?

        public init(endpointArn: String? = nil, lastFailureMessage: String? = nil, lastRefreshDate: Date? = nil, replicationInstanceArn: String? = nil, status: RefreshSchemasStatusTypeValue? = nil) {
            self.endpointArn = endpointArn
            self.lastFailureMessage = lastFailureMessage
            self.lastRefreshDate = lastRefreshDate
            self.replicationInstanceArn = replicationInstanceArn
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case endpointArn = "EndpointArn"
            case lastFailureMessage = "LastFailureMessage"
            case lastRefreshDate = "LastRefreshDate"
            case replicationInstanceArn = "ReplicationInstanceArn"
            case status = "Status"
        }
    }

    public struct ReloadTablesMessage: AWSEncodableShape {
        /// Options for reload. Specify data-reload to reload the data and re-validate it if validation is enabled. Specify validate-only to re-validate the table. This option applies only when validation is enabled for the task.  Valid values: data-reload, validate-only Default value is data-reload.
        public let reloadOption: ReloadOptionValue?
        /// The Amazon Resource Name (ARN) of the replication task.
        public let replicationTaskArn: String
        /// The name and schema of the table to be reloaded.
        public let tablesToReload: [TableToReload]

        public init(reloadOption: ReloadOptionValue? = nil, replicationTaskArn: String, tablesToReload: [TableToReload]) {
            self.reloadOption = reloadOption
            self.replicationTaskArn = replicationTaskArn
            self.tablesToReload = tablesToReload
        }

        private enum CodingKeys: String, CodingKey {
            case reloadOption = "ReloadOption"
            case replicationTaskArn = "ReplicationTaskArn"
            case tablesToReload = "TablesToReload"
        }
    }

    public struct ReloadTablesResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the replication task.
        public let replicationTaskArn: String?

        public init(replicationTaskArn: String? = nil) {
            self.replicationTaskArn = replicationTaskArn
        }

        private enum CodingKeys: String, CodingKey {
            case replicationTaskArn = "ReplicationTaskArn"
        }
    }

    public struct RemoveTagsFromResourceMessage: AWSEncodableShape {
        /// An DMS resource from which you want to remove tag(s). The value for this parameter is an Amazon Resource Name (ARN).
        public let resourceArn: String
        /// The tag key (name) of the tag to be removed.
        public let tagKeys: [String]

        public init(resourceArn: String, tagKeys: [String]) {
            self.resourceArn = resourceArn
            self.tagKeys = tagKeys
        }

        private enum CodingKeys: String, CodingKey {
            case resourceArn = "ResourceArn"
            case tagKeys = "TagKeys"
        }
    }

    public struct RemoveTagsFromResourceResponse: AWSDecodableShape {
        public init() {}
    }

    public struct ReplicationInstance: AWSDecodableShape {
        /// The amount of storage (in gigabytes) that is allocated for the replication instance.
        public let allocatedStorage: Int?
        /// Boolean value indicating if minor version upgrades will be automatically applied to the instance.
        public let autoMinorVersionUpgrade: Bool?
        /// The Availability Zone for the instance.
        public let availabilityZone: String?
        /// The DNS name servers supported for the replication instance to access your on-premise source or target database.
        public let dnsNameServers: String?
        /// The engine version number of the replication instance. If an engine version number is not specified when a replication instance is created, the default is the latest engine version available. When modifying a major engine version of an instance, also set AllowMajorVersionUpgrade to true.
        public let engineVersion: String?
        ///  The expiration date of the free replication instance that is part of the Free DMS program.
        public let freeUntil: Date?
        /// The time the replication instance was created.
        public let instanceCreateTime: Date?
        /// An KMS key identifier that is used to encrypt the data on the replication instance. If you don't specify a value for the KmsKeyId parameter, then DMS uses your default encryption key. KMS creates the default encryption key for your account. Your account has a different default encryption key for each Region.
        public let kmsKeyId: String?
        ///  Specifies whether the replication instance is a Multi-AZ deployment. You can't set the AvailabilityZone parameter if the Multi-AZ parameter is set to true.
        public let multiAZ: Bool?
        /// The pending modification values.
        public let pendingModifiedValues: ReplicationPendingModifiedValues?
        /// The maintenance window times for the replication instance. Any pending upgrades to the replication instance are performed during this time.
        public let preferredMaintenanceWindow: String?
        ///  Specifies the accessibility options for the replication instance. A value of true represents an instance with a public IP address. A value of false represents an instance with a private IP address. The default value is true.
        public let publiclyAccessible: Bool?
        /// The Amazon Resource Name (ARN) of the replication instance.
        public let replicationInstanceArn: String?
        /// The compute and memory capacity of the replication instance as defined for the specified replication instance class. It is a required parameter, although a default value is pre-selected in the DMS console. For more information on the settings and capacities for the available replication instance classes, see  Selecting the right DMS replication instance for your migration.
        public let replicationInstanceClass: String?
        /// The replication instance identifier is a required parameter. This parameter is stored as a lowercase string. Constraints:   Must contain 1-63 alphanumeric characters or hyphens.   First character must be a letter.   Cannot end with a hyphen or contain two consecutive hyphens.   Example: myrepinstance
        public let replicationInstanceIdentifier: String?
        /// One or more private IP addresses for the replication instance.
        public let replicationInstancePrivateIpAddresses: [String]?
        /// One or more public IP addresses for the replication instance.
        public let replicationInstancePublicIpAddresses: [String]?
        /// The status of the replication instance. The possible return values include:    "available"     "creating"     "deleted"     "deleting"     "failed"     "modifying"     "upgrading"     "rebooting"     "resetting-master-credentials"     "storage-full"     "incompatible-credentials"     "incompatible-network"     "maintenance"
        public let replicationInstanceStatus: String?
        /// The subnet group for the replication instance.
        public let replicationSubnetGroup: ReplicationSubnetGroup?
        /// The Availability Zone of the standby replication instance in a Multi-AZ deployment.
        public let secondaryAvailabilityZone: String?
        /// The VPC security group for the instance.
        public let vpcSecurityGroups: [VpcSecurityGroupMembership]?

        public init(allocatedStorage: Int? = nil, autoMinorVersionUpgrade: Bool? = nil, availabilityZone: String? = nil, dnsNameServers: String? = nil, engineVersion: String? = nil, freeUntil: Date? = nil, instanceCreateTime: Date? = nil, kmsKeyId: String? = nil, multiAZ: Bool? = nil, pendingModifiedValues: ReplicationPendingModifiedValues? = nil, preferredMaintenanceWindow: String? = nil, publiclyAccessible: Bool? = nil, replicationInstanceArn: String? = nil, replicationInstanceClass: String? = nil, replicationInstanceIdentifier: String? = nil, replicationInstancePrivateIpAddresses: [String]? = nil, replicationInstancePublicIpAddresses: [String]? = nil, replicationInstanceStatus: String? = nil, replicationSubnetGroup: ReplicationSubnetGroup? = nil, secondaryAvailabilityZone: String? = nil, vpcSecurityGroups: [VpcSecurityGroupMembership]? = nil) {
            self.allocatedStorage = allocatedStorage
            self.autoMinorVersionUpgrade = autoMinorVersionUpgrade
            self.availabilityZone = availabilityZone
            self.dnsNameServers = dnsNameServers
            self.engineVersion = engineVersion
            self.freeUntil = freeUntil
            self.instanceCreateTime = instanceCreateTime
            self.kmsKeyId = kmsKeyId
            self.multiAZ = multiAZ
            self.pendingModifiedValues = pendingModifiedValues
            self.preferredMaintenanceWindow = preferredMaintenanceWindow
            self.publiclyAccessible = publiclyAccessible
            self.replicationInstanceArn = replicationInstanceArn
            self.replicationInstanceClass = replicationInstanceClass
            self.replicationInstanceIdentifier = replicationInstanceIdentifier
            self.replicationInstancePrivateIpAddresses = replicationInstancePrivateIpAddresses
            self.replicationInstancePublicIpAddresses = replicationInstancePublicIpAddresses
            self.replicationInstanceStatus = replicationInstanceStatus
            self.replicationSubnetGroup = replicationSubnetGroup
            self.secondaryAvailabilityZone = secondaryAvailabilityZone
            self.vpcSecurityGroups = vpcSecurityGroups
        }

        private enum CodingKeys: String, CodingKey {
            case allocatedStorage = "AllocatedStorage"
            case autoMinorVersionUpgrade = "AutoMinorVersionUpgrade"
            case availabilityZone = "AvailabilityZone"
            case dnsNameServers = "DnsNameServers"
            case engineVersion = "EngineVersion"
            case freeUntil = "FreeUntil"
            case instanceCreateTime = "InstanceCreateTime"
            case kmsKeyId = "KmsKeyId"
            case multiAZ = "MultiAZ"
            case pendingModifiedValues = "PendingModifiedValues"
            case preferredMaintenanceWindow = "PreferredMaintenanceWindow"
            case publiclyAccessible = "PubliclyAccessible"
            case replicationInstanceArn = "ReplicationInstanceArn"
            case replicationInstanceClass = "ReplicationInstanceClass"
            case replicationInstanceIdentifier = "ReplicationInstanceIdentifier"
            case replicationInstancePrivateIpAddresses = "ReplicationInstancePrivateIpAddresses"
            case replicationInstancePublicIpAddresses = "ReplicationInstancePublicIpAddresses"
            case replicationInstanceStatus = "ReplicationInstanceStatus"
            case replicationSubnetGroup = "ReplicationSubnetGroup"
            case secondaryAvailabilityZone = "SecondaryAvailabilityZone"
            case vpcSecurityGroups = "VpcSecurityGroups"
        }
    }

    public struct ReplicationInstanceTaskLog: AWSDecodableShape {
        /// The size, in bytes, of the replication task log.
        public let replicationInstanceTaskLogSize: Int64?
        /// The Amazon Resource Name (ARN) of the replication task.
        public let replicationTaskArn: String?
        /// The name of the replication task.
        public let replicationTaskName: String?

        public init(replicationInstanceTaskLogSize: Int64? = nil, replicationTaskArn: String? = nil, replicationTaskName: String? = nil) {
            self.replicationInstanceTaskLogSize = replicationInstanceTaskLogSize
            self.replicationTaskArn = replicationTaskArn
            self.replicationTaskName = replicationTaskName
        }

        private enum CodingKeys: String, CodingKey {
            case replicationInstanceTaskLogSize = "ReplicationInstanceTaskLogSize"
            case replicationTaskArn = "ReplicationTaskArn"
            case replicationTaskName = "ReplicationTaskName"
        }
    }

    public struct ReplicationPendingModifiedValues: AWSDecodableShape {
        /// The amount of storage (in gigabytes) that is allocated for the replication instance.
        public let allocatedStorage: Int?
        /// The engine version number of the replication instance.
        public let engineVersion: String?
        ///  Specifies whether the replication instance is a Multi-AZ deployment. You can't set the AvailabilityZone parameter if the Multi-AZ parameter is set to true.
        public let multiAZ: Bool?
        /// The compute and memory capacity of the replication instance as defined for the specified replication instance class. For more information on the settings and capacities for the available replication instance classes, see  Selecting the right DMS replication instance for your migration.
        public let replicationInstanceClass: String?

        public init(allocatedStorage: Int? = nil, engineVersion: String? = nil, multiAZ: Bool? = nil, replicationInstanceClass: String? = nil) {
            self.allocatedStorage = allocatedStorage
            self.engineVersion = engineVersion
            self.multiAZ = multiAZ
            self.replicationInstanceClass = replicationInstanceClass
        }

        private enum CodingKeys: String, CodingKey {
            case allocatedStorage = "AllocatedStorage"
            case engineVersion = "EngineVersion"
            case multiAZ = "MultiAZ"
            case replicationInstanceClass = "ReplicationInstanceClass"
        }
    }

    public struct ReplicationSubnetGroup: AWSDecodableShape {
        /// A description for the replication subnet group.
        public let replicationSubnetGroupDescription: String?
        /// The identifier of the replication instance subnet group.
        public let replicationSubnetGroupIdentifier: String?
        /// The status of the subnet group.
        public let subnetGroupStatus: String?
        /// The subnets that are in the subnet group.
        public let subnets: [Subnet]?
        /// The ID of the VPC.
        public let vpcId: String?

        public init(replicationSubnetGroupDescription: String? = nil, replicationSubnetGroupIdentifier: String? = nil, subnetGroupStatus: String? = nil, subnets: [Subnet]? = nil, vpcId: String? = nil) {
            self.replicationSubnetGroupDescription = replicationSubnetGroupDescription
            self.replicationSubnetGroupIdentifier = replicationSubnetGroupIdentifier
            self.subnetGroupStatus = subnetGroupStatus
            self.subnets = subnets
            self.vpcId = vpcId
        }

        private enum CodingKeys: String, CodingKey {
            case replicationSubnetGroupDescription = "ReplicationSubnetGroupDescription"
            case replicationSubnetGroupIdentifier = "ReplicationSubnetGroupIdentifier"
            case subnetGroupStatus = "SubnetGroupStatus"
            case subnets = "Subnets"
            case vpcId = "VpcId"
        }
    }

    public struct ReplicationTask: AWSDecodableShape {
        /// Indicates when you want a change data capture (CDC) operation to start. Use either CdcStartPosition or CdcStartTime to specify when you want the CDC operation to start. Specifying both values results in an error. The value can be in date, checkpoint, or LSN/SCN format. Date Example: --cdc-start-position “2018-03-08T12:12:12” Checkpoint Example: --cdc-start-position "checkpoint:V1#27#mysql-bin-changelog.157832:1975:-1:2002:677883278264080:mysql-bin-changelog.157832:1876#0#0#*#0#93" LSN Example: --cdc-start-position “mysql-bin-changelog.000024:373”
        public let cdcStartPosition: String?
        /// Indicates when you want a change data capture (CDC) operation to stop. The value can be either server time or commit time. Server time example: --cdc-stop-position “server_time:2018-02-09T12:12:12” Commit time example: --cdc-stop-position “commit_time: 2018-02-09T12:12:12 “
        public let cdcStopPosition: String?
        /// The last error (failure) message generated for the replication task.
        public let lastFailureMessage: String?
        /// The type of migration.
        public let migrationType: MigrationTypeValue?
        /// Indicates the last checkpoint that occurred during a change data capture (CDC) operation. You can provide this value to the CdcStartPosition parameter to start a CDC operation that begins at that checkpoint.
        public let recoveryCheckpoint: String?
        /// The ARN of the replication instance.
        public let replicationInstanceArn: String?
        /// The Amazon Resource Name (ARN) of the replication task.
        public let replicationTaskArn: String?
        /// The date the replication task was created.
        public let replicationTaskCreationDate: Date?
        /// The user-assigned replication task identifier or name. Constraints:   Must contain 1-255 alphanumeric characters or hyphens.   First character must be a letter.   Cannot end with a hyphen or contain two consecutive hyphens.
        public let replicationTaskIdentifier: String?
        /// The settings for the replication task.
        public let replicationTaskSettings: String?
        /// The date the replication task is scheduled to start.
        public let replicationTaskStartDate: Date?
        /// The statistics for the task, including elapsed time, tables loaded, and table errors.
        public let replicationTaskStats: ReplicationTaskStats?
        /// The Amazon Resource Name (ARN) that uniquely identifies the endpoint.
        public let sourceEndpointArn: String?
        /// The status of the replication task. This response parameter can return one of the following values:    "moving" – The task is being moved in response to running the  MoveReplicationTask  operation.    "creating" – The task is being created in response to running the  CreateReplicationTask  operation.    "deleting" – The task is being deleted in response to running the  DeleteReplicationTask  operation.    "failed" – The task failed to successfully complete the database migration in response to running the  StartReplicationTask  operation.    "failed-move" – The task failed to move in response to running the  MoveReplicationTask  operation.    "modifying" – The task definition is being modified in response to running the  ModifyReplicationTask  operation.    "ready" – The task is in a ready state where it can respond to other task operations, such as  StartReplicationTask  or  DeleteReplicationTask .     "running" – The task is performing a database migration in response to running the  StartReplicationTask  operation.    "starting" – The task is preparing to perform a database migration in response to running the  StartReplicationTask  operation.    "stopped" – The task has stopped in response to running the  StopReplicationTask  operation.    "stopping" – The task is preparing to stop in response to running the  StopReplicationTask  operation.    "testing" – The database migration specified for this task is being tested in response to running either the  StartReplicationTaskAssessmentRun  or the  StartReplicationTaskAssessment  operation.    StartReplicationTaskAssessmentRun  is an improved premigration task assessment operation. The  StartReplicationTaskAssessment  operation assesses data type compatibility only between the source and target database of a given migration task. In contrast,  StartReplicationTaskAssessmentRun  enables you to specify a variety of premigration task assessments in addition to data type compatibility. These assessments include ones for the validity of primary key definitions and likely issues with database migration performance, among others.
        public let status: String?
        /// The reason the replication task was stopped. This response parameter can return one of the following values:    "STOP_REASON_FULL_LOAD_COMPLETED" – Full-load migration completed.    "STOP_REASON_CACHED_CHANGES_APPLIED" – Change data capture (CDC) load completed.    "STOP_REASON_CACHED_CHANGES_NOT_APPLIED" – In a full-load and CDC migration, the full load stopped as specified before starting the CDC migration.    "STOP_REASON_SERVER_TIME" – The migration stopped at the specified server time.
        public let stopReason: String?
        /// Table mappings specified in the task.
        public let tableMappings: String?
        /// The ARN that uniquely identifies the endpoint.
        public let targetEndpointArn: String?
        /// The ARN of the replication instance to which this task is moved in response to running the  MoveReplicationTask  operation. Otherwise, this response parameter isn't a member of the ReplicationTask object.
        public let targetReplicationInstanceArn: String?
        /// Supplemental information that the task requires to migrate the data for certain source and target endpoints. For more information, see Specifying Supplemental Data for Task Settings in the Database Migration Service User Guide.
        public let taskData: String?

        public init(cdcStartPosition: String? = nil, cdcStopPosition: String? = nil, lastFailureMessage: String? = nil, migrationType: MigrationTypeValue? = nil, recoveryCheckpoint: String? = nil, replicationInstanceArn: String? = nil, replicationTaskArn: String? = nil, replicationTaskCreationDate: Date? = nil, replicationTaskIdentifier: String? = nil, replicationTaskSettings: String? = nil, replicationTaskStartDate: Date? = nil, replicationTaskStats: ReplicationTaskStats? = nil, sourceEndpointArn: String? = nil, status: String? = nil, stopReason: String? = nil, tableMappings: String? = nil, targetEndpointArn: String? = nil, targetReplicationInstanceArn: String? = nil, taskData: String? = nil) {
            self.cdcStartPosition = cdcStartPosition
            self.cdcStopPosition = cdcStopPosition
            self.lastFailureMessage = lastFailureMessage
            self.migrationType = migrationType
            self.recoveryCheckpoint = recoveryCheckpoint
            self.replicationInstanceArn = replicationInstanceArn
            self.replicationTaskArn = replicationTaskArn
            self.replicationTaskCreationDate = replicationTaskCreationDate
            self.replicationTaskIdentifier = replicationTaskIdentifier
            self.replicationTaskSettings = replicationTaskSettings
            self.replicationTaskStartDate = replicationTaskStartDate
            self.replicationTaskStats = replicationTaskStats
            self.sourceEndpointArn = sourceEndpointArn
            self.status = status
            self.stopReason = stopReason
            self.tableMappings = tableMappings
            self.targetEndpointArn = targetEndpointArn
            self.targetReplicationInstanceArn = targetReplicationInstanceArn
            self.taskData = taskData
        }

        private enum CodingKeys: String, CodingKey {
            case cdcStartPosition = "CdcStartPosition"
            case cdcStopPosition = "CdcStopPosition"
            case lastFailureMessage = "LastFailureMessage"
            case migrationType = "MigrationType"
            case recoveryCheckpoint = "RecoveryCheckpoint"
            case replicationInstanceArn = "ReplicationInstanceArn"
            case replicationTaskArn = "ReplicationTaskArn"
            case replicationTaskCreationDate = "ReplicationTaskCreationDate"
            case replicationTaskIdentifier = "ReplicationTaskIdentifier"
            case replicationTaskSettings = "ReplicationTaskSettings"
            case replicationTaskStartDate = "ReplicationTaskStartDate"
            case replicationTaskStats = "ReplicationTaskStats"
            case sourceEndpointArn = "SourceEndpointArn"
            case status = "Status"
            case stopReason = "StopReason"
            case tableMappings = "TableMappings"
            case targetEndpointArn = "TargetEndpointArn"
            case targetReplicationInstanceArn = "TargetReplicationInstanceArn"
            case taskData = "TaskData"
        }
    }

    public struct ReplicationTaskAssessmentResult: AWSDecodableShape {
        ///  The task assessment results in JSON format.  The response object only contains this field if you provide DescribeReplicationTaskAssessmentResultsMessage$ReplicationTaskArn in the request.
        public let assessmentResults: String?
        ///  The file containing the results of the task assessment.
        public let assessmentResultsFile: String?
        ///  The status of the task assessment.
        public let assessmentStatus: String?
        /// The Amazon Resource Name (ARN) of the replication task.
        public let replicationTaskArn: String?
        ///  The replication task identifier of the task on which the task assessment was run.
        public let replicationTaskIdentifier: String?
        /// The date the task assessment was completed.
        public let replicationTaskLastAssessmentDate: Date?
        ///  The URL of the S3 object containing the task assessment results.  The response object only contains this field if you provide DescribeReplicationTaskAssessmentResultsMessage$ReplicationTaskArn in the request.
        public let s3ObjectUrl: String?

        public init(assessmentResults: String? = nil, assessmentResultsFile: String? = nil, assessmentStatus: String? = nil, replicationTaskArn: String? = nil, replicationTaskIdentifier: String? = nil, replicationTaskLastAssessmentDate: Date? = nil, s3ObjectUrl: String? = nil) {
            self.assessmentResults = assessmentResults
            self.assessmentResultsFile = assessmentResultsFile
            self.assessmentStatus = assessmentStatus
            self.replicationTaskArn = replicationTaskArn
            self.replicationTaskIdentifier = replicationTaskIdentifier
            self.replicationTaskLastAssessmentDate = replicationTaskLastAssessmentDate
            self.s3ObjectUrl = s3ObjectUrl
        }

        private enum CodingKeys: String, CodingKey {
            case assessmentResults = "AssessmentResults"
            case assessmentResultsFile = "AssessmentResultsFile"
            case assessmentStatus = "AssessmentStatus"
            case replicationTaskArn = "ReplicationTaskArn"
            case replicationTaskIdentifier = "ReplicationTaskIdentifier"
            case replicationTaskLastAssessmentDate = "ReplicationTaskLastAssessmentDate"
            case s3ObjectUrl = "S3ObjectUrl"
        }
    }

    public struct ReplicationTaskAssessmentRun: AWSDecodableShape {
        /// Indication of the completion progress for the individual assessments specified to run.
        public let assessmentProgress: ReplicationTaskAssessmentRunProgress?
        /// Unique name of the assessment run.
        public let assessmentRunName: String?
        /// Last message generated by an individual assessment failure.
        public let lastFailureMessage: String?
        /// ARN of the migration task associated with this premigration assessment run.
        public let replicationTaskArn: String?
        /// Amazon Resource Name (ARN) of this assessment run.
        public let replicationTaskAssessmentRunArn: String?
        /// Date on which the assessment run was created using the StartReplicationTaskAssessmentRun operation.
        public let replicationTaskAssessmentRunCreationDate: Date?
        /// Encryption mode used to encrypt the assessment run results.
        public let resultEncryptionMode: String?
        /// ARN of the KMS encryption key used to encrypt the assessment run results.
        public let resultKmsKeyArn: String?
        /// Amazon S3 bucket where DMS stores the results of this assessment run.
        public let resultLocationBucket: String?
        /// Folder in an Amazon S3 bucket where DMS stores the results of this assessment run.
        public let resultLocationFolder: String?
        /// ARN of the service role used to start the assessment run using the StartReplicationTaskAssessmentRun operation. The role must allow the iam:PassRole action.
        public let serviceAccessRoleArn: String?
        /// Assessment run status.  This status can have one of the following values:    "cancelling" – The assessment run was canceled by the CancelReplicationTaskAssessmentRun operation.    "deleting" – The assessment run was deleted by the DeleteReplicationTaskAssessmentRun operation.    "failed" – At least one individual assessment completed with a failed status.    "error-provisioning" – An internal error occurred while resources were provisioned (during provisioning status).    "error-executing" – An internal error occurred while individual assessments ran (during running status).    "invalid state" – The assessment run is in an unknown state.    "passed" – All individual assessments have completed, and none has a failed status.    "provisioning" – Resources required to run individual assessments are being provisioned.    "running" – Individual assessments are being run.    "starting" – The assessment run is starting, but resources are not yet being provisioned for individual assessments.
        public let status: String?

        public init(assessmentProgress: ReplicationTaskAssessmentRunProgress? = nil, assessmentRunName: String? = nil, lastFailureMessage: String? = nil, replicationTaskArn: String? = nil, replicationTaskAssessmentRunArn: String? = nil, replicationTaskAssessmentRunCreationDate: Date? = nil, resultEncryptionMode: String? = nil, resultKmsKeyArn: String? = nil, resultLocationBucket: String? = nil, resultLocationFolder: String? = nil, serviceAccessRoleArn: String? = nil, status: String? = nil) {
            self.assessmentProgress = assessmentProgress
            self.assessmentRunName = assessmentRunName
            self.lastFailureMessage = lastFailureMessage
            self.replicationTaskArn = replicationTaskArn
            self.replicationTaskAssessmentRunArn = replicationTaskAssessmentRunArn
            self.replicationTaskAssessmentRunCreationDate = replicationTaskAssessmentRunCreationDate
            self.resultEncryptionMode = resultEncryptionMode
            self.resultKmsKeyArn = resultKmsKeyArn
            self.resultLocationBucket = resultLocationBucket
            self.resultLocationFolder = resultLocationFolder
            self.serviceAccessRoleArn = serviceAccessRoleArn
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case assessmentProgress = "AssessmentProgress"
            case assessmentRunName = "AssessmentRunName"
            case lastFailureMessage = "LastFailureMessage"
            case replicationTaskArn = "ReplicationTaskArn"
            case replicationTaskAssessmentRunArn = "ReplicationTaskAssessmentRunArn"
            case replicationTaskAssessmentRunCreationDate = "ReplicationTaskAssessmentRunCreationDate"
            case resultEncryptionMode = "ResultEncryptionMode"
            case resultKmsKeyArn = "ResultKmsKeyArn"
            case resultLocationBucket = "ResultLocationBucket"
            case resultLocationFolder = "ResultLocationFolder"
            case serviceAccessRoleArn = "ServiceAccessRoleArn"
            case status = "Status"
        }
    }

    public struct ReplicationTaskAssessmentRunProgress: AWSDecodableShape {
        /// The number of individual assessments that have completed, successfully or not.
        public let individualAssessmentCompletedCount: Int?
        /// The number of individual assessments that are specified to run.
        public let individualAssessmentCount: Int?

        public init(individualAssessmentCompletedCount: Int? = nil, individualAssessmentCount: Int? = nil) {
            self.individualAssessmentCompletedCount = individualAssessmentCompletedCount
            self.individualAssessmentCount = individualAssessmentCount
        }

        private enum CodingKeys: String, CodingKey {
            case individualAssessmentCompletedCount = "IndividualAssessmentCompletedCount"
            case individualAssessmentCount = "IndividualAssessmentCount"
        }
    }

    public struct ReplicationTaskIndividualAssessment: AWSDecodableShape {
        /// Name of this individual assessment.
        public let individualAssessmentName: String?
        /// ARN of the premigration assessment run that is created to run this individual assessment.
        public let replicationTaskAssessmentRunArn: String?
        /// Amazon Resource Name (ARN) of this individual assessment.
        public let replicationTaskIndividualAssessmentArn: String?
        /// Date when this individual assessment was started as part of running the StartReplicationTaskAssessmentRun operation.
        public let replicationTaskIndividualAssessmentStartDate: Date?
        /// Individual assessment status. This status can have one of the following values:    "cancelled"     "error"     "failed"     "passed"     "pending"     "running"
        public let status: String?

        public init(individualAssessmentName: String? = nil, replicationTaskAssessmentRunArn: String? = nil, replicationTaskIndividualAssessmentArn: String? = nil, replicationTaskIndividualAssessmentStartDate: Date? = nil, status: String? = nil) {
            self.individualAssessmentName = individualAssessmentName
            self.replicationTaskAssessmentRunArn = replicationTaskAssessmentRunArn
            self.replicationTaskIndividualAssessmentArn = replicationTaskIndividualAssessmentArn
            self.replicationTaskIndividualAssessmentStartDate = replicationTaskIndividualAssessmentStartDate
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case individualAssessmentName = "IndividualAssessmentName"
            case replicationTaskAssessmentRunArn = "ReplicationTaskAssessmentRunArn"
            case replicationTaskIndividualAssessmentArn = "ReplicationTaskIndividualAssessmentArn"
            case replicationTaskIndividualAssessmentStartDate = "ReplicationTaskIndividualAssessmentStartDate"
            case status = "Status"
        }
    }

    public struct ReplicationTaskStats: AWSDecodableShape {
        /// The elapsed time of the task, in milliseconds.
        public let elapsedTimeMillis: Int64?
        /// The date the replication task was started either with a fresh start or a target reload.
        public let freshStartDate: Date?
        /// The date the replication task full load was completed.
        public let fullLoadFinishDate: Date?
        /// The percent complete for the full load migration task.
        public let fullLoadProgressPercent: Int?
        /// The date the replication task full load was started.
        public let fullLoadStartDate: Date?
        /// The date the replication task was started either with a fresh start or a resume. For more information, see StartReplicationTaskType.
        public let startDate: Date?
        /// The date the replication task was stopped.
        public let stopDate: Date?
        /// The number of errors that have occurred during this task.
        public let tablesErrored: Int?
        /// The number of tables loaded for this task.
        public let tablesLoaded: Int?
        /// The number of tables currently loading for this task.
        public let tablesLoading: Int?
        /// The number of tables queued for this task.
        public let tablesQueued: Int?

        public init(elapsedTimeMillis: Int64? = nil, freshStartDate: Date? = nil, fullLoadFinishDate: Date? = nil, fullLoadProgressPercent: Int? = nil, fullLoadStartDate: Date? = nil, startDate: Date? = nil, stopDate: Date? = nil, tablesErrored: Int? = nil, tablesLoaded: Int? = nil, tablesLoading: Int? = nil, tablesQueued: Int? = nil) {
            self.elapsedTimeMillis = elapsedTimeMillis
            self.freshStartDate = freshStartDate
            self.fullLoadFinishDate = fullLoadFinishDate
            self.fullLoadProgressPercent = fullLoadProgressPercent
            self.fullLoadStartDate = fullLoadStartDate
            self.startDate = startDate
            self.stopDate = stopDate
            self.tablesErrored = tablesErrored
            self.tablesLoaded = tablesLoaded
            self.tablesLoading = tablesLoading
            self.tablesQueued = tablesQueued
        }

        private enum CodingKeys: String, CodingKey {
            case elapsedTimeMillis = "ElapsedTimeMillis"
            case freshStartDate = "FreshStartDate"
            case fullLoadFinishDate = "FullLoadFinishDate"
            case fullLoadProgressPercent = "FullLoadProgressPercent"
            case fullLoadStartDate = "FullLoadStartDate"
            case startDate = "StartDate"
            case stopDate = "StopDate"
            case tablesErrored = "TablesErrored"
            case tablesLoaded = "TablesLoaded"
            case tablesLoading = "TablesLoading"
            case tablesQueued = "TablesQueued"
        }
    }

    public struct ResourcePendingMaintenanceActions: AWSDecodableShape {
        /// Detailed information about the pending maintenance action.
        public let pendingMaintenanceActionDetails: [PendingMaintenanceAction]?
        /// The Amazon Resource Name (ARN) of the DMS resource that the pending maintenance action applies to. For information about creating an ARN, see  Constructing an Amazon Resource Name (ARN) for DMS in the DMS documentation.
        public let resourceIdentifier: String?

        public init(pendingMaintenanceActionDetails: [PendingMaintenanceAction]? = nil, resourceIdentifier: String? = nil) {
            self.pendingMaintenanceActionDetails = pendingMaintenanceActionDetails
            self.resourceIdentifier = resourceIdentifier
        }

        private enum CodingKeys: String, CodingKey {
            case pendingMaintenanceActionDetails = "PendingMaintenanceActionDetails"
            case resourceIdentifier = "ResourceIdentifier"
        }
    }

    public struct S3Settings: AWSEncodableShape & AWSDecodableShape {
        ///  An optional parameter to set a folder name in the S3 bucket. If provided, tables are created in the path  bucketFolder/schema_name/table_name/. If this parameter isn't specified, then the path used is  schema_name/table_name/.
        public let bucketFolder: String?
        ///  The name of the S3 bucket.
        public let bucketName: String?
        /// A value that enables a change data capture (CDC) load to write INSERT and UPDATE operations to .csv or .parquet (columnar storage) output files. The default setting is false, but when CdcInsertsAndUpdates is set to true or y, only INSERTs and UPDATEs from the source database are migrated to the .csv or .parquet file.  For .csv file format only, how these INSERTs and UPDATEs are recorded depends on the value of the IncludeOpForFullLoad parameter. If IncludeOpForFullLoad is set to true, the first field of every CDC record is set to either I or U to indicate INSERT and UPDATE operations at the source. But if IncludeOpForFullLoad is set to false, CDC records are written without an indication of INSERT or UPDATE operations at the source. For more information about how these settings work together, see Indicating Source DB Operations in Migrated S3 Data in the Database Migration Service User Guide..  DMS supports the use of the CdcInsertsAndUpdates parameter in versions 3.3.1 and later.  CdcInsertsOnly and CdcInsertsAndUpdates can't both be set to true for the same endpoint. Set either CdcInsertsOnly or CdcInsertsAndUpdates to true for the same endpoint, but not both.
        public let cdcInsertsAndUpdates: Bool?
        /// A value that enables a change data capture (CDC) load to write only INSERT operations to .csv or columnar storage (.parquet) output files. By default (the false setting), the first field in a .csv or .parquet record contains the letter I (INSERT), U (UPDATE), or D (DELETE). These values indicate whether the row was inserted, updated, or deleted at the source database for a CDC load to the target. If CdcInsertsOnly is set to true or y, only INSERTs from the source database are migrated to the .csv or .parquet file. For .csv format only, how these INSERTs are recorded depends on the value of IncludeOpForFullLoad. If IncludeOpForFullLoad is set to true, the first field of every CDC record is set to I to indicate the INSERT operation at the source. If IncludeOpForFullLoad is set to false, every CDC record is written without a first field to indicate the INSERT operation at the source. For more information about how these settings work together, see Indicating Source DB Operations in Migrated S3 Data in the Database Migration Service User Guide..  DMS supports the interaction described preceding between the CdcInsertsOnly and IncludeOpForFullLoad parameters in versions 3.1.4 and later.   CdcInsertsOnly and CdcInsertsAndUpdates can't both be set to true for the same endpoint. Set either CdcInsertsOnly or CdcInsertsAndUpdates to true for the same endpoint, but not both.
        public let cdcInsertsOnly: Bool?
        /// Specifies the folder path of CDC files. For an S3 source, this setting is required if a task captures change data; otherwise, it's optional. If CdcPath is set, DMS reads CDC files from this path and replicates the data changes to the target endpoint. For an S3 target if you set  PreserveTransactions  to true, DMS verifies that you have set this parameter to a folder path on your S3 target where DMS can save the transaction order for the CDC load. DMS creates this CDC folder path in either your S3 target working directory or the S3 target location specified by  BucketFolder  and  BucketName . For example, if you specify CdcPath as MyChangedData, and you specify BucketName as MyTargetBucket but do not specify BucketFolder, DMS creates the CDC folder path following: MyTargetBucket/MyChangedData. If you specify the same CdcPath, and you specify BucketName as MyTargetBucket and BucketFolder as MyTargetData, DMS creates the CDC folder path following: MyTargetBucket/MyTargetData/MyChangedData. For more information on CDC including transaction order on an S3 target, see Capturing data changes (CDC) including transaction order on the S3 target.  This setting is supported in DMS versions 3.4.2 and later.
        public let cdcPath: String?
        /// An optional parameter to use GZIP to compress the target files. Set to GZIP to compress the target files. Either set this parameter to NONE (the default) or don't use it to leave the files uncompressed. This parameter applies to both .csv and .parquet file formats.
        public let compressionType: CompressionTypeValue?
        ///  The delimiter used to separate columns in the .csv file for both source and target. The default is a comma.
        public let csvDelimiter: String?
        /// This setting only applies if your Amazon S3 output files during a change data capture (CDC) load are written in .csv format. If  UseCsvNoSupValue  is set to true, specify a string value that you want DMS to use for all columns not included in the supplemental log. If you do not specify a string value, DMS uses the null value for these columns regardless of the UseCsvNoSupValue setting.  This setting is supported in DMS versions 3.4.1 and later.
        public let csvNoSupValue: String?
        ///  The delimiter used to separate rows in the .csv file for both source and target. The default is a carriage return (\n).
        public let csvRowDelimiter: String?
        /// The format of the data that you want to use for output. You can choose one of the following:     csv : This is a row-based file format with comma-separated values (.csv).     parquet : Apache Parquet (.parquet) is a columnar storage file format that features efficient compression and provides faster query response.
        public let dataFormat: DataFormatValue?
        /// The size of one data page in bytes. This parameter defaults to 1024 * 1024 bytes (1 MiB). This number is used for .parquet file format only.
        public let dataPageSize: Int?
        /// Specifies a date separating delimiter to use during folder partitioning. The default value is SLASH. Use this parameter when DatePartitionedEnabled is set to true.
        public let datePartitionDelimiter: DatePartitionDelimiterValue?
        /// When set to true, this parameter partitions S3 bucket folders based on transaction commit dates. The default value is false. For more information about date-based folder partitioning, see Using date-based folder partitioning.
        public let datePartitionEnabled: Bool?
        /// Identifies the sequence of the date format to use during folder partitioning. The default value is YYYYMMDD. Use this parameter when DatePartitionedEnabled is set to true.
        public let datePartitionSequence: DatePartitionSequenceValue?
        /// The maximum size of an encoded dictionary page of a column. If the dictionary page exceeds this, this column is stored using an encoding type of PLAIN. This parameter defaults to 1024 * 1024 bytes (1 MiB), the maximum size of a dictionary page before it reverts to PLAIN encoding. This size is used for .parquet file format only.
        public let dictPageSizeLimit: Int?
        /// A value that enables statistics for Parquet pages and row groups. Choose true to enable statistics, false to disable. Statistics include NULL, DISTINCT, MAX, and MIN values. This parameter defaults to true. This value is used for .parquet file format only.
        public let enableStatistics: Bool?
        /// The type of encoding you are using:     RLE_DICTIONARY uses a combination of bit-packing and run-length encoding to store repeated values more efficiently. This is the default.    PLAIN doesn't use encoding at all. Values are stored as they are.    PLAIN_DICTIONARY builds a dictionary of the values encountered in a given column. The dictionary is stored in a dictionary page for each column chunk.
        public let encodingType: EncodingTypeValue?
        /// The type of server-side encryption that you want to use for your data. This encryption type is part of the endpoint settings or the extra connections attributes for Amazon S3. You can choose either SSE_S3 (the default) or SSE_KMS.   For the ModifyEndpoint operation, you can change the existing value of the EncryptionMode parameter from SSE_KMS to SSE_S3. But you can’t change the existing value from SSE_S3 to SSE_KMS.  To use SSE_S3, you need an Identity and Access Management (IAM) role with permission to allow "arn:aws:s3:::dms-*" to use the following actions:    s3:CreateBucket     s3:ListBucket     s3:DeleteBucket     s3:GetBucketLocation     s3:GetObject     s3:PutObject     s3:DeleteObject     s3:GetObjectVersion     s3:GetBucketPolicy     s3:PutBucketPolicy     s3:DeleteBucketPolicy
        public let encryptionMode: EncryptionModeValue?
        ///  Specifies how tables are defined in the S3 source files only.
        public let externalTableDefinition: String?
        /// A value that enables a full load to write INSERT operations to the comma-separated value (.csv) output files only to indicate how the rows were added to the source database.  DMS supports the IncludeOpForFullLoad parameter in versions 3.1.4 and later.  For full load, records can only be inserted. By default (the false setting), no information is recorded in these output files for a full load to indicate that the rows were inserted at the source database. If IncludeOpForFullLoad is set to true or y, the INSERT is recorded as an I annotation in the first field of the .csv file. This allows the format of your target records from a full load to be consistent with the target records from a CDC load.  This setting works together with the CdcInsertsOnly and the CdcInsertsAndUpdates parameters for output to .csv files only. For more information about how these settings work together, see Indicating Source DB Operations in Migrated S3 Data in the Database Migration Service User Guide..
        public let includeOpForFullLoad: Bool?
        /// A value that specifies the precision of any TIMESTAMP column values that are written to an Amazon S3 object file in .parquet format.  DMS supports the ParquetTimestampInMillisecond parameter in versions 3.1.4 and later.  When ParquetTimestampInMillisecond is set to true or y, DMS writes all TIMESTAMP columns in a .parquet formatted file with millisecond precision. Otherwise, DMS writes them with microsecond precision. Currently, Amazon Athena and Glue can handle only millisecond precision for TIMESTAMP values. Set this parameter to true for S3 endpoint object files that are .parquet formatted only if you plan to query or process the data with Athena or Glue.  DMS writes any TIMESTAMP column values written to an S3 file in .csv format with microsecond precision. Setting ParquetTimestampInMillisecond has no effect on the string format of the timestamp column value that is inserted by setting the TimestampColumnName parameter.
        public let parquetTimestampInMillisecond: Bool?
        /// The version of the Apache Parquet format that you want to use: parquet_1_0 (the default) or parquet_2_0.
        public let parquetVersion: ParquetVersionValue?
        /// If set to true, DMS saves the transaction order for a change data capture (CDC) load on the Amazon S3 target specified by  CdcPath . For more information, see Capturing data changes (CDC) including transaction order on the S3 target.  This setting is supported in DMS versions 3.4.2 and later.
        public let preserveTransactions: Bool?
        /// The number of rows in a row group. A smaller row group size provides faster reads. But as the number of row groups grows, the slower writes become. This parameter defaults to 10,000 rows. This number is used for .parquet file format only.  If you choose a value larger than the maximum, RowGroupLength is set to the max row group length in bytes (64 * 1024 * 1024).
        public let rowGroupLength: Int?
        /// If you are using SSE_KMS for the EncryptionMode, provide the KMS key ID. The key that you use needs an attached policy that enables Identity and Access Management (IAM) user permissions and allows use of the key. Here is a CLI example: aws dms create-endpoint --endpoint-identifier value --endpoint-type target --engine-name s3 --s3-settings ServiceAccessRoleArn=value,BucketFolder=value,BucketName=value,EncryptionMode=SSE_KMS,ServerSideEncryptionKmsKeyId=value
        public let serverSideEncryptionKmsKeyId: String?
        ///  The Amazon Resource Name (ARN) used by the service to access the IAM role. The role must allow the iam:PassRole action. It is a required parameter that enables DMS to write and read objects from an S3 bucket.
        public let serviceAccessRoleArn: String?
        /// A value that when nonblank causes DMS to add a column with timestamp information to the endpoint data for an Amazon S3 target.  DMS supports the TimestampColumnName parameter in versions 3.1.4 and later.  DMS includes an additional STRING column in the .csv or .parquet object files of your migrated data when you set TimestampColumnName to a nonblank value. For a full load, each row of this timestamp column contains a timestamp for when the data was transferred from the source to the target by DMS.  For a change data capture (CDC) load, each row of the timestamp column contains the timestamp for the commit of that row in the source database. The string format for this timestamp column value is yyyy-MM-dd HH:mm:ss.SSSSSS. By default, the precision of this value is in microseconds. For a CDC load, the rounding of the precision depends on the commit timestamp supported by DMS for the source database. When the AddColumnName parameter is set to true, DMS also includes a name for the timestamp column that you set with TimestampColumnName.
        public let timestampColumnName: String?
        /// This setting applies if the S3 output files during a change data capture (CDC) load are written in .csv format. If set to true for columns not included in the supplemental log, DMS uses the value specified by  CsvNoSupValue . If not set or set to false, DMS uses the null value for these columns.  This setting is supported in DMS versions 3.4.1 and later.
        public let useCsvNoSupValue: Bool?

        public init(bucketFolder: String? = nil, bucketName: String? = nil, cdcInsertsAndUpdates: Bool? = nil, cdcInsertsOnly: Bool? = nil, cdcPath: String? = nil, compressionType: CompressionTypeValue? = nil, csvDelimiter: String? = nil, csvNoSupValue: String? = nil, csvRowDelimiter: String? = nil, dataFormat: DataFormatValue? = nil, dataPageSize: Int? = nil, datePartitionDelimiter: DatePartitionDelimiterValue? = nil, datePartitionEnabled: Bool? = nil, datePartitionSequence: DatePartitionSequenceValue? = nil, dictPageSizeLimit: Int? = nil, enableStatistics: Bool? = nil, encodingType: EncodingTypeValue? = nil, encryptionMode: EncryptionModeValue? = nil, externalTableDefinition: String? = nil, includeOpForFullLoad: Bool? = nil, parquetTimestampInMillisecond: Bool? = nil, parquetVersion: ParquetVersionValue? = nil, preserveTransactions: Bool? = nil, rowGroupLength: Int? = nil, serverSideEncryptionKmsKeyId: String? = nil, serviceAccessRoleArn: String? = nil, timestampColumnName: String? = nil, useCsvNoSupValue: Bool? = nil) {
            self.bucketFolder = bucketFolder
            self.bucketName = bucketName
            self.cdcInsertsAndUpdates = cdcInsertsAndUpdates
            self.cdcInsertsOnly = cdcInsertsOnly
            self.cdcPath = cdcPath
            self.compressionType = compressionType
            self.csvDelimiter = csvDelimiter
            self.csvNoSupValue = csvNoSupValue
            self.csvRowDelimiter = csvRowDelimiter
            self.dataFormat = dataFormat
            self.dataPageSize = dataPageSize
            self.datePartitionDelimiter = datePartitionDelimiter
            self.datePartitionEnabled = datePartitionEnabled
            self.datePartitionSequence = datePartitionSequence
            self.dictPageSizeLimit = dictPageSizeLimit
            self.enableStatistics = enableStatistics
            self.encodingType = encodingType
            self.encryptionMode = encryptionMode
            self.externalTableDefinition = externalTableDefinition
            self.includeOpForFullLoad = includeOpForFullLoad
            self.parquetTimestampInMillisecond = parquetTimestampInMillisecond
            self.parquetVersion = parquetVersion
            self.preserveTransactions = preserveTransactions
            self.rowGroupLength = rowGroupLength
            self.serverSideEncryptionKmsKeyId = serverSideEncryptionKmsKeyId
            self.serviceAccessRoleArn = serviceAccessRoleArn
            self.timestampColumnName = timestampColumnName
            self.useCsvNoSupValue = useCsvNoSupValue
        }

        private enum CodingKeys: String, CodingKey {
            case bucketFolder = "BucketFolder"
            case bucketName = "BucketName"
            case cdcInsertsAndUpdates = "CdcInsertsAndUpdates"
            case cdcInsertsOnly = "CdcInsertsOnly"
            case cdcPath = "CdcPath"
            case compressionType = "CompressionType"
            case csvDelimiter = "CsvDelimiter"
            case csvNoSupValue = "CsvNoSupValue"
            case csvRowDelimiter = "CsvRowDelimiter"
            case dataFormat = "DataFormat"
            case dataPageSize = "DataPageSize"
            case datePartitionDelimiter = "DatePartitionDelimiter"
            case datePartitionEnabled = "DatePartitionEnabled"
            case datePartitionSequence = "DatePartitionSequence"
            case dictPageSizeLimit = "DictPageSizeLimit"
            case enableStatistics = "EnableStatistics"
            case encodingType = "EncodingType"
            case encryptionMode = "EncryptionMode"
            case externalTableDefinition = "ExternalTableDefinition"
            case includeOpForFullLoad = "IncludeOpForFullLoad"
            case parquetTimestampInMillisecond = "ParquetTimestampInMillisecond"
            case parquetVersion = "ParquetVersion"
            case preserveTransactions = "PreserveTransactions"
            case rowGroupLength = "RowGroupLength"
            case serverSideEncryptionKmsKeyId = "ServerSideEncryptionKmsKeyId"
            case serviceAccessRoleArn = "ServiceAccessRoleArn"
            case timestampColumnName = "TimestampColumnName"
            case useCsvNoSupValue = "UseCsvNoSupValue"
        }
    }

    public struct StartReplicationTaskAssessmentMessage: AWSEncodableShape {
        ///  The Amazon Resource Name (ARN) of the replication task.
        public let replicationTaskArn: String

        public init(replicationTaskArn: String) {
            self.replicationTaskArn = replicationTaskArn
        }

        private enum CodingKeys: String, CodingKey {
            case replicationTaskArn = "ReplicationTaskArn"
        }
    }

    public struct StartReplicationTaskAssessmentResponse: AWSDecodableShape {
        ///  The assessed replication task.
        public let replicationTask: ReplicationTask?

        public init(replicationTask: ReplicationTask? = nil) {
            self.replicationTask = replicationTask
        }

        private enum CodingKeys: String, CodingKey {
            case replicationTask = "ReplicationTask"
        }
    }

    public struct StartReplicationTaskAssessmentRunMessage: AWSEncodableShape {
        /// Unique name to identify the assessment run.
        public let assessmentRunName: String
        /// Space-separated list of names for specific individual assessments that you want to exclude. These names come from the default list of individual assessments that DMS supports for the associated migration task. This task is specified by ReplicationTaskArn.  You can't set a value for Exclude if you also set a value for IncludeOnly in the API operation. To identify the names of the default individual assessments that DMS supports for the associated migration task, run the DescribeApplicableIndividualAssessments operation using its own ReplicationTaskArn request parameter.
        public let exclude: [String]?
        /// Space-separated list of names for specific individual assessments that you want to include. These names come from the default list of individual assessments that DMS supports for the associated migration task. This task is specified by ReplicationTaskArn.  You can't set a value for IncludeOnly if you also set a value for Exclude in the API operation.  To identify the names of the default individual assessments that DMS supports for the associated migration task, run the DescribeApplicableIndividualAssessments operation using its own ReplicationTaskArn request parameter.
        public let includeOnly: [String]?
        /// Amazon Resource Name (ARN) of the migration task associated with the premigration assessment run that you want to start.
        public let replicationTaskArn: String
        /// Encryption mode that you can specify to encrypt the results of this assessment run. If you don't specify this request parameter, DMS stores the assessment run results without encryption. You can specify one of the options following:    "SSE_S3" – The server-side encryption provided as a default by Amazon S3.    "SSE_KMS" – Key Management Service (KMS) encryption. This encryption can use either a custom KMS encryption key that you specify or the default KMS encryption key that DMS provides.
        public let resultEncryptionMode: String?
        /// ARN of a custom KMS encryption key that you specify when you set ResultEncryptionMode to "SSE_KMS".
        public let resultKmsKeyArn: String?
        /// Amazon S3 bucket where you want DMS to store the results of this assessment run.
        public let resultLocationBucket: String
        /// Folder within an Amazon S3 bucket where you want DMS to store the results of this assessment run.
        public let resultLocationFolder: String?
        /// ARN of the service role needed to start the assessment run. The role must allow the iam:PassRole action.
        public let serviceAccessRoleArn: String

        public init(assessmentRunName: String, exclude: [String]? = nil, includeOnly: [String]? = nil, replicationTaskArn: String, resultEncryptionMode: String? = nil, resultKmsKeyArn: String? = nil, resultLocationBucket: String, resultLocationFolder: String? = nil, serviceAccessRoleArn: String) {
            self.assessmentRunName = assessmentRunName
            self.exclude = exclude
            self.includeOnly = includeOnly
            self.replicationTaskArn = replicationTaskArn
            self.resultEncryptionMode = resultEncryptionMode
            self.resultKmsKeyArn = resultKmsKeyArn
            self.resultLocationBucket = resultLocationBucket
            self.resultLocationFolder = resultLocationFolder
            self.serviceAccessRoleArn = serviceAccessRoleArn
        }

        private enum CodingKeys: String, CodingKey {
            case assessmentRunName = "AssessmentRunName"
            case exclude = "Exclude"
            case includeOnly = "IncludeOnly"
            case replicationTaskArn = "ReplicationTaskArn"
            case resultEncryptionMode = "ResultEncryptionMode"
            case resultKmsKeyArn = "ResultKmsKeyArn"
            case resultLocationBucket = "ResultLocationBucket"
            case resultLocationFolder = "ResultLocationFolder"
            case serviceAccessRoleArn = "ServiceAccessRoleArn"
        }
    }

    public struct StartReplicationTaskAssessmentRunResponse: AWSDecodableShape {
        /// The premigration assessment run that was started.
        public let replicationTaskAssessmentRun: ReplicationTaskAssessmentRun?

        public init(replicationTaskAssessmentRun: ReplicationTaskAssessmentRun? = nil) {
            self.replicationTaskAssessmentRun = replicationTaskAssessmentRun
        }

        private enum CodingKeys: String, CodingKey {
            case replicationTaskAssessmentRun = "ReplicationTaskAssessmentRun"
        }
    }

    public struct StartReplicationTaskMessage: AWSEncodableShape {
        /// Indicates when you want a change data capture (CDC) operation to start. Use either CdcStartPosition or CdcStartTime to specify when you want a CDC operation to start. Specifying both values results in an error.  The value can be in date, checkpoint, or LSN/SCN format. Date Example: --cdc-start-position “2018-03-08T12:12:12” Checkpoint Example: --cdc-start-position "checkpoint:V1#27#mysql-bin-changelog.157832:1975:-1:2002:677883278264080:mysql-bin-changelog.157832:1876#0#0#*#0#93" LSN Example: --cdc-start-position “mysql-bin-changelog.000024:373”  When you use this task setting with a source PostgreSQL database, a logical replication slot should already be created and associated with the source endpoint. You can verify this by setting the slotName extra connection attribute to the name of this logical replication slot. For more information, see Extra Connection Attributes When Using PostgreSQL as a Source for DMS.
        public let cdcStartPosition: String?
        /// Indicates the start time for a change data capture (CDC) operation. Use either CdcStartTime or CdcStartPosition to specify when you want a CDC operation to start. Specifying both values results in an error. Timestamp Example: --cdc-start-time “2018-03-08T12:12:12”
        public let cdcStartTime: Date?
        /// Indicates when you want a change data capture (CDC) operation to stop. The value can be either server time or commit time. Server time example: --cdc-stop-position “server_time:2018-02-09T12:12:12” Commit time example: --cdc-stop-position “commit_time: 2018-02-09T12:12:12 “
        public let cdcStopPosition: String?
        /// The Amazon Resource Name (ARN) of the replication task to be started.
        public let replicationTaskArn: String
        /// A type of replication task.
        public let startReplicationTaskType: StartReplicationTaskTypeValue

        public init(cdcStartPosition: String? = nil, cdcStartTime: Date? = nil, cdcStopPosition: String? = nil, replicationTaskArn: String, startReplicationTaskType: StartReplicationTaskTypeValue) {
            self.cdcStartPosition = cdcStartPosition
            self.cdcStartTime = cdcStartTime
            self.cdcStopPosition = cdcStopPosition
            self.replicationTaskArn = replicationTaskArn
            self.startReplicationTaskType = startReplicationTaskType
        }

        private enum CodingKeys: String, CodingKey {
            case cdcStartPosition = "CdcStartPosition"
            case cdcStartTime = "CdcStartTime"
            case cdcStopPosition = "CdcStopPosition"
            case replicationTaskArn = "ReplicationTaskArn"
            case startReplicationTaskType = "StartReplicationTaskType"
        }
    }

    public struct StartReplicationTaskResponse: AWSDecodableShape {
        /// The replication task started.
        public let replicationTask: ReplicationTask?

        public init(replicationTask: ReplicationTask? = nil) {
            self.replicationTask = replicationTask
        }

        private enum CodingKeys: String, CodingKey {
            case replicationTask = "ReplicationTask"
        }
    }

    public struct StopReplicationTaskMessage: AWSEncodableShape {
        /// The Amazon Resource Name(ARN) of the replication task to be stopped.
        public let replicationTaskArn: String

        public init(replicationTaskArn: String) {
            self.replicationTaskArn = replicationTaskArn
        }

        private enum CodingKeys: String, CodingKey {
            case replicationTaskArn = "ReplicationTaskArn"
        }
    }

    public struct StopReplicationTaskResponse: AWSDecodableShape {
        /// The replication task stopped.
        public let replicationTask: ReplicationTask?

        public init(replicationTask: ReplicationTask? = nil) {
            self.replicationTask = replicationTask
        }

        private enum CodingKeys: String, CodingKey {
            case replicationTask = "ReplicationTask"
        }
    }

    public struct Subnet: AWSDecodableShape {
        /// The Availability Zone of the subnet.
        public let subnetAvailabilityZone: AvailabilityZone?
        /// The subnet identifier.
        public let subnetIdentifier: String?
        /// The status of the subnet.
        public let subnetStatus: String?

        public init(subnetAvailabilityZone: AvailabilityZone? = nil, subnetIdentifier: String? = nil, subnetStatus: String? = nil) {
            self.subnetAvailabilityZone = subnetAvailabilityZone
            self.subnetIdentifier = subnetIdentifier
            self.subnetStatus = subnetStatus
        }

        private enum CodingKeys: String, CodingKey {
            case subnetAvailabilityZone = "SubnetAvailabilityZone"
            case subnetIdentifier = "SubnetIdentifier"
            case subnetStatus = "SubnetStatus"
        }
    }

    public struct SupportedEndpointType: AWSDecodableShape {
        /// The type of endpoint. Valid values are source and target.
        public let endpointType: ReplicationEndpointTypeValue?
        /// The expanded name for the engine name. For example, if the EngineName parameter is "aurora," this value would be "Amazon Aurora MySQL."
        public let engineDisplayName: String?
        /// The database engine name. Valid values, depending on the EndpointType, include "mysql", "oracle", "postgres", "mariadb", "aurora", "aurora-postgresql", "redshift", "s3", "db2", "azuredb", "sybase", "dynamodb", "mongodb", "kinesis", "kafka", "elasticsearch", "documentdb", "sqlserver", and "neptune".
        public let engineName: String?
        /// The earliest DMS engine version that supports this endpoint engine. Note that endpoint engines released with DMS versions earlier than 3.1.1 do not return a value for this parameter.
        public let replicationInstanceEngineMinimumVersion: String?
        /// Indicates if change data capture (CDC) is supported.
        public let supportsCDC: Bool?

        public init(endpointType: ReplicationEndpointTypeValue? = nil, engineDisplayName: String? = nil, engineName: String? = nil, replicationInstanceEngineMinimumVersion: String? = nil, supportsCDC: Bool? = nil) {
            self.endpointType = endpointType
            self.engineDisplayName = engineDisplayName
            self.engineName = engineName
            self.replicationInstanceEngineMinimumVersion = replicationInstanceEngineMinimumVersion
            self.supportsCDC = supportsCDC
        }

        private enum CodingKeys: String, CodingKey {
            case endpointType = "EndpointType"
            case engineDisplayName = "EngineDisplayName"
            case engineName = "EngineName"
            case replicationInstanceEngineMinimumVersion = "ReplicationInstanceEngineMinimumVersion"
            case supportsCDC = "SupportsCDC"
        }
    }

    public struct SybaseSettings: AWSEncodableShape & AWSDecodableShape {
        /// Database name for the endpoint.
        public let databaseName: String?
        /// Endpoint connection password.
        public let password: String?
        /// Endpoint TCP port.
        public let port: Int?
        /// The full Amazon Resource Name (ARN) of the IAM role that specifies DMS as the trusted entity and grants the required permissions to access the value in SecretsManagerSecret. The role must allow the iam:PassRole action. SecretsManagerSecret has the value of the Amazon Web Services Secrets Manager secret that allows access to the SAP ASE endpoint.  You can specify one of two sets of values for these permissions. You can specify the values for this setting and SecretsManagerSecretId. Or you can specify clear-text values for UserName, Password, ServerName, and Port. You can't specify both. For more information on creating this SecretsManagerSecret and the SecretsManagerAccessRoleArn and SecretsManagerSecretId required to access it, see Using secrets to access Database Migration Service resources in the Database Migration Service User Guide.
        public let secretsManagerAccessRoleArn: String?
        /// The full ARN, partial ARN, or friendly name of the SecretsManagerSecret that contains the SAP SAE endpoint connection details.
        public let secretsManagerSecretId: String?
        /// Fully qualified domain name of the endpoint.
        public let serverName: String?
        /// Endpoint connection user name.
        public let username: String?

        public init(databaseName: String? = nil, password: String? = nil, port: Int? = nil, secretsManagerAccessRoleArn: String? = nil, secretsManagerSecretId: String? = nil, serverName: String? = nil, username: String? = nil) {
            self.databaseName = databaseName
            self.password = password
            self.port = port
            self.secretsManagerAccessRoleArn = secretsManagerAccessRoleArn
            self.secretsManagerSecretId = secretsManagerSecretId
            self.serverName = serverName
            self.username = username
        }

        private enum CodingKeys: String, CodingKey {
            case databaseName = "DatabaseName"
            case password = "Password"
            case port = "Port"
            case secretsManagerAccessRoleArn = "SecretsManagerAccessRoleArn"
            case secretsManagerSecretId = "SecretsManagerSecretId"
            case serverName = "ServerName"
            case username = "Username"
        }
    }

    public struct TableStatistics: AWSDecodableShape {
        /// The data definition language (DDL) used to build and modify the structure of your tables.
        public let ddls: Int64?
        /// The number of delete actions performed on a table.
        public let deletes: Int64?
        /// The number of rows that failed conditional checks during the full load operation (valid only for migrations where DynamoDB is the target).
        public let fullLoadCondtnlChkFailedRows: Int64?
        /// The time when the full load operation completed.
        public let fullLoadEndTime: Date?
        /// The number of rows that failed to load during the full load operation (valid only for migrations where DynamoDB is the target).
        public let fullLoadErrorRows: Int64?
        /// A value that indicates if the table was reloaded (true) or loaded as part of a new full load operation (false).
        public let fullLoadReloaded: Bool?
        /// The number of rows added during the full load operation.
        public let fullLoadRows: Int64?
        /// The time when the full load operation started.
        public let fullLoadStartTime: Date?
        /// The number of insert actions performed on a table.
        public let inserts: Int64?
        /// The last time a table was updated.
        public let lastUpdateTime: Date?
        /// The schema name.
        public let schemaName: String?
        /// The name of the table.
        public let tableName: String?
        /// The state of the tables described. Valid states: Table does not exist | Before load | Full load | Table completed | Table cancelled | Table error | Table all | Table updates | Table is being reloaded
        public let tableState: String?
        /// The number of update actions performed on a table.
        public let updates: Int64?
        /// The number of records that failed validation.
        public let validationFailedRecords: Int64?
        /// The number of records that have yet to be validated.
        public let validationPendingRecords: Int64?
        /// The validation state of the table. This parameter can have the following values:   Not enabled – Validation isn't enabled for the table in the migration task.   Pending records – Some records in the table are waiting for validation.   Mismatched records – Some records in the table don't match between the source and target.   Suspended records – Some records in the table couldn't be validated.   No primary key –The table couldn't be validated because it has no primary key.   Table error – The table wasn't validated because it's in an error state and some data wasn't migrated.   Validated – All rows in the table are validated. If the table is updated, the status can change from Validated.   Error – The table couldn't be validated because of an unexpected error.   Pending validation – The table is waiting validation.   Preparing table – Preparing the table enabled in the migration task for validation.   Pending revalidation – All rows in the table are pending validation after the table was updated.
        public let validationState: String?
        /// Additional details about the state of validation.
        public let validationStateDetails: String?
        /// The number of records that couldn't be validated.
        public let validationSuspendedRecords: Int64?

        public init(ddls: Int64? = nil, deletes: Int64? = nil, fullLoadCondtnlChkFailedRows: Int64? = nil, fullLoadEndTime: Date? = nil, fullLoadErrorRows: Int64? = nil, fullLoadReloaded: Bool? = nil, fullLoadRows: Int64? = nil, fullLoadStartTime: Date? = nil, inserts: Int64? = nil, lastUpdateTime: Date? = nil, schemaName: String? = nil, tableName: String? = nil, tableState: String? = nil, updates: Int64? = nil, validationFailedRecords: Int64? = nil, validationPendingRecords: Int64? = nil, validationState: String? = nil, validationStateDetails: String? = nil, validationSuspendedRecords: Int64? = nil) {
            self.ddls = ddls
            self.deletes = deletes
            self.fullLoadCondtnlChkFailedRows = fullLoadCondtnlChkFailedRows
            self.fullLoadEndTime = fullLoadEndTime
            self.fullLoadErrorRows = fullLoadErrorRows
            self.fullLoadReloaded = fullLoadReloaded
            self.fullLoadRows = fullLoadRows
            self.fullLoadStartTime = fullLoadStartTime
            self.inserts = inserts
            self.lastUpdateTime = lastUpdateTime
            self.schemaName = schemaName
            self.tableName = tableName
            self.tableState = tableState
            self.updates = updates
            self.validationFailedRecords = validationFailedRecords
            self.validationPendingRecords = validationPendingRecords
            self.validationState = validationState
            self.validationStateDetails = validationStateDetails
            self.validationSuspendedRecords = validationSuspendedRecords
        }

        private enum CodingKeys: String, CodingKey {
            case ddls = "Ddls"
            case deletes = "Deletes"
            case fullLoadCondtnlChkFailedRows = "FullLoadCondtnlChkFailedRows"
            case fullLoadEndTime = "FullLoadEndTime"
            case fullLoadErrorRows = "FullLoadErrorRows"
            case fullLoadReloaded = "FullLoadReloaded"
            case fullLoadRows = "FullLoadRows"
            case fullLoadStartTime = "FullLoadStartTime"
            case inserts = "Inserts"
            case lastUpdateTime = "LastUpdateTime"
            case schemaName = "SchemaName"
            case tableName = "TableName"
            case tableState = "TableState"
            case updates = "Updates"
            case validationFailedRecords = "ValidationFailedRecords"
            case validationPendingRecords = "ValidationPendingRecords"
            case validationState = "ValidationState"
            case validationStateDetails = "ValidationStateDetails"
            case validationSuspendedRecords = "ValidationSuspendedRecords"
        }
    }

    public struct TableToReload: AWSEncodableShape {
        /// The schema name of the table to be reloaded.
        public let schemaName: String
        /// The table name of the table to be reloaded.
        public let tableName: String

        public init(schemaName: String, tableName: String) {
            self.schemaName = schemaName
            self.tableName = tableName
        }

        private enum CodingKeys: String, CodingKey {
            case schemaName = "SchemaName"
            case tableName = "TableName"
        }
    }

    public struct Tag: AWSEncodableShape & AWSDecodableShape {
        /// A key is the required name of the tag. The string value can be 1-128 Unicode characters in length and can't be prefixed with "aws:" or "dms:". The string can only contain only the set of Unicode letters, digits, white-space, '_', '.', '/', '=', '+', '-' (Java regular expressions: "^([\\p{L}\\p{Z}\\p{N}_.:/=+\\-]*)$").
        public let key: String?
        /// A value is the optional value of the tag. The string value can be 1-256 Unicode characters in length and can't be prefixed with "aws:" or "dms:". The string can only contain only the set of Unicode letters, digits, white-space, '_', '.', '/', '=', '+', '-' (Java regular expressions: "^([\\p{L}\\p{Z}\\p{N}_.:/=+\\-]*)$").
        public let value: String?

        public init(key: String? = nil, value: String? = nil) {
            self.key = key
            self.value = value
        }

        private enum CodingKeys: String, CodingKey {
            case key = "Key"
            case value = "Value"
        }
    }

    public struct TestConnectionMessage: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) string that uniquely identifies the endpoint.
        public let endpointArn: String
        /// The Amazon Resource Name (ARN) of the replication instance.
        public let replicationInstanceArn: String

        public init(endpointArn: String, replicationInstanceArn: String) {
            self.endpointArn = endpointArn
            self.replicationInstanceArn = replicationInstanceArn
        }

        private enum CodingKeys: String, CodingKey {
            case endpointArn = "EndpointArn"
            case replicationInstanceArn = "ReplicationInstanceArn"
        }
    }

    public struct TestConnectionResponse: AWSDecodableShape {
        /// The connection tested.
        public let connection: Connection?

        public init(connection: Connection? = nil) {
            self.connection = connection
        }

        private enum CodingKeys: String, CodingKey {
            case connection = "Connection"
        }
    }

    public struct VpcSecurityGroupMembership: AWSDecodableShape {
        /// The status of the VPC security group.
        public let status: String?
        /// The VPC security group ID.
        public let vpcSecurityGroupId: String?

        public init(status: String? = nil, vpcSecurityGroupId: String? = nil) {
            self.status = status
            self.vpcSecurityGroupId = vpcSecurityGroupId
        }

        private enum CodingKeys: String, CodingKey {
            case status = "Status"
            case vpcSecurityGroupId = "VpcSecurityGroupId"
        }
    }
}
