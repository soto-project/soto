//===----------------------------------------------------------------------===//
//
// This source file is part of the Soto for AWS open source project
//
// Copyright (c) 2017-2021 the Soto project authors
// Licensed under Apache License v2.0
//
// See LICENSE.txt for license information
// See CONTRIBUTORS.txt for the list of Soto project authors
//
// SPDX-License-Identifier: Apache-2.0
//
//===----------------------------------------------------------------------===//

// THIS FILE IS AUTOMATICALLY GENERATED by https://github.com/soto-project/soto/tree/main/CodeGenerator. DO NOT EDIT.

import Foundation
import SotoCore

extension AppMesh {
    // MARK: Enums

    public enum DefaultGatewayRouteRewrite: String, CustomStringConvertible, Codable {
        case disabled = "DISABLED"
        case enabled = "ENABLED"
        public var description: String { return self.rawValue }
    }

    public enum DnsResponseType: String, CustomStringConvertible, Codable {
        case endpoints = "ENDPOINTS"
        case loadbalancer = "LOADBALANCER"
        public var description: String { return self.rawValue }
    }

    public enum DurationUnit: String, CustomStringConvertible, Codable {
        case ms
        case s
        public var description: String { return self.rawValue }
    }

    public enum EgressFilterType: String, CustomStringConvertible, Codable {
        case allowAll = "ALLOW_ALL"
        case dropAll = "DROP_ALL"
        public var description: String { return self.rawValue }
    }

    public enum GatewayRouteStatusCode: String, CustomStringConvertible, Codable {
        case active = "ACTIVE"
        case deleted = "DELETED"
        case inactive = "INACTIVE"
        public var description: String { return self.rawValue }
    }

    public enum GrpcRetryPolicyEvent: String, CustomStringConvertible, Codable {
        case cancelled
        case deadlineExceeded = "deadline-exceeded"
        case `internal`
        case resourceExhausted = "resource-exhausted"
        case unavailable
        public var description: String { return self.rawValue }
    }

    public enum HttpMethod: String, CustomStringConvertible, Codable {
        case connect = "CONNECT"
        case delete = "DELETE"
        case get = "GET"
        case head = "HEAD"
        case options = "OPTIONS"
        case patch = "PATCH"
        case post = "POST"
        case put = "PUT"
        case trace = "TRACE"
        public var description: String { return self.rawValue }
    }

    public enum HttpScheme: String, CustomStringConvertible, Codable {
        case http
        case https
        public var description: String { return self.rawValue }
    }

    public enum ListenerTlsMode: String, CustomStringConvertible, Codable {
        case disabled = "DISABLED"
        case permissive = "PERMISSIVE"
        case strict = "STRICT"
        public var description: String { return self.rawValue }
    }

    public enum MeshStatusCode: String, CustomStringConvertible, Codable {
        case active = "ACTIVE"
        case deleted = "DELETED"
        case inactive = "INACTIVE"
        public var description: String { return self.rawValue }
    }

    public enum PortProtocol: String, CustomStringConvertible, Codable {
        case grpc
        case http
        case http2
        case tcp
        public var description: String { return self.rawValue }
    }

    public enum RouteStatusCode: String, CustomStringConvertible, Codable {
        case active = "ACTIVE"
        case deleted = "DELETED"
        case inactive = "INACTIVE"
        public var description: String { return self.rawValue }
    }

    public enum TcpRetryPolicyEvent: String, CustomStringConvertible, Codable {
        case connectionError = "connection-error"
        public var description: String { return self.rawValue }
    }

    public enum VirtualGatewayListenerTlsMode: String, CustomStringConvertible, Codable {
        case disabled = "DISABLED"
        case permissive = "PERMISSIVE"
        case strict = "STRICT"
        public var description: String { return self.rawValue }
    }

    public enum VirtualGatewayPortProtocol: String, CustomStringConvertible, Codable {
        case grpc
        case http
        case http2
        public var description: String { return self.rawValue }
    }

    public enum VirtualGatewayStatusCode: String, CustomStringConvertible, Codable {
        case active = "ACTIVE"
        case deleted = "DELETED"
        case inactive = "INACTIVE"
        public var description: String { return self.rawValue }
    }

    public enum VirtualNodeStatusCode: String, CustomStringConvertible, Codable {
        case active = "ACTIVE"
        case deleted = "DELETED"
        case inactive = "INACTIVE"
        public var description: String { return self.rawValue }
    }

    public enum VirtualRouterStatusCode: String, CustomStringConvertible, Codable {
        case active = "ACTIVE"
        case deleted = "DELETED"
        case inactive = "INACTIVE"
        public var description: String { return self.rawValue }
    }

    public enum VirtualServiceStatusCode: String, CustomStringConvertible, Codable {
        case active = "ACTIVE"
        case deleted = "DELETED"
        case inactive = "INACTIVE"
        public var description: String { return self.rawValue }
    }

    // MARK: Shapes

    public struct AccessLog: AWSEncodableShape & AWSDecodableShape {
        /// The file object to send virtual node access logs to.
        public let file: FileAccessLog?

        public init(file: FileAccessLog? = nil) {
            self.file = file
        }

        public func validate(name: String) throws {
            try self.file?.validate(name: "\(name).file")
        }

        private enum CodingKeys: String, CodingKey {
            case file
        }
    }

    public struct AwsCloudMapInstanceAttribute: AWSEncodableShape & AWSDecodableShape {
        /// The name of an Cloud Map service instance attribute key. Any Cloud Map service instance that contains the specified key and value is returned.
        public let key: String
        /// The value of an Cloud Map service instance attribute key. Any Cloud Map service instance that contains the specified key and value is returned.
        public let value: String

        public init(key: String, value: String) {
            self.key = key
            self.value = value
        }

        public func validate(name: String) throws {
            try self.validate(self.key, name: "key", parent: name, max: 255)
            try self.validate(self.key, name: "key", parent: name, min: 1)
            try self.validate(self.key, name: "key", parent: name, pattern: "^[a-zA-Z0-9!-~]+$")
            try self.validate(self.value, name: "value", parent: name, max: 1024)
            try self.validate(self.value, name: "value", parent: name, min: 1)
            try self.validate(self.value, name: "value", parent: name, pattern: "^([a-zA-Z0-9!-~][  a-zA-Z0-9!-~]*){0,1}[a-zA-Z0-9!-~]{0,1}$")
        }

        private enum CodingKeys: String, CodingKey {
            case key
            case value
        }
    }

    public struct AwsCloudMapServiceDiscovery: AWSEncodableShape & AWSDecodableShape {
        /// A string map that contains attributes with values that you can use to filter instances by any custom attribute that you specified when you registered the instance. Only instances that match all of the specified key/value pairs will be returned.
        public let attributes: [AwsCloudMapInstanceAttribute]?
        /// The name of the Cloud Map namespace to use.
        public let namespaceName: String
        /// The name of the Cloud Map service to use.
        public let serviceName: String

        public init(attributes: [AwsCloudMapInstanceAttribute]? = nil, namespaceName: String, serviceName: String) {
            self.attributes = attributes
            self.namespaceName = namespaceName
            self.serviceName = serviceName
        }

        public func validate(name: String) throws {
            try self.attributes?.forEach {
                try $0.validate(name: "\(name).attributes[]")
            }
            try self.validate(self.namespaceName, name: "namespaceName", parent: name, max: 1024)
            try self.validate(self.namespaceName, name: "namespaceName", parent: name, min: 1)
            try self.validate(self.serviceName, name: "serviceName", parent: name, max: 1024)
            try self.validate(self.serviceName, name: "serviceName", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case attributes
            case namespaceName
            case serviceName
        }
    }

    public struct Backend: AWSEncodableShape & AWSDecodableShape {
        /// Specifies a virtual service to use as a backend.
        public let virtualService: VirtualServiceBackend?

        public init(virtualService: VirtualServiceBackend? = nil) {
            self.virtualService = virtualService
        }

        public func validate(name: String) throws {
            try self.virtualService?.validate(name: "\(name).virtualService")
        }

        private enum CodingKeys: String, CodingKey {
            case virtualService
        }
    }

    public struct BackendDefaults: AWSEncodableShape & AWSDecodableShape {
        /// A reference to an object that represents a client policy.
        public let clientPolicy: ClientPolicy?

        public init(clientPolicy: ClientPolicy? = nil) {
            self.clientPolicy = clientPolicy
        }

        public func validate(name: String) throws {
            try self.clientPolicy?.validate(name: "\(name).clientPolicy")
        }

        private enum CodingKeys: String, CodingKey {
            case clientPolicy
        }
    }

    public struct ClientPolicy: AWSEncodableShape & AWSDecodableShape {
        /// A reference to an object that represents a Transport Layer Security (TLS) client policy.
        public let tls: ClientPolicyTls?

        public init(tls: ClientPolicyTls? = nil) {
            self.tls = tls
        }

        public func validate(name: String) throws {
            try self.tls?.validate(name: "\(name).tls")
        }

        private enum CodingKeys: String, CodingKey {
            case tls
        }
    }

    public struct ClientPolicyTls: AWSEncodableShape & AWSDecodableShape {
        /// A reference to an object that represents a client's TLS certificate.
        public let certificate: ClientTlsCertificate?
        /// Whether the policy is enforced. The default is True, if a value isn't specified.
        public let enforce: Bool?
        /// One or more ports that the policy is enforced for.
        public let ports: [Int]?
        /// A reference to an object that represents a TLS validation context.
        public let validation: TlsValidationContext

        public init(certificate: ClientTlsCertificate? = nil, enforce: Bool? = nil, ports: [Int]? = nil, validation: TlsValidationContext) {
            self.certificate = certificate
            self.enforce = enforce
            self.ports = ports
            self.validation = validation
        }

        public func validate(name: String) throws {
            try self.certificate?.validate(name: "\(name).certificate")
            try self.ports?.forEach {
                try validate($0, name: "ports[]", parent: name, max: 65535)
                try validate($0, name: "ports[]", parent: name, min: 1)
            }
            try self.validation.validate(name: "\(name).validation")
        }

        private enum CodingKeys: String, CodingKey {
            case certificate
            case enforce
            case ports
            case validation
        }
    }

    public struct ClientTlsCertificate: AWSEncodableShape & AWSDecodableShape {
        /// An object that represents a local file certificate. The certificate must meet specific requirements and you must have proxy authorization enabled. For more information, see Transport Layer Security (TLS).
        public let file: ListenerTlsFileCertificate?
        /// A reference to an object that represents a client's TLS Secret Discovery Service certificate.
        public let sds: ListenerTlsSdsCertificate?

        public init(file: ListenerTlsFileCertificate? = nil, sds: ListenerTlsSdsCertificate? = nil) {
            self.file = file
            self.sds = sds
        }

        public func validate(name: String) throws {
            try self.file?.validate(name: "\(name).file")
        }

        private enum CodingKeys: String, CodingKey {
            case file
            case sds
        }
    }

    public struct CreateGatewayRouteInput: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "meshName", location: .uri(locationName: "meshName")),
            AWSMemberEncoding(label: "meshOwner", location: .querystring(locationName: "meshOwner")),
            AWSMemberEncoding(label: "virtualGatewayName", location: .uri(locationName: "virtualGatewayName"))
        ]

        /// Unique, case-sensitive identifier that you provide to ensure the idempotency of the request. Up to 36 letters, numbers, hyphens, and underscores are allowed.
        public let clientToken: String?
        /// The name to use for the gateway route.
        public let gatewayRouteName: String
        /// The name of the service mesh to create the gateway route in.
        public let meshName: String
        /// The AWS IAM account ID of the service mesh owner. If the account ID is not your own, then the account that you specify must share the mesh with your account before you can create the resource in the service mesh. For more information about mesh sharing, see Working with shared meshes.
        public let meshOwner: String?
        /// The gateway route specification to apply.
        public let spec: GatewayRouteSpec
        /// Optional metadata that you can apply to the gateway route to assist with categorization and organization. Each tag consists of a key and an optional value, both of which you define. Tag keys can have a maximum character length of 128 characters, and tag values can have a maximum length of 256 characters.
        public let tags: [TagRef]?
        /// The name of the virtual gateway to associate the gateway route with. If the virtual gateway is in a shared mesh, then you must be the owner of the virtual gateway resource.
        public let virtualGatewayName: String

        public init(clientToken: String? = CreateGatewayRouteInput.idempotencyToken(), gatewayRouteName: String, meshName: String, meshOwner: String? = nil, spec: GatewayRouteSpec, tags: [TagRef]? = nil, virtualGatewayName: String) {
            self.clientToken = clientToken
            self.gatewayRouteName = gatewayRouteName
            self.meshName = meshName
            self.meshOwner = meshOwner
            self.spec = spec
            self.tags = tags
            self.virtualGatewayName = virtualGatewayName
        }

        public func validate(name: String) throws {
            try self.validate(self.gatewayRouteName, name: "gatewayRouteName", parent: name, max: 255)
            try self.validate(self.gatewayRouteName, name: "gatewayRouteName", parent: name, min: 1)
            try self.validate(self.meshName, name: "meshName", parent: name, max: 255)
            try self.validate(self.meshName, name: "meshName", parent: name, min: 1)
            try self.validate(self.meshOwner, name: "meshOwner", parent: name, max: 12)
            try self.validate(self.meshOwner, name: "meshOwner", parent: name, min: 12)
            try self.spec.validate(name: "\(name).spec")
            try self.tags?.forEach {
                try $0.validate(name: "\(name).tags[]")
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 50)
            try self.validate(self.tags, name: "tags", parent: name, min: 0)
            try self.validate(self.virtualGatewayName, name: "virtualGatewayName", parent: name, max: 255)
            try self.validate(self.virtualGatewayName, name: "virtualGatewayName", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken
            case gatewayRouteName
            case spec
            case tags
        }
    }

    public struct CreateGatewayRouteOutput: AWSDecodableShape & AWSShapeWithPayload {
        /// The key for the payload
        public static let _payloadPath: String = "gatewayRoute"

        /// The full description of your gateway route following the create call.
        public let gatewayRoute: GatewayRouteData

        public init(gatewayRoute: GatewayRouteData) {
            self.gatewayRoute = gatewayRoute
        }

        private enum CodingKeys: String, CodingKey {
            case gatewayRoute
        }
    }

    public struct CreateMeshInput: AWSEncodableShape {
        /// Unique, case-sensitive identifier that you provide to ensure the idempotency of the request. Up to 36 letters, numbers, hyphens, and underscores are allowed.
        public let clientToken: String?
        /// The name to use for the service mesh.
        public let meshName: String
        /// The service mesh specification to apply.
        public let spec: MeshSpec?
        /// Optional metadata that you can apply to the service mesh to assist with categorization and organization. Each tag consists of a key and an optional value, both of which you define. Tag keys can have a maximum character length of 128 characters, and tag values can have a maximum length of 256 characters.
        public let tags: [TagRef]?

        public init(clientToken: String? = CreateMeshInput.idempotencyToken(), meshName: String, spec: MeshSpec? = nil, tags: [TagRef]? = nil) {
            self.clientToken = clientToken
            self.meshName = meshName
            self.spec = spec
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.validate(self.meshName, name: "meshName", parent: name, max: 255)
            try self.validate(self.meshName, name: "meshName", parent: name, min: 1)
            try self.tags?.forEach {
                try $0.validate(name: "\(name).tags[]")
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 50)
            try self.validate(self.tags, name: "tags", parent: name, min: 0)
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken
            case meshName
            case spec
            case tags
        }
    }

    public struct CreateMeshOutput: AWSDecodableShape & AWSShapeWithPayload {
        /// The key for the payload
        public static let _payloadPath: String = "mesh"

        /// The full description of your service mesh following the create call.
        public let mesh: MeshData

        public init(mesh: MeshData) {
            self.mesh = mesh
        }

        private enum CodingKeys: String, CodingKey {
            case mesh
        }
    }

    public struct CreateRouteInput: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "meshName", location: .uri(locationName: "meshName")),
            AWSMemberEncoding(label: "meshOwner", location: .querystring(locationName: "meshOwner")),
            AWSMemberEncoding(label: "virtualRouterName", location: .uri(locationName: "virtualRouterName"))
        ]

        /// Unique, case-sensitive identifier that you provide to ensure the idempotency of the request. Up to 36 letters, numbers, hyphens, and underscores are allowed.
        public let clientToken: String?
        /// The name of the service mesh to create the route in.
        public let meshName: String
        /// The AWS IAM account ID of the service mesh owner. If the account ID is not your own, then the account that you specify must share the mesh with your account before you can create the resource in the service mesh. For more information about mesh sharing, see Working with shared meshes.
        public let meshOwner: String?
        /// The name to use for the route.
        public let routeName: String
        /// The route specification to apply.
        public let spec: RouteSpec
        /// Optional metadata that you can apply to the route to assist with categorization and organization. Each tag consists of a key and an optional value, both of which you define. Tag keys can have a maximum character length of 128 characters, and tag values can have a maximum length of 256 characters.
        public let tags: [TagRef]?
        /// The name of the virtual router in which to create the route. If the virtual router is in a shared mesh, then you must be the owner of the virtual router resource.
        public let virtualRouterName: String

        public init(clientToken: String? = CreateRouteInput.idempotencyToken(), meshName: String, meshOwner: String? = nil, routeName: String, spec: RouteSpec, tags: [TagRef]? = nil, virtualRouterName: String) {
            self.clientToken = clientToken
            self.meshName = meshName
            self.meshOwner = meshOwner
            self.routeName = routeName
            self.spec = spec
            self.tags = tags
            self.virtualRouterName = virtualRouterName
        }

        public func validate(name: String) throws {
            try self.validate(self.meshName, name: "meshName", parent: name, max: 255)
            try self.validate(self.meshName, name: "meshName", parent: name, min: 1)
            try self.validate(self.meshOwner, name: "meshOwner", parent: name, max: 12)
            try self.validate(self.meshOwner, name: "meshOwner", parent: name, min: 12)
            try self.validate(self.routeName, name: "routeName", parent: name, max: 255)
            try self.validate(self.routeName, name: "routeName", parent: name, min: 1)
            try self.spec.validate(name: "\(name).spec")
            try self.tags?.forEach {
                try $0.validate(name: "\(name).tags[]")
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 50)
            try self.validate(self.tags, name: "tags", parent: name, min: 0)
            try self.validate(self.virtualRouterName, name: "virtualRouterName", parent: name, max: 255)
            try self.validate(self.virtualRouterName, name: "virtualRouterName", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken
            case routeName
            case spec
            case tags
        }
    }

    public struct CreateRouteOutput: AWSDecodableShape & AWSShapeWithPayload {
        /// The key for the payload
        public static let _payloadPath: String = "route"

        /// The full description of your mesh following the create call.
        public let route: RouteData

        public init(route: RouteData) {
            self.route = route
        }

        private enum CodingKeys: String, CodingKey {
            case route
        }
    }

    public struct CreateVirtualGatewayInput: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "meshName", location: .uri(locationName: "meshName")),
            AWSMemberEncoding(label: "meshOwner", location: .querystring(locationName: "meshOwner"))
        ]

        /// Unique, case-sensitive identifier that you provide to ensure the idempotency of the request. Up to 36 letters, numbers, hyphens, and underscores are allowed.
        public let clientToken: String?
        /// The name of the service mesh to create the virtual gateway in.
        public let meshName: String
        /// The AWS IAM account ID of the service mesh owner. If the account ID is not your own, then the account that you specify must share the mesh with your account before you can create the resource in the service mesh. For more information about mesh sharing, see Working with shared meshes.
        public let meshOwner: String?
        /// The virtual gateway specification to apply.
        public let spec: VirtualGatewaySpec
        /// Optional metadata that you can apply to the virtual gateway to assist with categorization and organization. Each tag consists of a key and an optional value, both of which you define. Tag keys can have a maximum character length of 128 characters, and tag values can have a maximum length of 256 characters.
        public let tags: [TagRef]?
        /// The name to use for the virtual gateway.
        public let virtualGatewayName: String

        public init(clientToken: String? = CreateVirtualGatewayInput.idempotencyToken(), meshName: String, meshOwner: String? = nil, spec: VirtualGatewaySpec, tags: [TagRef]? = nil, virtualGatewayName: String) {
            self.clientToken = clientToken
            self.meshName = meshName
            self.meshOwner = meshOwner
            self.spec = spec
            self.tags = tags
            self.virtualGatewayName = virtualGatewayName
        }

        public func validate(name: String) throws {
            try self.validate(self.meshName, name: "meshName", parent: name, max: 255)
            try self.validate(self.meshName, name: "meshName", parent: name, min: 1)
            try self.validate(self.meshOwner, name: "meshOwner", parent: name, max: 12)
            try self.validate(self.meshOwner, name: "meshOwner", parent: name, min: 12)
            try self.spec.validate(name: "\(name).spec")
            try self.tags?.forEach {
                try $0.validate(name: "\(name).tags[]")
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 50)
            try self.validate(self.tags, name: "tags", parent: name, min: 0)
            try self.validate(self.virtualGatewayName, name: "virtualGatewayName", parent: name, max: 255)
            try self.validate(self.virtualGatewayName, name: "virtualGatewayName", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken
            case spec
            case tags
            case virtualGatewayName
        }
    }

    public struct CreateVirtualGatewayOutput: AWSDecodableShape & AWSShapeWithPayload {
        /// The key for the payload
        public static let _payloadPath: String = "virtualGateway"

        /// The full description of your virtual gateway following the create call.
        public let virtualGateway: VirtualGatewayData

        public init(virtualGateway: VirtualGatewayData) {
            self.virtualGateway = virtualGateway
        }

        private enum CodingKeys: String, CodingKey {
            case virtualGateway
        }
    }

    public struct CreateVirtualNodeInput: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "meshName", location: .uri(locationName: "meshName")),
            AWSMemberEncoding(label: "meshOwner", location: .querystring(locationName: "meshOwner"))
        ]

        /// Unique, case-sensitive identifier that you provide to ensure the idempotency of the request. Up to 36 letters, numbers, hyphens, and underscores are allowed.
        public let clientToken: String?
        /// The name of the service mesh to create the virtual node in.
        public let meshName: String
        /// The AWS IAM account ID of the service mesh owner. If the account ID is not your own, then the account that you specify must share the mesh with your account before you can create the resource in the service mesh. For more information about mesh sharing, see Working with shared meshes.
        public let meshOwner: String?
        /// The virtual node specification to apply.
        public let spec: VirtualNodeSpec
        /// Optional metadata that you can apply to the virtual node to assist with categorization and organization. Each tag consists of a key and an optional value, both of which you define. Tag keys can have a maximum character length of 128 characters, and tag values can have a maximum length of 256 characters.
        public let tags: [TagRef]?
        /// The name to use for the virtual node.
        public let virtualNodeName: String

        public init(clientToken: String? = CreateVirtualNodeInput.idempotencyToken(), meshName: String, meshOwner: String? = nil, spec: VirtualNodeSpec, tags: [TagRef]? = nil, virtualNodeName: String) {
            self.clientToken = clientToken
            self.meshName = meshName
            self.meshOwner = meshOwner
            self.spec = spec
            self.tags = tags
            self.virtualNodeName = virtualNodeName
        }

        public func validate(name: String) throws {
            try self.validate(self.meshName, name: "meshName", parent: name, max: 255)
            try self.validate(self.meshName, name: "meshName", parent: name, min: 1)
            try self.validate(self.meshOwner, name: "meshOwner", parent: name, max: 12)
            try self.validate(self.meshOwner, name: "meshOwner", parent: name, min: 12)
            try self.spec.validate(name: "\(name).spec")
            try self.tags?.forEach {
                try $0.validate(name: "\(name).tags[]")
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 50)
            try self.validate(self.tags, name: "tags", parent: name, min: 0)
            try self.validate(self.virtualNodeName, name: "virtualNodeName", parent: name, max: 255)
            try self.validate(self.virtualNodeName, name: "virtualNodeName", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken
            case spec
            case tags
            case virtualNodeName
        }
    }

    public struct CreateVirtualNodeOutput: AWSDecodableShape & AWSShapeWithPayload {
        /// The key for the payload
        public static let _payloadPath: String = "virtualNode"

        /// The full description of your virtual node following the create call.
        public let virtualNode: VirtualNodeData

        public init(virtualNode: VirtualNodeData) {
            self.virtualNode = virtualNode
        }

        private enum CodingKeys: String, CodingKey {
            case virtualNode
        }
    }

    public struct CreateVirtualRouterInput: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "meshName", location: .uri(locationName: "meshName")),
            AWSMemberEncoding(label: "meshOwner", location: .querystring(locationName: "meshOwner"))
        ]

        /// Unique, case-sensitive identifier that you provide to ensure the idempotency of the request. Up to 36 letters, numbers, hyphens, and underscores are allowed.
        public let clientToken: String?
        /// The name of the service mesh to create the virtual router in.
        public let meshName: String
        /// The AWS IAM account ID of the service mesh owner. If the account ID is not your own, then the account that you specify must share the mesh with your account before you can create the resource in the service mesh. For more information about mesh sharing, see Working with shared meshes.
        public let meshOwner: String?
        /// The virtual router specification to apply.
        public let spec: VirtualRouterSpec
        /// Optional metadata that you can apply to the virtual router to assist with categorization and organization. Each tag consists of a key and an optional value, both of which you define. Tag keys can have a maximum character length of 128 characters, and tag values can have a maximum length of 256 characters.
        public let tags: [TagRef]?
        /// The name to use for the virtual router.
        public let virtualRouterName: String

        public init(clientToken: String? = CreateVirtualRouterInput.idempotencyToken(), meshName: String, meshOwner: String? = nil, spec: VirtualRouterSpec, tags: [TagRef]? = nil, virtualRouterName: String) {
            self.clientToken = clientToken
            self.meshName = meshName
            self.meshOwner = meshOwner
            self.spec = spec
            self.tags = tags
            self.virtualRouterName = virtualRouterName
        }

        public func validate(name: String) throws {
            try self.validate(self.meshName, name: "meshName", parent: name, max: 255)
            try self.validate(self.meshName, name: "meshName", parent: name, min: 1)
            try self.validate(self.meshOwner, name: "meshOwner", parent: name, max: 12)
            try self.validate(self.meshOwner, name: "meshOwner", parent: name, min: 12)
            try self.spec.validate(name: "\(name).spec")
            try self.tags?.forEach {
                try $0.validate(name: "\(name).tags[]")
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 50)
            try self.validate(self.tags, name: "tags", parent: name, min: 0)
            try self.validate(self.virtualRouterName, name: "virtualRouterName", parent: name, max: 255)
            try self.validate(self.virtualRouterName, name: "virtualRouterName", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken
            case spec
            case tags
            case virtualRouterName
        }
    }

    public struct CreateVirtualRouterOutput: AWSDecodableShape & AWSShapeWithPayload {
        /// The key for the payload
        public static let _payloadPath: String = "virtualRouter"

        /// The full description of your virtual router following the create call.
        public let virtualRouter: VirtualRouterData

        public init(virtualRouter: VirtualRouterData) {
            self.virtualRouter = virtualRouter
        }

        private enum CodingKeys: String, CodingKey {
            case virtualRouter
        }
    }

    public struct CreateVirtualServiceInput: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "meshName", location: .uri(locationName: "meshName")),
            AWSMemberEncoding(label: "meshOwner", location: .querystring(locationName: "meshOwner"))
        ]

        /// Unique, case-sensitive identifier that you provide to ensure the idempotency of the request. Up to 36 letters, numbers, hyphens, and underscores are allowed.
        public let clientToken: String?
        /// The name of the service mesh to create the virtual service in.
        public let meshName: String
        /// The AWS IAM account ID of the service mesh owner. If the account ID is not your own, then the account that you specify must share the mesh with your account before you can create the resource in the service mesh. For more information about mesh sharing, see Working with shared meshes.
        public let meshOwner: String?
        /// The virtual service specification to apply.
        public let spec: VirtualServiceSpec
        /// Optional metadata that you can apply to the virtual service to assist with categorization and organization. Each tag consists of a key and an optional value, both of which you define. Tag keys can have a maximum character length of 128 characters, and tag values can have a maximum length of 256 characters.
        public let tags: [TagRef]?
        /// The name to use for the virtual service.
        public let virtualServiceName: String

        public init(clientToken: String? = CreateVirtualServiceInput.idempotencyToken(), meshName: String, meshOwner: String? = nil, spec: VirtualServiceSpec, tags: [TagRef]? = nil, virtualServiceName: String) {
            self.clientToken = clientToken
            self.meshName = meshName
            self.meshOwner = meshOwner
            self.spec = spec
            self.tags = tags
            self.virtualServiceName = virtualServiceName
        }

        public func validate(name: String) throws {
            try self.validate(self.meshName, name: "meshName", parent: name, max: 255)
            try self.validate(self.meshName, name: "meshName", parent: name, min: 1)
            try self.validate(self.meshOwner, name: "meshOwner", parent: name, max: 12)
            try self.validate(self.meshOwner, name: "meshOwner", parent: name, min: 12)
            try self.spec.validate(name: "\(name).spec")
            try self.tags?.forEach {
                try $0.validate(name: "\(name).tags[]")
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 50)
            try self.validate(self.tags, name: "tags", parent: name, min: 0)
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken
            case spec
            case tags
            case virtualServiceName
        }
    }

    public struct CreateVirtualServiceOutput: AWSDecodableShape & AWSShapeWithPayload {
        /// The key for the payload
        public static let _payloadPath: String = "virtualService"

        /// The full description of your virtual service following the create call.
        public let virtualService: VirtualServiceData

        public init(virtualService: VirtualServiceData) {
            self.virtualService = virtualService
        }

        private enum CodingKeys: String, CodingKey {
            case virtualService
        }
    }

    public struct DeleteGatewayRouteInput: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "gatewayRouteName", location: .uri(locationName: "gatewayRouteName")),
            AWSMemberEncoding(label: "meshName", location: .uri(locationName: "meshName")),
            AWSMemberEncoding(label: "meshOwner", location: .querystring(locationName: "meshOwner")),
            AWSMemberEncoding(label: "virtualGatewayName", location: .uri(locationName: "virtualGatewayName"))
        ]

        /// The name of the gateway route to delete.
        public let gatewayRouteName: String
        /// The name of the service mesh to delete the gateway route from.
        public let meshName: String
        /// The AWS IAM account ID of the service mesh owner. If the account ID is not your own, then it's the ID of the account that shared the mesh with your account. For more information about mesh sharing, see Working with shared meshes.
        public let meshOwner: String?
        /// The name of the virtual gateway to delete the route from.
        public let virtualGatewayName: String

        public init(gatewayRouteName: String, meshName: String, meshOwner: String? = nil, virtualGatewayName: String) {
            self.gatewayRouteName = gatewayRouteName
            self.meshName = meshName
            self.meshOwner = meshOwner
            self.virtualGatewayName = virtualGatewayName
        }

        public func validate(name: String) throws {
            try self.validate(self.gatewayRouteName, name: "gatewayRouteName", parent: name, max: 255)
            try self.validate(self.gatewayRouteName, name: "gatewayRouteName", parent: name, min: 1)
            try self.validate(self.meshName, name: "meshName", parent: name, max: 255)
            try self.validate(self.meshName, name: "meshName", parent: name, min: 1)
            try self.validate(self.meshOwner, name: "meshOwner", parent: name, max: 12)
            try self.validate(self.meshOwner, name: "meshOwner", parent: name, min: 12)
            try self.validate(self.virtualGatewayName, name: "virtualGatewayName", parent: name, max: 255)
            try self.validate(self.virtualGatewayName, name: "virtualGatewayName", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteGatewayRouteOutput: AWSDecodableShape & AWSShapeWithPayload {
        /// The key for the payload
        public static let _payloadPath: String = "gatewayRoute"

        /// The gateway route that was deleted.
        public let gatewayRoute: GatewayRouteData

        public init(gatewayRoute: GatewayRouteData) {
            self.gatewayRoute = gatewayRoute
        }

        private enum CodingKeys: String, CodingKey {
            case gatewayRoute
        }
    }

    public struct DeleteMeshInput: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "meshName", location: .uri(locationName: "meshName"))
        ]

        /// The name of the service mesh to delete.
        public let meshName: String

        public init(meshName: String) {
            self.meshName = meshName
        }

        public func validate(name: String) throws {
            try self.validate(self.meshName, name: "meshName", parent: name, max: 255)
            try self.validate(self.meshName, name: "meshName", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteMeshOutput: AWSDecodableShape & AWSShapeWithPayload {
        /// The key for the payload
        public static let _payloadPath: String = "mesh"

        /// The service mesh that was deleted.
        public let mesh: MeshData

        public init(mesh: MeshData) {
            self.mesh = mesh
        }

        private enum CodingKeys: String, CodingKey {
            case mesh
        }
    }

    public struct DeleteRouteInput: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "meshName", location: .uri(locationName: "meshName")),
            AWSMemberEncoding(label: "meshOwner", location: .querystring(locationName: "meshOwner")),
            AWSMemberEncoding(label: "routeName", location: .uri(locationName: "routeName")),
            AWSMemberEncoding(label: "virtualRouterName", location: .uri(locationName: "virtualRouterName"))
        ]

        /// The name of the service mesh to delete the route in.
        public let meshName: String
        /// The AWS IAM account ID of the service mesh owner. If the account ID is not your own, then it's the ID of the account that shared the mesh with your account. For more information about mesh sharing, see Working with shared meshes.
        public let meshOwner: String?
        /// The name of the route to delete.
        public let routeName: String
        /// The name of the virtual router to delete the route in.
        public let virtualRouterName: String

        public init(meshName: String, meshOwner: String? = nil, routeName: String, virtualRouterName: String) {
            self.meshName = meshName
            self.meshOwner = meshOwner
            self.routeName = routeName
            self.virtualRouterName = virtualRouterName
        }

        public func validate(name: String) throws {
            try self.validate(self.meshName, name: "meshName", parent: name, max: 255)
            try self.validate(self.meshName, name: "meshName", parent: name, min: 1)
            try self.validate(self.meshOwner, name: "meshOwner", parent: name, max: 12)
            try self.validate(self.meshOwner, name: "meshOwner", parent: name, min: 12)
            try self.validate(self.routeName, name: "routeName", parent: name, max: 255)
            try self.validate(self.routeName, name: "routeName", parent: name, min: 1)
            try self.validate(self.virtualRouterName, name: "virtualRouterName", parent: name, max: 255)
            try self.validate(self.virtualRouterName, name: "virtualRouterName", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteRouteOutput: AWSDecodableShape & AWSShapeWithPayload {
        /// The key for the payload
        public static let _payloadPath: String = "route"

        /// The route that was deleted.
        public let route: RouteData

        public init(route: RouteData) {
            self.route = route
        }

        private enum CodingKeys: String, CodingKey {
            case route
        }
    }

    public struct DeleteVirtualGatewayInput: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "meshName", location: .uri(locationName: "meshName")),
            AWSMemberEncoding(label: "meshOwner", location: .querystring(locationName: "meshOwner")),
            AWSMemberEncoding(label: "virtualGatewayName", location: .uri(locationName: "virtualGatewayName"))
        ]

        /// The name of the service mesh to delete the virtual gateway from.
        public let meshName: String
        /// The AWS IAM account ID of the service mesh owner. If the account ID is not your own, then it's the ID of the account that shared the mesh with your account. For more information about mesh sharing, see Working with shared meshes.
        public let meshOwner: String?
        /// The name of the virtual gateway to delete.
        public let virtualGatewayName: String

        public init(meshName: String, meshOwner: String? = nil, virtualGatewayName: String) {
            self.meshName = meshName
            self.meshOwner = meshOwner
            self.virtualGatewayName = virtualGatewayName
        }

        public func validate(name: String) throws {
            try self.validate(self.meshName, name: "meshName", parent: name, max: 255)
            try self.validate(self.meshName, name: "meshName", parent: name, min: 1)
            try self.validate(self.meshOwner, name: "meshOwner", parent: name, max: 12)
            try self.validate(self.meshOwner, name: "meshOwner", parent: name, min: 12)
            try self.validate(self.virtualGatewayName, name: "virtualGatewayName", parent: name, max: 255)
            try self.validate(self.virtualGatewayName, name: "virtualGatewayName", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteVirtualGatewayOutput: AWSDecodableShape & AWSShapeWithPayload {
        /// The key for the payload
        public static let _payloadPath: String = "virtualGateway"

        /// The virtual gateway that was deleted.
        public let virtualGateway: VirtualGatewayData

        public init(virtualGateway: VirtualGatewayData) {
            self.virtualGateway = virtualGateway
        }

        private enum CodingKeys: String, CodingKey {
            case virtualGateway
        }
    }

    public struct DeleteVirtualNodeInput: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "meshName", location: .uri(locationName: "meshName")),
            AWSMemberEncoding(label: "meshOwner", location: .querystring(locationName: "meshOwner")),
            AWSMemberEncoding(label: "virtualNodeName", location: .uri(locationName: "virtualNodeName"))
        ]

        /// The name of the service mesh to delete the virtual node in.
        public let meshName: String
        /// The AWS IAM account ID of the service mesh owner. If the account ID is not your own, then it's the ID of the account that shared the mesh with your account. For more information about mesh sharing, see Working with shared meshes.
        public let meshOwner: String?
        /// The name of the virtual node to delete.
        public let virtualNodeName: String

        public init(meshName: String, meshOwner: String? = nil, virtualNodeName: String) {
            self.meshName = meshName
            self.meshOwner = meshOwner
            self.virtualNodeName = virtualNodeName
        }

        public func validate(name: String) throws {
            try self.validate(self.meshName, name: "meshName", parent: name, max: 255)
            try self.validate(self.meshName, name: "meshName", parent: name, min: 1)
            try self.validate(self.meshOwner, name: "meshOwner", parent: name, max: 12)
            try self.validate(self.meshOwner, name: "meshOwner", parent: name, min: 12)
            try self.validate(self.virtualNodeName, name: "virtualNodeName", parent: name, max: 255)
            try self.validate(self.virtualNodeName, name: "virtualNodeName", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteVirtualNodeOutput: AWSDecodableShape & AWSShapeWithPayload {
        /// The key for the payload
        public static let _payloadPath: String = "virtualNode"

        /// The virtual node that was deleted.
        public let virtualNode: VirtualNodeData

        public init(virtualNode: VirtualNodeData) {
            self.virtualNode = virtualNode
        }

        private enum CodingKeys: String, CodingKey {
            case virtualNode
        }
    }

    public struct DeleteVirtualRouterInput: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "meshName", location: .uri(locationName: "meshName")),
            AWSMemberEncoding(label: "meshOwner", location: .querystring(locationName: "meshOwner")),
            AWSMemberEncoding(label: "virtualRouterName", location: .uri(locationName: "virtualRouterName"))
        ]

        /// The name of the service mesh to delete the virtual router in.
        public let meshName: String
        /// The AWS IAM account ID of the service mesh owner. If the account ID is not your own, then it's the ID of the account that shared the mesh with your account. For more information about mesh sharing, see Working with shared meshes.
        public let meshOwner: String?
        /// The name of the virtual router to delete.
        public let virtualRouterName: String

        public init(meshName: String, meshOwner: String? = nil, virtualRouterName: String) {
            self.meshName = meshName
            self.meshOwner = meshOwner
            self.virtualRouterName = virtualRouterName
        }

        public func validate(name: String) throws {
            try self.validate(self.meshName, name: "meshName", parent: name, max: 255)
            try self.validate(self.meshName, name: "meshName", parent: name, min: 1)
            try self.validate(self.meshOwner, name: "meshOwner", parent: name, max: 12)
            try self.validate(self.meshOwner, name: "meshOwner", parent: name, min: 12)
            try self.validate(self.virtualRouterName, name: "virtualRouterName", parent: name, max: 255)
            try self.validate(self.virtualRouterName, name: "virtualRouterName", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteVirtualRouterOutput: AWSDecodableShape & AWSShapeWithPayload {
        /// The key for the payload
        public static let _payloadPath: String = "virtualRouter"

        /// The virtual router that was deleted.
        public let virtualRouter: VirtualRouterData

        public init(virtualRouter: VirtualRouterData) {
            self.virtualRouter = virtualRouter
        }

        private enum CodingKeys: String, CodingKey {
            case virtualRouter
        }
    }

    public struct DeleteVirtualServiceInput: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "meshName", location: .uri(locationName: "meshName")),
            AWSMemberEncoding(label: "meshOwner", location: .querystring(locationName: "meshOwner")),
            AWSMemberEncoding(label: "virtualServiceName", location: .uri(locationName: "virtualServiceName"))
        ]

        /// The name of the service mesh to delete the virtual service in.
        public let meshName: String
        /// The AWS IAM account ID of the service mesh owner. If the account ID is not your own, then it's the ID of the account that shared the mesh with your account. For more information about mesh sharing, see Working with shared meshes.
        public let meshOwner: String?
        /// The name of the virtual service to delete.
        public let virtualServiceName: String

        public init(meshName: String, meshOwner: String? = nil, virtualServiceName: String) {
            self.meshName = meshName
            self.meshOwner = meshOwner
            self.virtualServiceName = virtualServiceName
        }

        public func validate(name: String) throws {
            try self.validate(self.meshName, name: "meshName", parent: name, max: 255)
            try self.validate(self.meshName, name: "meshName", parent: name, min: 1)
            try self.validate(self.meshOwner, name: "meshOwner", parent: name, max: 12)
            try self.validate(self.meshOwner, name: "meshOwner", parent: name, min: 12)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteVirtualServiceOutput: AWSDecodableShape & AWSShapeWithPayload {
        /// The key for the payload
        public static let _payloadPath: String = "virtualService"

        /// The virtual service that was deleted.
        public let virtualService: VirtualServiceData

        public init(virtualService: VirtualServiceData) {
            self.virtualService = virtualService
        }

        private enum CodingKeys: String, CodingKey {
            case virtualService
        }
    }

    public struct DescribeGatewayRouteInput: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "gatewayRouteName", location: .uri(locationName: "gatewayRouteName")),
            AWSMemberEncoding(label: "meshName", location: .uri(locationName: "meshName")),
            AWSMemberEncoding(label: "meshOwner", location: .querystring(locationName: "meshOwner")),
            AWSMemberEncoding(label: "virtualGatewayName", location: .uri(locationName: "virtualGatewayName"))
        ]

        /// The name of the gateway route to describe.
        public let gatewayRouteName: String
        /// The name of the service mesh that the gateway route resides in.
        public let meshName: String
        /// The AWS IAM account ID of the service mesh owner. If the account ID is not your own, then it's the ID of the account that shared the mesh with your account. For more information about mesh sharing, see Working with shared meshes.
        public let meshOwner: String?
        /// The name of the virtual gateway that the gateway route is associated with.
        public let virtualGatewayName: String

        public init(gatewayRouteName: String, meshName: String, meshOwner: String? = nil, virtualGatewayName: String) {
            self.gatewayRouteName = gatewayRouteName
            self.meshName = meshName
            self.meshOwner = meshOwner
            self.virtualGatewayName = virtualGatewayName
        }

        public func validate(name: String) throws {
            try self.validate(self.gatewayRouteName, name: "gatewayRouteName", parent: name, max: 255)
            try self.validate(self.gatewayRouteName, name: "gatewayRouteName", parent: name, min: 1)
            try self.validate(self.meshName, name: "meshName", parent: name, max: 255)
            try self.validate(self.meshName, name: "meshName", parent: name, min: 1)
            try self.validate(self.meshOwner, name: "meshOwner", parent: name, max: 12)
            try self.validate(self.meshOwner, name: "meshOwner", parent: name, min: 12)
            try self.validate(self.virtualGatewayName, name: "virtualGatewayName", parent: name, max: 255)
            try self.validate(self.virtualGatewayName, name: "virtualGatewayName", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DescribeGatewayRouteOutput: AWSDecodableShape & AWSShapeWithPayload {
        /// The key for the payload
        public static let _payloadPath: String = "gatewayRoute"

        /// The full description of your gateway route.
        public let gatewayRoute: GatewayRouteData

        public init(gatewayRoute: GatewayRouteData) {
            self.gatewayRoute = gatewayRoute
        }

        private enum CodingKeys: String, CodingKey {
            case gatewayRoute
        }
    }

    public struct DescribeMeshInput: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "meshName", location: .uri(locationName: "meshName")),
            AWSMemberEncoding(label: "meshOwner", location: .querystring(locationName: "meshOwner"))
        ]

        /// The name of the service mesh to describe.
        public let meshName: String
        /// The AWS IAM account ID of the service mesh owner. If the account ID is not your own, then it's the ID of the account that shared the mesh with your account. For more information about mesh sharing, see Working with shared meshes.
        public let meshOwner: String?

        public init(meshName: String, meshOwner: String? = nil) {
            self.meshName = meshName
            self.meshOwner = meshOwner
        }

        public func validate(name: String) throws {
            try self.validate(self.meshName, name: "meshName", parent: name, max: 255)
            try self.validate(self.meshName, name: "meshName", parent: name, min: 1)
            try self.validate(self.meshOwner, name: "meshOwner", parent: name, max: 12)
            try self.validate(self.meshOwner, name: "meshOwner", parent: name, min: 12)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DescribeMeshOutput: AWSDecodableShape & AWSShapeWithPayload {
        /// The key for the payload
        public static let _payloadPath: String = "mesh"

        /// The full description of your service mesh.
        public let mesh: MeshData

        public init(mesh: MeshData) {
            self.mesh = mesh
        }

        private enum CodingKeys: String, CodingKey {
            case mesh
        }
    }

    public struct DescribeRouteInput: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "meshName", location: .uri(locationName: "meshName")),
            AWSMemberEncoding(label: "meshOwner", location: .querystring(locationName: "meshOwner")),
            AWSMemberEncoding(label: "routeName", location: .uri(locationName: "routeName")),
            AWSMemberEncoding(label: "virtualRouterName", location: .uri(locationName: "virtualRouterName"))
        ]

        /// The name of the service mesh that the route resides in.
        public let meshName: String
        /// The AWS IAM account ID of the service mesh owner. If the account ID is not your own, then it's the ID of the account that shared the mesh with your account. For more information about mesh sharing, see Working with shared meshes.
        public let meshOwner: String?
        /// The name of the route to describe.
        public let routeName: String
        /// The name of the virtual router that the route is associated with.
        public let virtualRouterName: String

        public init(meshName: String, meshOwner: String? = nil, routeName: String, virtualRouterName: String) {
            self.meshName = meshName
            self.meshOwner = meshOwner
            self.routeName = routeName
            self.virtualRouterName = virtualRouterName
        }

        public func validate(name: String) throws {
            try self.validate(self.meshName, name: "meshName", parent: name, max: 255)
            try self.validate(self.meshName, name: "meshName", parent: name, min: 1)
            try self.validate(self.meshOwner, name: "meshOwner", parent: name, max: 12)
            try self.validate(self.meshOwner, name: "meshOwner", parent: name, min: 12)
            try self.validate(self.routeName, name: "routeName", parent: name, max: 255)
            try self.validate(self.routeName, name: "routeName", parent: name, min: 1)
            try self.validate(self.virtualRouterName, name: "virtualRouterName", parent: name, max: 255)
            try self.validate(self.virtualRouterName, name: "virtualRouterName", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DescribeRouteOutput: AWSDecodableShape & AWSShapeWithPayload {
        /// The key for the payload
        public static let _payloadPath: String = "route"

        /// The full description of your route.
        public let route: RouteData

        public init(route: RouteData) {
            self.route = route
        }

        private enum CodingKeys: String, CodingKey {
            case route
        }
    }

    public struct DescribeVirtualGatewayInput: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "meshName", location: .uri(locationName: "meshName")),
            AWSMemberEncoding(label: "meshOwner", location: .querystring(locationName: "meshOwner")),
            AWSMemberEncoding(label: "virtualGatewayName", location: .uri(locationName: "virtualGatewayName"))
        ]

        /// The name of the service mesh that the gateway route resides in.
        public let meshName: String
        /// The AWS IAM account ID of the service mesh owner. If the account ID is not your own, then it's the ID of the account that shared the mesh with your account. For more information about mesh sharing, see Working with shared meshes.
        public let meshOwner: String?
        /// The name of the virtual gateway to describe.
        public let virtualGatewayName: String

        public init(meshName: String, meshOwner: String? = nil, virtualGatewayName: String) {
            self.meshName = meshName
            self.meshOwner = meshOwner
            self.virtualGatewayName = virtualGatewayName
        }

        public func validate(name: String) throws {
            try self.validate(self.meshName, name: "meshName", parent: name, max: 255)
            try self.validate(self.meshName, name: "meshName", parent: name, min: 1)
            try self.validate(self.meshOwner, name: "meshOwner", parent: name, max: 12)
            try self.validate(self.meshOwner, name: "meshOwner", parent: name, min: 12)
            try self.validate(self.virtualGatewayName, name: "virtualGatewayName", parent: name, max: 255)
            try self.validate(self.virtualGatewayName, name: "virtualGatewayName", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DescribeVirtualGatewayOutput: AWSDecodableShape & AWSShapeWithPayload {
        /// The key for the payload
        public static let _payloadPath: String = "virtualGateway"

        /// The full description of your virtual gateway.
        public let virtualGateway: VirtualGatewayData

        public init(virtualGateway: VirtualGatewayData) {
            self.virtualGateway = virtualGateway
        }

        private enum CodingKeys: String, CodingKey {
            case virtualGateway
        }
    }

    public struct DescribeVirtualNodeInput: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "meshName", location: .uri(locationName: "meshName")),
            AWSMemberEncoding(label: "meshOwner", location: .querystring(locationName: "meshOwner")),
            AWSMemberEncoding(label: "virtualNodeName", location: .uri(locationName: "virtualNodeName"))
        ]

        /// The name of the service mesh that the virtual node resides in.
        public let meshName: String
        /// The AWS IAM account ID of the service mesh owner. If the account ID is not your own, then it's the ID of the account that shared the mesh with your account. For more information about mesh sharing, see Working with shared meshes.
        public let meshOwner: String?
        /// The name of the virtual node to describe.
        public let virtualNodeName: String

        public init(meshName: String, meshOwner: String? = nil, virtualNodeName: String) {
            self.meshName = meshName
            self.meshOwner = meshOwner
            self.virtualNodeName = virtualNodeName
        }

        public func validate(name: String) throws {
            try self.validate(self.meshName, name: "meshName", parent: name, max: 255)
            try self.validate(self.meshName, name: "meshName", parent: name, min: 1)
            try self.validate(self.meshOwner, name: "meshOwner", parent: name, max: 12)
            try self.validate(self.meshOwner, name: "meshOwner", parent: name, min: 12)
            try self.validate(self.virtualNodeName, name: "virtualNodeName", parent: name, max: 255)
            try self.validate(self.virtualNodeName, name: "virtualNodeName", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DescribeVirtualNodeOutput: AWSDecodableShape & AWSShapeWithPayload {
        /// The key for the payload
        public static let _payloadPath: String = "virtualNode"

        /// The full description of your virtual node.
        public let virtualNode: VirtualNodeData

        public init(virtualNode: VirtualNodeData) {
            self.virtualNode = virtualNode
        }

        private enum CodingKeys: String, CodingKey {
            case virtualNode
        }
    }

    public struct DescribeVirtualRouterInput: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "meshName", location: .uri(locationName: "meshName")),
            AWSMemberEncoding(label: "meshOwner", location: .querystring(locationName: "meshOwner")),
            AWSMemberEncoding(label: "virtualRouterName", location: .uri(locationName: "virtualRouterName"))
        ]

        /// The name of the service mesh that the virtual router resides in.
        public let meshName: String
        /// The AWS IAM account ID of the service mesh owner. If the account ID is not your own, then it's the ID of the account that shared the mesh with your account. For more information about mesh sharing, see Working with shared meshes.
        public let meshOwner: String?
        /// The name of the virtual router to describe.
        public let virtualRouterName: String

        public init(meshName: String, meshOwner: String? = nil, virtualRouterName: String) {
            self.meshName = meshName
            self.meshOwner = meshOwner
            self.virtualRouterName = virtualRouterName
        }

        public func validate(name: String) throws {
            try self.validate(self.meshName, name: "meshName", parent: name, max: 255)
            try self.validate(self.meshName, name: "meshName", parent: name, min: 1)
            try self.validate(self.meshOwner, name: "meshOwner", parent: name, max: 12)
            try self.validate(self.meshOwner, name: "meshOwner", parent: name, min: 12)
            try self.validate(self.virtualRouterName, name: "virtualRouterName", parent: name, max: 255)
            try self.validate(self.virtualRouterName, name: "virtualRouterName", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DescribeVirtualRouterOutput: AWSDecodableShape & AWSShapeWithPayload {
        /// The key for the payload
        public static let _payloadPath: String = "virtualRouter"

        /// The full description of your virtual router.
        public let virtualRouter: VirtualRouterData

        public init(virtualRouter: VirtualRouterData) {
            self.virtualRouter = virtualRouter
        }

        private enum CodingKeys: String, CodingKey {
            case virtualRouter
        }
    }

    public struct DescribeVirtualServiceInput: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "meshName", location: .uri(locationName: "meshName")),
            AWSMemberEncoding(label: "meshOwner", location: .querystring(locationName: "meshOwner")),
            AWSMemberEncoding(label: "virtualServiceName", location: .uri(locationName: "virtualServiceName"))
        ]

        /// The name of the service mesh that the virtual service resides in.
        public let meshName: String
        /// The AWS IAM account ID of the service mesh owner. If the account ID is not your own, then it's the ID of the account that shared the mesh with your account. For more information about mesh sharing, see Working with shared meshes.
        public let meshOwner: String?
        /// The name of the virtual service to describe.
        public let virtualServiceName: String

        public init(meshName: String, meshOwner: String? = nil, virtualServiceName: String) {
            self.meshName = meshName
            self.meshOwner = meshOwner
            self.virtualServiceName = virtualServiceName
        }

        public func validate(name: String) throws {
            try self.validate(self.meshName, name: "meshName", parent: name, max: 255)
            try self.validate(self.meshName, name: "meshName", parent: name, min: 1)
            try self.validate(self.meshOwner, name: "meshOwner", parent: name, max: 12)
            try self.validate(self.meshOwner, name: "meshOwner", parent: name, min: 12)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DescribeVirtualServiceOutput: AWSDecodableShape & AWSShapeWithPayload {
        /// The key for the payload
        public static let _payloadPath: String = "virtualService"

        /// The full description of your virtual service.
        public let virtualService: VirtualServiceData

        public init(virtualService: VirtualServiceData) {
            self.virtualService = virtualService
        }

        private enum CodingKeys: String, CodingKey {
            case virtualService
        }
    }

    public struct DnsServiceDiscovery: AWSEncodableShape & AWSDecodableShape {
        /// Specifies the DNS service discovery hostname for the virtual node.
        public let hostname: String
        /// Specifies the DNS response type for the virtual node.
        public let responseType: DnsResponseType?

        public init(hostname: String, responseType: DnsResponseType? = nil) {
            self.hostname = hostname
            self.responseType = responseType
        }

        private enum CodingKeys: String, CodingKey {
            case hostname
            case responseType
        }
    }

    public struct Duration: AWSEncodableShape & AWSDecodableShape {
        /// A unit of time.
        public let unit: DurationUnit?
        /// A number of time units.
        public let value: Int64?

        public init(unit: DurationUnit? = nil, value: Int64? = nil) {
            self.unit = unit
            self.value = value
        }

        public func validate(name: String) throws {
            try self.validate(self.value, name: "value", parent: name, min: 0)
        }

        private enum CodingKeys: String, CodingKey {
            case unit
            case value
        }
    }

    public struct EgressFilter: AWSEncodableShape & AWSDecodableShape {
        /// The egress filter type. By default, the type is DROP_ALL, which allows egress only from virtual nodes to other defined resources in the service mesh (and any traffic to *.amazonaws.com for Amazon Web Services API calls). You can set the egress filter type to ALLOW_ALL to allow egress to any endpoint inside or outside of the service mesh.
        public let type: EgressFilterType

        public init(type: EgressFilterType) {
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case type
        }
    }

    public struct FileAccessLog: AWSEncodableShape & AWSDecodableShape {
        /// The file path to write access logs to. You can use /dev/stdout to send access logs to standard out and configure your Envoy container to use a log driver, such as awslogs, to export the access logs to a log storage service such as Amazon CloudWatch Logs. You can also specify a path in the Envoy container's file system to write the files to disk.  The Envoy process must have write permissions to the path that you specify here. Otherwise, Envoy fails to bootstrap properly.
        public let path: String

        public init(path: String) {
            self.path = path
        }

        public func validate(name: String) throws {
            try self.validate(self.path, name: "path", parent: name, max: 255)
            try self.validate(self.path, name: "path", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case path
        }
    }

    public struct GatewayRouteData: AWSDecodableShape {
        /// The name of the gateway route.
        public let gatewayRouteName: String
        /// The name of the service mesh that the resource resides in.
        public let meshName: String
        public let metadata: ResourceMetadata
        /// The specifications of the gateway route.
        public let spec: GatewayRouteSpec
        /// The status of the gateway route.
        public let status: GatewayRouteStatus
        /// The virtual gateway that the gateway route is associated with.
        public let virtualGatewayName: String

        public init(gatewayRouteName: String, meshName: String, metadata: ResourceMetadata, spec: GatewayRouteSpec, status: GatewayRouteStatus, virtualGatewayName: String) {
            self.gatewayRouteName = gatewayRouteName
            self.meshName = meshName
            self.metadata = metadata
            self.spec = spec
            self.status = status
            self.virtualGatewayName = virtualGatewayName
        }

        private enum CodingKeys: String, CodingKey {
            case gatewayRouteName
            case meshName
            case metadata
            case spec
            case status
            case virtualGatewayName
        }
    }

    public struct GatewayRouteHostnameMatch: AWSEncodableShape & AWSDecodableShape {
        /// The exact host name to match on.
        public let exact: String?
        /// The specified ending characters of the host name to match on.
        public let suffix: String?

        public init(exact: String? = nil, suffix: String? = nil) {
            self.exact = exact
            self.suffix = suffix
        }

        public func validate(name: String) throws {
            try self.validate(self.exact, name: "exact", parent: name, max: 253)
            try self.validate(self.exact, name: "exact", parent: name, min: 1)
            try self.validate(self.suffix, name: "suffix", parent: name, max: 253)
            try self.validate(self.suffix, name: "suffix", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case exact
            case suffix
        }
    }

    public struct GatewayRouteHostnameRewrite: AWSEncodableShape & AWSDecodableShape {
        /// The default target host name to write to.
        public let defaultTargetHostname: DefaultGatewayRouteRewrite?

        public init(defaultTargetHostname: DefaultGatewayRouteRewrite? = nil) {
            self.defaultTargetHostname = defaultTargetHostname
        }

        private enum CodingKeys: String, CodingKey {
            case defaultTargetHostname
        }
    }

    public struct GatewayRouteRef: AWSDecodableShape {
        /// The full Amazon Resource Name (ARN) for the gateway route.
        public let arn: String
        /// The Unix epoch timestamp in seconds for when the resource was created.
        public let createdAt: Date
        /// The name of the gateway route.
        public let gatewayRouteName: String
        /// The Unix epoch timestamp in seconds for when the resource was last updated.
        public let lastUpdatedAt: Date
        /// The name of the service mesh that the resource resides in.
        public let meshName: String
        /// The AWS IAM account ID of the service mesh owner. If the account ID is not your own, then it's the ID of the account that shared the mesh with your account. For more information about mesh sharing, see Working with shared meshes.
        public let meshOwner: String
        /// The AWS IAM account ID of the resource owner. If the account ID is not your own, then it's the ID of the mesh owner or of another account that the mesh is shared with. For more information about mesh sharing, see Working with shared meshes.
        public let resourceOwner: String
        /// The version of the resource. Resources are created at version 1, and this version is incremented each time that they're updated.
        public let version: Int64
        /// The virtual gateway that the gateway route is associated with.
        public let virtualGatewayName: String

        public init(arn: String, createdAt: Date, gatewayRouteName: String, lastUpdatedAt: Date, meshName: String, meshOwner: String, resourceOwner: String, version: Int64, virtualGatewayName: String) {
            self.arn = arn
            self.createdAt = createdAt
            self.gatewayRouteName = gatewayRouteName
            self.lastUpdatedAt = lastUpdatedAt
            self.meshName = meshName
            self.meshOwner = meshOwner
            self.resourceOwner = resourceOwner
            self.version = version
            self.virtualGatewayName = virtualGatewayName
        }

        private enum CodingKeys: String, CodingKey {
            case arn
            case createdAt
            case gatewayRouteName
            case lastUpdatedAt
            case meshName
            case meshOwner
            case resourceOwner
            case version
            case virtualGatewayName
        }
    }

    public struct GatewayRouteSpec: AWSEncodableShape & AWSDecodableShape {
        /// An object that represents the specification of a gRPC gateway route.
        public let grpcRoute: GrpcGatewayRoute?
        /// An object that represents the specification of an HTTP/2 gateway route.
        public let http2Route: HttpGatewayRoute?
        /// An object that represents the specification of an HTTP gateway route.
        public let httpRoute: HttpGatewayRoute?
        /// The ordering of the gateway routes spec.
        public let priority: Int?

        public init(grpcRoute: GrpcGatewayRoute? = nil, http2Route: HttpGatewayRoute? = nil, httpRoute: HttpGatewayRoute? = nil, priority: Int? = nil) {
            self.grpcRoute = grpcRoute
            self.http2Route = http2Route
            self.httpRoute = httpRoute
            self.priority = priority
        }

        public func validate(name: String) throws {
            try self.grpcRoute?.validate(name: "\(name).grpcRoute")
            try self.http2Route?.validate(name: "\(name).http2Route")
            try self.httpRoute?.validate(name: "\(name).httpRoute")
            try self.validate(self.priority, name: "priority", parent: name, max: 1000)
            try self.validate(self.priority, name: "priority", parent: name, min: 0)
        }

        private enum CodingKeys: String, CodingKey {
            case grpcRoute
            case http2Route
            case httpRoute
            case priority
        }
    }

    public struct GatewayRouteStatus: AWSDecodableShape {
        /// The current status for the gateway route.
        public let status: GatewayRouteStatusCode

        public init(status: GatewayRouteStatusCode) {
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case status
        }
    }

    public struct GatewayRouteTarget: AWSEncodableShape & AWSDecodableShape {
        /// An object that represents a virtual service gateway route target.
        public let virtualService: GatewayRouteVirtualService

        public init(virtualService: GatewayRouteVirtualService) {
            self.virtualService = virtualService
        }

        public func validate(name: String) throws {
            try self.virtualService.validate(name: "\(name).virtualService")
        }

        private enum CodingKeys: String, CodingKey {
            case virtualService
        }
    }

    public struct GatewayRouteVirtualService: AWSEncodableShape & AWSDecodableShape {
        /// The name of the virtual service that traffic is routed to.
        public let virtualServiceName: String

        public init(virtualServiceName: String) {
            self.virtualServiceName = virtualServiceName
        }

        public func validate(name: String) throws {
            try self.validate(self.virtualServiceName, name: "virtualServiceName", parent: name, max: 255)
            try self.validate(self.virtualServiceName, name: "virtualServiceName", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case virtualServiceName
        }
    }

    public struct GrpcGatewayRoute: AWSEncodableShape & AWSDecodableShape {
        /// An object that represents the action to take if a match is determined.
        public let action: GrpcGatewayRouteAction
        /// An object that represents the criteria for determining a request match.
        public let match: GrpcGatewayRouteMatch

        public init(action: GrpcGatewayRouteAction, match: GrpcGatewayRouteMatch) {
            self.action = action
            self.match = match
        }

        public func validate(name: String) throws {
            try self.action.validate(name: "\(name).action")
            try self.match.validate(name: "\(name).match")
        }

        private enum CodingKeys: String, CodingKey {
            case action
            case match
        }
    }

    public struct GrpcGatewayRouteAction: AWSEncodableShape & AWSDecodableShape {
        /// The gateway route action to rewrite.
        public let rewrite: GrpcGatewayRouteRewrite?
        /// An object that represents the target that traffic is routed to when a request matches the gateway route.
        public let target: GatewayRouteTarget

        public init(rewrite: GrpcGatewayRouteRewrite? = nil, target: GatewayRouteTarget) {
            self.rewrite = rewrite
            self.target = target
        }

        public func validate(name: String) throws {
            try self.target.validate(name: "\(name).target")
        }

        private enum CodingKeys: String, CodingKey {
            case rewrite
            case target
        }
    }

    public struct GrpcGatewayRouteMatch: AWSEncodableShape & AWSDecodableShape {
        /// The gateway route host name to be matched on.
        public let hostname: GatewayRouteHostnameMatch?
        /// The gateway route metadata to be matched on.
        public let metadata: [GrpcGatewayRouteMetadata]?
        /// The fully qualified domain name for the service to match from the request.
        public let serviceName: String?

        public init(hostname: GatewayRouteHostnameMatch? = nil, metadata: [GrpcGatewayRouteMetadata]? = nil, serviceName: String? = nil) {
            self.hostname = hostname
            self.metadata = metadata
            self.serviceName = serviceName
        }

        public func validate(name: String) throws {
            try self.hostname?.validate(name: "\(name).hostname")
            try self.metadata?.forEach {
                try $0.validate(name: "\(name).metadata[]")
            }
            try self.validate(self.metadata, name: "metadata", parent: name, max: 10)
            try self.validate(self.metadata, name: "metadata", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case hostname
            case metadata
            case serviceName
        }
    }

    public struct GrpcGatewayRouteMetadata: AWSEncodableShape & AWSDecodableShape {
        /// Specify True to match anything except the match criteria. The default value is False.
        public let invert: Bool?
        /// The criteria for determining a metadata match.
        public let match: GrpcMetadataMatchMethod?
        /// A name for the gateway route metadata.
        public let name: String

        public init(invert: Bool? = nil, match: GrpcMetadataMatchMethod? = nil, name: String) {
            self.invert = invert
            self.match = match
            self.name = name
        }

        public func validate(name: String) throws {
            try self.match?.validate(name: "\(name).match")
            try self.validate(self.name, name: "name", parent: name, max: 50)
            try self.validate(self.name, name: "name", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case invert
            case match
            case name
        }
    }

    public struct GrpcGatewayRouteRewrite: AWSEncodableShape & AWSDecodableShape {
        /// The host name of the gateway route to rewrite.
        public let hostname: GatewayRouteHostnameRewrite?

        public init(hostname: GatewayRouteHostnameRewrite? = nil) {
            self.hostname = hostname
        }

        private enum CodingKeys: String, CodingKey {
            case hostname
        }
    }

    public struct GrpcMetadataMatchMethod: AWSEncodableShape & AWSDecodableShape {
        /// The exact method header to be matched on.
        public let exact: String?
        /// The specified beginning characters of the method header to be matched on.
        public let prefix: String?
        public let range: MatchRange?
        /// The regex used to match the method header.
        public let regex: String?
        /// The specified ending characters of the method header to match on.
        public let suffix: String?

        public init(exact: String? = nil, prefix: String? = nil, range: MatchRange? = nil, regex: String? = nil, suffix: String? = nil) {
            self.exact = exact
            self.prefix = prefix
            self.range = range
            self.regex = regex
            self.suffix = suffix
        }

        public func validate(name: String) throws {
            try self.validate(self.exact, name: "exact", parent: name, max: 255)
            try self.validate(self.exact, name: "exact", parent: name, min: 1)
            try self.validate(self.prefix, name: "prefix", parent: name, max: 255)
            try self.validate(self.prefix, name: "prefix", parent: name, min: 1)
            try self.validate(self.regex, name: "regex", parent: name, max: 255)
            try self.validate(self.regex, name: "regex", parent: name, min: 1)
            try self.validate(self.suffix, name: "suffix", parent: name, max: 255)
            try self.validate(self.suffix, name: "suffix", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case exact
            case prefix
            case range
            case regex
            case suffix
        }
    }

    public struct GrpcRetryPolicy: AWSEncodableShape & AWSDecodableShape {
        /// Specify at least one of the valid values.
        public let grpcRetryEvents: [GrpcRetryPolicyEvent]?
        /// Specify at least one of the following values.    server-error – HTTP status codes 500, 501, 502, 503, 504, 505, 506, 507, 508, 510, and 511    gateway-error – HTTP status codes 502, 503, and 504    client-error – HTTP status code 409    stream-error – Retry on refused stream
        public let httpRetryEvents: [String]?
        /// The maximum number of retry attempts.
        public let maxRetries: Int64
        /// The timeout for each retry attempt.
        public let perRetryTimeout: Duration
        /// Specify a valid value. The event occurs before any processing of a request has started and is encountered when the upstream is temporarily or permanently unavailable.
        public let tcpRetryEvents: [TcpRetryPolicyEvent]?

        public init(grpcRetryEvents: [GrpcRetryPolicyEvent]? = nil, httpRetryEvents: [String]? = nil, maxRetries: Int64, perRetryTimeout: Duration, tcpRetryEvents: [TcpRetryPolicyEvent]? = nil) {
            self.grpcRetryEvents = grpcRetryEvents
            self.httpRetryEvents = httpRetryEvents
            self.maxRetries = maxRetries
            self.perRetryTimeout = perRetryTimeout
            self.tcpRetryEvents = tcpRetryEvents
        }

        public func validate(name: String) throws {
            try self.validate(self.grpcRetryEvents, name: "grpcRetryEvents", parent: name, max: 5)
            try self.validate(self.grpcRetryEvents, name: "grpcRetryEvents", parent: name, min: 1)
            try self.httpRetryEvents?.forEach {
                try validate($0, name: "httpRetryEvents[]", parent: name, max: 25)
                try validate($0, name: "httpRetryEvents[]", parent: name, min: 1)
            }
            try self.validate(self.httpRetryEvents, name: "httpRetryEvents", parent: name, max: 25)
            try self.validate(self.httpRetryEvents, name: "httpRetryEvents", parent: name, min: 1)
            try self.validate(self.maxRetries, name: "maxRetries", parent: name, min: 0)
            try self.perRetryTimeout.validate(name: "\(name).perRetryTimeout")
            try self.validate(self.tcpRetryEvents, name: "tcpRetryEvents", parent: name, max: 1)
            try self.validate(self.tcpRetryEvents, name: "tcpRetryEvents", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case grpcRetryEvents
            case httpRetryEvents
            case maxRetries
            case perRetryTimeout
            case tcpRetryEvents
        }
    }

    public struct GrpcRoute: AWSEncodableShape & AWSDecodableShape {
        /// An object that represents the action to take if a match is determined.
        public let action: GrpcRouteAction
        /// An object that represents the criteria for determining a request match.
        public let match: GrpcRouteMatch
        /// An object that represents a retry policy.
        public let retryPolicy: GrpcRetryPolicy?
        /// An object that represents types of timeouts.
        public let timeout: GrpcTimeout?

        public init(action: GrpcRouteAction, match: GrpcRouteMatch, retryPolicy: GrpcRetryPolicy? = nil, timeout: GrpcTimeout? = nil) {
            self.action = action
            self.match = match
            self.retryPolicy = retryPolicy
            self.timeout = timeout
        }

        public func validate(name: String) throws {
            try self.action.validate(name: "\(name).action")
            try self.match.validate(name: "\(name).match")
            try self.retryPolicy?.validate(name: "\(name).retryPolicy")
            try self.timeout?.validate(name: "\(name).timeout")
        }

        private enum CodingKeys: String, CodingKey {
            case action
            case match
            case retryPolicy
            case timeout
        }
    }

    public struct GrpcRouteAction: AWSEncodableShape & AWSDecodableShape {
        /// An object that represents the targets that traffic is routed to when a request matches the route.
        public let weightedTargets: [WeightedTarget]

        public init(weightedTargets: [WeightedTarget]) {
            self.weightedTargets = weightedTargets
        }

        public func validate(name: String) throws {
            try self.weightedTargets.forEach {
                try $0.validate(name: "\(name).weightedTargets[]")
            }
            try self.validate(self.weightedTargets, name: "weightedTargets", parent: name, max: 10)
            try self.validate(self.weightedTargets, name: "weightedTargets", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case weightedTargets
        }
    }

    public struct GrpcRouteMatch: AWSEncodableShape & AWSDecodableShape {
        /// An object that represents the data to match from the request.
        public let metadata: [GrpcRouteMetadata]?
        /// The method name to match from the request. If you specify a name, you must also specify a serviceName.
        public let methodName: String?
        /// The fully qualified domain name for the service to match from the request.
        public let serviceName: String?

        public init(metadata: [GrpcRouteMetadata]? = nil, methodName: String? = nil, serviceName: String? = nil) {
            self.metadata = metadata
            self.methodName = methodName
            self.serviceName = serviceName
        }

        public func validate(name: String) throws {
            try self.metadata?.forEach {
                try $0.validate(name: "\(name).metadata[]")
            }
            try self.validate(self.metadata, name: "metadata", parent: name, max: 10)
            try self.validate(self.metadata, name: "metadata", parent: name, min: 1)
            try self.validate(self.methodName, name: "methodName", parent: name, max: 50)
            try self.validate(self.methodName, name: "methodName", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case metadata
            case methodName
            case serviceName
        }
    }

    public struct GrpcRouteMetadata: AWSEncodableShape & AWSDecodableShape {
        /// Specify True to match anything except the match criteria. The default value is False.
        public let invert: Bool?
        /// An object that represents the data to match from the request.
        public let match: GrpcRouteMetadataMatchMethod?
        /// The name of the route.
        public let name: String

        public init(invert: Bool? = nil, match: GrpcRouteMetadataMatchMethod? = nil, name: String) {
            self.invert = invert
            self.match = match
            self.name = name
        }

        public func validate(name: String) throws {
            try self.match?.validate(name: "\(name).match")
            try self.validate(self.name, name: "name", parent: name, max: 50)
            try self.validate(self.name, name: "name", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case invert
            case match
            case name
        }
    }

    public struct GrpcRouteMetadataMatchMethod: AWSEncodableShape & AWSDecodableShape {
        /// The value sent by the client must match the specified value exactly.
        public let exact: String?
        /// The value sent by the client must begin with the specified characters.
        public let prefix: String?
        /// An object that represents the range of values to match on.
        public let range: MatchRange?
        /// The value sent by the client must include the specified characters.
        public let regex: String?
        /// The value sent by the client must end with the specified characters.
        public let suffix: String?

        public init(exact: String? = nil, prefix: String? = nil, range: MatchRange? = nil, regex: String? = nil, suffix: String? = nil) {
            self.exact = exact
            self.prefix = prefix
            self.range = range
            self.regex = regex
            self.suffix = suffix
        }

        public func validate(name: String) throws {
            try self.validate(self.exact, name: "exact", parent: name, max: 255)
            try self.validate(self.exact, name: "exact", parent: name, min: 1)
            try self.validate(self.prefix, name: "prefix", parent: name, max: 255)
            try self.validate(self.prefix, name: "prefix", parent: name, min: 1)
            try self.validate(self.regex, name: "regex", parent: name, max: 255)
            try self.validate(self.regex, name: "regex", parent: name, min: 1)
            try self.validate(self.suffix, name: "suffix", parent: name, max: 255)
            try self.validate(self.suffix, name: "suffix", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case exact
            case prefix
            case range
            case regex
            case suffix
        }
    }

    public struct GrpcTimeout: AWSEncodableShape & AWSDecodableShape {
        /// An object that represents an idle timeout. An idle timeout bounds the amount of time that a connection may be idle. The default value is none.
        public let idle: Duration?
        /// An object that represents a per request timeout. The default value is 15 seconds. If you set a higher timeout, then make sure that the higher value is set for each App Mesh resource in a conversation. For example, if a virtual node backend uses a virtual router provider to route to another virtual node, then the timeout should be greater than 15 seconds for the source and destination virtual node and the route.
        public let perRequest: Duration?

        public init(idle: Duration? = nil, perRequest: Duration? = nil) {
            self.idle = idle
            self.perRequest = perRequest
        }

        public func validate(name: String) throws {
            try self.idle?.validate(name: "\(name).idle")
            try self.perRequest?.validate(name: "\(name).perRequest")
        }

        private enum CodingKeys: String, CodingKey {
            case idle
            case perRequest
        }
    }

    public struct HeaderMatchMethod: AWSEncodableShape & AWSDecodableShape {
        /// The value sent by the client must match the specified value exactly.
        public let exact: String?
        /// The value sent by the client must begin with the specified characters.
        public let prefix: String?
        /// An object that represents the range of values to match on.
        public let range: MatchRange?
        /// The value sent by the client must include the specified characters.
        public let regex: String?
        /// The value sent by the client must end with the specified characters.
        public let suffix: String?

        public init(exact: String? = nil, prefix: String? = nil, range: MatchRange? = nil, regex: String? = nil, suffix: String? = nil) {
            self.exact = exact
            self.prefix = prefix
            self.range = range
            self.regex = regex
            self.suffix = suffix
        }

        public func validate(name: String) throws {
            try self.validate(self.exact, name: "exact", parent: name, max: 255)
            try self.validate(self.exact, name: "exact", parent: name, min: 1)
            try self.validate(self.prefix, name: "prefix", parent: name, max: 255)
            try self.validate(self.prefix, name: "prefix", parent: name, min: 1)
            try self.validate(self.regex, name: "regex", parent: name, max: 255)
            try self.validate(self.regex, name: "regex", parent: name, min: 1)
            try self.validate(self.suffix, name: "suffix", parent: name, max: 255)
            try self.validate(self.suffix, name: "suffix", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case exact
            case prefix
            case range
            case regex
            case suffix
        }
    }

    public struct HealthCheckPolicy: AWSEncodableShape & AWSDecodableShape {
        /// The number of consecutive successful health checks that must occur before declaring listener healthy.
        public let healthyThreshold: Int
        /// The time period in milliseconds between each health check execution.
        public let intervalMillis: Int64
        /// The destination path for the health check request. This value is only used if the specified protocol is HTTP or HTTP/2. For any other protocol, this value is ignored.
        public let path: String?
        /// The destination port for the health check request. This port must match the port defined in the PortMapping for the listener.
        public let port: Int?
        /// The protocol for the health check request. If you specify grpc, then your service must conform to the GRPC Health Checking Protocol.
        public let `protocol`: PortProtocol
        /// The amount of time to wait when receiving a response from the health check, in milliseconds.
        public let timeoutMillis: Int64
        /// The number of consecutive failed health checks that must occur before declaring a virtual node unhealthy.
        public let unhealthyThreshold: Int

        public init(healthyThreshold: Int, intervalMillis: Int64, path: String? = nil, port: Int? = nil, protocol: PortProtocol, timeoutMillis: Int64, unhealthyThreshold: Int) {
            self.healthyThreshold = healthyThreshold
            self.intervalMillis = intervalMillis
            self.path = path
            self.port = port
            self.`protocol` = `protocol`
            self.timeoutMillis = timeoutMillis
            self.unhealthyThreshold = unhealthyThreshold
        }

        public func validate(name: String) throws {
            try self.validate(self.healthyThreshold, name: "healthyThreshold", parent: name, max: 10)
            try self.validate(self.healthyThreshold, name: "healthyThreshold", parent: name, min: 2)
            try self.validate(self.intervalMillis, name: "intervalMillis", parent: name, max: 300_000)
            try self.validate(self.intervalMillis, name: "intervalMillis", parent: name, min: 5000)
            try self.validate(self.port, name: "port", parent: name, max: 65535)
            try self.validate(self.port, name: "port", parent: name, min: 1)
            try self.validate(self.timeoutMillis, name: "timeoutMillis", parent: name, max: 60000)
            try self.validate(self.timeoutMillis, name: "timeoutMillis", parent: name, min: 2000)
            try self.validate(self.unhealthyThreshold, name: "unhealthyThreshold", parent: name, max: 10)
            try self.validate(self.unhealthyThreshold, name: "unhealthyThreshold", parent: name, min: 2)
        }

        private enum CodingKeys: String, CodingKey {
            case healthyThreshold
            case intervalMillis
            case path
            case port
            case `protocol`
            case timeoutMillis
            case unhealthyThreshold
        }
    }

    public struct HttpGatewayRoute: AWSEncodableShape & AWSDecodableShape {
        /// An object that represents the action to take if a match is determined.
        public let action: HttpGatewayRouteAction
        /// An object that represents the criteria for determining a request match.
        public let match: HttpGatewayRouteMatch

        public init(action: HttpGatewayRouteAction, match: HttpGatewayRouteMatch) {
            self.action = action
            self.match = match
        }

        public func validate(name: String) throws {
            try self.action.validate(name: "\(name).action")
            try self.match.validate(name: "\(name).match")
        }

        private enum CodingKeys: String, CodingKey {
            case action
            case match
        }
    }

    public struct HttpGatewayRouteAction: AWSEncodableShape & AWSDecodableShape {
        /// The gateway route action to rewrite.
        public let rewrite: HttpGatewayRouteRewrite?
        /// An object that represents the target that traffic is routed to when a request matches the gateway route.
        public let target: GatewayRouteTarget

        public init(rewrite: HttpGatewayRouteRewrite? = nil, target: GatewayRouteTarget) {
            self.rewrite = rewrite
            self.target = target
        }

        public func validate(name: String) throws {
            try self.rewrite?.validate(name: "\(name).rewrite")
            try self.target.validate(name: "\(name).target")
        }

        private enum CodingKeys: String, CodingKey {
            case rewrite
            case target
        }
    }

    public struct HttpGatewayRouteHeader: AWSEncodableShape & AWSDecodableShape {
        /// Specify True to match anything except the match criteria. The default value is False.
        public let invert: Bool?
        public let match: HeaderMatchMethod?
        /// A name for the HTTP header in the gateway route that will be matched on.
        public let name: String

        public init(invert: Bool? = nil, match: HeaderMatchMethod? = nil, name: String) {
            self.invert = invert
            self.match = match
            self.name = name
        }

        public func validate(name: String) throws {
            try self.match?.validate(name: "\(name).match")
            try self.validate(self.name, name: "name", parent: name, max: 50)
            try self.validate(self.name, name: "name", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case invert
            case match
            case name
        }
    }

    public struct HttpGatewayRouteMatch: AWSEncodableShape & AWSDecodableShape {
        /// The client request headers to match on.
        public let headers: [HttpGatewayRouteHeader]?
        /// The host name to match on.
        public let hostname: GatewayRouteHostnameMatch?
        /// The method to match on.
        public let method: HttpMethod?
        /// The path to match on.
        public let path: HttpPathMatch?
        /// Specifies the path to match requests with. This parameter must always start with /, which by itself matches all requests to the virtual service name. You can also match for path-based routing of requests. For example, if your virtual service name is my-service.local and you want the route to match requests to my-service.local/metrics, your prefix should be /metrics.
        public let prefix: String?
        /// The query parameter to match on.
        public let queryParameters: [HttpQueryParameter]?

        public init(headers: [HttpGatewayRouteHeader]? = nil, hostname: GatewayRouteHostnameMatch? = nil, method: HttpMethod? = nil, path: HttpPathMatch? = nil, prefix: String? = nil, queryParameters: [HttpQueryParameter]? = nil) {
            self.headers = headers
            self.hostname = hostname
            self.method = method
            self.path = path
            self.prefix = prefix
            self.queryParameters = queryParameters
        }

        public func validate(name: String) throws {
            try self.headers?.forEach {
                try $0.validate(name: "\(name).headers[]")
            }
            try self.validate(self.headers, name: "headers", parent: name, max: 10)
            try self.validate(self.headers, name: "headers", parent: name, min: 1)
            try self.hostname?.validate(name: "\(name).hostname")
            try self.path?.validate(name: "\(name).path")
            try self.validate(self.queryParameters, name: "queryParameters", parent: name, max: 10)
            try self.validate(self.queryParameters, name: "queryParameters", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case headers
            case hostname
            case method
            case path
            case prefix
            case queryParameters
        }
    }

    public struct HttpGatewayRoutePathRewrite: AWSEncodableShape & AWSDecodableShape {
        /// The exact path to rewrite.
        public let exact: String?

        public init(exact: String? = nil) {
            self.exact = exact
        }

        public func validate(name: String) throws {
            try self.validate(self.exact, name: "exact", parent: name, max: 255)
            try self.validate(self.exact, name: "exact", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case exact
        }
    }

    public struct HttpGatewayRoutePrefixRewrite: AWSEncodableShape & AWSDecodableShape {
        /// The default prefix used to replace the incoming route prefix when rewritten.
        public let defaultPrefix: DefaultGatewayRouteRewrite?
        /// The value used to replace the incoming route prefix when rewritten.
        public let value: String?

        public init(defaultPrefix: DefaultGatewayRouteRewrite? = nil, value: String? = nil) {
            self.defaultPrefix = defaultPrefix
            self.value = value
        }

        public func validate(name: String) throws {
            try self.validate(self.value, name: "value", parent: name, max: 255)
            try self.validate(self.value, name: "value", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case defaultPrefix
            case value
        }
    }

    public struct HttpGatewayRouteRewrite: AWSEncodableShape & AWSDecodableShape {
        /// The host name to rewrite.
        public let hostname: GatewayRouteHostnameRewrite?
        /// The path to rewrite.
        public let path: HttpGatewayRoutePathRewrite?
        /// The specified beginning characters to rewrite.
        public let prefix: HttpGatewayRoutePrefixRewrite?

        public init(hostname: GatewayRouteHostnameRewrite? = nil, path: HttpGatewayRoutePathRewrite? = nil, prefix: HttpGatewayRoutePrefixRewrite? = nil) {
            self.hostname = hostname
            self.path = path
            self.prefix = prefix
        }

        public func validate(name: String) throws {
            try self.path?.validate(name: "\(name).path")
            try self.prefix?.validate(name: "\(name).prefix")
        }

        private enum CodingKeys: String, CodingKey {
            case hostname
            case path
            case prefix
        }
    }

    public struct HttpPathMatch: AWSEncodableShape & AWSDecodableShape {
        /// The exact path to match on.
        public let exact: String?
        /// The regex used to match the path.
        public let regex: String?

        public init(exact: String? = nil, regex: String? = nil) {
            self.exact = exact
            self.regex = regex
        }

        public func validate(name: String) throws {
            try self.validate(self.exact, name: "exact", parent: name, max: 255)
            try self.validate(self.exact, name: "exact", parent: name, min: 1)
            try self.validate(self.regex, name: "regex", parent: name, max: 255)
            try self.validate(self.regex, name: "regex", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case exact
            case regex
        }
    }

    public struct HttpQueryParameter: AWSEncodableShape & AWSDecodableShape {
        /// The query parameter to match on.
        public let match: QueryParameterMatch?
        /// A name for the query parameter that will be matched on.
        public let name: String

        public init(match: QueryParameterMatch? = nil, name: String) {
            self.match = match
            self.name = name
        }

        private enum CodingKeys: String, CodingKey {
            case match
            case name
        }
    }

    public struct HttpRetryPolicy: AWSEncodableShape & AWSDecodableShape {
        /// Specify at least one of the following values.    server-error – HTTP status codes 500, 501, 502, 503, 504, 505, 506, 507, 508, 510, and 511    gateway-error – HTTP status codes 502, 503, and 504    client-error – HTTP status code 409    stream-error – Retry on refused stream
        public let httpRetryEvents: [String]?
        /// The maximum number of retry attempts.
        public let maxRetries: Int64
        /// The timeout for each retry attempt.
        public let perRetryTimeout: Duration
        /// Specify a valid value. The event occurs before any processing of a request has started and is encountered when the upstream is temporarily or permanently unavailable.
        public let tcpRetryEvents: [TcpRetryPolicyEvent]?

        public init(httpRetryEvents: [String]? = nil, maxRetries: Int64, perRetryTimeout: Duration, tcpRetryEvents: [TcpRetryPolicyEvent]? = nil) {
            self.httpRetryEvents = httpRetryEvents
            self.maxRetries = maxRetries
            self.perRetryTimeout = perRetryTimeout
            self.tcpRetryEvents = tcpRetryEvents
        }

        public func validate(name: String) throws {
            try self.httpRetryEvents?.forEach {
                try validate($0, name: "httpRetryEvents[]", parent: name, max: 25)
                try validate($0, name: "httpRetryEvents[]", parent: name, min: 1)
            }
            try self.validate(self.httpRetryEvents, name: "httpRetryEvents", parent: name, max: 25)
            try self.validate(self.httpRetryEvents, name: "httpRetryEvents", parent: name, min: 1)
            try self.validate(self.maxRetries, name: "maxRetries", parent: name, min: 0)
            try self.perRetryTimeout.validate(name: "\(name).perRetryTimeout")
            try self.validate(self.tcpRetryEvents, name: "tcpRetryEvents", parent: name, max: 1)
            try self.validate(self.tcpRetryEvents, name: "tcpRetryEvents", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case httpRetryEvents
            case maxRetries
            case perRetryTimeout
            case tcpRetryEvents
        }
    }

    public struct HttpRoute: AWSEncodableShape & AWSDecodableShape {
        /// An object that represents the action to take if a match is determined.
        public let action: HttpRouteAction
        /// An object that represents the criteria for determining a request match.
        public let match: HttpRouteMatch
        /// An object that represents a retry policy.
        public let retryPolicy: HttpRetryPolicy?
        /// An object that represents types of timeouts.
        public let timeout: HttpTimeout?

        public init(action: HttpRouteAction, match: HttpRouteMatch, retryPolicy: HttpRetryPolicy? = nil, timeout: HttpTimeout? = nil) {
            self.action = action
            self.match = match
            self.retryPolicy = retryPolicy
            self.timeout = timeout
        }

        public func validate(name: String) throws {
            try self.action.validate(name: "\(name).action")
            try self.match.validate(name: "\(name).match")
            try self.retryPolicy?.validate(name: "\(name).retryPolicy")
            try self.timeout?.validate(name: "\(name).timeout")
        }

        private enum CodingKeys: String, CodingKey {
            case action
            case match
            case retryPolicy
            case timeout
        }
    }

    public struct HttpRouteAction: AWSEncodableShape & AWSDecodableShape {
        /// An object that represents the targets that traffic is routed to when a request matches the route.
        public let weightedTargets: [WeightedTarget]

        public init(weightedTargets: [WeightedTarget]) {
            self.weightedTargets = weightedTargets
        }

        public func validate(name: String) throws {
            try self.weightedTargets.forEach {
                try $0.validate(name: "\(name).weightedTargets[]")
            }
            try self.validate(self.weightedTargets, name: "weightedTargets", parent: name, max: 10)
            try self.validate(self.weightedTargets, name: "weightedTargets", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case weightedTargets
        }
    }

    public struct HttpRouteHeader: AWSEncodableShape & AWSDecodableShape {
        /// Specify True to match anything except the match criteria. The default value is False.
        public let invert: Bool?
        /// The HeaderMatchMethod object.
        public let match: HeaderMatchMethod?
        /// A name for the HTTP header in the client request that will be matched on.
        public let name: String

        public init(invert: Bool? = nil, match: HeaderMatchMethod? = nil, name: String) {
            self.invert = invert
            self.match = match
            self.name = name
        }

        public func validate(name: String) throws {
            try self.match?.validate(name: "\(name).match")
            try self.validate(self.name, name: "name", parent: name, max: 50)
            try self.validate(self.name, name: "name", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case invert
            case match
            case name
        }
    }

    public struct HttpRouteMatch: AWSEncodableShape & AWSDecodableShape {
        /// The client request headers to match on.
        public let headers: [HttpRouteHeader]?
        /// The client request method to match on. Specify only one.
        public let method: HttpMethod?
        /// The client request path to match on.
        public let path: HttpPathMatch?
        /// Specifies the path to match requests with. This parameter must always start with /, which by itself matches all requests to the virtual service name. You can also match for path-based routing of requests. For example, if your virtual service name is my-service.local and you want the route to match requests to my-service.local/metrics, your prefix should be /metrics.
        public let prefix: String?
        /// The client request query parameters to match on.
        public let queryParameters: [HttpQueryParameter]?
        /// The client request scheme to match on. Specify only one. Applicable only for HTTP2 routes.
        public let scheme: HttpScheme?

        public init(headers: [HttpRouteHeader]? = nil, method: HttpMethod? = nil, path: HttpPathMatch? = nil, prefix: String? = nil, queryParameters: [HttpQueryParameter]? = nil, scheme: HttpScheme? = nil) {
            self.headers = headers
            self.method = method
            self.path = path
            self.prefix = prefix
            self.queryParameters = queryParameters
            self.scheme = scheme
        }

        public func validate(name: String) throws {
            try self.headers?.forEach {
                try $0.validate(name: "\(name).headers[]")
            }
            try self.validate(self.headers, name: "headers", parent: name, max: 10)
            try self.validate(self.headers, name: "headers", parent: name, min: 1)
            try self.path?.validate(name: "\(name).path")
            try self.validate(self.queryParameters, name: "queryParameters", parent: name, max: 10)
            try self.validate(self.queryParameters, name: "queryParameters", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case headers
            case method
            case path
            case prefix
            case queryParameters
            case scheme
        }
    }

    public struct HttpTimeout: AWSEncodableShape & AWSDecodableShape {
        /// An object that represents an idle timeout. An idle timeout bounds the amount of time that a connection may be idle. The default value is none.
        public let idle: Duration?
        /// An object that represents a per request timeout. The default value is 15 seconds. If you set a higher timeout, then make sure that the higher value is set for each App Mesh resource in a conversation. For example, if a virtual node backend uses a virtual router provider to route to another virtual node, then the timeout should be greater than 15 seconds for the source and destination virtual node and the route.
        public let perRequest: Duration?

        public init(idle: Duration? = nil, perRequest: Duration? = nil) {
            self.idle = idle
            self.perRequest = perRequest
        }

        public func validate(name: String) throws {
            try self.idle?.validate(name: "\(name).idle")
            try self.perRequest?.validate(name: "\(name).perRequest")
        }

        private enum CodingKeys: String, CodingKey {
            case idle
            case perRequest
        }
    }

    public struct ListGatewayRoutesInput: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "limit", location: .querystring(locationName: "limit")),
            AWSMemberEncoding(label: "meshName", location: .uri(locationName: "meshName")),
            AWSMemberEncoding(label: "meshOwner", location: .querystring(locationName: "meshOwner")),
            AWSMemberEncoding(label: "nextToken", location: .querystring(locationName: "nextToken")),
            AWSMemberEncoding(label: "virtualGatewayName", location: .uri(locationName: "virtualGatewayName"))
        ]

        /// The maximum number of results returned by ListGatewayRoutes in paginated output. When you use this parameter, ListGatewayRoutes returns only limit results in a single page along with a nextToken response element. You can see the remaining results of the initial request by sending another ListGatewayRoutes request with the returned nextToken value. This value can be between 1 and 100. If you don't use this parameter, ListGatewayRoutes returns up to 100 results and a nextToken value if applicable.
        public let limit: Int?
        /// The name of the service mesh to list gateway routes in.
        public let meshName: String
        /// The AWS IAM account ID of the service mesh owner. If the account ID is not your own, then it's the ID of the account that shared the mesh with your account. For more information about mesh sharing, see Working with shared meshes.
        public let meshOwner: String?
        /// The nextToken value returned from a previous paginated ListGatewayRoutes request where limit was used and the results exceeded the value of that parameter. Pagination continues from the end of the previous results that returned the nextToken value.
        public let nextToken: String?
        /// The name of the virtual gateway to list gateway routes in.
        public let virtualGatewayName: String

        public init(limit: Int? = nil, meshName: String, meshOwner: String? = nil, nextToken: String? = nil, virtualGatewayName: String) {
            self.limit = limit
            self.meshName = meshName
            self.meshOwner = meshOwner
            self.nextToken = nextToken
            self.virtualGatewayName = virtualGatewayName
        }

        public func validate(name: String) throws {
            try self.validate(self.limit, name: "limit", parent: name, max: 100)
            try self.validate(self.limit, name: "limit", parent: name, min: 1)
            try self.validate(self.meshName, name: "meshName", parent: name, max: 255)
            try self.validate(self.meshName, name: "meshName", parent: name, min: 1)
            try self.validate(self.meshOwner, name: "meshOwner", parent: name, max: 12)
            try self.validate(self.meshOwner, name: "meshOwner", parent: name, min: 12)
            try self.validate(self.virtualGatewayName, name: "virtualGatewayName", parent: name, max: 255)
            try self.validate(self.virtualGatewayName, name: "virtualGatewayName", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListGatewayRoutesOutput: AWSDecodableShape {
        /// The list of existing gateway routes for the specified service mesh and virtual gateway.
        public let gatewayRoutes: [GatewayRouteRef]
        /// The nextToken value to include in a future ListGatewayRoutes request. When the results of a ListGatewayRoutes request exceed limit, you can use this value to retrieve the next page of results. This value is null when there are no more results to return.
        public let nextToken: String?

        public init(gatewayRoutes: [GatewayRouteRef], nextToken: String? = nil) {
            self.gatewayRoutes = gatewayRoutes
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case gatewayRoutes
            case nextToken
        }
    }

    public struct ListMeshesInput: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "limit", location: .querystring(locationName: "limit")),
            AWSMemberEncoding(label: "nextToken", location: .querystring(locationName: "nextToken"))
        ]

        /// The maximum number of results returned by ListMeshes in paginated output. When you use this parameter, ListMeshes returns only limit results in a single page along with a nextToken response element. You can see the remaining results of the initial request by sending another ListMeshes request with the returned nextToken value. This value can be between 1 and 100. If you don't use this parameter, ListMeshes returns up to 100 results and a nextToken value if applicable.
        public let limit: Int?
        /// The nextToken value returned from a previous paginated ListMeshes request where limit was used and the results exceeded the value of that parameter. Pagination continues from the end of the previous results that returned the nextToken value.  This token should be treated as an opaque identifier that is used only to retrieve the next items in a list and not for other programmatic purposes.
        public let nextToken: String?

        public init(limit: Int? = nil, nextToken: String? = nil) {
            self.limit = limit
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.validate(self.limit, name: "limit", parent: name, max: 100)
            try self.validate(self.limit, name: "limit", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListMeshesOutput: AWSDecodableShape {
        /// The list of existing service meshes.
        public let meshes: [MeshRef]
        /// The nextToken value to include in a future ListMeshes request. When the results of a ListMeshes request exceed limit, you can use this value to retrieve the next page of results. This value is null when there are no more results to return.
        public let nextToken: String?

        public init(meshes: [MeshRef], nextToken: String? = nil) {
            self.meshes = meshes
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case meshes
            case nextToken
        }
    }

    public struct ListRoutesInput: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "limit", location: .querystring(locationName: "limit")),
            AWSMemberEncoding(label: "meshName", location: .uri(locationName: "meshName")),
            AWSMemberEncoding(label: "meshOwner", location: .querystring(locationName: "meshOwner")),
            AWSMemberEncoding(label: "nextToken", location: .querystring(locationName: "nextToken")),
            AWSMemberEncoding(label: "virtualRouterName", location: .uri(locationName: "virtualRouterName"))
        ]

        /// The maximum number of results returned by ListRoutes in paginated output. When you use this parameter, ListRoutes returns only limit results in a single page along with a nextToken response element. You can see the remaining results of the initial request by sending another ListRoutes request with the returned nextToken value. This value can be between 1 and 100. If you don't use this parameter, ListRoutes returns up to 100 results and a nextToken value if applicable.
        public let limit: Int?
        /// The name of the service mesh to list routes in.
        public let meshName: String
        /// The AWS IAM account ID of the service mesh owner. If the account ID is not your own, then it's the ID of the account that shared the mesh with your account. For more information about mesh sharing, see Working with shared meshes.
        public let meshOwner: String?
        /// The nextToken value returned from a previous paginated ListRoutes request where limit was used and the results exceeded the value of that parameter. Pagination continues from the end of the previous results that returned the nextToken value.
        public let nextToken: String?
        /// The name of the virtual router to list routes in.
        public let virtualRouterName: String

        public init(limit: Int? = nil, meshName: String, meshOwner: String? = nil, nextToken: String? = nil, virtualRouterName: String) {
            self.limit = limit
            self.meshName = meshName
            self.meshOwner = meshOwner
            self.nextToken = nextToken
            self.virtualRouterName = virtualRouterName
        }

        public func validate(name: String) throws {
            try self.validate(self.limit, name: "limit", parent: name, max: 100)
            try self.validate(self.limit, name: "limit", parent: name, min: 1)
            try self.validate(self.meshName, name: "meshName", parent: name, max: 255)
            try self.validate(self.meshName, name: "meshName", parent: name, min: 1)
            try self.validate(self.meshOwner, name: "meshOwner", parent: name, max: 12)
            try self.validate(self.meshOwner, name: "meshOwner", parent: name, min: 12)
            try self.validate(self.virtualRouterName, name: "virtualRouterName", parent: name, max: 255)
            try self.validate(self.virtualRouterName, name: "virtualRouterName", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListRoutesOutput: AWSDecodableShape {
        /// The nextToken value to include in a future ListRoutes request. When the results of a ListRoutes request exceed limit, you can use this value to retrieve the next page of results. This value is null when there are no more results to return.
        public let nextToken: String?
        /// The list of existing routes for the specified service mesh and virtual router.
        public let routes: [RouteRef]

        public init(nextToken: String? = nil, routes: [RouteRef]) {
            self.nextToken = nextToken
            self.routes = routes
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken
            case routes
        }
    }

    public struct ListTagsForResourceInput: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "limit", location: .querystring(locationName: "limit")),
            AWSMemberEncoding(label: "nextToken", location: .querystring(locationName: "nextToken")),
            AWSMemberEncoding(label: "resourceArn", location: .querystring(locationName: "resourceArn"))
        ]

        /// The maximum number of tag results returned by ListTagsForResource in paginated output. When this parameter is used, ListTagsForResource returns only limit results in a single page along with a nextToken response element. You can see the remaining results of the initial request by sending another ListTagsForResource request with the returned nextToken value. This value can be between 1 and 100. If you don't use this parameter, ListTagsForResource returns up to 100 results and a nextToken value if applicable.
        public let limit: Int?
        /// The nextToken value returned from a previous paginated ListTagsForResource request where limit was used and the results exceeded the value of that parameter. Pagination continues from the end of the previous results that returned the nextToken value.
        public let nextToken: String?
        /// The Amazon Resource Name (ARN) that identifies the resource to list the tags for.
        public let resourceArn: String

        public init(limit: Int? = nil, nextToken: String? = nil, resourceArn: String) {
            self.limit = limit
            self.nextToken = nextToken
            self.resourceArn = resourceArn
        }

        public func validate(name: String) throws {
            try self.validate(self.limit, name: "limit", parent: name, max: 50)
            try self.validate(self.limit, name: "limit", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListTagsForResourceOutput: AWSDecodableShape {
        /// The nextToken value to include in a future ListTagsForResource request. When the results of a ListTagsForResource request exceed limit, you can use this value to retrieve the next page of results. This value is null when there are no more results to return.
        public let nextToken: String?
        /// The tags for the resource.
        public let tags: [TagRef]

        public init(nextToken: String? = nil, tags: [TagRef]) {
            self.nextToken = nextToken
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken
            case tags
        }
    }

    public struct ListVirtualGatewaysInput: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "limit", location: .querystring(locationName: "limit")),
            AWSMemberEncoding(label: "meshName", location: .uri(locationName: "meshName")),
            AWSMemberEncoding(label: "meshOwner", location: .querystring(locationName: "meshOwner")),
            AWSMemberEncoding(label: "nextToken", location: .querystring(locationName: "nextToken"))
        ]

        /// The maximum number of results returned by ListVirtualGateways in paginated output. When you use this parameter, ListVirtualGateways returns only limit results in a single page along with a nextToken response element. You can see the remaining results of the initial request by sending another ListVirtualGateways request with the returned nextToken value. This value can be between 1 and 100. If you don't use this parameter, ListVirtualGateways returns up to 100 results and a nextToken value if applicable.
        public let limit: Int?
        /// The name of the service mesh to list virtual gateways in.
        public let meshName: String
        /// The AWS IAM account ID of the service mesh owner. If the account ID is not your own, then it's the ID of the account that shared the mesh with your account. For more information about mesh sharing, see Working with shared meshes.
        public let meshOwner: String?
        /// The nextToken value returned from a previous paginated ListVirtualGateways request where limit was used and the results exceeded the value of that parameter. Pagination continues from the end of the previous results that returned the nextToken value.
        public let nextToken: String?

        public init(limit: Int? = nil, meshName: String, meshOwner: String? = nil, nextToken: String? = nil) {
            self.limit = limit
            self.meshName = meshName
            self.meshOwner = meshOwner
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.validate(self.limit, name: "limit", parent: name, max: 100)
            try self.validate(self.limit, name: "limit", parent: name, min: 1)
            try self.validate(self.meshName, name: "meshName", parent: name, max: 255)
            try self.validate(self.meshName, name: "meshName", parent: name, min: 1)
            try self.validate(self.meshOwner, name: "meshOwner", parent: name, max: 12)
            try self.validate(self.meshOwner, name: "meshOwner", parent: name, min: 12)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListVirtualGatewaysOutput: AWSDecodableShape {
        /// The nextToken value to include in a future ListVirtualGateways request. When the results of a ListVirtualGateways request exceed limit, you can use this value to retrieve the next page of results. This value is null when there are no more results to return.
        public let nextToken: String?
        /// The list of existing virtual gateways for the specified service mesh.
        public let virtualGateways: [VirtualGatewayRef]

        public init(nextToken: String? = nil, virtualGateways: [VirtualGatewayRef]) {
            self.nextToken = nextToken
            self.virtualGateways = virtualGateways
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken
            case virtualGateways
        }
    }

    public struct ListVirtualNodesInput: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "limit", location: .querystring(locationName: "limit")),
            AWSMemberEncoding(label: "meshName", location: .uri(locationName: "meshName")),
            AWSMemberEncoding(label: "meshOwner", location: .querystring(locationName: "meshOwner")),
            AWSMemberEncoding(label: "nextToken", location: .querystring(locationName: "nextToken"))
        ]

        /// The maximum number of results returned by ListVirtualNodes in paginated output. When you use this parameter, ListVirtualNodes returns only limit results in a single page along with a nextToken response element. You can see the remaining results of the initial request by sending another ListVirtualNodes request with the returned nextToken value. This value can be between 1 and 100. If you don't use this parameter, ListVirtualNodes returns up to 100 results and a nextToken value if applicable.
        public let limit: Int?
        /// The name of the service mesh to list virtual nodes in.
        public let meshName: String
        /// The AWS IAM account ID of the service mesh owner. If the account ID is not your own, then it's the ID of the account that shared the mesh with your account. For more information about mesh sharing, see Working with shared meshes.
        public let meshOwner: String?
        /// The nextToken value returned from a previous paginated ListVirtualNodes request where limit was used and the results exceeded the value of that parameter. Pagination continues from the end of the previous results that returned the nextToken value.
        public let nextToken: String?

        public init(limit: Int? = nil, meshName: String, meshOwner: String? = nil, nextToken: String? = nil) {
            self.limit = limit
            self.meshName = meshName
            self.meshOwner = meshOwner
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.validate(self.limit, name: "limit", parent: name, max: 100)
            try self.validate(self.limit, name: "limit", parent: name, min: 1)
            try self.validate(self.meshName, name: "meshName", parent: name, max: 255)
            try self.validate(self.meshName, name: "meshName", parent: name, min: 1)
            try self.validate(self.meshOwner, name: "meshOwner", parent: name, max: 12)
            try self.validate(self.meshOwner, name: "meshOwner", parent: name, min: 12)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListVirtualNodesOutput: AWSDecodableShape {
        /// The nextToken value to include in a future ListVirtualNodes request. When the results of a ListVirtualNodes request exceed limit, you can use this value to retrieve the next page of results. This value is null when there are no more results to return.
        public let nextToken: String?
        /// The list of existing virtual nodes for the specified service mesh.
        public let virtualNodes: [VirtualNodeRef]

        public init(nextToken: String? = nil, virtualNodes: [VirtualNodeRef]) {
            self.nextToken = nextToken
            self.virtualNodes = virtualNodes
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken
            case virtualNodes
        }
    }

    public struct ListVirtualRoutersInput: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "limit", location: .querystring(locationName: "limit")),
            AWSMemberEncoding(label: "meshName", location: .uri(locationName: "meshName")),
            AWSMemberEncoding(label: "meshOwner", location: .querystring(locationName: "meshOwner")),
            AWSMemberEncoding(label: "nextToken", location: .querystring(locationName: "nextToken"))
        ]

        /// The maximum number of results returned by ListVirtualRouters in paginated output. When you use this parameter, ListVirtualRouters returns only limit results in a single page along with a nextToken response element. You can see the remaining results of the initial request by sending another ListVirtualRouters request with the returned nextToken value. This value can be between 1 and 100. If you don't use this parameter, ListVirtualRouters returns up to 100 results and a nextToken value if applicable.
        public let limit: Int?
        /// The name of the service mesh to list virtual routers in.
        public let meshName: String
        /// The AWS IAM account ID of the service mesh owner. If the account ID is not your own, then it's the ID of the account that shared the mesh with your account. For more information about mesh sharing, see Working with shared meshes.
        public let meshOwner: String?
        /// The nextToken value returned from a previous paginated ListVirtualRouters request where limit was used and the results exceeded the value of that parameter. Pagination continues from the end of the previous results that returned the nextToken value.
        public let nextToken: String?

        public init(limit: Int? = nil, meshName: String, meshOwner: String? = nil, nextToken: String? = nil) {
            self.limit = limit
            self.meshName = meshName
            self.meshOwner = meshOwner
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.validate(self.limit, name: "limit", parent: name, max: 100)
            try self.validate(self.limit, name: "limit", parent: name, min: 1)
            try self.validate(self.meshName, name: "meshName", parent: name, max: 255)
            try self.validate(self.meshName, name: "meshName", parent: name, min: 1)
            try self.validate(self.meshOwner, name: "meshOwner", parent: name, max: 12)
            try self.validate(self.meshOwner, name: "meshOwner", parent: name, min: 12)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListVirtualRoutersOutput: AWSDecodableShape {
        /// The nextToken value to include in a future ListVirtualRouters request. When the results of a ListVirtualRouters request exceed limit, you can use this value to retrieve the next page of results. This value is null when there are no more results to return.
        public let nextToken: String?
        /// The list of existing virtual routers for the specified service mesh.
        public let virtualRouters: [VirtualRouterRef]

        public init(nextToken: String? = nil, virtualRouters: [VirtualRouterRef]) {
            self.nextToken = nextToken
            self.virtualRouters = virtualRouters
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken
            case virtualRouters
        }
    }

    public struct ListVirtualServicesInput: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "limit", location: .querystring(locationName: "limit")),
            AWSMemberEncoding(label: "meshName", location: .uri(locationName: "meshName")),
            AWSMemberEncoding(label: "meshOwner", location: .querystring(locationName: "meshOwner")),
            AWSMemberEncoding(label: "nextToken", location: .querystring(locationName: "nextToken"))
        ]

        /// The maximum number of results returned by ListVirtualServices in paginated output. When you use this parameter, ListVirtualServices returns only limit results in a single page along with a nextToken response element. You can see the remaining results of the initial request by sending another ListVirtualServices request with the returned nextToken value. This value can be between 1 and 100. If you don't use this parameter, ListVirtualServices returns up to 100 results and a nextToken value if applicable.
        public let limit: Int?
        /// The name of the service mesh to list virtual services in.
        public let meshName: String
        /// The AWS IAM account ID of the service mesh owner. If the account ID is not your own, then it's the ID of the account that shared the mesh with your account. For more information about mesh sharing, see Working with shared meshes.
        public let meshOwner: String?
        /// The nextToken value returned from a previous paginated ListVirtualServices request where limit was used and the results exceeded the value of that parameter. Pagination continues from the end of the previous results that returned the nextToken value.
        public let nextToken: String?

        public init(limit: Int? = nil, meshName: String, meshOwner: String? = nil, nextToken: String? = nil) {
            self.limit = limit
            self.meshName = meshName
            self.meshOwner = meshOwner
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.validate(self.limit, name: "limit", parent: name, max: 100)
            try self.validate(self.limit, name: "limit", parent: name, min: 1)
            try self.validate(self.meshName, name: "meshName", parent: name, max: 255)
            try self.validate(self.meshName, name: "meshName", parent: name, min: 1)
            try self.validate(self.meshOwner, name: "meshOwner", parent: name, max: 12)
            try self.validate(self.meshOwner, name: "meshOwner", parent: name, min: 12)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListVirtualServicesOutput: AWSDecodableShape {
        /// The nextToken value to include in a future ListVirtualServices request. When the results of a ListVirtualServices request exceed limit, you can use this value to retrieve the next page of results. This value is null when there are no more results to return.
        public let nextToken: String?
        /// The list of existing virtual services for the specified service mesh.
        public let virtualServices: [VirtualServiceRef]

        public init(nextToken: String? = nil, virtualServices: [VirtualServiceRef]) {
            self.nextToken = nextToken
            self.virtualServices = virtualServices
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken
            case virtualServices
        }
    }

    public struct Listener: AWSEncodableShape & AWSDecodableShape {
        /// The connection pool information for the listener.
        public let connectionPool: VirtualNodeConnectionPool?
        /// The health check information for the listener.
        public let healthCheck: HealthCheckPolicy?
        /// The outlier detection information for the listener.
        public let outlierDetection: OutlierDetection?
        /// The port mapping information for the listener.
        public let portMapping: PortMapping
        /// An object that represents timeouts for different protocols.
        public let timeout: ListenerTimeout?
        /// A reference to an object that represents the Transport Layer Security (TLS) properties for a listener.
        public let tls: ListenerTls?

        public init(connectionPool: VirtualNodeConnectionPool? = nil, healthCheck: HealthCheckPolicy? = nil, outlierDetection: OutlierDetection? = nil, portMapping: PortMapping, timeout: ListenerTimeout? = nil, tls: ListenerTls? = nil) {
            self.connectionPool = connectionPool
            self.healthCheck = healthCheck
            self.outlierDetection = outlierDetection
            self.portMapping = portMapping
            self.timeout = timeout
            self.tls = tls
        }

        public func validate(name: String) throws {
            try self.connectionPool?.validate(name: "\(name).connectionPool")
            try self.healthCheck?.validate(name: "\(name).healthCheck")
            try self.outlierDetection?.validate(name: "\(name).outlierDetection")
            try self.portMapping.validate(name: "\(name).portMapping")
            try self.timeout?.validate(name: "\(name).timeout")
            try self.tls?.validate(name: "\(name).tls")
        }

        private enum CodingKeys: String, CodingKey {
            case connectionPool
            case healthCheck
            case outlierDetection
            case portMapping
            case timeout
            case tls
        }
    }

    public struct ListenerTimeout: AWSEncodableShape & AWSDecodableShape {
        /// An object that represents types of timeouts.
        public let grpc: GrpcTimeout?
        /// An object that represents types of timeouts.
        public let http: HttpTimeout?
        /// An object that represents types of timeouts.
        public let http2: HttpTimeout?
        /// An object that represents types of timeouts.
        public let tcp: TcpTimeout?

        public init(grpc: GrpcTimeout? = nil, http: HttpTimeout? = nil, http2: HttpTimeout? = nil, tcp: TcpTimeout? = nil) {
            self.grpc = grpc
            self.http = http
            self.http2 = http2
            self.tcp = tcp
        }

        public func validate(name: String) throws {
            try self.grpc?.validate(name: "\(name).grpc")
            try self.http?.validate(name: "\(name).http")
            try self.http2?.validate(name: "\(name).http2")
            try self.tcp?.validate(name: "\(name).tcp")
        }

        private enum CodingKeys: String, CodingKey {
            case grpc
            case http
            case http2
            case tcp
        }
    }

    public struct ListenerTls: AWSEncodableShape & AWSDecodableShape {
        /// A reference to an object that represents a listener's Transport Layer Security (TLS) certificate.
        public let certificate: ListenerTlsCertificate
        /// Specify one of the following modes.    STRICT – Listener only accepts connections with TLS enabled.     PERMISSIVE – Listener accepts connections with or without TLS enabled.    DISABLED – Listener only accepts connections without TLS.
        public let mode: ListenerTlsMode
        /// A reference to an object that represents a listener's Transport Layer Security (TLS) validation context.
        public let validation: ListenerTlsValidationContext?

        public init(certificate: ListenerTlsCertificate, mode: ListenerTlsMode, validation: ListenerTlsValidationContext? = nil) {
            self.certificate = certificate
            self.mode = mode
            self.validation = validation
        }

        public func validate(name: String) throws {
            try self.certificate.validate(name: "\(name).certificate")
            try self.validation?.validate(name: "\(name).validation")
        }

        private enum CodingKeys: String, CodingKey {
            case certificate
            case mode
            case validation
        }
    }

    public struct ListenerTlsAcmCertificate: AWSEncodableShape & AWSDecodableShape {
        /// The Amazon Resource Name (ARN) for the certificate. The certificate must meet specific requirements and you must have proxy authorization enabled. For more information, see Transport Layer Security (TLS).
        public let certificateArn: String

        public init(certificateArn: String) {
            self.certificateArn = certificateArn
        }

        private enum CodingKeys: String, CodingKey {
            case certificateArn
        }
    }

    public struct ListenerTlsCertificate: AWSEncodableShape & AWSDecodableShape {
        /// A reference to an object that represents an AWS Certicate Manager (ACM) certificate.
        public let acm: ListenerTlsAcmCertificate?
        /// A reference to an object that represents a local file certificate.
        public let file: ListenerTlsFileCertificate?
        /// A reference to an object that represents a listener's Secret Discovery Service certificate.
        public let sds: ListenerTlsSdsCertificate?

        public init(acm: ListenerTlsAcmCertificate? = nil, file: ListenerTlsFileCertificate? = nil, sds: ListenerTlsSdsCertificate? = nil) {
            self.acm = acm
            self.file = file
            self.sds = sds
        }

        public func validate(name: String) throws {
            try self.file?.validate(name: "\(name).file")
        }

        private enum CodingKeys: String, CodingKey {
            case acm
            case file
            case sds
        }
    }

    public struct ListenerTlsFileCertificate: AWSEncodableShape & AWSDecodableShape {
        /// The certificate chain for the certificate.
        public let certificateChain: String
        /// The private key for a certificate stored on the file system of the virtual node that the proxy is running on.
        public let privateKey: String

        public init(certificateChain: String, privateKey: String) {
            self.certificateChain = certificateChain
            self.privateKey = privateKey
        }

        public func validate(name: String) throws {
            try self.validate(self.certificateChain, name: "certificateChain", parent: name, max: 255)
            try self.validate(self.certificateChain, name: "certificateChain", parent: name, min: 1)
            try self.validate(self.privateKey, name: "privateKey", parent: name, max: 255)
            try self.validate(self.privateKey, name: "privateKey", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case certificateChain
            case privateKey
        }
    }

    public struct ListenerTlsSdsCertificate: AWSEncodableShape & AWSDecodableShape {
        /// A reference to an object that represents the name of the secret requested from the Secret Discovery Service provider representing Transport Layer Security (TLS) materials like a certificate or certificate chain.
        public let secretName: String

        public init(secretName: String) {
            self.secretName = secretName
        }

        private enum CodingKeys: String, CodingKey {
            case secretName
        }
    }

    public struct ListenerTlsValidationContext: AWSEncodableShape & AWSDecodableShape {
        /// A reference to an object that represents the SANs for a listener's Transport Layer Security (TLS) validation context.
        public let subjectAlternativeNames: SubjectAlternativeNames?
        /// A reference to where to retrieve the trust chain when validating a peer’s Transport Layer Security (TLS) certificate.
        public let trust: ListenerTlsValidationContextTrust

        public init(subjectAlternativeNames: SubjectAlternativeNames? = nil, trust: ListenerTlsValidationContextTrust) {
            self.subjectAlternativeNames = subjectAlternativeNames
            self.trust = trust
        }

        public func validate(name: String) throws {
            try self.subjectAlternativeNames?.validate(name: "\(name).subjectAlternativeNames")
            try self.trust.validate(name: "\(name).trust")
        }

        private enum CodingKeys: String, CodingKey {
            case subjectAlternativeNames
            case trust
        }
    }

    public struct ListenerTlsValidationContextTrust: AWSEncodableShape & AWSDecodableShape {
        /// An object that represents a Transport Layer Security (TLS) validation context trust for a local file.
        public let file: TlsValidationContextFileTrust?
        /// A reference to an object that represents a listener's Transport Layer Security (TLS) Secret Discovery Service validation context trust.
        public let sds: TlsValidationContextSdsTrust?

        public init(file: TlsValidationContextFileTrust? = nil, sds: TlsValidationContextSdsTrust? = nil) {
            self.file = file
            self.sds = sds
        }

        public func validate(name: String) throws {
            try self.file?.validate(name: "\(name).file")
        }

        private enum CodingKeys: String, CodingKey {
            case file
            case sds
        }
    }

    public struct Logging: AWSEncodableShape & AWSDecodableShape {
        /// The access log configuration for a virtual node.
        public let accessLog: AccessLog?

        public init(accessLog: AccessLog? = nil) {
            self.accessLog = accessLog
        }

        public func validate(name: String) throws {
            try self.accessLog?.validate(name: "\(name).accessLog")
        }

        private enum CodingKeys: String, CodingKey {
            case accessLog
        }
    }

    public struct MatchRange: AWSEncodableShape & AWSDecodableShape {
        /// The end of the range.
        public let end: Int64
        /// The start of the range.
        public let start: Int64

        public init(end: Int64, start: Int64) {
            self.end = end
            self.start = start
        }

        private enum CodingKeys: String, CodingKey {
            case end
            case start
        }
    }

    public struct MeshData: AWSDecodableShape {
        /// The name of the service mesh.
        public let meshName: String
        /// The associated metadata for the service mesh.
        public let metadata: ResourceMetadata
        /// The associated specification for the service mesh.
        public let spec: MeshSpec
        /// The status of the service mesh.
        public let status: MeshStatus

        public init(meshName: String, metadata: ResourceMetadata, spec: MeshSpec, status: MeshStatus) {
            self.meshName = meshName
            self.metadata = metadata
            self.spec = spec
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case meshName
            case metadata
            case spec
            case status
        }
    }

    public struct MeshRef: AWSDecodableShape {
        /// The full Amazon Resource Name (ARN) of the service mesh.
        public let arn: String
        /// The Unix epoch timestamp in seconds for when the resource was created.
        public let createdAt: Date
        /// The Unix epoch timestamp in seconds for when the resource was last updated.
        public let lastUpdatedAt: Date
        /// The name of the service mesh.
        public let meshName: String
        /// The AWS IAM account ID of the service mesh owner. If the account ID is not your own, then it's the ID of the account that shared the mesh with your account. For more information about mesh sharing, see Working with shared meshes.
        public let meshOwner: String
        /// The AWS IAM account ID of the resource owner. If the account ID is not your own, then it's the ID of the mesh owner or of another account that the mesh is shared with. For more information about mesh sharing, see Working with shared meshes.
        public let resourceOwner: String
        /// The version of the resource. Resources are created at version 1, and this version is incremented each time that they're updated.
        public let version: Int64

        public init(arn: String, createdAt: Date, lastUpdatedAt: Date, meshName: String, meshOwner: String, resourceOwner: String, version: Int64) {
            self.arn = arn
            self.createdAt = createdAt
            self.lastUpdatedAt = lastUpdatedAt
            self.meshName = meshName
            self.meshOwner = meshOwner
            self.resourceOwner = resourceOwner
            self.version = version
        }

        private enum CodingKeys: String, CodingKey {
            case arn
            case createdAt
            case lastUpdatedAt
            case meshName
            case meshOwner
            case resourceOwner
            case version
        }
    }

    public struct MeshSpec: AWSEncodableShape & AWSDecodableShape {
        /// The egress filter rules for the service mesh.
        public let egressFilter: EgressFilter?

        public init(egressFilter: EgressFilter? = nil) {
            self.egressFilter = egressFilter
        }

        private enum CodingKeys: String, CodingKey {
            case egressFilter
        }
    }

    public struct MeshStatus: AWSDecodableShape {
        /// The current mesh status.
        public let status: MeshStatusCode?

        public init(status: MeshStatusCode? = nil) {
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case status
        }
    }

    public struct OutlierDetection: AWSEncodableShape & AWSDecodableShape {
        /// The base amount of time for which a host is ejected.
        public let baseEjectionDuration: Duration
        /// The time interval between ejection sweep analysis.
        public let interval: Duration
        /// Maximum percentage of hosts in load balancing pool for upstream service that can be ejected. Will eject at least one host regardless of the value.
        public let maxEjectionPercent: Int
        /// Number of consecutive 5xx errors required for ejection.
        public let maxServerErrors: Int64

        public init(baseEjectionDuration: Duration, interval: Duration, maxEjectionPercent: Int, maxServerErrors: Int64) {
            self.baseEjectionDuration = baseEjectionDuration
            self.interval = interval
            self.maxEjectionPercent = maxEjectionPercent
            self.maxServerErrors = maxServerErrors
        }

        public func validate(name: String) throws {
            try self.baseEjectionDuration.validate(name: "\(name).baseEjectionDuration")
            try self.interval.validate(name: "\(name).interval")
            try self.validate(self.maxEjectionPercent, name: "maxEjectionPercent", parent: name, max: 100)
            try self.validate(self.maxEjectionPercent, name: "maxEjectionPercent", parent: name, min: 0)
            try self.validate(self.maxServerErrors, name: "maxServerErrors", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case baseEjectionDuration
            case interval
            case maxEjectionPercent
            case maxServerErrors
        }
    }

    public struct PortMapping: AWSEncodableShape & AWSDecodableShape {
        /// The port used for the port mapping.
        public let port: Int
        /// The protocol used for the port mapping. Specify one protocol.
        public let `protocol`: PortProtocol

        public init(port: Int, protocol: PortProtocol) {
            self.port = port
            self.`protocol` = `protocol`
        }

        public func validate(name: String) throws {
            try self.validate(self.port, name: "port", parent: name, max: 65535)
            try self.validate(self.port, name: "port", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case port
            case `protocol`
        }
    }

    public struct QueryParameterMatch: AWSEncodableShape & AWSDecodableShape {
        /// The exact query parameter to match on.
        public let exact: String?

        public init(exact: String? = nil) {
            self.exact = exact
        }

        private enum CodingKeys: String, CodingKey {
            case exact
        }
    }

    public struct ResourceMetadata: AWSDecodableShape {
        /// The full Amazon Resource Name (ARN) for the resource.
        public let arn: String
        /// The Unix epoch timestamp in seconds for when the resource was created.
        public let createdAt: Date
        /// The Unix epoch timestamp in seconds for when the resource was last updated.
        public let lastUpdatedAt: Date
        /// The AWS IAM account ID of the service mesh owner. If the account ID is not your own, then it's the ID of the account that shared the mesh with your account. For more information about mesh sharing, see Working with shared meshes.
        public let meshOwner: String
        /// The AWS IAM account ID of the resource owner. If the account ID is not your own, then it's the ID of the mesh owner or of another account that the mesh is shared with. For more information about mesh sharing, see Working with shared meshes.
        public let resourceOwner: String
        /// The unique identifier for the resource.
        public let uid: String
        /// The version of the resource. Resources are created at version 1, and this version is incremented each time that they're updated.
        public let version: Int64

        public init(arn: String, createdAt: Date, lastUpdatedAt: Date, meshOwner: String, resourceOwner: String, uid: String, version: Int64) {
            self.arn = arn
            self.createdAt = createdAt
            self.lastUpdatedAt = lastUpdatedAt
            self.meshOwner = meshOwner
            self.resourceOwner = resourceOwner
            self.uid = uid
            self.version = version
        }

        private enum CodingKeys: String, CodingKey {
            case arn
            case createdAt
            case lastUpdatedAt
            case meshOwner
            case resourceOwner
            case uid
            case version
        }
    }

    public struct RouteData: AWSDecodableShape {
        /// The name of the service mesh that the route resides in.
        public let meshName: String
        /// The associated metadata for the route.
        public let metadata: ResourceMetadata
        /// The name of the route.
        public let routeName: String
        /// The specifications of the route.
        public let spec: RouteSpec
        /// The status of the route.
        public let status: RouteStatus
        /// The virtual router that the route is associated with.
        public let virtualRouterName: String

        public init(meshName: String, metadata: ResourceMetadata, routeName: String, spec: RouteSpec, status: RouteStatus, virtualRouterName: String) {
            self.meshName = meshName
            self.metadata = metadata
            self.routeName = routeName
            self.spec = spec
            self.status = status
            self.virtualRouterName = virtualRouterName
        }

        private enum CodingKeys: String, CodingKey {
            case meshName
            case metadata
            case routeName
            case spec
            case status
            case virtualRouterName
        }
    }

    public struct RouteRef: AWSDecodableShape {
        /// The full Amazon Resource Name (ARN) for the route.
        public let arn: String
        /// The Unix epoch timestamp in seconds for when the resource was created.
        public let createdAt: Date
        /// The Unix epoch timestamp in seconds for when the resource was last updated.
        public let lastUpdatedAt: Date
        /// The name of the service mesh that the route resides in.
        public let meshName: String
        /// The AWS IAM account ID of the service mesh owner. If the account ID is not your own, then it's the ID of the account that shared the mesh with your account. For more information about mesh sharing, see Working with shared meshes.
        public let meshOwner: String
        /// The AWS IAM account ID of the resource owner. If the account ID is not your own, then it's the ID of the mesh owner or of another account that the mesh is shared with. For more information about mesh sharing, see Working with shared meshes.
        public let resourceOwner: String
        /// The name of the route.
        public let routeName: String
        /// The version of the resource. Resources are created at version 1, and this version is incremented each time that they're updated.
        public let version: Int64
        /// The virtual router that the route is associated with.
        public let virtualRouterName: String

        public init(arn: String, createdAt: Date, lastUpdatedAt: Date, meshName: String, meshOwner: String, resourceOwner: String, routeName: String, version: Int64, virtualRouterName: String) {
            self.arn = arn
            self.createdAt = createdAt
            self.lastUpdatedAt = lastUpdatedAt
            self.meshName = meshName
            self.meshOwner = meshOwner
            self.resourceOwner = resourceOwner
            self.routeName = routeName
            self.version = version
            self.virtualRouterName = virtualRouterName
        }

        private enum CodingKeys: String, CodingKey {
            case arn
            case createdAt
            case lastUpdatedAt
            case meshName
            case meshOwner
            case resourceOwner
            case routeName
            case version
            case virtualRouterName
        }
    }

    public struct RouteSpec: AWSEncodableShape & AWSDecodableShape {
        /// An object that represents the specification of a gRPC route.
        public let grpcRoute: GrpcRoute?
        /// An object that represents the specification of an HTTP/2 route.
        public let http2Route: HttpRoute?
        /// An object that represents the specification of an HTTP route.
        public let httpRoute: HttpRoute?
        /// The priority for the route. Routes are matched based on the specified value, where 0 is the highest priority.
        public let priority: Int?
        /// An object that represents the specification of a TCP route.
        public let tcpRoute: TcpRoute?

        public init(grpcRoute: GrpcRoute? = nil, http2Route: HttpRoute? = nil, httpRoute: HttpRoute? = nil, priority: Int? = nil, tcpRoute: TcpRoute? = nil) {
            self.grpcRoute = grpcRoute
            self.http2Route = http2Route
            self.httpRoute = httpRoute
            self.priority = priority
            self.tcpRoute = tcpRoute
        }

        public func validate(name: String) throws {
            try self.grpcRoute?.validate(name: "\(name).grpcRoute")
            try self.http2Route?.validate(name: "\(name).http2Route")
            try self.httpRoute?.validate(name: "\(name).httpRoute")
            try self.validate(self.priority, name: "priority", parent: name, max: 1000)
            try self.validate(self.priority, name: "priority", parent: name, min: 0)
            try self.tcpRoute?.validate(name: "\(name).tcpRoute")
        }

        private enum CodingKeys: String, CodingKey {
            case grpcRoute
            case http2Route
            case httpRoute
            case priority
            case tcpRoute
        }
    }

    public struct RouteStatus: AWSDecodableShape {
        /// The current status for the route.
        public let status: RouteStatusCode

        public init(status: RouteStatusCode) {
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case status
        }
    }

    public struct ServiceDiscovery: AWSEncodableShape & AWSDecodableShape {
        /// Specifies any Cloud Map information for the virtual node.
        public let awsCloudMap: AwsCloudMapServiceDiscovery?
        /// Specifies the DNS information for the virtual node.
        public let dns: DnsServiceDiscovery?

        public init(awsCloudMap: AwsCloudMapServiceDiscovery? = nil, dns: DnsServiceDiscovery? = nil) {
            self.awsCloudMap = awsCloudMap
            self.dns = dns
        }

        public func validate(name: String) throws {
            try self.awsCloudMap?.validate(name: "\(name).awsCloudMap")
        }

        private enum CodingKeys: String, CodingKey {
            case awsCloudMap
            case dns
        }
    }

    public struct SubjectAlternativeNameMatchers: AWSEncodableShape & AWSDecodableShape {
        /// The values sent must match the specified values exactly.
        public let exact: [String]

        public init(exact: [String]) {
            self.exact = exact
        }

        public func validate(name: String) throws {
            try self.exact.forEach {
                try validate($0, name: "exact[]", parent: name, max: 254)
                try validate($0, name: "exact[]", parent: name, min: 1)
            }
        }

        private enum CodingKeys: String, CodingKey {
            case exact
        }
    }

    public struct SubjectAlternativeNames: AWSEncodableShape & AWSDecodableShape {
        /// An object that represents the criteria for determining a SANs match.
        public let match: SubjectAlternativeNameMatchers

        public init(match: SubjectAlternativeNameMatchers) {
            self.match = match
        }

        public func validate(name: String) throws {
            try self.match.validate(name: "\(name).match")
        }

        private enum CodingKeys: String, CodingKey {
            case match
        }
    }

    public struct TagRef: AWSEncodableShape & AWSDecodableShape {
        /// One part of a key-value pair that make up a tag. A key is a general label that acts like a category for more specific tag values.
        public let key: String
        /// The optional part of a key-value pair that make up a tag. A value acts as a descriptor within a tag category (key).
        public let value: String

        public init(key: String, value: String) {
            self.key = key
            self.value = value
        }

        public func validate(name: String) throws {
            try self.validate(self.key, name: "key", parent: name, max: 128)
            try self.validate(self.key, name: "key", parent: name, min: 1)
            try self.validate(self.value, name: "value", parent: name, max: 256)
            try self.validate(self.value, name: "value", parent: name, min: 0)
        }

        private enum CodingKeys: String, CodingKey {
            case key
            case value
        }
    }

    public struct TagResourceInput: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "resourceArn", location: .querystring(locationName: "resourceArn"))
        ]

        /// The Amazon Resource Name (ARN) of the resource to add tags to.
        public let resourceArn: String
        /// The tags to add to the resource. A tag is an array of key-value pairs. Tag keys can have a maximum character length of 128 characters, and tag values can have a maximum length of 256 characters.
        public let tags: [TagRef]

        public init(resourceArn: String, tags: [TagRef]) {
            self.resourceArn = resourceArn
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.tags.forEach {
                try $0.validate(name: "\(name).tags[]")
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 50)
            try self.validate(self.tags, name: "tags", parent: name, min: 0)
        }

        private enum CodingKeys: String, CodingKey {
            case tags
        }
    }

    public struct TagResourceOutput: AWSDecodableShape {
        public init() {}
    }

    public struct TcpRoute: AWSEncodableShape & AWSDecodableShape {
        /// The action to take if a match is determined.
        public let action: TcpRouteAction
        /// An object that represents types of timeouts.
        public let timeout: TcpTimeout?

        public init(action: TcpRouteAction, timeout: TcpTimeout? = nil) {
            self.action = action
            self.timeout = timeout
        }

        public func validate(name: String) throws {
            try self.action.validate(name: "\(name).action")
            try self.timeout?.validate(name: "\(name).timeout")
        }

        private enum CodingKeys: String, CodingKey {
            case action
            case timeout
        }
    }

    public struct TcpRouteAction: AWSEncodableShape & AWSDecodableShape {
        /// An object that represents the targets that traffic is routed to when a request matches the route.
        public let weightedTargets: [WeightedTarget]

        public init(weightedTargets: [WeightedTarget]) {
            self.weightedTargets = weightedTargets
        }

        public func validate(name: String) throws {
            try self.weightedTargets.forEach {
                try $0.validate(name: "\(name).weightedTargets[]")
            }
            try self.validate(self.weightedTargets, name: "weightedTargets", parent: name, max: 10)
            try self.validate(self.weightedTargets, name: "weightedTargets", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case weightedTargets
        }
    }

    public struct TcpTimeout: AWSEncodableShape & AWSDecodableShape {
        /// An object that represents an idle timeout. An idle timeout bounds the amount of time that a connection may be idle. The default value is none.
        public let idle: Duration?

        public init(idle: Duration? = nil) {
            self.idle = idle
        }

        public func validate(name: String) throws {
            try self.idle?.validate(name: "\(name).idle")
        }

        private enum CodingKeys: String, CodingKey {
            case idle
        }
    }

    public struct TlsValidationContext: AWSEncodableShape & AWSDecodableShape {
        /// A reference to an object that represents the SANs for a Transport Layer Security (TLS) validation context.
        public let subjectAlternativeNames: SubjectAlternativeNames?
        /// A reference to where to retrieve the trust chain when validating a peer’s Transport Layer Security (TLS) certificate.
        public let trust: TlsValidationContextTrust

        public init(subjectAlternativeNames: SubjectAlternativeNames? = nil, trust: TlsValidationContextTrust) {
            self.subjectAlternativeNames = subjectAlternativeNames
            self.trust = trust
        }

        public func validate(name: String) throws {
            try self.subjectAlternativeNames?.validate(name: "\(name).subjectAlternativeNames")
            try self.trust.validate(name: "\(name).trust")
        }

        private enum CodingKeys: String, CodingKey {
            case subjectAlternativeNames
            case trust
        }
    }

    public struct TlsValidationContextAcmTrust: AWSEncodableShape & AWSDecodableShape {
        /// One or more ACM Amazon Resource Name (ARN)s.
        public let certificateAuthorityArns: [String]

        public init(certificateAuthorityArns: [String]) {
            self.certificateAuthorityArns = certificateAuthorityArns
        }

        public func validate(name: String) throws {
            try self.validate(self.certificateAuthorityArns, name: "certificateAuthorityArns", parent: name, max: 3)
            try self.validate(self.certificateAuthorityArns, name: "certificateAuthorityArns", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case certificateAuthorityArns
        }
    }

    public struct TlsValidationContextFileTrust: AWSEncodableShape & AWSDecodableShape {
        /// The certificate trust chain for a certificate stored on the file system of the virtual node that the proxy is running on.
        public let certificateChain: String

        public init(certificateChain: String) {
            self.certificateChain = certificateChain
        }

        public func validate(name: String) throws {
            try self.validate(self.certificateChain, name: "certificateChain", parent: name, max: 255)
            try self.validate(self.certificateChain, name: "certificateChain", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case certificateChain
        }
    }

    public struct TlsValidationContextSdsTrust: AWSEncodableShape & AWSDecodableShape {
        /// A reference to an object that represents the name of the secret for a Transport Layer Security (TLS) Secret Discovery Service validation context trust.
        public let secretName: String

        public init(secretName: String) {
            self.secretName = secretName
        }

        private enum CodingKeys: String, CodingKey {
            case secretName
        }
    }

    public struct TlsValidationContextTrust: AWSEncodableShape & AWSDecodableShape {
        /// A reference to an object that represents a Transport Layer Security (TLS) validation context trust for an Certificate Manager certificate.
        public let acm: TlsValidationContextAcmTrust?
        /// An object that represents a Transport Layer Security (TLS) validation context trust for a local file.
        public let file: TlsValidationContextFileTrust?
        /// A reference to an object that represents a Transport Layer Security (TLS) Secret Discovery Service validation context trust.
        public let sds: TlsValidationContextSdsTrust?

        public init(acm: TlsValidationContextAcmTrust? = nil, file: TlsValidationContextFileTrust? = nil, sds: TlsValidationContextSdsTrust? = nil) {
            self.acm = acm
            self.file = file
            self.sds = sds
        }

        public func validate(name: String) throws {
            try self.acm?.validate(name: "\(name).acm")
            try self.file?.validate(name: "\(name).file")
        }

        private enum CodingKeys: String, CodingKey {
            case acm
            case file
            case sds
        }
    }

    public struct UntagResourceInput: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "resourceArn", location: .querystring(locationName: "resourceArn"))
        ]

        /// The Amazon Resource Name (ARN) of the resource to delete tags from.
        public let resourceArn: String
        /// The keys of the tags to be removed.
        public let tagKeys: [String]

        public init(resourceArn: String, tagKeys: [String]) {
            self.resourceArn = resourceArn
            self.tagKeys = tagKeys
        }

        public func validate(name: String) throws {
            try self.tagKeys.forEach {
                try validate($0, name: "tagKeys[]", parent: name, max: 128)
                try validate($0, name: "tagKeys[]", parent: name, min: 1)
            }
            try self.validate(self.tagKeys, name: "tagKeys", parent: name, max: 50)
            try self.validate(self.tagKeys, name: "tagKeys", parent: name, min: 0)
        }

        private enum CodingKeys: String, CodingKey {
            case tagKeys
        }
    }

    public struct UntagResourceOutput: AWSDecodableShape {
        public init() {}
    }

    public struct UpdateGatewayRouteInput: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "gatewayRouteName", location: .uri(locationName: "gatewayRouteName")),
            AWSMemberEncoding(label: "meshName", location: .uri(locationName: "meshName")),
            AWSMemberEncoding(label: "meshOwner", location: .querystring(locationName: "meshOwner")),
            AWSMemberEncoding(label: "virtualGatewayName", location: .uri(locationName: "virtualGatewayName"))
        ]

        /// Unique, case-sensitive identifier that you provide to ensure the idempotency of the request. Up to 36 letters, numbers, hyphens, and underscores are allowed.
        public let clientToken: String?
        /// The name of the gateway route to update.
        public let gatewayRouteName: String
        /// The name of the service mesh that the gateway route resides in.
        public let meshName: String
        /// The AWS IAM account ID of the service mesh owner. If the account ID is not your own, then it's the ID of the account that shared the mesh with your account. For more information about mesh sharing, see Working with shared meshes.
        public let meshOwner: String?
        /// The new gateway route specification to apply. This overwrites the existing data.
        public let spec: GatewayRouteSpec
        /// The name of the virtual gateway that the gateway route is associated with.
        public let virtualGatewayName: String

        public init(clientToken: String? = UpdateGatewayRouteInput.idempotencyToken(), gatewayRouteName: String, meshName: String, meshOwner: String? = nil, spec: GatewayRouteSpec, virtualGatewayName: String) {
            self.clientToken = clientToken
            self.gatewayRouteName = gatewayRouteName
            self.meshName = meshName
            self.meshOwner = meshOwner
            self.spec = spec
            self.virtualGatewayName = virtualGatewayName
        }

        public func validate(name: String) throws {
            try self.validate(self.gatewayRouteName, name: "gatewayRouteName", parent: name, max: 255)
            try self.validate(self.gatewayRouteName, name: "gatewayRouteName", parent: name, min: 1)
            try self.validate(self.meshName, name: "meshName", parent: name, max: 255)
            try self.validate(self.meshName, name: "meshName", parent: name, min: 1)
            try self.validate(self.meshOwner, name: "meshOwner", parent: name, max: 12)
            try self.validate(self.meshOwner, name: "meshOwner", parent: name, min: 12)
            try self.spec.validate(name: "\(name).spec")
            try self.validate(self.virtualGatewayName, name: "virtualGatewayName", parent: name, max: 255)
            try self.validate(self.virtualGatewayName, name: "virtualGatewayName", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken
            case spec
        }
    }

    public struct UpdateGatewayRouteOutput: AWSDecodableShape & AWSShapeWithPayload {
        /// The key for the payload
        public static let _payloadPath: String = "gatewayRoute"

        /// A full description of the gateway route that was updated.
        public let gatewayRoute: GatewayRouteData

        public init(gatewayRoute: GatewayRouteData) {
            self.gatewayRoute = gatewayRoute
        }

        private enum CodingKeys: String, CodingKey {
            case gatewayRoute
        }
    }

    public struct UpdateMeshInput: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "meshName", location: .uri(locationName: "meshName"))
        ]

        /// Unique, case-sensitive identifier that you provide to ensure the idempotency of the request. Up to 36 letters, numbers, hyphens, and underscores are allowed.
        public let clientToken: String?
        /// The name of the service mesh to update.
        public let meshName: String
        /// The service mesh specification to apply.
        public let spec: MeshSpec?

        public init(clientToken: String? = UpdateMeshInput.idempotencyToken(), meshName: String, spec: MeshSpec? = nil) {
            self.clientToken = clientToken
            self.meshName = meshName
            self.spec = spec
        }

        public func validate(name: String) throws {
            try self.validate(self.meshName, name: "meshName", parent: name, max: 255)
            try self.validate(self.meshName, name: "meshName", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken
            case spec
        }
    }

    public struct UpdateMeshOutput: AWSDecodableShape & AWSShapeWithPayload {
        /// The key for the payload
        public static let _payloadPath: String = "mesh"

        public let mesh: MeshData

        public init(mesh: MeshData) {
            self.mesh = mesh
        }

        private enum CodingKeys: String, CodingKey {
            case mesh
        }
    }

    public struct UpdateRouteInput: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "meshName", location: .uri(locationName: "meshName")),
            AWSMemberEncoding(label: "meshOwner", location: .querystring(locationName: "meshOwner")),
            AWSMemberEncoding(label: "routeName", location: .uri(locationName: "routeName")),
            AWSMemberEncoding(label: "virtualRouterName", location: .uri(locationName: "virtualRouterName"))
        ]

        /// Unique, case-sensitive identifier that you provide to ensure the idempotency of the request. Up to 36 letters, numbers, hyphens, and underscores are allowed.
        public let clientToken: String?
        /// The name of the service mesh that the route resides in.
        public let meshName: String
        /// The AWS IAM account ID of the service mesh owner. If the account ID is not your own, then it's the ID of the account that shared the mesh with your account. For more information about mesh sharing, see Working with shared meshes.
        public let meshOwner: String?
        /// The name of the route to update.
        public let routeName: String
        /// The new route specification to apply. This overwrites the existing data.
        public let spec: RouteSpec
        /// The name of the virtual router that the route is associated with.
        public let virtualRouterName: String

        public init(clientToken: String? = UpdateRouteInput.idempotencyToken(), meshName: String, meshOwner: String? = nil, routeName: String, spec: RouteSpec, virtualRouterName: String) {
            self.clientToken = clientToken
            self.meshName = meshName
            self.meshOwner = meshOwner
            self.routeName = routeName
            self.spec = spec
            self.virtualRouterName = virtualRouterName
        }

        public func validate(name: String) throws {
            try self.validate(self.meshName, name: "meshName", parent: name, max: 255)
            try self.validate(self.meshName, name: "meshName", parent: name, min: 1)
            try self.validate(self.meshOwner, name: "meshOwner", parent: name, max: 12)
            try self.validate(self.meshOwner, name: "meshOwner", parent: name, min: 12)
            try self.validate(self.routeName, name: "routeName", parent: name, max: 255)
            try self.validate(self.routeName, name: "routeName", parent: name, min: 1)
            try self.spec.validate(name: "\(name).spec")
            try self.validate(self.virtualRouterName, name: "virtualRouterName", parent: name, max: 255)
            try self.validate(self.virtualRouterName, name: "virtualRouterName", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken
            case spec
        }
    }

    public struct UpdateRouteOutput: AWSDecodableShape & AWSShapeWithPayload {
        /// The key for the payload
        public static let _payloadPath: String = "route"

        /// A full description of the route that was updated.
        public let route: RouteData

        public init(route: RouteData) {
            self.route = route
        }

        private enum CodingKeys: String, CodingKey {
            case route
        }
    }

    public struct UpdateVirtualGatewayInput: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "meshName", location: .uri(locationName: "meshName")),
            AWSMemberEncoding(label: "meshOwner", location: .querystring(locationName: "meshOwner")),
            AWSMemberEncoding(label: "virtualGatewayName", location: .uri(locationName: "virtualGatewayName"))
        ]

        /// Unique, case-sensitive identifier that you provide to ensure the idempotency of the request. Up to 36 letters, numbers, hyphens, and underscores are allowed.
        public let clientToken: String?
        /// The name of the service mesh that the virtual gateway resides in.
        public let meshName: String
        /// The AWS IAM account ID of the service mesh owner. If the account ID is not your own, then it's the ID of the account that shared the mesh with your account. For more information about mesh sharing, see Working with shared meshes.
        public let meshOwner: String?
        /// The new virtual gateway specification to apply. This overwrites the existing data.
        public let spec: VirtualGatewaySpec
        /// The name of the virtual gateway to update.
        public let virtualGatewayName: String

        public init(clientToken: String? = UpdateVirtualGatewayInput.idempotencyToken(), meshName: String, meshOwner: String? = nil, spec: VirtualGatewaySpec, virtualGatewayName: String) {
            self.clientToken = clientToken
            self.meshName = meshName
            self.meshOwner = meshOwner
            self.spec = spec
            self.virtualGatewayName = virtualGatewayName
        }

        public func validate(name: String) throws {
            try self.validate(self.meshName, name: "meshName", parent: name, max: 255)
            try self.validate(self.meshName, name: "meshName", parent: name, min: 1)
            try self.validate(self.meshOwner, name: "meshOwner", parent: name, max: 12)
            try self.validate(self.meshOwner, name: "meshOwner", parent: name, min: 12)
            try self.spec.validate(name: "\(name).spec")
            try self.validate(self.virtualGatewayName, name: "virtualGatewayName", parent: name, max: 255)
            try self.validate(self.virtualGatewayName, name: "virtualGatewayName", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken
            case spec
        }
    }

    public struct UpdateVirtualGatewayOutput: AWSDecodableShape & AWSShapeWithPayload {
        /// The key for the payload
        public static let _payloadPath: String = "virtualGateway"

        /// A full description of the virtual gateway that was updated.
        public let virtualGateway: VirtualGatewayData

        public init(virtualGateway: VirtualGatewayData) {
            self.virtualGateway = virtualGateway
        }

        private enum CodingKeys: String, CodingKey {
            case virtualGateway
        }
    }

    public struct UpdateVirtualNodeInput: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "meshName", location: .uri(locationName: "meshName")),
            AWSMemberEncoding(label: "meshOwner", location: .querystring(locationName: "meshOwner")),
            AWSMemberEncoding(label: "virtualNodeName", location: .uri(locationName: "virtualNodeName"))
        ]

        /// Unique, case-sensitive identifier that you provide to ensure the idempotency of the request. Up to 36 letters, numbers, hyphens, and underscores are allowed.
        public let clientToken: String?
        /// The name of the service mesh that the virtual node resides in.
        public let meshName: String
        /// The AWS IAM account ID of the service mesh owner. If the account ID is not your own, then it's the ID of the account that shared the mesh with your account. For more information about mesh sharing, see Working with shared meshes.
        public let meshOwner: String?
        /// The new virtual node specification to apply. This overwrites the existing data.
        public let spec: VirtualNodeSpec
        /// The name of the virtual node to update.
        public let virtualNodeName: String

        public init(clientToken: String? = UpdateVirtualNodeInput.idempotencyToken(), meshName: String, meshOwner: String? = nil, spec: VirtualNodeSpec, virtualNodeName: String) {
            self.clientToken = clientToken
            self.meshName = meshName
            self.meshOwner = meshOwner
            self.spec = spec
            self.virtualNodeName = virtualNodeName
        }

        public func validate(name: String) throws {
            try self.validate(self.meshName, name: "meshName", parent: name, max: 255)
            try self.validate(self.meshName, name: "meshName", parent: name, min: 1)
            try self.validate(self.meshOwner, name: "meshOwner", parent: name, max: 12)
            try self.validate(self.meshOwner, name: "meshOwner", parent: name, min: 12)
            try self.spec.validate(name: "\(name).spec")
            try self.validate(self.virtualNodeName, name: "virtualNodeName", parent: name, max: 255)
            try self.validate(self.virtualNodeName, name: "virtualNodeName", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken
            case spec
        }
    }

    public struct UpdateVirtualNodeOutput: AWSDecodableShape & AWSShapeWithPayload {
        /// The key for the payload
        public static let _payloadPath: String = "virtualNode"

        /// A full description of the virtual node that was updated.
        public let virtualNode: VirtualNodeData

        public init(virtualNode: VirtualNodeData) {
            self.virtualNode = virtualNode
        }

        private enum CodingKeys: String, CodingKey {
            case virtualNode
        }
    }

    public struct UpdateVirtualRouterInput: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "meshName", location: .uri(locationName: "meshName")),
            AWSMemberEncoding(label: "meshOwner", location: .querystring(locationName: "meshOwner")),
            AWSMemberEncoding(label: "virtualRouterName", location: .uri(locationName: "virtualRouterName"))
        ]

        /// Unique, case-sensitive identifier that you provide to ensure the idempotency of the request. Up to 36 letters, numbers, hyphens, and underscores are allowed.
        public let clientToken: String?
        /// The name of the service mesh that the virtual router resides in.
        public let meshName: String
        /// The AWS IAM account ID of the service mesh owner. If the account ID is not your own, then it's the ID of the account that shared the mesh with your account. For more information about mesh sharing, see Working with shared meshes.
        public let meshOwner: String?
        /// The new virtual router specification to apply. This overwrites the existing data.
        public let spec: VirtualRouterSpec
        /// The name of the virtual router to update.
        public let virtualRouterName: String

        public init(clientToken: String? = UpdateVirtualRouterInput.idempotencyToken(), meshName: String, meshOwner: String? = nil, spec: VirtualRouterSpec, virtualRouterName: String) {
            self.clientToken = clientToken
            self.meshName = meshName
            self.meshOwner = meshOwner
            self.spec = spec
            self.virtualRouterName = virtualRouterName
        }

        public func validate(name: String) throws {
            try self.validate(self.meshName, name: "meshName", parent: name, max: 255)
            try self.validate(self.meshName, name: "meshName", parent: name, min: 1)
            try self.validate(self.meshOwner, name: "meshOwner", parent: name, max: 12)
            try self.validate(self.meshOwner, name: "meshOwner", parent: name, min: 12)
            try self.spec.validate(name: "\(name).spec")
            try self.validate(self.virtualRouterName, name: "virtualRouterName", parent: name, max: 255)
            try self.validate(self.virtualRouterName, name: "virtualRouterName", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken
            case spec
        }
    }

    public struct UpdateVirtualRouterOutput: AWSDecodableShape & AWSShapeWithPayload {
        /// The key for the payload
        public static let _payloadPath: String = "virtualRouter"

        /// A full description of the virtual router that was updated.
        public let virtualRouter: VirtualRouterData

        public init(virtualRouter: VirtualRouterData) {
            self.virtualRouter = virtualRouter
        }

        private enum CodingKeys: String, CodingKey {
            case virtualRouter
        }
    }

    public struct UpdateVirtualServiceInput: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "meshName", location: .uri(locationName: "meshName")),
            AWSMemberEncoding(label: "meshOwner", location: .querystring(locationName: "meshOwner")),
            AWSMemberEncoding(label: "virtualServiceName", location: .uri(locationName: "virtualServiceName"))
        ]

        /// Unique, case-sensitive identifier that you provide to ensure the idempotency of the request. Up to 36 letters, numbers, hyphens, and underscores are allowed.
        public let clientToken: String?
        /// The name of the service mesh that the virtual service resides in.
        public let meshName: String
        /// The AWS IAM account ID of the service mesh owner. If the account ID is not your own, then it's the ID of the account that shared the mesh with your account. For more information about mesh sharing, see Working with shared meshes.
        public let meshOwner: String?
        /// The new virtual service specification to apply. This overwrites the existing data.
        public let spec: VirtualServiceSpec
        /// The name of the virtual service to update.
        public let virtualServiceName: String

        public init(clientToken: String? = UpdateVirtualServiceInput.idempotencyToken(), meshName: String, meshOwner: String? = nil, spec: VirtualServiceSpec, virtualServiceName: String) {
            self.clientToken = clientToken
            self.meshName = meshName
            self.meshOwner = meshOwner
            self.spec = spec
            self.virtualServiceName = virtualServiceName
        }

        public func validate(name: String) throws {
            try self.validate(self.meshName, name: "meshName", parent: name, max: 255)
            try self.validate(self.meshName, name: "meshName", parent: name, min: 1)
            try self.validate(self.meshOwner, name: "meshOwner", parent: name, max: 12)
            try self.validate(self.meshOwner, name: "meshOwner", parent: name, min: 12)
            try self.spec.validate(name: "\(name).spec")
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken
            case spec
        }
    }

    public struct UpdateVirtualServiceOutput: AWSDecodableShape & AWSShapeWithPayload {
        /// The key for the payload
        public static let _payloadPath: String = "virtualService"

        /// A full description of the virtual service that was updated.
        public let virtualService: VirtualServiceData

        public init(virtualService: VirtualServiceData) {
            self.virtualService = virtualService
        }

        private enum CodingKeys: String, CodingKey {
            case virtualService
        }
    }

    public struct VirtualGatewayAccessLog: AWSEncodableShape & AWSDecodableShape {
        /// The file object to send virtual gateway access logs to.
        public let file: VirtualGatewayFileAccessLog?

        public init(file: VirtualGatewayFileAccessLog? = nil) {
            self.file = file
        }

        public func validate(name: String) throws {
            try self.file?.validate(name: "\(name).file")
        }

        private enum CodingKeys: String, CodingKey {
            case file
        }
    }

    public struct VirtualGatewayBackendDefaults: AWSEncodableShape & AWSDecodableShape {
        /// A reference to an object that represents a client policy.
        public let clientPolicy: VirtualGatewayClientPolicy?

        public init(clientPolicy: VirtualGatewayClientPolicy? = nil) {
            self.clientPolicy = clientPolicy
        }

        public func validate(name: String) throws {
            try self.clientPolicy?.validate(name: "\(name).clientPolicy")
        }

        private enum CodingKeys: String, CodingKey {
            case clientPolicy
        }
    }

    public struct VirtualGatewayClientPolicy: AWSEncodableShape & AWSDecodableShape {
        /// A reference to an object that represents a Transport Layer Security (TLS) client policy.
        public let tls: VirtualGatewayClientPolicyTls?

        public init(tls: VirtualGatewayClientPolicyTls? = nil) {
            self.tls = tls
        }

        public func validate(name: String) throws {
            try self.tls?.validate(name: "\(name).tls")
        }

        private enum CodingKeys: String, CodingKey {
            case tls
        }
    }

    public struct VirtualGatewayClientPolicyTls: AWSEncodableShape & AWSDecodableShape {
        /// A reference to an object that represents a virtual gateway's client's Transport Layer Security (TLS) certificate.
        public let certificate: VirtualGatewayClientTlsCertificate?
        /// Whether the policy is enforced. The default is True, if a value isn't specified.
        public let enforce: Bool?
        /// One or more ports that the policy is enforced for.
        public let ports: [Int]?
        /// A reference to an object that represents a Transport Layer Security (TLS) validation context.
        public let validation: VirtualGatewayTlsValidationContext

        public init(certificate: VirtualGatewayClientTlsCertificate? = nil, enforce: Bool? = nil, ports: [Int]? = nil, validation: VirtualGatewayTlsValidationContext) {
            self.certificate = certificate
            self.enforce = enforce
            self.ports = ports
            self.validation = validation
        }

        public func validate(name: String) throws {
            try self.certificate?.validate(name: "\(name).certificate")
            try self.ports?.forEach {
                try validate($0, name: "ports[]", parent: name, max: 65535)
                try validate($0, name: "ports[]", parent: name, min: 1)
            }
            try self.validation.validate(name: "\(name).validation")
        }

        private enum CodingKeys: String, CodingKey {
            case certificate
            case enforce
            case ports
            case validation
        }
    }

    public struct VirtualGatewayClientTlsCertificate: AWSEncodableShape & AWSDecodableShape {
        /// An object that represents a local file certificate. The certificate must meet specific requirements and you must have proxy authorization enabled. For more information, see  Transport Layer Security (TLS) .
        public let file: VirtualGatewayListenerTlsFileCertificate?
        /// A reference to an object that represents a virtual gateway's client's Secret Discovery Service certificate.
        public let sds: VirtualGatewayListenerTlsSdsCertificate?

        public init(file: VirtualGatewayListenerTlsFileCertificate? = nil, sds: VirtualGatewayListenerTlsSdsCertificate? = nil) {
            self.file = file
            self.sds = sds
        }

        public func validate(name: String) throws {
            try self.file?.validate(name: "\(name).file")
        }

        private enum CodingKeys: String, CodingKey {
            case file
            case sds
        }
    }

    public struct VirtualGatewayConnectionPool: AWSEncodableShape & AWSDecodableShape {
        /// An object that represents a type of connection pool.
        public let grpc: VirtualGatewayGrpcConnectionPool?
        /// An object that represents a type of connection pool.
        public let http: VirtualGatewayHttpConnectionPool?
        /// An object that represents a type of connection pool.
        public let http2: VirtualGatewayHttp2ConnectionPool?

        public init(grpc: VirtualGatewayGrpcConnectionPool? = nil, http: VirtualGatewayHttpConnectionPool? = nil, http2: VirtualGatewayHttp2ConnectionPool? = nil) {
            self.grpc = grpc
            self.http = http
            self.http2 = http2
        }

        public func validate(name: String) throws {
            try self.grpc?.validate(name: "\(name).grpc")
            try self.http?.validate(name: "\(name).http")
            try self.http2?.validate(name: "\(name).http2")
        }

        private enum CodingKeys: String, CodingKey {
            case grpc
            case http
            case http2
        }
    }

    public struct VirtualGatewayData: AWSDecodableShape {
        /// The name of the service mesh that the virtual gateway resides in.
        public let meshName: String
        public let metadata: ResourceMetadata
        /// The specifications of the virtual gateway.
        public let spec: VirtualGatewaySpec
        /// The current status of the virtual gateway.
        public let status: VirtualGatewayStatus
        /// The name of the virtual gateway.
        public let virtualGatewayName: String

        public init(meshName: String, metadata: ResourceMetadata, spec: VirtualGatewaySpec, status: VirtualGatewayStatus, virtualGatewayName: String) {
            self.meshName = meshName
            self.metadata = metadata
            self.spec = spec
            self.status = status
            self.virtualGatewayName = virtualGatewayName
        }

        private enum CodingKeys: String, CodingKey {
            case meshName
            case metadata
            case spec
            case status
            case virtualGatewayName
        }
    }

    public struct VirtualGatewayFileAccessLog: AWSEncodableShape & AWSDecodableShape {
        /// The file path to write access logs to. You can use /dev/stdout to send access logs to standard out and configure your Envoy container to use a log driver, such as awslogs, to export the access logs to a log storage service such as Amazon CloudWatch Logs. You can also specify a path in the Envoy container's file system to write the files to disk.
        public let path: String

        public init(path: String) {
            self.path = path
        }

        public func validate(name: String) throws {
            try self.validate(self.path, name: "path", parent: name, max: 255)
            try self.validate(self.path, name: "path", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case path
        }
    }

    public struct VirtualGatewayGrpcConnectionPool: AWSEncodableShape & AWSDecodableShape {
        /// Maximum number of inflight requests Envoy can concurrently support across hosts in upstream cluster.
        public let maxRequests: Int

        public init(maxRequests: Int) {
            self.maxRequests = maxRequests
        }

        public func validate(name: String) throws {
            try self.validate(self.maxRequests, name: "maxRequests", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case maxRequests
        }
    }

    public struct VirtualGatewayHealthCheckPolicy: AWSEncodableShape & AWSDecodableShape {
        /// The number of consecutive successful health checks that must occur before declaring the listener healthy.
        public let healthyThreshold: Int
        /// The time period in milliseconds between each health check execution.
        public let intervalMillis: Int64
        /// The destination path for the health check request. This value is only used if the specified protocol is HTTP or HTTP/2. For any other protocol, this value is ignored.
        public let path: String?
        /// The destination port for the health check request. This port must match the port defined in the PortMapping for the listener.
        public let port: Int?
        /// The protocol for the health check request. If you specify grpc, then your service must conform to the GRPC Health Checking Protocol.
        public let `protocol`: VirtualGatewayPortProtocol
        /// The amount of time to wait when receiving a response from the health check, in milliseconds.
        public let timeoutMillis: Int64
        /// The number of consecutive failed health checks that must occur before declaring a virtual gateway unhealthy.
        public let unhealthyThreshold: Int

        public init(healthyThreshold: Int, intervalMillis: Int64, path: String? = nil, port: Int? = nil, protocol: VirtualGatewayPortProtocol, timeoutMillis: Int64, unhealthyThreshold: Int) {
            self.healthyThreshold = healthyThreshold
            self.intervalMillis = intervalMillis
            self.path = path
            self.port = port
            self.`protocol` = `protocol`
            self.timeoutMillis = timeoutMillis
            self.unhealthyThreshold = unhealthyThreshold
        }

        public func validate(name: String) throws {
            try self.validate(self.healthyThreshold, name: "healthyThreshold", parent: name, max: 10)
            try self.validate(self.healthyThreshold, name: "healthyThreshold", parent: name, min: 2)
            try self.validate(self.intervalMillis, name: "intervalMillis", parent: name, max: 300_000)
            try self.validate(self.intervalMillis, name: "intervalMillis", parent: name, min: 5000)
            try self.validate(self.port, name: "port", parent: name, max: 65535)
            try self.validate(self.port, name: "port", parent: name, min: 1)
            try self.validate(self.timeoutMillis, name: "timeoutMillis", parent: name, max: 60000)
            try self.validate(self.timeoutMillis, name: "timeoutMillis", parent: name, min: 2000)
            try self.validate(self.unhealthyThreshold, name: "unhealthyThreshold", parent: name, max: 10)
            try self.validate(self.unhealthyThreshold, name: "unhealthyThreshold", parent: name, min: 2)
        }

        private enum CodingKeys: String, CodingKey {
            case healthyThreshold
            case intervalMillis
            case path
            case port
            case `protocol`
            case timeoutMillis
            case unhealthyThreshold
        }
    }

    public struct VirtualGatewayHttp2ConnectionPool: AWSEncodableShape & AWSDecodableShape {
        /// Maximum number of inflight requests Envoy can concurrently support across hosts in upstream cluster.
        public let maxRequests: Int

        public init(maxRequests: Int) {
            self.maxRequests = maxRequests
        }

        public func validate(name: String) throws {
            try self.validate(self.maxRequests, name: "maxRequests", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case maxRequests
        }
    }

    public struct VirtualGatewayHttpConnectionPool: AWSEncodableShape & AWSDecodableShape {
        /// Maximum number of outbound TCP connections Envoy can establish concurrently with all hosts in upstream cluster.
        public let maxConnections: Int
        /// Number of overflowing requests after max_connections Envoy will queue to upstream cluster.
        public let maxPendingRequests: Int?

        public init(maxConnections: Int, maxPendingRequests: Int? = nil) {
            self.maxConnections = maxConnections
            self.maxPendingRequests = maxPendingRequests
        }

        public func validate(name: String) throws {
            try self.validate(self.maxConnections, name: "maxConnections", parent: name, min: 1)
            try self.validate(self.maxPendingRequests, name: "maxPendingRequests", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case maxConnections
            case maxPendingRequests
        }
    }

    public struct VirtualGatewayListener: AWSEncodableShape & AWSDecodableShape {
        /// The connection pool information for the virtual gateway listener.
        public let connectionPool: VirtualGatewayConnectionPool?
        /// The health check information for the listener.
        public let healthCheck: VirtualGatewayHealthCheckPolicy?
        /// The port mapping information for the listener.
        public let portMapping: VirtualGatewayPortMapping
        /// A reference to an object that represents the Transport Layer Security (TLS) properties for the listener.
        public let tls: VirtualGatewayListenerTls?

        public init(connectionPool: VirtualGatewayConnectionPool? = nil, healthCheck: VirtualGatewayHealthCheckPolicy? = nil, portMapping: VirtualGatewayPortMapping, tls: VirtualGatewayListenerTls? = nil) {
            self.connectionPool = connectionPool
            self.healthCheck = healthCheck
            self.portMapping = portMapping
            self.tls = tls
        }

        public func validate(name: String) throws {
            try self.connectionPool?.validate(name: "\(name).connectionPool")
            try self.healthCheck?.validate(name: "\(name).healthCheck")
            try self.portMapping.validate(name: "\(name).portMapping")
            try self.tls?.validate(name: "\(name).tls")
        }

        private enum CodingKeys: String, CodingKey {
            case connectionPool
            case healthCheck
            case portMapping
            case tls
        }
    }

    public struct VirtualGatewayListenerTls: AWSEncodableShape & AWSDecodableShape {
        /// An object that represents a Transport Layer Security (TLS) certificate.
        public let certificate: VirtualGatewayListenerTlsCertificate
        /// Specify one of the following modes.    STRICT – Listener only accepts connections with TLS enabled.     PERMISSIVE – Listener accepts connections with or without TLS enabled.    DISABLED – Listener only accepts connections without TLS.
        public let mode: VirtualGatewayListenerTlsMode
        /// A reference to an object that represents a virtual gateway's listener's Transport Layer Security (TLS) validation context.
        public let validation: VirtualGatewayListenerTlsValidationContext?

        public init(certificate: VirtualGatewayListenerTlsCertificate, mode: VirtualGatewayListenerTlsMode, validation: VirtualGatewayListenerTlsValidationContext? = nil) {
            self.certificate = certificate
            self.mode = mode
            self.validation = validation
        }

        public func validate(name: String) throws {
            try self.certificate.validate(name: "\(name).certificate")
            try self.validation?.validate(name: "\(name).validation")
        }

        private enum CodingKeys: String, CodingKey {
            case certificate
            case mode
            case validation
        }
    }

    public struct VirtualGatewayListenerTlsAcmCertificate: AWSEncodableShape & AWSDecodableShape {
        /// The Amazon Resource Name (ARN) for the certificate. The certificate must meet specific requirements and you must have proxy authorization enabled. For more information, see Transport Layer Security (TLS).
        public let certificateArn: String

        public init(certificateArn: String) {
            self.certificateArn = certificateArn
        }

        private enum CodingKeys: String, CodingKey {
            case certificateArn
        }
    }

    public struct VirtualGatewayListenerTlsCertificate: AWSEncodableShape & AWSDecodableShape {
        /// A reference to an object that represents an Certificate Manager certificate.
        public let acm: VirtualGatewayListenerTlsAcmCertificate?
        /// A reference to an object that represents a local file certificate.
        public let file: VirtualGatewayListenerTlsFileCertificate?
        /// A reference to an object that represents a virtual gateway's listener's Secret Discovery Service certificate.
        public let sds: VirtualGatewayListenerTlsSdsCertificate?

        public init(acm: VirtualGatewayListenerTlsAcmCertificate? = nil, file: VirtualGatewayListenerTlsFileCertificate? = nil, sds: VirtualGatewayListenerTlsSdsCertificate? = nil) {
            self.acm = acm
            self.file = file
            self.sds = sds
        }

        public func validate(name: String) throws {
            try self.file?.validate(name: "\(name).file")
        }

        private enum CodingKeys: String, CodingKey {
            case acm
            case file
            case sds
        }
    }

    public struct VirtualGatewayListenerTlsFileCertificate: AWSEncodableShape & AWSDecodableShape {
        /// The certificate chain for the certificate.
        public let certificateChain: String
        /// The private key for a certificate stored on the file system of the mesh endpoint that the proxy is running on.
        public let privateKey: String

        public init(certificateChain: String, privateKey: String) {
            self.certificateChain = certificateChain
            self.privateKey = privateKey
        }

        public func validate(name: String) throws {
            try self.validate(self.certificateChain, name: "certificateChain", parent: name, max: 255)
            try self.validate(self.certificateChain, name: "certificateChain", parent: name, min: 1)
            try self.validate(self.privateKey, name: "privateKey", parent: name, max: 255)
            try self.validate(self.privateKey, name: "privateKey", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case certificateChain
            case privateKey
        }
    }

    public struct VirtualGatewayListenerTlsSdsCertificate: AWSEncodableShape & AWSDecodableShape {
        /// A reference to an object that represents the name of the secret secret requested from the Secret Discovery Service provider representing Transport Layer Security (TLS) materials like a certificate or certificate chain.
        public let secretName: String

        public init(secretName: String) {
            self.secretName = secretName
        }

        private enum CodingKeys: String, CodingKey {
            case secretName
        }
    }

    public struct VirtualGatewayListenerTlsValidationContext: AWSEncodableShape & AWSDecodableShape {
        /// A reference to an object that represents the SANs for a virtual gateway listener's Transport Layer Security (TLS) validation context.
        public let subjectAlternativeNames: SubjectAlternativeNames?
        /// A reference to where to retrieve the trust chain when validating a peer’s Transport Layer Security (TLS) certificate.
        public let trust: VirtualGatewayListenerTlsValidationContextTrust

        public init(subjectAlternativeNames: SubjectAlternativeNames? = nil, trust: VirtualGatewayListenerTlsValidationContextTrust) {
            self.subjectAlternativeNames = subjectAlternativeNames
            self.trust = trust
        }

        public func validate(name: String) throws {
            try self.subjectAlternativeNames?.validate(name: "\(name).subjectAlternativeNames")
            try self.trust.validate(name: "\(name).trust")
        }

        private enum CodingKeys: String, CodingKey {
            case subjectAlternativeNames
            case trust
        }
    }

    public struct VirtualGatewayListenerTlsValidationContextTrust: AWSEncodableShape & AWSDecodableShape {
        /// An object that represents a Transport Layer Security (TLS) validation context trust for a local file.
        public let file: VirtualGatewayTlsValidationContextFileTrust?
        /// A reference to an object that represents a virtual gateway's listener's Transport Layer Security (TLS) Secret Discovery Service validation context trust.
        public let sds: VirtualGatewayTlsValidationContextSdsTrust?

        public init(file: VirtualGatewayTlsValidationContextFileTrust? = nil, sds: VirtualGatewayTlsValidationContextSdsTrust? = nil) {
            self.file = file
            self.sds = sds
        }

        public func validate(name: String) throws {
            try self.file?.validate(name: "\(name).file")
        }

        private enum CodingKeys: String, CodingKey {
            case file
            case sds
        }
    }

    public struct VirtualGatewayLogging: AWSEncodableShape & AWSDecodableShape {
        /// The access log configuration.
        public let accessLog: VirtualGatewayAccessLog?

        public init(accessLog: VirtualGatewayAccessLog? = nil) {
            self.accessLog = accessLog
        }

        public func validate(name: String) throws {
            try self.accessLog?.validate(name: "\(name).accessLog")
        }

        private enum CodingKeys: String, CodingKey {
            case accessLog
        }
    }

    public struct VirtualGatewayPortMapping: AWSEncodableShape & AWSDecodableShape {
        /// The port used for the port mapping. Specify one protocol.
        public let port: Int
        /// The protocol used for the port mapping.
        public let `protocol`: VirtualGatewayPortProtocol

        public init(port: Int, protocol: VirtualGatewayPortProtocol) {
            self.port = port
            self.`protocol` = `protocol`
        }

        public func validate(name: String) throws {
            try self.validate(self.port, name: "port", parent: name, max: 65535)
            try self.validate(self.port, name: "port", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case port
            case `protocol`
        }
    }

    public struct VirtualGatewayRef: AWSDecodableShape {
        /// The full Amazon Resource Name (ARN) for the resource.
        public let arn: String
        /// The Unix epoch timestamp in seconds for when the resource was created.
        public let createdAt: Date
        /// The Unix epoch timestamp in seconds for when the resource was last updated.
        public let lastUpdatedAt: Date
        /// The name of the service mesh that the resource resides in.
        public let meshName: String
        /// The AWS IAM account ID of the service mesh owner. If the account ID is not your own, then it's the ID of the account that shared the mesh with your account. For more information about mesh sharing, see Working with shared meshes.
        public let meshOwner: String
        /// The AWS IAM account ID of the resource owner. If the account ID is not your own, then it's the ID of the mesh owner or of another account that the mesh is shared with. For more information about mesh sharing, see Working with shared meshes.
        public let resourceOwner: String
        /// The version of the resource. Resources are created at version 1, and this version is incremented each time that they're updated.
        public let version: Int64
        /// The name of the resource.
        public let virtualGatewayName: String

        public init(arn: String, createdAt: Date, lastUpdatedAt: Date, meshName: String, meshOwner: String, resourceOwner: String, version: Int64, virtualGatewayName: String) {
            self.arn = arn
            self.createdAt = createdAt
            self.lastUpdatedAt = lastUpdatedAt
            self.meshName = meshName
            self.meshOwner = meshOwner
            self.resourceOwner = resourceOwner
            self.version = version
            self.virtualGatewayName = virtualGatewayName
        }

        private enum CodingKeys: String, CodingKey {
            case arn
            case createdAt
            case lastUpdatedAt
            case meshName
            case meshOwner
            case resourceOwner
            case version
            case virtualGatewayName
        }
    }

    public struct VirtualGatewaySpec: AWSEncodableShape & AWSDecodableShape {
        /// A reference to an object that represents the defaults for backends.
        public let backendDefaults: VirtualGatewayBackendDefaults?
        /// The listeners that the mesh endpoint is expected to receive inbound traffic from. You can specify one listener.
        public let listeners: [VirtualGatewayListener]
        public let logging: VirtualGatewayLogging?

        public init(backendDefaults: VirtualGatewayBackendDefaults? = nil, listeners: [VirtualGatewayListener], logging: VirtualGatewayLogging? = nil) {
            self.backendDefaults = backendDefaults
            self.listeners = listeners
            self.logging = logging
        }

        public func validate(name: String) throws {
            try self.backendDefaults?.validate(name: "\(name).backendDefaults")
            try self.listeners.forEach {
                try $0.validate(name: "\(name).listeners[]")
            }
            try self.validate(self.listeners, name: "listeners", parent: name, max: 1)
            try self.validate(self.listeners, name: "listeners", parent: name, min: 0)
            try self.logging?.validate(name: "\(name).logging")
        }

        private enum CodingKeys: String, CodingKey {
            case backendDefaults
            case listeners
            case logging
        }
    }

    public struct VirtualGatewayStatus: AWSDecodableShape {
        /// The current status.
        public let status: VirtualGatewayStatusCode

        public init(status: VirtualGatewayStatusCode) {
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case status
        }
    }

    public struct VirtualGatewayTlsValidationContext: AWSEncodableShape & AWSDecodableShape {
        /// A reference to an object that represents the SANs for a virtual gateway's listener's Transport Layer Security (TLS) validation context.
        public let subjectAlternativeNames: SubjectAlternativeNames?
        /// A reference to where to retrieve the trust chain when validating a peer’s Transport Layer Security (TLS) certificate.
        public let trust: VirtualGatewayTlsValidationContextTrust

        public init(subjectAlternativeNames: SubjectAlternativeNames? = nil, trust: VirtualGatewayTlsValidationContextTrust) {
            self.subjectAlternativeNames = subjectAlternativeNames
            self.trust = trust
        }

        public func validate(name: String) throws {
            try self.subjectAlternativeNames?.validate(name: "\(name).subjectAlternativeNames")
            try self.trust.validate(name: "\(name).trust")
        }

        private enum CodingKeys: String, CodingKey {
            case subjectAlternativeNames
            case trust
        }
    }

    public struct VirtualGatewayTlsValidationContextAcmTrust: AWSEncodableShape & AWSDecodableShape {
        /// One or more ACM Amazon Resource Name (ARN)s.
        public let certificateAuthorityArns: [String]

        public init(certificateAuthorityArns: [String]) {
            self.certificateAuthorityArns = certificateAuthorityArns
        }

        public func validate(name: String) throws {
            try self.validate(self.certificateAuthorityArns, name: "certificateAuthorityArns", parent: name, max: 3)
            try self.validate(self.certificateAuthorityArns, name: "certificateAuthorityArns", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case certificateAuthorityArns
        }
    }

    public struct VirtualGatewayTlsValidationContextFileTrust: AWSEncodableShape & AWSDecodableShape {
        /// The certificate trust chain for a certificate stored on the file system of the virtual node that the proxy is running on.
        public let certificateChain: String

        public init(certificateChain: String) {
            self.certificateChain = certificateChain
        }

        public func validate(name: String) throws {
            try self.validate(self.certificateChain, name: "certificateChain", parent: name, max: 255)
            try self.validate(self.certificateChain, name: "certificateChain", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case certificateChain
        }
    }

    public struct VirtualGatewayTlsValidationContextSdsTrust: AWSEncodableShape & AWSDecodableShape {
        /// A reference to an object that represents the name of the secret for a virtual gateway's Transport Layer Security (TLS) Secret Discovery Service validation context trust.
        public let secretName: String

        public init(secretName: String) {
            self.secretName = secretName
        }

        private enum CodingKeys: String, CodingKey {
            case secretName
        }
    }

    public struct VirtualGatewayTlsValidationContextTrust: AWSEncodableShape & AWSDecodableShape {
        /// A reference to an object that represents a Transport Layer Security (TLS) validation context trust for an Certificate Manager certificate.
        public let acm: VirtualGatewayTlsValidationContextAcmTrust?
        /// An object that represents a Transport Layer Security (TLS) validation context trust for a local file.
        public let file: VirtualGatewayTlsValidationContextFileTrust?
        /// A reference to an object that represents a virtual gateway's Transport Layer Security (TLS) Secret Discovery Service validation context trust.
        public let sds: VirtualGatewayTlsValidationContextSdsTrust?

        public init(acm: VirtualGatewayTlsValidationContextAcmTrust? = nil, file: VirtualGatewayTlsValidationContextFileTrust? = nil, sds: VirtualGatewayTlsValidationContextSdsTrust? = nil) {
            self.acm = acm
            self.file = file
            self.sds = sds
        }

        public func validate(name: String) throws {
            try self.acm?.validate(name: "\(name).acm")
            try self.file?.validate(name: "\(name).file")
        }

        private enum CodingKeys: String, CodingKey {
            case acm
            case file
            case sds
        }
    }

    public struct VirtualNodeConnectionPool: AWSEncodableShape & AWSDecodableShape {
        /// An object that represents a type of connection pool.
        public let grpc: VirtualNodeGrpcConnectionPool?
        /// An object that represents a type of connection pool.
        public let http: VirtualNodeHttpConnectionPool?
        /// An object that represents a type of connection pool.
        public let http2: VirtualNodeHttp2ConnectionPool?
        /// An object that represents a type of connection pool.
        public let tcp: VirtualNodeTcpConnectionPool?

        public init(grpc: VirtualNodeGrpcConnectionPool? = nil, http: VirtualNodeHttpConnectionPool? = nil, http2: VirtualNodeHttp2ConnectionPool? = nil, tcp: VirtualNodeTcpConnectionPool? = nil) {
            self.grpc = grpc
            self.http = http
            self.http2 = http2
            self.tcp = tcp
        }

        public func validate(name: String) throws {
            try self.grpc?.validate(name: "\(name).grpc")
            try self.http?.validate(name: "\(name).http")
            try self.http2?.validate(name: "\(name).http2")
            try self.tcp?.validate(name: "\(name).tcp")
        }

        private enum CodingKeys: String, CodingKey {
            case grpc
            case http
            case http2
            case tcp
        }
    }

    public struct VirtualNodeData: AWSDecodableShape {
        /// The name of the service mesh that the virtual node resides in.
        public let meshName: String
        /// The associated metadata for the virtual node.
        public let metadata: ResourceMetadata
        /// The specifications of the virtual node.
        public let spec: VirtualNodeSpec
        /// The current status for the virtual node.
        public let status: VirtualNodeStatus
        /// The name of the virtual node.
        public let virtualNodeName: String

        public init(meshName: String, metadata: ResourceMetadata, spec: VirtualNodeSpec, status: VirtualNodeStatus, virtualNodeName: String) {
            self.meshName = meshName
            self.metadata = metadata
            self.spec = spec
            self.status = status
            self.virtualNodeName = virtualNodeName
        }

        private enum CodingKeys: String, CodingKey {
            case meshName
            case metadata
            case spec
            case status
            case virtualNodeName
        }
    }

    public struct VirtualNodeGrpcConnectionPool: AWSEncodableShape & AWSDecodableShape {
        /// Maximum number of inflight requests Envoy can concurrently support across hosts in upstream cluster.
        public let maxRequests: Int

        public init(maxRequests: Int) {
            self.maxRequests = maxRequests
        }

        public func validate(name: String) throws {
            try self.validate(self.maxRequests, name: "maxRequests", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case maxRequests
        }
    }

    public struct VirtualNodeHttp2ConnectionPool: AWSEncodableShape & AWSDecodableShape {
        /// Maximum number of inflight requests Envoy can concurrently support across hosts in upstream cluster.
        public let maxRequests: Int

        public init(maxRequests: Int) {
            self.maxRequests = maxRequests
        }

        public func validate(name: String) throws {
            try self.validate(self.maxRequests, name: "maxRequests", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case maxRequests
        }
    }

    public struct VirtualNodeHttpConnectionPool: AWSEncodableShape & AWSDecodableShape {
        /// Maximum number of outbound TCP connections Envoy can establish concurrently with all hosts in upstream cluster.
        public let maxConnections: Int
        /// Number of overflowing requests after max_connections Envoy will queue to upstream cluster.
        public let maxPendingRequests: Int?

        public init(maxConnections: Int, maxPendingRequests: Int? = nil) {
            self.maxConnections = maxConnections
            self.maxPendingRequests = maxPendingRequests
        }

        public func validate(name: String) throws {
            try self.validate(self.maxConnections, name: "maxConnections", parent: name, min: 1)
            try self.validate(self.maxPendingRequests, name: "maxPendingRequests", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case maxConnections
            case maxPendingRequests
        }
    }

    public struct VirtualNodeRef: AWSDecodableShape {
        /// The full Amazon Resource Name (ARN) for the virtual node.
        public let arn: String
        /// The Unix epoch timestamp in seconds for when the resource was created.
        public let createdAt: Date
        /// The Unix epoch timestamp in seconds for when the resource was last updated.
        public let lastUpdatedAt: Date
        /// The name of the service mesh that the virtual node resides in.
        public let meshName: String
        /// The AWS IAM account ID of the service mesh owner. If the account ID is not your own, then it's the ID of the account that shared the mesh with your account. For more information about mesh sharing, see Working with shared meshes.
        public let meshOwner: String
        /// The AWS IAM account ID of the resource owner. If the account ID is not your own, then it's the ID of the mesh owner or of another account that the mesh is shared with. For more information about mesh sharing, see Working with shared meshes.
        public let resourceOwner: String
        /// The version of the resource. Resources are created at version 1, and this version is incremented each time that they're updated.
        public let version: Int64
        /// The name of the virtual node.
        public let virtualNodeName: String

        public init(arn: String, createdAt: Date, lastUpdatedAt: Date, meshName: String, meshOwner: String, resourceOwner: String, version: Int64, virtualNodeName: String) {
            self.arn = arn
            self.createdAt = createdAt
            self.lastUpdatedAt = lastUpdatedAt
            self.meshName = meshName
            self.meshOwner = meshOwner
            self.resourceOwner = resourceOwner
            self.version = version
            self.virtualNodeName = virtualNodeName
        }

        private enum CodingKeys: String, CodingKey {
            case arn
            case createdAt
            case lastUpdatedAt
            case meshName
            case meshOwner
            case resourceOwner
            case version
            case virtualNodeName
        }
    }

    public struct VirtualNodeServiceProvider: AWSEncodableShape & AWSDecodableShape {
        /// The name of the virtual node that is acting as a service provider.
        public let virtualNodeName: String

        public init(virtualNodeName: String) {
            self.virtualNodeName = virtualNodeName
        }

        public func validate(name: String) throws {
            try self.validate(self.virtualNodeName, name: "virtualNodeName", parent: name, max: 255)
            try self.validate(self.virtualNodeName, name: "virtualNodeName", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case virtualNodeName
        }
    }

    public struct VirtualNodeSpec: AWSEncodableShape & AWSDecodableShape {
        /// A reference to an object that represents the defaults for backends.
        public let backendDefaults: BackendDefaults?
        /// The backends that the virtual node is expected to send outbound traffic to.
        public let backends: [Backend]?
        /// The listener that the virtual node is expected to receive inbound traffic from. You can specify one listener.
        public let listeners: [Listener]?
        /// The inbound and outbound access logging information for the virtual node.
        public let logging: Logging?
        /// The service discovery information for the virtual node. If your virtual node does not expect ingress traffic, you can omit this parameter. If you specify a listener, then you must specify service discovery information.
        public let serviceDiscovery: ServiceDiscovery?

        public init(backendDefaults: BackendDefaults? = nil, backends: [Backend]? = nil, listeners: [Listener]? = nil, logging: Logging? = nil, serviceDiscovery: ServiceDiscovery? = nil) {
            self.backendDefaults = backendDefaults
            self.backends = backends
            self.listeners = listeners
            self.logging = logging
            self.serviceDiscovery = serviceDiscovery
        }

        public func validate(name: String) throws {
            try self.backendDefaults?.validate(name: "\(name).backendDefaults")
            try self.backends?.forEach {
                try $0.validate(name: "\(name).backends[]")
            }
            try self.listeners?.forEach {
                try $0.validate(name: "\(name).listeners[]")
            }
            try self.validate(self.listeners, name: "listeners", parent: name, max: 1)
            try self.validate(self.listeners, name: "listeners", parent: name, min: 0)
            try self.logging?.validate(name: "\(name).logging")
            try self.serviceDiscovery?.validate(name: "\(name).serviceDiscovery")
        }

        private enum CodingKeys: String, CodingKey {
            case backendDefaults
            case backends
            case listeners
            case logging
            case serviceDiscovery
        }
    }

    public struct VirtualNodeStatus: AWSDecodableShape {
        /// The current status of the virtual node.
        public let status: VirtualNodeStatusCode

        public init(status: VirtualNodeStatusCode) {
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case status
        }
    }

    public struct VirtualNodeTcpConnectionPool: AWSEncodableShape & AWSDecodableShape {
        /// Maximum number of outbound TCP connections Envoy can establish concurrently with all hosts in upstream cluster.
        public let maxConnections: Int

        public init(maxConnections: Int) {
            self.maxConnections = maxConnections
        }

        public func validate(name: String) throws {
            try self.validate(self.maxConnections, name: "maxConnections", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case maxConnections
        }
    }

    public struct VirtualRouterData: AWSDecodableShape {
        /// The name of the service mesh that the virtual router resides in.
        public let meshName: String
        /// The associated metadata for the virtual router.
        public let metadata: ResourceMetadata
        /// The specifications of the virtual router.
        public let spec: VirtualRouterSpec
        /// The current status of the virtual router.
        public let status: VirtualRouterStatus
        /// The name of the virtual router.
        public let virtualRouterName: String

        public init(meshName: String, metadata: ResourceMetadata, spec: VirtualRouterSpec, status: VirtualRouterStatus, virtualRouterName: String) {
            self.meshName = meshName
            self.metadata = metadata
            self.spec = spec
            self.status = status
            self.virtualRouterName = virtualRouterName
        }

        private enum CodingKeys: String, CodingKey {
            case meshName
            case metadata
            case spec
            case status
            case virtualRouterName
        }
    }

    public struct VirtualRouterListener: AWSEncodableShape & AWSDecodableShape {
        public let portMapping: PortMapping

        public init(portMapping: PortMapping) {
            self.portMapping = portMapping
        }

        public func validate(name: String) throws {
            try self.portMapping.validate(name: "\(name).portMapping")
        }

        private enum CodingKeys: String, CodingKey {
            case portMapping
        }
    }

    public struct VirtualRouterRef: AWSDecodableShape {
        /// The full Amazon Resource Name (ARN) for the virtual router.
        public let arn: String
        /// The Unix epoch timestamp in seconds for when the resource was created.
        public let createdAt: Date
        /// The Unix epoch timestamp in seconds for when the resource was last updated.
        public let lastUpdatedAt: Date
        /// The name of the service mesh that the virtual router resides in.
        public let meshName: String
        /// The AWS IAM account ID of the service mesh owner. If the account ID is not your own, then it's the ID of the account that shared the mesh with your account. For more information about mesh sharing, see Working with shared meshes.
        public let meshOwner: String
        /// The AWS IAM account ID of the resource owner. If the account ID is not your own, then it's the ID of the mesh owner or of another account that the mesh is shared with. For more information about mesh sharing, see Working with shared meshes.
        public let resourceOwner: String
        /// The version of the resource. Resources are created at version 1, and this version is incremented each time that they're updated.
        public let version: Int64
        /// The name of the virtual router.
        public let virtualRouterName: String

        public init(arn: String, createdAt: Date, lastUpdatedAt: Date, meshName: String, meshOwner: String, resourceOwner: String, version: Int64, virtualRouterName: String) {
            self.arn = arn
            self.createdAt = createdAt
            self.lastUpdatedAt = lastUpdatedAt
            self.meshName = meshName
            self.meshOwner = meshOwner
            self.resourceOwner = resourceOwner
            self.version = version
            self.virtualRouterName = virtualRouterName
        }

        private enum CodingKeys: String, CodingKey {
            case arn
            case createdAt
            case lastUpdatedAt
            case meshName
            case meshOwner
            case resourceOwner
            case version
            case virtualRouterName
        }
    }

    public struct VirtualRouterServiceProvider: AWSEncodableShape & AWSDecodableShape {
        /// The name of the virtual router that is acting as a service provider.
        public let virtualRouterName: String

        public init(virtualRouterName: String) {
            self.virtualRouterName = virtualRouterName
        }

        public func validate(name: String) throws {
            try self.validate(self.virtualRouterName, name: "virtualRouterName", parent: name, max: 255)
            try self.validate(self.virtualRouterName, name: "virtualRouterName", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case virtualRouterName
        }
    }

    public struct VirtualRouterSpec: AWSEncodableShape & AWSDecodableShape {
        /// The listeners that the virtual router is expected to receive inbound traffic from. You can specify one listener.
        public let listeners: [VirtualRouterListener]?

        public init(listeners: [VirtualRouterListener]? = nil) {
            self.listeners = listeners
        }

        public func validate(name: String) throws {
            try self.listeners?.forEach {
                try $0.validate(name: "\(name).listeners[]")
            }
            try self.validate(self.listeners, name: "listeners", parent: name, max: 1)
            try self.validate(self.listeners, name: "listeners", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case listeners
        }
    }

    public struct VirtualRouterStatus: AWSDecodableShape {
        /// The current status of the virtual router.
        public let status: VirtualRouterStatusCode

        public init(status: VirtualRouterStatusCode) {
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case status
        }
    }

    public struct VirtualServiceBackend: AWSEncodableShape & AWSDecodableShape {
        /// A reference to an object that represents the client policy for a backend.
        public let clientPolicy: ClientPolicy?
        /// The name of the virtual service that is acting as a virtual node backend.
        public let virtualServiceName: String

        public init(clientPolicy: ClientPolicy? = nil, virtualServiceName: String) {
            self.clientPolicy = clientPolicy
            self.virtualServiceName = virtualServiceName
        }

        public func validate(name: String) throws {
            try self.clientPolicy?.validate(name: "\(name).clientPolicy")
        }

        private enum CodingKeys: String, CodingKey {
            case clientPolicy
            case virtualServiceName
        }
    }

    public struct VirtualServiceData: AWSDecodableShape {
        /// The name of the service mesh that the virtual service resides in.
        public let meshName: String
        public let metadata: ResourceMetadata
        /// The specifications of the virtual service.
        public let spec: VirtualServiceSpec
        /// The current status of the virtual service.
        public let status: VirtualServiceStatus
        /// The name of the virtual service.
        public let virtualServiceName: String

        public init(meshName: String, metadata: ResourceMetadata, spec: VirtualServiceSpec, status: VirtualServiceStatus, virtualServiceName: String) {
            self.meshName = meshName
            self.metadata = metadata
            self.spec = spec
            self.status = status
            self.virtualServiceName = virtualServiceName
        }

        private enum CodingKeys: String, CodingKey {
            case meshName
            case metadata
            case spec
            case status
            case virtualServiceName
        }
    }

    public struct VirtualServiceProvider: AWSEncodableShape & AWSDecodableShape {
        /// The virtual node associated with a virtual service.
        public let virtualNode: VirtualNodeServiceProvider?
        /// The virtual router associated with a virtual service.
        public let virtualRouter: VirtualRouterServiceProvider?

        public init(virtualNode: VirtualNodeServiceProvider? = nil, virtualRouter: VirtualRouterServiceProvider? = nil) {
            self.virtualNode = virtualNode
            self.virtualRouter = virtualRouter
        }

        public func validate(name: String) throws {
            try self.virtualNode?.validate(name: "\(name).virtualNode")
            try self.virtualRouter?.validate(name: "\(name).virtualRouter")
        }

        private enum CodingKeys: String, CodingKey {
            case virtualNode
            case virtualRouter
        }
    }

    public struct VirtualServiceRef: AWSDecodableShape {
        /// The full Amazon Resource Name (ARN) for the virtual service.
        public let arn: String
        /// The Unix epoch timestamp in seconds for when the resource was created.
        public let createdAt: Date
        /// The Unix epoch timestamp in seconds for when the resource was last updated.
        public let lastUpdatedAt: Date
        /// The name of the service mesh that the virtual service resides in.
        public let meshName: String
        /// The AWS IAM account ID of the service mesh owner. If the account ID is not your own, then it's the ID of the account that shared the mesh with your account. For more information about mesh sharing, see Working with shared meshes.
        public let meshOwner: String
        /// The AWS IAM account ID of the resource owner. If the account ID is not your own, then it's the ID of the mesh owner or of another account that the mesh is shared with. For more information about mesh sharing, see Working with shared meshes.
        public let resourceOwner: String
        /// The version of the resource. Resources are created at version 1, and this version is incremented each time that they're updated.
        public let version: Int64
        /// The name of the virtual service.
        public let virtualServiceName: String

        public init(arn: String, createdAt: Date, lastUpdatedAt: Date, meshName: String, meshOwner: String, resourceOwner: String, version: Int64, virtualServiceName: String) {
            self.arn = arn
            self.createdAt = createdAt
            self.lastUpdatedAt = lastUpdatedAt
            self.meshName = meshName
            self.meshOwner = meshOwner
            self.resourceOwner = resourceOwner
            self.version = version
            self.virtualServiceName = virtualServiceName
        }

        private enum CodingKeys: String, CodingKey {
            case arn
            case createdAt
            case lastUpdatedAt
            case meshName
            case meshOwner
            case resourceOwner
            case version
            case virtualServiceName
        }
    }

    public struct VirtualServiceSpec: AWSEncodableShape & AWSDecodableShape {
        /// The App Mesh object that is acting as the provider for a virtual service. You can specify a single virtual node or virtual router.
        public let provider: VirtualServiceProvider?

        public init(provider: VirtualServiceProvider? = nil) {
            self.provider = provider
        }

        public func validate(name: String) throws {
            try self.provider?.validate(name: "\(name).provider")
        }

        private enum CodingKeys: String, CodingKey {
            case provider
        }
    }

    public struct VirtualServiceStatus: AWSDecodableShape {
        /// The current status of the virtual service.
        public let status: VirtualServiceStatusCode

        public init(status: VirtualServiceStatusCode) {
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case status
        }
    }

    public struct WeightedTarget: AWSEncodableShape & AWSDecodableShape {
        /// The virtual node to associate with the weighted target.
        public let virtualNode: String
        /// The relative weight of the weighted target.
        public let weight: Int

        public init(virtualNode: String, weight: Int) {
            self.virtualNode = virtualNode
            self.weight = weight
        }

        public func validate(name: String) throws {
            try self.validate(self.virtualNode, name: "virtualNode", parent: name, max: 255)
            try self.validate(self.virtualNode, name: "virtualNode", parent: name, min: 1)
            try self.validate(self.weight, name: "weight", parent: name, max: 100)
            try self.validate(self.weight, name: "weight", parent: name, min: 0)
        }

        private enum CodingKeys: String, CodingKey {
            case virtualNode
            case weight
        }
    }
}
