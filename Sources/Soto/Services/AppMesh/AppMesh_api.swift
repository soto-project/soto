//===----------------------------------------------------------------------===//
//
// This source file is part of the Soto for AWS open source project
//
// Copyright (c) 2017-2024 the Soto project authors
// Licensed under Apache License v2.0
//
// See LICENSE.txt for license information
// See CONTRIBUTORS.txt for the list of Soto project authors
//
// SPDX-License-Identifier: Apache-2.0
//
//===----------------------------------------------------------------------===//

// THIS FILE IS AUTOMATICALLY GENERATED by https://github.com/soto-project/soto-codegenerator.
// DO NOT EDIT.

#if os(Linux) && compiler(<5.10)
// swift-corelibs-foundation hasn't been updated with Sendable conformances
@preconcurrency import Foundation
#else
import Foundation
#endif
@_exported import SotoCore

/// Service object for interacting with AWS AppMesh service.
///
/// App Mesh is a service mesh based on the Envoy proxy that makes it easy to monitor and control microservices. App Mesh standardizes how your microservices communicate, giving you end-to-end visibility and helping to ensure high availability for your applications. App Mesh gives you consistent visibility and network traffic controls for every microservice in an application. You can use App Mesh with Amazon Web Services Fargate, Amazon ECS, Amazon EKS, Kubernetes on Amazon Web Services, and Amazon EC2.  App Mesh supports microservice applications that use service discovery naming for their components. For more information about service discovery on Amazon ECS, see Service Discovery in the Amazon Elastic Container Service Developer Guide. Kubernetes kube-dns and coredns are supported. For more information, see DNS for Services and Pods in the Kubernetes documentation.
public struct AppMesh: AWSService {
    // MARK: Member variables

    /// Client used for communication with AWS
    public let client: AWSClient
    /// Service configuration
    public let config: AWSServiceConfig

    // MARK: Initialization

    /// Initialize the AppMesh client
    /// - parameters:
    ///     - client: AWSClient used to process requests
    ///     - region: Region of server you want to communicate with. This will override the partition parameter.
    ///     - partition: AWS partition where service resides, standard (.aws), china (.awscn), government (.awsusgov).
    ///     - endpoint: Custom endpoint URL to use instead of standard AWS servers
    ///     - middleware: Middleware chain used to edit requests before they are sent and responses before they are decoded 
    ///     - timeout: Timeout value for HTTP requests
    ///     - byteBufferAllocator: Allocator for ByteBuffers
    ///     - options: Service options
    public init(
        client: AWSClient,
        region: SotoCore.Region? = nil,
        partition: AWSPartition = .aws,
        endpoint: String? = nil,
        middleware: AWSMiddlewareProtocol? = nil,
        timeout: TimeAmount? = nil,
        byteBufferAllocator: ByteBufferAllocator = ByteBufferAllocator(),
        options: AWSServiceConfig.Options = []
    ) {
        self.client = client
        self.config = AWSServiceConfig(
            region: region,
            partition: region?.partition ?? partition,
            serviceName: "AppMesh",
            serviceIdentifier: "appmesh",
            serviceProtocol: .restjson,
            apiVersion: "2019-01-25",
            endpoint: endpoint,
            variantEndpoints: Self.variantEndpoints,
            errorType: AppMeshErrorType.self,
            middleware: middleware,
            timeout: timeout,
            byteBufferAllocator: byteBufferAllocator,
            options: options
        )
    }




    /// FIPS and dualstack endpoints
    static var variantEndpoints: [EndpointVariantType: AWSServiceConfig.EndpointVariant] {[
        [.dualstack]: .init(endpoints: [
            "af-south-1": "appmesh.af-south-1.api.aws",
            "ap-east-1": "appmesh.ap-east-1.api.aws",
            "ap-northeast-1": "appmesh.ap-northeast-1.api.aws",
            "ap-northeast-2": "appmesh.ap-northeast-2.api.aws",
            "ap-northeast-3": "appmesh.ap-northeast-3.api.aws",
            "ap-south-1": "appmesh.ap-south-1.api.aws",
            "ap-southeast-1": "appmesh.ap-southeast-1.api.aws",
            "ap-southeast-2": "appmesh.ap-southeast-2.api.aws",
            "ap-southeast-3": "appmesh.ap-southeast-3.api.aws",
            "ca-central-1": "appmesh.ca-central-1.api.aws",
            "cn-north-1": "appmesh.cn-north-1.api.amazonwebservices.com.cn",
            "cn-northwest-1": "appmesh.cn-northwest-1.api.amazonwebservices.com.cn",
            "eu-central-1": "appmesh.eu-central-1.api.aws",
            "eu-central-2": "appmesh.eu-central-2.api.aws",
            "eu-north-1": "appmesh.eu-north-1.api.aws",
            "eu-south-1": "appmesh.eu-south-1.api.aws",
            "eu-south-2": "appmesh.eu-south-2.api.aws",
            "eu-west-1": "appmesh.eu-west-1.api.aws",
            "eu-west-2": "appmesh.eu-west-2.api.aws",
            "eu-west-3": "appmesh.eu-west-3.api.aws",
            "il-central-1": "appmesh.il-central-1.api.aws",
            "me-south-1": "appmesh.me-south-1.api.aws",
            "sa-east-1": "appmesh.sa-east-1.api.aws",
            "us-east-1": "appmesh.us-east-1.api.aws",
            "us-east-2": "appmesh.us-east-2.api.aws",
            "us-west-1": "appmesh.us-west-1.api.aws",
            "us-west-2": "appmesh.us-west-2.api.aws"
        ]),
        [.dualstack, .fips]: .init(endpoints: [
            "ca-central-1": "appmesh-fips.ca-central-1.api.aws",
            "us-east-1": "appmesh-fips.us-east-1.api.aws",
            "us-east-2": "appmesh-fips.us-east-2.api.aws",
            "us-west-1": "appmesh-fips.us-west-1.api.aws",
            "us-west-2": "appmesh-fips.us-west-2.api.aws"
        ]),
        [.fips]: .init(endpoints: [
            "ca-central-1": "appmesh-fips.ca-central-1.amazonaws.com",
            "us-east-1": "appmesh-fips.us-east-1.amazonaws.com",
            "us-east-2": "appmesh-fips.us-east-2.amazonaws.com",
            "us-west-1": "appmesh-fips.us-west-1.amazonaws.com",
            "us-west-2": "appmesh-fips.us-west-2.amazonaws.com"
        ])
    ]}

    // MARK: API Calls

    /// Creates a gateway route. A gateway route is attached to a virtual gateway and routes traffic to an existing virtual service. If a route matches a request, it can distribute traffic to a target virtual service. For more information about gateway routes, see Gateway routes.
    @Sendable
    @inlinable
    public func createGatewayRoute(_ input: CreateGatewayRouteInput, logger: Logger = AWSClient.loggingDisabled) async throws -> CreateGatewayRouteOutput {
        try await self.client.execute(
            operation: "CreateGatewayRoute", 
            path: "/v20190125/meshes/{meshName}/virtualGateway/{virtualGatewayName}/gatewayRoutes", 
            httpMethod: .PUT, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Creates a gateway route. A gateway route is attached to a virtual gateway and routes traffic to an existing virtual service. If a route matches a request, it can distribute traffic to a target virtual service. For more information about gateway routes, see Gateway routes.
    ///
    /// Parameters:
    ///   - clientToken: Unique, case-sensitive identifier that you provide to ensure the idempotency of the
    ///   - gatewayRouteName: The name to use for the gateway route.
    ///   - meshName: The name of the service mesh to create the gateway route in.
    ///   - meshOwner: The Amazon Web Services IAM account ID of the service mesh owner. If the account ID is not your own, then the account that you specify must share the mesh with your account before you can create  the resource in the service mesh. For more information about mesh sharing, see Working with shared meshes.
    ///   - spec: The gateway route specification to apply.
    ///   - tags: Optional metadata that you can apply to the gateway route to assist with categorization and organization. Each tag consists of a key and an optional value, both of which you define. Tag keys can have a maximum character length of 128 characters, and tag values can have a maximum length of 256 characters.
    ///   - virtualGatewayName: The name of the virtual gateway to associate the gateway route with. If the virtual gateway is in a shared mesh, then you must be the owner of the virtual gateway resource.
    ///   - logger: Logger use during operation
    @inlinable
    public func createGatewayRoute(
        clientToken: String? = CreateGatewayRouteInput.idempotencyToken(),
        gatewayRouteName: String,
        meshName: String,
        meshOwner: String? = nil,
        spec: GatewayRouteSpec,
        tags: [TagRef]? = nil,
        virtualGatewayName: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> CreateGatewayRouteOutput {
        let input = CreateGatewayRouteInput(
            clientToken: clientToken, 
            gatewayRouteName: gatewayRouteName, 
            meshName: meshName, 
            meshOwner: meshOwner, 
            spec: spec, 
            tags: tags, 
            virtualGatewayName: virtualGatewayName
        )
        return try await self.createGatewayRoute(input, logger: logger)
    }

    /// Creates a service mesh. A service mesh is a logical boundary for network traffic between services that are represented by resources within the mesh. After you create your service mesh, you can create virtual services, virtual nodes, virtual routers, and routes to distribute traffic between the applications in your mesh. For more information about service meshes, see Service meshes.
    @Sendable
    @inlinable
    public func createMesh(_ input: CreateMeshInput, logger: Logger = AWSClient.loggingDisabled) async throws -> CreateMeshOutput {
        try await self.client.execute(
            operation: "CreateMesh", 
            path: "/v20190125/meshes", 
            httpMethod: .PUT, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Creates a service mesh. A service mesh is a logical boundary for network traffic between services that are represented by resources within the mesh. After you create your service mesh, you can create virtual services, virtual nodes, virtual routers, and routes to distribute traffic between the applications in your mesh. For more information about service meshes, see Service meshes.
    ///
    /// Parameters:
    ///   - clientToken: Unique, case-sensitive identifier that you provide to ensure the idempotency of the
    ///   - meshName: The name to use for the service mesh.
    ///   - spec: The service mesh specification to apply.
    ///   - tags: Optional metadata that you can apply to the service mesh to assist with categorization and organization. Each tag consists of a key and an optional value, both of which you define. Tag keys can have a maximum character length of 128 characters, and tag values can have a maximum length of 256 characters.
    ///   - logger: Logger use during operation
    @inlinable
    public func createMesh(
        clientToken: String? = CreateMeshInput.idempotencyToken(),
        meshName: String,
        spec: MeshSpec? = nil,
        tags: [TagRef]? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> CreateMeshOutput {
        let input = CreateMeshInput(
            clientToken: clientToken, 
            meshName: meshName, 
            spec: spec, 
            tags: tags
        )
        return try await self.createMesh(input, logger: logger)
    }

    /// Creates a route that is associated with a virtual router. You can route several different protocols and define a retry policy for a route. Traffic can be routed to one or more virtual nodes. For more information about routes, see Routes.
    @Sendable
    @inlinable
    public func createRoute(_ input: CreateRouteInput, logger: Logger = AWSClient.loggingDisabled) async throws -> CreateRouteOutput {
        try await self.client.execute(
            operation: "CreateRoute", 
            path: "/v20190125/meshes/{meshName}/virtualRouter/{virtualRouterName}/routes", 
            httpMethod: .PUT, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Creates a route that is associated with a virtual router. You can route several different protocols and define a retry policy for a route. Traffic can be routed to one or more virtual nodes. For more information about routes, see Routes.
    ///
    /// Parameters:
    ///   - clientToken: Unique, case-sensitive identifier that you provide to ensure the idempotency of the
    ///   - meshName: The name of the service mesh to create the route in.
    ///   - meshOwner: The Amazon Web Services IAM account ID of the service mesh owner. If the account ID is not your own, then the account that you specify must share the mesh with your account before you can create  the resource in the service mesh. For more information about mesh sharing, see Working with shared meshes.
    ///   - routeName: The name to use for the route.
    ///   - spec: The route specification to apply.
    ///   - tags: Optional metadata that you can apply to the route to assist with categorization and organization. Each tag consists of a key and an optional value, both of which you define. Tag keys can have a maximum character length of 128 characters, and tag values can have a maximum length of 256 characters.
    ///   - virtualRouterName: The name of the virtual router in which to create the route. If the virtual router is in a shared mesh, then you must be the owner of the virtual router resource.
    ///   - logger: Logger use during operation
    @inlinable
    public func createRoute(
        clientToken: String? = CreateRouteInput.idempotencyToken(),
        meshName: String,
        meshOwner: String? = nil,
        routeName: String,
        spec: RouteSpec,
        tags: [TagRef]? = nil,
        virtualRouterName: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> CreateRouteOutput {
        let input = CreateRouteInput(
            clientToken: clientToken, 
            meshName: meshName, 
            meshOwner: meshOwner, 
            routeName: routeName, 
            spec: spec, 
            tags: tags, 
            virtualRouterName: virtualRouterName
        )
        return try await self.createRoute(input, logger: logger)
    }

    /// Creates a virtual gateway. A virtual gateway allows resources outside your mesh to communicate to resources that are inside your mesh. The virtual gateway represents an Envoy proxy running in an Amazon ECS task, in a Kubernetes service, or on an Amazon EC2 instance. Unlike a virtual node, which represents an Envoy running with an application, a virtual gateway represents Envoy deployed by itself. For more information about virtual gateways, see Virtual gateways.
    @Sendable
    @inlinable
    public func createVirtualGateway(_ input: CreateVirtualGatewayInput, logger: Logger = AWSClient.loggingDisabled) async throws -> CreateVirtualGatewayOutput {
        try await self.client.execute(
            operation: "CreateVirtualGateway", 
            path: "/v20190125/meshes/{meshName}/virtualGateways", 
            httpMethod: .PUT, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Creates a virtual gateway. A virtual gateway allows resources outside your mesh to communicate to resources that are inside your mesh. The virtual gateway represents an Envoy proxy running in an Amazon ECS task, in a Kubernetes service, or on an Amazon EC2 instance. Unlike a virtual node, which represents an Envoy running with an application, a virtual gateway represents Envoy deployed by itself. For more information about virtual gateways, see Virtual gateways.
    ///
    /// Parameters:
    ///   - clientToken: Unique, case-sensitive identifier that you provide to ensure the idempotency of the
    ///   - meshName: The name of the service mesh to create the virtual gateway in.
    ///   - meshOwner: The Amazon Web Services IAM account ID of the service mesh owner. If the account ID is not your own, then the account that you specify must share the mesh with your account before you can create  the resource in the service mesh. For more information about mesh sharing, see Working with shared meshes.
    ///   - spec: The virtual gateway specification to apply.
    ///   - tags: Optional metadata that you can apply to the virtual gateway to assist with categorization and organization. Each tag consists of a key and an optional value, both of which you define. Tag keys can have a maximum character length of 128 characters, and tag values can have a maximum length of 256 characters.
    ///   - virtualGatewayName: The name to use for the virtual gateway.
    ///   - logger: Logger use during operation
    @inlinable
    public func createVirtualGateway(
        clientToken: String? = CreateVirtualGatewayInput.idempotencyToken(),
        meshName: String,
        meshOwner: String? = nil,
        spec: VirtualGatewaySpec,
        tags: [TagRef]? = nil,
        virtualGatewayName: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> CreateVirtualGatewayOutput {
        let input = CreateVirtualGatewayInput(
            clientToken: clientToken, 
            meshName: meshName, 
            meshOwner: meshOwner, 
            spec: spec, 
            tags: tags, 
            virtualGatewayName: virtualGatewayName
        )
        return try await self.createVirtualGateway(input, logger: logger)
    }

    /// Creates a virtual node within a service mesh. A virtual node acts as a logical pointer to a particular task group, such as an Amazon ECS service or a Kubernetes deployment. When you create a virtual node, you can specify the service discovery information for your task group, and whether the proxy running in a task group will communicate with other proxies using Transport Layer Security (TLS). You define a listener for any inbound traffic that your virtual node expects. Any virtual service that your virtual node expects to communicate to is specified as a backend. The response metadata for your new virtual node contains the arn that is associated with the virtual node. Set this value to the full ARN; for example, arn:aws:appmesh:us-west-2:123456789012:myMesh/default/virtualNode/myApp) as the APPMESH_RESOURCE_ARN environment variable for your task group's Envoy proxy container in your task definition or pod spec. This is then mapped to the node.id and node.cluster Envoy parameters.  By default, App Mesh uses the name of the resource you specified in APPMESH_RESOURCE_ARN when Envoy is referring to itself in metrics and traces. You can override this behavior by setting the APPMESH_RESOURCE_CLUSTER environment variable with your own name.  For more information about virtual nodes, see Virtual nodes. You must be using 1.15.0 or later of the Envoy image when setting these variables. For more information aboutApp Mesh Envoy variables, see Envoy image in the App Mesh User Guide.
    @Sendable
    @inlinable
    public func createVirtualNode(_ input: CreateVirtualNodeInput, logger: Logger = AWSClient.loggingDisabled) async throws -> CreateVirtualNodeOutput {
        try await self.client.execute(
            operation: "CreateVirtualNode", 
            path: "/v20190125/meshes/{meshName}/virtualNodes", 
            httpMethod: .PUT, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Creates a virtual node within a service mesh. A virtual node acts as a logical pointer to a particular task group, such as an Amazon ECS service or a Kubernetes deployment. When you create a virtual node, you can specify the service discovery information for your task group, and whether the proxy running in a task group will communicate with other proxies using Transport Layer Security (TLS). You define a listener for any inbound traffic that your virtual node expects. Any virtual service that your virtual node expects to communicate to is specified as a backend. The response metadata for your new virtual node contains the arn that is associated with the virtual node. Set this value to the full ARN; for example, arn:aws:appmesh:us-west-2:123456789012:myMesh/default/virtualNode/myApp) as the APPMESH_RESOURCE_ARN environment variable for your task group's Envoy proxy container in your task definition or pod spec. This is then mapped to the node.id and node.cluster Envoy parameters.  By default, App Mesh uses the name of the resource you specified in APPMESH_RESOURCE_ARN when Envoy is referring to itself in metrics and traces. You can override this behavior by setting the APPMESH_RESOURCE_CLUSTER environment variable with your own name.  For more information about virtual nodes, see Virtual nodes. You must be using 1.15.0 or later of the Envoy image when setting these variables. For more information aboutApp Mesh Envoy variables, see Envoy image in the App Mesh User Guide.
    ///
    /// Parameters:
    ///   - clientToken: Unique, case-sensitive identifier that you provide to ensure the idempotency of the
    ///   - meshName: The name of the service mesh to create the virtual node in.
    ///   - meshOwner: The Amazon Web Services IAM account ID of the service mesh owner. If the account ID is not your own, then the account that you specify must share the mesh with your account before you can create  the resource in the service mesh. For more information about mesh sharing, see Working with shared meshes.
    ///   - spec: The virtual node specification to apply.
    ///   - tags: Optional metadata that you can apply to the virtual node to assist with categorization and organization. Each tag consists of a key and an optional value, both of which you define. Tag keys can have a maximum character length of 128 characters, and tag values can have a maximum length of 256 characters.
    ///   - virtualNodeName: The name to use for the virtual node.
    ///   - logger: Logger use during operation
    @inlinable
    public func createVirtualNode(
        clientToken: String? = CreateVirtualNodeInput.idempotencyToken(),
        meshName: String,
        meshOwner: String? = nil,
        spec: VirtualNodeSpec,
        tags: [TagRef]? = nil,
        virtualNodeName: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> CreateVirtualNodeOutput {
        let input = CreateVirtualNodeInput(
            clientToken: clientToken, 
            meshName: meshName, 
            meshOwner: meshOwner, 
            spec: spec, 
            tags: tags, 
            virtualNodeName: virtualNodeName
        )
        return try await self.createVirtualNode(input, logger: logger)
    }

    /// Creates a virtual router within a service mesh. Specify a listener for any inbound traffic that your virtual router receives. Create a virtual router for each protocol and port that you need to route. Virtual routers handle traffic for one or more virtual services within your mesh. After you create your virtual router, create and associate routes for your virtual router that direct incoming requests to different virtual nodes. For more information about virtual routers, see Virtual routers.
    @Sendable
    @inlinable
    public func createVirtualRouter(_ input: CreateVirtualRouterInput, logger: Logger = AWSClient.loggingDisabled) async throws -> CreateVirtualRouterOutput {
        try await self.client.execute(
            operation: "CreateVirtualRouter", 
            path: "/v20190125/meshes/{meshName}/virtualRouters", 
            httpMethod: .PUT, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Creates a virtual router within a service mesh. Specify a listener for any inbound traffic that your virtual router receives. Create a virtual router for each protocol and port that you need to route. Virtual routers handle traffic for one or more virtual services within your mesh. After you create your virtual router, create and associate routes for your virtual router that direct incoming requests to different virtual nodes. For more information about virtual routers, see Virtual routers.
    ///
    /// Parameters:
    ///   - clientToken: Unique, case-sensitive identifier that you provide to ensure the idempotency of the
    ///   - meshName: The name of the service mesh to create the virtual router in.
    ///   - meshOwner: The Amazon Web Services IAM account ID of the service mesh owner. If the account ID is not your own, then the account that you specify must share the mesh with your account before you can create  the resource in the service mesh. For more information about mesh sharing, see Working with shared meshes.
    ///   - spec: The virtual router specification to apply.
    ///   - tags: Optional metadata that you can apply to the virtual router to assist with categorization and organization. Each tag consists of a key and an optional value, both of which you define. Tag keys can have a maximum character length of 128 characters, and tag values can have a maximum length of 256 characters.
    ///   - virtualRouterName: The name to use for the virtual router.
    ///   - logger: Logger use during operation
    @inlinable
    public func createVirtualRouter(
        clientToken: String? = CreateVirtualRouterInput.idempotencyToken(),
        meshName: String,
        meshOwner: String? = nil,
        spec: VirtualRouterSpec,
        tags: [TagRef]? = nil,
        virtualRouterName: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> CreateVirtualRouterOutput {
        let input = CreateVirtualRouterInput(
            clientToken: clientToken, 
            meshName: meshName, 
            meshOwner: meshOwner, 
            spec: spec, 
            tags: tags, 
            virtualRouterName: virtualRouterName
        )
        return try await self.createVirtualRouter(input, logger: logger)
    }

    /// Creates a virtual service within a service mesh. A virtual service is an abstraction of a real service that is provided by a virtual node directly or indirectly by means of a virtual router. Dependent services call your virtual service by its virtualServiceName, and those requests are routed to the virtual node or virtual router that is specified as the provider for the virtual service. For more information about virtual services, see Virtual services.
    @Sendable
    @inlinable
    public func createVirtualService(_ input: CreateVirtualServiceInput, logger: Logger = AWSClient.loggingDisabled) async throws -> CreateVirtualServiceOutput {
        try await self.client.execute(
            operation: "CreateVirtualService", 
            path: "/v20190125/meshes/{meshName}/virtualServices", 
            httpMethod: .PUT, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Creates a virtual service within a service mesh. A virtual service is an abstraction of a real service that is provided by a virtual node directly or indirectly by means of a virtual router. Dependent services call your virtual service by its virtualServiceName, and those requests are routed to the virtual node or virtual router that is specified as the provider for the virtual service. For more information about virtual services, see Virtual services.
    ///
    /// Parameters:
    ///   - clientToken: Unique, case-sensitive identifier that you provide to ensure the idempotency of the
    ///   - meshName: The name of the service mesh to create the virtual service in.
    ///   - meshOwner: The Amazon Web Services IAM account ID of the service mesh owner. If the account ID is not your own, then the account that you specify must share the mesh with your account before you can create  the resource in the service mesh. For more information about mesh sharing, see Working with shared meshes.
    ///   - spec: The virtual service specification to apply.
    ///   - tags: Optional metadata that you can apply to the virtual service to assist with categorization and organization. Each tag consists of a key and an optional value, both of which you define. Tag keys can have a maximum character length of 128 characters, and tag values can have a maximum length of 256 characters.
    ///   - virtualServiceName: The name to use for the virtual service.
    ///   - logger: Logger use during operation
    @inlinable
    public func createVirtualService(
        clientToken: String? = CreateVirtualServiceInput.idempotencyToken(),
        meshName: String,
        meshOwner: String? = nil,
        spec: VirtualServiceSpec,
        tags: [TagRef]? = nil,
        virtualServiceName: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> CreateVirtualServiceOutput {
        let input = CreateVirtualServiceInput(
            clientToken: clientToken, 
            meshName: meshName, 
            meshOwner: meshOwner, 
            spec: spec, 
            tags: tags, 
            virtualServiceName: virtualServiceName
        )
        return try await self.createVirtualService(input, logger: logger)
    }

    /// Deletes an existing gateway route.
    @Sendable
    @inlinable
    public func deleteGatewayRoute(_ input: DeleteGatewayRouteInput, logger: Logger = AWSClient.loggingDisabled) async throws -> DeleteGatewayRouteOutput {
        try await self.client.execute(
            operation: "DeleteGatewayRoute", 
            path: "/v20190125/meshes/{meshName}/virtualGateway/{virtualGatewayName}/gatewayRoutes/{gatewayRouteName}", 
            httpMethod: .DELETE, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Deletes an existing gateway route.
    ///
    /// Parameters:
    ///   - gatewayRouteName: The name of the gateway route to delete.
    ///   - meshName: The name of the service mesh to delete the gateway route from.
    ///   - meshOwner: The Amazon Web Services IAM account ID of the service mesh owner. If the account ID is not your own, then it's the ID of the account that shared the mesh with your account. For more information about mesh sharing, see Working with shared meshes.
    ///   - virtualGatewayName: The name of the virtual gateway to delete the route from.
    ///   - logger: Logger use during operation
    @inlinable
    public func deleteGatewayRoute(
        gatewayRouteName: String,
        meshName: String,
        meshOwner: String? = nil,
        virtualGatewayName: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> DeleteGatewayRouteOutput {
        let input = DeleteGatewayRouteInput(
            gatewayRouteName: gatewayRouteName, 
            meshName: meshName, 
            meshOwner: meshOwner, 
            virtualGatewayName: virtualGatewayName
        )
        return try await self.deleteGatewayRoute(input, logger: logger)
    }

    /// Deletes an existing service mesh. You must delete all resources (virtual services, routes, virtual routers, and virtual nodes) in the service mesh before you can delete the mesh itself.
    @Sendable
    @inlinable
    public func deleteMesh(_ input: DeleteMeshInput, logger: Logger = AWSClient.loggingDisabled) async throws -> DeleteMeshOutput {
        try await self.client.execute(
            operation: "DeleteMesh", 
            path: "/v20190125/meshes/{meshName}", 
            httpMethod: .DELETE, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Deletes an existing service mesh. You must delete all resources (virtual services, routes, virtual routers, and virtual nodes) in the service mesh before you can delete the mesh itself.
    ///
    /// Parameters:
    ///   - meshName: The name of the service mesh to delete.
    ///   - logger: Logger use during operation
    @inlinable
    public func deleteMesh(
        meshName: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> DeleteMeshOutput {
        let input = DeleteMeshInput(
            meshName: meshName
        )
        return try await self.deleteMesh(input, logger: logger)
    }

    /// Deletes an existing route.
    @Sendable
    @inlinable
    public func deleteRoute(_ input: DeleteRouteInput, logger: Logger = AWSClient.loggingDisabled) async throws -> DeleteRouteOutput {
        try await self.client.execute(
            operation: "DeleteRoute", 
            path: "/v20190125/meshes/{meshName}/virtualRouter/{virtualRouterName}/routes/{routeName}", 
            httpMethod: .DELETE, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Deletes an existing route.
    ///
    /// Parameters:
    ///   - meshName: The name of the service mesh to delete the route in.
    ///   - meshOwner: The Amazon Web Services IAM account ID of the service mesh owner. If the account ID is not your own, then it's the ID of the account that shared the mesh with your account. For more information about mesh sharing, see Working with shared meshes.
    ///   - routeName: The name of the route to delete.
    ///   - virtualRouterName: The name of the virtual router to delete the route in.
    ///   - logger: Logger use during operation
    @inlinable
    public func deleteRoute(
        meshName: String,
        meshOwner: String? = nil,
        routeName: String,
        virtualRouterName: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> DeleteRouteOutput {
        let input = DeleteRouteInput(
            meshName: meshName, 
            meshOwner: meshOwner, 
            routeName: routeName, 
            virtualRouterName: virtualRouterName
        )
        return try await self.deleteRoute(input, logger: logger)
    }

    /// Deletes an existing virtual gateway. You cannot delete a virtual gateway if any gateway routes are associated to it.
    @Sendable
    @inlinable
    public func deleteVirtualGateway(_ input: DeleteVirtualGatewayInput, logger: Logger = AWSClient.loggingDisabled) async throws -> DeleteVirtualGatewayOutput {
        try await self.client.execute(
            operation: "DeleteVirtualGateway", 
            path: "/v20190125/meshes/{meshName}/virtualGateways/{virtualGatewayName}", 
            httpMethod: .DELETE, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Deletes an existing virtual gateway. You cannot delete a virtual gateway if any gateway routes are associated to it.
    ///
    /// Parameters:
    ///   - meshName: The name of the service mesh to delete the virtual gateway from.
    ///   - meshOwner: The Amazon Web Services IAM account ID of the service mesh owner. If the account ID is not your own, then it's the ID of the account that shared the mesh with your account. For more information about mesh sharing, see Working with shared meshes.
    ///   - virtualGatewayName: The name of the virtual gateway to delete.
    ///   - logger: Logger use during operation
    @inlinable
    public func deleteVirtualGateway(
        meshName: String,
        meshOwner: String? = nil,
        virtualGatewayName: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> DeleteVirtualGatewayOutput {
        let input = DeleteVirtualGatewayInput(
            meshName: meshName, 
            meshOwner: meshOwner, 
            virtualGatewayName: virtualGatewayName
        )
        return try await self.deleteVirtualGateway(input, logger: logger)
    }

    /// Deletes an existing virtual node. You must delete any virtual services that list a virtual node as a service provider before you can delete the virtual node itself.
    @Sendable
    @inlinable
    public func deleteVirtualNode(_ input: DeleteVirtualNodeInput, logger: Logger = AWSClient.loggingDisabled) async throws -> DeleteVirtualNodeOutput {
        try await self.client.execute(
            operation: "DeleteVirtualNode", 
            path: "/v20190125/meshes/{meshName}/virtualNodes/{virtualNodeName}", 
            httpMethod: .DELETE, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Deletes an existing virtual node. You must delete any virtual services that list a virtual node as a service provider before you can delete the virtual node itself.
    ///
    /// Parameters:
    ///   - meshName: The name of the service mesh to delete the virtual node in.
    ///   - meshOwner: The Amazon Web Services IAM account ID of the service mesh owner. If the account ID is not your own, then it's the ID of the account that shared the mesh with your account. For more information about mesh sharing, see Working with shared meshes.
    ///   - virtualNodeName: The name of the virtual node to delete.
    ///   - logger: Logger use during operation
    @inlinable
    public func deleteVirtualNode(
        meshName: String,
        meshOwner: String? = nil,
        virtualNodeName: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> DeleteVirtualNodeOutput {
        let input = DeleteVirtualNodeInput(
            meshName: meshName, 
            meshOwner: meshOwner, 
            virtualNodeName: virtualNodeName
        )
        return try await self.deleteVirtualNode(input, logger: logger)
    }

    /// Deletes an existing virtual router. You must delete any routes associated with the virtual router before you can delete the router itself.
    @Sendable
    @inlinable
    public func deleteVirtualRouter(_ input: DeleteVirtualRouterInput, logger: Logger = AWSClient.loggingDisabled) async throws -> DeleteVirtualRouterOutput {
        try await self.client.execute(
            operation: "DeleteVirtualRouter", 
            path: "/v20190125/meshes/{meshName}/virtualRouters/{virtualRouterName}", 
            httpMethod: .DELETE, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Deletes an existing virtual router. You must delete any routes associated with the virtual router before you can delete the router itself.
    ///
    /// Parameters:
    ///   - meshName: The name of the service mesh to delete the virtual router in.
    ///   - meshOwner: The Amazon Web Services IAM account ID of the service mesh owner. If the account ID is not your own, then it's the ID of the account that shared the mesh with your account. For more information about mesh sharing, see Working with shared meshes.
    ///   - virtualRouterName: The name of the virtual router to delete.
    ///   - logger: Logger use during operation
    @inlinable
    public func deleteVirtualRouter(
        meshName: String,
        meshOwner: String? = nil,
        virtualRouterName: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> DeleteVirtualRouterOutput {
        let input = DeleteVirtualRouterInput(
            meshName: meshName, 
            meshOwner: meshOwner, 
            virtualRouterName: virtualRouterName
        )
        return try await self.deleteVirtualRouter(input, logger: logger)
    }

    /// Deletes an existing virtual service.
    @Sendable
    @inlinable
    public func deleteVirtualService(_ input: DeleteVirtualServiceInput, logger: Logger = AWSClient.loggingDisabled) async throws -> DeleteVirtualServiceOutput {
        try await self.client.execute(
            operation: "DeleteVirtualService", 
            path: "/v20190125/meshes/{meshName}/virtualServices/{virtualServiceName}", 
            httpMethod: .DELETE, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Deletes an existing virtual service.
    ///
    /// Parameters:
    ///   - meshName: The name of the service mesh to delete the virtual service in.
    ///   - meshOwner: The Amazon Web Services IAM account ID of the service mesh owner. If the account ID is not your own, then it's the ID of the account that shared the mesh with your account. For more information about mesh sharing, see Working with shared meshes.
    ///   - virtualServiceName: The name of the virtual service to delete.
    ///   - logger: Logger use during operation
    @inlinable
    public func deleteVirtualService(
        meshName: String,
        meshOwner: String? = nil,
        virtualServiceName: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> DeleteVirtualServiceOutput {
        let input = DeleteVirtualServiceInput(
            meshName: meshName, 
            meshOwner: meshOwner, 
            virtualServiceName: virtualServiceName
        )
        return try await self.deleteVirtualService(input, logger: logger)
    }

    /// Describes an existing gateway route.
    @Sendable
    @inlinable
    public func describeGatewayRoute(_ input: DescribeGatewayRouteInput, logger: Logger = AWSClient.loggingDisabled) async throws -> DescribeGatewayRouteOutput {
        try await self.client.execute(
            operation: "DescribeGatewayRoute", 
            path: "/v20190125/meshes/{meshName}/virtualGateway/{virtualGatewayName}/gatewayRoutes/{gatewayRouteName}", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Describes an existing gateway route.
    ///
    /// Parameters:
    ///   - gatewayRouteName: The name of the gateway route to describe.
    ///   - meshName: The name of the service mesh that the gateway route resides in.
    ///   - meshOwner: The Amazon Web Services IAM account ID of the service mesh owner. If the account ID is not your own, then it's the ID of the account that shared the mesh with your account. For more information about mesh sharing, see Working with shared meshes.
    ///   - virtualGatewayName: The name of the virtual gateway that the gateway route is associated with.
    ///   - logger: Logger use during operation
    @inlinable
    public func describeGatewayRoute(
        gatewayRouteName: String,
        meshName: String,
        meshOwner: String? = nil,
        virtualGatewayName: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> DescribeGatewayRouteOutput {
        let input = DescribeGatewayRouteInput(
            gatewayRouteName: gatewayRouteName, 
            meshName: meshName, 
            meshOwner: meshOwner, 
            virtualGatewayName: virtualGatewayName
        )
        return try await self.describeGatewayRoute(input, logger: logger)
    }

    /// Describes an existing service mesh.
    @Sendable
    @inlinable
    public func describeMesh(_ input: DescribeMeshInput, logger: Logger = AWSClient.loggingDisabled) async throws -> DescribeMeshOutput {
        try await self.client.execute(
            operation: "DescribeMesh", 
            path: "/v20190125/meshes/{meshName}", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Describes an existing service mesh.
    ///
    /// Parameters:
    ///   - meshName: The name of the service mesh to describe.
    ///   - meshOwner: The Amazon Web Services IAM account ID of the service mesh owner. If the account ID is not your own, then it's the ID of the account that shared the mesh with your account. For more information about mesh sharing, see Working with shared meshes.
    ///   - logger: Logger use during operation
    @inlinable
    public func describeMesh(
        meshName: String,
        meshOwner: String? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> DescribeMeshOutput {
        let input = DescribeMeshInput(
            meshName: meshName, 
            meshOwner: meshOwner
        )
        return try await self.describeMesh(input, logger: logger)
    }

    /// Describes an existing route.
    @Sendable
    @inlinable
    public func describeRoute(_ input: DescribeRouteInput, logger: Logger = AWSClient.loggingDisabled) async throws -> DescribeRouteOutput {
        try await self.client.execute(
            operation: "DescribeRoute", 
            path: "/v20190125/meshes/{meshName}/virtualRouter/{virtualRouterName}/routes/{routeName}", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Describes an existing route.
    ///
    /// Parameters:
    ///   - meshName: The name of the service mesh that the route resides in.
    ///   - meshOwner: The Amazon Web Services IAM account ID of the service mesh owner. If the account ID is not your own, then it's the ID of the account that shared the mesh with your account. For more information about mesh sharing, see Working with shared meshes.
    ///   - routeName: The name of the route to describe.
    ///   - virtualRouterName: The name of the virtual router that the route is associated with.
    ///   - logger: Logger use during operation
    @inlinable
    public func describeRoute(
        meshName: String,
        meshOwner: String? = nil,
        routeName: String,
        virtualRouterName: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> DescribeRouteOutput {
        let input = DescribeRouteInput(
            meshName: meshName, 
            meshOwner: meshOwner, 
            routeName: routeName, 
            virtualRouterName: virtualRouterName
        )
        return try await self.describeRoute(input, logger: logger)
    }

    /// Describes an existing virtual gateway.
    @Sendable
    @inlinable
    public func describeVirtualGateway(_ input: DescribeVirtualGatewayInput, logger: Logger = AWSClient.loggingDisabled) async throws -> DescribeVirtualGatewayOutput {
        try await self.client.execute(
            operation: "DescribeVirtualGateway", 
            path: "/v20190125/meshes/{meshName}/virtualGateways/{virtualGatewayName}", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Describes an existing virtual gateway.
    ///
    /// Parameters:
    ///   - meshName: The name of the service mesh that the gateway route resides in.
    ///   - meshOwner: The Amazon Web Services IAM account ID of the service mesh owner. If the account ID is not your own, then it's the ID of the account that shared the mesh with your account. For more information about mesh sharing, see Working with shared meshes.
    ///   - virtualGatewayName: The name of the virtual gateway to describe.
    ///   - logger: Logger use during operation
    @inlinable
    public func describeVirtualGateway(
        meshName: String,
        meshOwner: String? = nil,
        virtualGatewayName: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> DescribeVirtualGatewayOutput {
        let input = DescribeVirtualGatewayInput(
            meshName: meshName, 
            meshOwner: meshOwner, 
            virtualGatewayName: virtualGatewayName
        )
        return try await self.describeVirtualGateway(input, logger: logger)
    }

    /// Describes an existing virtual node.
    @Sendable
    @inlinable
    public func describeVirtualNode(_ input: DescribeVirtualNodeInput, logger: Logger = AWSClient.loggingDisabled) async throws -> DescribeVirtualNodeOutput {
        try await self.client.execute(
            operation: "DescribeVirtualNode", 
            path: "/v20190125/meshes/{meshName}/virtualNodes/{virtualNodeName}", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Describes an existing virtual node.
    ///
    /// Parameters:
    ///   - meshName: The name of the service mesh that the virtual node resides in.
    ///   - meshOwner: The Amazon Web Services IAM account ID of the service mesh owner. If the account ID is not your own, then it's the ID of the account that shared the mesh with your account. For more information about mesh sharing, see Working with shared meshes.
    ///   - virtualNodeName: The name of the virtual node to describe.
    ///   - logger: Logger use during operation
    @inlinable
    public func describeVirtualNode(
        meshName: String,
        meshOwner: String? = nil,
        virtualNodeName: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> DescribeVirtualNodeOutput {
        let input = DescribeVirtualNodeInput(
            meshName: meshName, 
            meshOwner: meshOwner, 
            virtualNodeName: virtualNodeName
        )
        return try await self.describeVirtualNode(input, logger: logger)
    }

    /// Describes an existing virtual router.
    @Sendable
    @inlinable
    public func describeVirtualRouter(_ input: DescribeVirtualRouterInput, logger: Logger = AWSClient.loggingDisabled) async throws -> DescribeVirtualRouterOutput {
        try await self.client.execute(
            operation: "DescribeVirtualRouter", 
            path: "/v20190125/meshes/{meshName}/virtualRouters/{virtualRouterName}", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Describes an existing virtual router.
    ///
    /// Parameters:
    ///   - meshName: The name of the service mesh that the virtual router resides in.
    ///   - meshOwner: The Amazon Web Services IAM account ID of the service mesh owner. If the account ID is not your own, then it's the ID of the account that shared the mesh with your account. For more information about mesh sharing, see Working with shared meshes.
    ///   - virtualRouterName: The name of the virtual router to describe.
    ///   - logger: Logger use during operation
    @inlinable
    public func describeVirtualRouter(
        meshName: String,
        meshOwner: String? = nil,
        virtualRouterName: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> DescribeVirtualRouterOutput {
        let input = DescribeVirtualRouterInput(
            meshName: meshName, 
            meshOwner: meshOwner, 
            virtualRouterName: virtualRouterName
        )
        return try await self.describeVirtualRouter(input, logger: logger)
    }

    /// Describes an existing virtual service.
    @Sendable
    @inlinable
    public func describeVirtualService(_ input: DescribeVirtualServiceInput, logger: Logger = AWSClient.loggingDisabled) async throws -> DescribeVirtualServiceOutput {
        try await self.client.execute(
            operation: "DescribeVirtualService", 
            path: "/v20190125/meshes/{meshName}/virtualServices/{virtualServiceName}", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Describes an existing virtual service.
    ///
    /// Parameters:
    ///   - meshName: The name of the service mesh that the virtual service resides in.
    ///   - meshOwner: The Amazon Web Services IAM account ID of the service mesh owner. If the account ID is not your own, then it's the ID of the account that shared the mesh with your account. For more information about mesh sharing, see Working with shared meshes.
    ///   - virtualServiceName: The name of the virtual service to describe.
    ///   - logger: Logger use during operation
    @inlinable
    public func describeVirtualService(
        meshName: String,
        meshOwner: String? = nil,
        virtualServiceName: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> DescribeVirtualServiceOutput {
        let input = DescribeVirtualServiceInput(
            meshName: meshName, 
            meshOwner: meshOwner, 
            virtualServiceName: virtualServiceName
        )
        return try await self.describeVirtualService(input, logger: logger)
    }

    /// Returns a list of existing gateway routes that are associated to a virtual gateway.
    @Sendable
    @inlinable
    public func listGatewayRoutes(_ input: ListGatewayRoutesInput, logger: Logger = AWSClient.loggingDisabled) async throws -> ListGatewayRoutesOutput {
        try await self.client.execute(
            operation: "ListGatewayRoutes", 
            path: "/v20190125/meshes/{meshName}/virtualGateway/{virtualGatewayName}/gatewayRoutes", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Returns a list of existing gateway routes that are associated to a virtual gateway.
    ///
    /// Parameters:
    ///   - limit: The maximum number of results returned by ListGatewayRoutes in paginated output. When you use this parameter, ListGatewayRoutes returns only limit results in a single page along with a nextToken response element. You can see the remaining results of the initial request by sending another ListGatewayRoutes request with the returned nextToken value. This value can be between 1 and 100. If you don't use this parameter, ListGatewayRoutes returns up to 100 results and a nextToken value if applicable.
    ///   - meshName: The name of the service mesh to list gateway routes in.
    ///   - meshOwner: The Amazon Web Services IAM account ID of the service mesh owner. If the account ID is not your own, then it's the ID of the account that shared the mesh with your account. For more information about mesh sharing, see Working with shared meshes.
    ///   - nextToken: The nextToken value returned from a previous paginated ListGatewayRoutes request where limit was used and the results exceeded the value of that parameter. Pagination continues from the end of the previous results that returned the nextToken value.
    ///   - virtualGatewayName: The name of the virtual gateway to list gateway routes in.
    ///   - logger: Logger use during operation
    @inlinable
    public func listGatewayRoutes(
        limit: Int? = nil,
        meshName: String,
        meshOwner: String? = nil,
        nextToken: String? = nil,
        virtualGatewayName: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ListGatewayRoutesOutput {
        let input = ListGatewayRoutesInput(
            limit: limit, 
            meshName: meshName, 
            meshOwner: meshOwner, 
            nextToken: nextToken, 
            virtualGatewayName: virtualGatewayName
        )
        return try await self.listGatewayRoutes(input, logger: logger)
    }

    /// Returns a list of existing service meshes.
    @Sendable
    @inlinable
    public func listMeshes(_ input: ListMeshesInput, logger: Logger = AWSClient.loggingDisabled) async throws -> ListMeshesOutput {
        try await self.client.execute(
            operation: "ListMeshes", 
            path: "/v20190125/meshes", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Returns a list of existing service meshes.
    ///
    /// Parameters:
    ///   - limit: The maximum number of results returned by ListMeshes in paginated output. When you use this parameter, ListMeshes returns only limit results in a single page along with a nextToken response element. You can see the remaining results of the initial request by sending another ListMeshes request with the returned nextToken value. This value can be between 1 and 100. If you don't use this parameter, ListMeshes returns up to 100 results and a nextToken value if applicable.
    ///   - nextToken: The nextToken value returned from a previous paginated ListMeshes request where limit was used and the results exceeded the value of that parameter. Pagination continues from the end of the previous results that returned the nextToken value.  This token should be treated as an opaque identifier that is used only to retrieve the next items in a list and not for other programmatic purposes.
    ///   - logger: Logger use during operation
    @inlinable
    public func listMeshes(
        limit: Int? = nil,
        nextToken: String? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ListMeshesOutput {
        let input = ListMeshesInput(
            limit: limit, 
            nextToken: nextToken
        )
        return try await self.listMeshes(input, logger: logger)
    }

    /// Returns a list of existing routes in a service mesh.
    @Sendable
    @inlinable
    public func listRoutes(_ input: ListRoutesInput, logger: Logger = AWSClient.loggingDisabled) async throws -> ListRoutesOutput {
        try await self.client.execute(
            operation: "ListRoutes", 
            path: "/v20190125/meshes/{meshName}/virtualRouter/{virtualRouterName}/routes", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Returns a list of existing routes in a service mesh.
    ///
    /// Parameters:
    ///   - limit: The maximum number of results returned by ListRoutes in paginated output. When you use this parameter, ListRoutes returns only limit results in a single page along with a nextToken response element. You can see the remaining results of the initial request by sending another ListRoutes request with the returned nextToken value. This value can be between 1 and 100. If you don't use this parameter, ListRoutes returns up to 100 results and a nextToken value if applicable.
    ///   - meshName: The name of the service mesh to list routes in.
    ///   - meshOwner: The Amazon Web Services IAM account ID of the service mesh owner. If the account ID is not your own, then it's the ID of the account that shared the mesh with your account. For more information about mesh sharing, see Working with shared meshes.
    ///   - nextToken: The nextToken value returned from a previous paginated ListRoutes request where limit was used and the results exceeded the value of that parameter. Pagination continues from the end of the previous results that returned the nextToken value.
    ///   - virtualRouterName: The name of the virtual router to list routes in.
    ///   - logger: Logger use during operation
    @inlinable
    public func listRoutes(
        limit: Int? = nil,
        meshName: String,
        meshOwner: String? = nil,
        nextToken: String? = nil,
        virtualRouterName: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ListRoutesOutput {
        let input = ListRoutesInput(
            limit: limit, 
            meshName: meshName, 
            meshOwner: meshOwner, 
            nextToken: nextToken, 
            virtualRouterName: virtualRouterName
        )
        return try await self.listRoutes(input, logger: logger)
    }

    /// List the tags for an App Mesh resource.
    @Sendable
    @inlinable
    public func listTagsForResource(_ input: ListTagsForResourceInput, logger: Logger = AWSClient.loggingDisabled) async throws -> ListTagsForResourceOutput {
        try await self.client.execute(
            operation: "ListTagsForResource", 
            path: "/v20190125/tags", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// List the tags for an App Mesh resource.
    ///
    /// Parameters:
    ///   - limit: The maximum number of tag results returned by ListTagsForResource in paginated output. When this parameter is used, ListTagsForResource returns only limit results in a single page along with a nextToken response element. You can see the remaining results of the initial request by sending another ListTagsForResource request with the returned nextToken value. This value can be between 1 and 100. If you don't use this parameter, ListTagsForResource returns up to 100 results and a nextToken value if applicable.
    ///   - nextToken: The nextToken value returned from a previous paginated ListTagsForResource request where limit was used and the results exceeded the value of that parameter. Pagination continues from the end of the previous results that returned the nextToken value.
    ///   - resourceArn: The Amazon Resource Name (ARN) that identifies the resource to list the tags for.
    ///   - logger: Logger use during operation
    @inlinable
    public func listTagsForResource(
        limit: Int? = nil,
        nextToken: String? = nil,
        resourceArn: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ListTagsForResourceOutput {
        let input = ListTagsForResourceInput(
            limit: limit, 
            nextToken: nextToken, 
            resourceArn: resourceArn
        )
        return try await self.listTagsForResource(input, logger: logger)
    }

    /// Returns a list of existing virtual gateways in a service mesh.
    @Sendable
    @inlinable
    public func listVirtualGateways(_ input: ListVirtualGatewaysInput, logger: Logger = AWSClient.loggingDisabled) async throws -> ListVirtualGatewaysOutput {
        try await self.client.execute(
            operation: "ListVirtualGateways", 
            path: "/v20190125/meshes/{meshName}/virtualGateways", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Returns a list of existing virtual gateways in a service mesh.
    ///
    /// Parameters:
    ///   - limit: The maximum number of results returned by ListVirtualGateways in paginated output. When you use this parameter, ListVirtualGateways returns only limit results in a single page along with a nextToken response element. You can see the remaining results of the initial request by sending another ListVirtualGateways request with the returned nextToken value. This value can be between 1 and 100. If you don't use this parameter, ListVirtualGateways returns up to 100 results and a nextToken value if applicable.
    ///   - meshName: The name of the service mesh to list virtual gateways in.
    ///   - meshOwner: The Amazon Web Services IAM account ID of the service mesh owner. If the account ID is not your own, then it's the ID of the account that shared the mesh with your account. For more information about mesh sharing, see Working with shared meshes.
    ///   - nextToken: The nextToken value returned from a previous paginated ListVirtualGateways request where limit was used and the results exceeded the value of that parameter. Pagination continues from the end of the previous results that returned the nextToken value.
    ///   - logger: Logger use during operation
    @inlinable
    public func listVirtualGateways(
        limit: Int? = nil,
        meshName: String,
        meshOwner: String? = nil,
        nextToken: String? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ListVirtualGatewaysOutput {
        let input = ListVirtualGatewaysInput(
            limit: limit, 
            meshName: meshName, 
            meshOwner: meshOwner, 
            nextToken: nextToken
        )
        return try await self.listVirtualGateways(input, logger: logger)
    }

    /// Returns a list of existing virtual nodes.
    @Sendable
    @inlinable
    public func listVirtualNodes(_ input: ListVirtualNodesInput, logger: Logger = AWSClient.loggingDisabled) async throws -> ListVirtualNodesOutput {
        try await self.client.execute(
            operation: "ListVirtualNodes", 
            path: "/v20190125/meshes/{meshName}/virtualNodes", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Returns a list of existing virtual nodes.
    ///
    /// Parameters:
    ///   - limit: The maximum number of results returned by ListVirtualNodes in paginated output. When you use this parameter, ListVirtualNodes returns only limit results in a single page along with a nextToken response element. You can see the remaining results of the initial request by sending another ListVirtualNodes request with the returned nextToken value. This value can be between 1 and 100. If you don't use this parameter, ListVirtualNodes returns up to 100 results and a nextToken value if applicable.
    ///   - meshName: The name of the service mesh to list virtual nodes in.
    ///   - meshOwner: The Amazon Web Services IAM account ID of the service mesh owner. If the account ID is not your own, then it's the ID of the account that shared the mesh with your account. For more information about mesh sharing, see Working with shared meshes.
    ///   - nextToken: The nextToken value returned from a previous paginated ListVirtualNodes request where limit was used and the results exceeded the value of that parameter. Pagination continues from the end of the previous results that returned the nextToken value.
    ///   - logger: Logger use during operation
    @inlinable
    public func listVirtualNodes(
        limit: Int? = nil,
        meshName: String,
        meshOwner: String? = nil,
        nextToken: String? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ListVirtualNodesOutput {
        let input = ListVirtualNodesInput(
            limit: limit, 
            meshName: meshName, 
            meshOwner: meshOwner, 
            nextToken: nextToken
        )
        return try await self.listVirtualNodes(input, logger: logger)
    }

    /// Returns a list of existing virtual routers in a service mesh.
    @Sendable
    @inlinable
    public func listVirtualRouters(_ input: ListVirtualRoutersInput, logger: Logger = AWSClient.loggingDisabled) async throws -> ListVirtualRoutersOutput {
        try await self.client.execute(
            operation: "ListVirtualRouters", 
            path: "/v20190125/meshes/{meshName}/virtualRouters", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Returns a list of existing virtual routers in a service mesh.
    ///
    /// Parameters:
    ///   - limit: The maximum number of results returned by ListVirtualRouters in paginated output. When you use this parameter, ListVirtualRouters returns only limit results in a single page along with a nextToken response element. You can see the remaining results of the initial request by sending another ListVirtualRouters request with the returned nextToken value. This value can be between 1 and 100. If you don't use this parameter, ListVirtualRouters returns up to 100 results and a nextToken value if applicable.
    ///   - meshName: The name of the service mesh to list virtual routers in.
    ///   - meshOwner: The Amazon Web Services IAM account ID of the service mesh owner. If the account ID is not your own, then it's the ID of the account that shared the mesh with your account. For more information about mesh sharing, see Working with shared meshes.
    ///   - nextToken: The nextToken value returned from a previous paginated ListVirtualRouters request where limit was used and the results exceeded the value of that parameter. Pagination continues from the end of the previous results that returned the nextToken value.
    ///   - logger: Logger use during operation
    @inlinable
    public func listVirtualRouters(
        limit: Int? = nil,
        meshName: String,
        meshOwner: String? = nil,
        nextToken: String? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ListVirtualRoutersOutput {
        let input = ListVirtualRoutersInput(
            limit: limit, 
            meshName: meshName, 
            meshOwner: meshOwner, 
            nextToken: nextToken
        )
        return try await self.listVirtualRouters(input, logger: logger)
    }

    /// Returns a list of existing virtual services in a service mesh.
    @Sendable
    @inlinable
    public func listVirtualServices(_ input: ListVirtualServicesInput, logger: Logger = AWSClient.loggingDisabled) async throws -> ListVirtualServicesOutput {
        try await self.client.execute(
            operation: "ListVirtualServices", 
            path: "/v20190125/meshes/{meshName}/virtualServices", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Returns a list of existing virtual services in a service mesh.
    ///
    /// Parameters:
    ///   - limit: The maximum number of results returned by ListVirtualServices in paginated output. When you use this parameter, ListVirtualServices returns only limit results in a single page along with a nextToken response element. You can see the remaining results of the initial request by sending another ListVirtualServices request with the returned nextToken value. This value can be between 1 and 100. If you don't use this parameter, ListVirtualServices returns up to 100 results and a nextToken value if applicable.
    ///   - meshName: The name of the service mesh to list virtual services in.
    ///   - meshOwner: The Amazon Web Services IAM account ID of the service mesh owner. If the account ID is not your own, then it's the ID of the account that shared the mesh with your account. For more information about mesh sharing, see Working with shared meshes.
    ///   - nextToken: The nextToken value returned from a previous paginated ListVirtualServices request where limit was used and the results exceeded the value of that parameter. Pagination continues from the end of the previous results that returned the nextToken value.
    ///   - logger: Logger use during operation
    @inlinable
    public func listVirtualServices(
        limit: Int? = nil,
        meshName: String,
        meshOwner: String? = nil,
        nextToken: String? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ListVirtualServicesOutput {
        let input = ListVirtualServicesInput(
            limit: limit, 
            meshName: meshName, 
            meshOwner: meshOwner, 
            nextToken: nextToken
        )
        return try await self.listVirtualServices(input, logger: logger)
    }

    /// Associates the specified tags to a resource with the specified resourceArn. If existing tags on a resource aren't specified in the request parameters, they aren't changed. When a resource is deleted, the tags associated with that resource are also deleted.
    @Sendable
    @inlinable
    public func tagResource(_ input: TagResourceInput, logger: Logger = AWSClient.loggingDisabled) async throws -> TagResourceOutput {
        try await self.client.execute(
            operation: "TagResource", 
            path: "/v20190125/tag", 
            httpMethod: .PUT, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Associates the specified tags to a resource with the specified resourceArn. If existing tags on a resource aren't specified in the request parameters, they aren't changed. When a resource is deleted, the tags associated with that resource are also deleted.
    ///
    /// Parameters:
    ///   - resourceArn: The Amazon Resource Name (ARN) of the resource to add tags to.
    ///   - tags: The tags to add to the resource. A tag is an array of key-value pairs. Tag keys can have a maximum character length of 128 characters, and tag values can have a maximum length of 256 characters.
    ///   - logger: Logger use during operation
    @inlinable
    public func tagResource(
        resourceArn: String,
        tags: [TagRef],
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> TagResourceOutput {
        let input = TagResourceInput(
            resourceArn: resourceArn, 
            tags: tags
        )
        return try await self.tagResource(input, logger: logger)
    }

    /// Deletes specified tags from a resource.
    @Sendable
    @inlinable
    public func untagResource(_ input: UntagResourceInput, logger: Logger = AWSClient.loggingDisabled) async throws -> UntagResourceOutput {
        try await self.client.execute(
            operation: "UntagResource", 
            path: "/v20190125/untag", 
            httpMethod: .PUT, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Deletes specified tags from a resource.
    ///
    /// Parameters:
    ///   - resourceArn: The Amazon Resource Name (ARN) of the resource to delete tags from.
    ///   - tagKeys: The keys of the tags to be removed.
    ///   - logger: Logger use during operation
    @inlinable
    public func untagResource(
        resourceArn: String,
        tagKeys: [String],
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> UntagResourceOutput {
        let input = UntagResourceInput(
            resourceArn: resourceArn, 
            tagKeys: tagKeys
        )
        return try await self.untagResource(input, logger: logger)
    }

    /// Updates an existing gateway route that is associated to a specified virtual gateway in a service mesh.
    @Sendable
    @inlinable
    public func updateGatewayRoute(_ input: UpdateGatewayRouteInput, logger: Logger = AWSClient.loggingDisabled) async throws -> UpdateGatewayRouteOutput {
        try await self.client.execute(
            operation: "UpdateGatewayRoute", 
            path: "/v20190125/meshes/{meshName}/virtualGateway/{virtualGatewayName}/gatewayRoutes/{gatewayRouteName}", 
            httpMethod: .PUT, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Updates an existing gateway route that is associated to a specified virtual gateway in a service mesh.
    ///
    /// Parameters:
    ///   - clientToken: Unique, case-sensitive identifier that you provide to ensure the idempotency of the
    ///   - gatewayRouteName: The name of the gateway route to update.
    ///   - meshName: The name of the service mesh that the gateway route resides in.
    ///   - meshOwner: The Amazon Web Services IAM account ID of the service mesh owner. If the account ID is not your own, then it's the ID of the account that shared the mesh with your account. For more information about mesh sharing, see Working with shared meshes.
    ///   - spec: The new gateway route specification to apply. This overwrites the existing data.
    ///   - virtualGatewayName: The name of the virtual gateway that the gateway route is associated with.
    ///   - logger: Logger use during operation
    @inlinable
    public func updateGatewayRoute(
        clientToken: String? = UpdateGatewayRouteInput.idempotencyToken(),
        gatewayRouteName: String,
        meshName: String,
        meshOwner: String? = nil,
        spec: GatewayRouteSpec,
        virtualGatewayName: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> UpdateGatewayRouteOutput {
        let input = UpdateGatewayRouteInput(
            clientToken: clientToken, 
            gatewayRouteName: gatewayRouteName, 
            meshName: meshName, 
            meshOwner: meshOwner, 
            spec: spec, 
            virtualGatewayName: virtualGatewayName
        )
        return try await self.updateGatewayRoute(input, logger: logger)
    }

    /// Updates an existing service mesh.
    @Sendable
    @inlinable
    public func updateMesh(_ input: UpdateMeshInput, logger: Logger = AWSClient.loggingDisabled) async throws -> UpdateMeshOutput {
        try await self.client.execute(
            operation: "UpdateMesh", 
            path: "/v20190125/meshes/{meshName}", 
            httpMethod: .PUT, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Updates an existing service mesh.
    ///
    /// Parameters:
    ///   - clientToken: Unique, case-sensitive identifier that you provide to ensure the idempotency of the
    ///   - meshName: The name of the service mesh to update.
    ///   - spec: The service mesh specification to apply.
    ///   - logger: Logger use during operation
    @inlinable
    public func updateMesh(
        clientToken: String? = UpdateMeshInput.idempotencyToken(),
        meshName: String,
        spec: MeshSpec? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> UpdateMeshOutput {
        let input = UpdateMeshInput(
            clientToken: clientToken, 
            meshName: meshName, 
            spec: spec
        )
        return try await self.updateMesh(input, logger: logger)
    }

    /// Updates an existing route for a specified service mesh and virtual router.
    @Sendable
    @inlinable
    public func updateRoute(_ input: UpdateRouteInput, logger: Logger = AWSClient.loggingDisabled) async throws -> UpdateRouteOutput {
        try await self.client.execute(
            operation: "UpdateRoute", 
            path: "/v20190125/meshes/{meshName}/virtualRouter/{virtualRouterName}/routes/{routeName}", 
            httpMethod: .PUT, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Updates an existing route for a specified service mesh and virtual router.
    ///
    /// Parameters:
    ///   - clientToken: Unique, case-sensitive identifier that you provide to ensure the idempotency of the
    ///   - meshName: The name of the service mesh that the route resides in.
    ///   - meshOwner: The Amazon Web Services IAM account ID of the service mesh owner. If the account ID is not your own, then it's the ID of the account that shared the mesh with your account. For more information about mesh sharing, see Working with shared meshes.
    ///   - routeName: The name of the route to update.
    ///   - spec: The new route specification to apply. This overwrites the existing data.
    ///   - virtualRouterName: The name of the virtual router that the route is associated with.
    ///   - logger: Logger use during operation
    @inlinable
    public func updateRoute(
        clientToken: String? = UpdateRouteInput.idempotencyToken(),
        meshName: String,
        meshOwner: String? = nil,
        routeName: String,
        spec: RouteSpec,
        virtualRouterName: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> UpdateRouteOutput {
        let input = UpdateRouteInput(
            clientToken: clientToken, 
            meshName: meshName, 
            meshOwner: meshOwner, 
            routeName: routeName, 
            spec: spec, 
            virtualRouterName: virtualRouterName
        )
        return try await self.updateRoute(input, logger: logger)
    }

    /// Updates an existing virtual gateway in a specified service mesh.
    @Sendable
    @inlinable
    public func updateVirtualGateway(_ input: UpdateVirtualGatewayInput, logger: Logger = AWSClient.loggingDisabled) async throws -> UpdateVirtualGatewayOutput {
        try await self.client.execute(
            operation: "UpdateVirtualGateway", 
            path: "/v20190125/meshes/{meshName}/virtualGateways/{virtualGatewayName}", 
            httpMethod: .PUT, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Updates an existing virtual gateway in a specified service mesh.
    ///
    /// Parameters:
    ///   - clientToken: Unique, case-sensitive identifier that you provide to ensure the idempotency of the
    ///   - meshName: The name of the service mesh that the virtual gateway resides in.
    ///   - meshOwner: The Amazon Web Services IAM account ID of the service mesh owner. If the account ID is not your own, then it's the ID of the account that shared the mesh with your account. For more information about mesh sharing, see Working with shared meshes.
    ///   - spec: The new virtual gateway specification to apply. This overwrites the existing data.
    ///   - virtualGatewayName: The name of the virtual gateway to update.
    ///   - logger: Logger use during operation
    @inlinable
    public func updateVirtualGateway(
        clientToken: String? = UpdateVirtualGatewayInput.idempotencyToken(),
        meshName: String,
        meshOwner: String? = nil,
        spec: VirtualGatewaySpec,
        virtualGatewayName: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> UpdateVirtualGatewayOutput {
        let input = UpdateVirtualGatewayInput(
            clientToken: clientToken, 
            meshName: meshName, 
            meshOwner: meshOwner, 
            spec: spec, 
            virtualGatewayName: virtualGatewayName
        )
        return try await self.updateVirtualGateway(input, logger: logger)
    }

    /// Updates an existing virtual node in a specified service mesh.
    @Sendable
    @inlinable
    public func updateVirtualNode(_ input: UpdateVirtualNodeInput, logger: Logger = AWSClient.loggingDisabled) async throws -> UpdateVirtualNodeOutput {
        try await self.client.execute(
            operation: "UpdateVirtualNode", 
            path: "/v20190125/meshes/{meshName}/virtualNodes/{virtualNodeName}", 
            httpMethod: .PUT, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Updates an existing virtual node in a specified service mesh.
    ///
    /// Parameters:
    ///   - clientToken: Unique, case-sensitive identifier that you provide to ensure the idempotency of the
    ///   - meshName: The name of the service mesh that the virtual node resides in.
    ///   - meshOwner: The Amazon Web Services IAM account ID of the service mesh owner. If the account ID is not your own, then it's the ID of the account that shared the mesh with your account. For more information about mesh sharing, see Working with shared meshes.
    ///   - spec: The new virtual node specification to apply. This overwrites the existing data.
    ///   - virtualNodeName: The name of the virtual node to update.
    ///   - logger: Logger use during operation
    @inlinable
    public func updateVirtualNode(
        clientToken: String? = UpdateVirtualNodeInput.idempotencyToken(),
        meshName: String,
        meshOwner: String? = nil,
        spec: VirtualNodeSpec,
        virtualNodeName: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> UpdateVirtualNodeOutput {
        let input = UpdateVirtualNodeInput(
            clientToken: clientToken, 
            meshName: meshName, 
            meshOwner: meshOwner, 
            spec: spec, 
            virtualNodeName: virtualNodeName
        )
        return try await self.updateVirtualNode(input, logger: logger)
    }

    /// Updates an existing virtual router in a specified service mesh.
    @Sendable
    @inlinable
    public func updateVirtualRouter(_ input: UpdateVirtualRouterInput, logger: Logger = AWSClient.loggingDisabled) async throws -> UpdateVirtualRouterOutput {
        try await self.client.execute(
            operation: "UpdateVirtualRouter", 
            path: "/v20190125/meshes/{meshName}/virtualRouters/{virtualRouterName}", 
            httpMethod: .PUT, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Updates an existing virtual router in a specified service mesh.
    ///
    /// Parameters:
    ///   - clientToken: Unique, case-sensitive identifier that you provide to ensure the idempotency of the
    ///   - meshName: The name of the service mesh that the virtual router resides in.
    ///   - meshOwner: The Amazon Web Services IAM account ID of the service mesh owner. If the account ID is not your own, then it's the ID of the account that shared the mesh with your account. For more information about mesh sharing, see Working with shared meshes.
    ///   - spec: The new virtual router specification to apply. This overwrites the existing data.
    ///   - virtualRouterName: The name of the virtual router to update.
    ///   - logger: Logger use during operation
    @inlinable
    public func updateVirtualRouter(
        clientToken: String? = UpdateVirtualRouterInput.idempotencyToken(),
        meshName: String,
        meshOwner: String? = nil,
        spec: VirtualRouterSpec,
        virtualRouterName: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> UpdateVirtualRouterOutput {
        let input = UpdateVirtualRouterInput(
            clientToken: clientToken, 
            meshName: meshName, 
            meshOwner: meshOwner, 
            spec: spec, 
            virtualRouterName: virtualRouterName
        )
        return try await self.updateVirtualRouter(input, logger: logger)
    }

    /// Updates an existing virtual service in a specified service mesh.
    @Sendable
    @inlinable
    public func updateVirtualService(_ input: UpdateVirtualServiceInput, logger: Logger = AWSClient.loggingDisabled) async throws -> UpdateVirtualServiceOutput {
        try await self.client.execute(
            operation: "UpdateVirtualService", 
            path: "/v20190125/meshes/{meshName}/virtualServices/{virtualServiceName}", 
            httpMethod: .PUT, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Updates an existing virtual service in a specified service mesh.
    ///
    /// Parameters:
    ///   - clientToken: Unique, case-sensitive identifier that you provide to ensure the idempotency of the
    ///   - meshName: The name of the service mesh that the virtual service resides in.
    ///   - meshOwner: The Amazon Web Services IAM account ID of the service mesh owner. If the account ID is not your own, then it's the ID of the account that shared the mesh with your account. For more information about mesh sharing, see Working with shared meshes.
    ///   - spec: The new virtual service specification to apply. This overwrites the existing data.
    ///   - virtualServiceName: The name of the virtual service to update.
    ///   - logger: Logger use during operation
    @inlinable
    public func updateVirtualService(
        clientToken: String? = UpdateVirtualServiceInput.idempotencyToken(),
        meshName: String,
        meshOwner: String? = nil,
        spec: VirtualServiceSpec,
        virtualServiceName: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> UpdateVirtualServiceOutput {
        let input = UpdateVirtualServiceInput(
            clientToken: clientToken, 
            meshName: meshName, 
            meshOwner: meshOwner, 
            spec: spec, 
            virtualServiceName: virtualServiceName
        )
        return try await self.updateVirtualService(input, logger: logger)
    }
}

extension AppMesh {
    /// Initializer required by `AWSService.with(middlewares:timeout:byteBufferAllocator:options)`. You are not able to use this initializer directly as there are not public
    /// initializers for `AWSServiceConfig.Patch`. Please use `AWSService.with(middlewares:timeout:byteBufferAllocator:options)` instead.
    public init(from: AppMesh, patch: AWSServiceConfig.Patch) {
        self.client = from.client
        self.config = from.config.with(patch: patch)
    }
}

// MARK: Paginators

@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension AppMesh {
    /// Return PaginatorSequence for operation ``listGatewayRoutes(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func listGatewayRoutesPaginator(
        _ input: ListGatewayRoutesInput,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<ListGatewayRoutesInput, ListGatewayRoutesOutput> {
        return .init(
            input: input,
            command: self.listGatewayRoutes,
            inputKey: \ListGatewayRoutesInput.nextToken,
            outputKey: \ListGatewayRoutesOutput.nextToken,
            logger: logger
        )
    }
    /// Return PaginatorSequence for operation ``listGatewayRoutes(_:logger:)``.
    ///
    /// - Parameters:
    ///   - limit: The maximum number of results returned by ListGatewayRoutes in paginated output. When you use this parameter, ListGatewayRoutes returns only limit results in a single page along with a nextToken response element. You can see the remaining results of the initial request by sending another ListGatewayRoutes request with the returned nextToken value. This value can be between 1 and 100. If you don't use this parameter, ListGatewayRoutes returns up to 100 results and a nextToken value if applicable.
    ///   - meshName: The name of the service mesh to list gateway routes in.
    ///   - meshOwner: The Amazon Web Services IAM account ID of the service mesh owner. If the account ID is not your own, then it's the ID of the account that shared the mesh with your account. For more information about mesh sharing, see Working with shared meshes.
    ///   - virtualGatewayName: The name of the virtual gateway to list gateway routes in.
    ///   - logger: Logger used for logging
    @inlinable
    public func listGatewayRoutesPaginator(
        limit: Int? = nil,
        meshName: String,
        meshOwner: String? = nil,
        virtualGatewayName: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) -> AWSClient.PaginatorSequence<ListGatewayRoutesInput, ListGatewayRoutesOutput> {
        let input = ListGatewayRoutesInput(
            limit: limit, 
            meshName: meshName, 
            meshOwner: meshOwner, 
            virtualGatewayName: virtualGatewayName
        )
        return self.listGatewayRoutesPaginator(input, logger: logger)
    }

    /// Return PaginatorSequence for operation ``listMeshes(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func listMeshesPaginator(
        _ input: ListMeshesInput,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<ListMeshesInput, ListMeshesOutput> {
        return .init(
            input: input,
            command: self.listMeshes,
            inputKey: \ListMeshesInput.nextToken,
            outputKey: \ListMeshesOutput.nextToken,
            logger: logger
        )
    }
    /// Return PaginatorSequence for operation ``listMeshes(_:logger:)``.
    ///
    /// - Parameters:
    ///   - limit: The maximum number of results returned by ListMeshes in paginated output. When you use this parameter, ListMeshes returns only limit results in a single page along with a nextToken response element. You can see the remaining results of the initial request by sending another ListMeshes request with the returned nextToken value. This value can be between 1 and 100. If you don't use this parameter, ListMeshes returns up to 100 results and a nextToken value if applicable.
    ///   - logger: Logger used for logging
    @inlinable
    public func listMeshesPaginator(
        limit: Int? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) -> AWSClient.PaginatorSequence<ListMeshesInput, ListMeshesOutput> {
        let input = ListMeshesInput(
            limit: limit
        )
        return self.listMeshesPaginator(input, logger: logger)
    }

    /// Return PaginatorSequence for operation ``listRoutes(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func listRoutesPaginator(
        _ input: ListRoutesInput,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<ListRoutesInput, ListRoutesOutput> {
        return .init(
            input: input,
            command: self.listRoutes,
            inputKey: \ListRoutesInput.nextToken,
            outputKey: \ListRoutesOutput.nextToken,
            logger: logger
        )
    }
    /// Return PaginatorSequence for operation ``listRoutes(_:logger:)``.
    ///
    /// - Parameters:
    ///   - limit: The maximum number of results returned by ListRoutes in paginated output. When you use this parameter, ListRoutes returns only limit results in a single page along with a nextToken response element. You can see the remaining results of the initial request by sending another ListRoutes request with the returned nextToken value. This value can be between 1 and 100. If you don't use this parameter, ListRoutes returns up to 100 results and a nextToken value if applicable.
    ///   - meshName: The name of the service mesh to list routes in.
    ///   - meshOwner: The Amazon Web Services IAM account ID of the service mesh owner. If the account ID is not your own, then it's the ID of the account that shared the mesh with your account. For more information about mesh sharing, see Working with shared meshes.
    ///   - virtualRouterName: The name of the virtual router to list routes in.
    ///   - logger: Logger used for logging
    @inlinable
    public func listRoutesPaginator(
        limit: Int? = nil,
        meshName: String,
        meshOwner: String? = nil,
        virtualRouterName: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) -> AWSClient.PaginatorSequence<ListRoutesInput, ListRoutesOutput> {
        let input = ListRoutesInput(
            limit: limit, 
            meshName: meshName, 
            meshOwner: meshOwner, 
            virtualRouterName: virtualRouterName
        )
        return self.listRoutesPaginator(input, logger: logger)
    }

    /// Return PaginatorSequence for operation ``listTagsForResource(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func listTagsForResourcePaginator(
        _ input: ListTagsForResourceInput,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<ListTagsForResourceInput, ListTagsForResourceOutput> {
        return .init(
            input: input,
            command: self.listTagsForResource,
            inputKey: \ListTagsForResourceInput.nextToken,
            outputKey: \ListTagsForResourceOutput.nextToken,
            logger: logger
        )
    }
    /// Return PaginatorSequence for operation ``listTagsForResource(_:logger:)``.
    ///
    /// - Parameters:
    ///   - limit: The maximum number of tag results returned by ListTagsForResource in paginated output. When this parameter is used, ListTagsForResource returns only limit results in a single page along with a nextToken response element. You can see the remaining results of the initial request by sending another ListTagsForResource request with the returned nextToken value. This value can be between 1 and 100. If you don't use this parameter, ListTagsForResource returns up to 100 results and a nextToken value if applicable.
    ///   - resourceArn: The Amazon Resource Name (ARN) that identifies the resource to list the tags for.
    ///   - logger: Logger used for logging
    @inlinable
    public func listTagsForResourcePaginator(
        limit: Int? = nil,
        resourceArn: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) -> AWSClient.PaginatorSequence<ListTagsForResourceInput, ListTagsForResourceOutput> {
        let input = ListTagsForResourceInput(
            limit: limit, 
            resourceArn: resourceArn
        )
        return self.listTagsForResourcePaginator(input, logger: logger)
    }

    /// Return PaginatorSequence for operation ``listVirtualGateways(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func listVirtualGatewaysPaginator(
        _ input: ListVirtualGatewaysInput,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<ListVirtualGatewaysInput, ListVirtualGatewaysOutput> {
        return .init(
            input: input,
            command: self.listVirtualGateways,
            inputKey: \ListVirtualGatewaysInput.nextToken,
            outputKey: \ListVirtualGatewaysOutput.nextToken,
            logger: logger
        )
    }
    /// Return PaginatorSequence for operation ``listVirtualGateways(_:logger:)``.
    ///
    /// - Parameters:
    ///   - limit: The maximum number of results returned by ListVirtualGateways in paginated output. When you use this parameter, ListVirtualGateways returns only limit results in a single page along with a nextToken response element. You can see the remaining results of the initial request by sending another ListVirtualGateways request with the returned nextToken value. This value can be between 1 and 100. If you don't use this parameter, ListVirtualGateways returns up to 100 results and a nextToken value if applicable.
    ///   - meshName: The name of the service mesh to list virtual gateways in.
    ///   - meshOwner: The Amazon Web Services IAM account ID of the service mesh owner. If the account ID is not your own, then it's the ID of the account that shared the mesh with your account. For more information about mesh sharing, see Working with shared meshes.
    ///   - logger: Logger used for logging
    @inlinable
    public func listVirtualGatewaysPaginator(
        limit: Int? = nil,
        meshName: String,
        meshOwner: String? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) -> AWSClient.PaginatorSequence<ListVirtualGatewaysInput, ListVirtualGatewaysOutput> {
        let input = ListVirtualGatewaysInput(
            limit: limit, 
            meshName: meshName, 
            meshOwner: meshOwner
        )
        return self.listVirtualGatewaysPaginator(input, logger: logger)
    }

    /// Return PaginatorSequence for operation ``listVirtualNodes(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func listVirtualNodesPaginator(
        _ input: ListVirtualNodesInput,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<ListVirtualNodesInput, ListVirtualNodesOutput> {
        return .init(
            input: input,
            command: self.listVirtualNodes,
            inputKey: \ListVirtualNodesInput.nextToken,
            outputKey: \ListVirtualNodesOutput.nextToken,
            logger: logger
        )
    }
    /// Return PaginatorSequence for operation ``listVirtualNodes(_:logger:)``.
    ///
    /// - Parameters:
    ///   - limit: The maximum number of results returned by ListVirtualNodes in paginated output. When you use this parameter, ListVirtualNodes returns only limit results in a single page along with a nextToken response element. You can see the remaining results of the initial request by sending another ListVirtualNodes request with the returned nextToken value. This value can be between 1 and 100. If you don't use this parameter, ListVirtualNodes returns up to 100 results and a nextToken value if applicable.
    ///   - meshName: The name of the service mesh to list virtual nodes in.
    ///   - meshOwner: The Amazon Web Services IAM account ID of the service mesh owner. If the account ID is not your own, then it's the ID of the account that shared the mesh with your account. For more information about mesh sharing, see Working with shared meshes.
    ///   - logger: Logger used for logging
    @inlinable
    public func listVirtualNodesPaginator(
        limit: Int? = nil,
        meshName: String,
        meshOwner: String? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) -> AWSClient.PaginatorSequence<ListVirtualNodesInput, ListVirtualNodesOutput> {
        let input = ListVirtualNodesInput(
            limit: limit, 
            meshName: meshName, 
            meshOwner: meshOwner
        )
        return self.listVirtualNodesPaginator(input, logger: logger)
    }

    /// Return PaginatorSequence for operation ``listVirtualRouters(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func listVirtualRoutersPaginator(
        _ input: ListVirtualRoutersInput,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<ListVirtualRoutersInput, ListVirtualRoutersOutput> {
        return .init(
            input: input,
            command: self.listVirtualRouters,
            inputKey: \ListVirtualRoutersInput.nextToken,
            outputKey: \ListVirtualRoutersOutput.nextToken,
            logger: logger
        )
    }
    /// Return PaginatorSequence for operation ``listVirtualRouters(_:logger:)``.
    ///
    /// - Parameters:
    ///   - limit: The maximum number of results returned by ListVirtualRouters in paginated output. When you use this parameter, ListVirtualRouters returns only limit results in a single page along with a nextToken response element. You can see the remaining results of the initial request by sending another ListVirtualRouters request with the returned nextToken value. This value can be between 1 and 100. If you don't use this parameter, ListVirtualRouters returns up to 100 results and a nextToken value if applicable.
    ///   - meshName: The name of the service mesh to list virtual routers in.
    ///   - meshOwner: The Amazon Web Services IAM account ID of the service mesh owner. If the account ID is not your own, then it's the ID of the account that shared the mesh with your account. For more information about mesh sharing, see Working with shared meshes.
    ///   - logger: Logger used for logging
    @inlinable
    public func listVirtualRoutersPaginator(
        limit: Int? = nil,
        meshName: String,
        meshOwner: String? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) -> AWSClient.PaginatorSequence<ListVirtualRoutersInput, ListVirtualRoutersOutput> {
        let input = ListVirtualRoutersInput(
            limit: limit, 
            meshName: meshName, 
            meshOwner: meshOwner
        )
        return self.listVirtualRoutersPaginator(input, logger: logger)
    }

    /// Return PaginatorSequence for operation ``listVirtualServices(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func listVirtualServicesPaginator(
        _ input: ListVirtualServicesInput,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<ListVirtualServicesInput, ListVirtualServicesOutput> {
        return .init(
            input: input,
            command: self.listVirtualServices,
            inputKey: \ListVirtualServicesInput.nextToken,
            outputKey: \ListVirtualServicesOutput.nextToken,
            logger: logger
        )
    }
    /// Return PaginatorSequence for operation ``listVirtualServices(_:logger:)``.
    ///
    /// - Parameters:
    ///   - limit: The maximum number of results returned by ListVirtualServices in paginated output. When you use this parameter, ListVirtualServices returns only limit results in a single page along with a nextToken response element. You can see the remaining results of the initial request by sending another ListVirtualServices request with the returned nextToken value. This value can be between 1 and 100. If you don't use this parameter, ListVirtualServices returns up to 100 results and a nextToken value if applicable.
    ///   - meshName: The name of the service mesh to list virtual services in.
    ///   - meshOwner: The Amazon Web Services IAM account ID of the service mesh owner. If the account ID is not your own, then it's the ID of the account that shared the mesh with your account. For more information about mesh sharing, see Working with shared meshes.
    ///   - logger: Logger used for logging
    @inlinable
    public func listVirtualServicesPaginator(
        limit: Int? = nil,
        meshName: String,
        meshOwner: String? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) -> AWSClient.PaginatorSequence<ListVirtualServicesInput, ListVirtualServicesOutput> {
        let input = ListVirtualServicesInput(
            limit: limit, 
            meshName: meshName, 
            meshOwner: meshOwner
        )
        return self.listVirtualServicesPaginator(input, logger: logger)
    }
}

extension AppMesh.ListGatewayRoutesInput: AWSPaginateToken {
    @inlinable
    public func usingPaginationToken(_ token: String) -> AppMesh.ListGatewayRoutesInput {
        return .init(
            limit: self.limit,
            meshName: self.meshName,
            meshOwner: self.meshOwner,
            nextToken: token,
            virtualGatewayName: self.virtualGatewayName
        )
    }
}

extension AppMesh.ListMeshesInput: AWSPaginateToken {
    @inlinable
    public func usingPaginationToken(_ token: String) -> AppMesh.ListMeshesInput {
        return .init(
            limit: self.limit,
            nextToken: token
        )
    }
}

extension AppMesh.ListRoutesInput: AWSPaginateToken {
    @inlinable
    public func usingPaginationToken(_ token: String) -> AppMesh.ListRoutesInput {
        return .init(
            limit: self.limit,
            meshName: self.meshName,
            meshOwner: self.meshOwner,
            nextToken: token,
            virtualRouterName: self.virtualRouterName
        )
    }
}

extension AppMesh.ListTagsForResourceInput: AWSPaginateToken {
    @inlinable
    public func usingPaginationToken(_ token: String) -> AppMesh.ListTagsForResourceInput {
        return .init(
            limit: self.limit,
            nextToken: token,
            resourceArn: self.resourceArn
        )
    }
}

extension AppMesh.ListVirtualGatewaysInput: AWSPaginateToken {
    @inlinable
    public func usingPaginationToken(_ token: String) -> AppMesh.ListVirtualGatewaysInput {
        return .init(
            limit: self.limit,
            meshName: self.meshName,
            meshOwner: self.meshOwner,
            nextToken: token
        )
    }
}

extension AppMesh.ListVirtualNodesInput: AWSPaginateToken {
    @inlinable
    public func usingPaginationToken(_ token: String) -> AppMesh.ListVirtualNodesInput {
        return .init(
            limit: self.limit,
            meshName: self.meshName,
            meshOwner: self.meshOwner,
            nextToken: token
        )
    }
}

extension AppMesh.ListVirtualRoutersInput: AWSPaginateToken {
    @inlinable
    public func usingPaginationToken(_ token: String) -> AppMesh.ListVirtualRoutersInput {
        return .init(
            limit: self.limit,
            meshName: self.meshName,
            meshOwner: self.meshOwner,
            nextToken: token
        )
    }
}

extension AppMesh.ListVirtualServicesInput: AWSPaginateToken {
    @inlinable
    public func usingPaginationToken(_ token: String) -> AppMesh.ListVirtualServicesInput {
        return .init(
            limit: self.limit,
            meshName: self.meshName,
            meshOwner: self.meshOwner,
            nextToken: token
        )
    }
}
