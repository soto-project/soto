//===----------------------------------------------------------------------===//
//
// This source file is part of the Soto for AWS open source project
//
// Copyright (c) 2017-2024 the Soto project authors
// Licensed under Apache License v2.0
//
// See LICENSE.txt for license information
// See CONTRIBUTORS.txt for the list of Soto project authors
//
// SPDX-License-Identifier: Apache-2.0
//
//===----------------------------------------------------------------------===//

// THIS FILE IS AUTOMATICALLY GENERATED by https://github.com/soto-project/soto-codegenerator.
// DO NOT EDIT.

#if canImport(FoundationEssentials)
import FoundationEssentials
#else
import Foundation
#endif
@_spi(SotoInternal) import SotoCore

extension AppMesh {
    // MARK: Enums

    public enum DefaultGatewayRouteRewrite: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case disabled = "DISABLED"
        case enabled = "ENABLED"
        public var description: String { return self.rawValue }
    }

    public enum DnsResponseType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case endpoints = "ENDPOINTS"
        case loadbalancer = "LOADBALANCER"
        public var description: String { return self.rawValue }
    }

    public enum DurationUnit: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case ms = "ms"
        case s = "s"
        public var description: String { return self.rawValue }
    }

    public enum EgressFilterType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case allowAll = "ALLOW_ALL"
        case dropAll = "DROP_ALL"
        public var description: String { return self.rawValue }
    }

    public enum GatewayRouteStatusCode: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case active = "ACTIVE"
        case deleted = "DELETED"
        case inactive = "INACTIVE"
        public var description: String { return self.rawValue }
    }

    public enum GrpcRetryPolicyEvent: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case cancelled = "cancelled"
        case deadlineExceeded = "deadline-exceeded"
        case `internal` = "internal"
        case resourceExhausted = "resource-exhausted"
        case unavailable = "unavailable"
        public var description: String { return self.rawValue }
    }

    public enum HttpMethod: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case connect = "CONNECT"
        case delete = "DELETE"
        case get = "GET"
        case head = "HEAD"
        case options = "OPTIONS"
        case patch = "PATCH"
        case post = "POST"
        case put = "PUT"
        case trace = "TRACE"
        public var description: String { return self.rawValue }
    }

    public enum HttpScheme: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case http = "http"
        case https = "https"
        public var description: String { return self.rawValue }
    }

    public enum IpPreference: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case iPv4ONLY = "IPv4_ONLY"
        case iPv4PREFERRED = "IPv4_PREFERRED"
        case iPv6ONLY = "IPv6_ONLY"
        case iPv6PREFERRED = "IPv6_PREFERRED"
        public var description: String { return self.rawValue }
    }

    public enum ListenerTlsMode: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case disabled = "DISABLED"
        case permissive = "PERMISSIVE"
        case strict = "STRICT"
        public var description: String { return self.rawValue }
    }

    public enum MeshStatusCode: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case active = "ACTIVE"
        case deleted = "DELETED"
        case inactive = "INACTIVE"
        public var description: String { return self.rawValue }
    }

    public enum PortProtocol: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case grpc = "grpc"
        case http = "http"
        case http2 = "http2"
        case tcp = "tcp"
        public var description: String { return self.rawValue }
    }

    public enum RouteStatusCode: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case active = "ACTIVE"
        case deleted = "DELETED"
        case inactive = "INACTIVE"
        public var description: String { return self.rawValue }
    }

    public enum TcpRetryPolicyEvent: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case connectionError = "connection-error"
        public var description: String { return self.rawValue }
    }

    public enum VirtualGatewayListenerTlsMode: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case disabled = "DISABLED"
        case permissive = "PERMISSIVE"
        case strict = "STRICT"
        public var description: String { return self.rawValue }
    }

    public enum VirtualGatewayPortProtocol: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case grpc = "grpc"
        case http = "http"
        case http2 = "http2"
        public var description: String { return self.rawValue }
    }

    public enum VirtualGatewayStatusCode: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case active = "ACTIVE"
        case deleted = "DELETED"
        case inactive = "INACTIVE"
        public var description: String { return self.rawValue }
    }

    public enum VirtualNodeStatusCode: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case active = "ACTIVE"
        case deleted = "DELETED"
        case inactive = "INACTIVE"
        public var description: String { return self.rawValue }
    }

    public enum VirtualRouterStatusCode: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case active = "ACTIVE"
        case deleted = "DELETED"
        case inactive = "INACTIVE"
        public var description: String { return self.rawValue }
    }

    public enum VirtualServiceStatusCode: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case active = "ACTIVE"
        case deleted = "DELETED"
        case inactive = "INACTIVE"
        public var description: String { return self.rawValue }
    }

    public enum ClientTlsCertificate: AWSEncodableShape & AWSDecodableShape, Sendable {
        /// An object that represents a local file certificate. The certificate must meet specific requirements and you must have proxy authorization enabled. For more information, see Transport Layer Security (TLS).
        case file(ListenerTlsFileCertificate)
        /// A reference to an object that represents a client's TLS Secret Discovery Service certificate.
        case sds(ListenerTlsSdsCertificate)

        public init(from decoder: Decoder) throws {
            let container = try decoder.container(keyedBy: CodingKeys.self)
            guard container.allKeys.count == 1, let key = container.allKeys.first else {
                let context = DecodingError.Context(
                    codingPath: container.codingPath,
                    debugDescription: "Expected exactly one key, but got \(container.allKeys.count)"
                )
                throw DecodingError.dataCorrupted(context)
            }
            switch key {
            case .file:
                let value = try container.decode(ListenerTlsFileCertificate.self, forKey: .file)
                self = .file(value)
            case .sds:
                let value = try container.decode(ListenerTlsSdsCertificate.self, forKey: .sds)
                self = .sds(value)
            }
        }

        public func encode(to encoder: Encoder) throws {
            var container = encoder.container(keyedBy: CodingKeys.self)
            switch self {
            case .file(let value):
                try container.encode(value, forKey: .file)
            case .sds(let value):
                try container.encode(value, forKey: .sds)
            }
        }

        public func validate(name: String) throws {
            switch self {
            case .file(let value):
                try value.validate(name: "\(name).file")
            default:
                break
            }
        }

        private enum CodingKeys: String, CodingKey {
            case file = "file"
            case sds = "sds"
        }
    }

    public enum GrpcMetadataMatchMethod: AWSEncodableShape & AWSDecodableShape, Sendable {
        /// The exact method header to be matched on.
        case exact(String)
        /// The specified beginning characters of the method header to be matched on.
        case prefix(String)
        case range(MatchRange)
        /// The regex used to match the method header.
        case regex(String)
        /// The specified ending characters of the method header to match on.
        case suffix(String)

        public init(from decoder: Decoder) throws {
            let container = try decoder.container(keyedBy: CodingKeys.self)
            guard container.allKeys.count == 1, let key = container.allKeys.first else {
                let context = DecodingError.Context(
                    codingPath: container.codingPath,
                    debugDescription: "Expected exactly one key, but got \(container.allKeys.count)"
                )
                throw DecodingError.dataCorrupted(context)
            }
            switch key {
            case .exact:
                let value = try container.decode(String.self, forKey: .exact)
                self = .exact(value)
            case .prefix:
                let value = try container.decode(String.self, forKey: .prefix)
                self = .prefix(value)
            case .range:
                let value = try container.decode(MatchRange.self, forKey: .range)
                self = .range(value)
            case .regex:
                let value = try container.decode(String.self, forKey: .regex)
                self = .regex(value)
            case .suffix:
                let value = try container.decode(String.self, forKey: .suffix)
                self = .suffix(value)
            }
        }

        public func encode(to encoder: Encoder) throws {
            var container = encoder.container(keyedBy: CodingKeys.self)
            switch self {
            case .exact(let value):
                try container.encode(value, forKey: .exact)
            case .prefix(let value):
                try container.encode(value, forKey: .prefix)
            case .range(let value):
                try container.encode(value, forKey: .range)
            case .regex(let value):
                try container.encode(value, forKey: .regex)
            case .suffix(let value):
                try container.encode(value, forKey: .suffix)
            }
        }

        public func validate(name: String) throws {
            switch self {
            case .exact(let value):
                try self.validate(value, name: "exact", parent: name, max: 255)
                try self.validate(value, name: "exact", parent: name, min: 1)
            case .prefix(let value):
                try self.validate(value, name: "prefix", parent: name, max: 255)
                try self.validate(value, name: "prefix", parent: name, min: 1)
            case .regex(let value):
                try self.validate(value, name: "regex", parent: name, max: 255)
                try self.validate(value, name: "regex", parent: name, min: 1)
            case .suffix(let value):
                try self.validate(value, name: "suffix", parent: name, max: 255)
                try self.validate(value, name: "suffix", parent: name, min: 1)
            default:
                break
            }
        }

        private enum CodingKeys: String, CodingKey {
            case exact = "exact"
            case prefix = "prefix"
            case range = "range"
            case regex = "regex"
            case suffix = "suffix"
        }
    }

    public enum GrpcRouteMetadataMatchMethod: AWSEncodableShape & AWSDecodableShape, Sendable {
        /// The value sent by the client must match the specified value exactly.
        case exact(String)
        /// The value sent by the client must begin with the specified characters.
        case prefix(String)
        /// An object that represents the range of values to match on.
        case range(MatchRange)
        /// The value sent by the client must include the specified characters.
        case regex(String)
        /// The value sent by the client must end with the specified characters.
        case suffix(String)

        public init(from decoder: Decoder) throws {
            let container = try decoder.container(keyedBy: CodingKeys.self)
            guard container.allKeys.count == 1, let key = container.allKeys.first else {
                let context = DecodingError.Context(
                    codingPath: container.codingPath,
                    debugDescription: "Expected exactly one key, but got \(container.allKeys.count)"
                )
                throw DecodingError.dataCorrupted(context)
            }
            switch key {
            case .exact:
                let value = try container.decode(String.self, forKey: .exact)
                self = .exact(value)
            case .prefix:
                let value = try container.decode(String.self, forKey: .prefix)
                self = .prefix(value)
            case .range:
                let value = try container.decode(MatchRange.self, forKey: .range)
                self = .range(value)
            case .regex:
                let value = try container.decode(String.self, forKey: .regex)
                self = .regex(value)
            case .suffix:
                let value = try container.decode(String.self, forKey: .suffix)
                self = .suffix(value)
            }
        }

        public func encode(to encoder: Encoder) throws {
            var container = encoder.container(keyedBy: CodingKeys.self)
            switch self {
            case .exact(let value):
                try container.encode(value, forKey: .exact)
            case .prefix(let value):
                try container.encode(value, forKey: .prefix)
            case .range(let value):
                try container.encode(value, forKey: .range)
            case .regex(let value):
                try container.encode(value, forKey: .regex)
            case .suffix(let value):
                try container.encode(value, forKey: .suffix)
            }
        }

        public func validate(name: String) throws {
            switch self {
            case .exact(let value):
                try self.validate(value, name: "exact", parent: name, max: 255)
                try self.validate(value, name: "exact", parent: name, min: 1)
            case .prefix(let value):
                try self.validate(value, name: "prefix", parent: name, max: 255)
                try self.validate(value, name: "prefix", parent: name, min: 1)
            case .regex(let value):
                try self.validate(value, name: "regex", parent: name, max: 255)
                try self.validate(value, name: "regex", parent: name, min: 1)
            case .suffix(let value):
                try self.validate(value, name: "suffix", parent: name, max: 255)
                try self.validate(value, name: "suffix", parent: name, min: 1)
            default:
                break
            }
        }

        private enum CodingKeys: String, CodingKey {
            case exact = "exact"
            case prefix = "prefix"
            case range = "range"
            case regex = "regex"
            case suffix = "suffix"
        }
    }

    public enum HeaderMatchMethod: AWSEncodableShape & AWSDecodableShape, Sendable {
        /// The value sent by the client must match the specified value exactly.
        case exact(String)
        /// The value sent by the client must begin with the specified characters.
        case prefix(String)
        /// An object that represents the range of values to match on.
        case range(MatchRange)
        /// The value sent by the client must include the specified characters.
        case regex(String)
        /// The value sent by the client must end with the specified characters.
        case suffix(String)

        public init(from decoder: Decoder) throws {
            let container = try decoder.container(keyedBy: CodingKeys.self)
            guard container.allKeys.count == 1, let key = container.allKeys.first else {
                let context = DecodingError.Context(
                    codingPath: container.codingPath,
                    debugDescription: "Expected exactly one key, but got \(container.allKeys.count)"
                )
                throw DecodingError.dataCorrupted(context)
            }
            switch key {
            case .exact:
                let value = try container.decode(String.self, forKey: .exact)
                self = .exact(value)
            case .prefix:
                let value = try container.decode(String.self, forKey: .prefix)
                self = .prefix(value)
            case .range:
                let value = try container.decode(MatchRange.self, forKey: .range)
                self = .range(value)
            case .regex:
                let value = try container.decode(String.self, forKey: .regex)
                self = .regex(value)
            case .suffix:
                let value = try container.decode(String.self, forKey: .suffix)
                self = .suffix(value)
            }
        }

        public func encode(to encoder: Encoder) throws {
            var container = encoder.container(keyedBy: CodingKeys.self)
            switch self {
            case .exact(let value):
                try container.encode(value, forKey: .exact)
            case .prefix(let value):
                try container.encode(value, forKey: .prefix)
            case .range(let value):
                try container.encode(value, forKey: .range)
            case .regex(let value):
                try container.encode(value, forKey: .regex)
            case .suffix(let value):
                try container.encode(value, forKey: .suffix)
            }
        }

        public func validate(name: String) throws {
            switch self {
            case .exact(let value):
                try self.validate(value, name: "exact", parent: name, max: 255)
                try self.validate(value, name: "exact", parent: name, min: 1)
            case .prefix(let value):
                try self.validate(value, name: "prefix", parent: name, max: 255)
                try self.validate(value, name: "prefix", parent: name, min: 1)
            case .regex(let value):
                try self.validate(value, name: "regex", parent: name, max: 255)
                try self.validate(value, name: "regex", parent: name, min: 1)
            case .suffix(let value):
                try self.validate(value, name: "suffix", parent: name, max: 255)
                try self.validate(value, name: "suffix", parent: name, min: 1)
            default:
                break
            }
        }

        private enum CodingKeys: String, CodingKey {
            case exact = "exact"
            case prefix = "prefix"
            case range = "range"
            case regex = "regex"
            case suffix = "suffix"
        }
    }

    public enum ListenerTimeout: AWSEncodableShape & AWSDecodableShape, Sendable {
        /// An object that represents types of timeouts.
        case grpc(GrpcTimeout)
        /// An object that represents types of timeouts.
        case http(HttpTimeout)
        /// An object that represents types of timeouts.
        case http2(HttpTimeout)
        /// An object that represents types of timeouts.
        case tcp(TcpTimeout)

        public init(from decoder: Decoder) throws {
            let container = try decoder.container(keyedBy: CodingKeys.self)
            guard container.allKeys.count == 1, let key = container.allKeys.first else {
                let context = DecodingError.Context(
                    codingPath: container.codingPath,
                    debugDescription: "Expected exactly one key, but got \(container.allKeys.count)"
                )
                throw DecodingError.dataCorrupted(context)
            }
            switch key {
            case .grpc:
                let value = try container.decode(GrpcTimeout.self, forKey: .grpc)
                self = .grpc(value)
            case .http:
                let value = try container.decode(HttpTimeout.self, forKey: .http)
                self = .http(value)
            case .http2:
                let value = try container.decode(HttpTimeout.self, forKey: .http2)
                self = .http2(value)
            case .tcp:
                let value = try container.decode(TcpTimeout.self, forKey: .tcp)
                self = .tcp(value)
            }
        }

        public func encode(to encoder: Encoder) throws {
            var container = encoder.container(keyedBy: CodingKeys.self)
            switch self {
            case .grpc(let value):
                try container.encode(value, forKey: .grpc)
            case .http(let value):
                try container.encode(value, forKey: .http)
            case .http2(let value):
                try container.encode(value, forKey: .http2)
            case .tcp(let value):
                try container.encode(value, forKey: .tcp)
            }
        }

        public func validate(name: String) throws {
            switch self {
            case .grpc(let value):
                try value.validate(name: "\(name).grpc")
            case .http(let value):
                try value.validate(name: "\(name).http")
            case .http2(let value):
                try value.validate(name: "\(name).http2")
            case .tcp(let value):
                try value.validate(name: "\(name).tcp")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case grpc = "grpc"
            case http = "http"
            case http2 = "http2"
            case tcp = "tcp"
        }
    }

    public enum ListenerTlsCertificate: AWSEncodableShape & AWSDecodableShape, Sendable {
        /// A reference to an object that represents an Certificate Manager certificate.
        case acm(ListenerTlsAcmCertificate)
        /// A reference to an object that represents a local file certificate.
        case file(ListenerTlsFileCertificate)
        /// A reference to an object that represents a listener's Secret Discovery Service certificate.
        case sds(ListenerTlsSdsCertificate)

        public init(from decoder: Decoder) throws {
            let container = try decoder.container(keyedBy: CodingKeys.self)
            guard container.allKeys.count == 1, let key = container.allKeys.first else {
                let context = DecodingError.Context(
                    codingPath: container.codingPath,
                    debugDescription: "Expected exactly one key, but got \(container.allKeys.count)"
                )
                throw DecodingError.dataCorrupted(context)
            }
            switch key {
            case .acm:
                let value = try container.decode(ListenerTlsAcmCertificate.self, forKey: .acm)
                self = .acm(value)
            case .file:
                let value = try container.decode(ListenerTlsFileCertificate.self, forKey: .file)
                self = .file(value)
            case .sds:
                let value = try container.decode(ListenerTlsSdsCertificate.self, forKey: .sds)
                self = .sds(value)
            }
        }

        public func encode(to encoder: Encoder) throws {
            var container = encoder.container(keyedBy: CodingKeys.self)
            switch self {
            case .acm(let value):
                try container.encode(value, forKey: .acm)
            case .file(let value):
                try container.encode(value, forKey: .file)
            case .sds(let value):
                try container.encode(value, forKey: .sds)
            }
        }

        public func validate(name: String) throws {
            switch self {
            case .file(let value):
                try value.validate(name: "\(name).file")
            default:
                break
            }
        }

        private enum CodingKeys: String, CodingKey {
            case acm = "acm"
            case file = "file"
            case sds = "sds"
        }
    }

    public enum ListenerTlsValidationContextTrust: AWSEncodableShape & AWSDecodableShape, Sendable {
        /// An object that represents a Transport Layer Security (TLS) validation context trust for a local file.
        case file(TlsValidationContextFileTrust)
        /// A reference to an object that represents a listener's Transport Layer Security (TLS) Secret Discovery Service validation context trust.
        case sds(TlsValidationContextSdsTrust)

        public init(from decoder: Decoder) throws {
            let container = try decoder.container(keyedBy: CodingKeys.self)
            guard container.allKeys.count == 1, let key = container.allKeys.first else {
                let context = DecodingError.Context(
                    codingPath: container.codingPath,
                    debugDescription: "Expected exactly one key, but got \(container.allKeys.count)"
                )
                throw DecodingError.dataCorrupted(context)
            }
            switch key {
            case .file:
                let value = try container.decode(TlsValidationContextFileTrust.self, forKey: .file)
                self = .file(value)
            case .sds:
                let value = try container.decode(TlsValidationContextSdsTrust.self, forKey: .sds)
                self = .sds(value)
            }
        }

        public func encode(to encoder: Encoder) throws {
            var container = encoder.container(keyedBy: CodingKeys.self)
            switch self {
            case .file(let value):
                try container.encode(value, forKey: .file)
            case .sds(let value):
                try container.encode(value, forKey: .sds)
            }
        }

        public func validate(name: String) throws {
            switch self {
            case .file(let value):
                try value.validate(name: "\(name).file")
            default:
                break
            }
        }

        private enum CodingKeys: String, CodingKey {
            case file = "file"
            case sds = "sds"
        }
    }

    public enum LoggingFormat: AWSEncodableShape & AWSDecodableShape, Sendable {
        case json([JsonFormatRef])
        case text(String)

        public init(from decoder: Decoder) throws {
            let container = try decoder.container(keyedBy: CodingKeys.self)
            guard container.allKeys.count == 1, let key = container.allKeys.first else {
                let context = DecodingError.Context(
                    codingPath: container.codingPath,
                    debugDescription: "Expected exactly one key, but got \(container.allKeys.count)"
                )
                throw DecodingError.dataCorrupted(context)
            }
            switch key {
            case .json:
                let value = try container.decode([JsonFormatRef].self, forKey: .json)
                self = .json(value)
            case .text:
                let value = try container.decode(String.self, forKey: .text)
                self = .text(value)
            }
        }

        public func encode(to encoder: Encoder) throws {
            var container = encoder.container(keyedBy: CodingKeys.self)
            switch self {
            case .json(let value):
                try container.encode(value, forKey: .json)
            case .text(let value):
                try container.encode(value, forKey: .text)
            }
        }

        public func validate(name: String) throws {
            switch self {
            case .json(let value):
                try value.forEach {
                    try $0.validate(name: "\(name).json[]")
                }
            case .text(let value):
                try self.validate(value, name: "text", parent: name, max: 1000)
                try self.validate(value, name: "text", parent: name, min: 1)
            }
        }

        private enum CodingKeys: String, CodingKey {
            case json = "json"
            case text = "text"
        }
    }

    public enum ServiceDiscovery: AWSEncodableShape & AWSDecodableShape, Sendable {
        /// Specifies any Cloud Map information for the virtual node.
        case awsCloudMap(AwsCloudMapServiceDiscovery)
        /// Specifies the DNS information for the virtual node.
        case dns(DnsServiceDiscovery)

        public init(from decoder: Decoder) throws {
            let container = try decoder.container(keyedBy: CodingKeys.self)
            guard container.allKeys.count == 1, let key = container.allKeys.first else {
                let context = DecodingError.Context(
                    codingPath: container.codingPath,
                    debugDescription: "Expected exactly one key, but got \(container.allKeys.count)"
                )
                throw DecodingError.dataCorrupted(context)
            }
            switch key {
            case .awsCloudMap:
                let value = try container.decode(AwsCloudMapServiceDiscovery.self, forKey: .awsCloudMap)
                self = .awsCloudMap(value)
            case .dns:
                let value = try container.decode(DnsServiceDiscovery.self, forKey: .dns)
                self = .dns(value)
            }
        }

        public func encode(to encoder: Encoder) throws {
            var container = encoder.container(keyedBy: CodingKeys.self)
            switch self {
            case .awsCloudMap(let value):
                try container.encode(value, forKey: .awsCloudMap)
            case .dns(let value):
                try container.encode(value, forKey: .dns)
            }
        }

        public func validate(name: String) throws {
            switch self {
            case .awsCloudMap(let value):
                try value.validate(name: "\(name).awsCloudMap")
            default:
                break
            }
        }

        private enum CodingKeys: String, CodingKey {
            case awsCloudMap = "awsCloudMap"
            case dns = "dns"
        }
    }

    public enum TlsValidationContextTrust: AWSEncodableShape & AWSDecodableShape, Sendable {
        /// A reference to an object that represents a Transport Layer Security (TLS) validation context trust for an Certificate Manager certificate.
        case acm(TlsValidationContextAcmTrust)
        /// An object that represents a Transport Layer Security (TLS) validation context trust for a local file.
        case file(TlsValidationContextFileTrust)
        /// A reference to an object that represents a Transport Layer Security (TLS) Secret Discovery Service validation context trust.
        case sds(TlsValidationContextSdsTrust)

        public init(from decoder: Decoder) throws {
            let container = try decoder.container(keyedBy: CodingKeys.self)
            guard container.allKeys.count == 1, let key = container.allKeys.first else {
                let context = DecodingError.Context(
                    codingPath: container.codingPath,
                    debugDescription: "Expected exactly one key, but got \(container.allKeys.count)"
                )
                throw DecodingError.dataCorrupted(context)
            }
            switch key {
            case .acm:
                let value = try container.decode(TlsValidationContextAcmTrust.self, forKey: .acm)
                self = .acm(value)
            case .file:
                let value = try container.decode(TlsValidationContextFileTrust.self, forKey: .file)
                self = .file(value)
            case .sds:
                let value = try container.decode(TlsValidationContextSdsTrust.self, forKey: .sds)
                self = .sds(value)
            }
        }

        public func encode(to encoder: Encoder) throws {
            var container = encoder.container(keyedBy: CodingKeys.self)
            switch self {
            case .acm(let value):
                try container.encode(value, forKey: .acm)
            case .file(let value):
                try container.encode(value, forKey: .file)
            case .sds(let value):
                try container.encode(value, forKey: .sds)
            }
        }

        public func validate(name: String) throws {
            switch self {
            case .acm(let value):
                try value.validate(name: "\(name).acm")
            case .file(let value):
                try value.validate(name: "\(name).file")
            default:
                break
            }
        }

        private enum CodingKeys: String, CodingKey {
            case acm = "acm"
            case file = "file"
            case sds = "sds"
        }
    }

    public enum VirtualGatewayClientTlsCertificate: AWSEncodableShape & AWSDecodableShape, Sendable {
        /// An object that represents a local file certificate. The certificate must meet specific requirements and you must have proxy authorization enabled. For more information, see Transport Layer Security (TLS) .
        case file(VirtualGatewayListenerTlsFileCertificate)
        /// A reference to an object that represents a virtual gateway's client's Secret Discovery Service certificate.
        case sds(VirtualGatewayListenerTlsSdsCertificate)

        public init(from decoder: Decoder) throws {
            let container = try decoder.container(keyedBy: CodingKeys.self)
            guard container.allKeys.count == 1, let key = container.allKeys.first else {
                let context = DecodingError.Context(
                    codingPath: container.codingPath,
                    debugDescription: "Expected exactly one key, but got \(container.allKeys.count)"
                )
                throw DecodingError.dataCorrupted(context)
            }
            switch key {
            case .file:
                let value = try container.decode(VirtualGatewayListenerTlsFileCertificate.self, forKey: .file)
                self = .file(value)
            case .sds:
                let value = try container.decode(VirtualGatewayListenerTlsSdsCertificate.self, forKey: .sds)
                self = .sds(value)
            }
        }

        public func encode(to encoder: Encoder) throws {
            var container = encoder.container(keyedBy: CodingKeys.self)
            switch self {
            case .file(let value):
                try container.encode(value, forKey: .file)
            case .sds(let value):
                try container.encode(value, forKey: .sds)
            }
        }

        public func validate(name: String) throws {
            switch self {
            case .file(let value):
                try value.validate(name: "\(name).file")
            default:
                break
            }
        }

        private enum CodingKeys: String, CodingKey {
            case file = "file"
            case sds = "sds"
        }
    }

    public enum VirtualGatewayConnectionPool: AWSEncodableShape & AWSDecodableShape, Sendable {
        /// An object that represents a type of connection pool.
        case grpc(VirtualGatewayGrpcConnectionPool)
        /// An object that represents a type of connection pool.
        case http(VirtualGatewayHttpConnectionPool)
        /// An object that represents a type of connection pool.
        case http2(VirtualGatewayHttp2ConnectionPool)

        public init(from decoder: Decoder) throws {
            let container = try decoder.container(keyedBy: CodingKeys.self)
            guard container.allKeys.count == 1, let key = container.allKeys.first else {
                let context = DecodingError.Context(
                    codingPath: container.codingPath,
                    debugDescription: "Expected exactly one key, but got \(container.allKeys.count)"
                )
                throw DecodingError.dataCorrupted(context)
            }
            switch key {
            case .grpc:
                let value = try container.decode(VirtualGatewayGrpcConnectionPool.self, forKey: .grpc)
                self = .grpc(value)
            case .http:
                let value = try container.decode(VirtualGatewayHttpConnectionPool.self, forKey: .http)
                self = .http(value)
            case .http2:
                let value = try container.decode(VirtualGatewayHttp2ConnectionPool.self, forKey: .http2)
                self = .http2(value)
            }
        }

        public func encode(to encoder: Encoder) throws {
            var container = encoder.container(keyedBy: CodingKeys.self)
            switch self {
            case .grpc(let value):
                try container.encode(value, forKey: .grpc)
            case .http(let value):
                try container.encode(value, forKey: .http)
            case .http2(let value):
                try container.encode(value, forKey: .http2)
            }
        }

        public func validate(name: String) throws {
            switch self {
            case .grpc(let value):
                try value.validate(name: "\(name).grpc")
            case .http(let value):
                try value.validate(name: "\(name).http")
            case .http2(let value):
                try value.validate(name: "\(name).http2")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case grpc = "grpc"
            case http = "http"
            case http2 = "http2"
        }
    }

    public enum VirtualGatewayListenerTlsCertificate: AWSEncodableShape & AWSDecodableShape, Sendable {
        /// A reference to an object that represents an Certificate Manager certificate.
        case acm(VirtualGatewayListenerTlsAcmCertificate)
        /// A reference to an object that represents a local file certificate.
        case file(VirtualGatewayListenerTlsFileCertificate)
        /// A reference to an object that represents a virtual gateway's listener's Secret Discovery Service certificate.
        case sds(VirtualGatewayListenerTlsSdsCertificate)

        public init(from decoder: Decoder) throws {
            let container = try decoder.container(keyedBy: CodingKeys.self)
            guard container.allKeys.count == 1, let key = container.allKeys.first else {
                let context = DecodingError.Context(
                    codingPath: container.codingPath,
                    debugDescription: "Expected exactly one key, but got \(container.allKeys.count)"
                )
                throw DecodingError.dataCorrupted(context)
            }
            switch key {
            case .acm:
                let value = try container.decode(VirtualGatewayListenerTlsAcmCertificate.self, forKey: .acm)
                self = .acm(value)
            case .file:
                let value = try container.decode(VirtualGatewayListenerTlsFileCertificate.self, forKey: .file)
                self = .file(value)
            case .sds:
                let value = try container.decode(VirtualGatewayListenerTlsSdsCertificate.self, forKey: .sds)
                self = .sds(value)
            }
        }

        public func encode(to encoder: Encoder) throws {
            var container = encoder.container(keyedBy: CodingKeys.self)
            switch self {
            case .acm(let value):
                try container.encode(value, forKey: .acm)
            case .file(let value):
                try container.encode(value, forKey: .file)
            case .sds(let value):
                try container.encode(value, forKey: .sds)
            }
        }

        public func validate(name: String) throws {
            switch self {
            case .file(let value):
                try value.validate(name: "\(name).file")
            default:
                break
            }
        }

        private enum CodingKeys: String, CodingKey {
            case acm = "acm"
            case file = "file"
            case sds = "sds"
        }
    }

    public enum VirtualGatewayListenerTlsValidationContextTrust: AWSEncodableShape & AWSDecodableShape, Sendable {
        /// An object that represents a Transport Layer Security (TLS) validation context trust for a local file.
        case file(VirtualGatewayTlsValidationContextFileTrust)
        /// A reference to an object that represents a virtual gateway's listener's Transport Layer Security (TLS) Secret Discovery Service validation context trust.
        case sds(VirtualGatewayTlsValidationContextSdsTrust)

        public init(from decoder: Decoder) throws {
            let container = try decoder.container(keyedBy: CodingKeys.self)
            guard container.allKeys.count == 1, let key = container.allKeys.first else {
                let context = DecodingError.Context(
                    codingPath: container.codingPath,
                    debugDescription: "Expected exactly one key, but got \(container.allKeys.count)"
                )
                throw DecodingError.dataCorrupted(context)
            }
            switch key {
            case .file:
                let value = try container.decode(VirtualGatewayTlsValidationContextFileTrust.self, forKey: .file)
                self = .file(value)
            case .sds:
                let value = try container.decode(VirtualGatewayTlsValidationContextSdsTrust.self, forKey: .sds)
                self = .sds(value)
            }
        }

        public func encode(to encoder: Encoder) throws {
            var container = encoder.container(keyedBy: CodingKeys.self)
            switch self {
            case .file(let value):
                try container.encode(value, forKey: .file)
            case .sds(let value):
                try container.encode(value, forKey: .sds)
            }
        }

        public func validate(name: String) throws {
            switch self {
            case .file(let value):
                try value.validate(name: "\(name).file")
            default:
                break
            }
        }

        private enum CodingKeys: String, CodingKey {
            case file = "file"
            case sds = "sds"
        }
    }

    public enum VirtualGatewayTlsValidationContextTrust: AWSEncodableShape & AWSDecodableShape, Sendable {
        /// A reference to an object that represents a Transport Layer Security (TLS) validation context trust for an Certificate Manager certificate.
        case acm(VirtualGatewayTlsValidationContextAcmTrust)
        /// An object that represents a Transport Layer Security (TLS) validation context trust for a local file.
        case file(VirtualGatewayTlsValidationContextFileTrust)
        /// A reference to an object that represents a virtual gateway's Transport Layer Security (TLS) Secret Discovery Service validation context trust.
        case sds(VirtualGatewayTlsValidationContextSdsTrust)

        public init(from decoder: Decoder) throws {
            let container = try decoder.container(keyedBy: CodingKeys.self)
            guard container.allKeys.count == 1, let key = container.allKeys.first else {
                let context = DecodingError.Context(
                    codingPath: container.codingPath,
                    debugDescription: "Expected exactly one key, but got \(container.allKeys.count)"
                )
                throw DecodingError.dataCorrupted(context)
            }
            switch key {
            case .acm:
                let value = try container.decode(VirtualGatewayTlsValidationContextAcmTrust.self, forKey: .acm)
                self = .acm(value)
            case .file:
                let value = try container.decode(VirtualGatewayTlsValidationContextFileTrust.self, forKey: .file)
                self = .file(value)
            case .sds:
                let value = try container.decode(VirtualGatewayTlsValidationContextSdsTrust.self, forKey: .sds)
                self = .sds(value)
            }
        }

        public func encode(to encoder: Encoder) throws {
            var container = encoder.container(keyedBy: CodingKeys.self)
            switch self {
            case .acm(let value):
                try container.encode(value, forKey: .acm)
            case .file(let value):
                try container.encode(value, forKey: .file)
            case .sds(let value):
                try container.encode(value, forKey: .sds)
            }
        }

        public func validate(name: String) throws {
            switch self {
            case .acm(let value):
                try value.validate(name: "\(name).acm")
            case .file(let value):
                try value.validate(name: "\(name).file")
            default:
                break
            }
        }

        private enum CodingKeys: String, CodingKey {
            case acm = "acm"
            case file = "file"
            case sds = "sds"
        }
    }

    public enum VirtualNodeConnectionPool: AWSEncodableShape & AWSDecodableShape, Sendable {
        /// An object that represents a type of connection pool.
        case grpc(VirtualNodeGrpcConnectionPool)
        /// An object that represents a type of connection pool.
        case http(VirtualNodeHttpConnectionPool)
        /// An object that represents a type of connection pool.
        case http2(VirtualNodeHttp2ConnectionPool)
        /// An object that represents a type of connection pool.
        case tcp(VirtualNodeTcpConnectionPool)

        public init(from decoder: Decoder) throws {
            let container = try decoder.container(keyedBy: CodingKeys.self)
            guard container.allKeys.count == 1, let key = container.allKeys.first else {
                let context = DecodingError.Context(
                    codingPath: container.codingPath,
                    debugDescription: "Expected exactly one key, but got \(container.allKeys.count)"
                )
                throw DecodingError.dataCorrupted(context)
            }
            switch key {
            case .grpc:
                let value = try container.decode(VirtualNodeGrpcConnectionPool.self, forKey: .grpc)
                self = .grpc(value)
            case .http:
                let value = try container.decode(VirtualNodeHttpConnectionPool.self, forKey: .http)
                self = .http(value)
            case .http2:
                let value = try container.decode(VirtualNodeHttp2ConnectionPool.self, forKey: .http2)
                self = .http2(value)
            case .tcp:
                let value = try container.decode(VirtualNodeTcpConnectionPool.self, forKey: .tcp)
                self = .tcp(value)
            }
        }

        public func encode(to encoder: Encoder) throws {
            var container = encoder.container(keyedBy: CodingKeys.self)
            switch self {
            case .grpc(let value):
                try container.encode(value, forKey: .grpc)
            case .http(let value):
                try container.encode(value, forKey: .http)
            case .http2(let value):
                try container.encode(value, forKey: .http2)
            case .tcp(let value):
                try container.encode(value, forKey: .tcp)
            }
        }

        public func validate(name: String) throws {
            switch self {
            case .grpc(let value):
                try value.validate(name: "\(name).grpc")
            case .http(let value):
                try value.validate(name: "\(name).http")
            case .http2(let value):
                try value.validate(name: "\(name).http2")
            case .tcp(let value):
                try value.validate(name: "\(name).tcp")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case grpc = "grpc"
            case http = "http"
            case http2 = "http2"
            case tcp = "tcp"
        }
    }

    public enum VirtualServiceProvider: AWSEncodableShape & AWSDecodableShape, Sendable {
        /// The virtual node associated with a virtual service.
        case virtualNode(VirtualNodeServiceProvider)
        /// The virtual router associated with a virtual service.
        case virtualRouter(VirtualRouterServiceProvider)

        public init(from decoder: Decoder) throws {
            let container = try decoder.container(keyedBy: CodingKeys.self)
            guard container.allKeys.count == 1, let key = container.allKeys.first else {
                let context = DecodingError.Context(
                    codingPath: container.codingPath,
                    debugDescription: "Expected exactly one key, but got \(container.allKeys.count)"
                )
                throw DecodingError.dataCorrupted(context)
            }
            switch key {
            case .virtualNode:
                let value = try container.decode(VirtualNodeServiceProvider.self, forKey: .virtualNode)
                self = .virtualNode(value)
            case .virtualRouter:
                let value = try container.decode(VirtualRouterServiceProvider.self, forKey: .virtualRouter)
                self = .virtualRouter(value)
            }
        }

        public func encode(to encoder: Encoder) throws {
            var container = encoder.container(keyedBy: CodingKeys.self)
            switch self {
            case .virtualNode(let value):
                try container.encode(value, forKey: .virtualNode)
            case .virtualRouter(let value):
                try container.encode(value, forKey: .virtualRouter)
            }
        }

        public func validate(name: String) throws {
            switch self {
            case .virtualNode(let value):
                try value.validate(name: "\(name).virtualNode")
            case .virtualRouter(let value):
                try value.validate(name: "\(name).virtualRouter")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case virtualNode = "virtualNode"
            case virtualRouter = "virtualRouter"
        }
    }

    // MARK: Shapes

    public struct AwsCloudMapInstanceAttribute: AWSEncodableShape & AWSDecodableShape {
        /// The name of an Cloud Map service instance attribute key. Any Cloud Map service instance that contains the specified key and value is returned.
        public let key: String
        /// The value of an Cloud Map service instance attribute key. Any Cloud Map service instance that contains the specified key and value is returned.
        public let value: String

        @inlinable
        public init(key: String, value: String) {
            self.key = key
            self.value = value
        }

        public func validate(name: String) throws {
            try self.validate(self.key, name: "key", parent: name, max: 255)
            try self.validate(self.key, name: "key", parent: name, min: 1)
            try self.validate(self.key, name: "key", parent: name, pattern: "^[a-zA-Z0-9!-~]+$")
            try self.validate(self.value, name: "value", parent: name, max: 1024)
            try self.validate(self.value, name: "value", parent: name, min: 1)
            try self.validate(self.value, name: "value", parent: name, pattern: "^([a-zA-Z0-9!-~][ \ta-zA-Z0-9!-~]*){0,1}[a-zA-Z0-9!-~]{0,1}$")
        }

        private enum CodingKeys: String, CodingKey {
            case key = "key"
            case value = "value"
        }
    }

    public struct AwsCloudMapServiceDiscovery: AWSEncodableShape & AWSDecodableShape {
        /// A string map that contains attributes with values that you can use to filter instances by any custom attribute that you specified when you registered the instance. Only instances that match all of the specified key/value pairs will be returned.
        public let attributes: [AwsCloudMapInstanceAttribute]?
        /// The preferred IP version that this virtual node uses. Setting the IP preference on the virtual node only overrides the IP preference set for the mesh on this specific node.
        public let ipPreference: IpPreference?
        /// The name of the Cloud Map namespace to use.
        public let namespaceName: String
        /// The name of the Cloud Map service to use.
        public let serviceName: String

        @inlinable
        public init(attributes: [AwsCloudMapInstanceAttribute]? = nil, ipPreference: IpPreference? = nil, namespaceName: String, serviceName: String) {
            self.attributes = attributes
            self.ipPreference = ipPreference
            self.namespaceName = namespaceName
            self.serviceName = serviceName
        }

        public func validate(name: String) throws {
            try self.attributes?.forEach {
                try $0.validate(name: "\(name).attributes[]")
            }
            try self.validate(self.namespaceName, name: "namespaceName", parent: name, max: 1024)
            try self.validate(self.namespaceName, name: "namespaceName", parent: name, min: 1)
            try self.validate(self.serviceName, name: "serviceName", parent: name, max: 1024)
            try self.validate(self.serviceName, name: "serviceName", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case attributes = "attributes"
            case ipPreference = "ipPreference"
            case namespaceName = "namespaceName"
            case serviceName = "serviceName"
        }
    }

    public struct BackendDefaults: AWSEncodableShape & AWSDecodableShape {
        /// A reference to an object that represents a client policy.
        public let clientPolicy: ClientPolicy?

        @inlinable
        public init(clientPolicy: ClientPolicy? = nil) {
            self.clientPolicy = clientPolicy
        }

        public func validate(name: String) throws {
            try self.clientPolicy?.validate(name: "\(name).clientPolicy")
        }

        private enum CodingKeys: String, CodingKey {
            case clientPolicy = "clientPolicy"
        }
    }

    public struct ClientPolicy: AWSEncodableShape & AWSDecodableShape {
        /// A reference to an object that represents a Transport Layer Security (TLS) client policy.
        public let tls: ClientPolicyTls?

        @inlinable
        public init(tls: ClientPolicyTls? = nil) {
            self.tls = tls
        }

        public func validate(name: String) throws {
            try self.tls?.validate(name: "\(name).tls")
        }

        private enum CodingKeys: String, CodingKey {
            case tls = "tls"
        }
    }

    public struct ClientPolicyTls: AWSEncodableShape & AWSDecodableShape {
        /// A reference to an object that represents a client's TLS certificate.
        public let certificate: ClientTlsCertificate?
        /// Whether the policy is enforced. The default is True, if a value isn't specified.
        public let enforce: Bool?
        /// One or more ports that the policy is enforced for.
        public let ports: [Int]?
        /// A reference to an object that represents a TLS validation context.
        public let validation: TlsValidationContext

        @inlinable
        public init(certificate: ClientTlsCertificate? = nil, enforce: Bool? = nil, ports: [Int]? = nil, validation: TlsValidationContext) {
            self.certificate = certificate
            self.enforce = enforce
            self.ports = ports
            self.validation = validation
        }

        public func validate(name: String) throws {
            try self.certificate?.validate(name: "\(name).certificate")
            try self.ports?.forEach {
                try validate($0, name: "ports[]", parent: name, max: 65535)
                try validate($0, name: "ports[]", parent: name, min: 1)
            }
            try self.validation.validate(name: "\(name).validation")
        }

        private enum CodingKeys: String, CodingKey {
            case certificate = "certificate"
            case enforce = "enforce"
            case ports = "ports"
            case validation = "validation"
        }
    }

    public struct CreateGatewayRouteInput: AWSEncodableShape {
        /// Unique, case-sensitive identifier that you provide to ensure the idempotency of the
        /// request. Up to 36 letters, numbers, hyphens, and underscores are allowed.
        public let clientToken: String?
        /// The name to use for the gateway route.
        public let gatewayRouteName: String
        /// The name of the service mesh to create the gateway route in.
        public let meshName: String
        /// The Amazon Web Services IAM account ID of the service mesh owner. If the account ID is not your own, then the account that you specify must share the mesh with your account before you can create  the resource in the service mesh. For more information about mesh sharing, see Working with shared meshes.
        public let meshOwner: String?
        /// The gateway route specification to apply.
        public let spec: GatewayRouteSpec
        /// Optional metadata that you can apply to the gateway route to assist with categorization and organization. Each tag consists of a key and an optional value, both of which you define. Tag keys can have a maximum character length of 128 characters, and tag values can have a maximum length of 256 characters.
        public let tags: [TagRef]?
        /// The name of the virtual gateway to associate the gateway route with. If the virtual gateway is in a shared mesh, then you must be the owner of the virtual gateway resource.
        public let virtualGatewayName: String

        @inlinable
        public init(clientToken: String? = CreateGatewayRouteInput.idempotencyToken(), gatewayRouteName: String, meshName: String, meshOwner: String? = nil, spec: GatewayRouteSpec, tags: [TagRef]? = nil, virtualGatewayName: String) {
            self.clientToken = clientToken
            self.gatewayRouteName = gatewayRouteName
            self.meshName = meshName
            self.meshOwner = meshOwner
            self.spec = spec
            self.tags = tags
            self.virtualGatewayName = virtualGatewayName
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.clientToken, forKey: .clientToken)
            try container.encode(self.gatewayRouteName, forKey: .gatewayRouteName)
            request.encodePath(self.meshName, key: "meshName")
            request.encodeQuery(self.meshOwner, key: "meshOwner")
            try container.encode(self.spec, forKey: .spec)
            try container.encodeIfPresent(self.tags, forKey: .tags)
            request.encodePath(self.virtualGatewayName, key: "virtualGatewayName")
        }

        public func validate(name: String) throws {
            try self.validate(self.gatewayRouteName, name: "gatewayRouteName", parent: name, max: 255)
            try self.validate(self.gatewayRouteName, name: "gatewayRouteName", parent: name, min: 1)
            try self.validate(self.meshName, name: "meshName", parent: name, max: 255)
            try self.validate(self.meshName, name: "meshName", parent: name, min: 1)
            try self.validate(self.meshOwner, name: "meshOwner", parent: name, max: 12)
            try self.validate(self.meshOwner, name: "meshOwner", parent: name, min: 12)
            try self.spec.validate(name: "\(name).spec")
            try self.tags?.forEach {
                try $0.validate(name: "\(name).tags[]")
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 50)
            try self.validate(self.virtualGatewayName, name: "virtualGatewayName", parent: name, max: 255)
            try self.validate(self.virtualGatewayName, name: "virtualGatewayName", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "clientToken"
            case gatewayRouteName = "gatewayRouteName"
            case spec = "spec"
            case tags = "tags"
        }
    }

    public struct CreateGatewayRouteOutput: AWSDecodableShape {
        /// The full description of your gateway route following the create call.
        public let gatewayRoute: GatewayRouteData

        @inlinable
        public init(gatewayRoute: GatewayRouteData) {
            self.gatewayRoute = gatewayRoute
        }

        public init(from decoder: Decoder) throws {
            let container = try decoder.singleValueContainer()
            self.gatewayRoute = try container.decode(GatewayRouteData.self)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct CreateMeshInput: AWSEncodableShape {
        /// Unique, case-sensitive identifier that you provide to ensure the idempotency of the
        /// request. Up to 36 letters, numbers, hyphens, and underscores are allowed.
        public let clientToken: String?
        /// The name to use for the service mesh.
        public let meshName: String
        /// The service mesh specification to apply.
        public let spec: MeshSpec?
        /// Optional metadata that you can apply to the service mesh to assist with categorization and organization. Each tag consists of a key and an optional value, both of which you define. Tag keys can have a maximum character length of 128 characters, and tag values can have a maximum length of 256 characters.
        public let tags: [TagRef]?

        @inlinable
        public init(clientToken: String? = CreateMeshInput.idempotencyToken(), meshName: String, spec: MeshSpec? = nil, tags: [TagRef]? = nil) {
            self.clientToken = clientToken
            self.meshName = meshName
            self.spec = spec
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.validate(self.meshName, name: "meshName", parent: name, max: 255)
            try self.validate(self.meshName, name: "meshName", parent: name, min: 1)
            try self.tags?.forEach {
                try $0.validate(name: "\(name).tags[]")
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 50)
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "clientToken"
            case meshName = "meshName"
            case spec = "spec"
            case tags = "tags"
        }
    }

    public struct CreateMeshOutput: AWSDecodableShape {
        /// The full description of your service mesh following the create call.
        public let mesh: MeshData

        @inlinable
        public init(mesh: MeshData) {
            self.mesh = mesh
        }

        public init(from decoder: Decoder) throws {
            let container = try decoder.singleValueContainer()
            self.mesh = try container.decode(MeshData.self)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct CreateRouteInput: AWSEncodableShape {
        /// Unique, case-sensitive identifier that you provide to ensure the idempotency of the
        /// request. Up to 36 letters, numbers, hyphens, and underscores are allowed.
        public let clientToken: String?
        /// The name of the service mesh to create the route in.
        public let meshName: String
        /// The Amazon Web Services IAM account ID of the service mesh owner. If the account ID is not your own, then the account that you specify must share the mesh with your account before you can create  the resource in the service mesh. For more information about mesh sharing, see Working with shared meshes.
        public let meshOwner: String?
        /// The name to use for the route.
        public let routeName: String
        /// The route specification to apply.
        public let spec: RouteSpec
        /// Optional metadata that you can apply to the route to assist with categorization and organization. Each tag consists of a key and an optional value, both of which you define. Tag keys can have a maximum character length of 128 characters, and tag values can have a maximum length of 256 characters.
        public let tags: [TagRef]?
        /// The name of the virtual router in which to create the route. If the virtual router is in a shared mesh, then you must be the owner of the virtual router resource.
        public let virtualRouterName: String

        @inlinable
        public init(clientToken: String? = CreateRouteInput.idempotencyToken(), meshName: String, meshOwner: String? = nil, routeName: String, spec: RouteSpec, tags: [TagRef]? = nil, virtualRouterName: String) {
            self.clientToken = clientToken
            self.meshName = meshName
            self.meshOwner = meshOwner
            self.routeName = routeName
            self.spec = spec
            self.tags = tags
            self.virtualRouterName = virtualRouterName
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.clientToken, forKey: .clientToken)
            request.encodePath(self.meshName, key: "meshName")
            request.encodeQuery(self.meshOwner, key: "meshOwner")
            try container.encode(self.routeName, forKey: .routeName)
            try container.encode(self.spec, forKey: .spec)
            try container.encodeIfPresent(self.tags, forKey: .tags)
            request.encodePath(self.virtualRouterName, key: "virtualRouterName")
        }

        public func validate(name: String) throws {
            try self.validate(self.meshName, name: "meshName", parent: name, max: 255)
            try self.validate(self.meshName, name: "meshName", parent: name, min: 1)
            try self.validate(self.meshOwner, name: "meshOwner", parent: name, max: 12)
            try self.validate(self.meshOwner, name: "meshOwner", parent: name, min: 12)
            try self.validate(self.routeName, name: "routeName", parent: name, max: 255)
            try self.validate(self.routeName, name: "routeName", parent: name, min: 1)
            try self.spec.validate(name: "\(name).spec")
            try self.tags?.forEach {
                try $0.validate(name: "\(name).tags[]")
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 50)
            try self.validate(self.virtualRouterName, name: "virtualRouterName", parent: name, max: 255)
            try self.validate(self.virtualRouterName, name: "virtualRouterName", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "clientToken"
            case routeName = "routeName"
            case spec = "spec"
            case tags = "tags"
        }
    }

    public struct CreateRouteOutput: AWSDecodableShape {
        /// The full description of your mesh following the create call.
        public let route: RouteData

        @inlinable
        public init(route: RouteData) {
            self.route = route
        }

        public init(from decoder: Decoder) throws {
            let container = try decoder.singleValueContainer()
            self.route = try container.decode(RouteData.self)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct CreateVirtualGatewayInput: AWSEncodableShape {
        /// Unique, case-sensitive identifier that you provide to ensure the idempotency of the
        /// request. Up to 36 letters, numbers, hyphens, and underscores are allowed.
        public let clientToken: String?
        /// The name of the service mesh to create the virtual gateway in.
        public let meshName: String
        /// The Amazon Web Services IAM account ID of the service mesh owner. If the account ID is not your own, then the account that you specify must share the mesh with your account before you can create  the resource in the service mesh. For more information about mesh sharing, see Working with shared meshes.
        public let meshOwner: String?
        /// The virtual gateway specification to apply.
        public let spec: VirtualGatewaySpec
        /// Optional metadata that you can apply to the virtual gateway to assist with categorization and organization. Each tag consists of a key and an optional value, both of which you define. Tag keys can have a maximum character length of 128 characters, and tag values can have a maximum length of 256 characters.
        public let tags: [TagRef]?
        /// The name to use for the virtual gateway.
        public let virtualGatewayName: String

        @inlinable
        public init(clientToken: String? = CreateVirtualGatewayInput.idempotencyToken(), meshName: String, meshOwner: String? = nil, spec: VirtualGatewaySpec, tags: [TagRef]? = nil, virtualGatewayName: String) {
            self.clientToken = clientToken
            self.meshName = meshName
            self.meshOwner = meshOwner
            self.spec = spec
            self.tags = tags
            self.virtualGatewayName = virtualGatewayName
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.clientToken, forKey: .clientToken)
            request.encodePath(self.meshName, key: "meshName")
            request.encodeQuery(self.meshOwner, key: "meshOwner")
            try container.encode(self.spec, forKey: .spec)
            try container.encodeIfPresent(self.tags, forKey: .tags)
            try container.encode(self.virtualGatewayName, forKey: .virtualGatewayName)
        }

        public func validate(name: String) throws {
            try self.validate(self.meshName, name: "meshName", parent: name, max: 255)
            try self.validate(self.meshName, name: "meshName", parent: name, min: 1)
            try self.validate(self.meshOwner, name: "meshOwner", parent: name, max: 12)
            try self.validate(self.meshOwner, name: "meshOwner", parent: name, min: 12)
            try self.spec.validate(name: "\(name).spec")
            try self.tags?.forEach {
                try $0.validate(name: "\(name).tags[]")
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 50)
            try self.validate(self.virtualGatewayName, name: "virtualGatewayName", parent: name, max: 255)
            try self.validate(self.virtualGatewayName, name: "virtualGatewayName", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "clientToken"
            case spec = "spec"
            case tags = "tags"
            case virtualGatewayName = "virtualGatewayName"
        }
    }

    public struct CreateVirtualGatewayOutput: AWSDecodableShape {
        /// The full description of your virtual gateway following the create call.
        public let virtualGateway: VirtualGatewayData

        @inlinable
        public init(virtualGateway: VirtualGatewayData) {
            self.virtualGateway = virtualGateway
        }

        public init(from decoder: Decoder) throws {
            let container = try decoder.singleValueContainer()
            self.virtualGateway = try container.decode(VirtualGatewayData.self)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct CreateVirtualNodeInput: AWSEncodableShape {
        /// Unique, case-sensitive identifier that you provide to ensure the idempotency of the
        /// request. Up to 36 letters, numbers, hyphens, and underscores are allowed.
        public let clientToken: String?
        /// The name of the service mesh to create the virtual node in.
        public let meshName: String
        /// The Amazon Web Services IAM account ID of the service mesh owner. If the account ID is not your own, then the account that you specify must share the mesh with your account before you can create  the resource in the service mesh. For more information about mesh sharing, see Working with shared meshes.
        public let meshOwner: String?
        /// The virtual node specification to apply.
        public let spec: VirtualNodeSpec
        /// Optional metadata that you can apply to the virtual node to assist with categorization and organization. Each tag consists of a key and an optional value, both of which you define. Tag keys can have a maximum character length of 128 characters, and tag values can have a maximum length of 256 characters.
        public let tags: [TagRef]?
        /// The name to use for the virtual node.
        public let virtualNodeName: String

        @inlinable
        public init(clientToken: String? = CreateVirtualNodeInput.idempotencyToken(), meshName: String, meshOwner: String? = nil, spec: VirtualNodeSpec, tags: [TagRef]? = nil, virtualNodeName: String) {
            self.clientToken = clientToken
            self.meshName = meshName
            self.meshOwner = meshOwner
            self.spec = spec
            self.tags = tags
            self.virtualNodeName = virtualNodeName
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.clientToken, forKey: .clientToken)
            request.encodePath(self.meshName, key: "meshName")
            request.encodeQuery(self.meshOwner, key: "meshOwner")
            try container.encode(self.spec, forKey: .spec)
            try container.encodeIfPresent(self.tags, forKey: .tags)
            try container.encode(self.virtualNodeName, forKey: .virtualNodeName)
        }

        public func validate(name: String) throws {
            try self.validate(self.meshName, name: "meshName", parent: name, max: 255)
            try self.validate(self.meshName, name: "meshName", parent: name, min: 1)
            try self.validate(self.meshOwner, name: "meshOwner", parent: name, max: 12)
            try self.validate(self.meshOwner, name: "meshOwner", parent: name, min: 12)
            try self.spec.validate(name: "\(name).spec")
            try self.tags?.forEach {
                try $0.validate(name: "\(name).tags[]")
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 50)
            try self.validate(self.virtualNodeName, name: "virtualNodeName", parent: name, max: 255)
            try self.validate(self.virtualNodeName, name: "virtualNodeName", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "clientToken"
            case spec = "spec"
            case tags = "tags"
            case virtualNodeName = "virtualNodeName"
        }
    }

    public struct CreateVirtualNodeOutput: AWSDecodableShape {
        /// The full description of your virtual node following the create call.
        public let virtualNode: VirtualNodeData

        @inlinable
        public init(virtualNode: VirtualNodeData) {
            self.virtualNode = virtualNode
        }

        public init(from decoder: Decoder) throws {
            let container = try decoder.singleValueContainer()
            self.virtualNode = try container.decode(VirtualNodeData.self)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct CreateVirtualRouterInput: AWSEncodableShape {
        /// Unique, case-sensitive identifier that you provide to ensure the idempotency of the
        /// request. Up to 36 letters, numbers, hyphens, and underscores are allowed.
        public let clientToken: String?
        /// The name of the service mesh to create the virtual router in.
        public let meshName: String
        /// The Amazon Web Services IAM account ID of the service mesh owner. If the account ID is not your own, then the account that you specify must share the mesh with your account before you can create  the resource in the service mesh. For more information about mesh sharing, see Working with shared meshes.
        public let meshOwner: String?
        /// The virtual router specification to apply.
        public let spec: VirtualRouterSpec
        /// Optional metadata that you can apply to the virtual router to assist with categorization and organization. Each tag consists of a key and an optional value, both of which you define. Tag keys can have a maximum character length of 128 characters, and tag values can have a maximum length of 256 characters.
        public let tags: [TagRef]?
        /// The name to use for the virtual router.
        public let virtualRouterName: String

        @inlinable
        public init(clientToken: String? = CreateVirtualRouterInput.idempotencyToken(), meshName: String, meshOwner: String? = nil, spec: VirtualRouterSpec, tags: [TagRef]? = nil, virtualRouterName: String) {
            self.clientToken = clientToken
            self.meshName = meshName
            self.meshOwner = meshOwner
            self.spec = spec
            self.tags = tags
            self.virtualRouterName = virtualRouterName
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.clientToken, forKey: .clientToken)
            request.encodePath(self.meshName, key: "meshName")
            request.encodeQuery(self.meshOwner, key: "meshOwner")
            try container.encode(self.spec, forKey: .spec)
            try container.encodeIfPresent(self.tags, forKey: .tags)
            try container.encode(self.virtualRouterName, forKey: .virtualRouterName)
        }

        public func validate(name: String) throws {
            try self.validate(self.meshName, name: "meshName", parent: name, max: 255)
            try self.validate(self.meshName, name: "meshName", parent: name, min: 1)
            try self.validate(self.meshOwner, name: "meshOwner", parent: name, max: 12)
            try self.validate(self.meshOwner, name: "meshOwner", parent: name, min: 12)
            try self.spec.validate(name: "\(name).spec")
            try self.tags?.forEach {
                try $0.validate(name: "\(name).tags[]")
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 50)
            try self.validate(self.virtualRouterName, name: "virtualRouterName", parent: name, max: 255)
            try self.validate(self.virtualRouterName, name: "virtualRouterName", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "clientToken"
            case spec = "spec"
            case tags = "tags"
            case virtualRouterName = "virtualRouterName"
        }
    }

    public struct CreateVirtualRouterOutput: AWSDecodableShape {
        /// The full description of your virtual router following the create call.
        public let virtualRouter: VirtualRouterData

        @inlinable
        public init(virtualRouter: VirtualRouterData) {
            self.virtualRouter = virtualRouter
        }

        public init(from decoder: Decoder) throws {
            let container = try decoder.singleValueContainer()
            self.virtualRouter = try container.decode(VirtualRouterData.self)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct CreateVirtualServiceInput: AWSEncodableShape {
        /// Unique, case-sensitive identifier that you provide to ensure the idempotency of the
        /// request. Up to 36 letters, numbers, hyphens, and underscores are allowed.
        public let clientToken: String?
        /// The name of the service mesh to create the virtual service in.
        public let meshName: String
        /// The Amazon Web Services IAM account ID of the service mesh owner. If the account ID is not your own, then the account that you specify must share the mesh with your account before you can create  the resource in the service mesh. For more information about mesh sharing, see Working with shared meshes.
        public let meshOwner: String?
        /// The virtual service specification to apply.
        public let spec: VirtualServiceSpec
        /// Optional metadata that you can apply to the virtual service to assist with categorization and organization. Each tag consists of a key and an optional value, both of which you define. Tag keys can have a maximum character length of 128 characters, and tag values can have a maximum length of 256 characters.
        public let tags: [TagRef]?
        /// The name to use for the virtual service.
        public let virtualServiceName: String

        @inlinable
        public init(clientToken: String? = CreateVirtualServiceInput.idempotencyToken(), meshName: String, meshOwner: String? = nil, spec: VirtualServiceSpec, tags: [TagRef]? = nil, virtualServiceName: String) {
            self.clientToken = clientToken
            self.meshName = meshName
            self.meshOwner = meshOwner
            self.spec = spec
            self.tags = tags
            self.virtualServiceName = virtualServiceName
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.clientToken, forKey: .clientToken)
            request.encodePath(self.meshName, key: "meshName")
            request.encodeQuery(self.meshOwner, key: "meshOwner")
            try container.encode(self.spec, forKey: .spec)
            try container.encodeIfPresent(self.tags, forKey: .tags)
            try container.encode(self.virtualServiceName, forKey: .virtualServiceName)
        }

        public func validate(name: String) throws {
            try self.validate(self.meshName, name: "meshName", parent: name, max: 255)
            try self.validate(self.meshName, name: "meshName", parent: name, min: 1)
            try self.validate(self.meshOwner, name: "meshOwner", parent: name, max: 12)
            try self.validate(self.meshOwner, name: "meshOwner", parent: name, min: 12)
            try self.spec.validate(name: "\(name).spec")
            try self.tags?.forEach {
                try $0.validate(name: "\(name).tags[]")
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 50)
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "clientToken"
            case spec = "spec"
            case tags = "tags"
            case virtualServiceName = "virtualServiceName"
        }
    }

    public struct CreateVirtualServiceOutput: AWSDecodableShape {
        /// The full description of your virtual service following the create call.
        public let virtualService: VirtualServiceData

        @inlinable
        public init(virtualService: VirtualServiceData) {
            self.virtualService = virtualService
        }

        public init(from decoder: Decoder) throws {
            let container = try decoder.singleValueContainer()
            self.virtualService = try container.decode(VirtualServiceData.self)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteGatewayRouteInput: AWSEncodableShape {
        /// The name of the gateway route to delete.
        public let gatewayRouteName: String
        /// The name of the service mesh to delete the gateway route from.
        public let meshName: String
        /// The Amazon Web Services IAM account ID of the service mesh owner. If the account ID is not your own, then it's the ID of the account that shared the mesh with your account. For more information about mesh sharing, see Working with shared meshes.
        public let meshOwner: String?
        /// The name of the virtual gateway to delete the route from.
        public let virtualGatewayName: String

        @inlinable
        public init(gatewayRouteName: String, meshName: String, meshOwner: String? = nil, virtualGatewayName: String) {
            self.gatewayRouteName = gatewayRouteName
            self.meshName = meshName
            self.meshOwner = meshOwner
            self.virtualGatewayName = virtualGatewayName
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.gatewayRouteName, key: "gatewayRouteName")
            request.encodePath(self.meshName, key: "meshName")
            request.encodeQuery(self.meshOwner, key: "meshOwner")
            request.encodePath(self.virtualGatewayName, key: "virtualGatewayName")
        }

        public func validate(name: String) throws {
            try self.validate(self.gatewayRouteName, name: "gatewayRouteName", parent: name, max: 255)
            try self.validate(self.gatewayRouteName, name: "gatewayRouteName", parent: name, min: 1)
            try self.validate(self.meshName, name: "meshName", parent: name, max: 255)
            try self.validate(self.meshName, name: "meshName", parent: name, min: 1)
            try self.validate(self.meshOwner, name: "meshOwner", parent: name, max: 12)
            try self.validate(self.meshOwner, name: "meshOwner", parent: name, min: 12)
            try self.validate(self.virtualGatewayName, name: "virtualGatewayName", parent: name, max: 255)
            try self.validate(self.virtualGatewayName, name: "virtualGatewayName", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteGatewayRouteOutput: AWSDecodableShape {
        /// The gateway route that was deleted.
        public let gatewayRoute: GatewayRouteData

        @inlinable
        public init(gatewayRoute: GatewayRouteData) {
            self.gatewayRoute = gatewayRoute
        }

        public init(from decoder: Decoder) throws {
            let container = try decoder.singleValueContainer()
            self.gatewayRoute = try container.decode(GatewayRouteData.self)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteMeshInput: AWSEncodableShape {
        /// The name of the service mesh to delete.
        public let meshName: String

        @inlinable
        public init(meshName: String) {
            self.meshName = meshName
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.meshName, key: "meshName")
        }

        public func validate(name: String) throws {
            try self.validate(self.meshName, name: "meshName", parent: name, max: 255)
            try self.validate(self.meshName, name: "meshName", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteMeshOutput: AWSDecodableShape {
        /// The service mesh that was deleted.
        public let mesh: MeshData

        @inlinable
        public init(mesh: MeshData) {
            self.mesh = mesh
        }

        public init(from decoder: Decoder) throws {
            let container = try decoder.singleValueContainer()
            self.mesh = try container.decode(MeshData.self)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteRouteInput: AWSEncodableShape {
        /// The name of the service mesh to delete the route in.
        public let meshName: String
        /// The Amazon Web Services IAM account ID of the service mesh owner. If the account ID is not your own, then it's the ID of the account that shared the mesh with your account. For more information about mesh sharing, see Working with shared meshes.
        public let meshOwner: String?
        /// The name of the route to delete.
        public let routeName: String
        /// The name of the virtual router to delete the route in.
        public let virtualRouterName: String

        @inlinable
        public init(meshName: String, meshOwner: String? = nil, routeName: String, virtualRouterName: String) {
            self.meshName = meshName
            self.meshOwner = meshOwner
            self.routeName = routeName
            self.virtualRouterName = virtualRouterName
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.meshName, key: "meshName")
            request.encodeQuery(self.meshOwner, key: "meshOwner")
            request.encodePath(self.routeName, key: "routeName")
            request.encodePath(self.virtualRouterName, key: "virtualRouterName")
        }

        public func validate(name: String) throws {
            try self.validate(self.meshName, name: "meshName", parent: name, max: 255)
            try self.validate(self.meshName, name: "meshName", parent: name, min: 1)
            try self.validate(self.meshOwner, name: "meshOwner", parent: name, max: 12)
            try self.validate(self.meshOwner, name: "meshOwner", parent: name, min: 12)
            try self.validate(self.routeName, name: "routeName", parent: name, max: 255)
            try self.validate(self.routeName, name: "routeName", parent: name, min: 1)
            try self.validate(self.virtualRouterName, name: "virtualRouterName", parent: name, max: 255)
            try self.validate(self.virtualRouterName, name: "virtualRouterName", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteRouteOutput: AWSDecodableShape {
        /// The route that was deleted.
        public let route: RouteData

        @inlinable
        public init(route: RouteData) {
            self.route = route
        }

        public init(from decoder: Decoder) throws {
            let container = try decoder.singleValueContainer()
            self.route = try container.decode(RouteData.self)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteVirtualGatewayInput: AWSEncodableShape {
        /// The name of the service mesh to delete the virtual gateway from.
        public let meshName: String
        /// The Amazon Web Services IAM account ID of the service mesh owner. If the account ID is not your own, then it's the ID of the account that shared the mesh with your account. For more information about mesh sharing, see Working with shared meshes.
        public let meshOwner: String?
        /// The name of the virtual gateway to delete.
        public let virtualGatewayName: String

        @inlinable
        public init(meshName: String, meshOwner: String? = nil, virtualGatewayName: String) {
            self.meshName = meshName
            self.meshOwner = meshOwner
            self.virtualGatewayName = virtualGatewayName
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.meshName, key: "meshName")
            request.encodeQuery(self.meshOwner, key: "meshOwner")
            request.encodePath(self.virtualGatewayName, key: "virtualGatewayName")
        }

        public func validate(name: String) throws {
            try self.validate(self.meshName, name: "meshName", parent: name, max: 255)
            try self.validate(self.meshName, name: "meshName", parent: name, min: 1)
            try self.validate(self.meshOwner, name: "meshOwner", parent: name, max: 12)
            try self.validate(self.meshOwner, name: "meshOwner", parent: name, min: 12)
            try self.validate(self.virtualGatewayName, name: "virtualGatewayName", parent: name, max: 255)
            try self.validate(self.virtualGatewayName, name: "virtualGatewayName", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteVirtualGatewayOutput: AWSDecodableShape {
        /// The virtual gateway that was deleted.
        public let virtualGateway: VirtualGatewayData

        @inlinable
        public init(virtualGateway: VirtualGatewayData) {
            self.virtualGateway = virtualGateway
        }

        public init(from decoder: Decoder) throws {
            let container = try decoder.singleValueContainer()
            self.virtualGateway = try container.decode(VirtualGatewayData.self)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteVirtualNodeInput: AWSEncodableShape {
        /// The name of the service mesh to delete the virtual node in.
        public let meshName: String
        /// The Amazon Web Services IAM account ID of the service mesh owner. If the account ID is not your own, then it's the ID of the account that shared the mesh with your account. For more information about mesh sharing, see Working with shared meshes.
        public let meshOwner: String?
        /// The name of the virtual node to delete.
        public let virtualNodeName: String

        @inlinable
        public init(meshName: String, meshOwner: String? = nil, virtualNodeName: String) {
            self.meshName = meshName
            self.meshOwner = meshOwner
            self.virtualNodeName = virtualNodeName
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.meshName, key: "meshName")
            request.encodeQuery(self.meshOwner, key: "meshOwner")
            request.encodePath(self.virtualNodeName, key: "virtualNodeName")
        }

        public func validate(name: String) throws {
            try self.validate(self.meshName, name: "meshName", parent: name, max: 255)
            try self.validate(self.meshName, name: "meshName", parent: name, min: 1)
            try self.validate(self.meshOwner, name: "meshOwner", parent: name, max: 12)
            try self.validate(self.meshOwner, name: "meshOwner", parent: name, min: 12)
            try self.validate(self.virtualNodeName, name: "virtualNodeName", parent: name, max: 255)
            try self.validate(self.virtualNodeName, name: "virtualNodeName", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteVirtualNodeOutput: AWSDecodableShape {
        /// The virtual node that was deleted.
        public let virtualNode: VirtualNodeData

        @inlinable
        public init(virtualNode: VirtualNodeData) {
            self.virtualNode = virtualNode
        }

        public init(from decoder: Decoder) throws {
            let container = try decoder.singleValueContainer()
            self.virtualNode = try container.decode(VirtualNodeData.self)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteVirtualRouterInput: AWSEncodableShape {
        /// The name of the service mesh to delete the virtual router in.
        public let meshName: String
        /// The Amazon Web Services IAM account ID of the service mesh owner. If the account ID is not your own, then it's the ID of the account that shared the mesh with your account. For more information about mesh sharing, see Working with shared meshes.
        public let meshOwner: String?
        /// The name of the virtual router to delete.
        public let virtualRouterName: String

        @inlinable
        public init(meshName: String, meshOwner: String? = nil, virtualRouterName: String) {
            self.meshName = meshName
            self.meshOwner = meshOwner
            self.virtualRouterName = virtualRouterName
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.meshName, key: "meshName")
            request.encodeQuery(self.meshOwner, key: "meshOwner")
            request.encodePath(self.virtualRouterName, key: "virtualRouterName")
        }

        public func validate(name: String) throws {
            try self.validate(self.meshName, name: "meshName", parent: name, max: 255)
            try self.validate(self.meshName, name: "meshName", parent: name, min: 1)
            try self.validate(self.meshOwner, name: "meshOwner", parent: name, max: 12)
            try self.validate(self.meshOwner, name: "meshOwner", parent: name, min: 12)
            try self.validate(self.virtualRouterName, name: "virtualRouterName", parent: name, max: 255)
            try self.validate(self.virtualRouterName, name: "virtualRouterName", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteVirtualRouterOutput: AWSDecodableShape {
        /// The virtual router that was deleted.
        public let virtualRouter: VirtualRouterData

        @inlinable
        public init(virtualRouter: VirtualRouterData) {
            self.virtualRouter = virtualRouter
        }

        public init(from decoder: Decoder) throws {
            let container = try decoder.singleValueContainer()
            self.virtualRouter = try container.decode(VirtualRouterData.self)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteVirtualServiceInput: AWSEncodableShape {
        /// The name of the service mesh to delete the virtual service in.
        public let meshName: String
        /// The Amazon Web Services IAM account ID of the service mesh owner. If the account ID is not your own, then it's the ID of the account that shared the mesh with your account. For more information about mesh sharing, see Working with shared meshes.
        public let meshOwner: String?
        /// The name of the virtual service to delete.
        public let virtualServiceName: String

        @inlinable
        public init(meshName: String, meshOwner: String? = nil, virtualServiceName: String) {
            self.meshName = meshName
            self.meshOwner = meshOwner
            self.virtualServiceName = virtualServiceName
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.meshName, key: "meshName")
            request.encodeQuery(self.meshOwner, key: "meshOwner")
            request.encodePath(self.virtualServiceName, key: "virtualServiceName")
        }

        public func validate(name: String) throws {
            try self.validate(self.meshName, name: "meshName", parent: name, max: 255)
            try self.validate(self.meshName, name: "meshName", parent: name, min: 1)
            try self.validate(self.meshOwner, name: "meshOwner", parent: name, max: 12)
            try self.validate(self.meshOwner, name: "meshOwner", parent: name, min: 12)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteVirtualServiceOutput: AWSDecodableShape {
        /// The virtual service that was deleted.
        public let virtualService: VirtualServiceData

        @inlinable
        public init(virtualService: VirtualServiceData) {
            self.virtualService = virtualService
        }

        public init(from decoder: Decoder) throws {
            let container = try decoder.singleValueContainer()
            self.virtualService = try container.decode(VirtualServiceData.self)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DescribeGatewayRouteInput: AWSEncodableShape {
        /// The name of the gateway route to describe.
        public let gatewayRouteName: String
        /// The name of the service mesh that the gateway route resides in.
        public let meshName: String
        /// The Amazon Web Services IAM account ID of the service mesh owner. If the account ID is not your own, then it's the ID of the account that shared the mesh with your account. For more information about mesh sharing, see Working with shared meshes.
        public let meshOwner: String?
        /// The name of the virtual gateway that the gateway route is associated with.
        public let virtualGatewayName: String

        @inlinable
        public init(gatewayRouteName: String, meshName: String, meshOwner: String? = nil, virtualGatewayName: String) {
            self.gatewayRouteName = gatewayRouteName
            self.meshName = meshName
            self.meshOwner = meshOwner
            self.virtualGatewayName = virtualGatewayName
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.gatewayRouteName, key: "gatewayRouteName")
            request.encodePath(self.meshName, key: "meshName")
            request.encodeQuery(self.meshOwner, key: "meshOwner")
            request.encodePath(self.virtualGatewayName, key: "virtualGatewayName")
        }

        public func validate(name: String) throws {
            try self.validate(self.gatewayRouteName, name: "gatewayRouteName", parent: name, max: 255)
            try self.validate(self.gatewayRouteName, name: "gatewayRouteName", parent: name, min: 1)
            try self.validate(self.meshName, name: "meshName", parent: name, max: 255)
            try self.validate(self.meshName, name: "meshName", parent: name, min: 1)
            try self.validate(self.meshOwner, name: "meshOwner", parent: name, max: 12)
            try self.validate(self.meshOwner, name: "meshOwner", parent: name, min: 12)
            try self.validate(self.virtualGatewayName, name: "virtualGatewayName", parent: name, max: 255)
            try self.validate(self.virtualGatewayName, name: "virtualGatewayName", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DescribeGatewayRouteOutput: AWSDecodableShape {
        /// The full description of your gateway route.
        public let gatewayRoute: GatewayRouteData

        @inlinable
        public init(gatewayRoute: GatewayRouteData) {
            self.gatewayRoute = gatewayRoute
        }

        public init(from decoder: Decoder) throws {
            let container = try decoder.singleValueContainer()
            self.gatewayRoute = try container.decode(GatewayRouteData.self)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DescribeMeshInput: AWSEncodableShape {
        /// The name of the service mesh to describe.
        public let meshName: String
        /// The Amazon Web Services IAM account ID of the service mesh owner. If the account ID is not your own, then it's the ID of the account that shared the mesh with your account. For more information about mesh sharing, see Working with shared meshes.
        public let meshOwner: String?

        @inlinable
        public init(meshName: String, meshOwner: String? = nil) {
            self.meshName = meshName
            self.meshOwner = meshOwner
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.meshName, key: "meshName")
            request.encodeQuery(self.meshOwner, key: "meshOwner")
        }

        public func validate(name: String) throws {
            try self.validate(self.meshName, name: "meshName", parent: name, max: 255)
            try self.validate(self.meshName, name: "meshName", parent: name, min: 1)
            try self.validate(self.meshOwner, name: "meshOwner", parent: name, max: 12)
            try self.validate(self.meshOwner, name: "meshOwner", parent: name, min: 12)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DescribeMeshOutput: AWSDecodableShape {
        /// The full description of your service mesh.
        public let mesh: MeshData

        @inlinable
        public init(mesh: MeshData) {
            self.mesh = mesh
        }

        public init(from decoder: Decoder) throws {
            let container = try decoder.singleValueContainer()
            self.mesh = try container.decode(MeshData.self)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DescribeRouteInput: AWSEncodableShape {
        /// The name of the service mesh that the route resides in.
        public let meshName: String
        /// The Amazon Web Services IAM account ID of the service mesh owner. If the account ID is not your own, then it's the ID of the account that shared the mesh with your account. For more information about mesh sharing, see Working with shared meshes.
        public let meshOwner: String?
        /// The name of the route to describe.
        public let routeName: String
        /// The name of the virtual router that the route is associated with.
        public let virtualRouterName: String

        @inlinable
        public init(meshName: String, meshOwner: String? = nil, routeName: String, virtualRouterName: String) {
            self.meshName = meshName
            self.meshOwner = meshOwner
            self.routeName = routeName
            self.virtualRouterName = virtualRouterName
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.meshName, key: "meshName")
            request.encodeQuery(self.meshOwner, key: "meshOwner")
            request.encodePath(self.routeName, key: "routeName")
            request.encodePath(self.virtualRouterName, key: "virtualRouterName")
        }

        public func validate(name: String) throws {
            try self.validate(self.meshName, name: "meshName", parent: name, max: 255)
            try self.validate(self.meshName, name: "meshName", parent: name, min: 1)
            try self.validate(self.meshOwner, name: "meshOwner", parent: name, max: 12)
            try self.validate(self.meshOwner, name: "meshOwner", parent: name, min: 12)
            try self.validate(self.routeName, name: "routeName", parent: name, max: 255)
            try self.validate(self.routeName, name: "routeName", parent: name, min: 1)
            try self.validate(self.virtualRouterName, name: "virtualRouterName", parent: name, max: 255)
            try self.validate(self.virtualRouterName, name: "virtualRouterName", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DescribeRouteOutput: AWSDecodableShape {
        /// The full description of your route.
        public let route: RouteData

        @inlinable
        public init(route: RouteData) {
            self.route = route
        }

        public init(from decoder: Decoder) throws {
            let container = try decoder.singleValueContainer()
            self.route = try container.decode(RouteData.self)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DescribeVirtualGatewayInput: AWSEncodableShape {
        /// The name of the service mesh that the gateway route resides in.
        public let meshName: String
        /// The Amazon Web Services IAM account ID of the service mesh owner. If the account ID is not your own, then it's the ID of the account that shared the mesh with your account. For more information about mesh sharing, see Working with shared meshes.
        public let meshOwner: String?
        /// The name of the virtual gateway to describe.
        public let virtualGatewayName: String

        @inlinable
        public init(meshName: String, meshOwner: String? = nil, virtualGatewayName: String) {
            self.meshName = meshName
            self.meshOwner = meshOwner
            self.virtualGatewayName = virtualGatewayName
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.meshName, key: "meshName")
            request.encodeQuery(self.meshOwner, key: "meshOwner")
            request.encodePath(self.virtualGatewayName, key: "virtualGatewayName")
        }

        public func validate(name: String) throws {
            try self.validate(self.meshName, name: "meshName", parent: name, max: 255)
            try self.validate(self.meshName, name: "meshName", parent: name, min: 1)
            try self.validate(self.meshOwner, name: "meshOwner", parent: name, max: 12)
            try self.validate(self.meshOwner, name: "meshOwner", parent: name, min: 12)
            try self.validate(self.virtualGatewayName, name: "virtualGatewayName", parent: name, max: 255)
            try self.validate(self.virtualGatewayName, name: "virtualGatewayName", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DescribeVirtualGatewayOutput: AWSDecodableShape {
        /// The full description of your virtual gateway.
        public let virtualGateway: VirtualGatewayData

        @inlinable
        public init(virtualGateway: VirtualGatewayData) {
            self.virtualGateway = virtualGateway
        }

        public init(from decoder: Decoder) throws {
            let container = try decoder.singleValueContainer()
            self.virtualGateway = try container.decode(VirtualGatewayData.self)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DescribeVirtualNodeInput: AWSEncodableShape {
        /// The name of the service mesh that the virtual node resides in.
        public let meshName: String
        /// The Amazon Web Services IAM account ID of the service mesh owner. If the account ID is not your own, then it's the ID of the account that shared the mesh with your account. For more information about mesh sharing, see Working with shared meshes.
        public let meshOwner: String?
        /// The name of the virtual node to describe.
        public let virtualNodeName: String

        @inlinable
        public init(meshName: String, meshOwner: String? = nil, virtualNodeName: String) {
            self.meshName = meshName
            self.meshOwner = meshOwner
            self.virtualNodeName = virtualNodeName
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.meshName, key: "meshName")
            request.encodeQuery(self.meshOwner, key: "meshOwner")
            request.encodePath(self.virtualNodeName, key: "virtualNodeName")
        }

        public func validate(name: String) throws {
            try self.validate(self.meshName, name: "meshName", parent: name, max: 255)
            try self.validate(self.meshName, name: "meshName", parent: name, min: 1)
            try self.validate(self.meshOwner, name: "meshOwner", parent: name, max: 12)
            try self.validate(self.meshOwner, name: "meshOwner", parent: name, min: 12)
            try self.validate(self.virtualNodeName, name: "virtualNodeName", parent: name, max: 255)
            try self.validate(self.virtualNodeName, name: "virtualNodeName", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DescribeVirtualNodeOutput: AWSDecodableShape {
        /// The full description of your virtual node.
        public let virtualNode: VirtualNodeData

        @inlinable
        public init(virtualNode: VirtualNodeData) {
            self.virtualNode = virtualNode
        }

        public init(from decoder: Decoder) throws {
            let container = try decoder.singleValueContainer()
            self.virtualNode = try container.decode(VirtualNodeData.self)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DescribeVirtualRouterInput: AWSEncodableShape {
        /// The name of the service mesh that the virtual router resides in.
        public let meshName: String
        /// The Amazon Web Services IAM account ID of the service mesh owner. If the account ID is not your own, then it's the ID of the account that shared the mesh with your account. For more information about mesh sharing, see Working with shared meshes.
        public let meshOwner: String?
        /// The name of the virtual router to describe.
        public let virtualRouterName: String

        @inlinable
        public init(meshName: String, meshOwner: String? = nil, virtualRouterName: String) {
            self.meshName = meshName
            self.meshOwner = meshOwner
            self.virtualRouterName = virtualRouterName
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.meshName, key: "meshName")
            request.encodeQuery(self.meshOwner, key: "meshOwner")
            request.encodePath(self.virtualRouterName, key: "virtualRouterName")
        }

        public func validate(name: String) throws {
            try self.validate(self.meshName, name: "meshName", parent: name, max: 255)
            try self.validate(self.meshName, name: "meshName", parent: name, min: 1)
            try self.validate(self.meshOwner, name: "meshOwner", parent: name, max: 12)
            try self.validate(self.meshOwner, name: "meshOwner", parent: name, min: 12)
            try self.validate(self.virtualRouterName, name: "virtualRouterName", parent: name, max: 255)
            try self.validate(self.virtualRouterName, name: "virtualRouterName", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DescribeVirtualRouterOutput: AWSDecodableShape {
        /// The full description of your virtual router.
        public let virtualRouter: VirtualRouterData

        @inlinable
        public init(virtualRouter: VirtualRouterData) {
            self.virtualRouter = virtualRouter
        }

        public init(from decoder: Decoder) throws {
            let container = try decoder.singleValueContainer()
            self.virtualRouter = try container.decode(VirtualRouterData.self)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DescribeVirtualServiceInput: AWSEncodableShape {
        /// The name of the service mesh that the virtual service resides in.
        public let meshName: String
        /// The Amazon Web Services IAM account ID of the service mesh owner. If the account ID is not your own, then it's the ID of the account that shared the mesh with your account. For more information about mesh sharing, see Working with shared meshes.
        public let meshOwner: String?
        /// The name of the virtual service to describe.
        public let virtualServiceName: String

        @inlinable
        public init(meshName: String, meshOwner: String? = nil, virtualServiceName: String) {
            self.meshName = meshName
            self.meshOwner = meshOwner
            self.virtualServiceName = virtualServiceName
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.meshName, key: "meshName")
            request.encodeQuery(self.meshOwner, key: "meshOwner")
            request.encodePath(self.virtualServiceName, key: "virtualServiceName")
        }

        public func validate(name: String) throws {
            try self.validate(self.meshName, name: "meshName", parent: name, max: 255)
            try self.validate(self.meshName, name: "meshName", parent: name, min: 1)
            try self.validate(self.meshOwner, name: "meshOwner", parent: name, max: 12)
            try self.validate(self.meshOwner, name: "meshOwner", parent: name, min: 12)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DescribeVirtualServiceOutput: AWSDecodableShape {
        /// The full description of your virtual service.
        public let virtualService: VirtualServiceData

        @inlinable
        public init(virtualService: VirtualServiceData) {
            self.virtualService = virtualService
        }

        public init(from decoder: Decoder) throws {
            let container = try decoder.singleValueContainer()
            self.virtualService = try container.decode(VirtualServiceData.self)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DnsServiceDiscovery: AWSEncodableShape & AWSDecodableShape {
        /// Specifies the DNS service discovery hostname for the virtual node.
        public let hostname: String
        /// The preferred IP version that this virtual node uses. Setting the IP preference on the virtual node only overrides the IP preference set for the mesh on this specific node.
        public let ipPreference: IpPreference?
        /// Specifies the DNS response type for the virtual node.
        public let responseType: DnsResponseType?

        @inlinable
        public init(hostname: String, ipPreference: IpPreference? = nil, responseType: DnsResponseType? = nil) {
            self.hostname = hostname
            self.ipPreference = ipPreference
            self.responseType = responseType
        }

        private enum CodingKeys: String, CodingKey {
            case hostname = "hostname"
            case ipPreference = "ipPreference"
            case responseType = "responseType"
        }
    }

    public struct Duration: AWSEncodableShape & AWSDecodableShape {
        /// A unit of time.
        public let unit: DurationUnit?
        /// A number of time units.
        public let value: Int64?

        @inlinable
        public init(unit: DurationUnit? = nil, value: Int64? = nil) {
            self.unit = unit
            self.value = value
        }

        public func validate(name: String) throws {
            try self.validate(self.value, name: "value", parent: name, min: 0)
        }

        private enum CodingKeys: String, CodingKey {
            case unit = "unit"
            case value = "value"
        }
    }

    public struct EgressFilter: AWSEncodableShape & AWSDecodableShape {
        /// The egress filter type. By default, the type is DROP_ALL, which allows egress only from virtual nodes to other defined resources in the service mesh (and any traffic to *.amazonaws.com for Amazon Web Services API calls). You can set the egress filter type to ALLOW_ALL to allow egress to any endpoint inside or outside of the service mesh.
        public let type: EgressFilterType

        @inlinable
        public init(type: EgressFilterType) {
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case type = "type"
        }
    }

    public struct FileAccessLog: AWSEncodableShape & AWSDecodableShape {
        /// The specified format for the logs. The format is either json_format or text_format.
        public let format: LoggingFormat?
        /// The file path to write access logs to. You can use /dev/stdout to send access logs to standard out and configure your Envoy container to use a log driver, such as awslogs, to export the access logs to a log storage service such as Amazon CloudWatch Logs. You can also specify a path in the Envoy container's file system to write the files to disk.  The Envoy process must have write permissions to the path that you specify here. Otherwise, Envoy fails to bootstrap properly.
        public let path: String

        @inlinable
        public init(format: LoggingFormat? = nil, path: String) {
            self.format = format
            self.path = path
        }

        public func validate(name: String) throws {
            try self.format?.validate(name: "\(name).format")
            try self.validate(self.path, name: "path", parent: name, max: 255)
            try self.validate(self.path, name: "path", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case format = "format"
            case path = "path"
        }
    }

    public struct GatewayRouteData: AWSDecodableShape {
        /// The name of the gateway route.
        public let gatewayRouteName: String
        /// The name of the service mesh that the resource resides in.
        public let meshName: String
        public let metadata: ResourceMetadata
        /// The specifications of the gateway route.
        public let spec: GatewayRouteSpec
        /// The status of the gateway route.
        public let status: GatewayRouteStatus
        /// The virtual gateway that the gateway route is associated with.
        public let virtualGatewayName: String

        @inlinable
        public init(gatewayRouteName: String, meshName: String, metadata: ResourceMetadata, spec: GatewayRouteSpec, status: GatewayRouteStatus, virtualGatewayName: String) {
            self.gatewayRouteName = gatewayRouteName
            self.meshName = meshName
            self.metadata = metadata
            self.spec = spec
            self.status = status
            self.virtualGatewayName = virtualGatewayName
        }

        private enum CodingKeys: String, CodingKey {
            case gatewayRouteName = "gatewayRouteName"
            case meshName = "meshName"
            case metadata = "metadata"
            case spec = "spec"
            case status = "status"
            case virtualGatewayName = "virtualGatewayName"
        }
    }

    public struct GatewayRouteHostnameMatch: AWSEncodableShape & AWSDecodableShape {
        /// The exact host name to match on.
        public let exact: String?
        /// The specified ending characters of the host name to match on.
        public let suffix: String?

        @inlinable
        public init(exact: String? = nil, suffix: String? = nil) {
            self.exact = exact
            self.suffix = suffix
        }

        public func validate(name: String) throws {
            try self.validate(self.exact, name: "exact", parent: name, max: 253)
            try self.validate(self.exact, name: "exact", parent: name, min: 1)
            try self.validate(self.suffix, name: "suffix", parent: name, max: 253)
            try self.validate(self.suffix, name: "suffix", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case exact = "exact"
            case suffix = "suffix"
        }
    }

    public struct GatewayRouteHostnameRewrite: AWSEncodableShape & AWSDecodableShape {
        /// The default target host name to write to.
        public let defaultTargetHostname: DefaultGatewayRouteRewrite?

        @inlinable
        public init(defaultTargetHostname: DefaultGatewayRouteRewrite? = nil) {
            self.defaultTargetHostname = defaultTargetHostname
        }

        private enum CodingKeys: String, CodingKey {
            case defaultTargetHostname = "defaultTargetHostname"
        }
    }

    public struct GatewayRouteRef: AWSDecodableShape {
        /// The full Amazon Resource Name (ARN) for the gateway route.
        public let arn: String
        /// The Unix epoch timestamp in seconds for when the resource was created.
        public let createdAt: Date
        /// The name of the gateway route.
        public let gatewayRouteName: String
        /// The Unix epoch timestamp in seconds for when the resource was last updated.
        public let lastUpdatedAt: Date
        /// The name of the service mesh that the resource resides in.
        public let meshName: String
        /// The Amazon Web Services IAM account ID of the service mesh owner. If the account ID is not your own, then it's the ID of the account that shared the mesh with your account. For more information about mesh sharing, see Working with shared meshes.
        public let meshOwner: String
        /// The Amazon Web Services IAM account ID of the resource owner. If the account ID is not your own, then it's the ID of the mesh owner or of another account that the mesh is shared with. For more information about mesh sharing, see Working with shared meshes.
        public let resourceOwner: String
        /// The version of the resource. Resources are created at version 1, and this version is incremented each time that they're updated.
        public let version: Int64
        /// The virtual gateway that the gateway route is associated with.
        public let virtualGatewayName: String

        @inlinable
        public init(arn: String, createdAt: Date, gatewayRouteName: String, lastUpdatedAt: Date, meshName: String, meshOwner: String, resourceOwner: String, version: Int64, virtualGatewayName: String) {
            self.arn = arn
            self.createdAt = createdAt
            self.gatewayRouteName = gatewayRouteName
            self.lastUpdatedAt = lastUpdatedAt
            self.meshName = meshName
            self.meshOwner = meshOwner
            self.resourceOwner = resourceOwner
            self.version = version
            self.virtualGatewayName = virtualGatewayName
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case createdAt = "createdAt"
            case gatewayRouteName = "gatewayRouteName"
            case lastUpdatedAt = "lastUpdatedAt"
            case meshName = "meshName"
            case meshOwner = "meshOwner"
            case resourceOwner = "resourceOwner"
            case version = "version"
            case virtualGatewayName = "virtualGatewayName"
        }
    }

    public struct GatewayRouteSpec: AWSEncodableShape & AWSDecodableShape {
        /// An object that represents the specification of a gRPC gateway route.
        public let grpcRoute: GrpcGatewayRoute?
        /// An object that represents the specification of an HTTP/2 gateway route.
        public let http2Route: HttpGatewayRoute?
        /// An object that represents the specification of an HTTP gateway route.
        public let httpRoute: HttpGatewayRoute?
        /// The ordering of the gateway routes spec.
        public let priority: Int?

        @inlinable
        public init(grpcRoute: GrpcGatewayRoute? = nil, http2Route: HttpGatewayRoute? = nil, httpRoute: HttpGatewayRoute? = nil, priority: Int? = nil) {
            self.grpcRoute = grpcRoute
            self.http2Route = http2Route
            self.httpRoute = httpRoute
            self.priority = priority
        }

        public func validate(name: String) throws {
            try self.grpcRoute?.validate(name: "\(name).grpcRoute")
            try self.http2Route?.validate(name: "\(name).http2Route")
            try self.httpRoute?.validate(name: "\(name).httpRoute")
            try self.validate(self.priority, name: "priority", parent: name, max: 1000)
            try self.validate(self.priority, name: "priority", parent: name, min: 0)
        }

        private enum CodingKeys: String, CodingKey {
            case grpcRoute = "grpcRoute"
            case http2Route = "http2Route"
            case httpRoute = "httpRoute"
            case priority = "priority"
        }
    }

    public struct GatewayRouteStatus: AWSDecodableShape {
        /// The current status for the gateway route.
        public let status: GatewayRouteStatusCode

        @inlinable
        public init(status: GatewayRouteStatusCode) {
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case status = "status"
        }
    }

    public struct GatewayRouteTarget: AWSEncodableShape & AWSDecodableShape {
        /// The port number of the gateway route target.
        public let port: Int?
        /// An object that represents a virtual service gateway route target.
        public let virtualService: GatewayRouteVirtualService

        @inlinable
        public init(port: Int? = nil, virtualService: GatewayRouteVirtualService) {
            self.port = port
            self.virtualService = virtualService
        }

        public func validate(name: String) throws {
            try self.validate(self.port, name: "port", parent: name, max: 65535)
            try self.validate(self.port, name: "port", parent: name, min: 1)
            try self.virtualService.validate(name: "\(name).virtualService")
        }

        private enum CodingKeys: String, CodingKey {
            case port = "port"
            case virtualService = "virtualService"
        }
    }

    public struct GatewayRouteVirtualService: AWSEncodableShape & AWSDecodableShape {
        /// The name of the virtual service that traffic is routed to.
        public let virtualServiceName: String

        @inlinable
        public init(virtualServiceName: String) {
            self.virtualServiceName = virtualServiceName
        }

        public func validate(name: String) throws {
            try self.validate(self.virtualServiceName, name: "virtualServiceName", parent: name, max: 255)
            try self.validate(self.virtualServiceName, name: "virtualServiceName", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case virtualServiceName = "virtualServiceName"
        }
    }

    public struct GrpcGatewayRoute: AWSEncodableShape & AWSDecodableShape {
        /// An object that represents the action to take if a match is determined.
        public let action: GrpcGatewayRouteAction
        /// An object that represents the criteria for determining a request match.
        public let match: GrpcGatewayRouteMatch

        @inlinable
        public init(action: GrpcGatewayRouteAction, match: GrpcGatewayRouteMatch) {
            self.action = action
            self.match = match
        }

        public func validate(name: String) throws {
            try self.action.validate(name: "\(name).action")
            try self.match.validate(name: "\(name).match")
        }

        private enum CodingKeys: String, CodingKey {
            case action = "action"
            case match = "match"
        }
    }

    public struct GrpcGatewayRouteAction: AWSEncodableShape & AWSDecodableShape {
        /// The gateway route action to rewrite.
        public let rewrite: GrpcGatewayRouteRewrite?
        /// An object that represents the target that traffic is routed to when a request matches the gateway route.
        public let target: GatewayRouteTarget

        @inlinable
        public init(rewrite: GrpcGatewayRouteRewrite? = nil, target: GatewayRouteTarget) {
            self.rewrite = rewrite
            self.target = target
        }

        public func validate(name: String) throws {
            try self.target.validate(name: "\(name).target")
        }

        private enum CodingKeys: String, CodingKey {
            case rewrite = "rewrite"
            case target = "target"
        }
    }

    public struct GrpcGatewayRouteMatch: AWSEncodableShape & AWSDecodableShape {
        /// The gateway route host name to be matched on.
        public let hostname: GatewayRouteHostnameMatch?
        /// The gateway route metadata to be matched on.
        public let metadata: [GrpcGatewayRouteMetadata]?
        /// The gateway route port to be matched on.
        public let port: Int?
        /// The fully qualified domain name for the service to match from the request.
        public let serviceName: String?

        @inlinable
        public init(hostname: GatewayRouteHostnameMatch? = nil, metadata: [GrpcGatewayRouteMetadata]? = nil, port: Int? = nil, serviceName: String? = nil) {
            self.hostname = hostname
            self.metadata = metadata
            self.port = port
            self.serviceName = serviceName
        }

        public func validate(name: String) throws {
            try self.hostname?.validate(name: "\(name).hostname")
            try self.metadata?.forEach {
                try $0.validate(name: "\(name).metadata[]")
            }
            try self.validate(self.metadata, name: "metadata", parent: name, max: 10)
            try self.validate(self.metadata, name: "metadata", parent: name, min: 1)
            try self.validate(self.port, name: "port", parent: name, max: 65535)
            try self.validate(self.port, name: "port", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case hostname = "hostname"
            case metadata = "metadata"
            case port = "port"
            case serviceName = "serviceName"
        }
    }

    public struct GrpcGatewayRouteMetadata: AWSEncodableShape & AWSDecodableShape {
        /// Specify True to match anything except the match criteria. The default value is False.
        public let invert: Bool?
        /// The criteria for determining a metadata match.
        public let match: GrpcMetadataMatchMethod?
        /// A name for the gateway route metadata.
        public let name: String

        @inlinable
        public init(invert: Bool? = nil, match: GrpcMetadataMatchMethod? = nil, name: String) {
            self.invert = invert
            self.match = match
            self.name = name
        }

        public func validate(name: String) throws {
            try self.match?.validate(name: "\(name).match")
            try self.validate(self.name, name: "name", parent: name, max: 50)
            try self.validate(self.name, name: "name", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case invert = "invert"
            case match = "match"
            case name = "name"
        }
    }

    public struct GrpcGatewayRouteRewrite: AWSEncodableShape & AWSDecodableShape {
        /// The host name of the gateway route to rewrite.
        public let hostname: GatewayRouteHostnameRewrite?

        @inlinable
        public init(hostname: GatewayRouteHostnameRewrite? = nil) {
            self.hostname = hostname
        }

        private enum CodingKeys: String, CodingKey {
            case hostname = "hostname"
        }
    }

    public struct GrpcRetryPolicy: AWSEncodableShape & AWSDecodableShape {
        /// Specify at least one of the valid values.
        public let grpcRetryEvents: [GrpcRetryPolicyEvent]?
        /// Specify at least one of the following values.    server-error  HTTP status codes 500, 501, 502, 503, 504, 505, 506, 507, 508, 510, and 511    gateway-error  HTTP status codes 502, 503, and 504    client-error  HTTP status code 409    stream-error  Retry on refused stream
        public let httpRetryEvents: [String]?
        /// The maximum number of retry attempts.
        public let maxRetries: Int64
        /// The timeout for each retry attempt.
        public let perRetryTimeout: Duration
        /// Specify a valid value. The event occurs before any processing of a request has started and is encountered when the upstream is temporarily or permanently unavailable.
        public let tcpRetryEvents: [TcpRetryPolicyEvent]?

        @inlinable
        public init(grpcRetryEvents: [GrpcRetryPolicyEvent]? = nil, httpRetryEvents: [String]? = nil, maxRetries: Int64, perRetryTimeout: Duration, tcpRetryEvents: [TcpRetryPolicyEvent]? = nil) {
            self.grpcRetryEvents = grpcRetryEvents
            self.httpRetryEvents = httpRetryEvents
            self.maxRetries = maxRetries
            self.perRetryTimeout = perRetryTimeout
            self.tcpRetryEvents = tcpRetryEvents
        }

        public func validate(name: String) throws {
            try self.validate(self.grpcRetryEvents, name: "grpcRetryEvents", parent: name, max: 5)
            try self.validate(self.grpcRetryEvents, name: "grpcRetryEvents", parent: name, min: 1)
            try self.httpRetryEvents?.forEach {
                try validate($0, name: "httpRetryEvents[]", parent: name, max: 25)
                try validate($0, name: "httpRetryEvents[]", parent: name, min: 1)
            }
            try self.validate(self.httpRetryEvents, name: "httpRetryEvents", parent: name, max: 25)
            try self.validate(self.httpRetryEvents, name: "httpRetryEvents", parent: name, min: 1)
            try self.validate(self.maxRetries, name: "maxRetries", parent: name, min: 0)
            try self.perRetryTimeout.validate(name: "\(name).perRetryTimeout")
            try self.validate(self.tcpRetryEvents, name: "tcpRetryEvents", parent: name, max: 1)
            try self.validate(self.tcpRetryEvents, name: "tcpRetryEvents", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case grpcRetryEvents = "grpcRetryEvents"
            case httpRetryEvents = "httpRetryEvents"
            case maxRetries = "maxRetries"
            case perRetryTimeout = "perRetryTimeout"
            case tcpRetryEvents = "tcpRetryEvents"
        }
    }

    public struct GrpcRoute: AWSEncodableShape & AWSDecodableShape {
        /// An object that represents the action to take if a match is determined.
        public let action: GrpcRouteAction
        /// An object that represents the criteria for determining a request match.
        public let match: GrpcRouteMatch
        /// An object that represents a retry policy.
        public let retryPolicy: GrpcRetryPolicy?
        /// An object that represents types of timeouts.
        public let timeout: GrpcTimeout?

        @inlinable
        public init(action: GrpcRouteAction, match: GrpcRouteMatch, retryPolicy: GrpcRetryPolicy? = nil, timeout: GrpcTimeout? = nil) {
            self.action = action
            self.match = match
            self.retryPolicy = retryPolicy
            self.timeout = timeout
        }

        public func validate(name: String) throws {
            try self.action.validate(name: "\(name).action")
            try self.match.validate(name: "\(name).match")
            try self.retryPolicy?.validate(name: "\(name).retryPolicy")
            try self.timeout?.validate(name: "\(name).timeout")
        }

        private enum CodingKeys: String, CodingKey {
            case action = "action"
            case match = "match"
            case retryPolicy = "retryPolicy"
            case timeout = "timeout"
        }
    }

    public struct GrpcRouteAction: AWSEncodableShape & AWSDecodableShape {
        /// An object that represents the targets that traffic is routed to when a request matches the route.
        public let weightedTargets: [WeightedTarget]

        @inlinable
        public init(weightedTargets: [WeightedTarget]) {
            self.weightedTargets = weightedTargets
        }

        public func validate(name: String) throws {
            try self.weightedTargets.forEach {
                try $0.validate(name: "\(name).weightedTargets[]")
            }
            try self.validate(self.weightedTargets, name: "weightedTargets", parent: name, max: 10)
            try self.validate(self.weightedTargets, name: "weightedTargets", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case weightedTargets = "weightedTargets"
        }
    }

    public struct GrpcRouteMatch: AWSEncodableShape & AWSDecodableShape {
        /// An object that represents the data to match from the request.
        public let metadata: [GrpcRouteMetadata]?
        /// The method name to match from the request. If you specify a name, you must also specify a serviceName.
        public let methodName: String?
        /// The port number to match on.
        public let port: Int?
        /// The fully qualified domain name for the service to match from the request.
        public let serviceName: String?

        @inlinable
        public init(metadata: [GrpcRouteMetadata]? = nil, methodName: String? = nil, port: Int? = nil, serviceName: String? = nil) {
            self.metadata = metadata
            self.methodName = methodName
            self.port = port
            self.serviceName = serviceName
        }

        public func validate(name: String) throws {
            try self.metadata?.forEach {
                try $0.validate(name: "\(name).metadata[]")
            }
            try self.validate(self.metadata, name: "metadata", parent: name, max: 10)
            try self.validate(self.metadata, name: "metadata", parent: name, min: 1)
            try self.validate(self.methodName, name: "methodName", parent: name, max: 50)
            try self.validate(self.methodName, name: "methodName", parent: name, min: 1)
            try self.validate(self.port, name: "port", parent: name, max: 65535)
            try self.validate(self.port, name: "port", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case metadata = "metadata"
            case methodName = "methodName"
            case port = "port"
            case serviceName = "serviceName"
        }
    }

    public struct GrpcRouteMetadata: AWSEncodableShape & AWSDecodableShape {
        /// Specify True to match anything except the match criteria. The default value is False.
        public let invert: Bool?
        /// An object that represents the data to match from the request.
        public let match: GrpcRouteMetadataMatchMethod?
        /// The name of the route.
        public let name: String

        @inlinable
        public init(invert: Bool? = nil, match: GrpcRouteMetadataMatchMethod? = nil, name: String) {
            self.invert = invert
            self.match = match
            self.name = name
        }

        public func validate(name: String) throws {
            try self.match?.validate(name: "\(name).match")
            try self.validate(self.name, name: "name", parent: name, max: 50)
            try self.validate(self.name, name: "name", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case invert = "invert"
            case match = "match"
            case name = "name"
        }
    }

    public struct GrpcTimeout: AWSEncodableShape & AWSDecodableShape {
        /// An object that represents an idle timeout. An idle timeout bounds the amount of time that a connection may be idle. The default value is none.
        public let idle: Duration?
        /// An object that represents a per request timeout. The default value is 15 seconds. If you set a higher timeout, then make sure that the higher value is set for each App Mesh  resource in a conversation. For example, if a virtual node backend uses a virtual router provider to route to another virtual node, then the timeout should be greater than 15 seconds for the source and destination virtual node and the route.
        public let perRequest: Duration?

        @inlinable
        public init(idle: Duration? = nil, perRequest: Duration? = nil) {
            self.idle = idle
            self.perRequest = perRequest
        }

        public func validate(name: String) throws {
            try self.idle?.validate(name: "\(name).idle")
            try self.perRequest?.validate(name: "\(name).perRequest")
        }

        private enum CodingKeys: String, CodingKey {
            case idle = "idle"
            case perRequest = "perRequest"
        }
    }

    public struct HealthCheckPolicy: AWSEncodableShape & AWSDecodableShape {
        /// The number of consecutive successful health checks that must occur before declaring listener healthy.
        public let healthyThreshold: Int
        /// The time period in milliseconds between each health check execution.
        public let intervalMillis: Int64
        /// The destination path for the health check request. This value is only used if the specified protocol is HTTP or HTTP/2. For any other protocol, this value is ignored.
        public let path: String?
        /// The destination port for the health check request. This port must match the port defined in the PortMapping for the listener.
        public let port: Int?
        /// The protocol for the health check request. If you specify grpc, then your service must conform to the GRPC Health Checking Protocol.
        public let `protocol`: PortProtocol
        /// The amount of time to wait when receiving a response from the health check, in milliseconds.
        public let timeoutMillis: Int64
        /// The number of consecutive failed health checks that must occur before declaring a virtual node unhealthy.
        public let unhealthyThreshold: Int

        @inlinable
        public init(healthyThreshold: Int, intervalMillis: Int64, path: String? = nil, port: Int? = nil, protocol: PortProtocol, timeoutMillis: Int64, unhealthyThreshold: Int) {
            self.healthyThreshold = healthyThreshold
            self.intervalMillis = intervalMillis
            self.path = path
            self.port = port
            self.`protocol` = `protocol`
            self.timeoutMillis = timeoutMillis
            self.unhealthyThreshold = unhealthyThreshold
        }

        public func validate(name: String) throws {
            try self.validate(self.healthyThreshold, name: "healthyThreshold", parent: name, max: 10)
            try self.validate(self.healthyThreshold, name: "healthyThreshold", parent: name, min: 2)
            try self.validate(self.intervalMillis, name: "intervalMillis", parent: name, max: 300000)
            try self.validate(self.intervalMillis, name: "intervalMillis", parent: name, min: 5000)
            try self.validate(self.port, name: "port", parent: name, max: 65535)
            try self.validate(self.port, name: "port", parent: name, min: 1)
            try self.validate(self.timeoutMillis, name: "timeoutMillis", parent: name, max: 60000)
            try self.validate(self.timeoutMillis, name: "timeoutMillis", parent: name, min: 2000)
            try self.validate(self.unhealthyThreshold, name: "unhealthyThreshold", parent: name, max: 10)
            try self.validate(self.unhealthyThreshold, name: "unhealthyThreshold", parent: name, min: 2)
        }

        private enum CodingKeys: String, CodingKey {
            case healthyThreshold = "healthyThreshold"
            case intervalMillis = "intervalMillis"
            case path = "path"
            case port = "port"
            case `protocol` = "protocol"
            case timeoutMillis = "timeoutMillis"
            case unhealthyThreshold = "unhealthyThreshold"
        }
    }

    public struct HttpGatewayRoute: AWSEncodableShape & AWSDecodableShape {
        /// An object that represents the action to take if a match is determined.
        public let action: HttpGatewayRouteAction
        /// An object that represents the criteria for determining a request match.
        public let match: HttpGatewayRouteMatch

        @inlinable
        public init(action: HttpGatewayRouteAction, match: HttpGatewayRouteMatch) {
            self.action = action
            self.match = match
        }

        public func validate(name: String) throws {
            try self.action.validate(name: "\(name).action")
            try self.match.validate(name: "\(name).match")
        }

        private enum CodingKeys: String, CodingKey {
            case action = "action"
            case match = "match"
        }
    }

    public struct HttpGatewayRouteAction: AWSEncodableShape & AWSDecodableShape {
        /// The gateway route action to rewrite.
        public let rewrite: HttpGatewayRouteRewrite?
        /// An object that represents the target that traffic is routed to when a request matches the gateway route.
        public let target: GatewayRouteTarget

        @inlinable
        public init(rewrite: HttpGatewayRouteRewrite? = nil, target: GatewayRouteTarget) {
            self.rewrite = rewrite
            self.target = target
        }

        public func validate(name: String) throws {
            try self.rewrite?.validate(name: "\(name).rewrite")
            try self.target.validate(name: "\(name).target")
        }

        private enum CodingKeys: String, CodingKey {
            case rewrite = "rewrite"
            case target = "target"
        }
    }

    public struct HttpGatewayRouteHeader: AWSEncodableShape & AWSDecodableShape {
        /// Specify True to match anything except the match criteria. The default value is False.
        public let invert: Bool?
        /// An object that represents the method and value to match with the header value sent in a request. Specify one match method.
        public let match: HeaderMatchMethod?
        /// A name for the HTTP header in the gateway route that will be matched on.
        public let name: String

        @inlinable
        public init(invert: Bool? = nil, match: HeaderMatchMethod? = nil, name: String) {
            self.invert = invert
            self.match = match
            self.name = name
        }

        public func validate(name: String) throws {
            try self.match?.validate(name: "\(name).match")
            try self.validate(self.name, name: "name", parent: name, max: 50)
            try self.validate(self.name, name: "name", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case invert = "invert"
            case match = "match"
            case name = "name"
        }
    }

    public struct HttpGatewayRouteMatch: AWSEncodableShape & AWSDecodableShape {
        /// The client request headers to match on.
        public let headers: [HttpGatewayRouteHeader]?
        /// The host name to match on.
        public let hostname: GatewayRouteHostnameMatch?
        /// The method to match on.
        public let method: HttpMethod?
        /// The path to match on.
        public let path: HttpPathMatch?
        /// The port number to match on.
        public let port: Int?
        /// Specifies the path to match requests with. This parameter must always start with /, which by itself matches all requests to the virtual service name. You can also match for path-based routing of requests. For example, if your virtual service name is my-service.local and you want the route to match requests to my-service.local/metrics, your prefix should be /metrics.
        public let prefix: String?
        /// The query parameter to match on.
        public let queryParameters: [HttpQueryParameter]?

        @inlinable
        public init(headers: [HttpGatewayRouteHeader]? = nil, hostname: GatewayRouteHostnameMatch? = nil, method: HttpMethod? = nil, path: HttpPathMatch? = nil, port: Int? = nil, prefix: String? = nil, queryParameters: [HttpQueryParameter]? = nil) {
            self.headers = headers
            self.hostname = hostname
            self.method = method
            self.path = path
            self.port = port
            self.prefix = prefix
            self.queryParameters = queryParameters
        }

        public func validate(name: String) throws {
            try self.headers?.forEach {
                try $0.validate(name: "\(name).headers[]")
            }
            try self.validate(self.headers, name: "headers", parent: name, max: 10)
            try self.validate(self.headers, name: "headers", parent: name, min: 1)
            try self.hostname?.validate(name: "\(name).hostname")
            try self.path?.validate(name: "\(name).path")
            try self.validate(self.port, name: "port", parent: name, max: 65535)
            try self.validate(self.port, name: "port", parent: name, min: 1)
            try self.validate(self.queryParameters, name: "queryParameters", parent: name, max: 10)
            try self.validate(self.queryParameters, name: "queryParameters", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case headers = "headers"
            case hostname = "hostname"
            case method = "method"
            case path = "path"
            case port = "port"
            case prefix = "prefix"
            case queryParameters = "queryParameters"
        }
    }

    public struct HttpGatewayRoutePathRewrite: AWSEncodableShape & AWSDecodableShape {
        /// The exact path to rewrite.
        public let exact: String?

        @inlinable
        public init(exact: String? = nil) {
            self.exact = exact
        }

        public func validate(name: String) throws {
            try self.validate(self.exact, name: "exact", parent: name, max: 255)
            try self.validate(self.exact, name: "exact", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case exact = "exact"
        }
    }

    public struct HttpGatewayRoutePrefixRewrite: AWSEncodableShape & AWSDecodableShape {
        /// The default prefix used to replace the incoming route prefix when rewritten.
        public let defaultPrefix: DefaultGatewayRouteRewrite?
        /// The value used to replace the incoming route prefix when rewritten.
        public let value: String?

        @inlinable
        public init(defaultPrefix: DefaultGatewayRouteRewrite? = nil, value: String? = nil) {
            self.defaultPrefix = defaultPrefix
            self.value = value
        }

        public func validate(name: String) throws {
            try self.validate(self.value, name: "value", parent: name, max: 255)
            try self.validate(self.value, name: "value", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case defaultPrefix = "defaultPrefix"
            case value = "value"
        }
    }

    public struct HttpGatewayRouteRewrite: AWSEncodableShape & AWSDecodableShape {
        /// The host name to rewrite.
        public let hostname: GatewayRouteHostnameRewrite?
        /// The path to rewrite.
        public let path: HttpGatewayRoutePathRewrite?
        /// The specified beginning characters to rewrite.
        public let prefix: HttpGatewayRoutePrefixRewrite?

        @inlinable
        public init(hostname: GatewayRouteHostnameRewrite? = nil, path: HttpGatewayRoutePathRewrite? = nil, prefix: HttpGatewayRoutePrefixRewrite? = nil) {
            self.hostname = hostname
            self.path = path
            self.prefix = prefix
        }

        public func validate(name: String) throws {
            try self.path?.validate(name: "\(name).path")
            try self.prefix?.validate(name: "\(name).prefix")
        }

        private enum CodingKeys: String, CodingKey {
            case hostname = "hostname"
            case path = "path"
            case prefix = "prefix"
        }
    }

    public struct HttpPathMatch: AWSEncodableShape & AWSDecodableShape {
        /// The exact path to match on.
        public let exact: String?
        /// The regex used to match the path.
        public let regex: String?

        @inlinable
        public init(exact: String? = nil, regex: String? = nil) {
            self.exact = exact
            self.regex = regex
        }

        public func validate(name: String) throws {
            try self.validate(self.exact, name: "exact", parent: name, max: 255)
            try self.validate(self.exact, name: "exact", parent: name, min: 1)
            try self.validate(self.regex, name: "regex", parent: name, max: 255)
            try self.validate(self.regex, name: "regex", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case exact = "exact"
            case regex = "regex"
        }
    }

    public struct HttpQueryParameter: AWSEncodableShape & AWSDecodableShape {
        /// The query parameter to match on.
        public let match: QueryParameterMatch?
        /// A name for the query parameter that will be matched on.
        public let name: String

        @inlinable
        public init(match: QueryParameterMatch? = nil, name: String) {
            self.match = match
            self.name = name
        }

        private enum CodingKeys: String, CodingKey {
            case match = "match"
            case name = "name"
        }
    }

    public struct HttpRetryPolicy: AWSEncodableShape & AWSDecodableShape {
        /// Specify at least one of the following values.    server-error  HTTP status codes 500, 501, 502, 503, 504, 505, 506, 507, 508, 510, and 511    gateway-error  HTTP status codes 502, 503, and 504    client-error  HTTP status code 409    stream-error  Retry on refused stream
        public let httpRetryEvents: [String]?
        /// The maximum number of retry attempts.
        public let maxRetries: Int64
        /// The timeout for each retry attempt.
        public let perRetryTimeout: Duration
        /// Specify a valid value. The event occurs before any processing of a request has started and is encountered when the upstream is temporarily or permanently unavailable.
        public let tcpRetryEvents: [TcpRetryPolicyEvent]?

        @inlinable
        public init(httpRetryEvents: [String]? = nil, maxRetries: Int64, perRetryTimeout: Duration, tcpRetryEvents: [TcpRetryPolicyEvent]? = nil) {
            self.httpRetryEvents = httpRetryEvents
            self.maxRetries = maxRetries
            self.perRetryTimeout = perRetryTimeout
            self.tcpRetryEvents = tcpRetryEvents
        }

        public func validate(name: String) throws {
            try self.httpRetryEvents?.forEach {
                try validate($0, name: "httpRetryEvents[]", parent: name, max: 25)
                try validate($0, name: "httpRetryEvents[]", parent: name, min: 1)
            }
            try self.validate(self.httpRetryEvents, name: "httpRetryEvents", parent: name, max: 25)
            try self.validate(self.httpRetryEvents, name: "httpRetryEvents", parent: name, min: 1)
            try self.validate(self.maxRetries, name: "maxRetries", parent: name, min: 0)
            try self.perRetryTimeout.validate(name: "\(name).perRetryTimeout")
            try self.validate(self.tcpRetryEvents, name: "tcpRetryEvents", parent: name, max: 1)
            try self.validate(self.tcpRetryEvents, name: "tcpRetryEvents", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case httpRetryEvents = "httpRetryEvents"
            case maxRetries = "maxRetries"
            case perRetryTimeout = "perRetryTimeout"
            case tcpRetryEvents = "tcpRetryEvents"
        }
    }

    public struct HttpRoute: AWSEncodableShape & AWSDecodableShape {
        /// An object that represents the action to take if a match is determined.
        public let action: HttpRouteAction
        /// An object that represents the criteria for determining a request match.
        public let match: HttpRouteMatch
        /// An object that represents a retry policy.
        public let retryPolicy: HttpRetryPolicy?
        /// An object that represents types of timeouts.
        public let timeout: HttpTimeout?

        @inlinable
        public init(action: HttpRouteAction, match: HttpRouteMatch, retryPolicy: HttpRetryPolicy? = nil, timeout: HttpTimeout? = nil) {
            self.action = action
            self.match = match
            self.retryPolicy = retryPolicy
            self.timeout = timeout
        }

        public func validate(name: String) throws {
            try self.action.validate(name: "\(name).action")
            try self.match.validate(name: "\(name).match")
            try self.retryPolicy?.validate(name: "\(name).retryPolicy")
            try self.timeout?.validate(name: "\(name).timeout")
        }

        private enum CodingKeys: String, CodingKey {
            case action = "action"
            case match = "match"
            case retryPolicy = "retryPolicy"
            case timeout = "timeout"
        }
    }

    public struct HttpRouteAction: AWSEncodableShape & AWSDecodableShape {
        /// An object that represents the targets that traffic is routed to when a request matches the route.
        public let weightedTargets: [WeightedTarget]

        @inlinable
        public init(weightedTargets: [WeightedTarget]) {
            self.weightedTargets = weightedTargets
        }

        public func validate(name: String) throws {
            try self.weightedTargets.forEach {
                try $0.validate(name: "\(name).weightedTargets[]")
            }
            try self.validate(self.weightedTargets, name: "weightedTargets", parent: name, max: 10)
            try self.validate(self.weightedTargets, name: "weightedTargets", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case weightedTargets = "weightedTargets"
        }
    }

    public struct HttpRouteHeader: AWSEncodableShape & AWSDecodableShape {
        /// Specify True to match anything except the match criteria. The default value is False.
        public let invert: Bool?
        /// The HeaderMatchMethod object.
        public let match: HeaderMatchMethod?
        /// A name for the HTTP header in the client request that will be matched on.
        public let name: String

        @inlinable
        public init(invert: Bool? = nil, match: HeaderMatchMethod? = nil, name: String) {
            self.invert = invert
            self.match = match
            self.name = name
        }

        public func validate(name: String) throws {
            try self.match?.validate(name: "\(name).match")
            try self.validate(self.name, name: "name", parent: name, max: 50)
            try self.validate(self.name, name: "name", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case invert = "invert"
            case match = "match"
            case name = "name"
        }
    }

    public struct HttpRouteMatch: AWSEncodableShape & AWSDecodableShape {
        /// The client request headers to match on.
        public let headers: [HttpRouteHeader]?
        /// The client request method to match on. Specify only one.
        public let method: HttpMethod?
        /// The client request path to match on.
        public let path: HttpPathMatch?
        /// The port number to match on.
        public let port: Int?
        /// Specifies the path to match requests with. This parameter must always start with /, which by itself matches all requests to the virtual service name. You can also match for path-based routing of requests. For example, if your virtual service name is my-service.local and you want the route to match requests to my-service.local/metrics, your prefix should be /metrics.
        public let prefix: String?
        /// The client request query parameters to match on.
        public let queryParameters: [HttpQueryParameter]?
        /// The client request scheme to match on. Specify only one. Applicable only for HTTP2 routes.
        public let scheme: HttpScheme?

        @inlinable
        public init(headers: [HttpRouteHeader]? = nil, method: HttpMethod? = nil, path: HttpPathMatch? = nil, port: Int? = nil, prefix: String? = nil, queryParameters: [HttpQueryParameter]? = nil, scheme: HttpScheme? = nil) {
            self.headers = headers
            self.method = method
            self.path = path
            self.port = port
            self.prefix = prefix
            self.queryParameters = queryParameters
            self.scheme = scheme
        }

        public func validate(name: String) throws {
            try self.headers?.forEach {
                try $0.validate(name: "\(name).headers[]")
            }
            try self.validate(self.headers, name: "headers", parent: name, max: 10)
            try self.validate(self.headers, name: "headers", parent: name, min: 1)
            try self.path?.validate(name: "\(name).path")
            try self.validate(self.port, name: "port", parent: name, max: 65535)
            try self.validate(self.port, name: "port", parent: name, min: 1)
            try self.validate(self.queryParameters, name: "queryParameters", parent: name, max: 10)
            try self.validate(self.queryParameters, name: "queryParameters", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case headers = "headers"
            case method = "method"
            case path = "path"
            case port = "port"
            case prefix = "prefix"
            case queryParameters = "queryParameters"
            case scheme = "scheme"
        }
    }

    public struct HttpTimeout: AWSEncodableShape & AWSDecodableShape {
        /// An object that represents an idle timeout. An idle timeout bounds the amount of time that a connection may be idle. The default value is none.
        public let idle: Duration?
        /// An object that represents a per request timeout. The default value is 15 seconds. If you set a higher timeout, then make sure that the higher value is set for each App Mesh  resource in a conversation. For example, if a virtual node backend uses a virtual router provider to route to another virtual node, then the timeout should be greater than 15 seconds for the source and destination virtual node and the route.
        public let perRequest: Duration?

        @inlinable
        public init(idle: Duration? = nil, perRequest: Duration? = nil) {
            self.idle = idle
            self.perRequest = perRequest
        }

        public func validate(name: String) throws {
            try self.idle?.validate(name: "\(name).idle")
            try self.perRequest?.validate(name: "\(name).perRequest")
        }

        private enum CodingKeys: String, CodingKey {
            case idle = "idle"
            case perRequest = "perRequest"
        }
    }

    public struct JsonFormatRef: AWSEncodableShape & AWSDecodableShape {
        /// The specified key for the JSON.
        public let key: String
        /// The specified value for the JSON.
        public let value: String

        @inlinable
        public init(key: String, value: String) {
            self.key = key
            self.value = value
        }

        public func validate(name: String) throws {
            try self.validate(self.key, name: "key", parent: name, max: 100)
            try self.validate(self.key, name: "key", parent: name, min: 1)
            try self.validate(self.value, name: "value", parent: name, max: 100)
            try self.validate(self.value, name: "value", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case key = "key"
            case value = "value"
        }
    }

    public struct ListGatewayRoutesInput: AWSEncodableShape {
        /// The maximum number of results returned by ListGatewayRoutes in paginated output. When you use this parameter, ListGatewayRoutes returns only limit results in a single page along with a nextToken response element. You can see the remaining results of the initial request by sending another ListGatewayRoutes request with the returned nextToken value. This value can be between 1 and 100. If you don't use this parameter, ListGatewayRoutes returns up to 100 results and a nextToken value if applicable.
        public let limit: Int?
        /// The name of the service mesh to list gateway routes in.
        public let meshName: String
        /// The Amazon Web Services IAM account ID of the service mesh owner. If the account ID is not your own, then it's the ID of the account that shared the mesh with your account. For more information about mesh sharing, see Working with shared meshes.
        public let meshOwner: String?
        /// The nextToken value returned from a previous paginated ListGatewayRoutes request where limit was used and the results exceeded the value of that parameter. Pagination continues from the end of the previous results that returned the nextToken value.
        public let nextToken: String?
        /// The name of the virtual gateway to list gateway routes in.
        public let virtualGatewayName: String

        @inlinable
        public init(limit: Int? = nil, meshName: String, meshOwner: String? = nil, nextToken: String? = nil, virtualGatewayName: String) {
            self.limit = limit
            self.meshName = meshName
            self.meshOwner = meshOwner
            self.nextToken = nextToken
            self.virtualGatewayName = virtualGatewayName
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.limit, key: "limit")
            request.encodePath(self.meshName, key: "meshName")
            request.encodeQuery(self.meshOwner, key: "meshOwner")
            request.encodeQuery(self.nextToken, key: "nextToken")
            request.encodePath(self.virtualGatewayName, key: "virtualGatewayName")
        }

        public func validate(name: String) throws {
            try self.validate(self.limit, name: "limit", parent: name, max: 100)
            try self.validate(self.limit, name: "limit", parent: name, min: 1)
            try self.validate(self.meshName, name: "meshName", parent: name, max: 255)
            try self.validate(self.meshName, name: "meshName", parent: name, min: 1)
            try self.validate(self.meshOwner, name: "meshOwner", parent: name, max: 12)
            try self.validate(self.meshOwner, name: "meshOwner", parent: name, min: 12)
            try self.validate(self.virtualGatewayName, name: "virtualGatewayName", parent: name, max: 255)
            try self.validate(self.virtualGatewayName, name: "virtualGatewayName", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListGatewayRoutesOutput: AWSDecodableShape {
        /// The list of existing gateway routes for the specified service mesh and virtual gateway.
        public let gatewayRoutes: [GatewayRouteRef]
        /// The nextToken value to include in a future ListGatewayRoutes request. When the results of a ListGatewayRoutes request exceed limit, you can use this value to retrieve the next page of results. This value is null when there are no more results to return.
        public let nextToken: String?

        @inlinable
        public init(gatewayRoutes: [GatewayRouteRef], nextToken: String? = nil) {
            self.gatewayRoutes = gatewayRoutes
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case gatewayRoutes = "gatewayRoutes"
            case nextToken = "nextToken"
        }
    }

    public struct ListMeshesInput: AWSEncodableShape {
        /// The maximum number of results returned by ListMeshes in paginated output. When you use this parameter, ListMeshes returns only limit results in a single page along with a nextToken response element. You can see the remaining results of the initial request by sending another ListMeshes request with the returned nextToken value. This value can be between 1 and 100. If you don't use this parameter, ListMeshes returns up to 100 results and a nextToken value if applicable.
        public let limit: Int?
        /// The nextToken value returned from a previous paginated ListMeshes request where limit was used and the results exceeded the value of that parameter. Pagination continues from the end of the previous results that returned the nextToken value.  This token should be treated as an opaque identifier that is used only to retrieve the next items in a list and not for other programmatic purposes.
        public let nextToken: String?

        @inlinable
        public init(limit: Int? = nil, nextToken: String? = nil) {
            self.limit = limit
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.limit, key: "limit")
            request.encodeQuery(self.nextToken, key: "nextToken")
        }

        public func validate(name: String) throws {
            try self.validate(self.limit, name: "limit", parent: name, max: 100)
            try self.validate(self.limit, name: "limit", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListMeshesOutput: AWSDecodableShape {
        /// The list of existing service meshes.
        public let meshes: [MeshRef]
        /// The nextToken value to include in a future ListMeshes request. When the results of a ListMeshes request exceed limit, you can use this value to retrieve the next page of results. This value is null when there are no more results to return.
        public let nextToken: String?

        @inlinable
        public init(meshes: [MeshRef], nextToken: String? = nil) {
            self.meshes = meshes
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case meshes = "meshes"
            case nextToken = "nextToken"
        }
    }

    public struct ListRoutesInput: AWSEncodableShape {
        /// The maximum number of results returned by ListRoutes in paginated output. When you use this parameter, ListRoutes returns only limit results in a single page along with a nextToken response element. You can see the remaining results of the initial request by sending another ListRoutes request with the returned nextToken value. This value can be between 1 and 100. If you don't use this parameter, ListRoutes returns up to 100 results and a nextToken value if applicable.
        public let limit: Int?
        /// The name of the service mesh to list routes in.
        public let meshName: String
        /// The Amazon Web Services IAM account ID of the service mesh owner. If the account ID is not your own, then it's the ID of the account that shared the mesh with your account. For more information about mesh sharing, see Working with shared meshes.
        public let meshOwner: String?
        /// The nextToken value returned from a previous paginated ListRoutes request where limit was used and the results exceeded the value of that parameter. Pagination continues from the end of the previous results that returned the nextToken value.
        public let nextToken: String?
        /// The name of the virtual router to list routes in.
        public let virtualRouterName: String

        @inlinable
        public init(limit: Int? = nil, meshName: String, meshOwner: String? = nil, nextToken: String? = nil, virtualRouterName: String) {
            self.limit = limit
            self.meshName = meshName
            self.meshOwner = meshOwner
            self.nextToken = nextToken
            self.virtualRouterName = virtualRouterName
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.limit, key: "limit")
            request.encodePath(self.meshName, key: "meshName")
            request.encodeQuery(self.meshOwner, key: "meshOwner")
            request.encodeQuery(self.nextToken, key: "nextToken")
            request.encodePath(self.virtualRouterName, key: "virtualRouterName")
        }

        public func validate(name: String) throws {
            try self.validate(self.limit, name: "limit", parent: name, max: 100)
            try self.validate(self.limit, name: "limit", parent: name, min: 1)
            try self.validate(self.meshName, name: "meshName", parent: name, max: 255)
            try self.validate(self.meshName, name: "meshName", parent: name, min: 1)
            try self.validate(self.meshOwner, name: "meshOwner", parent: name, max: 12)
            try self.validate(self.meshOwner, name: "meshOwner", parent: name, min: 12)
            try self.validate(self.virtualRouterName, name: "virtualRouterName", parent: name, max: 255)
            try self.validate(self.virtualRouterName, name: "virtualRouterName", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListRoutesOutput: AWSDecodableShape {
        /// The nextToken value to include in a future ListRoutes request. When the results of a ListRoutes request exceed limit, you can use this value to retrieve the next page of results. This value is null when there are no more results to return.
        public let nextToken: String?
        /// The list of existing routes for the specified service mesh and virtual router.
        public let routes: [RouteRef]

        @inlinable
        public init(nextToken: String? = nil, routes: [RouteRef]) {
            self.nextToken = nextToken
            self.routes = routes
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "nextToken"
            case routes = "routes"
        }
    }

    public struct ListTagsForResourceInput: AWSEncodableShape {
        /// The maximum number of tag results returned by ListTagsForResource in paginated output. When this parameter is used, ListTagsForResource returns only limit results in a single page along with a nextToken response element. You can see the remaining results of the initial request by sending another ListTagsForResource request with the returned nextToken value. This value can be between 1 and 100. If you don't use this parameter, ListTagsForResource returns up to 100 results and a nextToken value if applicable.
        public let limit: Int?
        /// The nextToken value returned from a previous paginated ListTagsForResource request where limit was used and the results exceeded the value of that parameter. Pagination continues from the end of the previous results that returned the nextToken value.
        public let nextToken: String?
        /// The Amazon Resource Name (ARN) that identifies the resource to list the tags for.
        public let resourceArn: String

        @inlinable
        public init(limit: Int? = nil, nextToken: String? = nil, resourceArn: String) {
            self.limit = limit
            self.nextToken = nextToken
            self.resourceArn = resourceArn
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.limit, key: "limit")
            request.encodeQuery(self.nextToken, key: "nextToken")
            request.encodeQuery(self.resourceArn, key: "resourceArn")
        }

        public func validate(name: String) throws {
            try self.validate(self.limit, name: "limit", parent: name, max: 50)
            try self.validate(self.limit, name: "limit", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListTagsForResourceOutput: AWSDecodableShape {
        /// The nextToken value to include in a future ListTagsForResource request. When the results of a ListTagsForResource request exceed limit, you can use this value to retrieve the next page of results. This value is null when there are no more results to return.
        public let nextToken: String?
        /// The tags for the resource.
        public let tags: [TagRef]

        @inlinable
        public init(nextToken: String? = nil, tags: [TagRef]) {
            self.nextToken = nextToken
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "nextToken"
            case tags = "tags"
        }
    }

    public struct ListVirtualGatewaysInput: AWSEncodableShape {
        /// The maximum number of results returned by ListVirtualGateways in paginated output. When you use this parameter, ListVirtualGateways returns only limit results in a single page along with a nextToken response element. You can see the remaining results of the initial request by sending another ListVirtualGateways request with the returned nextToken value. This value can be between 1 and 100. If you don't use this parameter, ListVirtualGateways returns up to 100 results and a nextToken value if applicable.
        public let limit: Int?
        /// The name of the service mesh to list virtual gateways in.
        public let meshName: String
        /// The Amazon Web Services IAM account ID of the service mesh owner. If the account ID is not your own, then it's the ID of the account that shared the mesh with your account. For more information about mesh sharing, see Working with shared meshes.
        public let meshOwner: String?
        /// The nextToken value returned from a previous paginated ListVirtualGateways request where limit was used and the results exceeded the value of that parameter. Pagination continues from the end of the previous results that returned the nextToken value.
        public let nextToken: String?

        @inlinable
        public init(limit: Int? = nil, meshName: String, meshOwner: String? = nil, nextToken: String? = nil) {
            self.limit = limit
            self.meshName = meshName
            self.meshOwner = meshOwner
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.limit, key: "limit")
            request.encodePath(self.meshName, key: "meshName")
            request.encodeQuery(self.meshOwner, key: "meshOwner")
            request.encodeQuery(self.nextToken, key: "nextToken")
        }

        public func validate(name: String) throws {
            try self.validate(self.limit, name: "limit", parent: name, max: 100)
            try self.validate(self.limit, name: "limit", parent: name, min: 1)
            try self.validate(self.meshName, name: "meshName", parent: name, max: 255)
            try self.validate(self.meshName, name: "meshName", parent: name, min: 1)
            try self.validate(self.meshOwner, name: "meshOwner", parent: name, max: 12)
            try self.validate(self.meshOwner, name: "meshOwner", parent: name, min: 12)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListVirtualGatewaysOutput: AWSDecodableShape {
        /// The nextToken value to include in a future ListVirtualGateways request. When the results of a ListVirtualGateways request exceed limit, you can use this value to retrieve the next page of results. This value is null when there are no more results to return.
        public let nextToken: String?
        /// The list of existing virtual gateways for the specified service mesh.
        public let virtualGateways: [VirtualGatewayRef]

        @inlinable
        public init(nextToken: String? = nil, virtualGateways: [VirtualGatewayRef]) {
            self.nextToken = nextToken
            self.virtualGateways = virtualGateways
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "nextToken"
            case virtualGateways = "virtualGateways"
        }
    }

    public struct ListVirtualNodesInput: AWSEncodableShape {
        /// The maximum number of results returned by ListVirtualNodes in paginated output. When you use this parameter, ListVirtualNodes returns only limit results in a single page along with a nextToken response element. You can see the remaining results of the initial request by sending another ListVirtualNodes request with the returned nextToken value. This value can be between 1 and 100. If you don't use this parameter, ListVirtualNodes returns up to 100 results and a nextToken value if applicable.
        public let limit: Int?
        /// The name of the service mesh to list virtual nodes in.
        public let meshName: String
        /// The Amazon Web Services IAM account ID of the service mesh owner. If the account ID is not your own, then it's the ID of the account that shared the mesh with your account. For more information about mesh sharing, see Working with shared meshes.
        public let meshOwner: String?
        /// The nextToken value returned from a previous paginated ListVirtualNodes request where limit was used and the results exceeded the value of that parameter. Pagination continues from the end of the previous results that returned the nextToken value.
        public let nextToken: String?

        @inlinable
        public init(limit: Int? = nil, meshName: String, meshOwner: String? = nil, nextToken: String? = nil) {
            self.limit = limit
            self.meshName = meshName
            self.meshOwner = meshOwner
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.limit, key: "limit")
            request.encodePath(self.meshName, key: "meshName")
            request.encodeQuery(self.meshOwner, key: "meshOwner")
            request.encodeQuery(self.nextToken, key: "nextToken")
        }

        public func validate(name: String) throws {
            try self.validate(self.limit, name: "limit", parent: name, max: 100)
            try self.validate(self.limit, name: "limit", parent: name, min: 1)
            try self.validate(self.meshName, name: "meshName", parent: name, max: 255)
            try self.validate(self.meshName, name: "meshName", parent: name, min: 1)
            try self.validate(self.meshOwner, name: "meshOwner", parent: name, max: 12)
            try self.validate(self.meshOwner, name: "meshOwner", parent: name, min: 12)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListVirtualNodesOutput: AWSDecodableShape {
        /// The nextToken value to include in a future ListVirtualNodes request. When the results of a ListVirtualNodes request exceed limit, you can use this value to retrieve the next page of results. This value is null when there are no more results to return.
        public let nextToken: String?
        /// The list of existing virtual nodes for the specified service mesh.
        public let virtualNodes: [VirtualNodeRef]

        @inlinable
        public init(nextToken: String? = nil, virtualNodes: [VirtualNodeRef]) {
            self.nextToken = nextToken
            self.virtualNodes = virtualNodes
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "nextToken"
            case virtualNodes = "virtualNodes"
        }
    }

    public struct ListVirtualRoutersInput: AWSEncodableShape {
        /// The maximum number of results returned by ListVirtualRouters in paginated output. When you use this parameter, ListVirtualRouters returns only limit results in a single page along with a nextToken response element. You can see the remaining results of the initial request by sending another ListVirtualRouters request with the returned nextToken value. This value can be between 1 and 100. If you don't use this parameter, ListVirtualRouters returns up to 100 results and a nextToken value if applicable.
        public let limit: Int?
        /// The name of the service mesh to list virtual routers in.
        public let meshName: String
        /// The Amazon Web Services IAM account ID of the service mesh owner. If the account ID is not your own, then it's the ID of the account that shared the mesh with your account. For more information about mesh sharing, see Working with shared meshes.
        public let meshOwner: String?
        /// The nextToken value returned from a previous paginated ListVirtualRouters request where limit was used and the results exceeded the value of that parameter. Pagination continues from the end of the previous results that returned the nextToken value.
        public let nextToken: String?

        @inlinable
        public init(limit: Int? = nil, meshName: String, meshOwner: String? = nil, nextToken: String? = nil) {
            self.limit = limit
            self.meshName = meshName
            self.meshOwner = meshOwner
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.limit, key: "limit")
            request.encodePath(self.meshName, key: "meshName")
            request.encodeQuery(self.meshOwner, key: "meshOwner")
            request.encodeQuery(self.nextToken, key: "nextToken")
        }

        public func validate(name: String) throws {
            try self.validate(self.limit, name: "limit", parent: name, max: 100)
            try self.validate(self.limit, name: "limit", parent: name, min: 1)
            try self.validate(self.meshName, name: "meshName", parent: name, max: 255)
            try self.validate(self.meshName, name: "meshName", parent: name, min: 1)
            try self.validate(self.meshOwner, name: "meshOwner", parent: name, max: 12)
            try self.validate(self.meshOwner, name: "meshOwner", parent: name, min: 12)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListVirtualRoutersOutput: AWSDecodableShape {
        /// The nextToken value to include in a future ListVirtualRouters request. When the results of a ListVirtualRouters request exceed limit, you can use this value to retrieve the next page of results. This value is null when there are no more results to return.
        public let nextToken: String?
        /// The list of existing virtual routers for the specified service mesh.
        public let virtualRouters: [VirtualRouterRef]

        @inlinable
        public init(nextToken: String? = nil, virtualRouters: [VirtualRouterRef]) {
            self.nextToken = nextToken
            self.virtualRouters = virtualRouters
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "nextToken"
            case virtualRouters = "virtualRouters"
        }
    }

    public struct ListVirtualServicesInput: AWSEncodableShape {
        /// The maximum number of results returned by ListVirtualServices in paginated output. When you use this parameter, ListVirtualServices returns only limit results in a single page along with a nextToken response element. You can see the remaining results of the initial request by sending another ListVirtualServices request with the returned nextToken value. This value can be between 1 and 100. If you don't use this parameter, ListVirtualServices returns up to 100 results and a nextToken value if applicable.
        public let limit: Int?
        /// The name of the service mesh to list virtual services in.
        public let meshName: String
        /// The Amazon Web Services IAM account ID of the service mesh owner. If the account ID is not your own, then it's the ID of the account that shared the mesh with your account. For more information about mesh sharing, see Working with shared meshes.
        public let meshOwner: String?
        /// The nextToken value returned from a previous paginated ListVirtualServices request where limit was used and the results exceeded the value of that parameter. Pagination continues from the end of the previous results that returned the nextToken value.
        public let nextToken: String?

        @inlinable
        public init(limit: Int? = nil, meshName: String, meshOwner: String? = nil, nextToken: String? = nil) {
            self.limit = limit
            self.meshName = meshName
            self.meshOwner = meshOwner
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.limit, key: "limit")
            request.encodePath(self.meshName, key: "meshName")
            request.encodeQuery(self.meshOwner, key: "meshOwner")
            request.encodeQuery(self.nextToken, key: "nextToken")
        }

        public func validate(name: String) throws {
            try self.validate(self.limit, name: "limit", parent: name, max: 100)
            try self.validate(self.limit, name: "limit", parent: name, min: 1)
            try self.validate(self.meshName, name: "meshName", parent: name, max: 255)
            try self.validate(self.meshName, name: "meshName", parent: name, min: 1)
            try self.validate(self.meshOwner, name: "meshOwner", parent: name, max: 12)
            try self.validate(self.meshOwner, name: "meshOwner", parent: name, min: 12)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListVirtualServicesOutput: AWSDecodableShape {
        /// The nextToken value to include in a future ListVirtualServices request. When the results of a ListVirtualServices request exceed limit, you can use this value to retrieve the next page of results. This value is null when there are no more results to return.
        public let nextToken: String?
        /// The list of existing virtual services for the specified service mesh.
        public let virtualServices: [VirtualServiceRef]

        @inlinable
        public init(nextToken: String? = nil, virtualServices: [VirtualServiceRef]) {
            self.nextToken = nextToken
            self.virtualServices = virtualServices
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "nextToken"
            case virtualServices = "virtualServices"
        }
    }

    public struct Listener: AWSEncodableShape & AWSDecodableShape {
        /// The connection pool information for the listener.
        public let connectionPool: VirtualNodeConnectionPool?
        /// The health check information for the listener.
        public let healthCheck: HealthCheckPolicy?
        /// The outlier detection information for the listener.
        public let outlierDetection: OutlierDetection?
        /// The port mapping information for the listener.
        public let portMapping: PortMapping
        /// An object that represents timeouts for different protocols.
        public let timeout: ListenerTimeout?
        /// A reference to an object that represents the Transport Layer Security (TLS) properties for a listener.
        public let tls: ListenerTls?

        @inlinable
        public init(connectionPool: VirtualNodeConnectionPool? = nil, healthCheck: HealthCheckPolicy? = nil, outlierDetection: OutlierDetection? = nil, portMapping: PortMapping, timeout: ListenerTimeout? = nil, tls: ListenerTls? = nil) {
            self.connectionPool = connectionPool
            self.healthCheck = healthCheck
            self.outlierDetection = outlierDetection
            self.portMapping = portMapping
            self.timeout = timeout
            self.tls = tls
        }

        public func validate(name: String) throws {
            try self.connectionPool?.validate(name: "\(name).connectionPool")
            try self.healthCheck?.validate(name: "\(name).healthCheck")
            try self.outlierDetection?.validate(name: "\(name).outlierDetection")
            try self.portMapping.validate(name: "\(name).portMapping")
            try self.timeout?.validate(name: "\(name).timeout")
            try self.tls?.validate(name: "\(name).tls")
        }

        private enum CodingKeys: String, CodingKey {
            case connectionPool = "connectionPool"
            case healthCheck = "healthCheck"
            case outlierDetection = "outlierDetection"
            case portMapping = "portMapping"
            case timeout = "timeout"
            case tls = "tls"
        }
    }

    public struct ListenerTls: AWSEncodableShape & AWSDecodableShape {
        /// A reference to an object that represents a listener's Transport Layer Security (TLS) certificate.
        public let certificate: ListenerTlsCertificate
        /// Specify one of the following modes.    STRICT  Listener only accepts connections with TLS enabled.     PERMISSIVE  Listener accepts connections with or without TLS enabled.    DISABLED  Listener only accepts connections without TLS.
        public let mode: ListenerTlsMode
        /// A reference to an object that represents a listener's Transport Layer Security (TLS) validation context.
        public let validation: ListenerTlsValidationContext?

        @inlinable
        public init(certificate: ListenerTlsCertificate, mode: ListenerTlsMode, validation: ListenerTlsValidationContext? = nil) {
            self.certificate = certificate
            self.mode = mode
            self.validation = validation
        }

        public func validate(name: String) throws {
            try self.certificate.validate(name: "\(name).certificate")
            try self.validation?.validate(name: "\(name).validation")
        }

        private enum CodingKeys: String, CodingKey {
            case certificate = "certificate"
            case mode = "mode"
            case validation = "validation"
        }
    }

    public struct ListenerTlsAcmCertificate: AWSEncodableShape & AWSDecodableShape {
        /// The Amazon Resource Name (ARN) for the certificate. The certificate must meet specific requirements and you must have proxy authorization enabled. For more information, see Transport Layer Security (TLS).
        public let certificateArn: String

        @inlinable
        public init(certificateArn: String) {
            self.certificateArn = certificateArn
        }

        private enum CodingKeys: String, CodingKey {
            case certificateArn = "certificateArn"
        }
    }

    public struct ListenerTlsFileCertificate: AWSEncodableShape & AWSDecodableShape {
        /// The certificate chain for the certificate.
        public let certificateChain: String
        /// The private key for a certificate stored on the file system of the virtual node that the proxy is running on.
        public let privateKey: String

        @inlinable
        public init(certificateChain: String, privateKey: String) {
            self.certificateChain = certificateChain
            self.privateKey = privateKey
        }

        public func validate(name: String) throws {
            try self.validate(self.certificateChain, name: "certificateChain", parent: name, max: 255)
            try self.validate(self.certificateChain, name: "certificateChain", parent: name, min: 1)
            try self.validate(self.privateKey, name: "privateKey", parent: name, max: 255)
            try self.validate(self.privateKey, name: "privateKey", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case certificateChain = "certificateChain"
            case privateKey = "privateKey"
        }
    }

    public struct ListenerTlsSdsCertificate: AWSEncodableShape & AWSDecodableShape {
        /// A reference to an object that represents the name of the secret requested from the Secret Discovery Service provider representing Transport Layer Security (TLS) materials like a certificate or certificate chain.
        public let secretName: String

        @inlinable
        public init(secretName: String) {
            self.secretName = secretName
        }

        private enum CodingKeys: String, CodingKey {
            case secretName = "secretName"
        }
    }

    public struct ListenerTlsValidationContext: AWSEncodableShape & AWSDecodableShape {
        /// A reference to an object that represents the SANs for a listener's Transport Layer Security (TLS) validation context.
        public let subjectAlternativeNames: SubjectAlternativeNames?
        /// A reference to where to retrieve the trust chain when validating a peers Transport Layer Security (TLS) certificate.
        public let trust: ListenerTlsValidationContextTrust

        @inlinable
        public init(subjectAlternativeNames: SubjectAlternativeNames? = nil, trust: ListenerTlsValidationContextTrust) {
            self.subjectAlternativeNames = subjectAlternativeNames
            self.trust = trust
        }

        public func validate(name: String) throws {
            try self.subjectAlternativeNames?.validate(name: "\(name).subjectAlternativeNames")
            try self.trust.validate(name: "\(name).trust")
        }

        private enum CodingKeys: String, CodingKey {
            case subjectAlternativeNames = "subjectAlternativeNames"
            case trust = "trust"
        }
    }

    public struct Logging: AWSEncodableShape & AWSDecodableShape {
        /// The access log configuration for a virtual node.
        public let accessLog: AccessLog?

        @inlinable
        public init(accessLog: AccessLog? = nil) {
            self.accessLog = accessLog
        }

        public func validate(name: String) throws {
            try self.accessLog?.validate(name: "\(name).accessLog")
        }

        private enum CodingKeys: String, CodingKey {
            case accessLog = "accessLog"
        }
    }

    public struct MatchRange: AWSEncodableShape & AWSDecodableShape {
        /// The end of the range.
        public let end: Int64
        /// The start of the range.
        public let start: Int64

        @inlinable
        public init(end: Int64, start: Int64) {
            self.end = end
            self.start = start
        }

        private enum CodingKeys: String, CodingKey {
            case end = "end"
            case start = "start"
        }
    }

    public struct MeshData: AWSDecodableShape {
        /// The name of the service mesh.
        public let meshName: String
        /// The associated metadata for the service mesh.
        public let metadata: ResourceMetadata
        /// The associated specification for the service mesh.
        public let spec: MeshSpec
        /// The status of the service mesh.
        public let status: MeshStatus

        @inlinable
        public init(meshName: String, metadata: ResourceMetadata, spec: MeshSpec, status: MeshStatus) {
            self.meshName = meshName
            self.metadata = metadata
            self.spec = spec
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case meshName = "meshName"
            case metadata = "metadata"
            case spec = "spec"
            case status = "status"
        }
    }

    public struct MeshRef: AWSDecodableShape {
        /// The full Amazon Resource Name (ARN) of the service mesh.
        public let arn: String
        /// The Unix epoch timestamp in seconds for when the resource was created.
        public let createdAt: Date
        /// The Unix epoch timestamp in seconds for when the resource was last updated.
        public let lastUpdatedAt: Date
        /// The name of the service mesh.
        public let meshName: String
        /// The Amazon Web Services IAM account ID of the service mesh owner. If the account ID is not your own, then it's the ID of the account that shared the mesh with your account. For more information about mesh sharing, see Working with shared meshes.
        public let meshOwner: String
        /// The Amazon Web Services IAM account ID of the resource owner. If the account ID is not your own, then it's the ID of the mesh owner or of another account that the mesh is shared with. For more information about mesh sharing, see Working with shared meshes.
        public let resourceOwner: String
        /// The version of the resource. Resources are created at version 1, and this version is incremented each time that they're updated.
        public let version: Int64

        @inlinable
        public init(arn: String, createdAt: Date, lastUpdatedAt: Date, meshName: String, meshOwner: String, resourceOwner: String, version: Int64) {
            self.arn = arn
            self.createdAt = createdAt
            self.lastUpdatedAt = lastUpdatedAt
            self.meshName = meshName
            self.meshOwner = meshOwner
            self.resourceOwner = resourceOwner
            self.version = version
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case createdAt = "createdAt"
            case lastUpdatedAt = "lastUpdatedAt"
            case meshName = "meshName"
            case meshOwner = "meshOwner"
            case resourceOwner = "resourceOwner"
            case version = "version"
        }
    }

    public struct MeshServiceDiscovery: AWSEncodableShape & AWSDecodableShape {
        /// The IP version to use to control traffic within the mesh.
        public let ipPreference: IpPreference?

        @inlinable
        public init(ipPreference: IpPreference? = nil) {
            self.ipPreference = ipPreference
        }

        private enum CodingKeys: String, CodingKey {
            case ipPreference = "ipPreference"
        }
    }

    public struct MeshSpec: AWSEncodableShape & AWSDecodableShape {
        /// The egress filter rules for the service mesh.
        public let egressFilter: EgressFilter?
        public let serviceDiscovery: MeshServiceDiscovery?

        @inlinable
        public init(egressFilter: EgressFilter? = nil, serviceDiscovery: MeshServiceDiscovery? = nil) {
            self.egressFilter = egressFilter
            self.serviceDiscovery = serviceDiscovery
        }

        private enum CodingKeys: String, CodingKey {
            case egressFilter = "egressFilter"
            case serviceDiscovery = "serviceDiscovery"
        }
    }

    public struct MeshStatus: AWSDecodableShape {
        /// The current mesh status.
        public let status: MeshStatusCode?

        @inlinable
        public init(status: MeshStatusCode? = nil) {
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case status = "status"
        }
    }

    public struct OutlierDetection: AWSEncodableShape & AWSDecodableShape {
        /// The base amount of time for which a host is ejected.
        public let baseEjectionDuration: Duration
        /// The time interval between ejection sweep analysis.
        public let interval: Duration
        /// Maximum percentage of hosts in load balancing pool for upstream service that can be ejected. Will eject at least one host regardless of the value.
        public let maxEjectionPercent: Int
        /// Number of consecutive 5xx errors required for ejection.
        public let maxServerErrors: Int64

        @inlinable
        public init(baseEjectionDuration: Duration, interval: Duration, maxEjectionPercent: Int, maxServerErrors: Int64) {
            self.baseEjectionDuration = baseEjectionDuration
            self.interval = interval
            self.maxEjectionPercent = maxEjectionPercent
            self.maxServerErrors = maxServerErrors
        }

        public func validate(name: String) throws {
            try self.baseEjectionDuration.validate(name: "\(name).baseEjectionDuration")
            try self.interval.validate(name: "\(name).interval")
            try self.validate(self.maxEjectionPercent, name: "maxEjectionPercent", parent: name, max: 100)
            try self.validate(self.maxEjectionPercent, name: "maxEjectionPercent", parent: name, min: 0)
            try self.validate(self.maxServerErrors, name: "maxServerErrors", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case baseEjectionDuration = "baseEjectionDuration"
            case interval = "interval"
            case maxEjectionPercent = "maxEjectionPercent"
            case maxServerErrors = "maxServerErrors"
        }
    }

    public struct PortMapping: AWSEncodableShape & AWSDecodableShape {
        /// The port used for the port mapping.
        public let port: Int
        /// The protocol used for the port mapping. Specify one protocol.
        public let `protocol`: PortProtocol

        @inlinable
        public init(port: Int, protocol: PortProtocol) {
            self.port = port
            self.`protocol` = `protocol`
        }

        public func validate(name: String) throws {
            try self.validate(self.port, name: "port", parent: name, max: 65535)
            try self.validate(self.port, name: "port", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case port = "port"
            case `protocol` = "protocol"
        }
    }

    public struct QueryParameterMatch: AWSEncodableShape & AWSDecodableShape {
        /// The exact query parameter to match on.
        public let exact: String?

        @inlinable
        public init(exact: String? = nil) {
            self.exact = exact
        }

        private enum CodingKeys: String, CodingKey {
            case exact = "exact"
        }
    }

    public struct ResourceMetadata: AWSDecodableShape {
        /// The full Amazon Resource Name (ARN) for the resource.
        public let arn: String
        /// The Unix epoch timestamp in seconds for when the resource was created.
        public let createdAt: Date
        /// The Unix epoch timestamp in seconds for when the resource was last updated.
        public let lastUpdatedAt: Date
        /// The Amazon Web Services IAM account ID of the service mesh owner. If the account ID is not your own, then it's the ID of the account that shared the mesh with your account. For more information about mesh sharing, see Working with shared meshes.
        public let meshOwner: String
        /// The Amazon Web Services IAM account ID of the resource owner. If the account ID is not your own, then it's the ID of the mesh owner or of another account that the mesh is shared with. For more information about mesh sharing, see Working with shared meshes.
        public let resourceOwner: String
        /// The unique identifier for the resource.
        public let uid: String
        /// The version of the resource. Resources are created at version 1, and this version is incremented each time that they're updated.
        public let version: Int64

        @inlinable
        public init(arn: String, createdAt: Date, lastUpdatedAt: Date, meshOwner: String, resourceOwner: String, uid: String, version: Int64) {
            self.arn = arn
            self.createdAt = createdAt
            self.lastUpdatedAt = lastUpdatedAt
            self.meshOwner = meshOwner
            self.resourceOwner = resourceOwner
            self.uid = uid
            self.version = version
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case createdAt = "createdAt"
            case lastUpdatedAt = "lastUpdatedAt"
            case meshOwner = "meshOwner"
            case resourceOwner = "resourceOwner"
            case uid = "uid"
            case version = "version"
        }
    }

    public struct RouteData: AWSDecodableShape {
        /// The name of the service mesh that the route resides in.
        public let meshName: String
        /// The associated metadata for the route.
        public let metadata: ResourceMetadata
        /// The name of the route.
        public let routeName: String
        /// The specifications of the route.
        public let spec: RouteSpec
        /// The status of the route.
        public let status: RouteStatus
        /// The virtual router that the route is associated with.
        public let virtualRouterName: String

        @inlinable
        public init(meshName: String, metadata: ResourceMetadata, routeName: String, spec: RouteSpec, status: RouteStatus, virtualRouterName: String) {
            self.meshName = meshName
            self.metadata = metadata
            self.routeName = routeName
            self.spec = spec
            self.status = status
            self.virtualRouterName = virtualRouterName
        }

        private enum CodingKeys: String, CodingKey {
            case meshName = "meshName"
            case metadata = "metadata"
            case routeName = "routeName"
            case spec = "spec"
            case status = "status"
            case virtualRouterName = "virtualRouterName"
        }
    }

    public struct RouteRef: AWSDecodableShape {
        /// The full Amazon Resource Name (ARN) for the route.
        public let arn: String
        /// The Unix epoch timestamp in seconds for when the resource was created.
        public let createdAt: Date
        /// The Unix epoch timestamp in seconds for when the resource was last updated.
        public let lastUpdatedAt: Date
        /// The name of the service mesh that the route resides in.
        public let meshName: String
        /// The Amazon Web Services IAM account ID of the service mesh owner. If the account ID is not your own, then it's the ID of the account that shared the mesh with your account. For more information about mesh sharing, see Working with shared meshes.
        public let meshOwner: String
        /// The Amazon Web Services IAM account ID of the resource owner. If the account ID is not your own, then it's the ID of the mesh owner or of another account that the mesh is shared with. For more information about mesh sharing, see Working with shared meshes.
        public let resourceOwner: String
        /// The name of the route.
        public let routeName: String
        /// The version of the resource. Resources are created at version 1, and this version is incremented each time that they're updated.
        public let version: Int64
        /// The virtual router that the route is associated with.
        public let virtualRouterName: String

        @inlinable
        public init(arn: String, createdAt: Date, lastUpdatedAt: Date, meshName: String, meshOwner: String, resourceOwner: String, routeName: String, version: Int64, virtualRouterName: String) {
            self.arn = arn
            self.createdAt = createdAt
            self.lastUpdatedAt = lastUpdatedAt
            self.meshName = meshName
            self.meshOwner = meshOwner
            self.resourceOwner = resourceOwner
            self.routeName = routeName
            self.version = version
            self.virtualRouterName = virtualRouterName
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case createdAt = "createdAt"
            case lastUpdatedAt = "lastUpdatedAt"
            case meshName = "meshName"
            case meshOwner = "meshOwner"
            case resourceOwner = "resourceOwner"
            case routeName = "routeName"
            case version = "version"
            case virtualRouterName = "virtualRouterName"
        }
    }

    public struct RouteSpec: AWSEncodableShape & AWSDecodableShape {
        /// An object that represents the specification of a gRPC route.
        public let grpcRoute: GrpcRoute?
        /// An object that represents the specification of an HTTP/2 route.
        public let http2Route: HttpRoute?
        /// An object that represents the specification of an HTTP route.
        public let httpRoute: HttpRoute?
        /// The priority for the route. Routes are matched based on the specified value, where 0 is the highest priority.
        public let priority: Int?
        /// An object that represents the specification of a TCP route.
        public let tcpRoute: TcpRoute?

        @inlinable
        public init(grpcRoute: GrpcRoute? = nil, http2Route: HttpRoute? = nil, httpRoute: HttpRoute? = nil, priority: Int? = nil, tcpRoute: TcpRoute? = nil) {
            self.grpcRoute = grpcRoute
            self.http2Route = http2Route
            self.httpRoute = httpRoute
            self.priority = priority
            self.tcpRoute = tcpRoute
        }

        public func validate(name: String) throws {
            try self.grpcRoute?.validate(name: "\(name).grpcRoute")
            try self.http2Route?.validate(name: "\(name).http2Route")
            try self.httpRoute?.validate(name: "\(name).httpRoute")
            try self.validate(self.priority, name: "priority", parent: name, max: 1000)
            try self.validate(self.priority, name: "priority", parent: name, min: 0)
            try self.tcpRoute?.validate(name: "\(name).tcpRoute")
        }

        private enum CodingKeys: String, CodingKey {
            case grpcRoute = "grpcRoute"
            case http2Route = "http2Route"
            case httpRoute = "httpRoute"
            case priority = "priority"
            case tcpRoute = "tcpRoute"
        }
    }

    public struct RouteStatus: AWSDecodableShape {
        /// The current status for the route.
        public let status: RouteStatusCode

        @inlinable
        public init(status: RouteStatusCode) {
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case status = "status"
        }
    }

    public struct SubjectAlternativeNameMatchers: AWSEncodableShape & AWSDecodableShape {
        /// The values sent must match the specified values exactly.
        public let exact: [String]

        @inlinable
        public init(exact: [String]) {
            self.exact = exact
        }

        public func validate(name: String) throws {
            try self.exact.forEach {
                try validate($0, name: "exact[]", parent: name, max: 254)
                try validate($0, name: "exact[]", parent: name, min: 1)
            }
        }

        private enum CodingKeys: String, CodingKey {
            case exact = "exact"
        }
    }

    public struct SubjectAlternativeNames: AWSEncodableShape & AWSDecodableShape {
        /// An object that represents the criteria for determining a SANs match.
        public let match: SubjectAlternativeNameMatchers

        @inlinable
        public init(match: SubjectAlternativeNameMatchers) {
            self.match = match
        }

        public func validate(name: String) throws {
            try self.match.validate(name: "\(name).match")
        }

        private enum CodingKeys: String, CodingKey {
            case match = "match"
        }
    }

    public struct TagRef: AWSEncodableShape & AWSDecodableShape {
        /// One part of a key-value pair that make up a tag. A key is a general label that acts like a category for more specific tag values.
        public let key: String
        /// The optional part of a key-value pair that make up a tag. A value acts as a descriptor within a tag category (key).
        public let value: String

        @inlinable
        public init(key: String, value: String) {
            self.key = key
            self.value = value
        }

        public func validate(name: String) throws {
            try self.validate(self.key, name: "key", parent: name, max: 128)
            try self.validate(self.key, name: "key", parent: name, min: 1)
            try self.validate(self.value, name: "value", parent: name, max: 256)
        }

        private enum CodingKeys: String, CodingKey {
            case key = "key"
            case value = "value"
        }
    }

    public struct TagResourceInput: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the resource to add tags to.
        public let resourceArn: String
        /// The tags to add to the resource. A tag is an array of key-value pairs. Tag keys can have a maximum character length of 128 characters, and tag values can have a maximum length of 256 characters.
        public let tags: [TagRef]

        @inlinable
        public init(resourceArn: String, tags: [TagRef]) {
            self.resourceArn = resourceArn
            self.tags = tags
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.resourceArn, key: "resourceArn")
            try container.encode(self.tags, forKey: .tags)
        }

        public func validate(name: String) throws {
            try self.tags.forEach {
                try $0.validate(name: "\(name).tags[]")
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 50)
        }

        private enum CodingKeys: String, CodingKey {
            case tags = "tags"
        }
    }

    public struct TagResourceOutput: AWSDecodableShape {
        public init() {}
    }

    public struct TcpRoute: AWSEncodableShape & AWSDecodableShape {
        /// The action to take if a match is determined.
        public let action: TcpRouteAction
        /// An object that represents the criteria for determining a request match.
        public let match: TcpRouteMatch?
        /// An object that represents types of timeouts.
        public let timeout: TcpTimeout?

        @inlinable
        public init(action: TcpRouteAction, match: TcpRouteMatch? = nil, timeout: TcpTimeout? = nil) {
            self.action = action
            self.match = match
            self.timeout = timeout
        }

        public func validate(name: String) throws {
            try self.action.validate(name: "\(name).action")
            try self.match?.validate(name: "\(name).match")
            try self.timeout?.validate(name: "\(name).timeout")
        }

        private enum CodingKeys: String, CodingKey {
            case action = "action"
            case match = "match"
            case timeout = "timeout"
        }
    }

    public struct TcpRouteAction: AWSEncodableShape & AWSDecodableShape {
        /// An object that represents the targets that traffic is routed to when a request matches the route.
        public let weightedTargets: [WeightedTarget]

        @inlinable
        public init(weightedTargets: [WeightedTarget]) {
            self.weightedTargets = weightedTargets
        }

        public func validate(name: String) throws {
            try self.weightedTargets.forEach {
                try $0.validate(name: "\(name).weightedTargets[]")
            }
            try self.validate(self.weightedTargets, name: "weightedTargets", parent: name, max: 10)
            try self.validate(self.weightedTargets, name: "weightedTargets", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case weightedTargets = "weightedTargets"
        }
    }

    public struct TcpRouteMatch: AWSEncodableShape & AWSDecodableShape {
        /// The port number to match on.
        public let port: Int?

        @inlinable
        public init(port: Int? = nil) {
            self.port = port
        }

        public func validate(name: String) throws {
            try self.validate(self.port, name: "port", parent: name, max: 65535)
            try self.validate(self.port, name: "port", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case port = "port"
        }
    }

    public struct TcpTimeout: AWSEncodableShape & AWSDecodableShape {
        /// An object that represents an idle timeout. An idle timeout bounds the amount of time that a connection may be idle. The default value is none.
        public let idle: Duration?

        @inlinable
        public init(idle: Duration? = nil) {
            self.idle = idle
        }

        public func validate(name: String) throws {
            try self.idle?.validate(name: "\(name).idle")
        }

        private enum CodingKeys: String, CodingKey {
            case idle = "idle"
        }
    }

    public struct TlsValidationContext: AWSEncodableShape & AWSDecodableShape {
        /// A reference to an object that represents the SANs for a Transport Layer Security (TLS) validation context. If you don't specify SANs on the terminating mesh endpoint, the Envoy proxy for that node doesn't verify the SAN on a peer client certificate. If you don't specify SANs on the originating mesh endpoint, the SAN on the certificate provided by the terminating endpoint must match the mesh endpoint service discovery configuration. Since SPIRE vended certificates have a SPIFFE ID as a name, you must set the SAN since the name doesn't match the service discovery name.
        public let subjectAlternativeNames: SubjectAlternativeNames?
        /// A reference to where to retrieve the trust chain when validating a peers Transport Layer Security (TLS) certificate.
        public let trust: TlsValidationContextTrust

        @inlinable
        public init(subjectAlternativeNames: SubjectAlternativeNames? = nil, trust: TlsValidationContextTrust) {
            self.subjectAlternativeNames = subjectAlternativeNames
            self.trust = trust
        }

        public func validate(name: String) throws {
            try self.subjectAlternativeNames?.validate(name: "\(name).subjectAlternativeNames")
            try self.trust.validate(name: "\(name).trust")
        }

        private enum CodingKeys: String, CodingKey {
            case subjectAlternativeNames = "subjectAlternativeNames"
            case trust = "trust"
        }
    }

    public struct TlsValidationContextAcmTrust: AWSEncodableShape & AWSDecodableShape {
        /// One or more ACM Amazon Resource Name (ARN)s.
        public let certificateAuthorityArns: [String]

        @inlinable
        public init(certificateAuthorityArns: [String]) {
            self.certificateAuthorityArns = certificateAuthorityArns
        }

        public func validate(name: String) throws {
            try self.validate(self.certificateAuthorityArns, name: "certificateAuthorityArns", parent: name, max: 3)
            try self.validate(self.certificateAuthorityArns, name: "certificateAuthorityArns", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case certificateAuthorityArns = "certificateAuthorityArns"
        }
    }

    public struct TlsValidationContextFileTrust: AWSEncodableShape & AWSDecodableShape {
        /// The certificate trust chain for a certificate stored on the file system of the virtual node that the proxy is running on.
        public let certificateChain: String

        @inlinable
        public init(certificateChain: String) {
            self.certificateChain = certificateChain
        }

        public func validate(name: String) throws {
            try self.validate(self.certificateChain, name: "certificateChain", parent: name, max: 255)
            try self.validate(self.certificateChain, name: "certificateChain", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case certificateChain = "certificateChain"
        }
    }

    public struct TlsValidationContextSdsTrust: AWSEncodableShape & AWSDecodableShape {
        /// A reference to an object that represents the name of the secret for a Transport Layer Security (TLS) Secret Discovery Service validation context trust.
        public let secretName: String

        @inlinable
        public init(secretName: String) {
            self.secretName = secretName
        }

        private enum CodingKeys: String, CodingKey {
            case secretName = "secretName"
        }
    }

    public struct UntagResourceInput: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the resource to delete tags from.
        public let resourceArn: String
        /// The keys of the tags to be removed.
        public let tagKeys: [String]

        @inlinable
        public init(resourceArn: String, tagKeys: [String]) {
            self.resourceArn = resourceArn
            self.tagKeys = tagKeys
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.resourceArn, key: "resourceArn")
            try container.encode(self.tagKeys, forKey: .tagKeys)
        }

        public func validate(name: String) throws {
            try self.tagKeys.forEach {
                try validate($0, name: "tagKeys[]", parent: name, max: 128)
                try validate($0, name: "tagKeys[]", parent: name, min: 1)
            }
            try self.validate(self.tagKeys, name: "tagKeys", parent: name, max: 50)
        }

        private enum CodingKeys: String, CodingKey {
            case tagKeys = "tagKeys"
        }
    }

    public struct UntagResourceOutput: AWSDecodableShape {
        public init() {}
    }

    public struct UpdateGatewayRouteInput: AWSEncodableShape {
        /// Unique, case-sensitive identifier that you provide to ensure the idempotency of the
        /// request. Up to 36 letters, numbers, hyphens, and underscores are allowed.
        public let clientToken: String?
        /// The name of the gateway route to update.
        public let gatewayRouteName: String
        /// The name of the service mesh that the gateway route resides in.
        public let meshName: String
        /// The Amazon Web Services IAM account ID of the service mesh owner. If the account ID is not your own, then it's the ID of the account that shared the mesh with your account. For more information about mesh sharing, see Working with shared meshes.
        public let meshOwner: String?
        /// The new gateway route specification to apply. This overwrites the existing data.
        public let spec: GatewayRouteSpec
        /// The name of the virtual gateway that the gateway route is associated with.
        public let virtualGatewayName: String

        @inlinable
        public init(clientToken: String? = UpdateGatewayRouteInput.idempotencyToken(), gatewayRouteName: String, meshName: String, meshOwner: String? = nil, spec: GatewayRouteSpec, virtualGatewayName: String) {
            self.clientToken = clientToken
            self.gatewayRouteName = gatewayRouteName
            self.meshName = meshName
            self.meshOwner = meshOwner
            self.spec = spec
            self.virtualGatewayName = virtualGatewayName
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.clientToken, forKey: .clientToken)
            request.encodePath(self.gatewayRouteName, key: "gatewayRouteName")
            request.encodePath(self.meshName, key: "meshName")
            request.encodeQuery(self.meshOwner, key: "meshOwner")
            try container.encode(self.spec, forKey: .spec)
            request.encodePath(self.virtualGatewayName, key: "virtualGatewayName")
        }

        public func validate(name: String) throws {
            try self.validate(self.gatewayRouteName, name: "gatewayRouteName", parent: name, max: 255)
            try self.validate(self.gatewayRouteName, name: "gatewayRouteName", parent: name, min: 1)
            try self.validate(self.meshName, name: "meshName", parent: name, max: 255)
            try self.validate(self.meshName, name: "meshName", parent: name, min: 1)
            try self.validate(self.meshOwner, name: "meshOwner", parent: name, max: 12)
            try self.validate(self.meshOwner, name: "meshOwner", parent: name, min: 12)
            try self.spec.validate(name: "\(name).spec")
            try self.validate(self.virtualGatewayName, name: "virtualGatewayName", parent: name, max: 255)
            try self.validate(self.virtualGatewayName, name: "virtualGatewayName", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "clientToken"
            case spec = "spec"
        }
    }

    public struct UpdateGatewayRouteOutput: AWSDecodableShape {
        /// A full description of the gateway route that was updated.
        public let gatewayRoute: GatewayRouteData

        @inlinable
        public init(gatewayRoute: GatewayRouteData) {
            self.gatewayRoute = gatewayRoute
        }

        public init(from decoder: Decoder) throws {
            let container = try decoder.singleValueContainer()
            self.gatewayRoute = try container.decode(GatewayRouteData.self)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct UpdateMeshInput: AWSEncodableShape {
        /// Unique, case-sensitive identifier that you provide to ensure the idempotency of the
        /// request. Up to 36 letters, numbers, hyphens, and underscores are allowed.
        public let clientToken: String?
        /// The name of the service mesh to update.
        public let meshName: String
        /// The service mesh specification to apply.
        public let spec: MeshSpec?

        @inlinable
        public init(clientToken: String? = UpdateMeshInput.idempotencyToken(), meshName: String, spec: MeshSpec? = nil) {
            self.clientToken = clientToken
            self.meshName = meshName
            self.spec = spec
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.clientToken, forKey: .clientToken)
            request.encodePath(self.meshName, key: "meshName")
            try container.encodeIfPresent(self.spec, forKey: .spec)
        }

        public func validate(name: String) throws {
            try self.validate(self.meshName, name: "meshName", parent: name, max: 255)
            try self.validate(self.meshName, name: "meshName", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "clientToken"
            case spec = "spec"
        }
    }

    public struct UpdateMeshOutput: AWSDecodableShape {
        public let mesh: MeshData

        @inlinable
        public init(mesh: MeshData) {
            self.mesh = mesh
        }

        public init(from decoder: Decoder) throws {
            let container = try decoder.singleValueContainer()
            self.mesh = try container.decode(MeshData.self)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct UpdateRouteInput: AWSEncodableShape {
        /// Unique, case-sensitive identifier that you provide to ensure the idempotency of the
        /// request. Up to 36 letters, numbers, hyphens, and underscores are allowed.
        public let clientToken: String?
        /// The name of the service mesh that the route resides in.
        public let meshName: String
        /// The Amazon Web Services IAM account ID of the service mesh owner. If the account ID is not your own, then it's the ID of the account that shared the mesh with your account. For more information about mesh sharing, see Working with shared meshes.
        public let meshOwner: String?
        /// The name of the route to update.
        public let routeName: String
        /// The new route specification to apply. This overwrites the existing data.
        public let spec: RouteSpec
        /// The name of the virtual router that the route is associated with.
        public let virtualRouterName: String

        @inlinable
        public init(clientToken: String? = UpdateRouteInput.idempotencyToken(), meshName: String, meshOwner: String? = nil, routeName: String, spec: RouteSpec, virtualRouterName: String) {
            self.clientToken = clientToken
            self.meshName = meshName
            self.meshOwner = meshOwner
            self.routeName = routeName
            self.spec = spec
            self.virtualRouterName = virtualRouterName
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.clientToken, forKey: .clientToken)
            request.encodePath(self.meshName, key: "meshName")
            request.encodeQuery(self.meshOwner, key: "meshOwner")
            request.encodePath(self.routeName, key: "routeName")
            try container.encode(self.spec, forKey: .spec)
            request.encodePath(self.virtualRouterName, key: "virtualRouterName")
        }

        public func validate(name: String) throws {
            try self.validate(self.meshName, name: "meshName", parent: name, max: 255)
            try self.validate(self.meshName, name: "meshName", parent: name, min: 1)
            try self.validate(self.meshOwner, name: "meshOwner", parent: name, max: 12)
            try self.validate(self.meshOwner, name: "meshOwner", parent: name, min: 12)
            try self.validate(self.routeName, name: "routeName", parent: name, max: 255)
            try self.validate(self.routeName, name: "routeName", parent: name, min: 1)
            try self.spec.validate(name: "\(name).spec")
            try self.validate(self.virtualRouterName, name: "virtualRouterName", parent: name, max: 255)
            try self.validate(self.virtualRouterName, name: "virtualRouterName", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "clientToken"
            case spec = "spec"
        }
    }

    public struct UpdateRouteOutput: AWSDecodableShape {
        /// A full description of the route that was updated.
        public let route: RouteData

        @inlinable
        public init(route: RouteData) {
            self.route = route
        }

        public init(from decoder: Decoder) throws {
            let container = try decoder.singleValueContainer()
            self.route = try container.decode(RouteData.self)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct UpdateVirtualGatewayInput: AWSEncodableShape {
        /// Unique, case-sensitive identifier that you provide to ensure the idempotency of the
        /// request. Up to 36 letters, numbers, hyphens, and underscores are allowed.
        public let clientToken: String?
        /// The name of the service mesh that the virtual gateway resides in.
        public let meshName: String
        /// The Amazon Web Services IAM account ID of the service mesh owner. If the account ID is not your own, then it's the ID of the account that shared the mesh with your account. For more information about mesh sharing, see Working with shared meshes.
        public let meshOwner: String?
        /// The new virtual gateway specification to apply. This overwrites the existing data.
        public let spec: VirtualGatewaySpec
        /// The name of the virtual gateway to update.
        public let virtualGatewayName: String

        @inlinable
        public init(clientToken: String? = UpdateVirtualGatewayInput.idempotencyToken(), meshName: String, meshOwner: String? = nil, spec: VirtualGatewaySpec, virtualGatewayName: String) {
            self.clientToken = clientToken
            self.meshName = meshName
            self.meshOwner = meshOwner
            self.spec = spec
            self.virtualGatewayName = virtualGatewayName
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.clientToken, forKey: .clientToken)
            request.encodePath(self.meshName, key: "meshName")
            request.encodeQuery(self.meshOwner, key: "meshOwner")
            try container.encode(self.spec, forKey: .spec)
            request.encodePath(self.virtualGatewayName, key: "virtualGatewayName")
        }

        public func validate(name: String) throws {
            try self.validate(self.meshName, name: "meshName", parent: name, max: 255)
            try self.validate(self.meshName, name: "meshName", parent: name, min: 1)
            try self.validate(self.meshOwner, name: "meshOwner", parent: name, max: 12)
            try self.validate(self.meshOwner, name: "meshOwner", parent: name, min: 12)
            try self.spec.validate(name: "\(name).spec")
            try self.validate(self.virtualGatewayName, name: "virtualGatewayName", parent: name, max: 255)
            try self.validate(self.virtualGatewayName, name: "virtualGatewayName", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "clientToken"
            case spec = "spec"
        }
    }

    public struct UpdateVirtualGatewayOutput: AWSDecodableShape {
        /// A full description of the virtual gateway that was updated.
        public let virtualGateway: VirtualGatewayData

        @inlinable
        public init(virtualGateway: VirtualGatewayData) {
            self.virtualGateway = virtualGateway
        }

        public init(from decoder: Decoder) throws {
            let container = try decoder.singleValueContainer()
            self.virtualGateway = try container.decode(VirtualGatewayData.self)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct UpdateVirtualNodeInput: AWSEncodableShape {
        /// Unique, case-sensitive identifier that you provide to ensure the idempotency of the
        /// request. Up to 36 letters, numbers, hyphens, and underscores are allowed.
        public let clientToken: String?
        /// The name of the service mesh that the virtual node resides in.
        public let meshName: String
        /// The Amazon Web Services IAM account ID of the service mesh owner. If the account ID is not your own, then it's the ID of the account that shared the mesh with your account. For more information about mesh sharing, see Working with shared meshes.
        public let meshOwner: String?
        /// The new virtual node specification to apply. This overwrites the existing data.
        public let spec: VirtualNodeSpec
        /// The name of the virtual node to update.
        public let virtualNodeName: String

        @inlinable
        public init(clientToken: String? = UpdateVirtualNodeInput.idempotencyToken(), meshName: String, meshOwner: String? = nil, spec: VirtualNodeSpec, virtualNodeName: String) {
            self.clientToken = clientToken
            self.meshName = meshName
            self.meshOwner = meshOwner
            self.spec = spec
            self.virtualNodeName = virtualNodeName
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.clientToken, forKey: .clientToken)
            request.encodePath(self.meshName, key: "meshName")
            request.encodeQuery(self.meshOwner, key: "meshOwner")
            try container.encode(self.spec, forKey: .spec)
            request.encodePath(self.virtualNodeName, key: "virtualNodeName")
        }

        public func validate(name: String) throws {
            try self.validate(self.meshName, name: "meshName", parent: name, max: 255)
            try self.validate(self.meshName, name: "meshName", parent: name, min: 1)
            try self.validate(self.meshOwner, name: "meshOwner", parent: name, max: 12)
            try self.validate(self.meshOwner, name: "meshOwner", parent: name, min: 12)
            try self.spec.validate(name: "\(name).spec")
            try self.validate(self.virtualNodeName, name: "virtualNodeName", parent: name, max: 255)
            try self.validate(self.virtualNodeName, name: "virtualNodeName", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "clientToken"
            case spec = "spec"
        }
    }

    public struct UpdateVirtualNodeOutput: AWSDecodableShape {
        /// A full description of the virtual node that was updated.
        public let virtualNode: VirtualNodeData

        @inlinable
        public init(virtualNode: VirtualNodeData) {
            self.virtualNode = virtualNode
        }

        public init(from decoder: Decoder) throws {
            let container = try decoder.singleValueContainer()
            self.virtualNode = try container.decode(VirtualNodeData.self)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct UpdateVirtualRouterInput: AWSEncodableShape {
        /// Unique, case-sensitive identifier that you provide to ensure the idempotency of the
        /// request. Up to 36 letters, numbers, hyphens, and underscores are allowed.
        public let clientToken: String?
        /// The name of the service mesh that the virtual router resides in.
        public let meshName: String
        /// The Amazon Web Services IAM account ID of the service mesh owner. If the account ID is not your own, then it's the ID of the account that shared the mesh with your account. For more information about mesh sharing, see Working with shared meshes.
        public let meshOwner: String?
        /// The new virtual router specification to apply. This overwrites the existing data.
        public let spec: VirtualRouterSpec
        /// The name of the virtual router to update.
        public let virtualRouterName: String

        @inlinable
        public init(clientToken: String? = UpdateVirtualRouterInput.idempotencyToken(), meshName: String, meshOwner: String? = nil, spec: VirtualRouterSpec, virtualRouterName: String) {
            self.clientToken = clientToken
            self.meshName = meshName
            self.meshOwner = meshOwner
            self.spec = spec
            self.virtualRouterName = virtualRouterName
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.clientToken, forKey: .clientToken)
            request.encodePath(self.meshName, key: "meshName")
            request.encodeQuery(self.meshOwner, key: "meshOwner")
            try container.encode(self.spec, forKey: .spec)
            request.encodePath(self.virtualRouterName, key: "virtualRouterName")
        }

        public func validate(name: String) throws {
            try self.validate(self.meshName, name: "meshName", parent: name, max: 255)
            try self.validate(self.meshName, name: "meshName", parent: name, min: 1)
            try self.validate(self.meshOwner, name: "meshOwner", parent: name, max: 12)
            try self.validate(self.meshOwner, name: "meshOwner", parent: name, min: 12)
            try self.spec.validate(name: "\(name).spec")
            try self.validate(self.virtualRouterName, name: "virtualRouterName", parent: name, max: 255)
            try self.validate(self.virtualRouterName, name: "virtualRouterName", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "clientToken"
            case spec = "spec"
        }
    }

    public struct UpdateVirtualRouterOutput: AWSDecodableShape {
        /// A full description of the virtual router that was updated.
        public let virtualRouter: VirtualRouterData

        @inlinable
        public init(virtualRouter: VirtualRouterData) {
            self.virtualRouter = virtualRouter
        }

        public init(from decoder: Decoder) throws {
            let container = try decoder.singleValueContainer()
            self.virtualRouter = try container.decode(VirtualRouterData.self)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct UpdateVirtualServiceInput: AWSEncodableShape {
        /// Unique, case-sensitive identifier that you provide to ensure the idempotency of the
        /// request. Up to 36 letters, numbers, hyphens, and underscores are allowed.
        public let clientToken: String?
        /// The name of the service mesh that the virtual service resides in.
        public let meshName: String
        /// The Amazon Web Services IAM account ID of the service mesh owner. If the account ID is not your own, then it's the ID of the account that shared the mesh with your account. For more information about mesh sharing, see Working with shared meshes.
        public let meshOwner: String?
        /// The new virtual service specification to apply. This overwrites the existing data.
        public let spec: VirtualServiceSpec
        /// The name of the virtual service to update.
        public let virtualServiceName: String

        @inlinable
        public init(clientToken: String? = UpdateVirtualServiceInput.idempotencyToken(), meshName: String, meshOwner: String? = nil, spec: VirtualServiceSpec, virtualServiceName: String) {
            self.clientToken = clientToken
            self.meshName = meshName
            self.meshOwner = meshOwner
            self.spec = spec
            self.virtualServiceName = virtualServiceName
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.clientToken, forKey: .clientToken)
            request.encodePath(self.meshName, key: "meshName")
            request.encodeQuery(self.meshOwner, key: "meshOwner")
            try container.encode(self.spec, forKey: .spec)
            request.encodePath(self.virtualServiceName, key: "virtualServiceName")
        }

        public func validate(name: String) throws {
            try self.validate(self.meshName, name: "meshName", parent: name, max: 255)
            try self.validate(self.meshName, name: "meshName", parent: name, min: 1)
            try self.validate(self.meshOwner, name: "meshOwner", parent: name, max: 12)
            try self.validate(self.meshOwner, name: "meshOwner", parent: name, min: 12)
            try self.spec.validate(name: "\(name).spec")
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "clientToken"
            case spec = "spec"
        }
    }

    public struct UpdateVirtualServiceOutput: AWSDecodableShape {
        /// A full description of the virtual service that was updated.
        public let virtualService: VirtualServiceData

        @inlinable
        public init(virtualService: VirtualServiceData) {
            self.virtualService = virtualService
        }

        public init(from decoder: Decoder) throws {
            let container = try decoder.singleValueContainer()
            self.virtualService = try container.decode(VirtualServiceData.self)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct VirtualGatewayBackendDefaults: AWSEncodableShape & AWSDecodableShape {
        /// A reference to an object that represents a client policy.
        public let clientPolicy: VirtualGatewayClientPolicy?

        @inlinable
        public init(clientPolicy: VirtualGatewayClientPolicy? = nil) {
            self.clientPolicy = clientPolicy
        }

        public func validate(name: String) throws {
            try self.clientPolicy?.validate(name: "\(name).clientPolicy")
        }

        private enum CodingKeys: String, CodingKey {
            case clientPolicy = "clientPolicy"
        }
    }

    public struct VirtualGatewayClientPolicy: AWSEncodableShape & AWSDecodableShape {
        /// A reference to an object that represents a Transport Layer Security (TLS) client policy.
        public let tls: VirtualGatewayClientPolicyTls?

        @inlinable
        public init(tls: VirtualGatewayClientPolicyTls? = nil) {
            self.tls = tls
        }

        public func validate(name: String) throws {
            try self.tls?.validate(name: "\(name).tls")
        }

        private enum CodingKeys: String, CodingKey {
            case tls = "tls"
        }
    }

    public struct VirtualGatewayClientPolicyTls: AWSEncodableShape & AWSDecodableShape {
        /// A reference to an object that represents a virtual gateway's client's Transport Layer Security (TLS) certificate.
        public let certificate: VirtualGatewayClientTlsCertificate?
        /// Whether the policy is enforced. The default is True, if a value isn't specified.
        public let enforce: Bool?
        /// One or more ports that the policy is enforced for.
        public let ports: [Int]?
        /// A reference to an object that represents a Transport Layer Security (TLS) validation context.
        public let validation: VirtualGatewayTlsValidationContext

        @inlinable
        public init(certificate: VirtualGatewayClientTlsCertificate? = nil, enforce: Bool? = nil, ports: [Int]? = nil, validation: VirtualGatewayTlsValidationContext) {
            self.certificate = certificate
            self.enforce = enforce
            self.ports = ports
            self.validation = validation
        }

        public func validate(name: String) throws {
            try self.certificate?.validate(name: "\(name).certificate")
            try self.ports?.forEach {
                try validate($0, name: "ports[]", parent: name, max: 65535)
                try validate($0, name: "ports[]", parent: name, min: 1)
            }
            try self.validation.validate(name: "\(name).validation")
        }

        private enum CodingKeys: String, CodingKey {
            case certificate = "certificate"
            case enforce = "enforce"
            case ports = "ports"
            case validation = "validation"
        }
    }

    public struct VirtualGatewayData: AWSDecodableShape {
        /// The name of the service mesh that the virtual gateway resides in.
        public let meshName: String
        public let metadata: ResourceMetadata
        /// The specifications of the virtual gateway.
        public let spec: VirtualGatewaySpec
        /// The current status of the virtual gateway.
        public let status: VirtualGatewayStatus
        /// The name of the virtual gateway.
        public let virtualGatewayName: String

        @inlinable
        public init(meshName: String, metadata: ResourceMetadata, spec: VirtualGatewaySpec, status: VirtualGatewayStatus, virtualGatewayName: String) {
            self.meshName = meshName
            self.metadata = metadata
            self.spec = spec
            self.status = status
            self.virtualGatewayName = virtualGatewayName
        }

        private enum CodingKeys: String, CodingKey {
            case meshName = "meshName"
            case metadata = "metadata"
            case spec = "spec"
            case status = "status"
            case virtualGatewayName = "virtualGatewayName"
        }
    }

    public struct VirtualGatewayFileAccessLog: AWSEncodableShape & AWSDecodableShape {
        /// The specified format for the virtual gateway access logs. It can be either json_format or text_format.
        public let format: LoggingFormat?
        /// The file path to write access logs to. You can use /dev/stdout to send access logs to standard out and configure your Envoy container to use a log driver, such as awslogs, to export the access logs to a log storage service such as Amazon CloudWatch Logs. You can also specify a path in the Envoy container's file system to write the files to disk.
        public let path: String

        @inlinable
        public init(format: LoggingFormat? = nil, path: String) {
            self.format = format
            self.path = path
        }

        public func validate(name: String) throws {
            try self.format?.validate(name: "\(name).format")
            try self.validate(self.path, name: "path", parent: name, max: 255)
            try self.validate(self.path, name: "path", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case format = "format"
            case path = "path"
        }
    }

    public struct VirtualGatewayGrpcConnectionPool: AWSEncodableShape & AWSDecodableShape {
        /// Maximum number of inflight requests Envoy can concurrently support across hosts in upstream cluster.
        public let maxRequests: Int

        @inlinable
        public init(maxRequests: Int) {
            self.maxRequests = maxRequests
        }

        public func validate(name: String) throws {
            try self.validate(self.maxRequests, name: "maxRequests", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case maxRequests = "maxRequests"
        }
    }

    public struct VirtualGatewayHealthCheckPolicy: AWSEncodableShape & AWSDecodableShape {
        /// The number of consecutive successful health checks that must occur before declaring the listener healthy.
        public let healthyThreshold: Int
        /// The time period in milliseconds between each health check execution.
        public let intervalMillis: Int64
        /// The destination path for the health check request. This value is only used if the specified protocol is HTTP or HTTP/2. For any other protocol, this value is ignored.
        public let path: String?
        /// The destination port for the health check request. This port must match the port defined in the PortMapping for the listener.
        public let port: Int?
        /// The protocol for the health check request. If you specify grpc, then your service must conform to the GRPC Health Checking Protocol.
        public let `protocol`: VirtualGatewayPortProtocol
        /// The amount of time to wait when receiving a response from the health check, in milliseconds.
        public let timeoutMillis: Int64
        /// The number of consecutive failed health checks that must occur before declaring a virtual gateway unhealthy.
        public let unhealthyThreshold: Int

        @inlinable
        public init(healthyThreshold: Int, intervalMillis: Int64, path: String? = nil, port: Int? = nil, protocol: VirtualGatewayPortProtocol, timeoutMillis: Int64, unhealthyThreshold: Int) {
            self.healthyThreshold = healthyThreshold
            self.intervalMillis = intervalMillis
            self.path = path
            self.port = port
            self.`protocol` = `protocol`
            self.timeoutMillis = timeoutMillis
            self.unhealthyThreshold = unhealthyThreshold
        }

        public func validate(name: String) throws {
            try self.validate(self.healthyThreshold, name: "healthyThreshold", parent: name, max: 10)
            try self.validate(self.healthyThreshold, name: "healthyThreshold", parent: name, min: 2)
            try self.validate(self.intervalMillis, name: "intervalMillis", parent: name, max: 300000)
            try self.validate(self.intervalMillis, name: "intervalMillis", parent: name, min: 5000)
            try self.validate(self.port, name: "port", parent: name, max: 65535)
            try self.validate(self.port, name: "port", parent: name, min: 1)
            try self.validate(self.timeoutMillis, name: "timeoutMillis", parent: name, max: 60000)
            try self.validate(self.timeoutMillis, name: "timeoutMillis", parent: name, min: 2000)
            try self.validate(self.unhealthyThreshold, name: "unhealthyThreshold", parent: name, max: 10)
            try self.validate(self.unhealthyThreshold, name: "unhealthyThreshold", parent: name, min: 2)
        }

        private enum CodingKeys: String, CodingKey {
            case healthyThreshold = "healthyThreshold"
            case intervalMillis = "intervalMillis"
            case path = "path"
            case port = "port"
            case `protocol` = "protocol"
            case timeoutMillis = "timeoutMillis"
            case unhealthyThreshold = "unhealthyThreshold"
        }
    }

    public struct VirtualGatewayHttp2ConnectionPool: AWSEncodableShape & AWSDecodableShape {
        /// Maximum number of inflight requests Envoy can concurrently support across hosts in upstream cluster.
        public let maxRequests: Int

        @inlinable
        public init(maxRequests: Int) {
            self.maxRequests = maxRequests
        }

        public func validate(name: String) throws {
            try self.validate(self.maxRequests, name: "maxRequests", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case maxRequests = "maxRequests"
        }
    }

    public struct VirtualGatewayHttpConnectionPool: AWSEncodableShape & AWSDecodableShape {
        /// Maximum number of outbound TCP connections Envoy can establish concurrently with all hosts in upstream cluster.
        public let maxConnections: Int
        /// Number of overflowing requests after max_connections Envoy will queue to upstream cluster.
        public let maxPendingRequests: Int?

        @inlinable
        public init(maxConnections: Int, maxPendingRequests: Int? = nil) {
            self.maxConnections = maxConnections
            self.maxPendingRequests = maxPendingRequests
        }

        public func validate(name: String) throws {
            try self.validate(self.maxConnections, name: "maxConnections", parent: name, min: 1)
            try self.validate(self.maxPendingRequests, name: "maxPendingRequests", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case maxConnections = "maxConnections"
            case maxPendingRequests = "maxPendingRequests"
        }
    }

    public struct VirtualGatewayListener: AWSEncodableShape & AWSDecodableShape {
        /// The connection pool information for the virtual gateway listener.
        public let connectionPool: VirtualGatewayConnectionPool?
        /// The health check information for the listener.
        public let healthCheck: VirtualGatewayHealthCheckPolicy?
        /// The port mapping information for the listener.
        public let portMapping: VirtualGatewayPortMapping
        /// A reference to an object that represents the Transport Layer Security (TLS) properties for the listener.
        public let tls: VirtualGatewayListenerTls?

        @inlinable
        public init(connectionPool: VirtualGatewayConnectionPool? = nil, healthCheck: VirtualGatewayHealthCheckPolicy? = nil, portMapping: VirtualGatewayPortMapping, tls: VirtualGatewayListenerTls? = nil) {
            self.connectionPool = connectionPool
            self.healthCheck = healthCheck
            self.portMapping = portMapping
            self.tls = tls
        }

        public func validate(name: String) throws {
            try self.connectionPool?.validate(name: "\(name).connectionPool")
            try self.healthCheck?.validate(name: "\(name).healthCheck")
            try self.portMapping.validate(name: "\(name).portMapping")
            try self.tls?.validate(name: "\(name).tls")
        }

        private enum CodingKeys: String, CodingKey {
            case connectionPool = "connectionPool"
            case healthCheck = "healthCheck"
            case portMapping = "portMapping"
            case tls = "tls"
        }
    }

    public struct VirtualGatewayListenerTls: AWSEncodableShape & AWSDecodableShape {
        /// An object that represents a Transport Layer Security (TLS) certificate.
        public let certificate: VirtualGatewayListenerTlsCertificate
        /// Specify one of the following modes.    STRICT  Listener only accepts connections with TLS enabled.     PERMISSIVE  Listener accepts connections with or without TLS enabled.    DISABLED  Listener only accepts connections without TLS.
        public let mode: VirtualGatewayListenerTlsMode
        /// A reference to an object that represents a virtual gateway's listener's Transport Layer Security (TLS) validation context.
        public let validation: VirtualGatewayListenerTlsValidationContext?

        @inlinable
        public init(certificate: VirtualGatewayListenerTlsCertificate, mode: VirtualGatewayListenerTlsMode, validation: VirtualGatewayListenerTlsValidationContext? = nil) {
            self.certificate = certificate
            self.mode = mode
            self.validation = validation
        }

        public func validate(name: String) throws {
            try self.certificate.validate(name: "\(name).certificate")
            try self.validation?.validate(name: "\(name).validation")
        }

        private enum CodingKeys: String, CodingKey {
            case certificate = "certificate"
            case mode = "mode"
            case validation = "validation"
        }
    }

    public struct VirtualGatewayListenerTlsAcmCertificate: AWSEncodableShape & AWSDecodableShape {
        /// The Amazon Resource Name (ARN) for the certificate. The certificate must meet specific requirements and you must have proxy authorization enabled. For more information, see Transport Layer Security (TLS).
        public let certificateArn: String

        @inlinable
        public init(certificateArn: String) {
            self.certificateArn = certificateArn
        }

        private enum CodingKeys: String, CodingKey {
            case certificateArn = "certificateArn"
        }
    }

    public struct VirtualGatewayListenerTlsFileCertificate: AWSEncodableShape & AWSDecodableShape {
        /// The certificate chain for the certificate.
        public let certificateChain: String
        /// The private key for a certificate stored on the file system of the mesh endpoint that the proxy is running on.
        public let privateKey: String

        @inlinable
        public init(certificateChain: String, privateKey: String) {
            self.certificateChain = certificateChain
            self.privateKey = privateKey
        }

        public func validate(name: String) throws {
            try self.validate(self.certificateChain, name: "certificateChain", parent: name, max: 255)
            try self.validate(self.certificateChain, name: "certificateChain", parent: name, min: 1)
            try self.validate(self.privateKey, name: "privateKey", parent: name, max: 255)
            try self.validate(self.privateKey, name: "privateKey", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case certificateChain = "certificateChain"
            case privateKey = "privateKey"
        }
    }

    public struct VirtualGatewayListenerTlsSdsCertificate: AWSEncodableShape & AWSDecodableShape {
        /// A reference to an object that represents the name of the secret secret requested from the Secret Discovery Service provider representing Transport Layer Security (TLS) materials like a certificate or certificate chain.
        public let secretName: String

        @inlinable
        public init(secretName: String) {
            self.secretName = secretName
        }

        private enum CodingKeys: String, CodingKey {
            case secretName = "secretName"
        }
    }

    public struct VirtualGatewayListenerTlsValidationContext: AWSEncodableShape & AWSDecodableShape {
        /// A reference to an object that represents the SANs for a virtual gateway listener's Transport Layer Security (TLS) validation context.
        public let subjectAlternativeNames: SubjectAlternativeNames?
        /// A reference to where to retrieve the trust chain when validating a peers Transport Layer Security (TLS) certificate.
        public let trust: VirtualGatewayListenerTlsValidationContextTrust

        @inlinable
        public init(subjectAlternativeNames: SubjectAlternativeNames? = nil, trust: VirtualGatewayListenerTlsValidationContextTrust) {
            self.subjectAlternativeNames = subjectAlternativeNames
            self.trust = trust
        }

        public func validate(name: String) throws {
            try self.subjectAlternativeNames?.validate(name: "\(name).subjectAlternativeNames")
            try self.trust.validate(name: "\(name).trust")
        }

        private enum CodingKeys: String, CodingKey {
            case subjectAlternativeNames = "subjectAlternativeNames"
            case trust = "trust"
        }
    }

    public struct VirtualGatewayLogging: AWSEncodableShape & AWSDecodableShape {
        /// The access log configuration.
        public let accessLog: VirtualGatewayAccessLog?

        @inlinable
        public init(accessLog: VirtualGatewayAccessLog? = nil) {
            self.accessLog = accessLog
        }

        public func validate(name: String) throws {
            try self.accessLog?.validate(name: "\(name).accessLog")
        }

        private enum CodingKeys: String, CodingKey {
            case accessLog = "accessLog"
        }
    }

    public struct VirtualGatewayPortMapping: AWSEncodableShape & AWSDecodableShape {
        /// The port used for the port mapping. Specify one protocol.
        public let port: Int
        /// The protocol used for the port mapping.
        public let `protocol`: VirtualGatewayPortProtocol

        @inlinable
        public init(port: Int, protocol: VirtualGatewayPortProtocol) {
            self.port = port
            self.`protocol` = `protocol`
        }

        public func validate(name: String) throws {
            try self.validate(self.port, name: "port", parent: name, max: 65535)
            try self.validate(self.port, name: "port", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case port = "port"
            case `protocol` = "protocol"
        }
    }

    public struct VirtualGatewayRef: AWSDecodableShape {
        /// The full Amazon Resource Name (ARN) for the resource.
        public let arn: String
        /// The Unix epoch timestamp in seconds for when the resource was created.
        public let createdAt: Date
        /// The Unix epoch timestamp in seconds for when the resource was last updated.
        public let lastUpdatedAt: Date
        /// The name of the service mesh that the resource resides in.
        public let meshName: String
        /// The Amazon Web Services IAM account ID of the service mesh owner. If the account ID is not your own, then it's the ID of the account that shared the mesh with your account. For more information about mesh sharing, see Working with shared meshes.
        public let meshOwner: String
        /// The Amazon Web Services IAM account ID of the resource owner. If the account ID is not your own, then it's the ID of the mesh owner or of another account that the mesh is shared with. For more information about mesh sharing, see Working with shared meshes.
        public let resourceOwner: String
        /// The version of the resource. Resources are created at version 1, and this version is incremented each time that they're updated.
        public let version: Int64
        /// The name of the resource.
        public let virtualGatewayName: String

        @inlinable
        public init(arn: String, createdAt: Date, lastUpdatedAt: Date, meshName: String, meshOwner: String, resourceOwner: String, version: Int64, virtualGatewayName: String) {
            self.arn = arn
            self.createdAt = createdAt
            self.lastUpdatedAt = lastUpdatedAt
            self.meshName = meshName
            self.meshOwner = meshOwner
            self.resourceOwner = resourceOwner
            self.version = version
            self.virtualGatewayName = virtualGatewayName
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case createdAt = "createdAt"
            case lastUpdatedAt = "lastUpdatedAt"
            case meshName = "meshName"
            case meshOwner = "meshOwner"
            case resourceOwner = "resourceOwner"
            case version = "version"
            case virtualGatewayName = "virtualGatewayName"
        }
    }

    public struct VirtualGatewaySpec: AWSEncodableShape & AWSDecodableShape {
        /// A reference to an object that represents the defaults for backends.
        public let backendDefaults: VirtualGatewayBackendDefaults?
        /// The listeners that the mesh endpoint is expected to receive inbound traffic from. You can specify one listener.
        public let listeners: [VirtualGatewayListener]
        public let logging: VirtualGatewayLogging?

        @inlinable
        public init(backendDefaults: VirtualGatewayBackendDefaults? = nil, listeners: [VirtualGatewayListener], logging: VirtualGatewayLogging? = nil) {
            self.backendDefaults = backendDefaults
            self.listeners = listeners
            self.logging = logging
        }

        public func validate(name: String) throws {
            try self.backendDefaults?.validate(name: "\(name).backendDefaults")
            try self.listeners.forEach {
                try $0.validate(name: "\(name).listeners[]")
            }
            try self.logging?.validate(name: "\(name).logging")
        }

        private enum CodingKeys: String, CodingKey {
            case backendDefaults = "backendDefaults"
            case listeners = "listeners"
            case logging = "logging"
        }
    }

    public struct VirtualGatewayStatus: AWSDecodableShape {
        /// The current status.
        public let status: VirtualGatewayStatusCode

        @inlinable
        public init(status: VirtualGatewayStatusCode) {
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case status = "status"
        }
    }

    public struct VirtualGatewayTlsValidationContext: AWSEncodableShape & AWSDecodableShape {
        /// A reference to an object that represents the SANs for a virtual gateway's listener's Transport Layer Security (TLS) validation context.
        public let subjectAlternativeNames: SubjectAlternativeNames?
        /// A reference to where to retrieve the trust chain when validating a peers Transport Layer Security (TLS) certificate.
        public let trust: VirtualGatewayTlsValidationContextTrust

        @inlinable
        public init(subjectAlternativeNames: SubjectAlternativeNames? = nil, trust: VirtualGatewayTlsValidationContextTrust) {
            self.subjectAlternativeNames = subjectAlternativeNames
            self.trust = trust
        }

        public func validate(name: String) throws {
            try self.subjectAlternativeNames?.validate(name: "\(name).subjectAlternativeNames")
            try self.trust.validate(name: "\(name).trust")
        }

        private enum CodingKeys: String, CodingKey {
            case subjectAlternativeNames = "subjectAlternativeNames"
            case trust = "trust"
        }
    }

    public struct VirtualGatewayTlsValidationContextAcmTrust: AWSEncodableShape & AWSDecodableShape {
        /// One or more ACM Amazon Resource Name (ARN)s.
        public let certificateAuthorityArns: [String]

        @inlinable
        public init(certificateAuthorityArns: [String]) {
            self.certificateAuthorityArns = certificateAuthorityArns
        }

        public func validate(name: String) throws {
            try self.validate(self.certificateAuthorityArns, name: "certificateAuthorityArns", parent: name, max: 3)
            try self.validate(self.certificateAuthorityArns, name: "certificateAuthorityArns", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case certificateAuthorityArns = "certificateAuthorityArns"
        }
    }

    public struct VirtualGatewayTlsValidationContextFileTrust: AWSEncodableShape & AWSDecodableShape {
        /// The certificate trust chain for a certificate stored on the file system of the virtual node that the proxy is running on.
        public let certificateChain: String

        @inlinable
        public init(certificateChain: String) {
            self.certificateChain = certificateChain
        }

        public func validate(name: String) throws {
            try self.validate(self.certificateChain, name: "certificateChain", parent: name, max: 255)
            try self.validate(self.certificateChain, name: "certificateChain", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case certificateChain = "certificateChain"
        }
    }

    public struct VirtualGatewayTlsValidationContextSdsTrust: AWSEncodableShape & AWSDecodableShape {
        /// A reference to an object that represents the name of the secret for a virtual gateway's Transport Layer Security (TLS) Secret Discovery Service validation context trust.
        public let secretName: String

        @inlinable
        public init(secretName: String) {
            self.secretName = secretName
        }

        private enum CodingKeys: String, CodingKey {
            case secretName = "secretName"
        }
    }

    public struct VirtualNodeData: AWSDecodableShape {
        /// The name of the service mesh that the virtual node resides in.
        public let meshName: String
        /// The associated metadata for the virtual node.
        public let metadata: ResourceMetadata
        /// The specifications of the virtual node.
        public let spec: VirtualNodeSpec
        /// The current status for the virtual node.
        public let status: VirtualNodeStatus
        /// The name of the virtual node.
        public let virtualNodeName: String

        @inlinable
        public init(meshName: String, metadata: ResourceMetadata, spec: VirtualNodeSpec, status: VirtualNodeStatus, virtualNodeName: String) {
            self.meshName = meshName
            self.metadata = metadata
            self.spec = spec
            self.status = status
            self.virtualNodeName = virtualNodeName
        }

        private enum CodingKeys: String, CodingKey {
            case meshName = "meshName"
            case metadata = "metadata"
            case spec = "spec"
            case status = "status"
            case virtualNodeName = "virtualNodeName"
        }
    }

    public struct VirtualNodeGrpcConnectionPool: AWSEncodableShape & AWSDecodableShape {
        /// Maximum number of inflight requests Envoy can concurrently support across hosts in upstream cluster.
        public let maxRequests: Int

        @inlinable
        public init(maxRequests: Int) {
            self.maxRequests = maxRequests
        }

        public func validate(name: String) throws {
            try self.validate(self.maxRequests, name: "maxRequests", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case maxRequests = "maxRequests"
        }
    }

    public struct VirtualNodeHttp2ConnectionPool: AWSEncodableShape & AWSDecodableShape {
        /// Maximum number of inflight requests Envoy can concurrently support across hosts in upstream cluster.
        public let maxRequests: Int

        @inlinable
        public init(maxRequests: Int) {
            self.maxRequests = maxRequests
        }

        public func validate(name: String) throws {
            try self.validate(self.maxRequests, name: "maxRequests", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case maxRequests = "maxRequests"
        }
    }

    public struct VirtualNodeHttpConnectionPool: AWSEncodableShape & AWSDecodableShape {
        /// Maximum number of outbound TCP connections Envoy can establish concurrently with all hosts in upstream cluster.
        public let maxConnections: Int
        /// Number of overflowing requests after max_connections Envoy will queue to upstream cluster.
        public let maxPendingRequests: Int?

        @inlinable
        public init(maxConnections: Int, maxPendingRequests: Int? = nil) {
            self.maxConnections = maxConnections
            self.maxPendingRequests = maxPendingRequests
        }

        public func validate(name: String) throws {
            try self.validate(self.maxConnections, name: "maxConnections", parent: name, min: 1)
            try self.validate(self.maxPendingRequests, name: "maxPendingRequests", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case maxConnections = "maxConnections"
            case maxPendingRequests = "maxPendingRequests"
        }
    }

    public struct VirtualNodeRef: AWSDecodableShape {
        /// The full Amazon Resource Name (ARN) for the virtual node.
        public let arn: String
        /// The Unix epoch timestamp in seconds for when the resource was created.
        public let createdAt: Date
        /// The Unix epoch timestamp in seconds for when the resource was last updated.
        public let lastUpdatedAt: Date
        /// The name of the service mesh that the virtual node resides in.
        public let meshName: String
        /// The Amazon Web Services IAM account ID of the service mesh owner. If the account ID is not your own, then it's the ID of the account that shared the mesh with your account. For more information about mesh sharing, see Working with shared meshes.
        public let meshOwner: String
        /// The Amazon Web Services IAM account ID of the resource owner. If the account ID is not your own, then it's the ID of the mesh owner or of another account that the mesh is shared with. For more information about mesh sharing, see Working with shared meshes.
        public let resourceOwner: String
        /// The version of the resource. Resources are created at version 1, and this version is incremented each time that they're updated.
        public let version: Int64
        /// The name of the virtual node.
        public let virtualNodeName: String

        @inlinable
        public init(arn: String, createdAt: Date, lastUpdatedAt: Date, meshName: String, meshOwner: String, resourceOwner: String, version: Int64, virtualNodeName: String) {
            self.arn = arn
            self.createdAt = createdAt
            self.lastUpdatedAt = lastUpdatedAt
            self.meshName = meshName
            self.meshOwner = meshOwner
            self.resourceOwner = resourceOwner
            self.version = version
            self.virtualNodeName = virtualNodeName
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case createdAt = "createdAt"
            case lastUpdatedAt = "lastUpdatedAt"
            case meshName = "meshName"
            case meshOwner = "meshOwner"
            case resourceOwner = "resourceOwner"
            case version = "version"
            case virtualNodeName = "virtualNodeName"
        }
    }

    public struct VirtualNodeServiceProvider: AWSEncodableShape & AWSDecodableShape {
        /// The name of the virtual node that is acting as a service provider.
        public let virtualNodeName: String

        @inlinable
        public init(virtualNodeName: String) {
            self.virtualNodeName = virtualNodeName
        }

        public func validate(name: String) throws {
            try self.validate(self.virtualNodeName, name: "virtualNodeName", parent: name, max: 255)
            try self.validate(self.virtualNodeName, name: "virtualNodeName", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case virtualNodeName = "virtualNodeName"
        }
    }

    public struct VirtualNodeSpec: AWSEncodableShape & AWSDecodableShape {
        /// A reference to an object that represents the defaults for backends.
        public let backendDefaults: BackendDefaults?
        /// The backends that the virtual node is expected to send outbound traffic to.
        public let backends: [Backend]?
        /// The listener that the virtual node is expected to receive inbound traffic from. You can specify one listener.
        public let listeners: [Listener]?
        /// The inbound and outbound access logging information for the virtual node.
        public let logging: Logging?
        /// The service discovery information for the virtual node. If your virtual node does not expect ingress traffic, you can omit this parameter. If you specify a listener, then you must specify service discovery information.
        public let serviceDiscovery: ServiceDiscovery?

        @inlinable
        public init(backendDefaults: BackendDefaults? = nil, backends: [Backend]? = nil, listeners: [Listener]? = nil, logging: Logging? = nil, serviceDiscovery: ServiceDiscovery? = nil) {
            self.backendDefaults = backendDefaults
            self.backends = backends
            self.listeners = listeners
            self.logging = logging
            self.serviceDiscovery = serviceDiscovery
        }

        public func validate(name: String) throws {
            try self.backendDefaults?.validate(name: "\(name).backendDefaults")
            try self.backends?.forEach {
                try $0.validate(name: "\(name).backends[]")
            }
            try self.listeners?.forEach {
                try $0.validate(name: "\(name).listeners[]")
            }
            try self.logging?.validate(name: "\(name).logging")
            try self.serviceDiscovery?.validate(name: "\(name).serviceDiscovery")
        }

        private enum CodingKeys: String, CodingKey {
            case backendDefaults = "backendDefaults"
            case backends = "backends"
            case listeners = "listeners"
            case logging = "logging"
            case serviceDiscovery = "serviceDiscovery"
        }
    }

    public struct VirtualNodeStatus: AWSDecodableShape {
        /// The current status of the virtual node.
        public let status: VirtualNodeStatusCode

        @inlinable
        public init(status: VirtualNodeStatusCode) {
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case status = "status"
        }
    }

    public struct VirtualNodeTcpConnectionPool: AWSEncodableShape & AWSDecodableShape {
        /// Maximum number of outbound TCP connections Envoy can establish concurrently with all hosts in upstream cluster.
        public let maxConnections: Int

        @inlinable
        public init(maxConnections: Int) {
            self.maxConnections = maxConnections
        }

        public func validate(name: String) throws {
            try self.validate(self.maxConnections, name: "maxConnections", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case maxConnections = "maxConnections"
        }
    }

    public struct VirtualRouterData: AWSDecodableShape {
        /// The name of the service mesh that the virtual router resides in.
        public let meshName: String
        /// The associated metadata for the virtual router.
        public let metadata: ResourceMetadata
        /// The specifications of the virtual router.
        public let spec: VirtualRouterSpec
        /// The current status of the virtual router.
        public let status: VirtualRouterStatus
        /// The name of the virtual router.
        public let virtualRouterName: String

        @inlinable
        public init(meshName: String, metadata: ResourceMetadata, spec: VirtualRouterSpec, status: VirtualRouterStatus, virtualRouterName: String) {
            self.meshName = meshName
            self.metadata = metadata
            self.spec = spec
            self.status = status
            self.virtualRouterName = virtualRouterName
        }

        private enum CodingKeys: String, CodingKey {
            case meshName = "meshName"
            case metadata = "metadata"
            case spec = "spec"
            case status = "status"
            case virtualRouterName = "virtualRouterName"
        }
    }

    public struct VirtualRouterListener: AWSEncodableShape & AWSDecodableShape {
        public let portMapping: PortMapping

        @inlinable
        public init(portMapping: PortMapping) {
            self.portMapping = portMapping
        }

        public func validate(name: String) throws {
            try self.portMapping.validate(name: "\(name).portMapping")
        }

        private enum CodingKeys: String, CodingKey {
            case portMapping = "portMapping"
        }
    }

    public struct VirtualRouterRef: AWSDecodableShape {
        /// The full Amazon Resource Name (ARN) for the virtual router.
        public let arn: String
        /// The Unix epoch timestamp in seconds for when the resource was created.
        public let createdAt: Date
        /// The Unix epoch timestamp in seconds for when the resource was last updated.
        public let lastUpdatedAt: Date
        /// The name of the service mesh that the virtual router resides in.
        public let meshName: String
        /// The Amazon Web Services IAM account ID of the service mesh owner. If the account ID is not your own, then it's the ID of the account that shared the mesh with your account. For more information about mesh sharing, see Working with shared meshes.
        public let meshOwner: String
        /// The Amazon Web Services IAM account ID of the resource owner. If the account ID is not your own, then it's the ID of the mesh owner or of another account that the mesh is shared with. For more information about mesh sharing, see Working with shared meshes.
        public let resourceOwner: String
        /// The version of the resource. Resources are created at version 1, and this version is incremented each time that they're updated.
        public let version: Int64
        /// The name of the virtual router.
        public let virtualRouterName: String

        @inlinable
        public init(arn: String, createdAt: Date, lastUpdatedAt: Date, meshName: String, meshOwner: String, resourceOwner: String, version: Int64, virtualRouterName: String) {
            self.arn = arn
            self.createdAt = createdAt
            self.lastUpdatedAt = lastUpdatedAt
            self.meshName = meshName
            self.meshOwner = meshOwner
            self.resourceOwner = resourceOwner
            self.version = version
            self.virtualRouterName = virtualRouterName
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case createdAt = "createdAt"
            case lastUpdatedAt = "lastUpdatedAt"
            case meshName = "meshName"
            case meshOwner = "meshOwner"
            case resourceOwner = "resourceOwner"
            case version = "version"
            case virtualRouterName = "virtualRouterName"
        }
    }

    public struct VirtualRouterServiceProvider: AWSEncodableShape & AWSDecodableShape {
        /// The name of the virtual router that is acting as a service provider.
        public let virtualRouterName: String

        @inlinable
        public init(virtualRouterName: String) {
            self.virtualRouterName = virtualRouterName
        }

        public func validate(name: String) throws {
            try self.validate(self.virtualRouterName, name: "virtualRouterName", parent: name, max: 255)
            try self.validate(self.virtualRouterName, name: "virtualRouterName", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case virtualRouterName = "virtualRouterName"
        }
    }

    public struct VirtualRouterSpec: AWSEncodableShape & AWSDecodableShape {
        /// The listeners that the virtual router is expected to receive inbound traffic from. You can specify one listener.
        public let listeners: [VirtualRouterListener]?

        @inlinable
        public init(listeners: [VirtualRouterListener]? = nil) {
            self.listeners = listeners
        }

        public func validate(name: String) throws {
            try self.listeners?.forEach {
                try $0.validate(name: "\(name).listeners[]")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case listeners = "listeners"
        }
    }

    public struct VirtualRouterStatus: AWSDecodableShape {
        /// The current status of the virtual router.
        public let status: VirtualRouterStatusCode

        @inlinable
        public init(status: VirtualRouterStatusCode) {
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case status = "status"
        }
    }

    public struct VirtualServiceBackend: AWSEncodableShape & AWSDecodableShape {
        /// A reference to an object that represents the client policy for a backend.
        public let clientPolicy: ClientPolicy?
        /// The name of the virtual service that is acting as a virtual node backend.
        public let virtualServiceName: String

        @inlinable
        public init(clientPolicy: ClientPolicy? = nil, virtualServiceName: String) {
            self.clientPolicy = clientPolicy
            self.virtualServiceName = virtualServiceName
        }

        public func validate(name: String) throws {
            try self.clientPolicy?.validate(name: "\(name).clientPolicy")
        }

        private enum CodingKeys: String, CodingKey {
            case clientPolicy = "clientPolicy"
            case virtualServiceName = "virtualServiceName"
        }
    }

    public struct VirtualServiceData: AWSDecodableShape {
        /// The name of the service mesh that the virtual service resides in.
        public let meshName: String
        public let metadata: ResourceMetadata
        /// The specifications of the virtual service.
        public let spec: VirtualServiceSpec
        /// The current status of the virtual service.
        public let status: VirtualServiceStatus
        /// The name of the virtual service.
        public let virtualServiceName: String

        @inlinable
        public init(meshName: String, metadata: ResourceMetadata, spec: VirtualServiceSpec, status: VirtualServiceStatus, virtualServiceName: String) {
            self.meshName = meshName
            self.metadata = metadata
            self.spec = spec
            self.status = status
            self.virtualServiceName = virtualServiceName
        }

        private enum CodingKeys: String, CodingKey {
            case meshName = "meshName"
            case metadata = "metadata"
            case spec = "spec"
            case status = "status"
            case virtualServiceName = "virtualServiceName"
        }
    }

    public struct VirtualServiceRef: AWSDecodableShape {
        /// The full Amazon Resource Name (ARN) for the virtual service.
        public let arn: String
        /// The Unix epoch timestamp in seconds for when the resource was created.
        public let createdAt: Date
        /// The Unix epoch timestamp in seconds for when the resource was last updated.
        public let lastUpdatedAt: Date
        /// The name of the service mesh that the virtual service resides in.
        public let meshName: String
        /// The Amazon Web Services IAM account ID of the service mesh owner. If the account ID is not your own, then it's the ID of the account that shared the mesh with your account. For more information about mesh sharing, see Working with shared meshes.
        public let meshOwner: String
        /// The Amazon Web Services IAM account ID of the resource owner. If the account ID is not your own, then it's the ID of the mesh owner or of another account that the mesh is shared with. For more information about mesh sharing, see Working with shared meshes.
        public let resourceOwner: String
        /// The version of the resource. Resources are created at version 1, and this version is incremented each time that they're updated.
        public let version: Int64
        /// The name of the virtual service.
        public let virtualServiceName: String

        @inlinable
        public init(arn: String, createdAt: Date, lastUpdatedAt: Date, meshName: String, meshOwner: String, resourceOwner: String, version: Int64, virtualServiceName: String) {
            self.arn = arn
            self.createdAt = createdAt
            self.lastUpdatedAt = lastUpdatedAt
            self.meshName = meshName
            self.meshOwner = meshOwner
            self.resourceOwner = resourceOwner
            self.version = version
            self.virtualServiceName = virtualServiceName
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case createdAt = "createdAt"
            case lastUpdatedAt = "lastUpdatedAt"
            case meshName = "meshName"
            case meshOwner = "meshOwner"
            case resourceOwner = "resourceOwner"
            case version = "version"
            case virtualServiceName = "virtualServiceName"
        }
    }

    public struct VirtualServiceSpec: AWSEncodableShape & AWSDecodableShape {
        /// The App Mesh object that is acting as the provider for a virtual service. You can specify a single virtual node or virtual router.
        public let provider: VirtualServiceProvider?

        @inlinable
        public init(provider: VirtualServiceProvider? = nil) {
            self.provider = provider
        }

        public func validate(name: String) throws {
            try self.provider?.validate(name: "\(name).provider")
        }

        private enum CodingKeys: String, CodingKey {
            case provider = "provider"
        }
    }

    public struct VirtualServiceStatus: AWSDecodableShape {
        /// The current status of the virtual service.
        public let status: VirtualServiceStatusCode

        @inlinable
        public init(status: VirtualServiceStatusCode) {
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case status = "status"
        }
    }

    public struct WeightedTarget: AWSEncodableShape & AWSDecodableShape {
        /// The targeted port of the weighted object.
        public let port: Int?
        /// The virtual node to associate with the weighted target.
        public let virtualNode: String
        /// The relative weight of the weighted target.
        public let weight: Int

        @inlinable
        public init(port: Int? = nil, virtualNode: String, weight: Int) {
            self.port = port
            self.virtualNode = virtualNode
            self.weight = weight
        }

        public func validate(name: String) throws {
            try self.validate(self.port, name: "port", parent: name, max: 65535)
            try self.validate(self.port, name: "port", parent: name, min: 1)
            try self.validate(self.virtualNode, name: "virtualNode", parent: name, max: 255)
            try self.validate(self.virtualNode, name: "virtualNode", parent: name, min: 1)
            try self.validate(self.weight, name: "weight", parent: name, max: 100)
            try self.validate(self.weight, name: "weight", parent: name, min: 0)
        }

        private enum CodingKeys: String, CodingKey {
            case port = "port"
            case virtualNode = "virtualNode"
            case weight = "weight"
        }
    }

    public struct AccessLog: AWSEncodableShape & AWSDecodableShape {
        /// The file object to send virtual node access logs to.
        public let file: FileAccessLog?

        @inlinable
        public init(file: FileAccessLog? = nil) {
            self.file = file
        }

        public func validate(name: String) throws {
            try self.file?.validate(name: "\(name).file")
        }

        private enum CodingKeys: String, CodingKey {
            case file = "file"
        }
    }

    public struct Backend: AWSEncodableShape & AWSDecodableShape {
        /// Specifies a virtual service to use as a backend.
        public let virtualService: VirtualServiceBackend?

        @inlinable
        public init(virtualService: VirtualServiceBackend? = nil) {
            self.virtualService = virtualService
        }

        public func validate(name: String) throws {
            try self.virtualService?.validate(name: "\(name).virtualService")
        }

        private enum CodingKeys: String, CodingKey {
            case virtualService = "virtualService"
        }
    }

    public struct VirtualGatewayAccessLog: AWSEncodableShape & AWSDecodableShape {
        /// The file object to send virtual gateway access logs to.
        public let file: VirtualGatewayFileAccessLog?

        @inlinable
        public init(file: VirtualGatewayFileAccessLog? = nil) {
            self.file = file
        }

        public func validate(name: String) throws {
            try self.file?.validate(name: "\(name).file")
        }

        private enum CodingKeys: String, CodingKey {
            case file = "file"
        }
    }
}

// MARK: - Errors

/// Error enum for AppMesh
public struct AppMeshErrorType: AWSErrorType {
    enum Code: String {
        case badRequestException = "BadRequestException"
        case conflictException = "ConflictException"
        case forbiddenException = "ForbiddenException"
        case internalServerErrorException = "InternalServerErrorException"
        case limitExceededException = "LimitExceededException"
        case notFoundException = "NotFoundException"
        case resourceInUseException = "ResourceInUseException"
        case serviceUnavailableException = "ServiceUnavailableException"
        case tooManyRequestsException = "TooManyRequestsException"
        case tooManyTagsException = "TooManyTagsException"
    }

    private let error: Code
    public let context: AWSErrorContext?

    /// initialize AppMesh
    public init?(errorCode: String, context: AWSErrorContext) {
        guard let error = Code(rawValue: errorCode) else { return nil }
        self.error = error
        self.context = context
    }

    internal init(_ error: Code) {
        self.error = error
        self.context = nil
    }

    /// return error code string
    public var errorCode: String { self.error.rawValue }

    /// The request syntax was malformed. Check your request syntax and try again.
    public static var badRequestException: Self { .init(.badRequestException) }
    /// The request contains a client token that was used for a previous update resource call with different specifications. Try the request again with a new client token.
    public static var conflictException: Self { .init(.conflictException) }
    /// You don't have permissions to perform this action.
    public static var forbiddenException: Self { .init(.forbiddenException) }
    /// The request processing has failed because of an unknown error, exception, or failure.
    public static var internalServerErrorException: Self { .init(.internalServerErrorException) }
    /// You have exceeded a service limit for your account. For more information, see Service Limits in the App Mesh User Guide.
    public static var limitExceededException: Self { .init(.limitExceededException) }
    /// The specified resource doesn't exist. Check your request syntax and try again.
    public static var notFoundException: Self { .init(.notFoundException) }
    /// You can't delete the specified resource because it's in use or required by another resource.
    public static var resourceInUseException: Self { .init(.resourceInUseException) }
    /// The request has failed due to a temporary failure of the service.
    public static var serviceUnavailableException: Self { .init(.serviceUnavailableException) }
    /// The maximum request rate permitted by the App Mesh APIs has been exceeded for your account. For best results, use an increasing or variable sleep interval between requests.
    public static var tooManyRequestsException: Self { .init(.tooManyRequestsException) }
    /// The request exceeds the maximum allowed number of tags allowed per resource. The current limit is 50 user tags per resource. You must reduce the number of tags in the request. None of the tags in this request were applied.
    public static var tooManyTagsException: Self { .init(.tooManyTagsException) }
}

extension AppMeshErrorType: Equatable {
    public static func == (lhs: AppMeshErrorType, rhs: AppMeshErrorType) -> Bool {
        lhs.error == rhs.error
    }
}

extension AppMeshErrorType: CustomStringConvertible {
    public var description: String {
        return "\(self.error.rawValue): \(self.message ?? "")"
    }
}
