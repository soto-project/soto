//===----------------------------------------------------------------------===//
//
// This source file is part of the Soto for AWS open source project
//
// Copyright (c) 2017-2024 the Soto project authors
// Licensed under Apache License v2.0
//
// See LICENSE.txt for license information
// See CONTRIBUTORS.txt for the list of Soto project authors
//
// SPDX-License-Identifier: Apache-2.0
//
//===----------------------------------------------------------------------===//

// THIS FILE IS AUTOMATICALLY GENERATED by https://github.com/soto-project/soto-codegenerator.
// DO NOT EDIT.

#if canImport(FoundationEssentials)
import FoundationEssentials
#else
import Foundation
#endif
@_spi(SotoInternal) import SotoCore

extension Odb {
    // MARK: Enums

    public enum Access: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case disabled = "DISABLED"
        case enabled = "ENABLED"
        public var description: String { return self.rawValue }
    }

    public enum ComputeModel: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case ecpu = "ECPU"
        case ocpu = "OCPU"
        public var description: String { return self.rawValue }
    }

    public enum DayOfWeekName: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case friday = "FRIDAY"
        case monday = "MONDAY"
        case saturday = "SATURDAY"
        case sunday = "SUNDAY"
        case thursday = "THURSDAY"
        case tuesday = "TUESDAY"
        case wednesday = "WEDNESDAY"
        public var description: String { return self.rawValue }
    }

    public enum DbNodeMaintenanceType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case vmdbRebootMigration = "VMDB_REBOOT_MIGRATION"
        public var description: String { return self.rawValue }
    }

    public enum DbNodeResourceStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case available = "AVAILABLE"
        case failed = "FAILED"
        case provisioning = "PROVISIONING"
        case starting = "STARTING"
        case stopped = "STOPPED"
        case stopping = "STOPPING"
        case terminated = "TERMINATED"
        case terminating = "TERMINATING"
        case updating = "UPDATING"
        public var description: String { return self.rawValue }
    }

    public enum DbServerPatchingStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case complete = "COMPLETE"
        case failed = "FAILED"
        case maintenanceInProgress = "MAINTENANCE_IN_PROGRESS"
        case scheduled = "SCHEDULED"
        public var description: String { return self.rawValue }
    }

    public enum DiskRedundancy: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case high = "HIGH"
        case normal = "NORMAL"
        public var description: String { return self.rawValue }
    }

    public enum IormLifecycleState: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case bootstrapping = "BOOTSTRAPPING"
        case disabled = "DISABLED"
        case enabled = "ENABLED"
        case failed = "FAILED"
        case updating = "UPDATING"
        public var description: String { return self.rawValue }
    }

    public enum LicenseModel: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case bringYourOwnLicense = "BRING_YOUR_OWN_LICENSE"
        case licenseIncluded = "LICENSE_INCLUDED"
        public var description: String { return self.rawValue }
    }

    public enum ManagedResourceStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case disabled = "DISABLED"
        case disabling = "DISABLING"
        case enabled = "ENABLED"
        case enabling = "ENABLING"
        public var description: String { return self.rawValue }
    }

    public enum MonthName: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case april = "APRIL"
        case august = "AUGUST"
        case december = "DECEMBER"
        case february = "FEBRUARY"
        case january = "JANUARY"
        case july = "JULY"
        case june = "JUNE"
        case march = "MARCH"
        case may = "MAY"
        case november = "NOVEMBER"
        case october = "OCTOBER"
        case september = "SEPTEMBER"
        public var description: String { return self.rawValue }
    }

    public enum Objective: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case auto = "AUTO"
        case balanced = "BALANCED"
        case basic = "BASIC"
        case highThroughput = "HIGH_THROUGHPUT"
        case lowLatency = "LOW_LATENCY"
        public var description: String { return self.rawValue }
    }

    public enum OciOnboardingStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case activating = "ACTIVATING"
        case active = "ACTIVE"
        case activeInHomeRegion = "ACTIVE_IN_HOME_REGION"
        case activeLimited = "ACTIVE_LIMITED"
        case canceled = "CANCELED"
        case failed = "FAILED"
        case notStarted = "NOT_STARTED"
        case pendingCustomerAction = "PENDING_CUSTOMER_ACTION"
        case pendingInitialization = "PENDING_INITIALIZATION"
        case pendingLinkGeneration = "PENDING_LINK_GENERATION"
        case publicOfferUnsupported = "PUBLIC_OFFER_UNSUPPORTED"
        case suspended = "SUSPENDED"
        public var description: String { return self.rawValue }
    }

    public enum PatchingModeType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case nonrolling = "NONROLLING"
        case rolling = "ROLLING"
        public var description: String { return self.rawValue }
    }

    public enum PreferenceType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case customPreference = "CUSTOM_PREFERENCE"
        case noPreference = "NO_PREFERENCE"
        public var description: String { return self.rawValue }
    }

    public enum ResourceStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case available = "AVAILABLE"
        case failed = "FAILED"
        case maintenanceInProgress = "MAINTENANCE_IN_PROGRESS"
        case provisioning = "PROVISIONING"
        case terminated = "TERMINATED"
        case terminating = "TERMINATING"
        case updating = "UPDATING"
        public var description: String { return self.rawValue }
    }

    public enum ShapeType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case amd = "AMD"
        case ampereFlexA1 = "AMPERE_FLEX_A1"
        case intel = "INTEL"
        case intelFlexX9 = "INTEL_FLEX_X9"
        public var description: String { return self.rawValue }
    }

    public enum ValidationExceptionReason: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case cannotParse = "cannotParse"
        case fieldValidationFailed = "fieldValidationFailed"
        case other = "other"
        case unknownOperation = "unknownOperation"
        public var description: String { return self.rawValue }
    }

    public enum VpcEndpointType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case servicenetwork = "SERVICENETWORK"
        public var description: String { return self.rawValue }
    }

    // MARK: Shapes

    public struct AcceptMarketplaceRegistrationInput: AWSEncodableShape {
        /// The registration token that's generated by Amazon Web Services Marketplace and sent to Oracle Database@Amazon Web Services.
        public let marketplaceRegistrationToken: String

        @inlinable
        public init(marketplaceRegistrationToken: String) {
            self.marketplaceRegistrationToken = marketplaceRegistrationToken
        }

        private enum CodingKeys: String, CodingKey {
            case marketplaceRegistrationToken = "marketplaceRegistrationToken"
        }
    }

    public struct AcceptMarketplaceRegistrationOutput: AWSDecodableShape {
        public init() {}
    }

    public struct AutonomousVirtualMachineSummary: AWSDecodableShape {
        /// The unique identifier of the Autonomous VM.
        public let autonomousVirtualMachineId: String?
        /// The IP address used by clients to connect to this Autonomous VM.
        public let clientIpAddress: String?
        /// The unique identifier of the Autonomous VM cluster containing this Autonomous VM.
        public let cloudAutonomousVmClusterId: String?
        /// The number of CPU cores allocated to this Autonomous VM.
        public let cpuCoreCount: Int?
        /// The amount of storage allocated to this Autonomous Virtual Machine, in gigabytes (GB).
        public let dbNodeStorageSizeInGBs: Int?
        /// The display name of the database server hosting this Autonomous VM.
        public let dbServerDisplayName: String?
        /// The unique identifier of the database server hosting this Autonomous VM.
        public let dbServerId: String?
        /// The amount of memory allocated to this Autonomous VM, in gigabytes (GB).
        public let memorySizeInGBs: Int?
        /// The Oracle Cloud Identifier (OCID) of the Autonomous VM.
        public let ocid: String?
        /// The name of the Oracle Cloud Infrastructure (OCI) resource anchor associated with this Autonomous VM.
        public let ociResourceAnchorName: String?
        /// The current status of the Autonomous VM.
        public let status: ResourceStatus?
        /// Additional information about the current status of the Autonomous VM, if applicable.
        public let statusReason: String?
        /// The name of the Autonomous VM.
        public let vmName: String?

        @inlinable
        public init(autonomousVirtualMachineId: String? = nil, clientIpAddress: String? = nil, cloudAutonomousVmClusterId: String? = nil, cpuCoreCount: Int? = nil, dbNodeStorageSizeInGBs: Int? = nil, dbServerDisplayName: String? = nil, dbServerId: String? = nil, memorySizeInGBs: Int? = nil, ocid: String? = nil, ociResourceAnchorName: String? = nil, status: ResourceStatus? = nil, statusReason: String? = nil, vmName: String? = nil) {
            self.autonomousVirtualMachineId = autonomousVirtualMachineId
            self.clientIpAddress = clientIpAddress
            self.cloudAutonomousVmClusterId = cloudAutonomousVmClusterId
            self.cpuCoreCount = cpuCoreCount
            self.dbNodeStorageSizeInGBs = dbNodeStorageSizeInGBs
            self.dbServerDisplayName = dbServerDisplayName
            self.dbServerId = dbServerId
            self.memorySizeInGBs = memorySizeInGBs
            self.ocid = ocid
            self.ociResourceAnchorName = ociResourceAnchorName
            self.status = status
            self.statusReason = statusReason
            self.vmName = vmName
        }

        private enum CodingKeys: String, CodingKey {
            case autonomousVirtualMachineId = "autonomousVirtualMachineId"
            case clientIpAddress = "clientIpAddress"
            case cloudAutonomousVmClusterId = "cloudAutonomousVmClusterId"
            case cpuCoreCount = "cpuCoreCount"
            case dbNodeStorageSizeInGBs = "dbNodeStorageSizeInGBs"
            case dbServerDisplayName = "dbServerDisplayName"
            case dbServerId = "dbServerId"
            case memorySizeInGBs = "memorySizeInGBs"
            case ocid = "ocid"
            case ociResourceAnchorName = "ociResourceAnchorName"
            case status = "status"
            case statusReason = "statusReason"
            case vmName = "vmName"
        }
    }

    public struct CloudAutonomousVmCluster: AWSDecodableShape {
        /// The percentage of data storage currently in use for Autonomous Databases in the Autonomous VM cluster.
        public let autonomousDataStoragePercentage: Float?
        /// The data storage size allocated for Autonomous Databases in the Autonomous VM cluster, in TB.
        public let autonomousDataStorageSizeInTBs: Double?
        /// The available data storage space for Autonomous Databases in the Autonomous VM cluster, in TB.
        public let availableAutonomousDataStorageSizeInTBs: Double?
        /// The number of Autonomous CDBs that you can create with the currently available storage.
        public let availableContainerDatabases: Int?
        /// The number of CPU cores available for allocation to Autonomous Databases.
        public let availableCpus: Float?
        /// The Amazon Resource Name (ARN) for the Autonomous VM cluster.
        public let cloudAutonomousVmClusterArn: String?
        /// The unique identifier of the Autonomous VM cluster.
        public let cloudAutonomousVmClusterId: String
        /// The unique identifier of the Cloud Exadata Infrastructure containing this Autonomous VM cluster.
        public let cloudExadataInfrastructureId: String?
        /// The compute model of the Autonomous VM cluster: ECPU or OCPU.
        public let computeModel: ComputeModel?
        /// The total number of CPU cores in the Autonomous VM cluster.
        public let cpuCoreCount: Int?
        /// The number of CPU cores enabled per node in the Autonomous VM cluster.
        public let cpuCoreCountPerNode: Int?
        /// The percentage of total CPU cores currently in use in the Autonomous VM cluster.
        public let cpuPercentage: Float?
        /// The date and time when the Autonomous VM cluster was created.
        public let createdAt: Date?
        /// The total data storage allocated to the Autonomous VM cluster, in GB.
        public let dataStorageSizeInGBs: Double?
        /// The total data storage allocated to the Autonomous VM cluster, in TB.
        public let dataStorageSizeInTBs: Double?
        /// The local node storage allocated to the Autonomous VM cluster, in gigabytes (GB).
        public let dbNodeStorageSizeInGBs: Int?
        /// The list of database servers associated with the Autonomous VM cluster.
        public let dbServers: [String]?
        /// The user-provided description of the Autonomous VM cluster.
        public let description: String?
        /// The display name of the Autonomous VM cluster.
        public let displayName: String?
        /// The domain name for the Autonomous VM cluster.
        public let domain: String?
        /// The minimum value to which you can scale down the Exadata storage, in TB.
        public let exadataStorageInTBsLowestScaledValue: Double?
        /// The hostname for the Autonomous VM cluster.
        public let hostname: String?
        /// Indicates whether mutual TLS (mTLS) authentication is enabled for the Autonomous VM cluster.
        public let isMtlsEnabledVmCluster: Bool?
        /// The Oracle license model that applies to the Autonomous VM cluster. Valid values are LICENSE_INCLUDED or BRING_YOUR_OWN_LICENSE.
        public let licenseModel: LicenseModel?
        /// The scheduling details for the maintenance window. Patching and system updates take place during the maintenance window.
        public let maintenanceWindow: MaintenanceWindow?
        /// The minimum value to which you can scale down the maximum number of Autonomous CDBs.
        public let maxAcdsLowestScaledValue: Int?
        /// The amount of memory allocated per Oracle Compute Unit, in GB.
        public let memoryPerOracleComputeUnitInGBs: Int?
        /// The total amount of memory allocated to the Autonomous VM cluster, in gigabytes (GB).
        public let memorySizeInGBs: Int?
        /// The number of database server nodes in the Autonomous VM cluster.
        public let nodeCount: Int?
        /// The number of Autonomous CDBs that can't be provisioned because of resource constraints.
        public let nonProvisionableAutonomousContainerDatabases: Int?
        /// The Oracle Cloud Identifier (OCID) of the Autonomous VM cluster.
        public let ocid: String?
        /// The name of the OCI resource anchor associated with this Autonomous VM cluster.
        public let ociResourceAnchorName: String?
        /// The URL for accessing the OCI console page for this Autonomous VM cluster.
        public let ociUrl: String?
        /// The unique identifier of the ODB network associated with this Autonomous VM cluster.
        public let odbNetworkId: String?
        /// The progress of the current operation on the Autonomous VM cluster, as a percentage.
        public let percentProgress: Float?
        /// The number of Autonomous CDBs that can be provisioned in the Autonomous VM cluster.
        public let provisionableAutonomousContainerDatabases: Int?
        /// The number of Autonomous CDBs currently provisioned in the Autonomous VM cluster.
        public let provisionedAutonomousContainerDatabases: Int?
        /// The number of CPU cores currently provisioned in the Autonomous VM cluster.
        public let provisionedCpus: Float?
        /// The number of CPU cores that can be reclaimed from terminated or scaled-down Autonomous Databases.
        public let reclaimableCpus: Float?
        /// The number of CPU cores reserved for system operations and redundancy.
        public let reservedCpus: Float?
        /// The SCAN listener port for non-TLS (TCP) protocol. The default is 1521.
        public let scanListenerPortNonTls: Int?
        /// The SCAN listener port for TLS (TCP) protocol. The default is 2484.
        public let scanListenerPortTls: Int?
        /// The shape of the Exadata infrastructure for the Autonomous VM cluster.
        public let shape: String?
        /// The current state of the Autonomous VM cluster. Possible values include CREATING, AVAILABLE, UPDATING, DELETING, DELETED, FAILED.
        public let status: ResourceStatus?
        /// Additional information about the current status of the Autonomous VM cluster.
        public let statusReason: String?
        /// The expiration date and time of the database SSL certificate.
        public let timeDatabaseSslCertificateExpires: Date?
        /// The expiration date and time of the Oracle REST Data Services (ORDS) certificate.
        public let timeOrdsCertificateExpires: Date?
        /// The time zone of the Autonomous VM cluster.
        public let timeZone: String?
        /// The total number of Autonomous Container Databases that can be created with the allocated local storage.
        public let totalContainerDatabases: Int?

        @inlinable
        public init(autonomousDataStoragePercentage: Float? = nil, autonomousDataStorageSizeInTBs: Double? = nil, availableAutonomousDataStorageSizeInTBs: Double? = nil, availableContainerDatabases: Int? = nil, availableCpus: Float? = nil, cloudAutonomousVmClusterArn: String? = nil, cloudAutonomousVmClusterId: String, cloudExadataInfrastructureId: String? = nil, computeModel: ComputeModel? = nil, cpuCoreCount: Int? = nil, cpuCoreCountPerNode: Int? = nil, cpuPercentage: Float? = nil, createdAt: Date? = nil, dataStorageSizeInGBs: Double? = nil, dataStorageSizeInTBs: Double? = nil, dbNodeStorageSizeInGBs: Int? = nil, dbServers: [String]? = nil, description: String? = nil, displayName: String? = nil, domain: String? = nil, exadataStorageInTBsLowestScaledValue: Double? = nil, hostname: String? = nil, isMtlsEnabledVmCluster: Bool? = nil, licenseModel: LicenseModel? = nil, maintenanceWindow: MaintenanceWindow? = nil, maxAcdsLowestScaledValue: Int? = nil, memoryPerOracleComputeUnitInGBs: Int? = nil, memorySizeInGBs: Int? = nil, nodeCount: Int? = nil, nonProvisionableAutonomousContainerDatabases: Int? = nil, ocid: String? = nil, ociResourceAnchorName: String? = nil, ociUrl: String? = nil, odbNetworkId: String? = nil, percentProgress: Float? = nil, provisionableAutonomousContainerDatabases: Int? = nil, provisionedAutonomousContainerDatabases: Int? = nil, provisionedCpus: Float? = nil, reclaimableCpus: Float? = nil, reservedCpus: Float? = nil, scanListenerPortNonTls: Int? = nil, scanListenerPortTls: Int? = nil, shape: String? = nil, status: ResourceStatus? = nil, statusReason: String? = nil, timeDatabaseSslCertificateExpires: Date? = nil, timeOrdsCertificateExpires: Date? = nil, timeZone: String? = nil, totalContainerDatabases: Int? = nil) {
            self.autonomousDataStoragePercentage = autonomousDataStoragePercentage
            self.autonomousDataStorageSizeInTBs = autonomousDataStorageSizeInTBs
            self.availableAutonomousDataStorageSizeInTBs = availableAutonomousDataStorageSizeInTBs
            self.availableContainerDatabases = availableContainerDatabases
            self.availableCpus = availableCpus
            self.cloudAutonomousVmClusterArn = cloudAutonomousVmClusterArn
            self.cloudAutonomousVmClusterId = cloudAutonomousVmClusterId
            self.cloudExadataInfrastructureId = cloudExadataInfrastructureId
            self.computeModel = computeModel
            self.cpuCoreCount = cpuCoreCount
            self.cpuCoreCountPerNode = cpuCoreCountPerNode
            self.cpuPercentage = cpuPercentage
            self.createdAt = createdAt
            self.dataStorageSizeInGBs = dataStorageSizeInGBs
            self.dataStorageSizeInTBs = dataStorageSizeInTBs
            self.dbNodeStorageSizeInGBs = dbNodeStorageSizeInGBs
            self.dbServers = dbServers
            self.description = description
            self.displayName = displayName
            self.domain = domain
            self.exadataStorageInTBsLowestScaledValue = exadataStorageInTBsLowestScaledValue
            self.hostname = hostname
            self.isMtlsEnabledVmCluster = isMtlsEnabledVmCluster
            self.licenseModel = licenseModel
            self.maintenanceWindow = maintenanceWindow
            self.maxAcdsLowestScaledValue = maxAcdsLowestScaledValue
            self.memoryPerOracleComputeUnitInGBs = memoryPerOracleComputeUnitInGBs
            self.memorySizeInGBs = memorySizeInGBs
            self.nodeCount = nodeCount
            self.nonProvisionableAutonomousContainerDatabases = nonProvisionableAutonomousContainerDatabases
            self.ocid = ocid
            self.ociResourceAnchorName = ociResourceAnchorName
            self.ociUrl = ociUrl
            self.odbNetworkId = odbNetworkId
            self.percentProgress = percentProgress
            self.provisionableAutonomousContainerDatabases = provisionableAutonomousContainerDatabases
            self.provisionedAutonomousContainerDatabases = provisionedAutonomousContainerDatabases
            self.provisionedCpus = provisionedCpus
            self.reclaimableCpus = reclaimableCpus
            self.reservedCpus = reservedCpus
            self.scanListenerPortNonTls = scanListenerPortNonTls
            self.scanListenerPortTls = scanListenerPortTls
            self.shape = shape
            self.status = status
            self.statusReason = statusReason
            self.timeDatabaseSslCertificateExpires = timeDatabaseSslCertificateExpires
            self.timeOrdsCertificateExpires = timeOrdsCertificateExpires
            self.timeZone = timeZone
            self.totalContainerDatabases = totalContainerDatabases
        }

        private enum CodingKeys: String, CodingKey {
            case autonomousDataStoragePercentage = "autonomousDataStoragePercentage"
            case autonomousDataStorageSizeInTBs = "autonomousDataStorageSizeInTBs"
            case availableAutonomousDataStorageSizeInTBs = "availableAutonomousDataStorageSizeInTBs"
            case availableContainerDatabases = "availableContainerDatabases"
            case availableCpus = "availableCpus"
            case cloudAutonomousVmClusterArn = "cloudAutonomousVmClusterArn"
            case cloudAutonomousVmClusterId = "cloudAutonomousVmClusterId"
            case cloudExadataInfrastructureId = "cloudExadataInfrastructureId"
            case computeModel = "computeModel"
            case cpuCoreCount = "cpuCoreCount"
            case cpuCoreCountPerNode = "cpuCoreCountPerNode"
            case cpuPercentage = "cpuPercentage"
            case createdAt = "createdAt"
            case dataStorageSizeInGBs = "dataStorageSizeInGBs"
            case dataStorageSizeInTBs = "dataStorageSizeInTBs"
            case dbNodeStorageSizeInGBs = "dbNodeStorageSizeInGBs"
            case dbServers = "dbServers"
            case description = "description"
            case displayName = "displayName"
            case domain = "domain"
            case exadataStorageInTBsLowestScaledValue = "exadataStorageInTBsLowestScaledValue"
            case hostname = "hostname"
            case isMtlsEnabledVmCluster = "isMtlsEnabledVmCluster"
            case licenseModel = "licenseModel"
            case maintenanceWindow = "maintenanceWindow"
            case maxAcdsLowestScaledValue = "maxAcdsLowestScaledValue"
            case memoryPerOracleComputeUnitInGBs = "memoryPerOracleComputeUnitInGBs"
            case memorySizeInGBs = "memorySizeInGBs"
            case nodeCount = "nodeCount"
            case nonProvisionableAutonomousContainerDatabases = "nonProvisionableAutonomousContainerDatabases"
            case ocid = "ocid"
            case ociResourceAnchorName = "ociResourceAnchorName"
            case ociUrl = "ociUrl"
            case odbNetworkId = "odbNetworkId"
            case percentProgress = "percentProgress"
            case provisionableAutonomousContainerDatabases = "provisionableAutonomousContainerDatabases"
            case provisionedAutonomousContainerDatabases = "provisionedAutonomousContainerDatabases"
            case provisionedCpus = "provisionedCpus"
            case reclaimableCpus = "reclaimableCpus"
            case reservedCpus = "reservedCpus"
            case scanListenerPortNonTls = "scanListenerPortNonTls"
            case scanListenerPortTls = "scanListenerPortTls"
            case shape = "shape"
            case status = "status"
            case statusReason = "statusReason"
            case timeDatabaseSslCertificateExpires = "timeDatabaseSslCertificateExpires"
            case timeOrdsCertificateExpires = "timeOrdsCertificateExpires"
            case timeZone = "timeZone"
            case totalContainerDatabases = "totalContainerDatabases"
        }
    }

    public struct CloudAutonomousVmClusterResourceDetails: AWSDecodableShape {
        /// The unique identifier of the Autonomous VM cluster.
        public let cloudAutonomousVmClusterId: String?
        /// The amount of unallocated Autonomous Database storage in the Autonomous VM cluster, in terabytes.
        public let unallocatedAdbStorageInTBs: Double?

        @inlinable
        public init(cloudAutonomousVmClusterId: String? = nil, unallocatedAdbStorageInTBs: Double? = nil) {
            self.cloudAutonomousVmClusterId = cloudAutonomousVmClusterId
            self.unallocatedAdbStorageInTBs = unallocatedAdbStorageInTBs
        }

        private enum CodingKeys: String, CodingKey {
            case cloudAutonomousVmClusterId = "cloudAutonomousVmClusterId"
            case unallocatedAdbStorageInTBs = "unallocatedAdbStorageInTBs"
        }
    }

    public struct CloudAutonomousVmClusterSummary: AWSDecodableShape {
        /// The percentage of data storage currently in use for Autonomous Databases in the Autonomous VM cluster.
        public let autonomousDataStoragePercentage: Float?
        /// The total data storage allocated for Autonomous Databases in the Autonomous VM cluster, in TB.
        public let autonomousDataStorageSizeInTBs: Double?
        /// The available data storage for Autonomous Databases in the Autonomous VM cluster, in TB.
        public let availableAutonomousDataStorageSizeInTBs: Double?
        /// The number of Autonomous Container Databases that you can create with the currently available storage.
        public let availableContainerDatabases: Int?
        /// The number of CPU cores available for allocation to Autonomous Databases.
        public let availableCpus: Float?
        /// The Amazon Resource Name (ARN) for the Autonomous VM cluster.
        public let cloudAutonomousVmClusterArn: String?
        /// The unique identifier of the Autonomous VM cluster.
        public let cloudAutonomousVmClusterId: String
        /// The unique identifier of the Exadata infrastructure containing this Autonomous VM cluster.
        public let cloudExadataInfrastructureId: String?
        /// The compute model of the Autonomous VM cluster: ECPU or OCPU.
        public let computeModel: ComputeModel?
        /// The total number of CPU cores in the Autonomous VM cluster.
        public let cpuCoreCount: Int?
        /// The number of CPU cores per node in the Autonomous VM cluster.
        public let cpuCoreCountPerNode: Int?
        /// The percentage of total CPU cores currently in use in the Autonomous VM cluster.
        public let cpuPercentage: Float?
        /// The date and time when the Autonomous VM cluster was created.
        public let createdAt: Date?
        /// The total data storage allocated to the Autonomous VM cluster, in GB.
        public let dataStorageSizeInGBs: Double?
        /// The total data storage allocated to the Autonomous VM cluster, in TB.
        public let dataStorageSizeInTBs: Double?
        /// The local node storage allocated to the Autonomous VM cluster, in GB.
        public let dbNodeStorageSizeInGBs: Int?
        /// The list of database servers associated with the Autonomous VM cluster.
        public let dbServers: [String]?
        /// The user-provided description of the Autonomous VM cluster.
        public let description: String?
        /// The user-friendly name for the Autonomous VM cluster.
        public let displayName: String?
        /// The domain name for the Autonomous VM cluster.
        public let domain: String?
        /// The lowest value to which Exadata storage can be scaled down, in TB.
        public let exadataStorageInTBsLowestScaledValue: Double?
        /// The host name for the Autonomous VM cluster.
        public let hostname: String?
        /// Indicates if mutual TLS (mTLS) authentication is enabled for the Autonomous VM cluster.
        public let isMtlsEnabledVmCluster: Bool?
        /// The Oracle license model that applies to the Autonomous VM cluster.
        public let licenseModel: LicenseModel?
        /// The scheduling details for the maintenance window. Patching and system updates take place during the maintenance window.
        public let maintenanceWindow: MaintenanceWindow?
        /// The lowest value to which you can scale down the maximum number of Autonomous CDBs.
        public let maxAcdsLowestScaledValue: Int?
        /// The amount of memory allocated per Oracle Compute Unit (OCU), in GB.
        public let memoryPerOracleComputeUnitInGBs: Int?
        /// The total amount of memory allocated to the Autonomous VM cluster, in GB.
        public let memorySizeInGBs: Int?
        /// The number of database server nodes in the Autonomous VM cluster.
        public let nodeCount: Int?
        /// The number of Autonomous CDBs that can't be provisioned because of resource constraints.
        public let nonProvisionableAutonomousContainerDatabases: Int?
        /// The Oracle Cloud Identifier (OCID) of the Autonomous VM cluster.
        public let ocid: String?
        /// The name of the OCI resource anchor associated with this Autonomous VM cluster.
        public let ociResourceAnchorName: String?
        /// The URL for accessing the OCI console page for this Autonomous VM cluster.
        public let ociUrl: String?
        /// The unique identifier of the ODB network associated with this Autonomous VM cluster.
        public let odbNetworkId: String?
        /// The progress of the current operation on the Autonomous VM cluster, as a percentage.
        public let percentProgress: Float?
        /// The number of Autonomous CDBs that you can provision in the Autonomous VM cluster.
        public let provisionableAutonomousContainerDatabases: Int?
        /// The number of Autonomous Container Databases currently provisioned in the Autonomous VM cluster.
        public let provisionedAutonomousContainerDatabases: Int?
        /// The number of CPUs currently provisioned in the Autonomous VM cluster.
        public let provisionedCpus: Float?
        /// The number of CPUs that can be reclaimed from terminated or scaled-down Autonomous Databases.
        public let reclaimableCpus: Float?
        /// The number of CPUs reserved for system operations and redundancy.
        public let reservedCpus: Float?
        /// The SCAN listener port for non-TLS (TCP) protocol.
        public let scanListenerPortNonTls: Int?
        /// The SCAN listener port for TLS (TCP) protocol.
        public let scanListenerPortTls: Int?
        /// The shape of the Exadata infrastructure for the Autonomous VM cluster.
        public let shape: String?
        /// The current status of the Autonomous VM cluster.
        public let status: ResourceStatus?
        /// Additional information about the current status of the Autonomous VM cluster, if applicable.
        public let statusReason: String?
        /// The expiration date and time of the database SSL certificate.
        public let timeDatabaseSslCertificateExpires: Date?
        /// The expiration date and time of the Oracle REST Data Services (ORDS) certificate.
        public let timeOrdsCertificateExpires: Date?
        /// The time zone of the Autonomous VM cluster.
        public let timeZone: String?
        /// The total number of Autonomous Container Databases that can be created in the Autonomous VM cluster.
        public let totalContainerDatabases: Int?

        @inlinable
        public init(autonomousDataStoragePercentage: Float? = nil, autonomousDataStorageSizeInTBs: Double? = nil, availableAutonomousDataStorageSizeInTBs: Double? = nil, availableContainerDatabases: Int? = nil, availableCpus: Float? = nil, cloudAutonomousVmClusterArn: String? = nil, cloudAutonomousVmClusterId: String, cloudExadataInfrastructureId: String? = nil, computeModel: ComputeModel? = nil, cpuCoreCount: Int? = nil, cpuCoreCountPerNode: Int? = nil, cpuPercentage: Float? = nil, createdAt: Date? = nil, dataStorageSizeInGBs: Double? = nil, dataStorageSizeInTBs: Double? = nil, dbNodeStorageSizeInGBs: Int? = nil, dbServers: [String]? = nil, description: String? = nil, displayName: String? = nil, domain: String? = nil, exadataStorageInTBsLowestScaledValue: Double? = nil, hostname: String? = nil, isMtlsEnabledVmCluster: Bool? = nil, licenseModel: LicenseModel? = nil, maintenanceWindow: MaintenanceWindow? = nil, maxAcdsLowestScaledValue: Int? = nil, memoryPerOracleComputeUnitInGBs: Int? = nil, memorySizeInGBs: Int? = nil, nodeCount: Int? = nil, nonProvisionableAutonomousContainerDatabases: Int? = nil, ocid: String? = nil, ociResourceAnchorName: String? = nil, ociUrl: String? = nil, odbNetworkId: String? = nil, percentProgress: Float? = nil, provisionableAutonomousContainerDatabases: Int? = nil, provisionedAutonomousContainerDatabases: Int? = nil, provisionedCpus: Float? = nil, reclaimableCpus: Float? = nil, reservedCpus: Float? = nil, scanListenerPortNonTls: Int? = nil, scanListenerPortTls: Int? = nil, shape: String? = nil, status: ResourceStatus? = nil, statusReason: String? = nil, timeDatabaseSslCertificateExpires: Date? = nil, timeOrdsCertificateExpires: Date? = nil, timeZone: String? = nil, totalContainerDatabases: Int? = nil) {
            self.autonomousDataStoragePercentage = autonomousDataStoragePercentage
            self.autonomousDataStorageSizeInTBs = autonomousDataStorageSizeInTBs
            self.availableAutonomousDataStorageSizeInTBs = availableAutonomousDataStorageSizeInTBs
            self.availableContainerDatabases = availableContainerDatabases
            self.availableCpus = availableCpus
            self.cloudAutonomousVmClusterArn = cloudAutonomousVmClusterArn
            self.cloudAutonomousVmClusterId = cloudAutonomousVmClusterId
            self.cloudExadataInfrastructureId = cloudExadataInfrastructureId
            self.computeModel = computeModel
            self.cpuCoreCount = cpuCoreCount
            self.cpuCoreCountPerNode = cpuCoreCountPerNode
            self.cpuPercentage = cpuPercentage
            self.createdAt = createdAt
            self.dataStorageSizeInGBs = dataStorageSizeInGBs
            self.dataStorageSizeInTBs = dataStorageSizeInTBs
            self.dbNodeStorageSizeInGBs = dbNodeStorageSizeInGBs
            self.dbServers = dbServers
            self.description = description
            self.displayName = displayName
            self.domain = domain
            self.exadataStorageInTBsLowestScaledValue = exadataStorageInTBsLowestScaledValue
            self.hostname = hostname
            self.isMtlsEnabledVmCluster = isMtlsEnabledVmCluster
            self.licenseModel = licenseModel
            self.maintenanceWindow = maintenanceWindow
            self.maxAcdsLowestScaledValue = maxAcdsLowestScaledValue
            self.memoryPerOracleComputeUnitInGBs = memoryPerOracleComputeUnitInGBs
            self.memorySizeInGBs = memorySizeInGBs
            self.nodeCount = nodeCount
            self.nonProvisionableAutonomousContainerDatabases = nonProvisionableAutonomousContainerDatabases
            self.ocid = ocid
            self.ociResourceAnchorName = ociResourceAnchorName
            self.ociUrl = ociUrl
            self.odbNetworkId = odbNetworkId
            self.percentProgress = percentProgress
            self.provisionableAutonomousContainerDatabases = provisionableAutonomousContainerDatabases
            self.provisionedAutonomousContainerDatabases = provisionedAutonomousContainerDatabases
            self.provisionedCpus = provisionedCpus
            self.reclaimableCpus = reclaimableCpus
            self.reservedCpus = reservedCpus
            self.scanListenerPortNonTls = scanListenerPortNonTls
            self.scanListenerPortTls = scanListenerPortTls
            self.shape = shape
            self.status = status
            self.statusReason = statusReason
            self.timeDatabaseSslCertificateExpires = timeDatabaseSslCertificateExpires
            self.timeOrdsCertificateExpires = timeOrdsCertificateExpires
            self.timeZone = timeZone
            self.totalContainerDatabases = totalContainerDatabases
        }

        private enum CodingKeys: String, CodingKey {
            case autonomousDataStoragePercentage = "autonomousDataStoragePercentage"
            case autonomousDataStorageSizeInTBs = "autonomousDataStorageSizeInTBs"
            case availableAutonomousDataStorageSizeInTBs = "availableAutonomousDataStorageSizeInTBs"
            case availableContainerDatabases = "availableContainerDatabases"
            case availableCpus = "availableCpus"
            case cloudAutonomousVmClusterArn = "cloudAutonomousVmClusterArn"
            case cloudAutonomousVmClusterId = "cloudAutonomousVmClusterId"
            case cloudExadataInfrastructureId = "cloudExadataInfrastructureId"
            case computeModel = "computeModel"
            case cpuCoreCount = "cpuCoreCount"
            case cpuCoreCountPerNode = "cpuCoreCountPerNode"
            case cpuPercentage = "cpuPercentage"
            case createdAt = "createdAt"
            case dataStorageSizeInGBs = "dataStorageSizeInGBs"
            case dataStorageSizeInTBs = "dataStorageSizeInTBs"
            case dbNodeStorageSizeInGBs = "dbNodeStorageSizeInGBs"
            case dbServers = "dbServers"
            case description = "description"
            case displayName = "displayName"
            case domain = "domain"
            case exadataStorageInTBsLowestScaledValue = "exadataStorageInTBsLowestScaledValue"
            case hostname = "hostname"
            case isMtlsEnabledVmCluster = "isMtlsEnabledVmCluster"
            case licenseModel = "licenseModel"
            case maintenanceWindow = "maintenanceWindow"
            case maxAcdsLowestScaledValue = "maxAcdsLowestScaledValue"
            case memoryPerOracleComputeUnitInGBs = "memoryPerOracleComputeUnitInGBs"
            case memorySizeInGBs = "memorySizeInGBs"
            case nodeCount = "nodeCount"
            case nonProvisionableAutonomousContainerDatabases = "nonProvisionableAutonomousContainerDatabases"
            case ocid = "ocid"
            case ociResourceAnchorName = "ociResourceAnchorName"
            case ociUrl = "ociUrl"
            case odbNetworkId = "odbNetworkId"
            case percentProgress = "percentProgress"
            case provisionableAutonomousContainerDatabases = "provisionableAutonomousContainerDatabases"
            case provisionedAutonomousContainerDatabases = "provisionedAutonomousContainerDatabases"
            case provisionedCpus = "provisionedCpus"
            case reclaimableCpus = "reclaimableCpus"
            case reservedCpus = "reservedCpus"
            case scanListenerPortNonTls = "scanListenerPortNonTls"
            case scanListenerPortTls = "scanListenerPortTls"
            case shape = "shape"
            case status = "status"
            case statusReason = "statusReason"
            case timeDatabaseSslCertificateExpires = "timeDatabaseSslCertificateExpires"
            case timeOrdsCertificateExpires = "timeOrdsCertificateExpires"
            case timeZone = "timeZone"
            case totalContainerDatabases = "totalContainerDatabases"
        }
    }

    public struct CloudExadataInfrastructure: AWSDecodableShape {
        /// The number of storage servers requested for the Exadata infrastructure.
        public let activatedStorageCount: Int?
        /// The number of storage servers requested for the Exadata infrastructure.
        public let additionalStorageCount: Int?
        /// The name of the Availability Zone (AZ) where the Exadata infrastructure is located.
        public let availabilityZone: String?
        /// The AZ ID of the AZ where the Exadata infrastructure is located.
        public let availabilityZoneId: String?
        /// The amount of available storage, in gigabytes (GB), for the Exadata infrastructure.
        public let availableStorageSizeInGBs: Int?
        /// The Amazon Resource Name (ARN) for the Exadata infrastructure.
        public let cloudExadataInfrastructureArn: String?
        /// The unique identifier for the Exadata infrastructure.
        public let cloudExadataInfrastructureId: String
        /// The number of database servers for the Exadata infrastructure.
        public let computeCount: Int?
        /// The OCI model compute model used when you create or clone an instance: ECPU or OCPU. An ECPU is an abstracted measure of compute resources. ECPUs are based on the number of cores elastically allocated from a pool of compute and storage servers. An OCPU is a legacy physical measure of compute resources. OCPUs are based on the physical core of a processor with hyper-threading enabled.
        public let computeModel: ComputeModel?
        /// The total number of CPU cores that are allocated to the Exadata infrastructure.
        public let cpuCount: Int?
        /// The date and time when the Exadata infrastructure was created.
        public let createdAt: Date?
        /// The email addresses of contacts to receive notification from Oracle about maintenance updates for the Exadata infrastructure.
        public let customerContactsToSendToOCI: [CustomerContact]?
        /// The database server model type of the Exadata infrastructure. For the list of valid model names, use the ListDbSystemShapes operation.
        public let databaseServerType: String?
        /// The size of the Exadata infrastructure's data disk group, in terabytes (TB).
        public let dataStorageSizeInTBs: Double?
        /// The size of the Exadata infrastructure's local node storage, in gigabytes (GB).
        public let dbNodeStorageSizeInGBs: Int?
        /// The software version of the database servers (dom0) in the Exadata infrastructure.
        public let dbServerVersion: String?
        /// The user-friendly name for the Exadata infrastructure.
        public let displayName: String?
        /// The Oracle Cloud Identifier (OCID) of the last maintenance run for the Exadata infrastructure.
        public let lastMaintenanceRunId: String?
        /// The scheduling details for the maintenance window. Patching and system updates take place during the maintenance window.
        public let maintenanceWindow: MaintenanceWindow?
        /// The total number of CPU cores available on the Exadata infrastructure.
        public let maxCpuCount: Int?
        /// The total amount of data disk group storage, in terabytes (TB), that's available on the Exadata infrastructure.
        public let maxDataStorageInTBs: Double?
        /// The total amount of local node storage, in gigabytes (GB), that's available on the Exadata infrastructure.
        public let maxDbNodeStorageSizeInGBs: Int?
        /// The total amount of memory, in gigabytes (GB), that's available on the Exadata infrastructure.
        public let maxMemoryInGBs: Int?
        /// The amount of memory, in gigabytes (GB), that's allocated on the Exadata infrastructure.
        public let memorySizeInGBs: Int?
        /// The monthly software version of the database servers installed on the Exadata infrastructure.
        public let monthlyDbServerVersion: String?
        /// The monthly software version of the storage servers installed on the Exadata infrastructure.
        public let monthlyStorageServerVersion: String?
        /// The OCID of the next maintenance run for the Exadata infrastructure.
        public let nextMaintenanceRunId: String?
        /// The OCID of the Exadata infrastructure.
        public let ocid: String?
        /// The name of the OCI resource anchor for the Exadata infrastructure.
        public let ociResourceAnchorName: String?
        /// The HTTPS link to the Exadata infrastructure in OCI.
        public let ociUrl: String?
        /// The amount of progress made on the current operation on the Exadata infrastructure, expressed as a percentage.
        public let percentProgress: Float?
        /// The model name of the Exadata infrastructure.
        public let shape: String?
        /// The current status of the Exadata infrastructure.
        public let status: ResourceStatus?
        /// Additional information about the status of the Exadata infrastructure.
        public let statusReason: String?
        /// The number of storage servers that are activated for the Exadata infrastructure.
        public let storageCount: Int?
        /// The storage server model type of the Exadata infrastructure. For the list of valid model names, use the ListDbSystemShapes operation.
        public let storageServerType: String?
        /// The software version of the storage servers on the Exadata infrastructure.
        public let storageServerVersion: String?
        /// The total amount of storage, in gigabytes (GB), on the the Exadata infrastructure.
        public let totalStorageSizeInGBs: Int?

        @inlinable
        public init(activatedStorageCount: Int? = nil, additionalStorageCount: Int? = nil, availabilityZone: String? = nil, availabilityZoneId: String? = nil, availableStorageSizeInGBs: Int? = nil, cloudExadataInfrastructureArn: String? = nil, cloudExadataInfrastructureId: String, computeCount: Int? = nil, computeModel: ComputeModel? = nil, cpuCount: Int? = nil, createdAt: Date? = nil, customerContactsToSendToOCI: [CustomerContact]? = nil, databaseServerType: String? = nil, dataStorageSizeInTBs: Double? = nil, dbNodeStorageSizeInGBs: Int? = nil, dbServerVersion: String? = nil, displayName: String? = nil, lastMaintenanceRunId: String? = nil, maintenanceWindow: MaintenanceWindow? = nil, maxCpuCount: Int? = nil, maxDataStorageInTBs: Double? = nil, maxDbNodeStorageSizeInGBs: Int? = nil, maxMemoryInGBs: Int? = nil, memorySizeInGBs: Int? = nil, monthlyDbServerVersion: String? = nil, monthlyStorageServerVersion: String? = nil, nextMaintenanceRunId: String? = nil, ocid: String? = nil, ociResourceAnchorName: String? = nil, ociUrl: String? = nil, percentProgress: Float? = nil, shape: String? = nil, status: ResourceStatus? = nil, statusReason: String? = nil, storageCount: Int? = nil, storageServerType: String? = nil, storageServerVersion: String? = nil, totalStorageSizeInGBs: Int? = nil) {
            self.activatedStorageCount = activatedStorageCount
            self.additionalStorageCount = additionalStorageCount
            self.availabilityZone = availabilityZone
            self.availabilityZoneId = availabilityZoneId
            self.availableStorageSizeInGBs = availableStorageSizeInGBs
            self.cloudExadataInfrastructureArn = cloudExadataInfrastructureArn
            self.cloudExadataInfrastructureId = cloudExadataInfrastructureId
            self.computeCount = computeCount
            self.computeModel = computeModel
            self.cpuCount = cpuCount
            self.createdAt = createdAt
            self.customerContactsToSendToOCI = customerContactsToSendToOCI
            self.databaseServerType = databaseServerType
            self.dataStorageSizeInTBs = dataStorageSizeInTBs
            self.dbNodeStorageSizeInGBs = dbNodeStorageSizeInGBs
            self.dbServerVersion = dbServerVersion
            self.displayName = displayName
            self.lastMaintenanceRunId = lastMaintenanceRunId
            self.maintenanceWindow = maintenanceWindow
            self.maxCpuCount = maxCpuCount
            self.maxDataStorageInTBs = maxDataStorageInTBs
            self.maxDbNodeStorageSizeInGBs = maxDbNodeStorageSizeInGBs
            self.maxMemoryInGBs = maxMemoryInGBs
            self.memorySizeInGBs = memorySizeInGBs
            self.monthlyDbServerVersion = monthlyDbServerVersion
            self.monthlyStorageServerVersion = monthlyStorageServerVersion
            self.nextMaintenanceRunId = nextMaintenanceRunId
            self.ocid = ocid
            self.ociResourceAnchorName = ociResourceAnchorName
            self.ociUrl = ociUrl
            self.percentProgress = percentProgress
            self.shape = shape
            self.status = status
            self.statusReason = statusReason
            self.storageCount = storageCount
            self.storageServerType = storageServerType
            self.storageServerVersion = storageServerVersion
            self.totalStorageSizeInGBs = totalStorageSizeInGBs
        }

        private enum CodingKeys: String, CodingKey {
            case activatedStorageCount = "activatedStorageCount"
            case additionalStorageCount = "additionalStorageCount"
            case availabilityZone = "availabilityZone"
            case availabilityZoneId = "availabilityZoneId"
            case availableStorageSizeInGBs = "availableStorageSizeInGBs"
            case cloudExadataInfrastructureArn = "cloudExadataInfrastructureArn"
            case cloudExadataInfrastructureId = "cloudExadataInfrastructureId"
            case computeCount = "computeCount"
            case computeModel = "computeModel"
            case cpuCount = "cpuCount"
            case createdAt = "createdAt"
            case customerContactsToSendToOCI = "customerContactsToSendToOCI"
            case databaseServerType = "databaseServerType"
            case dataStorageSizeInTBs = "dataStorageSizeInTBs"
            case dbNodeStorageSizeInGBs = "dbNodeStorageSizeInGBs"
            case dbServerVersion = "dbServerVersion"
            case displayName = "displayName"
            case lastMaintenanceRunId = "lastMaintenanceRunId"
            case maintenanceWindow = "maintenanceWindow"
            case maxCpuCount = "maxCpuCount"
            case maxDataStorageInTBs = "maxDataStorageInTBs"
            case maxDbNodeStorageSizeInGBs = "maxDbNodeStorageSizeInGBs"
            case maxMemoryInGBs = "maxMemoryInGBs"
            case memorySizeInGBs = "memorySizeInGBs"
            case monthlyDbServerVersion = "monthlyDbServerVersion"
            case monthlyStorageServerVersion = "monthlyStorageServerVersion"
            case nextMaintenanceRunId = "nextMaintenanceRunId"
            case ocid = "ocid"
            case ociResourceAnchorName = "ociResourceAnchorName"
            case ociUrl = "ociUrl"
            case percentProgress = "percentProgress"
            case shape = "shape"
            case status = "status"
            case statusReason = "statusReason"
            case storageCount = "storageCount"
            case storageServerType = "storageServerType"
            case storageServerVersion = "storageServerVersion"
            case totalStorageSizeInGBs = "totalStorageSizeInGBs"
        }
    }

    public struct CloudExadataInfrastructureSummary: AWSDecodableShape {
        /// The number of storage servers requested for the Exadata infrastructure.
        public let activatedStorageCount: Int?
        /// The number of storage servers requested for the Exadata infrastructure.
        public let additionalStorageCount: Int?
        /// The name of the Availability Zone (AZ) where the Exadata infrastructure is located.
        public let availabilityZone: String?
        /// The AZ ID of the AZ where the Exadata infrastructure is located.
        public let availabilityZoneId: String?
        /// The amount of available storage, in gigabytes (GB), for the Exadata infrastructure.
        public let availableStorageSizeInGBs: Int?
        /// The Amazon Resource Name (ARN) for the Exadata infrastructure.
        public let cloudExadataInfrastructureArn: String?
        /// The unique identifier for the Exadata infrastructure.
        public let cloudExadataInfrastructureId: String
        /// The number of database servers for the Exadata infrastructure.
        public let computeCount: Int?
        /// The OCI model compute model used when you create or clone an instance: ECPU or OCPU. An ECPU is an abstracted measure of compute resources. ECPUs are based on the number of cores elastically allocated from a pool of compute and storage servers. An OCPU is a legacy physical measure of compute resources. OCPUs are based on the physical core of a processor with hyper-threading enabled.
        public let computeModel: ComputeModel?
        /// The total number of CPU cores that are allocated to the Exadata infrastructure.
        public let cpuCount: Int?
        /// The date and time when the Exadata infrastructure was created.
        public let createdAt: Date?
        /// The email addresses of contacts to receive notification from Oracle about maintenance updates for the Exadata infrastructure.
        public let customerContactsToSendToOCI: [CustomerContact]?
        /// The database server model type of the Exadata infrastructure. For the list of valid model names, use the ListDbSystemShapes operation.
        public let databaseServerType: String?
        /// The size of the Exadata infrastructure's data disk group, in terabytes (TB).
        public let dataStorageSizeInTBs: Double?
        /// The size of the Exadata infrastructure's local node storage, in gigabytes (GB).
        public let dbNodeStorageSizeInGBs: Int?
        /// The software version of the database servers on the Exadata infrastructure.
        public let dbServerVersion: String?
        /// The user-friendly name for the Exadata infrastructure.
        public let displayName: String?
        /// The Oracle Cloud Identifier (OCID) of the last maintenance run for the Exadata infrastructure.
        public let lastMaintenanceRunId: String?
        /// The scheduling details for the maintenance window. Patching and system updates take place during the maintenance window.
        public let maintenanceWindow: MaintenanceWindow?
        /// The total number of CPU cores available on the Exadata infrastructure.
        public let maxCpuCount: Int?
        /// The total amount of data disk group storage, in terabytes (TB), that's available on the Exadata infrastructure.
        public let maxDataStorageInTBs: Double?
        /// The total amount of local node storage, in gigabytes (GB), that's available on the Exadata infrastructure.
        public let maxDbNodeStorageSizeInGBs: Int?
        /// The total amount of memory, in gigabytes (GB), that's available on the Exadata infrastructure.
        public let maxMemoryInGBs: Int?
        /// The amount of memory, in gigabytes (GB), that's allocated on the Exadata infrastructure.
        public let memorySizeInGBs: Int?
        /// The monthly software version of the database servers (dom0) installed on the Exadata infrastructure.
        public let monthlyDbServerVersion: String?
        /// The monthly software version of the storage servers installed on the Exadata infrastructure.
        public let monthlyStorageServerVersion: String?
        /// The OCID of the next maintenance run for the Exadata infrastructure.
        public let nextMaintenanceRunId: String?
        /// The OCID of the Exadata infrastructure.
        public let ocid: String?
        /// The name of the OCI resource anchor for the Exadata infrastructure.
        public let ociResourceAnchorName: String?
        /// The HTTPS link to the Exadata infrastructure in OCI.
        public let ociUrl: String?
        /// The amount of progress made on the current operation on the Exadata infrastructure, expressed as a percentage.
        public let percentProgress: Float?
        /// The model name of the Exadata infrastructure.
        public let shape: String?
        /// The current status of the Exadata infrastructure.
        public let status: ResourceStatus?
        /// Additional information about the status of the Exadata infrastructure.
        public let statusReason: String?
        /// The number of storage servers that are activated for the Exadata infrastructure.
        public let storageCount: Int?
        /// The storage server model type of the Exadata infrastructure. For the list of valid model names, use the ListDbSystemShapes operation.
        public let storageServerType: String?
        /// The software version of the storage servers on the Exadata infrastructure.
        public let storageServerVersion: String?
        /// The total amount of storage, in gigabytes (GB), on the the Exadata infrastructure.
        public let totalStorageSizeInGBs: Int?

        @inlinable
        public init(activatedStorageCount: Int? = nil, additionalStorageCount: Int? = nil, availabilityZone: String? = nil, availabilityZoneId: String? = nil, availableStorageSizeInGBs: Int? = nil, cloudExadataInfrastructureArn: String? = nil, cloudExadataInfrastructureId: String, computeCount: Int? = nil, computeModel: ComputeModel? = nil, cpuCount: Int? = nil, createdAt: Date? = nil, customerContactsToSendToOCI: [CustomerContact]? = nil, databaseServerType: String? = nil, dataStorageSizeInTBs: Double? = nil, dbNodeStorageSizeInGBs: Int? = nil, dbServerVersion: String? = nil, displayName: String? = nil, lastMaintenanceRunId: String? = nil, maintenanceWindow: MaintenanceWindow? = nil, maxCpuCount: Int? = nil, maxDataStorageInTBs: Double? = nil, maxDbNodeStorageSizeInGBs: Int? = nil, maxMemoryInGBs: Int? = nil, memorySizeInGBs: Int? = nil, monthlyDbServerVersion: String? = nil, monthlyStorageServerVersion: String? = nil, nextMaintenanceRunId: String? = nil, ocid: String? = nil, ociResourceAnchorName: String? = nil, ociUrl: String? = nil, percentProgress: Float? = nil, shape: String? = nil, status: ResourceStatus? = nil, statusReason: String? = nil, storageCount: Int? = nil, storageServerType: String? = nil, storageServerVersion: String? = nil, totalStorageSizeInGBs: Int? = nil) {
            self.activatedStorageCount = activatedStorageCount
            self.additionalStorageCount = additionalStorageCount
            self.availabilityZone = availabilityZone
            self.availabilityZoneId = availabilityZoneId
            self.availableStorageSizeInGBs = availableStorageSizeInGBs
            self.cloudExadataInfrastructureArn = cloudExadataInfrastructureArn
            self.cloudExadataInfrastructureId = cloudExadataInfrastructureId
            self.computeCount = computeCount
            self.computeModel = computeModel
            self.cpuCount = cpuCount
            self.createdAt = createdAt
            self.customerContactsToSendToOCI = customerContactsToSendToOCI
            self.databaseServerType = databaseServerType
            self.dataStorageSizeInTBs = dataStorageSizeInTBs
            self.dbNodeStorageSizeInGBs = dbNodeStorageSizeInGBs
            self.dbServerVersion = dbServerVersion
            self.displayName = displayName
            self.lastMaintenanceRunId = lastMaintenanceRunId
            self.maintenanceWindow = maintenanceWindow
            self.maxCpuCount = maxCpuCount
            self.maxDataStorageInTBs = maxDataStorageInTBs
            self.maxDbNodeStorageSizeInGBs = maxDbNodeStorageSizeInGBs
            self.maxMemoryInGBs = maxMemoryInGBs
            self.memorySizeInGBs = memorySizeInGBs
            self.monthlyDbServerVersion = monthlyDbServerVersion
            self.monthlyStorageServerVersion = monthlyStorageServerVersion
            self.nextMaintenanceRunId = nextMaintenanceRunId
            self.ocid = ocid
            self.ociResourceAnchorName = ociResourceAnchorName
            self.ociUrl = ociUrl
            self.percentProgress = percentProgress
            self.shape = shape
            self.status = status
            self.statusReason = statusReason
            self.storageCount = storageCount
            self.storageServerType = storageServerType
            self.storageServerVersion = storageServerVersion
            self.totalStorageSizeInGBs = totalStorageSizeInGBs
        }

        private enum CodingKeys: String, CodingKey {
            case activatedStorageCount = "activatedStorageCount"
            case additionalStorageCount = "additionalStorageCount"
            case availabilityZone = "availabilityZone"
            case availabilityZoneId = "availabilityZoneId"
            case availableStorageSizeInGBs = "availableStorageSizeInGBs"
            case cloudExadataInfrastructureArn = "cloudExadataInfrastructureArn"
            case cloudExadataInfrastructureId = "cloudExadataInfrastructureId"
            case computeCount = "computeCount"
            case computeModel = "computeModel"
            case cpuCount = "cpuCount"
            case createdAt = "createdAt"
            case customerContactsToSendToOCI = "customerContactsToSendToOCI"
            case databaseServerType = "databaseServerType"
            case dataStorageSizeInTBs = "dataStorageSizeInTBs"
            case dbNodeStorageSizeInGBs = "dbNodeStorageSizeInGBs"
            case dbServerVersion = "dbServerVersion"
            case displayName = "displayName"
            case lastMaintenanceRunId = "lastMaintenanceRunId"
            case maintenanceWindow = "maintenanceWindow"
            case maxCpuCount = "maxCpuCount"
            case maxDataStorageInTBs = "maxDataStorageInTBs"
            case maxDbNodeStorageSizeInGBs = "maxDbNodeStorageSizeInGBs"
            case maxMemoryInGBs = "maxMemoryInGBs"
            case memorySizeInGBs = "memorySizeInGBs"
            case monthlyDbServerVersion = "monthlyDbServerVersion"
            case monthlyStorageServerVersion = "monthlyStorageServerVersion"
            case nextMaintenanceRunId = "nextMaintenanceRunId"
            case ocid = "ocid"
            case ociResourceAnchorName = "ociResourceAnchorName"
            case ociUrl = "ociUrl"
            case percentProgress = "percentProgress"
            case shape = "shape"
            case status = "status"
            case statusReason = "statusReason"
            case storageCount = "storageCount"
            case storageServerType = "storageServerType"
            case storageServerVersion = "storageServerVersion"
            case totalStorageSizeInGBs = "totalStorageSizeInGBs"
        }
    }

    public struct CloudExadataInfrastructureUnallocatedResources: AWSDecodableShape {
        /// A list of Autonomous VM clusters associated with this Cloud Exadata Infrastructure.
        public let cloudAutonomousVmClusters: [CloudAutonomousVmClusterResourceDetails]?
        /// The display name of the Cloud Exadata infrastructure.
        public let cloudExadataInfrastructureDisplayName: String?
        /// The unique identifier of the Cloud Exadata infrastructure.
        public let cloudExadataInfrastructureId: String?
        /// The amount of unallocated Exadata storage available, in terabytes (TB).
        public let exadataStorageInTBs: Double?
        /// The amount of unallocated local storage available, in gigabytes (GB).
        public let localStorageInGBs: Int?
        /// The amount of unallocated memory available, in gigabytes (GB).
        public let memoryInGBs: Int?
        /// The number of unallocated Oracle CPU Units (OCPUs) available.
        public let ocpus: Int?

        @inlinable
        public init(cloudAutonomousVmClusters: [CloudAutonomousVmClusterResourceDetails]? = nil, cloudExadataInfrastructureDisplayName: String? = nil, cloudExadataInfrastructureId: String? = nil, exadataStorageInTBs: Double? = nil, localStorageInGBs: Int? = nil, memoryInGBs: Int? = nil, ocpus: Int? = nil) {
            self.cloudAutonomousVmClusters = cloudAutonomousVmClusters
            self.cloudExadataInfrastructureDisplayName = cloudExadataInfrastructureDisplayName
            self.cloudExadataInfrastructureId = cloudExadataInfrastructureId
            self.exadataStorageInTBs = exadataStorageInTBs
            self.localStorageInGBs = localStorageInGBs
            self.memoryInGBs = memoryInGBs
            self.ocpus = ocpus
        }

        private enum CodingKeys: String, CodingKey {
            case cloudAutonomousVmClusters = "cloudAutonomousVmClusters"
            case cloudExadataInfrastructureDisplayName = "cloudExadataInfrastructureDisplayName"
            case cloudExadataInfrastructureId = "cloudExadataInfrastructureId"
            case exadataStorageInTBs = "exadataStorageInTBs"
            case localStorageInGBs = "localStorageInGBs"
            case memoryInGBs = "memoryInGBs"
            case ocpus = "ocpus"
        }
    }

    public struct CloudVmCluster: AWSDecodableShape {
        /// The unique identifier of the Exadata infrastructure that this VM cluster belongs to.
        public let cloudExadataInfrastructureId: String?
        /// The Amazon Resource Name (ARN) of the VM cluster.
        public let cloudVmClusterArn: String?
        /// The unique identifier of the VM cluster.
        public let cloudVmClusterId: String
        /// The name of the Grid Infrastructure (GI) cluster.
        public let clusterName: String?
        /// The OCI model compute model used when you create or clone an instance: ECPU or OCPU. An ECPU is an abstracted measure of compute resources. ECPUs are based on the number of cores elastically allocated from a pool of compute and storage servers. An OCPU is a legacy physical measure of compute resources. OCPUs are based on the physical core of a processor with hyper-threading enabled.
        public let computeModel: ComputeModel?
        /// The number of CPU cores enabled on the VM cluster.
        public let cpuCoreCount: Int?
        /// The date and time when the VM cluster was created.
        public let createdAt: Date?
        /// The set of diagnostic collection options enabled for the VM cluster.
        public let dataCollectionOptions: DataCollectionOptions?
        /// The size of the data disk group, in terabytes (TB), that's allocated for the VM cluster.
        public let dataStorageSizeInTBs: Double?
        /// The amount of local node storage, in gigabytes (GB), that's allocated for the VM cluster.
        public let dbNodeStorageSizeInGBs: Int?
        /// The list of database servers for the VM cluster.
        public let dbServers: [String]?
        /// The type of redundancy configured for the VM cluster. NORMAL is 2-way redundancy. HIGH is 3-way redundancy.
        public let diskRedundancy: DiskRedundancy?
        /// The user-friendly name for the VM cluster.
        public let displayName: String?
        /// The domain of the VM cluster.
        public let domain: String?
        /// The software version of the Oracle Grid Infrastructure (GI) for the VM cluster.
        public let giVersion: String?
        /// The host name for the VM cluster.
        public let hostname: String?
        /// The ExadataIormConfig cache details for the VM cluster.
        public let iormConfigCache: ExadataIormConfig?
        /// Indicates whether database backups to local Exadata storage is enabled for the VM cluster.
        public let isLocalBackupEnabled: Bool?
        /// Indicates whether the VM cluster is configured with a sparse disk group.
        public let isSparseDiskgroupEnabled: Bool?
        /// The Oracle Cloud ID (OCID) of the last maintenance update history entry.
        public let lastUpdateHistoryEntryId: String?
        /// The Oracle license model applied to the VM cluster.
        public let licenseModel: LicenseModel?
        /// The port number configured for the listener on the VM cluster.
        public let listenerPort: Int?
        /// The amount of memory, in gigabytes (GB), that's allocated for the VM cluster.
        public let memorySizeInGBs: Int?
        /// The number of nodes in the VM cluster.
        public let nodeCount: Int?
        /// The OCID of the VM cluster.
        public let ocid: String?
        /// The name of the OCI resource anchor for the VM cluster.
        public let ociResourceAnchorName: String?
        /// The HTTPS link to the VM cluster in OCI.
        public let ociUrl: String?
        /// The unique identifier of the ODB network for the VM cluster.
        public let odbNetworkId: String?
        /// The amount of progress made on the current operation on the VM cluster, expressed as a percentage.
        public let percentProgress: Float?
        /// The FQDN of the DNS record for the Single Client Access Name (SCAN) IP addresses that are associated with the VM cluster.
        public let scanDnsName: String?
        /// The OCID of the DNS record for the SCAN IP addresses that are associated with the VM cluster.
        public let scanDnsRecordId: String?
        /// The OCID of the SCAN IP addresses that are associated with the VM cluster.
        public let scanIpIds: [String]?
        /// The hardware model name of the Exadata infrastructure that's running the VM cluster.
        public let shape: String?
        /// The public key portion of one or more key pairs used for SSH access to the VM cluster.
        public let sshPublicKeys: [String]?
        /// The current status of the VM cluster.
        public let status: ResourceStatus?
        /// Additional information about the status of the VM cluster.
        public let statusReason: String?
        /// The amount of local node storage, in gigabytes (GB), that's allocated to the VM cluster.
        public let storageSizeInGBs: Int?
        /// The operating system version of the image chosen for the VM cluster.
        public let systemVersion: String?
        /// The time zone of the VM cluster.
        public let timeZone: String?
        /// The virtual IP (VIP) addresses that are associated with the VM cluster. Oracle's Cluster Ready Services (CRS) creates and maintains one VIP address for each node in the VM cluster to enable failover. If one node fails, the VIP is reassigned to another active node in the cluster.
        public let vipIds: [String]?

        @inlinable
        public init(cloudExadataInfrastructureId: String? = nil, cloudVmClusterArn: String? = nil, cloudVmClusterId: String, clusterName: String? = nil, computeModel: ComputeModel? = nil, cpuCoreCount: Int? = nil, createdAt: Date? = nil, dataCollectionOptions: DataCollectionOptions? = nil, dataStorageSizeInTBs: Double? = nil, dbNodeStorageSizeInGBs: Int? = nil, dbServers: [String]? = nil, diskRedundancy: DiskRedundancy? = nil, displayName: String? = nil, domain: String? = nil, giVersion: String? = nil, hostname: String? = nil, iormConfigCache: ExadataIormConfig? = nil, isLocalBackupEnabled: Bool? = nil, isSparseDiskgroupEnabled: Bool? = nil, lastUpdateHistoryEntryId: String? = nil, licenseModel: LicenseModel? = nil, listenerPort: Int? = nil, memorySizeInGBs: Int? = nil, nodeCount: Int? = nil, ocid: String? = nil, ociResourceAnchorName: String? = nil, ociUrl: String? = nil, odbNetworkId: String? = nil, percentProgress: Float? = nil, scanDnsName: String? = nil, scanDnsRecordId: String? = nil, scanIpIds: [String]? = nil, shape: String? = nil, sshPublicKeys: [String]? = nil, status: ResourceStatus? = nil, statusReason: String? = nil, storageSizeInGBs: Int? = nil, systemVersion: String? = nil, timeZone: String? = nil, vipIds: [String]? = nil) {
            self.cloudExadataInfrastructureId = cloudExadataInfrastructureId
            self.cloudVmClusterArn = cloudVmClusterArn
            self.cloudVmClusterId = cloudVmClusterId
            self.clusterName = clusterName
            self.computeModel = computeModel
            self.cpuCoreCount = cpuCoreCount
            self.createdAt = createdAt
            self.dataCollectionOptions = dataCollectionOptions
            self.dataStorageSizeInTBs = dataStorageSizeInTBs
            self.dbNodeStorageSizeInGBs = dbNodeStorageSizeInGBs
            self.dbServers = dbServers
            self.diskRedundancy = diskRedundancy
            self.displayName = displayName
            self.domain = domain
            self.giVersion = giVersion
            self.hostname = hostname
            self.iormConfigCache = iormConfigCache
            self.isLocalBackupEnabled = isLocalBackupEnabled
            self.isSparseDiskgroupEnabled = isSparseDiskgroupEnabled
            self.lastUpdateHistoryEntryId = lastUpdateHistoryEntryId
            self.licenseModel = licenseModel
            self.listenerPort = listenerPort
            self.memorySizeInGBs = memorySizeInGBs
            self.nodeCount = nodeCount
            self.ocid = ocid
            self.ociResourceAnchorName = ociResourceAnchorName
            self.ociUrl = ociUrl
            self.odbNetworkId = odbNetworkId
            self.percentProgress = percentProgress
            self.scanDnsName = scanDnsName
            self.scanDnsRecordId = scanDnsRecordId
            self.scanIpIds = scanIpIds
            self.shape = shape
            self.sshPublicKeys = sshPublicKeys
            self.status = status
            self.statusReason = statusReason
            self.storageSizeInGBs = storageSizeInGBs
            self.systemVersion = systemVersion
            self.timeZone = timeZone
            self.vipIds = vipIds
        }

        private enum CodingKeys: String, CodingKey {
            case cloudExadataInfrastructureId = "cloudExadataInfrastructureId"
            case cloudVmClusterArn = "cloudVmClusterArn"
            case cloudVmClusterId = "cloudVmClusterId"
            case clusterName = "clusterName"
            case computeModel = "computeModel"
            case cpuCoreCount = "cpuCoreCount"
            case createdAt = "createdAt"
            case dataCollectionOptions = "dataCollectionOptions"
            case dataStorageSizeInTBs = "dataStorageSizeInTBs"
            case dbNodeStorageSizeInGBs = "dbNodeStorageSizeInGBs"
            case dbServers = "dbServers"
            case diskRedundancy = "diskRedundancy"
            case displayName = "displayName"
            case domain = "domain"
            case giVersion = "giVersion"
            case hostname = "hostname"
            case iormConfigCache = "iormConfigCache"
            case isLocalBackupEnabled = "isLocalBackupEnabled"
            case isSparseDiskgroupEnabled = "isSparseDiskgroupEnabled"
            case lastUpdateHistoryEntryId = "lastUpdateHistoryEntryId"
            case licenseModel = "licenseModel"
            case listenerPort = "listenerPort"
            case memorySizeInGBs = "memorySizeInGBs"
            case nodeCount = "nodeCount"
            case ocid = "ocid"
            case ociResourceAnchorName = "ociResourceAnchorName"
            case ociUrl = "ociUrl"
            case odbNetworkId = "odbNetworkId"
            case percentProgress = "percentProgress"
            case scanDnsName = "scanDnsName"
            case scanDnsRecordId = "scanDnsRecordId"
            case scanIpIds = "scanIpIds"
            case shape = "shape"
            case sshPublicKeys = "sshPublicKeys"
            case status = "status"
            case statusReason = "statusReason"
            case storageSizeInGBs = "storageSizeInGBs"
            case systemVersion = "systemVersion"
            case timeZone = "timeZone"
            case vipIds = "vipIds"
        }
    }

    public struct CloudVmClusterSummary: AWSDecodableShape {
        /// The unique identifier of the Exadata infrastructure that this VM cluster belongs to.
        public let cloudExadataInfrastructureId: String?
        /// The Amazon Resource Name (ARN) of the VM cluster.
        public let cloudVmClusterArn: String?
        /// The unique identifier of the VM cluster.
        public let cloudVmClusterId: String
        /// The name of the Grid Infrastructure (GI) cluster.
        public let clusterName: String?
        /// The OCI model compute model used when you create or clone an instance: ECPU or OCPU. An ECPU is an abstracted measure of compute resources. ECPUs are based on the number of cores elastically allocated from a pool of compute and storage servers. An OCPU is a legacy physical measure of compute resources. OCPUs are based on the physical core of a processor with hyper-threading enabled.
        public let computeModel: ComputeModel?
        /// The number of CPU cores enabled on the VM cluster.
        public let cpuCoreCount: Int?
        /// The date and time when the VM cluster was created.
        public let createdAt: Date?
        public let dataCollectionOptions: DataCollectionOptions?
        /// The size of the data disk group, in terabytes (TB), that's allocated for the VM cluster.
        public let dataStorageSizeInTBs: Double?
        /// The amount of local node storage, in gigabytes (GB), that's allocated for the VM cluster.
        public let dbNodeStorageSizeInGBs: Int?
        /// The list of database servers for the VM cluster.
        public let dbServers: [String]?
        /// The type of redundancy configured for the VM cluster. NORMAL is 2-way redundancy. HIGH is 3-way redundancy.
        public let diskRedundancy: DiskRedundancy?
        /// The user-friendly name for the VM cluster.
        public let displayName: String?
        /// The domain of the VM cluster.
        public let domain: String?
        /// The software version of the Oracle Grid Infrastructure (GI) for the VM cluster.
        public let giVersion: String?
        /// The host name for the VM cluster.
        public let hostname: String?
        public let iormConfigCache: ExadataIormConfig?
        /// Indicates whether database backups to local Exadata storage is enabled for the VM cluster.
        public let isLocalBackupEnabled: Bool?
        /// Indicates whether the VM cluster is configured with a sparse disk group.
        public let isSparseDiskgroupEnabled: Bool?
        /// The Oracle Cloud ID (OCID) of the last maintenance update history entry.
        public let lastUpdateHistoryEntryId: String?
        /// The Oracle license model applied to the VM cluster.
        public let licenseModel: LicenseModel?
        /// The port number configured for the listener on the VM cluster.
        public let listenerPort: Int?
        /// The amount of memory, in gigabytes (GB), that's allocated for the VM cluster.
        public let memorySizeInGBs: Int?
        /// The number of nodes in the VM cluster.
        public let nodeCount: Int?
        /// The OCID of the VM cluster.
        public let ocid: String?
        /// The name of the OCI resource anchor for the VM cluster.
        public let ociResourceAnchorName: String?
        /// The HTTPS link to the VM cluster in OCI.
        public let ociUrl: String?
        /// The unique identifier of the ODB network for the VM cluster.
        public let odbNetworkId: String?
        /// The amount of progress made on the current operation on the VM cluster, expressed as a percentage.
        public let percentProgress: Float?
        /// The FQDN of the DNS record for the Single Client Access Name (SCAN) IP addresses that are associated with the VM cluster.
        public let scanDnsName: String?
        /// The OCID of the DNS record for the SCAN IP addresses that are associated with the VM cluster.
        public let scanDnsRecordId: String?
        /// The OCID of the SCAN IP addresses that are associated with the VM cluster.
        public let scanIpIds: [String]?
        /// The hardware model name of the Exadata infrastructure that's running the VM cluster.
        public let shape: String?
        /// The public key portion of one or more key pairs used for SSH access to the VM cluster.
        public let sshPublicKeys: [String]?
        /// The current status of the VM cluster.
        public let status: ResourceStatus?
        /// Additional information about the status of the VM cluster.
        public let statusReason: String?
        /// The amount of local node storage, in gigabytes (GB), that's allocated to the VM cluster.
        public let storageSizeInGBs: Int?
        /// The operating system version of the image chosen for the VM cluster.
        public let systemVersion: String?
        /// The time zone of the VM cluster.
        public let timeZone: String?
        /// The virtual IP (VIP) addresses that are associated with the VM cluster. Oracle's Cluster Ready Services (CRS) creates and maintains one VIP address for each node in the VM cluster to enable failover. If one node fails, the VIP is reassigned to another active node in the cluster.
        public let vipIds: [String]?

        @inlinable
        public init(cloudExadataInfrastructureId: String? = nil, cloudVmClusterArn: String? = nil, cloudVmClusterId: String, clusterName: String? = nil, computeModel: ComputeModel? = nil, cpuCoreCount: Int? = nil, createdAt: Date? = nil, dataCollectionOptions: DataCollectionOptions? = nil, dataStorageSizeInTBs: Double? = nil, dbNodeStorageSizeInGBs: Int? = nil, dbServers: [String]? = nil, diskRedundancy: DiskRedundancy? = nil, displayName: String? = nil, domain: String? = nil, giVersion: String? = nil, hostname: String? = nil, iormConfigCache: ExadataIormConfig? = nil, isLocalBackupEnabled: Bool? = nil, isSparseDiskgroupEnabled: Bool? = nil, lastUpdateHistoryEntryId: String? = nil, licenseModel: LicenseModel? = nil, listenerPort: Int? = nil, memorySizeInGBs: Int? = nil, nodeCount: Int? = nil, ocid: String? = nil, ociResourceAnchorName: String? = nil, ociUrl: String? = nil, odbNetworkId: String? = nil, percentProgress: Float? = nil, scanDnsName: String? = nil, scanDnsRecordId: String? = nil, scanIpIds: [String]? = nil, shape: String? = nil, sshPublicKeys: [String]? = nil, status: ResourceStatus? = nil, statusReason: String? = nil, storageSizeInGBs: Int? = nil, systemVersion: String? = nil, timeZone: String? = nil, vipIds: [String]? = nil) {
            self.cloudExadataInfrastructureId = cloudExadataInfrastructureId
            self.cloudVmClusterArn = cloudVmClusterArn
            self.cloudVmClusterId = cloudVmClusterId
            self.clusterName = clusterName
            self.computeModel = computeModel
            self.cpuCoreCount = cpuCoreCount
            self.createdAt = createdAt
            self.dataCollectionOptions = dataCollectionOptions
            self.dataStorageSizeInTBs = dataStorageSizeInTBs
            self.dbNodeStorageSizeInGBs = dbNodeStorageSizeInGBs
            self.dbServers = dbServers
            self.diskRedundancy = diskRedundancy
            self.displayName = displayName
            self.domain = domain
            self.giVersion = giVersion
            self.hostname = hostname
            self.iormConfigCache = iormConfigCache
            self.isLocalBackupEnabled = isLocalBackupEnabled
            self.isSparseDiskgroupEnabled = isSparseDiskgroupEnabled
            self.lastUpdateHistoryEntryId = lastUpdateHistoryEntryId
            self.licenseModel = licenseModel
            self.listenerPort = listenerPort
            self.memorySizeInGBs = memorySizeInGBs
            self.nodeCount = nodeCount
            self.ocid = ocid
            self.ociResourceAnchorName = ociResourceAnchorName
            self.ociUrl = ociUrl
            self.odbNetworkId = odbNetworkId
            self.percentProgress = percentProgress
            self.scanDnsName = scanDnsName
            self.scanDnsRecordId = scanDnsRecordId
            self.scanIpIds = scanIpIds
            self.shape = shape
            self.sshPublicKeys = sshPublicKeys
            self.status = status
            self.statusReason = statusReason
            self.storageSizeInGBs = storageSizeInGBs
            self.systemVersion = systemVersion
            self.timeZone = timeZone
            self.vipIds = vipIds
        }

        private enum CodingKeys: String, CodingKey {
            case cloudExadataInfrastructureId = "cloudExadataInfrastructureId"
            case cloudVmClusterArn = "cloudVmClusterArn"
            case cloudVmClusterId = "cloudVmClusterId"
            case clusterName = "clusterName"
            case computeModel = "computeModel"
            case cpuCoreCount = "cpuCoreCount"
            case createdAt = "createdAt"
            case dataCollectionOptions = "dataCollectionOptions"
            case dataStorageSizeInTBs = "dataStorageSizeInTBs"
            case dbNodeStorageSizeInGBs = "dbNodeStorageSizeInGBs"
            case dbServers = "dbServers"
            case diskRedundancy = "diskRedundancy"
            case displayName = "displayName"
            case domain = "domain"
            case giVersion = "giVersion"
            case hostname = "hostname"
            case iormConfigCache = "iormConfigCache"
            case isLocalBackupEnabled = "isLocalBackupEnabled"
            case isSparseDiskgroupEnabled = "isSparseDiskgroupEnabled"
            case lastUpdateHistoryEntryId = "lastUpdateHistoryEntryId"
            case licenseModel = "licenseModel"
            case listenerPort = "listenerPort"
            case memorySizeInGBs = "memorySizeInGBs"
            case nodeCount = "nodeCount"
            case ocid = "ocid"
            case ociResourceAnchorName = "ociResourceAnchorName"
            case ociUrl = "ociUrl"
            case odbNetworkId = "odbNetworkId"
            case percentProgress = "percentProgress"
            case scanDnsName = "scanDnsName"
            case scanDnsRecordId = "scanDnsRecordId"
            case scanIpIds = "scanIpIds"
            case shape = "shape"
            case sshPublicKeys = "sshPublicKeys"
            case status = "status"
            case statusReason = "statusReason"
            case storageSizeInGBs = "storageSizeInGBs"
            case systemVersion = "systemVersion"
            case timeZone = "timeZone"
            case vipIds = "vipIds"
        }
    }

    public struct ConflictException: AWSErrorShape {
        public let message: String
        /// The identifier of the resource that caused the conflict.
        public let resourceId: String
        /// The type of resource that caused the conflict.
        public let resourceType: String

        @inlinable
        public init(message: String, resourceId: String, resourceType: String) {
            self.message = message
            self.resourceId = resourceId
            self.resourceType = resourceType
        }

        private enum CodingKeys: String, CodingKey {
            case message = "message"
            case resourceId = "resourceId"
            case resourceType = "resourceType"
        }
    }

    public struct CreateCloudAutonomousVmClusterInput: AWSEncodableShape {
        /// The data disk group size to be allocated for Autonomous Databases, in terabytes (TB).
        public let autonomousDataStorageSizeInTBs: Double
        /// A client-provided token to ensure idempotency of the request.
        public let clientToken: String?
        /// The unique identifier of the Exadata infrastructure where the VM cluster will be created.
        public let cloudExadataInfrastructureId: String
        /// The number of CPU cores to be enabled per VM cluster node.
        public let cpuCoreCountPerNode: Int
        /// The list of database servers to be used for the Autonomous VM cluster.
        public let dbServers: [String]?
        /// A user-provided description of the Autonomous VM cluster.
        public let description: String?
        /// The display name for the Autonomous VM cluster. The name does not need to be unique.
        public let displayName: String
        /// Specifies whether to enable mutual TLS (mTLS) authentication for the Autonomous VM cluster.
        public let isMtlsEnabledVmCluster: Bool?
        /// The Oracle license model to apply to the Autonomous VM cluster.
        public let licenseModel: LicenseModel?
        /// The scheduling details for the maintenance window. Patching and system updates take place during the maintenance window.
        public let maintenanceWindow: MaintenanceWindow?
        /// The amount of memory to be allocated per OCPU, in GB.
        public let memoryPerOracleComputeUnitInGBs: Int
        /// The unique identifier of the ODB network to be used for the VM cluster.
        public let odbNetworkId: String
        /// The SCAN listener port for non-TLS (TCP) protocol.
        public let scanListenerPortNonTls: Int?
        /// The SCAN listener port for TLS (TCP) protocol.
        public let scanListenerPortTls: Int?
        /// Free-form tags for this resource. Each tag is a key-value pair with no predefined name, type, or namespace.
        public let tags: [String: String]?
        /// The time zone to use for the Autonomous VM cluster.
        public let timeZone: String?
        /// The total number of Autonomous CDBs that you can create in the Autonomous VM cluster.
        public let totalContainerDatabases: Int

        @inlinable
        public init(autonomousDataStorageSizeInTBs: Double, clientToken: String? = CreateCloudAutonomousVmClusterInput.idempotencyToken(), cloudExadataInfrastructureId: String, cpuCoreCountPerNode: Int, dbServers: [String]? = nil, description: String? = nil, displayName: String, isMtlsEnabledVmCluster: Bool? = nil, licenseModel: LicenseModel? = nil, maintenanceWindow: MaintenanceWindow? = nil, memoryPerOracleComputeUnitInGBs: Int, odbNetworkId: String, scanListenerPortNonTls: Int? = nil, scanListenerPortTls: Int? = nil, tags: [String: String]? = nil, timeZone: String? = nil, totalContainerDatabases: Int) {
            self.autonomousDataStorageSizeInTBs = autonomousDataStorageSizeInTBs
            self.clientToken = clientToken
            self.cloudExadataInfrastructureId = cloudExadataInfrastructureId
            self.cpuCoreCountPerNode = cpuCoreCountPerNode
            self.dbServers = dbServers
            self.description = description
            self.displayName = displayName
            self.isMtlsEnabledVmCluster = isMtlsEnabledVmCluster
            self.licenseModel = licenseModel
            self.maintenanceWindow = maintenanceWindow
            self.memoryPerOracleComputeUnitInGBs = memoryPerOracleComputeUnitInGBs
            self.odbNetworkId = odbNetworkId
            self.scanListenerPortNonTls = scanListenerPortNonTls
            self.scanListenerPortTls = scanListenerPortTls
            self.tags = tags
            self.timeZone = timeZone
            self.totalContainerDatabases = totalContainerDatabases
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "^[a-zA-Z0-9_\\/.=-]+$")
            try self.validate(self.cloudExadataInfrastructureId, name: "cloudExadataInfrastructureId", parent: name, max: 2048)
            try self.validate(self.cloudExadataInfrastructureId, name: "cloudExadataInfrastructureId", parent: name, min: 6)
            try self.validate(self.cloudExadataInfrastructureId, name: "cloudExadataInfrastructureId", parent: name, pattern: "^(arn:(?:aws|aws-cn|aws-us-gov|aws-iso-{0,1}[a-z]{0,1}):[a-z0-9-]+:[a-z0-9-]*:[0-9]+:[a-z0-9-]+/[a-zA-Z0-9_~.-]{6,64}|[a-zA-Z0-9_~.-]{6,64})$")
            try self.validate(self.dbServers, name: "dbServers", parent: name, max: 1024)
            try self.validate(self.dbServers, name: "dbServers", parent: name, min: 1)
            try self.validate(self.displayName, name: "displayName", parent: name, max: 255)
            try self.validate(self.displayName, name: "displayName", parent: name, min: 1)
            try self.validate(self.displayName, name: "displayName", parent: name, pattern: "^[a-zA-Z_](?!.*--)[a-zA-Z0-9_-]*$")
            try self.validate(self.odbNetworkId, name: "odbNetworkId", parent: name, max: 2048)
            try self.validate(self.odbNetworkId, name: "odbNetworkId", parent: name, min: 6)
            try self.validate(self.odbNetworkId, name: "odbNetworkId", parent: name, pattern: "^(arn:(?:aws|aws-cn|aws-us-gov|aws-iso-{0,1}[a-z]{0,1}):[a-z0-9-]+:[a-z0-9-]*:[0-9]+:[a-z0-9-]+/[a-zA-Z0-9_~.-]{6,64}|[a-zA-Z0-9_~.-]{6,64})$")
            try self.tags?.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 200)
            try self.validate(self.tags, name: "tags", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case autonomousDataStorageSizeInTBs = "autonomousDataStorageSizeInTBs"
            case clientToken = "clientToken"
            case cloudExadataInfrastructureId = "cloudExadataInfrastructureId"
            case cpuCoreCountPerNode = "cpuCoreCountPerNode"
            case dbServers = "dbServers"
            case description = "description"
            case displayName = "displayName"
            case isMtlsEnabledVmCluster = "isMtlsEnabledVmCluster"
            case licenseModel = "licenseModel"
            case maintenanceWindow = "maintenanceWindow"
            case memoryPerOracleComputeUnitInGBs = "memoryPerOracleComputeUnitInGBs"
            case odbNetworkId = "odbNetworkId"
            case scanListenerPortNonTls = "scanListenerPortNonTls"
            case scanListenerPortTls = "scanListenerPortTls"
            case tags = "tags"
            case timeZone = "timeZone"
            case totalContainerDatabases = "totalContainerDatabases"
        }
    }

    public struct CreateCloudAutonomousVmClusterOutput: AWSDecodableShape {
        /// The unique identifier of the created Autonomous VM cluster.
        public let cloudAutonomousVmClusterId: String
        /// The display name of the created Autonomous VM cluster.
        public let displayName: String?
        /// The current status of the Autonomous VM cluster creation process.
        public let status: ResourceStatus?
        /// Additional information about the current status of the Autonomous VM cluster creation process, if applicable.
        public let statusReason: String?

        @inlinable
        public init(cloudAutonomousVmClusterId: String, displayName: String? = nil, status: ResourceStatus? = nil, statusReason: String? = nil) {
            self.cloudAutonomousVmClusterId = cloudAutonomousVmClusterId
            self.displayName = displayName
            self.status = status
            self.statusReason = statusReason
        }

        private enum CodingKeys: String, CodingKey {
            case cloudAutonomousVmClusterId = "cloudAutonomousVmClusterId"
            case displayName = "displayName"
            case status = "status"
            case statusReason = "statusReason"
        }
    }

    public struct CreateCloudExadataInfrastructureInput: AWSEncodableShape {
        /// The name of the Availability Zone (AZ) where the Exadata infrastructure is located. This operation requires that you specify a value for either availabilityZone or availabilityZoneId. Example: us-east-1a
        public let availabilityZone: String?
        /// The AZ ID of the AZ where the Exadata infrastructure is located. This operation requires that you specify a value for either availabilityZone or availabilityZoneId. Example: use1-az1
        public let availabilityZoneId: String?
        /// A unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If you don't specify a client token, the Amazon Web Services SDK automatically generates a client token and uses it for the request to ensure idempotency. The client token is valid for up to 24 hours after it's first used.
        public let clientToken: String?
        /// The number of database servers for the Exadata infrastructure. Valid values for this parameter depend on the shape. To get information about the minimum and maximum values, use the ListDbSystemShapes operation.
        public let computeCount: Int
        /// The email addresses of contacts to receive notification from Oracle about maintenance updates for the Exadata infrastructure.
        public let customerContactsToSendToOCI: [CustomerContact]?
        /// The database server model type of the Exadata infrastructure. For the list of valid model names, use the ListDbSystemShapes operation.
        public let databaseServerType: String?
        /// A user-friendly name for the Exadata infrastructure.
        public let displayName: String
        /// The maintenance window configuration for the Exadata Cloud infrastructure. This allows you to define when maintenance operations such as patching and updates can be performed on the infrastructure.
        public let maintenanceWindow: MaintenanceWindow?
        /// The model name of the Exadata infrastructure. For the list of valid model names, use the ListDbSystemShapes operation.
        public let shape: String
        /// The number of storage servers to activate for this Exadata infrastructure. Valid values for this parameter depend on the shape. To get information about the minimum and maximum values, use the ListDbSystemShapes operation.
        public let storageCount: Int
        /// The storage server model type of the Exadata infrastructure. For the list of valid model names, use the ListDbSystemShapes operation.
        public let storageServerType: String?
        /// The list of resource tags to apply to the Exadata infrastructure.
        public let tags: [String: String]?

        @inlinable
        public init(availabilityZone: String? = nil, availabilityZoneId: String? = nil, clientToken: String? = CreateCloudExadataInfrastructureInput.idempotencyToken(), computeCount: Int, customerContactsToSendToOCI: [CustomerContact]? = nil, databaseServerType: String? = nil, displayName: String, maintenanceWindow: MaintenanceWindow? = nil, shape: String, storageCount: Int, storageServerType: String? = nil, tags: [String: String]? = nil) {
            self.availabilityZone = availabilityZone
            self.availabilityZoneId = availabilityZoneId
            self.clientToken = clientToken
            self.computeCount = computeCount
            self.customerContactsToSendToOCI = customerContactsToSendToOCI
            self.databaseServerType = databaseServerType
            self.displayName = displayName
            self.maintenanceWindow = maintenanceWindow
            self.shape = shape
            self.storageCount = storageCount
            self.storageServerType = storageServerType
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "^[a-zA-Z0-9_\\/.=-]+$")
            try self.validate(self.databaseServerType, name: "databaseServerType", parent: name, pattern: "^[a-zA-Z0-9_\\/.=-]+$")
            try self.validate(self.displayName, name: "displayName", parent: name, max: 255)
            try self.validate(self.displayName, name: "displayName", parent: name, min: 1)
            try self.validate(self.displayName, name: "displayName", parent: name, pattern: "^[a-zA-Z_](?!.*--)[a-zA-Z0-9_-]*$")
            try self.validate(self.shape, name: "shape", parent: name, pattern: "^[a-zA-Z0-9_\\/.=-]+$")
            try self.validate(self.storageServerType, name: "storageServerType", parent: name, pattern: "^[a-zA-Z0-9_\\/.=-]+$")
            try self.tags?.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 200)
            try self.validate(self.tags, name: "tags", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case availabilityZone = "availabilityZone"
            case availabilityZoneId = "availabilityZoneId"
            case clientToken = "clientToken"
            case computeCount = "computeCount"
            case customerContactsToSendToOCI = "customerContactsToSendToOCI"
            case databaseServerType = "databaseServerType"
            case displayName = "displayName"
            case maintenanceWindow = "maintenanceWindow"
            case shape = "shape"
            case storageCount = "storageCount"
            case storageServerType = "storageServerType"
            case tags = "tags"
        }
    }

    public struct CreateCloudExadataInfrastructureOutput: AWSDecodableShape {
        /// The unique identifier of the Exadata infrastructure.
        public let cloudExadataInfrastructureId: String
        /// The user-friendly name for the Exadata infrastructure.
        public let displayName: String?
        /// The current status of the Exadata infrastructure.
        public let status: ResourceStatus?
        /// Additional information about the status of the Exadata infrastructure.
        public let statusReason: String?

        @inlinable
        public init(cloudExadataInfrastructureId: String, displayName: String? = nil, status: ResourceStatus? = nil, statusReason: String? = nil) {
            self.cloudExadataInfrastructureId = cloudExadataInfrastructureId
            self.displayName = displayName
            self.status = status
            self.statusReason = statusReason
        }

        private enum CodingKeys: String, CodingKey {
            case cloudExadataInfrastructureId = "cloudExadataInfrastructureId"
            case displayName = "displayName"
            case status = "status"
            case statusReason = "statusReason"
        }
    }

    public struct CreateCloudVmClusterInput: AWSEncodableShape {
        /// A unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If you don't specify a client token, the Amazon Web Services SDK automatically generates a client token and uses it for the request to ensure idempotency. The client token is valid for up to 24 hours after it's first used.
        public let clientToken: String?
        /// The unique identifier of the Exadata infrastructure for this VM cluster.
        public let cloudExadataInfrastructureId: String
        /// A name for the Grid Infrastructure cluster. The name isn't case sensitive.
        public let clusterName: String?
        /// The number of CPU cores to enable on the VM cluster.
        public let cpuCoreCount: Int
        /// The set of preferences for the various diagnostic collection options for the VM cluster.
        public let dataCollectionOptions: DataCollectionOptions?
        /// The size of the data disk group, in terabytes (TBs), to allocate for the VM cluster.
        public let dataStorageSizeInTBs: Double?
        /// The amount of local node storage, in gigabytes (GBs), to allocate for the VM cluster.
        public let dbNodeStorageSizeInGBs: Int?
        /// The list of database servers for the VM cluster.
        public let dbServers: [String]?
        /// A user-friendly name for the VM cluster.
        public let displayName: String
        /// A valid software version of Oracle Grid Infrastructure (GI). To get the list of valid values, use the ListGiVersions operation and specify the shape of the Exadata infrastructure. Example: 19.0.0.0
        public let giVersion: String
        /// The host name for the VM cluster. Constraints:   Can't be "localhost" or "hostname".   Can't contain "-version".   The maximum length of the combined hostname and domain is 63 characters.   The hostname must be unique within the subnet.
        public let hostname: String
        /// Specifies whether to enable database backups to local Exadata storage for the VM cluster.
        public let isLocalBackupEnabled: Bool?
        /// Specifies whether to create a sparse disk group for the VM cluster.
        public let isSparseDiskgroupEnabled: Bool?
        /// The Oracle license model to apply to the VM cluster. Default: LICENSE_INCLUDED
        public let licenseModel: LicenseModel?
        /// The amount of memory, in gigabytes (GBs), to allocate for the VM cluster.
        public let memorySizeInGBs: Int?
        /// The unique identifier of the ODB network for the VM cluster.
        public let odbNetworkId: String
        /// The port number for TCP connections to the single client access name (SCAN) listener.  Valid values: 1024–8999 with the following exceptions: 2484, 6100, 6200, 7060, 7070, 7085, and 7879  Default: 1521
        public let scanListenerPortTcp: Int?
        /// The public key portion of one or more key pairs used for SSH access to the VM cluster.
        public let sshPublicKeys: [String]
        /// The version of the operating system of the image for the VM cluster.
        public let systemVersion: String?
        /// The list of resource tags to apply to the VM cluster.
        public let tags: [String: String]?
        /// The time zone for the VM cluster. For a list of valid values for time zone, you can check the options in the console. Default: UTC
        public let timeZone: String?

        @inlinable
        public init(clientToken: String? = CreateCloudVmClusterInput.idempotencyToken(), cloudExadataInfrastructureId: String, clusterName: String? = nil, cpuCoreCount: Int, dataCollectionOptions: DataCollectionOptions? = nil, dataStorageSizeInTBs: Double? = nil, dbNodeStorageSizeInGBs: Int? = nil, dbServers: [String]? = nil, displayName: String, giVersion: String, hostname: String, isLocalBackupEnabled: Bool? = nil, isSparseDiskgroupEnabled: Bool? = nil, licenseModel: LicenseModel? = nil, memorySizeInGBs: Int? = nil, odbNetworkId: String, scanListenerPortTcp: Int? = nil, sshPublicKeys: [String], systemVersion: String? = nil, tags: [String: String]? = nil, timeZone: String? = nil) {
            self.clientToken = clientToken
            self.cloudExadataInfrastructureId = cloudExadataInfrastructureId
            self.clusterName = clusterName
            self.cpuCoreCount = cpuCoreCount
            self.dataCollectionOptions = dataCollectionOptions
            self.dataStorageSizeInTBs = dataStorageSizeInTBs
            self.dbNodeStorageSizeInGBs = dbNodeStorageSizeInGBs
            self.dbServers = dbServers
            self.displayName = displayName
            self.giVersion = giVersion
            self.hostname = hostname
            self.isLocalBackupEnabled = isLocalBackupEnabled
            self.isSparseDiskgroupEnabled = isSparseDiskgroupEnabled
            self.licenseModel = licenseModel
            self.memorySizeInGBs = memorySizeInGBs
            self.odbNetworkId = odbNetworkId
            self.scanListenerPortTcp = scanListenerPortTcp
            self.sshPublicKeys = sshPublicKeys
            self.systemVersion = systemVersion
            self.tags = tags
            self.timeZone = timeZone
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "^[a-zA-Z0-9_\\/.=-]+$")
            try self.validate(self.cloudExadataInfrastructureId, name: "cloudExadataInfrastructureId", parent: name, max: 2048)
            try self.validate(self.cloudExadataInfrastructureId, name: "cloudExadataInfrastructureId", parent: name, min: 6)
            try self.validate(self.cloudExadataInfrastructureId, name: "cloudExadataInfrastructureId", parent: name, pattern: "^(arn:(?:aws|aws-cn|aws-us-gov|aws-iso-{0,1}[a-z]{0,1}):[a-z0-9-]+:[a-z0-9-]*:[0-9]+:[a-z0-9-]+/[a-zA-Z0-9_~.-]{6,64}|[a-zA-Z0-9_~.-]{6,64})$")
            try self.validate(self.dbServers, name: "dbServers", parent: name, max: 1024)
            try self.validate(self.dbServers, name: "dbServers", parent: name, min: 1)
            try self.validate(self.displayName, name: "displayName", parent: name, max: 255)
            try self.validate(self.displayName, name: "displayName", parent: name, min: 1)
            try self.validate(self.displayName, name: "displayName", parent: name, pattern: "^[a-zA-Z_](?!.*--)[a-zA-Z0-9_-]*$")
            try self.validate(self.odbNetworkId, name: "odbNetworkId", parent: name, max: 2048)
            try self.validate(self.odbNetworkId, name: "odbNetworkId", parent: name, min: 6)
            try self.validate(self.odbNetworkId, name: "odbNetworkId", parent: name, pattern: "^(arn:(?:aws|aws-cn|aws-us-gov|aws-iso-{0,1}[a-z]{0,1}):[a-z0-9-]+:[a-z0-9-]*:[0-9]+:[a-z0-9-]+/[a-zA-Z0-9_~.-]{6,64}|[a-zA-Z0-9_~.-]{6,64})$")
            try self.validate(self.sshPublicKeys, name: "sshPublicKeys", parent: name, max: 1024)
            try self.validate(self.sshPublicKeys, name: "sshPublicKeys", parent: name, min: 1)
            try self.tags?.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 200)
            try self.validate(self.tags, name: "tags", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "clientToken"
            case cloudExadataInfrastructureId = "cloudExadataInfrastructureId"
            case clusterName = "clusterName"
            case cpuCoreCount = "cpuCoreCount"
            case dataCollectionOptions = "dataCollectionOptions"
            case dataStorageSizeInTBs = "dataStorageSizeInTBs"
            case dbNodeStorageSizeInGBs = "dbNodeStorageSizeInGBs"
            case dbServers = "dbServers"
            case displayName = "displayName"
            case giVersion = "giVersion"
            case hostname = "hostname"
            case isLocalBackupEnabled = "isLocalBackupEnabled"
            case isSparseDiskgroupEnabled = "isSparseDiskgroupEnabled"
            case licenseModel = "licenseModel"
            case memorySizeInGBs = "memorySizeInGBs"
            case odbNetworkId = "odbNetworkId"
            case scanListenerPortTcp = "scanListenerPortTcp"
            case sshPublicKeys = "sshPublicKeys"
            case systemVersion = "systemVersion"
            case tags = "tags"
            case timeZone = "timeZone"
        }
    }

    public struct CreateCloudVmClusterOutput: AWSDecodableShape {
        /// The unique identifier for the VM cluster.
        public let cloudVmClusterId: String
        /// The user-friendly name for the VM cluster.
        public let displayName: String?
        /// The current status of the VM cluster.
        public let status: ResourceStatus?
        /// Additional information about the status of the VM cluster.
        public let statusReason: String?

        @inlinable
        public init(cloudVmClusterId: String, displayName: String? = nil, status: ResourceStatus? = nil, statusReason: String? = nil) {
            self.cloudVmClusterId = cloudVmClusterId
            self.displayName = displayName
            self.status = status
            self.statusReason = statusReason
        }

        private enum CodingKeys: String, CodingKey {
            case cloudVmClusterId = "cloudVmClusterId"
            case displayName = "displayName"
            case status = "status"
            case statusReason = "statusReason"
        }
    }

    public struct CreateOdbNetworkInput: AWSEncodableShape {
        /// The Amazon Web Services Availability Zone (AZ) where the ODB network is located. This operation requires that you specify a value for either availabilityZone or availabilityZoneId.
        public let availabilityZone: String?
        /// The AZ ID of the AZ where the ODB network is located. This operation requires that you specify a value for either availabilityZone or availabilityZoneId.
        public let availabilityZoneId: String?
        /// The CIDR range of the backup subnet for the ODB network. Constraints:   Must not overlap with the CIDR range of the client subnet.   Must not overlap with the CIDR ranges of the VPCs that are connected to the ODB network.   Must not use the following CIDR ranges that are reserved by OCI:    100.106.0.0/16 and 100.107.0.0/16     169.254.0.0/16     224.0.0.0 - 239.255.255.255     240.0.0.0 - 255.255.255.255
        public let backupSubnetCidr: String?
        /// The CIDR range of the client subnet for the ODB network. Constraints:   Must not overlap with the CIDR range of the backup subnet.   Must not overlap with the CIDR ranges of the VPCs that are connected to the ODB network.   Must not use the following CIDR ranges that are reserved by OCI:    100.106.0.0/16 and 100.107.0.0/16     169.254.0.0/16     224.0.0.0 - 239.255.255.255     240.0.0.0 - 255.255.255.255
        public let clientSubnetCidr: String
        /// A unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If you don't specify a client token, the Amazon Web Services SDK automatically generates a client token and uses it for the request to ensure idempotency. The client token is valid for up to 24 hours after it's first used.
        public let clientToken: String?
        /// The domain name to use for the resources in the ODB network.
        public let customDomainName: String?
        /// The DNS prefix to the default DNS domain name. The default DNS domain name is oraclevcn.com.
        public let defaultDnsPrefix: String?
        /// A user-friendly name for the ODB network.
        public let displayName: String
        /// Specifies the configuration for Amazon S3 access from the ODB network.
        public let s3Access: Access?
        /// Specifies the endpoint policy for Amazon S3 access from the ODB network.
        public let s3PolicyDocument: String?
        /// The list of resource tags to apply to the ODB network.
        public let tags: [String: String]?
        /// Specifies the configuration for Zero-ETL access from the ODB network.
        public let zeroEtlAccess: Access?

        @inlinable
        public init(availabilityZone: String? = nil, availabilityZoneId: String? = nil, backupSubnetCidr: String? = nil, clientSubnetCidr: String, clientToken: String? = CreateOdbNetworkInput.idempotencyToken(), customDomainName: String? = nil, defaultDnsPrefix: String? = nil, displayName: String, s3Access: Access? = nil, s3PolicyDocument: String? = nil, tags: [String: String]? = nil, zeroEtlAccess: Access? = nil) {
            self.availabilityZone = availabilityZone
            self.availabilityZoneId = availabilityZoneId
            self.backupSubnetCidr = backupSubnetCidr
            self.clientSubnetCidr = clientSubnetCidr
            self.clientToken = clientToken
            self.customDomainName = customDomainName
            self.defaultDnsPrefix = defaultDnsPrefix
            self.displayName = displayName
            self.s3Access = s3Access
            self.s3PolicyDocument = s3PolicyDocument
            self.tags = tags
            self.zeroEtlAccess = zeroEtlAccess
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "^[a-zA-Z0-9_\\/.=-]+$")
            try self.validate(self.displayName, name: "displayName", parent: name, max: 255)
            try self.validate(self.displayName, name: "displayName", parent: name, min: 1)
            try self.validate(self.displayName, name: "displayName", parent: name, pattern: "^[a-zA-Z_](?!.*--)[a-zA-Z0-9_-]*$")
            try self.validate(self.s3PolicyDocument, name: "s3PolicyDocument", parent: name, max: 20480)
            try self.validate(self.s3PolicyDocument, name: "s3PolicyDocument", parent: name, min: 3)
            try self.tags?.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 200)
            try self.validate(self.tags, name: "tags", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case availabilityZone = "availabilityZone"
            case availabilityZoneId = "availabilityZoneId"
            case backupSubnetCidr = "backupSubnetCidr"
            case clientSubnetCidr = "clientSubnetCidr"
            case clientToken = "clientToken"
            case customDomainName = "customDomainName"
            case defaultDnsPrefix = "defaultDnsPrefix"
            case displayName = "displayName"
            case s3Access = "s3Access"
            case s3PolicyDocument = "s3PolicyDocument"
            case tags = "tags"
            case zeroEtlAccess = "zeroEtlAccess"
        }
    }

    public struct CreateOdbNetworkOutput: AWSDecodableShape {
        /// The user-friendly name of the ODB network.
        public let displayName: String?
        /// The unique identifier of the ODB network.
        public let odbNetworkId: String
        /// The current status of the ODB network.
        public let status: ResourceStatus?
        /// Additional information about the status of the ODB network.
        public let statusReason: String?

        @inlinable
        public init(displayName: String? = nil, odbNetworkId: String, status: ResourceStatus? = nil, statusReason: String? = nil) {
            self.displayName = displayName
            self.odbNetworkId = odbNetworkId
            self.status = status
            self.statusReason = statusReason
        }

        private enum CodingKeys: String, CodingKey {
            case displayName = "displayName"
            case odbNetworkId = "odbNetworkId"
            case status = "status"
            case statusReason = "statusReason"
        }
    }

    public struct CreateOdbPeeringConnectionInput: AWSEncodableShape {
        /// The client token for the ODB peering connection request. Constraints:   Must be unique for each request.
        public let clientToken: String?
        /// The display name for the ODB peering connection.
        public let displayName: String?
        /// The unique identifier of the ODB network that initiates the peering connection.
        public let odbNetworkId: String
        /// The unique identifier of the peer network. This can be either a VPC ID or another ODB network ID.
        public let peerNetworkId: String
        /// The tags to assign to the ODB peering connection.
        public let tags: [String: String]?

        @inlinable
        public init(clientToken: String? = CreateOdbPeeringConnectionInput.idempotencyToken(), displayName: String? = nil, odbNetworkId: String, peerNetworkId: String, tags: [String: String]? = nil) {
            self.clientToken = clientToken
            self.displayName = displayName
            self.odbNetworkId = odbNetworkId
            self.peerNetworkId = peerNetworkId
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "^[a-zA-Z0-9_\\/.=-]+$")
            try self.validate(self.displayName, name: "displayName", parent: name, max: 255)
            try self.validate(self.displayName, name: "displayName", parent: name, min: 1)
            try self.validate(self.displayName, name: "displayName", parent: name, pattern: "^[a-zA-Z_](?!.*--)[a-zA-Z0-9_-]*$")
            try self.validate(self.odbNetworkId, name: "odbNetworkId", parent: name, max: 2048)
            try self.validate(self.odbNetworkId, name: "odbNetworkId", parent: name, min: 6)
            try self.validate(self.odbNetworkId, name: "odbNetworkId", parent: name, pattern: "^(arn:(?:aws|aws-cn|aws-us-gov|aws-iso-{0,1}[a-z]{0,1}):[a-z0-9-]+:[a-z0-9-]*:[0-9]+:[a-z0-9-]+/[a-zA-Z0-9_~.-]{6,64}|[a-zA-Z0-9_~.-]{6,64})$")
            try self.validate(self.peerNetworkId, name: "peerNetworkId", parent: name, max: 2048)
            try self.validate(self.peerNetworkId, name: "peerNetworkId", parent: name, min: 6)
            try self.validate(self.peerNetworkId, name: "peerNetworkId", parent: name, pattern: "^(arn:(?:aws|aws-cn|aws-us-gov|aws-iso-{0,1}[a-z]{0,1}):[a-z0-9-]+:[a-z0-9-]*:[0-9]+:[a-z0-9-]+/[a-zA-Z0-9_~.-]{6,64}|[a-zA-Z0-9_~.-]{6,64})$")
            try self.tags?.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 200)
            try self.validate(self.tags, name: "tags", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "clientToken"
            case displayName = "displayName"
            case odbNetworkId = "odbNetworkId"
            case peerNetworkId = "peerNetworkId"
            case tags = "tags"
        }
    }

    public struct CreateOdbPeeringConnectionOutput: AWSDecodableShape {
        /// The display name of the ODB peering connection.
        public let displayName: String?
        /// The unique identifier of the ODB peering connection.
        public let odbPeeringConnectionId: String
        /// The status of the ODB peering connection. Valid Values: provisioning | active | terminating | terminated | failed
        public let status: ResourceStatus?
        /// The reason for the current status of the ODB peering connection.
        public let statusReason: String?

        @inlinable
        public init(displayName: String? = nil, odbPeeringConnectionId: String, status: ResourceStatus? = nil, statusReason: String? = nil) {
            self.displayName = displayName
            self.odbPeeringConnectionId = odbPeeringConnectionId
            self.status = status
            self.statusReason = statusReason
        }

        private enum CodingKeys: String, CodingKey {
            case displayName = "displayName"
            case odbPeeringConnectionId = "odbPeeringConnectionId"
            case status = "status"
            case statusReason = "statusReason"
        }
    }

    public struct CustomerContact: AWSEncodableShape & AWSDecodableShape {
        /// The email address of the contact.
        public let email: String?

        @inlinable
        public init(email: String? = nil) {
            self.email = email
        }

        private enum CodingKeys: String, CodingKey {
            case email = "email"
        }
    }

    public struct DataCollectionOptions: AWSEncodableShape & AWSDecodableShape {
        /// Indicates whether diagnostic collection is enabled for the VM cluster.
        public let isDiagnosticsEventsEnabled: Bool?
        /// Indicates whether health monitoring is enabled for the VM cluster.
        public let isHealthMonitoringEnabled: Bool?
        /// Indicates whether incident logs are enabled for the cloud VM cluster.
        public let isIncidentLogsEnabled: Bool?

        @inlinable
        public init(isDiagnosticsEventsEnabled: Bool? = nil, isHealthMonitoringEnabled: Bool? = nil, isIncidentLogsEnabled: Bool? = nil) {
            self.isDiagnosticsEventsEnabled = isDiagnosticsEventsEnabled
            self.isHealthMonitoringEnabled = isHealthMonitoringEnabled
            self.isIncidentLogsEnabled = isIncidentLogsEnabled
        }

        private enum CodingKeys: String, CodingKey {
            case isDiagnosticsEventsEnabled = "isDiagnosticsEventsEnabled"
            case isHealthMonitoringEnabled = "isHealthMonitoringEnabled"
            case isIncidentLogsEnabled = "isIncidentLogsEnabled"
        }
    }

    public struct DayOfWeek: AWSEncodableShape & AWSDecodableShape {
        /// The name of the day of the week.
        public let name: DayOfWeekName?

        @inlinable
        public init(name: DayOfWeekName? = nil) {
            self.name = name
        }

        private enum CodingKeys: String, CodingKey {
            case name = "name"
        }
    }

    public struct DbIormConfig: AWSDecodableShape {
        /// The database name. For the default DbPlan, the dbName is default.
        public let dbName: String?
        /// The flash cache limit for this database. This value is internally configured based on the share value assigned to the database.
        public let flashCacheLimit: String?
        /// The relative priority of this database.
        public let share: Int?

        @inlinable
        public init(dbName: String? = nil, flashCacheLimit: String? = nil, share: Int? = nil) {
            self.dbName = dbName
            self.flashCacheLimit = flashCacheLimit
            self.share = share
        }

        private enum CodingKeys: String, CodingKey {
            case dbName = "dbName"
            case flashCacheLimit = "flashCacheLimit"
            case share = "share"
        }
    }

    public struct DbNode: AWSDecodableShape {
        /// Additional information about the planned maintenance.
        public let additionalDetails: String?
        /// The Oracle Cloud ID (OCID) of the backup IP address that's associated with the DB node.
        public let backupIpId: String?
        /// The OCID of the second backup VNIC.
        public let backupVnic2Id: String?
        /// The OCID of the backup VNIC.
        public let backupVnicId: String?
        /// Number of CPU cores enabled on the DB node.
        public let cpuCoreCount: Int?
        /// The date and time when the DB node was created.
        public let createdAt: Date?
        /// The Amazon Resource Name (ARN) of the DB node.
        public let dbNodeArn: String?
        /// The unique identifier of the DB node.
        public let dbNodeId: String?
        /// The amount of local node storage, in gigabytes (GBs), that's allocated on the DB node.
        public let dbNodeStorageSizeInGBs: Int?
        /// The unique identifier of the Db server that is associated with the DB node.
        public let dbServerId: String?
        /// The OCID of the DB system.
        public let dbSystemId: String?
        /// The name of the fault domain the instance is contained in.
        public let faultDomain: String?
        /// The floating IP address assigned to the DB node.
        public let floatingIpAddress: String?
        /// The OCID of the host IP address that's associated with the DB node.
        public let hostIpId: String?
        /// The host name for the DB node.
        public let hostname: String?
        /// The type of database node maintenance. Either VMDB_REBOOT_MIGRATION or EXADBXS_REBOOT_MIGRATION.
        public let maintenanceType: DbNodeMaintenanceType?
        /// The allocated memory in GBs on the DB node.
        public let memorySizeInGBs: Int?
        /// The OCID of the DB node.
        public let ocid: String?
        /// The name of the OCI resource anchor for the DB node.
        public let ociResourceAnchorName: String?
        /// The private IP address assigned to the DB node.
        public let privateIpAddress: String?
        /// The size (in GB) of the block storage volume allocation for the DB system.
        public let softwareStorageSizeInGB: Int?
        /// The current status of the DB node.
        public let status: DbNodeResourceStatus?
        /// Additional information about the status of the DB node.
        public let statusReason: String?
        /// End date and time of maintenance window.
        public let timeMaintenanceWindowEnd: String?
        /// Start date and time of maintenance window.
        public let timeMaintenanceWindowStart: String?
        /// The total number of CPU cores reserved on the DB node.
        public let totalCpuCoreCount: Int?
        /// The OCID of the second VNIC.
        public let vnic2Id: String?
        /// The OCID of the VNIC.
        public let vnicId: String?

        @inlinable
        public init(additionalDetails: String? = nil, backupIpId: String? = nil, backupVnic2Id: String? = nil, backupVnicId: String? = nil, cpuCoreCount: Int? = nil, createdAt: Date? = nil, dbNodeArn: String? = nil, dbNodeId: String? = nil, dbNodeStorageSizeInGBs: Int? = nil, dbServerId: String? = nil, dbSystemId: String? = nil, faultDomain: String? = nil, floatingIpAddress: String? = nil, hostIpId: String? = nil, hostname: String? = nil, maintenanceType: DbNodeMaintenanceType? = nil, memorySizeInGBs: Int? = nil, ocid: String? = nil, ociResourceAnchorName: String? = nil, privateIpAddress: String? = nil, softwareStorageSizeInGB: Int? = nil, status: DbNodeResourceStatus? = nil, statusReason: String? = nil, timeMaintenanceWindowEnd: String? = nil, timeMaintenanceWindowStart: String? = nil, totalCpuCoreCount: Int? = nil, vnic2Id: String? = nil, vnicId: String? = nil) {
            self.additionalDetails = additionalDetails
            self.backupIpId = backupIpId
            self.backupVnic2Id = backupVnic2Id
            self.backupVnicId = backupVnicId
            self.cpuCoreCount = cpuCoreCount
            self.createdAt = createdAt
            self.dbNodeArn = dbNodeArn
            self.dbNodeId = dbNodeId
            self.dbNodeStorageSizeInGBs = dbNodeStorageSizeInGBs
            self.dbServerId = dbServerId
            self.dbSystemId = dbSystemId
            self.faultDomain = faultDomain
            self.floatingIpAddress = floatingIpAddress
            self.hostIpId = hostIpId
            self.hostname = hostname
            self.maintenanceType = maintenanceType
            self.memorySizeInGBs = memorySizeInGBs
            self.ocid = ocid
            self.ociResourceAnchorName = ociResourceAnchorName
            self.privateIpAddress = privateIpAddress
            self.softwareStorageSizeInGB = softwareStorageSizeInGB
            self.status = status
            self.statusReason = statusReason
            self.timeMaintenanceWindowEnd = timeMaintenanceWindowEnd
            self.timeMaintenanceWindowStart = timeMaintenanceWindowStart
            self.totalCpuCoreCount = totalCpuCoreCount
            self.vnic2Id = vnic2Id
            self.vnicId = vnicId
        }

        private enum CodingKeys: String, CodingKey {
            case additionalDetails = "additionalDetails"
            case backupIpId = "backupIpId"
            case backupVnic2Id = "backupVnic2Id"
            case backupVnicId = "backupVnicId"
            case cpuCoreCount = "cpuCoreCount"
            case createdAt = "createdAt"
            case dbNodeArn = "dbNodeArn"
            case dbNodeId = "dbNodeId"
            case dbNodeStorageSizeInGBs = "dbNodeStorageSizeInGBs"
            case dbServerId = "dbServerId"
            case dbSystemId = "dbSystemId"
            case faultDomain = "faultDomain"
            case floatingIpAddress = "floatingIpAddress"
            case hostIpId = "hostIpId"
            case hostname = "hostname"
            case maintenanceType = "maintenanceType"
            case memorySizeInGBs = "memorySizeInGBs"
            case ocid = "ocid"
            case ociResourceAnchorName = "ociResourceAnchorName"
            case privateIpAddress = "privateIpAddress"
            case softwareStorageSizeInGB = "softwareStorageSizeInGB"
            case status = "status"
            case statusReason = "statusReason"
            case timeMaintenanceWindowEnd = "timeMaintenanceWindowEnd"
            case timeMaintenanceWindowStart = "timeMaintenanceWindowStart"
            case totalCpuCoreCount = "totalCpuCoreCount"
            case vnic2Id = "vnic2Id"
            case vnicId = "vnicId"
        }
    }

    public struct DbNodeSummary: AWSDecodableShape {
        /// Additional information about the planned maintenance.
        public let additionalDetails: String?
        /// The Oracle Cloud ID (OCID) of the backup IP address that's associated with the DB node.
        public let backupIpId: String?
        /// The OCID of the second backup virtual network interface card (VNIC) for the DB node.
        public let backupVnic2Id: String?
        /// The OCID of the backup VNIC for the DB node.
        public let backupVnicId: String?
        /// The number of CPU cores enabled on the DB node.
        public let cpuCoreCount: Int?
        /// The date and time when the DB node was created.
        public let createdAt: Date?
        /// The Amazon Resource Name (ARN) of the DB node.
        public let dbNodeArn: String?
        /// The unique identifier of the DB node.
        public let dbNodeId: String?
        /// The amount of local node storage, in gigabytes (GB), that's allocated on the DB node.
        public let dbNodeStorageSizeInGBs: Int?
        /// The unique identifier of the database server that's associated with the DB node.
        public let dbServerId: String?
        /// The OCID of the DB system.
        public let dbSystemId: String?
        /// The name of the fault domain where the DB node is located.
        public let faultDomain: String?
        /// The OCID of the host IP address that's associated with the DB node.
        public let hostIpId: String?
        /// The host name for the DB node.
        public let hostname: String?
        /// The type of maintenance the DB node.
        public let maintenanceType: DbNodeMaintenanceType?
        /// The amount of memory, in gigabytes (GB), that allocated on the DB node.
        public let memorySizeInGBs: Int?
        /// The OCID of the DB node.
        public let ocid: String?
        /// The name of the OCI resource anchor for the DB node.
        public let ociResourceAnchorName: String?
        /// The size of the block storage volume, in gigabytes (GB), that's allocated for the DB system. This attribute applies only for virtual machine DB systems.
        public let softwareStorageSizeInGB: Int?
        /// The current status of the DB node.
        public let status: DbNodeResourceStatus?
        /// Additional information about the status of the DB node.
        public let statusReason: String?
        /// The end date and time of the maintenance window.
        public let timeMaintenanceWindowEnd: String?
        /// The start date and time of the maintenance window.
        public let timeMaintenanceWindowStart: String?
        /// The total number of CPU cores reserved on the DB node.
        public let totalCpuCoreCount: Int?
        /// The OCID of the second VNIC.
        public let vnic2Id: String?
        /// The OCID of the VNIC.
        public let vnicId: String?

        @inlinable
        public init(additionalDetails: String? = nil, backupIpId: String? = nil, backupVnic2Id: String? = nil, backupVnicId: String? = nil, cpuCoreCount: Int? = nil, createdAt: Date? = nil, dbNodeArn: String? = nil, dbNodeId: String? = nil, dbNodeStorageSizeInGBs: Int? = nil, dbServerId: String? = nil, dbSystemId: String? = nil, faultDomain: String? = nil, hostIpId: String? = nil, hostname: String? = nil, maintenanceType: DbNodeMaintenanceType? = nil, memorySizeInGBs: Int? = nil, ocid: String? = nil, ociResourceAnchorName: String? = nil, softwareStorageSizeInGB: Int? = nil, status: DbNodeResourceStatus? = nil, statusReason: String? = nil, timeMaintenanceWindowEnd: String? = nil, timeMaintenanceWindowStart: String? = nil, totalCpuCoreCount: Int? = nil, vnic2Id: String? = nil, vnicId: String? = nil) {
            self.additionalDetails = additionalDetails
            self.backupIpId = backupIpId
            self.backupVnic2Id = backupVnic2Id
            self.backupVnicId = backupVnicId
            self.cpuCoreCount = cpuCoreCount
            self.createdAt = createdAt
            self.dbNodeArn = dbNodeArn
            self.dbNodeId = dbNodeId
            self.dbNodeStorageSizeInGBs = dbNodeStorageSizeInGBs
            self.dbServerId = dbServerId
            self.dbSystemId = dbSystemId
            self.faultDomain = faultDomain
            self.hostIpId = hostIpId
            self.hostname = hostname
            self.maintenanceType = maintenanceType
            self.memorySizeInGBs = memorySizeInGBs
            self.ocid = ocid
            self.ociResourceAnchorName = ociResourceAnchorName
            self.softwareStorageSizeInGB = softwareStorageSizeInGB
            self.status = status
            self.statusReason = statusReason
            self.timeMaintenanceWindowEnd = timeMaintenanceWindowEnd
            self.timeMaintenanceWindowStart = timeMaintenanceWindowStart
            self.totalCpuCoreCount = totalCpuCoreCount
            self.vnic2Id = vnic2Id
            self.vnicId = vnicId
        }

        private enum CodingKeys: String, CodingKey {
            case additionalDetails = "additionalDetails"
            case backupIpId = "backupIpId"
            case backupVnic2Id = "backupVnic2Id"
            case backupVnicId = "backupVnicId"
            case cpuCoreCount = "cpuCoreCount"
            case createdAt = "createdAt"
            case dbNodeArn = "dbNodeArn"
            case dbNodeId = "dbNodeId"
            case dbNodeStorageSizeInGBs = "dbNodeStorageSizeInGBs"
            case dbServerId = "dbServerId"
            case dbSystemId = "dbSystemId"
            case faultDomain = "faultDomain"
            case hostIpId = "hostIpId"
            case hostname = "hostname"
            case maintenanceType = "maintenanceType"
            case memorySizeInGBs = "memorySizeInGBs"
            case ocid = "ocid"
            case ociResourceAnchorName = "ociResourceAnchorName"
            case softwareStorageSizeInGB = "softwareStorageSizeInGB"
            case status = "status"
            case statusReason = "statusReason"
            case timeMaintenanceWindowEnd = "timeMaintenanceWindowEnd"
            case timeMaintenanceWindowStart = "timeMaintenanceWindowStart"
            case totalCpuCoreCount = "totalCpuCoreCount"
            case vnic2Id = "vnic2Id"
            case vnicId = "vnicId"
        }
    }

    public struct DbServer: AWSDecodableShape {
        /// The list of unique identifiers for the Autonomous VMs associated with this database server.
        public let autonomousVirtualMachineIds: [String]?
        /// The list of identifiers for the Autonomous VM clusters associated with this database server.
        public let autonomousVmClusterIds: [String]?
        /// The compute model of the database server (ECPU or OCPU).
        public let computeModel: ComputeModel?
        /// The number of CPU cores enabled on the database server.
        public let cpuCoreCount: Int?
        /// The date and time when the database server was created.
        public let createdAt: Date?
        /// The allocated local node storage in GBs on the database server.
        public let dbNodeStorageSizeInGBs: Int?
        /// The unique identifier for the database server.
        public let dbServerId: String?
        /// The scheduling details for the quarterly maintenance window. Patching and system updates take place during the maintenance window.
        public let dbServerPatchingDetails: DbServerPatchingDetails?
        /// The user-friendly name of the database server.
        public let displayName: String?
        /// The ID of the Exadata infrastructure the database server belongs to.
        public let exadataInfrastructureId: String?
        /// The total number of CPU cores available.
        public let maxCpuCount: Int?
        /// The total local node storage available in GBs.
        public let maxDbNodeStorageInGBs: Int?
        /// The total memory available in GBs.
        public let maxMemoryInGBs: Int?
        /// The allocated memory in GBs on the database server.
        public let memorySizeInGBs: Int?
        /// The OCID of the database server.
        public let ocid: String?
        /// The name of the OCI resource anchor for the database server.
        public let ociResourceAnchorName: String?
        /// The shape of the database server. The shape determines the amount of CPU, storage, and memory resources available.
        public let shape: String?
        /// The current status of the database server.
        public let status: ResourceStatus?
        /// Additional information about the current status of the database server.
        public let statusReason: String?
        /// The OCID of the VM clusters that are associated with the database server.
        public let vmClusterIds: [String]?

        @inlinable
        public init(autonomousVirtualMachineIds: [String]? = nil, autonomousVmClusterIds: [String]? = nil, computeModel: ComputeModel? = nil, cpuCoreCount: Int? = nil, createdAt: Date? = nil, dbNodeStorageSizeInGBs: Int? = nil, dbServerId: String? = nil, dbServerPatchingDetails: DbServerPatchingDetails? = nil, displayName: String? = nil, exadataInfrastructureId: String? = nil, maxCpuCount: Int? = nil, maxDbNodeStorageInGBs: Int? = nil, maxMemoryInGBs: Int? = nil, memorySizeInGBs: Int? = nil, ocid: String? = nil, ociResourceAnchorName: String? = nil, shape: String? = nil, status: ResourceStatus? = nil, statusReason: String? = nil, vmClusterIds: [String]? = nil) {
            self.autonomousVirtualMachineIds = autonomousVirtualMachineIds
            self.autonomousVmClusterIds = autonomousVmClusterIds
            self.computeModel = computeModel
            self.cpuCoreCount = cpuCoreCount
            self.createdAt = createdAt
            self.dbNodeStorageSizeInGBs = dbNodeStorageSizeInGBs
            self.dbServerId = dbServerId
            self.dbServerPatchingDetails = dbServerPatchingDetails
            self.displayName = displayName
            self.exadataInfrastructureId = exadataInfrastructureId
            self.maxCpuCount = maxCpuCount
            self.maxDbNodeStorageInGBs = maxDbNodeStorageInGBs
            self.maxMemoryInGBs = maxMemoryInGBs
            self.memorySizeInGBs = memorySizeInGBs
            self.ocid = ocid
            self.ociResourceAnchorName = ociResourceAnchorName
            self.shape = shape
            self.status = status
            self.statusReason = statusReason
            self.vmClusterIds = vmClusterIds
        }

        private enum CodingKeys: String, CodingKey {
            case autonomousVirtualMachineIds = "autonomousVirtualMachineIds"
            case autonomousVmClusterIds = "autonomousVmClusterIds"
            case computeModel = "computeModel"
            case cpuCoreCount = "cpuCoreCount"
            case createdAt = "createdAt"
            case dbNodeStorageSizeInGBs = "dbNodeStorageSizeInGBs"
            case dbServerId = "dbServerId"
            case dbServerPatchingDetails = "dbServerPatchingDetails"
            case displayName = "displayName"
            case exadataInfrastructureId = "exadataInfrastructureId"
            case maxCpuCount = "maxCpuCount"
            case maxDbNodeStorageInGBs = "maxDbNodeStorageInGBs"
            case maxMemoryInGBs = "maxMemoryInGBs"
            case memorySizeInGBs = "memorySizeInGBs"
            case ocid = "ocid"
            case ociResourceAnchorName = "ociResourceAnchorName"
            case shape = "shape"
            case status = "status"
            case statusReason = "statusReason"
            case vmClusterIds = "vmClusterIds"
        }
    }

    public struct DbServerPatchingDetails: AWSDecodableShape {
        /// Estimated time, in minutes, to patch one database server.
        public let estimatedPatchDuration: Int?
        /// The status of the patching operation. Possible values are SCHEDULED, MAINTENANCE_IN_PROGRESS, FAILED, and COMPLETE.
        public let patchingStatus: DbServerPatchingStatus?
        /// The time when the patching operation ended.
        public let timePatchingEnded: String?
        /// The time when the patching operation started.
        public let timePatchingStarted: String?

        @inlinable
        public init(estimatedPatchDuration: Int? = nil, patchingStatus: DbServerPatchingStatus? = nil, timePatchingEnded: String? = nil, timePatchingStarted: String? = nil) {
            self.estimatedPatchDuration = estimatedPatchDuration
            self.patchingStatus = patchingStatus
            self.timePatchingEnded = timePatchingEnded
            self.timePatchingStarted = timePatchingStarted
        }

        private enum CodingKeys: String, CodingKey {
            case estimatedPatchDuration = "estimatedPatchDuration"
            case patchingStatus = "patchingStatus"
            case timePatchingEnded = "timePatchingEnded"
            case timePatchingStarted = "timePatchingStarted"
        }
    }

    public struct DbServerSummary: AWSDecodableShape {
        /// A list of unique identifiers for the Autonomous VMs.
        public let autonomousVirtualMachineIds: [String]?
        /// A list of identifiers for the Autonomous VM clusters.
        public let autonomousVmClusterIds: [String]?
        /// The OCI model compute model used when you create or clone an instance: ECPU or OCPU. An ECPU is an abstracted measure of compute resources. ECPUs are based on the number of cores elastically allocated from a pool of compute and storage servers. An OCPU is a legacy physical measure of compute resources. OCPUs are based on the physical core of a processor with hyper-threading enabled.
        public let computeModel: ComputeModel?
        /// The number of CPU cores enabled on the database server.
        public let cpuCoreCount: Int?
        /// The date and time when the database server was created.
        public let createdAt: Date?
        /// The amount of local node storage, in gigabytes (GB), that's allocated on the database server.
        public let dbNodeStorageSizeInGBs: Int?
        /// The unique identifier of the database server.
        public let dbServerId: String?
        public let dbServerPatchingDetails: DbServerPatchingDetails?
        /// The user-friendly name of the database server. The name doesn't need to be unique.
        public let displayName: String?
        /// The ID of the Exadata infrastructure that hosts the database server.
        public let exadataInfrastructureId: String?
        /// The total number of CPU cores available on the database server.
        public let maxCpuCount: Int?
        /// The total amount of local node storage, in gigabytes (GB), that's available on the database server.
        public let maxDbNodeStorageInGBs: Int?
        /// The total amount of memory, in gigabytes (GB), that's available on the database server.
        public let maxMemoryInGBs: Int?
        /// The amount of memory, in gigabytes (GB), that's allocated on the database server.
        public let memorySizeInGBs: Int?
        /// The OCID of the database server.
        public let ocid: String?
        /// The name of the OCI resource anchor for the database server.
        public let ociResourceAnchorName: String?
        /// The hardware system model of the Exadata infrastructure that the database server is hosted on. The shape determines the amount of CPU, storage, and memory resources available.
        public let shape: String?
        /// The current status of the database server.
        public let status: ResourceStatus?
        /// Additional information about the status of the database server.
        public let statusReason: String?
        /// The IDs of the VM clusters that are associated with the database server.
        public let vmClusterIds: [String]?

        @inlinable
        public init(autonomousVirtualMachineIds: [String]? = nil, autonomousVmClusterIds: [String]? = nil, computeModel: ComputeModel? = nil, cpuCoreCount: Int? = nil, createdAt: Date? = nil, dbNodeStorageSizeInGBs: Int? = nil, dbServerId: String? = nil, dbServerPatchingDetails: DbServerPatchingDetails? = nil, displayName: String? = nil, exadataInfrastructureId: String? = nil, maxCpuCount: Int? = nil, maxDbNodeStorageInGBs: Int? = nil, maxMemoryInGBs: Int? = nil, memorySizeInGBs: Int? = nil, ocid: String? = nil, ociResourceAnchorName: String? = nil, shape: String? = nil, status: ResourceStatus? = nil, statusReason: String? = nil, vmClusterIds: [String]? = nil) {
            self.autonomousVirtualMachineIds = autonomousVirtualMachineIds
            self.autonomousVmClusterIds = autonomousVmClusterIds
            self.computeModel = computeModel
            self.cpuCoreCount = cpuCoreCount
            self.createdAt = createdAt
            self.dbNodeStorageSizeInGBs = dbNodeStorageSizeInGBs
            self.dbServerId = dbServerId
            self.dbServerPatchingDetails = dbServerPatchingDetails
            self.displayName = displayName
            self.exadataInfrastructureId = exadataInfrastructureId
            self.maxCpuCount = maxCpuCount
            self.maxDbNodeStorageInGBs = maxDbNodeStorageInGBs
            self.maxMemoryInGBs = maxMemoryInGBs
            self.memorySizeInGBs = memorySizeInGBs
            self.ocid = ocid
            self.ociResourceAnchorName = ociResourceAnchorName
            self.shape = shape
            self.status = status
            self.statusReason = statusReason
            self.vmClusterIds = vmClusterIds
        }

        private enum CodingKeys: String, CodingKey {
            case autonomousVirtualMachineIds = "autonomousVirtualMachineIds"
            case autonomousVmClusterIds = "autonomousVmClusterIds"
            case computeModel = "computeModel"
            case cpuCoreCount = "cpuCoreCount"
            case createdAt = "createdAt"
            case dbNodeStorageSizeInGBs = "dbNodeStorageSizeInGBs"
            case dbServerId = "dbServerId"
            case dbServerPatchingDetails = "dbServerPatchingDetails"
            case displayName = "displayName"
            case exadataInfrastructureId = "exadataInfrastructureId"
            case maxCpuCount = "maxCpuCount"
            case maxDbNodeStorageInGBs = "maxDbNodeStorageInGBs"
            case maxMemoryInGBs = "maxMemoryInGBs"
            case memorySizeInGBs = "memorySizeInGBs"
            case ocid = "ocid"
            case ociResourceAnchorName = "ociResourceAnchorName"
            case shape = "shape"
            case status = "status"
            case statusReason = "statusReason"
            case vmClusterIds = "vmClusterIds"
        }
    }

    public struct DbSystemShapeSummary: AWSDecodableShape {
        /// Indicates whether the hardware system model supports configurable database and server storage types.
        public let areServerTypesSupported: Bool?
        /// The maximum number of CPU cores that can be enabled for the shape.
        public let availableCoreCount: Int?
        /// The maximum number of CPU cores per DB node that can be enabled for the shape.
        public let availableCoreCountPerNode: Int?
        /// The maximum amount of data storage, in terabytes (TB), that can be enabled for the shape.
        public let availableDataStorageInTBs: Int?
        /// The maximum amount of data storage, in terabytes (TB), that's available per storage server for the shape.
        public let availableDataStoragePerServerInTBs: Int?
        /// The maximum amount of DB node storage, in gigabytes (GB), that's available per DB node for the shape.
        public let availableDbNodePerNodeInGBs: Int?
        /// The maximum amount of DB node storage, in gigabytes (GB), that can be enabled for the shape.
        public let availableDbNodeStorageInGBs: Int?
        /// The maximum amount of memory, in gigabytes (GB), that can be enabled for the shape.
        public let availableMemoryInGBs: Int?
        /// The maximum amount of memory, in gigabytes (GB), that's available per DB node for the shape.
        public let availableMemoryPerNodeInGBs: Int?
        /// The OCI model compute model used when you create or clone an instance: ECPU or OCPU. An ECPU is an abstracted measure of compute resources. ECPUs are based on the number of cores elastically allocated from a pool of compute and storage servers. An OCPU is a legacy physical measure of compute resources. OCPUs are based on the physical core of a processor with hyper-threading enabled.
        public let computeModel: ComputeModel?
        /// The discrete number by which the CPU core count for the shape can be increased or decreased.
        public let coreCountIncrement: Int?
        /// The maximum number of compute servers that is available for the shape.
        public let maximumNodeCount: Int?
        /// The maximum number of Exadata storage servers that's available for the shape.
        public let maxStorageCount: Int?
        /// The minimum number of CPU cores that can be enabled per node for the shape.
        public let minCoreCountPerNode: Int?
        /// The minimum amount of data storage, in terabytes (TB), that must be allocated for the shape.
        public let minDataStorageInTBs: Int?
        /// The minimum amount of DB node storage, in gigabytes (GB), that must be allocated per DB node for the shape.
        public let minDbNodeStoragePerNodeInGBs: Int?
        /// The minimum number of CPU cores that can be enabled for the shape.
        public let minimumCoreCount: Int?
        /// The minimum number of compute servers that are available for the shape.
        public let minimumNodeCount: Int?
        /// The minimum amount of memory, in gigabytes (GB), that must be allocated per DB node for the shape.
        public let minMemoryPerNodeInGBs: Int?
        /// The minimum number of Exadata storage servers that are available for the shape.
        public let minStorageCount: Int?
        /// The name of the shape.
        public let name: String?
        /// The runtime minimum number of CPU cores that can be enabled for the shape.
        public let runtimeMinimumCoreCount: Int?
        /// The family of the shape.
        public let shapeFamily: String?
        /// The shape type. This property is determined by the CPU hardware.
        public let shapeType: ShapeType?

        @inlinable
        public init(areServerTypesSupported: Bool? = nil, availableCoreCount: Int? = nil, availableCoreCountPerNode: Int? = nil, availableDataStorageInTBs: Int? = nil, availableDataStoragePerServerInTBs: Int? = nil, availableDbNodePerNodeInGBs: Int? = nil, availableDbNodeStorageInGBs: Int? = nil, availableMemoryInGBs: Int? = nil, availableMemoryPerNodeInGBs: Int? = nil, computeModel: ComputeModel? = nil, coreCountIncrement: Int? = nil, maximumNodeCount: Int? = nil, maxStorageCount: Int? = nil, minCoreCountPerNode: Int? = nil, minDataStorageInTBs: Int? = nil, minDbNodeStoragePerNodeInGBs: Int? = nil, minimumCoreCount: Int? = nil, minimumNodeCount: Int? = nil, minMemoryPerNodeInGBs: Int? = nil, minStorageCount: Int? = nil, name: String? = nil, runtimeMinimumCoreCount: Int? = nil, shapeFamily: String? = nil, shapeType: ShapeType? = nil) {
            self.areServerTypesSupported = areServerTypesSupported
            self.availableCoreCount = availableCoreCount
            self.availableCoreCountPerNode = availableCoreCountPerNode
            self.availableDataStorageInTBs = availableDataStorageInTBs
            self.availableDataStoragePerServerInTBs = availableDataStoragePerServerInTBs
            self.availableDbNodePerNodeInGBs = availableDbNodePerNodeInGBs
            self.availableDbNodeStorageInGBs = availableDbNodeStorageInGBs
            self.availableMemoryInGBs = availableMemoryInGBs
            self.availableMemoryPerNodeInGBs = availableMemoryPerNodeInGBs
            self.computeModel = computeModel
            self.coreCountIncrement = coreCountIncrement
            self.maximumNodeCount = maximumNodeCount
            self.maxStorageCount = maxStorageCount
            self.minCoreCountPerNode = minCoreCountPerNode
            self.minDataStorageInTBs = minDataStorageInTBs
            self.minDbNodeStoragePerNodeInGBs = minDbNodeStoragePerNodeInGBs
            self.minimumCoreCount = minimumCoreCount
            self.minimumNodeCount = minimumNodeCount
            self.minMemoryPerNodeInGBs = minMemoryPerNodeInGBs
            self.minStorageCount = minStorageCount
            self.name = name
            self.runtimeMinimumCoreCount = runtimeMinimumCoreCount
            self.shapeFamily = shapeFamily
            self.shapeType = shapeType
        }

        private enum CodingKeys: String, CodingKey {
            case areServerTypesSupported = "areServerTypesSupported"
            case availableCoreCount = "availableCoreCount"
            case availableCoreCountPerNode = "availableCoreCountPerNode"
            case availableDataStorageInTBs = "availableDataStorageInTBs"
            case availableDataStoragePerServerInTBs = "availableDataStoragePerServerInTBs"
            case availableDbNodePerNodeInGBs = "availableDbNodePerNodeInGBs"
            case availableDbNodeStorageInGBs = "availableDbNodeStorageInGBs"
            case availableMemoryInGBs = "availableMemoryInGBs"
            case availableMemoryPerNodeInGBs = "availableMemoryPerNodeInGBs"
            case computeModel = "computeModel"
            case coreCountIncrement = "coreCountIncrement"
            case maximumNodeCount = "maximumNodeCount"
            case maxStorageCount = "maxStorageCount"
            case minCoreCountPerNode = "minCoreCountPerNode"
            case minDataStorageInTBs = "minDataStorageInTBs"
            case minDbNodeStoragePerNodeInGBs = "minDbNodeStoragePerNodeInGBs"
            case minimumCoreCount = "minimumCoreCount"
            case minimumNodeCount = "minimumNodeCount"
            case minMemoryPerNodeInGBs = "minMemoryPerNodeInGBs"
            case minStorageCount = "minStorageCount"
            case name = "name"
            case runtimeMinimumCoreCount = "runtimeMinimumCoreCount"
            case shapeFamily = "shapeFamily"
            case shapeType = "shapeType"
        }
    }

    public struct DeleteCloudAutonomousVmClusterInput: AWSEncodableShape {
        /// The unique identifier of the Autonomous VM cluster to delete.
        public let cloudAutonomousVmClusterId: String

        @inlinable
        public init(cloudAutonomousVmClusterId: String) {
            self.cloudAutonomousVmClusterId = cloudAutonomousVmClusterId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.cloudAutonomousVmClusterId, key: "cloudAutonomousVmClusterId")
        }

        public func validate(name: String) throws {
            try self.validate(self.cloudAutonomousVmClusterId, name: "cloudAutonomousVmClusterId", parent: name, max: 64)
            try self.validate(self.cloudAutonomousVmClusterId, name: "cloudAutonomousVmClusterId", parent: name, min: 6)
            try self.validate(self.cloudAutonomousVmClusterId, name: "cloudAutonomousVmClusterId", parent: name, pattern: "^[a-zA-Z0-9_~.-]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteCloudAutonomousVmClusterOutput: AWSDecodableShape {
        public init() {}
    }

    public struct DeleteCloudExadataInfrastructureInput: AWSEncodableShape {
        /// The unique identifier of the Exadata infrastructure to delete.
        public let cloudExadataInfrastructureId: String

        @inlinable
        public init(cloudExadataInfrastructureId: String) {
            self.cloudExadataInfrastructureId = cloudExadataInfrastructureId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.cloudExadataInfrastructureId, key: "cloudExadataInfrastructureId")
        }

        public func validate(name: String) throws {
            try self.validate(self.cloudExadataInfrastructureId, name: "cloudExadataInfrastructureId", parent: name, max: 2048)
            try self.validate(self.cloudExadataInfrastructureId, name: "cloudExadataInfrastructureId", parent: name, min: 6)
            try self.validate(self.cloudExadataInfrastructureId, name: "cloudExadataInfrastructureId", parent: name, pattern: "^(arn:(?:aws|aws-cn|aws-us-gov|aws-iso-{0,1}[a-z]{0,1}):[a-z0-9-]+:[a-z0-9-]*:[0-9]+:[a-z0-9-]+/[a-zA-Z0-9_~.-]{6,64}|[a-zA-Z0-9_~.-]{6,64})$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteCloudExadataInfrastructureOutput: AWSDecodableShape {
        public init() {}
    }

    public struct DeleteCloudVmClusterInput: AWSEncodableShape {
        /// The unique identifier of the VM cluster to delete.
        public let cloudVmClusterId: String

        @inlinable
        public init(cloudVmClusterId: String) {
            self.cloudVmClusterId = cloudVmClusterId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.cloudVmClusterId, key: "cloudVmClusterId")
        }

        public func validate(name: String) throws {
            try self.validate(self.cloudVmClusterId, name: "cloudVmClusterId", parent: name, max: 64)
            try self.validate(self.cloudVmClusterId, name: "cloudVmClusterId", parent: name, min: 6)
            try self.validate(self.cloudVmClusterId, name: "cloudVmClusterId", parent: name, pattern: "^[a-zA-Z0-9_~.-]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteCloudVmClusterOutput: AWSDecodableShape {
        public init() {}
    }

    public struct DeleteOdbNetworkInput: AWSEncodableShape {
        /// Specifies whether to delete associated OCI networking resources along with the ODB network.
        public let deleteAssociatedResources: Bool
        /// The unique identifier of the ODB network to delete.
        public let odbNetworkId: String

        @inlinable
        public init(deleteAssociatedResources: Bool, odbNetworkId: String) {
            self.deleteAssociatedResources = deleteAssociatedResources
            self.odbNetworkId = odbNetworkId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encode(self.deleteAssociatedResources, forKey: .deleteAssociatedResources)
            request.encodePath(self.odbNetworkId, key: "odbNetworkId")
        }

        public func validate(name: String) throws {
            try self.validate(self.odbNetworkId, name: "odbNetworkId", parent: name, max: 2048)
            try self.validate(self.odbNetworkId, name: "odbNetworkId", parent: name, min: 6)
            try self.validate(self.odbNetworkId, name: "odbNetworkId", parent: name, pattern: "^(arn:(?:aws|aws-cn|aws-us-gov|aws-iso-{0,1}[a-z]{0,1}):[a-z0-9-]+:[a-z0-9-]*:[0-9]+:[a-z0-9-]+/[a-zA-Z0-9_~.-]{6,64}|[a-zA-Z0-9_~.-]{6,64})$")
        }

        private enum CodingKeys: String, CodingKey {
            case deleteAssociatedResources = "deleteAssociatedResources"
        }
    }

    public struct DeleteOdbNetworkOutput: AWSDecodableShape {
        public init() {}
    }

    public struct DeleteOdbPeeringConnectionInput: AWSEncodableShape {
        /// The unique identifier of the ODB peering connection to delete.
        public let odbPeeringConnectionId: String

        @inlinable
        public init(odbPeeringConnectionId: String) {
            self.odbPeeringConnectionId = odbPeeringConnectionId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.odbPeeringConnectionId, key: "odbPeeringConnectionId")
        }

        public func validate(name: String) throws {
            try self.validate(self.odbPeeringConnectionId, name: "odbPeeringConnectionId", parent: name, max: 2048)
            try self.validate(self.odbPeeringConnectionId, name: "odbPeeringConnectionId", parent: name, min: 6)
            try self.validate(self.odbPeeringConnectionId, name: "odbPeeringConnectionId", parent: name, pattern: "^(arn:(?:aws|aws-cn|aws-us-gov|aws-iso-{0,1}[a-z]{0,1}):[a-z0-9-]+:[a-z0-9-]*:[0-9]+:[a-z0-9-]+/[a-zA-Z0-9_~.-]{6,64}|[a-zA-Z0-9_~.-]{6,64})$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteOdbPeeringConnectionOutput: AWSDecodableShape {
        public init() {}
    }

    public struct ExadataIormConfig: AWSDecodableShape {
        /// An array of IORM settings for all the database in the Exadata DB system.
        public let dbPlans: [DbIormConfig]?
        /// Additional information about the current lifecycleState.
        public let lifecycleDetails: String?
        /// The current state of IORM configuration for the Exadata DB system.
        public let lifecycleState: IormLifecycleState?
        /// The current value for the IORM objective. The default is AUTO.
        public let objective: Objective?

        @inlinable
        public init(dbPlans: [DbIormConfig]? = nil, lifecycleDetails: String? = nil, lifecycleState: IormLifecycleState? = nil, objective: Objective? = nil) {
            self.dbPlans = dbPlans
            self.lifecycleDetails = lifecycleDetails
            self.lifecycleState = lifecycleState
            self.objective = objective
        }

        private enum CodingKeys: String, CodingKey {
            case dbPlans = "dbPlans"
            case lifecycleDetails = "lifecycleDetails"
            case lifecycleState = "lifecycleState"
            case objective = "objective"
        }
    }

    public struct GetCloudAutonomousVmClusterInput: AWSEncodableShape {
        /// The unique identifier of the Autonomous VM cluster to retrieve information about.
        public let cloudAutonomousVmClusterId: String

        @inlinable
        public init(cloudAutonomousVmClusterId: String) {
            self.cloudAutonomousVmClusterId = cloudAutonomousVmClusterId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.cloudAutonomousVmClusterId, key: "cloudAutonomousVmClusterId")
        }

        public func validate(name: String) throws {
            try self.validate(self.cloudAutonomousVmClusterId, name: "cloudAutonomousVmClusterId", parent: name, max: 64)
            try self.validate(self.cloudAutonomousVmClusterId, name: "cloudAutonomousVmClusterId", parent: name, min: 6)
            try self.validate(self.cloudAutonomousVmClusterId, name: "cloudAutonomousVmClusterId", parent: name, pattern: "^[a-zA-Z0-9_~.-]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetCloudAutonomousVmClusterOutput: AWSDecodableShape {
        /// The details of the requested Autonomous VM cluster.
        public let cloudAutonomousVmCluster: CloudAutonomousVmCluster?

        @inlinable
        public init(cloudAutonomousVmCluster: CloudAutonomousVmCluster? = nil) {
            self.cloudAutonomousVmCluster = cloudAutonomousVmCluster
        }

        private enum CodingKeys: String, CodingKey {
            case cloudAutonomousVmCluster = "cloudAutonomousVmCluster"
        }
    }

    public struct GetCloudExadataInfrastructureInput: AWSEncodableShape {
        /// The unique identifier of the Exadata infrastructure.
        public let cloudExadataInfrastructureId: String

        @inlinable
        public init(cloudExadataInfrastructureId: String) {
            self.cloudExadataInfrastructureId = cloudExadataInfrastructureId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.cloudExadataInfrastructureId, key: "cloudExadataInfrastructureId")
        }

        public func validate(name: String) throws {
            try self.validate(self.cloudExadataInfrastructureId, name: "cloudExadataInfrastructureId", parent: name, max: 2048)
            try self.validate(self.cloudExadataInfrastructureId, name: "cloudExadataInfrastructureId", parent: name, min: 6)
            try self.validate(self.cloudExadataInfrastructureId, name: "cloudExadataInfrastructureId", parent: name, pattern: "^(arn:(?:aws|aws-cn|aws-us-gov|aws-iso-{0,1}[a-z]{0,1}):[a-z0-9-]+:[a-z0-9-]*:[0-9]+:[a-z0-9-]+/[a-zA-Z0-9_~.-]{6,64}|[a-zA-Z0-9_~.-]{6,64})$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetCloudExadataInfrastructureOutput: AWSDecodableShape {
        /// The Exadata infrastructure.
        public let cloudExadataInfrastructure: CloudExadataInfrastructure?

        @inlinable
        public init(cloudExadataInfrastructure: CloudExadataInfrastructure? = nil) {
            self.cloudExadataInfrastructure = cloudExadataInfrastructure
        }

        private enum CodingKeys: String, CodingKey {
            case cloudExadataInfrastructure = "cloudExadataInfrastructure"
        }
    }

    public struct GetCloudExadataInfrastructureUnallocatedResourcesInput: AWSEncodableShape {
        /// The unique identifier of the Cloud Exadata infrastructure for which to retrieve unallocated resources.
        public let cloudExadataInfrastructureId: String
        /// The database servers to include in the unallocated resources query.
        public let dbServers: [String]?

        @inlinable
        public init(cloudExadataInfrastructureId: String, dbServers: [String]? = nil) {
            self.cloudExadataInfrastructureId = cloudExadataInfrastructureId
            self.dbServers = dbServers
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.cloudExadataInfrastructureId, key: "cloudExadataInfrastructureId")
            try container.encodeIfPresent(self.dbServers, forKey: .dbServers)
        }

        public func validate(name: String) throws {
            try self.validate(self.cloudExadataInfrastructureId, name: "cloudExadataInfrastructureId", parent: name, max: 2048)
            try self.validate(self.cloudExadataInfrastructureId, name: "cloudExadataInfrastructureId", parent: name, min: 6)
            try self.validate(self.cloudExadataInfrastructureId, name: "cloudExadataInfrastructureId", parent: name, pattern: "^(arn:(?:aws|aws-cn|aws-us-gov|aws-iso-{0,1}[a-z]{0,1}):[a-z0-9-]+:[a-z0-9-]*:[0-9]+:[a-z0-9-]+/[a-zA-Z0-9_~.-]{6,64}|[a-zA-Z0-9_~.-]{6,64})$")
            try self.validate(self.dbServers, name: "dbServers", parent: name, max: 1024)
            try self.validate(self.dbServers, name: "dbServers", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case dbServers = "dbServers"
        }
    }

    public struct GetCloudExadataInfrastructureUnallocatedResourcesOutput: AWSDecodableShape {
        /// Details about the unallocated resources in the specified Cloud Exadata infrastructure.
        public let cloudExadataInfrastructureUnallocatedResources: CloudExadataInfrastructureUnallocatedResources?

        @inlinable
        public init(cloudExadataInfrastructureUnallocatedResources: CloudExadataInfrastructureUnallocatedResources? = nil) {
            self.cloudExadataInfrastructureUnallocatedResources = cloudExadataInfrastructureUnallocatedResources
        }

        private enum CodingKeys: String, CodingKey {
            case cloudExadataInfrastructureUnallocatedResources = "cloudExadataInfrastructureUnallocatedResources"
        }
    }

    public struct GetCloudVmClusterInput: AWSEncodableShape {
        /// The unique identifier of the VM cluster.
        public let cloudVmClusterId: String

        @inlinable
        public init(cloudVmClusterId: String) {
            self.cloudVmClusterId = cloudVmClusterId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.cloudVmClusterId, key: "cloudVmClusterId")
        }

        public func validate(name: String) throws {
            try self.validate(self.cloudVmClusterId, name: "cloudVmClusterId", parent: name, max: 64)
            try self.validate(self.cloudVmClusterId, name: "cloudVmClusterId", parent: name, min: 6)
            try self.validate(self.cloudVmClusterId, name: "cloudVmClusterId", parent: name, pattern: "^[a-zA-Z0-9_~.-]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetCloudVmClusterOutput: AWSDecodableShape {
        /// The VM cluster.
        public let cloudVmCluster: CloudVmCluster?

        @inlinable
        public init(cloudVmCluster: CloudVmCluster? = nil) {
            self.cloudVmCluster = cloudVmCluster
        }

        private enum CodingKeys: String, CodingKey {
            case cloudVmCluster = "cloudVmCluster"
        }
    }

    public struct GetDbNodeInput: AWSEncodableShape {
        /// The unique identifier of the VM cluster that contains the DB node.
        public let cloudVmClusterId: String
        /// The unique identifier of the DB node to retrieve information about.
        public let dbNodeId: String

        @inlinable
        public init(cloudVmClusterId: String, dbNodeId: String) {
            self.cloudVmClusterId = cloudVmClusterId
            self.dbNodeId = dbNodeId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.cloudVmClusterId, key: "cloudVmClusterId")
            request.encodePath(self.dbNodeId, key: "dbNodeId")
        }

        public func validate(name: String) throws {
            try self.validate(self.cloudVmClusterId, name: "cloudVmClusterId", parent: name, max: 64)
            try self.validate(self.cloudVmClusterId, name: "cloudVmClusterId", parent: name, min: 6)
            try self.validate(self.cloudVmClusterId, name: "cloudVmClusterId", parent: name, pattern: "^[a-zA-Z0-9_~.-]+$")
            try self.validate(self.dbNodeId, name: "dbNodeId", parent: name, max: 64)
            try self.validate(self.dbNodeId, name: "dbNodeId", parent: name, min: 6)
            try self.validate(self.dbNodeId, name: "dbNodeId", parent: name, pattern: "^[a-zA-Z0-9_~.-]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetDbNodeOutput: AWSDecodableShape {
        public let dbNode: DbNode?

        @inlinable
        public init(dbNode: DbNode? = nil) {
            self.dbNode = dbNode
        }

        private enum CodingKeys: String, CodingKey {
            case dbNode = "dbNode"
        }
    }

    public struct GetDbServerInput: AWSEncodableShape {
        /// The unique identifier of the Oracle Exadata infrastructure that contains the database server.
        public let cloudExadataInfrastructureId: String
        /// The unique identifier of the database server to retrieve information about.
        public let dbServerId: String

        @inlinable
        public init(cloudExadataInfrastructureId: String, dbServerId: String) {
            self.cloudExadataInfrastructureId = cloudExadataInfrastructureId
            self.dbServerId = dbServerId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.cloudExadataInfrastructureId, key: "cloudExadataInfrastructureId")
            request.encodePath(self.dbServerId, key: "dbServerId")
        }

        public func validate(name: String) throws {
            try self.validate(self.cloudExadataInfrastructureId, name: "cloudExadataInfrastructureId", parent: name, max: 2048)
            try self.validate(self.cloudExadataInfrastructureId, name: "cloudExadataInfrastructureId", parent: name, min: 6)
            try self.validate(self.cloudExadataInfrastructureId, name: "cloudExadataInfrastructureId", parent: name, pattern: "^(arn:(?:aws|aws-cn|aws-us-gov|aws-iso-{0,1}[a-z]{0,1}):[a-z0-9-]+:[a-z0-9-]*:[0-9]+:[a-z0-9-]+/[a-zA-Z0-9_~.-]{6,64}|[a-zA-Z0-9_~.-]{6,64})$")
            try self.validate(self.dbServerId, name: "dbServerId", parent: name, max: 64)
            try self.validate(self.dbServerId, name: "dbServerId", parent: name, min: 6)
            try self.validate(self.dbServerId, name: "dbServerId", parent: name, pattern: "^[a-zA-Z0-9_~.-]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetDbServerOutput: AWSDecodableShape {
        /// The details of the requested database server.
        public let dbServer: DbServer?

        @inlinable
        public init(dbServer: DbServer? = nil) {
            self.dbServer = dbServer
        }

        private enum CodingKeys: String, CodingKey {
            case dbServer = "dbServer"
        }
    }

    public struct GetOciOnboardingStatusInput: AWSEncodableShape {
        public init() {}
    }

    public struct GetOciOnboardingStatusOutput: AWSDecodableShape {
        /// The existing OCI tenancy activation link for your Amazon Web Services account.
        public let existingTenancyActivationLink: String?
        /// A new OCI tenancy activation link for your Amazon Web Services account.
        public let newTenancyActivationLink: String?
        public let status: OciOnboardingStatus?

        @inlinable
        public init(existingTenancyActivationLink: String? = nil, newTenancyActivationLink: String? = nil, status: OciOnboardingStatus? = nil) {
            self.existingTenancyActivationLink = existingTenancyActivationLink
            self.newTenancyActivationLink = newTenancyActivationLink
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case existingTenancyActivationLink = "existingTenancyActivationLink"
            case newTenancyActivationLink = "newTenancyActivationLink"
            case status = "status"
        }
    }

    public struct GetOdbNetworkInput: AWSEncodableShape {
        /// The unique identifier of the ODB network.
        public let odbNetworkId: String

        @inlinable
        public init(odbNetworkId: String) {
            self.odbNetworkId = odbNetworkId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.odbNetworkId, key: "odbNetworkId")
        }

        public func validate(name: String) throws {
            try self.validate(self.odbNetworkId, name: "odbNetworkId", parent: name, max: 2048)
            try self.validate(self.odbNetworkId, name: "odbNetworkId", parent: name, min: 6)
            try self.validate(self.odbNetworkId, name: "odbNetworkId", parent: name, pattern: "^(arn:(?:aws|aws-cn|aws-us-gov|aws-iso-{0,1}[a-z]{0,1}):[a-z0-9-]+:[a-z0-9-]*:[0-9]+:[a-z0-9-]+/[a-zA-Z0-9_~.-]{6,64}|[a-zA-Z0-9_~.-]{6,64})$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetOdbNetworkOutput: AWSDecodableShape {
        /// The ODB network.
        public let odbNetwork: OdbNetwork?

        @inlinable
        public init(odbNetwork: OdbNetwork? = nil) {
            self.odbNetwork = odbNetwork
        }

        private enum CodingKeys: String, CodingKey {
            case odbNetwork = "odbNetwork"
        }
    }

    public struct GetOdbPeeringConnectionInput: AWSEncodableShape {
        /// The unique identifier of the ODB peering connection to retrieve information about.
        public let odbPeeringConnectionId: String

        @inlinable
        public init(odbPeeringConnectionId: String) {
            self.odbPeeringConnectionId = odbPeeringConnectionId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.odbPeeringConnectionId, key: "odbPeeringConnectionId")
        }

        public func validate(name: String) throws {
            try self.validate(self.odbPeeringConnectionId, name: "odbPeeringConnectionId", parent: name, max: 2048)
            try self.validate(self.odbPeeringConnectionId, name: "odbPeeringConnectionId", parent: name, min: 6)
            try self.validate(self.odbPeeringConnectionId, name: "odbPeeringConnectionId", parent: name, pattern: "^(arn:(?:aws|aws-cn|aws-us-gov|aws-iso-{0,1}[a-z]{0,1}):[a-z0-9-]+:[a-z0-9-]*:[0-9]+:[a-z0-9-]+/[a-zA-Z0-9_~.-]{6,64}|[a-zA-Z0-9_~.-]{6,64})$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetOdbPeeringConnectionOutput: AWSDecodableShape {
        public let odbPeeringConnection: OdbPeeringConnection?

        @inlinable
        public init(odbPeeringConnection: OdbPeeringConnection? = nil) {
            self.odbPeeringConnection = odbPeeringConnection
        }

        private enum CodingKeys: String, CodingKey {
            case odbPeeringConnection = "odbPeeringConnection"
        }
    }

    public struct GiVersionSummary: AWSDecodableShape {
        /// The GI software version.
        public let version: String?

        @inlinable
        public init(version: String? = nil) {
            self.version = version
        }

        private enum CodingKeys: String, CodingKey {
            case version = "version"
        }
    }

    public struct InitializeServiceInput: AWSEncodableShape {
        public init() {}
    }

    public struct InitializeServiceOutput: AWSDecodableShape {
        public init() {}
    }

    public struct InternalServerException: AWSErrorShape {
        public let message: String
        /// The number of seconds to wait before retrying the request after an internal server error.
        public let retryAfterSeconds: Int?

        @inlinable
        public init(message: String, retryAfterSeconds: Int? = nil) {
            self.message = message
            self.retryAfterSeconds = retryAfterSeconds
        }

        public init(from decoder: Decoder) throws {
            let response = decoder.userInfo[.awsResponse]! as! ResponseDecodingContainer
            let container = try decoder.container(keyedBy: CodingKeys.self)
            self.message = try container.decode(String.self, forKey: .message)
            self.retryAfterSeconds = try response.decodeHeaderIfPresent(Int.self, key: "Retry-After")
        }

        private enum CodingKeys: String, CodingKey {
            case message = "message"
        }
    }

    public struct ListAutonomousVirtualMachinesInput: AWSEncodableShape {
        /// The unique identifier of the Autonomous VM cluster whose virtual machines you're listing.
        public let cloudAutonomousVmClusterId: String
        /// The maximum number of items to return per page.
        public let maxResults: Int?
        /// The pagination token to continue listing from.
        public let nextToken: String?

        @inlinable
        public init(cloudAutonomousVmClusterId: String, maxResults: Int? = nil, nextToken: String? = nil) {
            self.cloudAutonomousVmClusterId = cloudAutonomousVmClusterId
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.cloudAutonomousVmClusterId, key: "cloudAutonomousVmClusterId")
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
        }

        public func validate(name: String) throws {
            try self.validate(self.cloudAutonomousVmClusterId, name: "cloudAutonomousVmClusterId", parent: name, max: 64)
            try self.validate(self.cloudAutonomousVmClusterId, name: "cloudAutonomousVmClusterId", parent: name, min: 6)
            try self.validate(self.cloudAutonomousVmClusterId, name: "cloudAutonomousVmClusterId", parent: name, pattern: "^[a-zA-Z0-9_~.-]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListAutonomousVirtualMachinesOutput: AWSDecodableShape {
        /// The list of Autonomous VMs in the specified Autonomous VM cluster.
        public let autonomousVirtualMachines: [AutonomousVirtualMachineSummary]
        /// The pagination token from which to continue listing.
        public let nextToken: String?

        @inlinable
        public init(autonomousVirtualMachines: [AutonomousVirtualMachineSummary], nextToken: String? = nil) {
            self.autonomousVirtualMachines = autonomousVirtualMachines
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case autonomousVirtualMachines = "autonomousVirtualMachines"
            case nextToken = "nextToken"
        }
    }

    public struct ListCloudAutonomousVmClustersInput: AWSEncodableShape {
        /// The unique identifier of the Cloud Exadata Infrastructure that hosts the Autonomous VM clusters to be listed.
        public let cloudExadataInfrastructureId: String?
        /// The maximum number of items to return per page.
        public let maxResults: Int?
        /// The pagination token to continue listing from.
        public let nextToken: String?

        @inlinable
        public init(cloudExadataInfrastructureId: String? = nil, maxResults: Int? = nil, nextToken: String? = nil) {
            self.cloudExadataInfrastructureId = cloudExadataInfrastructureId
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.cloudExadataInfrastructureId, forKey: .cloudExadataInfrastructureId)
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
        }

        public func validate(name: String) throws {
            try self.validate(self.cloudExadataInfrastructureId, name: "cloudExadataInfrastructureId", parent: name, max: 2048)
            try self.validate(self.cloudExadataInfrastructureId, name: "cloudExadataInfrastructureId", parent: name, min: 6)
            try self.validate(self.cloudExadataInfrastructureId, name: "cloudExadataInfrastructureId", parent: name, pattern: "^(arn:(?:aws|aws-cn|aws-us-gov|aws-iso-{0,1}[a-z]{0,1}):[a-z0-9-]+:[a-z0-9-]*:[0-9]+:[a-z0-9-]+/[a-zA-Z0-9_~.-]{6,64}|[a-zA-Z0-9_~.-]{6,64})$")
        }

        private enum CodingKeys: String, CodingKey {
            case cloudExadataInfrastructureId = "cloudExadataInfrastructureId"
        }
    }

    public struct ListCloudAutonomousVmClustersOutput: AWSDecodableShape {
        /// The list of Autonomous VM clusters in the specified Cloud Exadata Infrastructure.
        public let cloudAutonomousVmClusters: [CloudAutonomousVmClusterSummary]
        /// The pagination token to continue listing from.
        public let nextToken: String?

        @inlinable
        public init(cloudAutonomousVmClusters: [CloudAutonomousVmClusterSummary], nextToken: String? = nil) {
            self.cloudAutonomousVmClusters = cloudAutonomousVmClusters
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case cloudAutonomousVmClusters = "cloudAutonomousVmClusters"
            case nextToken = "nextToken"
        }
    }

    public struct ListCloudExadataInfrastructuresInput: AWSEncodableShape {
        /// The maximum number of items to return for this request. To get the next page of items, make another request with the token returned in the output. Default: 10
        public let maxResults: Int?
        /// The token returned from a previous paginated request. Pagination continues from the end of the items returned by the previous request.
        public let nextToken: String?

        @inlinable
        public init(maxResults: Int? = nil, nextToken: String? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListCloudExadataInfrastructuresOutput: AWSDecodableShape {
        /// The list of Exadata infrastructures along with their properties.
        public let cloudExadataInfrastructures: [CloudExadataInfrastructureSummary]
        /// The token to include in another request to get the next page of items. This value is null when there are no more items to return.
        public let nextToken: String?

        @inlinable
        public init(cloudExadataInfrastructures: [CloudExadataInfrastructureSummary], nextToken: String? = nil) {
            self.cloudExadataInfrastructures = cloudExadataInfrastructures
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case cloudExadataInfrastructures = "cloudExadataInfrastructures"
            case nextToken = "nextToken"
        }
    }

    public struct ListCloudVmClustersInput: AWSEncodableShape {
        /// The unique identifier of the Oracle Exadata infrastructure.
        public let cloudExadataInfrastructureId: String?
        /// The maximum number of items to return for this request. To get the next page of items, make another request with the token returned in the output. Default: 10
        public let maxResults: Int?
        /// The token returned from a previous paginated request. Pagination continues from the end of the items returned by the previous request.
        public let nextToken: String?

        @inlinable
        public init(cloudExadataInfrastructureId: String? = nil, maxResults: Int? = nil, nextToken: String? = nil) {
            self.cloudExadataInfrastructureId = cloudExadataInfrastructureId
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.cloudExadataInfrastructureId, forKey: .cloudExadataInfrastructureId)
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
        }

        public func validate(name: String) throws {
            try self.validate(self.cloudExadataInfrastructureId, name: "cloudExadataInfrastructureId", parent: name, max: 2048)
            try self.validate(self.cloudExadataInfrastructureId, name: "cloudExadataInfrastructureId", parent: name, min: 6)
            try self.validate(self.cloudExadataInfrastructureId, name: "cloudExadataInfrastructureId", parent: name, pattern: "^(arn:(?:aws|aws-cn|aws-us-gov|aws-iso-{0,1}[a-z]{0,1}):[a-z0-9-]+:[a-z0-9-]*:[0-9]+:[a-z0-9-]+/[a-zA-Z0-9_~.-]{6,64}|[a-zA-Z0-9_~.-]{6,64})$")
        }

        private enum CodingKeys: String, CodingKey {
            case cloudExadataInfrastructureId = "cloudExadataInfrastructureId"
        }
    }

    public struct ListCloudVmClustersOutput: AWSDecodableShape {
        /// The list of VM clusters along with their properties.
        public let cloudVmClusters: [CloudVmClusterSummary]
        /// The token to include in another request to get the next page of items. This value is null when there are no more items to return.
        public let nextToken: String?

        @inlinable
        public init(cloudVmClusters: [CloudVmClusterSummary], nextToken: String? = nil) {
            self.cloudVmClusters = cloudVmClusters
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case cloudVmClusters = "cloudVmClusters"
            case nextToken = "nextToken"
        }
    }

    public struct ListDbNodesInput: AWSEncodableShape {
        /// The unique identifier of the VM cluster.
        public let cloudVmClusterId: String
        /// The maximum number of items to return for this request. To get the next page of items, make another request with the token returned in the output. Default: 10
        public let maxResults: Int?
        /// The token returned from a previous paginated request. Pagination continues from the end of the items returned by the previous request.
        public let nextToken: String?

        @inlinable
        public init(cloudVmClusterId: String, maxResults: Int? = nil, nextToken: String? = nil) {
            self.cloudVmClusterId = cloudVmClusterId
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.cloudVmClusterId, key: "cloudVmClusterId")
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
        }

        public func validate(name: String) throws {
            try self.validate(self.cloudVmClusterId, name: "cloudVmClusterId", parent: name, max: 64)
            try self.validate(self.cloudVmClusterId, name: "cloudVmClusterId", parent: name, min: 6)
            try self.validate(self.cloudVmClusterId, name: "cloudVmClusterId", parent: name, pattern: "^[a-zA-Z0-9_~.-]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListDbNodesOutput: AWSDecodableShape {
        /// The list of DB nodes along with their properties.
        public let dbNodes: [DbNodeSummary]
        /// The token to include in another request to get the next page of items. This value is null when there are no more items to return.
        public let nextToken: String?

        @inlinable
        public init(dbNodes: [DbNodeSummary], nextToken: String? = nil) {
            self.dbNodes = dbNodes
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case dbNodes = "dbNodes"
            case nextToken = "nextToken"
        }
    }

    public struct ListDbServersInput: AWSEncodableShape {
        /// The unique identifier of the Oracle Exadata infrastructure.
        public let cloudExadataInfrastructureId: String
        /// The maximum number of items to return for this request. To get the next page of items, make another request with the token returned in the output. Default: 10
        public let maxResults: Int?
        /// The token returned from a previous paginated request. Pagination continues from the end of the items returned by the previous request.
        public let nextToken: String?

        @inlinable
        public init(cloudExadataInfrastructureId: String, maxResults: Int? = nil, nextToken: String? = nil) {
            self.cloudExadataInfrastructureId = cloudExadataInfrastructureId
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.cloudExadataInfrastructureId, key: "cloudExadataInfrastructureId")
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
        }

        public func validate(name: String) throws {
            try self.validate(self.cloudExadataInfrastructureId, name: "cloudExadataInfrastructureId", parent: name, max: 2048)
            try self.validate(self.cloudExadataInfrastructureId, name: "cloudExadataInfrastructureId", parent: name, min: 6)
            try self.validate(self.cloudExadataInfrastructureId, name: "cloudExadataInfrastructureId", parent: name, pattern: "^(arn:(?:aws|aws-cn|aws-us-gov|aws-iso-{0,1}[a-z]{0,1}):[a-z0-9-]+:[a-z0-9-]*:[0-9]+:[a-z0-9-]+/[a-zA-Z0-9_~.-]{6,64}|[a-zA-Z0-9_~.-]{6,64})$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListDbServersOutput: AWSDecodableShape {
        /// The list of database servers along with their properties.
        public let dbServers: [DbServerSummary]
        /// The token to include in another request to get the next page of items. This value is null when there are no more items to return.
        public let nextToken: String?

        @inlinable
        public init(dbServers: [DbServerSummary], nextToken: String? = nil) {
            self.dbServers = dbServers
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case dbServers = "dbServers"
            case nextToken = "nextToken"
        }
    }

    public struct ListDbSystemShapesInput: AWSEncodableShape {
        /// The logical name of the AZ, for example, us-east-1a. This name varies depending on the account.
        public let availabilityZone: String?
        /// The physical ID of the AZ, for example, use1-az4. This ID persists across accounts.
        public let availabilityZoneId: String?
        /// The maximum number of items to return for this request. To get the next page of items, make another request with the token returned in the output. Default: 10
        public let maxResults: Int?
        /// The token returned from a previous paginated request. Pagination continues from the end of the items returned by the previous request.
        public let nextToken: String?

        @inlinable
        public init(availabilityZone: String? = nil, availabilityZoneId: String? = nil, maxResults: Int? = nil, nextToken: String? = nil) {
            self.availabilityZone = availabilityZone
            self.availabilityZoneId = availabilityZoneId
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.availabilityZone, forKey: .availabilityZone)
            try container.encodeIfPresent(self.availabilityZoneId, forKey: .availabilityZoneId)
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
        }

        private enum CodingKeys: String, CodingKey {
            case availabilityZone = "availabilityZone"
            case availabilityZoneId = "availabilityZoneId"
        }
    }

    public struct ListDbSystemShapesOutput: AWSDecodableShape {
        /// The list of shapes and their properties.
        public let dbSystemShapes: [DbSystemShapeSummary]
        /// The token to include in another request to get the next page of items. This value is null when there are no more items to return.
        public let nextToken: String?

        @inlinable
        public init(dbSystemShapes: [DbSystemShapeSummary], nextToken: String? = nil) {
            self.dbSystemShapes = dbSystemShapes
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case dbSystemShapes = "dbSystemShapes"
            case nextToken = "nextToken"
        }
    }

    public struct ListGiVersionsInput: AWSEncodableShape {
        /// The maximum number of items to return for this request. To get the next page of items, make another request with the token returned in the output. Default: 10
        public let maxResults: Int?
        /// The token returned from a previous paginated request. Pagination continues from the end of the items returned by the previous request.
        public let nextToken: String?
        /// The shape to return GI versions for. For a list of valid shapes, use the ListDbSystemShapes operation..
        public let shape: String?

        @inlinable
        public init(maxResults: Int? = nil, nextToken: String? = nil, shape: String? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.shape = shape
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
            try container.encodeIfPresent(self.shape, forKey: .shape)
        }

        private enum CodingKeys: String, CodingKey {
            case shape = "shape"
        }
    }

    public struct ListGiVersionsOutput: AWSDecodableShape {
        /// The list of GI versions and their properties.
        public let giVersions: [GiVersionSummary]
        /// The token to include in another request to get the next page of items. This value is null when there are no more items to return.
        public let nextToken: String?

        @inlinable
        public init(giVersions: [GiVersionSummary], nextToken: String? = nil) {
            self.giVersions = giVersions
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case giVersions = "giVersions"
            case nextToken = "nextToken"
        }
    }

    public struct ListOdbNetworksInput: AWSEncodableShape {
        /// The maximum number of items to return for this request. To get the next page of items, make another request with the token returned in the output. Default: 10
        public let maxResults: Int?
        /// The token returned from a previous paginated request. Pagination continues from the end of the items returned by the previous request.
        public let nextToken: String?

        @inlinable
        public init(maxResults: Int? = nil, nextToken: String? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListOdbNetworksOutput: AWSDecodableShape {
        /// The token to include in another request to get the next page of items. This value is null when there are no more items to return.
        public let nextToken: String?
        /// The list of ODB networks.
        public let odbNetworks: [OdbNetworkSummary]

        @inlinable
        public init(nextToken: String? = nil, odbNetworks: [OdbNetworkSummary]) {
            self.nextToken = nextToken
            self.odbNetworks = odbNetworks
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "nextToken"
            case odbNetworks = "odbNetworks"
        }
    }

    public struct ListOdbPeeringConnectionsInput: AWSEncodableShape {
        /// The maximum number of ODB peering connections to return in the response. Default: 20  Constraints:   Must be between 1 and 100.
        public let maxResults: Int?
        /// The pagination token for the next page of ODB peering connections.
        public let nextToken: String?
        /// The identifier of the ODB network to list peering connections for. If not specified, lists all ODB peering connections in the account.
        public let odbNetworkId: String?

        @inlinable
        public init(maxResults: Int? = nil, nextToken: String? = nil, odbNetworkId: String? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.odbNetworkId = odbNetworkId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
            try container.encodeIfPresent(self.odbNetworkId, forKey: .odbNetworkId)
        }

        public func validate(name: String) throws {
            try self.validate(self.odbNetworkId, name: "odbNetworkId", parent: name, max: 2048)
            try self.validate(self.odbNetworkId, name: "odbNetworkId", parent: name, min: 6)
            try self.validate(self.odbNetworkId, name: "odbNetworkId", parent: name, pattern: "^(arn:(?:aws|aws-cn|aws-us-gov|aws-iso-{0,1}[a-z]{0,1}):[a-z0-9-]+:[a-z0-9-]*:[0-9]+:[a-z0-9-]+/[a-zA-Z0-9_~.-]{6,64}|[a-zA-Z0-9_~.-]{6,64})$")
        }

        private enum CodingKeys: String, CodingKey {
            case odbNetworkId = "odbNetworkId"
        }
    }

    public struct ListOdbPeeringConnectionsOutput: AWSDecodableShape {
        /// The pagination token for the next page of ODB peering connections.
        public let nextToken: String?
        /// The list of ODB peering connections.
        public let odbPeeringConnections: [OdbPeeringConnectionSummary]

        @inlinable
        public init(nextToken: String? = nil, odbPeeringConnections: [OdbPeeringConnectionSummary]) {
            self.nextToken = nextToken
            self.odbPeeringConnections = odbPeeringConnections
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "nextToken"
            case odbPeeringConnections = "odbPeeringConnections"
        }
    }

    public struct ListSystemVersionsInput: AWSEncodableShape {
        /// The software version of the Exadata Grid Infrastructure (GI).
        public let giVersion: String
        /// The maximum number of items to return for this request. To get the next page of items, make another request with the token returned in the output. Default: 10
        public let maxResults: Int?
        /// The token returned from a previous paginated request. Pagination continues from the end of the items returned by the previous request.
        public let nextToken: String?
        /// The Exadata hardware system model.
        public let shape: String

        @inlinable
        public init(giVersion: String, maxResults: Int? = nil, nextToken: String? = nil, shape: String) {
            self.giVersion = giVersion
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.shape = shape
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encode(self.giVersion, forKey: .giVersion)
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
            try container.encode(self.shape, forKey: .shape)
        }

        private enum CodingKeys: String, CodingKey {
            case giVersion = "giVersion"
            case shape = "shape"
        }
    }

    public struct ListSystemVersionsOutput: AWSDecodableShape {
        /// The token to include in another request to get the next page of items. This value is null when there are no more items to return.
        public let nextToken: String?
        /// The list of system versions.
        public let systemVersions: [SystemVersionSummary]

        @inlinable
        public init(nextToken: String? = nil, systemVersions: [SystemVersionSummary]) {
            self.nextToken = nextToken
            self.systemVersions = systemVersions
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "nextToken"
            case systemVersions = "systemVersions"
        }
    }

    public struct ListTagsForResourceRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the resource to list tags for.
        public let resourceArn: String

        @inlinable
        public init(resourceArn: String) {
            self.resourceArn = resourceArn
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, max: 2048)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, min: 20)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, pattern: "^arn:(?:aws|aws-cn|aws-us-gov|aws-iso-{0,1}[a-z]{0,1}):[a-z0-9-]+:[a-z0-9-]*:[0-9]+:[a-z0-9-]+/[a-z0-9-_]{6,64}$")
        }

        private enum CodingKeys: String, CodingKey {
            case resourceArn = "resourceArn"
        }
    }

    public struct ListTagsForResourceResponse: AWSDecodableShape {
        /// The list of tags applied to the resource.
        public let tags: [String: String]?

        @inlinable
        public init(tags: [String: String]? = nil) {
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case tags = "tags"
        }
    }

    public struct MaintenanceWindow: AWSEncodableShape & AWSDecodableShape {
        /// The custom action timeout in minutes for the maintenance window.
        public let customActionTimeoutInMins: Int?
        /// The days of the week when maintenance can be performed.
        public let daysOfWeek: [DayOfWeek]?
        /// The hours of the day when maintenance can be performed.
        public let hoursOfDay: [Int]?
        /// Indicates whether custom action timeout is enabled for the maintenance window.
        public let isCustomActionTimeoutEnabled: Bool?
        /// The lead time in weeks before the maintenance window.
        public let leadTimeInWeeks: Int?
        /// The months when maintenance can be performed.
        public let months: [Month]?
        /// The patching mode for the maintenance window.
        public let patchingMode: PatchingModeType?
        /// The preference for the maintenance window scheduling.
        public let preference: PreferenceType?
        /// Indicates whether to skip release updates during maintenance.
        public let skipRu: Bool?
        /// The weeks of the month when maintenance can be performed.
        public let weeksOfMonth: [Int]?

        @inlinable
        public init(customActionTimeoutInMins: Int? = nil, daysOfWeek: [DayOfWeek]? = nil, hoursOfDay: [Int]? = nil, isCustomActionTimeoutEnabled: Bool? = nil, leadTimeInWeeks: Int? = nil, months: [Month]? = nil, patchingMode: PatchingModeType? = nil, preference: PreferenceType? = nil, skipRu: Bool? = nil, weeksOfMonth: [Int]? = nil) {
            self.customActionTimeoutInMins = customActionTimeoutInMins
            self.daysOfWeek = daysOfWeek
            self.hoursOfDay = hoursOfDay
            self.isCustomActionTimeoutEnabled = isCustomActionTimeoutEnabled
            self.leadTimeInWeeks = leadTimeInWeeks
            self.months = months
            self.patchingMode = patchingMode
            self.preference = preference
            self.skipRu = skipRu
            self.weeksOfMonth = weeksOfMonth
        }

        private enum CodingKeys: String, CodingKey {
            case customActionTimeoutInMins = "customActionTimeoutInMins"
            case daysOfWeek = "daysOfWeek"
            case hoursOfDay = "hoursOfDay"
            case isCustomActionTimeoutEnabled = "isCustomActionTimeoutEnabled"
            case leadTimeInWeeks = "leadTimeInWeeks"
            case months = "months"
            case patchingMode = "patchingMode"
            case preference = "preference"
            case skipRu = "skipRu"
            case weeksOfMonth = "weeksOfMonth"
        }
    }

    public struct ManagedS3BackupAccess: AWSDecodableShape {
        /// The IPv4 addresses for the managed Amazon S3 backup access.
        public let ipv4Addresses: [String]?
        /// The status of the managed Amazon S3 backup access. Valid Values: enabled | disabled
        public let status: ManagedResourceStatus?

        @inlinable
        public init(ipv4Addresses: [String]? = nil, status: ManagedResourceStatus? = nil) {
            self.ipv4Addresses = ipv4Addresses
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case ipv4Addresses = "ipv4Addresses"
            case status = "status"
        }
    }

    public struct ManagedServices: AWSDecodableShape {
        /// The managed Amazon S3 backup access configuration.
        public let managedS3BackupAccess: ManagedS3BackupAccess?
        /// The IPv4 CIDR blocks for the managed services.
        public let managedServicesIpv4Cidrs: [String]?
        /// The Amazon Resource Name (ARN) of the resource gateway.
        public let resourceGatewayArn: String?
        /// The Amazon S3 access configuration.
        public let s3Access: S3Access?
        /// The Amazon Resource Name (ARN) of the service network.
        public let serviceNetworkArn: String?
        /// The service network endpoint configuration.
        public let serviceNetworkEndpoint: ServiceNetworkEndpoint?
        /// The Zero-ETL access configuration.
        public let zeroEtlAccess: ZeroEtlAccess?

        @inlinable
        public init(managedS3BackupAccess: ManagedS3BackupAccess? = nil, managedServicesIpv4Cidrs: [String]? = nil, resourceGatewayArn: String? = nil, s3Access: S3Access? = nil, serviceNetworkArn: String? = nil, serviceNetworkEndpoint: ServiceNetworkEndpoint? = nil, zeroEtlAccess: ZeroEtlAccess? = nil) {
            self.managedS3BackupAccess = managedS3BackupAccess
            self.managedServicesIpv4Cidrs = managedServicesIpv4Cidrs
            self.resourceGatewayArn = resourceGatewayArn
            self.s3Access = s3Access
            self.serviceNetworkArn = serviceNetworkArn
            self.serviceNetworkEndpoint = serviceNetworkEndpoint
            self.zeroEtlAccess = zeroEtlAccess
        }

        private enum CodingKeys: String, CodingKey {
            case managedS3BackupAccess = "managedS3BackupAccess"
            case managedServicesIpv4Cidrs = "managedServicesIpv4Cidrs"
            case resourceGatewayArn = "resourceGatewayArn"
            case s3Access = "s3Access"
            case serviceNetworkArn = "serviceNetworkArn"
            case serviceNetworkEndpoint = "serviceNetworkEndpoint"
            case zeroEtlAccess = "zeroEtlAccess"
        }
    }

    public struct Month: AWSEncodableShape & AWSDecodableShape {
        /// The name of the month.
        public let name: MonthName?

        @inlinable
        public init(name: MonthName? = nil) {
            self.name = name
        }

        private enum CodingKeys: String, CodingKey {
            case name = "name"
        }
    }

    public struct OciDnsForwardingConfig: AWSDecodableShape {
        /// Domain name to which DNS resolver forwards to.
        public let domainName: String?
        /// OCI DNS listener IP for custom DNS setup.
        public let ociDnsListenerIp: String?

        @inlinable
        public init(domainName: String? = nil, ociDnsListenerIp: String? = nil) {
            self.domainName = domainName
            self.ociDnsListenerIp = ociDnsListenerIp
        }

        private enum CodingKeys: String, CodingKey {
            case domainName = "domainName"
            case ociDnsListenerIp = "ociDnsListenerIp"
        }
    }

    public struct OdbNetwork: AWSDecodableShape {
        /// The Amazon Web Services Availability Zone (AZ) where the ODB network is located.
        public let availabilityZone: String?
        /// The AZ ID of the AZ where the ODB network is located.
        public let availabilityZoneId: String?
        /// The CIDR range of the backup subnet in the ODB network.
        public let backupSubnetCidr: String?
        /// The CIDR range of the client subnet in the ODB network.
        public let clientSubnetCidr: String?
        /// The date and time when the ODB network was created.
        public let createdAt: Date?
        /// The domain name for the resources in the ODB network.
        public let customDomainName: String?
        /// The DNS prefix to the default DNS domain name. The default DNS domain name is oraclevcn.com.
        public let defaultDnsPrefix: String?
        /// The user-friendly name of the ODB network.
        public let displayName: String?
        /// The managed services configuration for the ODB network.
        public let managedServices: ManagedServices?
        /// The DNS resolver endpoint in OCI for forwarding DNS queries for the ociPrivateZone domain.
        public let ociDnsForwardingConfigs: [OciDnsForwardingConfig]?
        /// The unique identifier of the OCI network anchor for the ODB network.
        public let ociNetworkAnchorId: String?
        /// The URL of the OCI network anchor for the ODB network.
        public let ociNetworkAnchorUrl: String?
        /// The name of the OCI resource anchor that's associated with the ODB network.
        public let ociResourceAnchorName: String?
        /// The Oracle Cloud ID (OCID) for the Virtual Cloud Network (VCN) that's associated with the ODB network.
        public let ociVcnId: String?
        /// The URL for the VCN that's associated with the ODB network.
        public let ociVcnUrl: String?
        /// The Amazon Resource Name (ARN) of the ODB network.
        public let odbNetworkArn: String?
        /// The unique identifier of the ODB network.
        public let odbNetworkId: String
        /// The list of CIDR ranges from the peered VPC that are allowed access to the ODB network.
        public let peeredCidrs: [String]?
        /// The amount of progress made on the current operation on the ODB network, expressed as a percentage.
        public let percentProgress: Float?
        /// The current status of the ODB network.
        public let status: ResourceStatus?
        /// Additional information about the current status of the ODB network.
        public let statusReason: String?

        @inlinable
        public init(availabilityZone: String? = nil, availabilityZoneId: String? = nil, backupSubnetCidr: String? = nil, clientSubnetCidr: String? = nil, createdAt: Date? = nil, customDomainName: String? = nil, defaultDnsPrefix: String? = nil, displayName: String? = nil, managedServices: ManagedServices? = nil, ociDnsForwardingConfigs: [OciDnsForwardingConfig]? = nil, ociNetworkAnchorId: String? = nil, ociNetworkAnchorUrl: String? = nil, ociResourceAnchorName: String? = nil, ociVcnId: String? = nil, ociVcnUrl: String? = nil, odbNetworkArn: String? = nil, odbNetworkId: String, peeredCidrs: [String]? = nil, percentProgress: Float? = nil, status: ResourceStatus? = nil, statusReason: String? = nil) {
            self.availabilityZone = availabilityZone
            self.availabilityZoneId = availabilityZoneId
            self.backupSubnetCidr = backupSubnetCidr
            self.clientSubnetCidr = clientSubnetCidr
            self.createdAt = createdAt
            self.customDomainName = customDomainName
            self.defaultDnsPrefix = defaultDnsPrefix
            self.displayName = displayName
            self.managedServices = managedServices
            self.ociDnsForwardingConfigs = ociDnsForwardingConfigs
            self.ociNetworkAnchorId = ociNetworkAnchorId
            self.ociNetworkAnchorUrl = ociNetworkAnchorUrl
            self.ociResourceAnchorName = ociResourceAnchorName
            self.ociVcnId = ociVcnId
            self.ociVcnUrl = ociVcnUrl
            self.odbNetworkArn = odbNetworkArn
            self.odbNetworkId = odbNetworkId
            self.peeredCidrs = peeredCidrs
            self.percentProgress = percentProgress
            self.status = status
            self.statusReason = statusReason
        }

        private enum CodingKeys: String, CodingKey {
            case availabilityZone = "availabilityZone"
            case availabilityZoneId = "availabilityZoneId"
            case backupSubnetCidr = "backupSubnetCidr"
            case clientSubnetCidr = "clientSubnetCidr"
            case createdAt = "createdAt"
            case customDomainName = "customDomainName"
            case defaultDnsPrefix = "defaultDnsPrefix"
            case displayName = "displayName"
            case managedServices = "managedServices"
            case ociDnsForwardingConfigs = "ociDnsForwardingConfigs"
            case ociNetworkAnchorId = "ociNetworkAnchorId"
            case ociNetworkAnchorUrl = "ociNetworkAnchorUrl"
            case ociResourceAnchorName = "ociResourceAnchorName"
            case ociVcnId = "ociVcnId"
            case ociVcnUrl = "ociVcnUrl"
            case odbNetworkArn = "odbNetworkArn"
            case odbNetworkId = "odbNetworkId"
            case peeredCidrs = "peeredCidrs"
            case percentProgress = "percentProgress"
            case status = "status"
            case statusReason = "statusReason"
        }
    }

    public struct OdbNetworkSummary: AWSDecodableShape {
        /// The Amazon Web Services Availability Zone (AZ) where the ODB network is located.
        public let availabilityZone: String?
        /// The AZ ID of the AZ where the ODB network is located.
        public let availabilityZoneId: String?
        /// The CIDR range of the backup subnet in the ODB network.
        public let backupSubnetCidr: String?
        /// The CIDR range of the client subnet in the ODB network.
        public let clientSubnetCidr: String?
        /// The date and time when the ODB network was created.
        public let createdAt: Date?
        /// The domain name for the resources in the ODB network.
        public let customDomainName: String?
        /// The DNS prefix to the default DNS domain name. The default DNS domain name is oraclevcn.com.
        public let defaultDnsPrefix: String?
        /// The user-friendly name of the ODB network.
        public let displayName: String?
        /// The managed services configuration for the ODB network.
        public let managedServices: ManagedServices?
        /// The DNS resolver endpoint in OCI for forwarding DNS queries for the ociPrivateZone domain.
        public let ociDnsForwardingConfigs: [OciDnsForwardingConfig]?
        /// The unique identifier of the OCI network anchor for the ODB network.
        public let ociNetworkAnchorId: String?
        /// The URL of the OCI network anchor for the ODB network.
        public let ociNetworkAnchorUrl: String?
        /// The name of the OCI resource anchor associated with the ODB network.
        public let ociResourceAnchorName: String?
        /// The Oracle Cloud ID (OCID) for the Virtual Cloud Network (VCN) associated with the ODB network.
        public let ociVcnId: String?
        /// The URL for the VCN that's associated with the ODB network.
        public let ociVcnUrl: String?
        /// The Amazon Resource Name (ARN) of the ODB network.
        public let odbNetworkArn: String?
        /// The unique identifier of the ODB network.
        public let odbNetworkId: String
        /// The list of CIDR ranges from the peered VPC that are allowed access to the ODB network.
        public let peeredCidrs: [String]?
        /// The amount of progress made on the current operation on the ODB network, expressed as a percentage.
        public let percentProgress: Float?
        /// The current status of the ODB network.
        public let status: ResourceStatus?
        /// Additional information about the current status of the ODB network.
        public let statusReason: String?

        @inlinable
        public init(availabilityZone: String? = nil, availabilityZoneId: String? = nil, backupSubnetCidr: String? = nil, clientSubnetCidr: String? = nil, createdAt: Date? = nil, customDomainName: String? = nil, defaultDnsPrefix: String? = nil, displayName: String? = nil, managedServices: ManagedServices? = nil, ociDnsForwardingConfigs: [OciDnsForwardingConfig]? = nil, ociNetworkAnchorId: String? = nil, ociNetworkAnchorUrl: String? = nil, ociResourceAnchorName: String? = nil, ociVcnId: String? = nil, ociVcnUrl: String? = nil, odbNetworkArn: String? = nil, odbNetworkId: String, peeredCidrs: [String]? = nil, percentProgress: Float? = nil, status: ResourceStatus? = nil, statusReason: String? = nil) {
            self.availabilityZone = availabilityZone
            self.availabilityZoneId = availabilityZoneId
            self.backupSubnetCidr = backupSubnetCidr
            self.clientSubnetCidr = clientSubnetCidr
            self.createdAt = createdAt
            self.customDomainName = customDomainName
            self.defaultDnsPrefix = defaultDnsPrefix
            self.displayName = displayName
            self.managedServices = managedServices
            self.ociDnsForwardingConfigs = ociDnsForwardingConfigs
            self.ociNetworkAnchorId = ociNetworkAnchorId
            self.ociNetworkAnchorUrl = ociNetworkAnchorUrl
            self.ociResourceAnchorName = ociResourceAnchorName
            self.ociVcnId = ociVcnId
            self.ociVcnUrl = ociVcnUrl
            self.odbNetworkArn = odbNetworkArn
            self.odbNetworkId = odbNetworkId
            self.peeredCidrs = peeredCidrs
            self.percentProgress = percentProgress
            self.status = status
            self.statusReason = statusReason
        }

        private enum CodingKeys: String, CodingKey {
            case availabilityZone = "availabilityZone"
            case availabilityZoneId = "availabilityZoneId"
            case backupSubnetCidr = "backupSubnetCidr"
            case clientSubnetCidr = "clientSubnetCidr"
            case createdAt = "createdAt"
            case customDomainName = "customDomainName"
            case defaultDnsPrefix = "defaultDnsPrefix"
            case displayName = "displayName"
            case managedServices = "managedServices"
            case ociDnsForwardingConfigs = "ociDnsForwardingConfigs"
            case ociNetworkAnchorId = "ociNetworkAnchorId"
            case ociNetworkAnchorUrl = "ociNetworkAnchorUrl"
            case ociResourceAnchorName = "ociResourceAnchorName"
            case ociVcnId = "ociVcnId"
            case ociVcnUrl = "ociVcnUrl"
            case odbNetworkArn = "odbNetworkArn"
            case odbNetworkId = "odbNetworkId"
            case peeredCidrs = "peeredCidrs"
            case percentProgress = "percentProgress"
            case status = "status"
            case statusReason = "statusReason"
        }
    }

    public struct OdbPeeringConnection: AWSDecodableShape {
        /// The timestamp when the ODB peering connection was created.
        public let createdAt: Date?
        /// The display name of the ODB peering connection.
        public let displayName: String?
        /// The Amazon Resource Name (ARN) of the ODB network that initiated the peering connection.
        public let odbNetworkArn: String?
        /// The Amazon Resource Name (ARN) of the ODB peering connection. Example: arn:aws:odb:us-east-1:123456789012:odb-peering-connection/odbpcx-abcdefgh12345678
        public let odbPeeringConnectionArn: String?
        /// The unique identifier of the ODB peering connection. A sample ID is odbpcx-abcdefgh12345678.
        public let odbPeeringConnectionId: String
        /// The type of the ODB peering connection. Valid Values: ODB-VPC | ODB-ODB
        public let odbPeeringConnectionType: String?
        /// The Amazon Resource Name (ARN) of the peer network.
        public let peerNetworkArn: String?
        /// The percentage progress of the ODB peering connection creation or deletion.
        public let percentProgress: Float?
        /// The status of the ODB peering connection. Valid Values: provisioning | active | terminating | terminated | failed
        public let status: ResourceStatus?
        /// The reason for the current status of the ODB peering connection.
        public let statusReason: String?

        @inlinable
        public init(createdAt: Date? = nil, displayName: String? = nil, odbNetworkArn: String? = nil, odbPeeringConnectionArn: String? = nil, odbPeeringConnectionId: String, odbPeeringConnectionType: String? = nil, peerNetworkArn: String? = nil, percentProgress: Float? = nil, status: ResourceStatus? = nil, statusReason: String? = nil) {
            self.createdAt = createdAt
            self.displayName = displayName
            self.odbNetworkArn = odbNetworkArn
            self.odbPeeringConnectionArn = odbPeeringConnectionArn
            self.odbPeeringConnectionId = odbPeeringConnectionId
            self.odbPeeringConnectionType = odbPeeringConnectionType
            self.peerNetworkArn = peerNetworkArn
            self.percentProgress = percentProgress
            self.status = status
            self.statusReason = statusReason
        }

        private enum CodingKeys: String, CodingKey {
            case createdAt = "createdAt"
            case displayName = "displayName"
            case odbNetworkArn = "odbNetworkArn"
            case odbPeeringConnectionArn = "odbPeeringConnectionArn"
            case odbPeeringConnectionId = "odbPeeringConnectionId"
            case odbPeeringConnectionType = "odbPeeringConnectionType"
            case peerNetworkArn = "peerNetworkArn"
            case percentProgress = "percentProgress"
            case status = "status"
            case statusReason = "statusReason"
        }
    }

    public struct OdbPeeringConnectionSummary: AWSDecodableShape {
        /// The timestamp when the ODB peering connection was created.
        public let createdAt: Date?
        /// The display name of the ODB peering connection.
        public let displayName: String?
        /// The Amazon Resource Name (ARN) of the ODB network that initiated the peering connection.
        public let odbNetworkArn: String?
        /// The Amazon Resource Name (ARN) of the ODB peering connection.
        public let odbPeeringConnectionArn: String?
        /// The unique identifier of the ODB peering connection. A sample ID is odbpcx-abcdefgh12345678.
        public let odbPeeringConnectionId: String
        /// The type of the ODB peering connection. Valid Values: ODB-VPC | ODB-ODB
        public let odbPeeringConnectionType: String?
        /// The Amazon Resource Name (ARN) of the peer network.
        public let peerNetworkArn: String?
        /// The percentage progress of the ODB peering connection creation or deletion.
        public let percentProgress: Float?
        /// The status of the ODB peering connection. Valid Values: provisioning | active | terminating | terminated | failed
        public let status: ResourceStatus?
        /// The reason for the current status of the ODB peering connection.
        public let statusReason: String?

        @inlinable
        public init(createdAt: Date? = nil, displayName: String? = nil, odbNetworkArn: String? = nil, odbPeeringConnectionArn: String? = nil, odbPeeringConnectionId: String, odbPeeringConnectionType: String? = nil, peerNetworkArn: String? = nil, percentProgress: Float? = nil, status: ResourceStatus? = nil, statusReason: String? = nil) {
            self.createdAt = createdAt
            self.displayName = displayName
            self.odbNetworkArn = odbNetworkArn
            self.odbPeeringConnectionArn = odbPeeringConnectionArn
            self.odbPeeringConnectionId = odbPeeringConnectionId
            self.odbPeeringConnectionType = odbPeeringConnectionType
            self.peerNetworkArn = peerNetworkArn
            self.percentProgress = percentProgress
            self.status = status
            self.statusReason = statusReason
        }

        private enum CodingKeys: String, CodingKey {
            case createdAt = "createdAt"
            case displayName = "displayName"
            case odbNetworkArn = "odbNetworkArn"
            case odbPeeringConnectionArn = "odbPeeringConnectionArn"
            case odbPeeringConnectionId = "odbPeeringConnectionId"
            case odbPeeringConnectionType = "odbPeeringConnectionType"
            case peerNetworkArn = "peerNetworkArn"
            case percentProgress = "percentProgress"
            case status = "status"
            case statusReason = "statusReason"
        }
    }

    public struct RebootDbNodeInput: AWSEncodableShape {
        /// The unique identifier of the VM cluster that contains the DB node to reboot.
        public let cloudVmClusterId: String
        /// The unique identifier of the DB node to reboot.
        public let dbNodeId: String

        @inlinable
        public init(cloudVmClusterId: String, dbNodeId: String) {
            self.cloudVmClusterId = cloudVmClusterId
            self.dbNodeId = dbNodeId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.cloudVmClusterId, key: "cloudVmClusterId")
            request.encodePath(self.dbNodeId, key: "dbNodeId")
        }

        public func validate(name: String) throws {
            try self.validate(self.cloudVmClusterId, name: "cloudVmClusterId", parent: name, max: 64)
            try self.validate(self.cloudVmClusterId, name: "cloudVmClusterId", parent: name, min: 6)
            try self.validate(self.cloudVmClusterId, name: "cloudVmClusterId", parent: name, pattern: "^[a-zA-Z0-9_~.-]+$")
            try self.validate(self.dbNodeId, name: "dbNodeId", parent: name, max: 64)
            try self.validate(self.dbNodeId, name: "dbNodeId", parent: name, min: 6)
            try self.validate(self.dbNodeId, name: "dbNodeId", parent: name, pattern: "^[a-zA-Z0-9_~.-]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct RebootDbNodeOutput: AWSDecodableShape {
        /// The unique identifier of the DB node that was rebooted.
        public let dbNodeId: String
        /// The current status of the DB node after the reboot operation.
        public let status: DbNodeResourceStatus?
        /// Additional information about the status of the DB node after the reboot operation.
        public let statusReason: String?

        @inlinable
        public init(dbNodeId: String, status: DbNodeResourceStatus? = nil, statusReason: String? = nil) {
            self.dbNodeId = dbNodeId
            self.status = status
            self.statusReason = statusReason
        }

        private enum CodingKeys: String, CodingKey {
            case dbNodeId = "dbNodeId"
            case status = "status"
            case statusReason = "statusReason"
        }
    }

    public struct ResourceNotFoundException: AWSErrorShape {
        public let message: String
        /// The identifier of the resource that was not found.
        public let resourceId: String
        /// The type of resource that was not found.
        public let resourceType: String

        @inlinable
        public init(message: String, resourceId: String, resourceType: String) {
            self.message = message
            self.resourceId = resourceId
            self.resourceType = resourceType
        }

        private enum CodingKeys: String, CodingKey {
            case message = "message"
            case resourceId = "resourceId"
            case resourceType = "resourceType"
        }
    }

    public struct S3Access: AWSDecodableShape {
        /// The domain name for the Amazon S3 access.
        public let domainName: String?
        /// The IPv4 addresses for the Amazon S3 access.
        public let ipv4Addresses: [String]?
        /// The endpoint policy for the Amazon S3 access.
        public let s3PolicyDocument: String?
        /// The status of the Amazon S3 access. Valid Values: enabled | disabled
        public let status: ManagedResourceStatus?

        @inlinable
        public init(domainName: String? = nil, ipv4Addresses: [String]? = nil, s3PolicyDocument: String? = nil, status: ManagedResourceStatus? = nil) {
            self.domainName = domainName
            self.ipv4Addresses = ipv4Addresses
            self.s3PolicyDocument = s3PolicyDocument
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case domainName = "domainName"
            case ipv4Addresses = "ipv4Addresses"
            case s3PolicyDocument = "s3PolicyDocument"
            case status = "status"
        }
    }

    public struct ServiceNetworkEndpoint: AWSDecodableShape {
        /// The identifier of the VPC endpoint.
        public let vpcEndpointId: String?
        /// The type of the VPC endpoint. Valid Values: Interface | Gateway
        public let vpcEndpointType: VpcEndpointType?

        @inlinable
        public init(vpcEndpointId: String? = nil, vpcEndpointType: VpcEndpointType? = nil) {
            self.vpcEndpointId = vpcEndpointId
            self.vpcEndpointType = vpcEndpointType
        }

        private enum CodingKeys: String, CodingKey {
            case vpcEndpointId = "vpcEndpointId"
            case vpcEndpointType = "vpcEndpointType"
        }
    }

    public struct ServiceQuotaExceededException: AWSErrorShape {
        public let message: String
        /// The unqiue identifier of the service quota that was exceeded.
        public let quotaCode: String
        /// The identifier of the resource that exceeded the service quota.
        public let resourceId: String
        /// The type of resource that exceeded the service quota.
        public let resourceType: String

        @inlinable
        public init(message: String, quotaCode: String, resourceId: String, resourceType: String) {
            self.message = message
            self.quotaCode = quotaCode
            self.resourceId = resourceId
            self.resourceType = resourceType
        }

        private enum CodingKeys: String, CodingKey {
            case message = "message"
            case quotaCode = "quotaCode"
            case resourceId = "resourceId"
            case resourceType = "resourceType"
        }
    }

    public struct StartDbNodeInput: AWSEncodableShape {
        /// The unique identifier of the VM cluster that contains the DB node to start.
        public let cloudVmClusterId: String
        /// The unique identifier of the DB node to start.
        public let dbNodeId: String

        @inlinable
        public init(cloudVmClusterId: String, dbNodeId: String) {
            self.cloudVmClusterId = cloudVmClusterId
            self.dbNodeId = dbNodeId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.cloudVmClusterId, key: "cloudVmClusterId")
            request.encodePath(self.dbNodeId, key: "dbNodeId")
        }

        public func validate(name: String) throws {
            try self.validate(self.cloudVmClusterId, name: "cloudVmClusterId", parent: name, max: 64)
            try self.validate(self.cloudVmClusterId, name: "cloudVmClusterId", parent: name, min: 6)
            try self.validate(self.cloudVmClusterId, name: "cloudVmClusterId", parent: name, pattern: "^[a-zA-Z0-9_~.-]+$")
            try self.validate(self.dbNodeId, name: "dbNodeId", parent: name, max: 64)
            try self.validate(self.dbNodeId, name: "dbNodeId", parent: name, min: 6)
            try self.validate(self.dbNodeId, name: "dbNodeId", parent: name, pattern: "^[a-zA-Z0-9_~.-]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct StartDbNodeOutput: AWSDecodableShape {
        /// The unique identifier of the DB node that was started.
        public let dbNodeId: String
        /// The current status of the DB node after the start operation.
        public let status: DbNodeResourceStatus?
        /// Additional information about the status of the DB node after the start operation.
        public let statusReason: String?

        @inlinable
        public init(dbNodeId: String, status: DbNodeResourceStatus? = nil, statusReason: String? = nil) {
            self.dbNodeId = dbNodeId
            self.status = status
            self.statusReason = statusReason
        }

        private enum CodingKeys: String, CodingKey {
            case dbNodeId = "dbNodeId"
            case status = "status"
            case statusReason = "statusReason"
        }
    }

    public struct StopDbNodeInput: AWSEncodableShape {
        /// The unique identifier of the VM cluster that contains the DB node to stop.
        public let cloudVmClusterId: String
        /// The unique identifier of the DB node to stop.
        public let dbNodeId: String

        @inlinable
        public init(cloudVmClusterId: String, dbNodeId: String) {
            self.cloudVmClusterId = cloudVmClusterId
            self.dbNodeId = dbNodeId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.cloudVmClusterId, key: "cloudVmClusterId")
            request.encodePath(self.dbNodeId, key: "dbNodeId")
        }

        public func validate(name: String) throws {
            try self.validate(self.cloudVmClusterId, name: "cloudVmClusterId", parent: name, max: 64)
            try self.validate(self.cloudVmClusterId, name: "cloudVmClusterId", parent: name, min: 6)
            try self.validate(self.cloudVmClusterId, name: "cloudVmClusterId", parent: name, pattern: "^[a-zA-Z0-9_~.-]+$")
            try self.validate(self.dbNodeId, name: "dbNodeId", parent: name, max: 64)
            try self.validate(self.dbNodeId, name: "dbNodeId", parent: name, min: 6)
            try self.validate(self.dbNodeId, name: "dbNodeId", parent: name, pattern: "^[a-zA-Z0-9_~.-]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct StopDbNodeOutput: AWSDecodableShape {
        /// The unique identifier of the DB node that was stopped.
        public let dbNodeId: String
        /// The current status of the DB node after the stop operation.
        public let status: DbNodeResourceStatus?
        /// Additional information about the status of the DB node after the stop operation.
        public let statusReason: String?

        @inlinable
        public init(dbNodeId: String, status: DbNodeResourceStatus? = nil, statusReason: String? = nil) {
            self.dbNodeId = dbNodeId
            self.status = status
            self.statusReason = statusReason
        }

        private enum CodingKeys: String, CodingKey {
            case dbNodeId = "dbNodeId"
            case status = "status"
            case statusReason = "statusReason"
        }
    }

    public struct SystemVersionSummary: AWSDecodableShape {
        /// The version of GI software.
        public let giVersion: String?
        /// The Exadata hardware model.
        public let shape: String?
        /// The Exadata system versions that are compatible with the specified Exadata shape and GI version.
        public let systemVersions: [String]?

        @inlinable
        public init(giVersion: String? = nil, shape: String? = nil, systemVersions: [String]? = nil) {
            self.giVersion = giVersion
            self.shape = shape
            self.systemVersions = systemVersions
        }

        private enum CodingKeys: String, CodingKey {
            case giVersion = "giVersion"
            case shape = "shape"
            case systemVersions = "systemVersions"
        }
    }

    public struct TagResourceRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the resource to apply tags to.
        public let resourceArn: String
        /// The list of tags to apply to the resource.
        public let tags: [String: String]

        @inlinable
        public init(resourceArn: String, tags: [String: String]) {
            self.resourceArn = resourceArn
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, max: 2048)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, min: 20)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, pattern: "^arn:(?:aws|aws-cn|aws-us-gov|aws-iso-{0,1}[a-z]{0,1}):[a-z0-9-]+:[a-z0-9-]*:[0-9]+:[a-z0-9-]+/[a-z0-9-_]{6,64}$")
            try self.tags.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 200)
            try self.validate(self.tags, name: "tags", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case resourceArn = "resourceArn"
            case tags = "tags"
        }
    }

    public struct TagResourceResponse: AWSDecodableShape {
        public init() {}
    }

    public struct ThrottlingException: AWSErrorShape {
        public let message: String
        /// The number of seconds to wait before retrying the request after being throttled.
        public let retryAfterSeconds: Int?

        @inlinable
        public init(message: String, retryAfterSeconds: Int? = nil) {
            self.message = message
            self.retryAfterSeconds = retryAfterSeconds
        }

        public init(from decoder: Decoder) throws {
            let response = decoder.userInfo[.awsResponse]! as! ResponseDecodingContainer
            let container = try decoder.container(keyedBy: CodingKeys.self)
            self.message = try container.decode(String.self, forKey: .message)
            self.retryAfterSeconds = try response.decodeHeaderIfPresent(Int.self, key: "Retry-After")
        }

        private enum CodingKeys: String, CodingKey {
            case message = "message"
        }
    }

    public struct UntagResourceRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the resource to remove tags from.
        public let resourceArn: String
        /// The names (keys) of the tags to remove from the resource.
        public let tagKeys: [String]

        @inlinable
        public init(resourceArn: String, tagKeys: [String]) {
            self.resourceArn = resourceArn
            self.tagKeys = tagKeys
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.resourceArn, key: "resourceArn")
            try container.encode(self.tagKeys, forKey: .tagKeys)
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, max: 2048)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, min: 20)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, pattern: "^arn:(?:aws|aws-cn|aws-us-gov|aws-iso-{0,1}[a-z]{0,1}):[a-z0-9-]+:[a-z0-9-]*:[0-9]+:[a-z0-9-]+/[a-z0-9-_]{6,64}$")
            try self.tagKeys.forEach {
                try validate($0, name: "tagKeys[]", parent: name, max: 128)
                try validate($0, name: "tagKeys[]", parent: name, min: 1)
            }
            try self.validate(self.tagKeys, name: "tagKeys", parent: name, max: 200)
            try self.validate(self.tagKeys, name: "tagKeys", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case tagKeys = "tagKeys"
        }
    }

    public struct UntagResourceResponse: AWSDecodableShape {
        public init() {}
    }

    public struct UpdateCloudExadataInfrastructureInput: AWSEncodableShape {
        /// The unique identifier of the Exadata infrastructure to update.
        public let cloudExadataInfrastructureId: String
        public let maintenanceWindow: MaintenanceWindow?

        @inlinable
        public init(cloudExadataInfrastructureId: String, maintenanceWindow: MaintenanceWindow? = nil) {
            self.cloudExadataInfrastructureId = cloudExadataInfrastructureId
            self.maintenanceWindow = maintenanceWindow
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.cloudExadataInfrastructureId, key: "cloudExadataInfrastructureId")
            try container.encodeIfPresent(self.maintenanceWindow, forKey: .maintenanceWindow)
        }

        public func validate(name: String) throws {
            try self.validate(self.cloudExadataInfrastructureId, name: "cloudExadataInfrastructureId", parent: name, max: 2048)
            try self.validate(self.cloudExadataInfrastructureId, name: "cloudExadataInfrastructureId", parent: name, min: 6)
            try self.validate(self.cloudExadataInfrastructureId, name: "cloudExadataInfrastructureId", parent: name, pattern: "^(arn:(?:aws|aws-cn|aws-us-gov|aws-iso-{0,1}[a-z]{0,1}):[a-z0-9-]+:[a-z0-9-]*:[0-9]+:[a-z0-9-]+/[a-zA-Z0-9_~.-]{6,64}|[a-zA-Z0-9_~.-]{6,64})$")
        }

        private enum CodingKeys: String, CodingKey {
            case maintenanceWindow = "maintenanceWindow"
        }
    }

    public struct UpdateCloudExadataInfrastructureOutput: AWSDecodableShape {
        /// The unique identifier of the updated Exadata infrastructure.
        public let cloudExadataInfrastructureId: String
        /// The user-friendly name of the updated Exadata infrastructure.
        public let displayName: String?
        /// The current status of the Exadata infrastructure after the update operation.
        public let status: ResourceStatus?
        /// Additional information about the status of the Exadata infrastructure after the update operation.
        public let statusReason: String?

        @inlinable
        public init(cloudExadataInfrastructureId: String, displayName: String? = nil, status: ResourceStatus? = nil, statusReason: String? = nil) {
            self.cloudExadataInfrastructureId = cloudExadataInfrastructureId
            self.displayName = displayName
            self.status = status
            self.statusReason = statusReason
        }

        private enum CodingKeys: String, CodingKey {
            case cloudExadataInfrastructureId = "cloudExadataInfrastructureId"
            case displayName = "displayName"
            case status = "status"
            case statusReason = "statusReason"
        }
    }

    public struct UpdateOdbNetworkInput: AWSEncodableShape {
        /// The new user-friendly name of the ODB network.
        public let displayName: String?
        /// The unique identifier of the ODB network to update.
        public let odbNetworkId: String
        /// The list of CIDR ranges from the peered VPC that allow access to the ODB network.
        public let peeredCidrsToBeAdded: [String]?
        /// The list of CIDR ranges from the peered VPC to remove from the ODB network.
        public let peeredCidrsToBeRemoved: [String]?
        /// Specifies the updated configuration for Amazon S3 access from the ODB network.
        public let s3Access: Access?
        /// Specifies the updated endpoint policy for Amazon S3 access from the ODB network.
        public let s3PolicyDocument: String?
        /// Specifies the updated configuration for Zero-ETL access from the ODB network.
        public let zeroEtlAccess: Access?

        @inlinable
        public init(displayName: String? = nil, odbNetworkId: String, peeredCidrsToBeAdded: [String]? = nil, peeredCidrsToBeRemoved: [String]? = nil, s3Access: Access? = nil, s3PolicyDocument: String? = nil, zeroEtlAccess: Access? = nil) {
            self.displayName = displayName
            self.odbNetworkId = odbNetworkId
            self.peeredCidrsToBeAdded = peeredCidrsToBeAdded
            self.peeredCidrsToBeRemoved = peeredCidrsToBeRemoved
            self.s3Access = s3Access
            self.s3PolicyDocument = s3PolicyDocument
            self.zeroEtlAccess = zeroEtlAccess
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.displayName, forKey: .displayName)
            request.encodePath(self.odbNetworkId, key: "odbNetworkId")
            try container.encodeIfPresent(self.peeredCidrsToBeAdded, forKey: .peeredCidrsToBeAdded)
            try container.encodeIfPresent(self.peeredCidrsToBeRemoved, forKey: .peeredCidrsToBeRemoved)
            try container.encodeIfPresent(self.s3Access, forKey: .s3Access)
            try container.encodeIfPresent(self.s3PolicyDocument, forKey: .s3PolicyDocument)
            try container.encodeIfPresent(self.zeroEtlAccess, forKey: .zeroEtlAccess)
        }

        public func validate(name: String) throws {
            try self.validate(self.displayName, name: "displayName", parent: name, max: 255)
            try self.validate(self.displayName, name: "displayName", parent: name, min: 1)
            try self.validate(self.displayName, name: "displayName", parent: name, pattern: "^[a-zA-Z_](?!.*--)[a-zA-Z0-9_-]*$")
            try self.validate(self.odbNetworkId, name: "odbNetworkId", parent: name, max: 2048)
            try self.validate(self.odbNetworkId, name: "odbNetworkId", parent: name, min: 6)
            try self.validate(self.odbNetworkId, name: "odbNetworkId", parent: name, pattern: "^(arn:(?:aws|aws-cn|aws-us-gov|aws-iso-{0,1}[a-z]{0,1}):[a-z0-9-]+:[a-z0-9-]*:[0-9]+:[a-z0-9-]+/[a-zA-Z0-9_~.-]{6,64}|[a-zA-Z0-9_~.-]{6,64})$")
            try self.validate(self.peeredCidrsToBeAdded, name: "peeredCidrsToBeAdded", parent: name, max: 1024)
            try self.validate(self.peeredCidrsToBeAdded, name: "peeredCidrsToBeAdded", parent: name, min: 1)
            try self.validate(self.peeredCidrsToBeRemoved, name: "peeredCidrsToBeRemoved", parent: name, max: 1024)
            try self.validate(self.peeredCidrsToBeRemoved, name: "peeredCidrsToBeRemoved", parent: name, min: 1)
            try self.validate(self.s3PolicyDocument, name: "s3PolicyDocument", parent: name, max: 20480)
            try self.validate(self.s3PolicyDocument, name: "s3PolicyDocument", parent: name, min: 3)
        }

        private enum CodingKeys: String, CodingKey {
            case displayName = "displayName"
            case peeredCidrsToBeAdded = "peeredCidrsToBeAdded"
            case peeredCidrsToBeRemoved = "peeredCidrsToBeRemoved"
            case s3Access = "s3Access"
            case s3PolicyDocument = "s3PolicyDocument"
            case zeroEtlAccess = "zeroEtlAccess"
        }
    }

    public struct UpdateOdbNetworkOutput: AWSDecodableShape {
        /// The user-friendly name of the ODB network.
        public let displayName: String?
        /// The unique identifier of the ODB network.
        public let odbNetworkId: String
        /// The current status of the ODB network.
        public let status: ResourceStatus?
        /// Additional information about the status of the ODB network.
        public let statusReason: String?

        @inlinable
        public init(displayName: String? = nil, odbNetworkId: String, status: ResourceStatus? = nil, statusReason: String? = nil) {
            self.displayName = displayName
            self.odbNetworkId = odbNetworkId
            self.status = status
            self.statusReason = statusReason
        }

        private enum CodingKeys: String, CodingKey {
            case displayName = "displayName"
            case odbNetworkId = "odbNetworkId"
            case status = "status"
            case statusReason = "statusReason"
        }
    }

    public struct ValidationException: AWSErrorShape {
        /// A list of fields that failed validation.
        public let fieldList: [ValidationExceptionField]?
        public let message: String
        /// The reason why the validation failed.
        public let reason: ValidationExceptionReason

        @inlinable
        public init(fieldList: [ValidationExceptionField]? = nil, message: String, reason: ValidationExceptionReason) {
            self.fieldList = fieldList
            self.message = message
            self.reason = reason
        }

        private enum CodingKeys: String, CodingKey {
            case fieldList = "fieldList"
            case message = "message"
            case reason = "reason"
        }
    }

    public struct ValidationExceptionField: AWSDecodableShape {
        /// The description of the error.
        public let message: String
        /// The field name for which validation failed.
        public let name: String

        @inlinable
        public init(message: String, name: String) {
            self.message = message
            self.name = name
        }

        private enum CodingKeys: String, CodingKey {
            case message = "message"
            case name = "name"
        }
    }

    public struct ZeroEtlAccess: AWSDecodableShape {
        /// The CIDR block for the Zero-ETL access.
        public let cidr: String?
        /// The status of the Zero-ETL access. Valid Values: enabled | disabled
        public let status: ManagedResourceStatus?

        @inlinable
        public init(cidr: String? = nil, status: ManagedResourceStatus? = nil) {
            self.cidr = cidr
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case cidr = "cidr"
            case status = "status"
        }
    }
}

// MARK: - Errors

/// Error enum for Odb
public struct OdbErrorType: AWSErrorType {
    enum Code: String {
        case accessDeniedException = "AccessDeniedException"
        case conflictException = "ConflictException"
        case internalServerException = "InternalServerException"
        case resourceNotFoundException = "ResourceNotFoundException"
        case serviceQuotaExceededException = "ServiceQuotaExceededException"
        case throttlingException = "ThrottlingException"
        case validationException = "ValidationException"
    }

    private let error: Code
    public let context: AWSErrorContext?

    /// initialize Odb
    public init?(errorCode: String, context: AWSErrorContext) {
        guard let error = Code(rawValue: errorCode) else { return nil }
        self.error = error
        self.context = context
    }

    internal init(_ error: Code) {
        self.error = error
        self.context = nil
    }

    /// return error code string
    public var errorCode: String { self.error.rawValue }

    /// You don't have sufficient access to perform this action. Make sure you have the required permissions and try again.
    public static var accessDeniedException: Self { .init(.accessDeniedException) }
    /// Occurs when a conflict with the current status of your resource. Fix any inconsistencies with your resource and try again.
    public static var conflictException: Self { .init(.conflictException) }
    /// Occurs when there is an internal failure in the Oracle Database@Amazon Web Services service. Wait and try again.
    public static var internalServerException: Self { .init(.internalServerException) }
    /// The operation tried to access a resource that doesn't exist. Make sure you provided the correct resource and try again.
    public static var resourceNotFoundException: Self { .init(.resourceNotFoundException) }
    /// You have exceeded the service quota.
    public static var serviceQuotaExceededException: Self { .init(.serviceQuotaExceededException) }
    /// The request was denied due to request throttling.
    public static var throttlingException: Self { .init(.throttlingException) }
    /// The request has failed validation because it is missing required fields or has invalid inputs.
    public static var validationException: Self { .init(.validationException) }
}

extension OdbErrorType: AWSServiceErrorType {
    public static let errorCodeMap: [String: AWSErrorShape.Type] = [
        "ConflictException": Odb.ConflictException.self,
        "InternalServerException": Odb.InternalServerException.self,
        "ResourceNotFoundException": Odb.ResourceNotFoundException.self,
        "ServiceQuotaExceededException": Odb.ServiceQuotaExceededException.self,
        "ThrottlingException": Odb.ThrottlingException.self,
        "ValidationException": Odb.ValidationException.self
    ]
}

extension OdbErrorType: Equatable {
    public static func == (lhs: OdbErrorType, rhs: OdbErrorType) -> Bool {
        lhs.error == rhs.error
    }
}

extension OdbErrorType: CustomStringConvertible {
    public var description: String {
        return "\(self.error.rawValue): \(self.message ?? "")"
    }
}
