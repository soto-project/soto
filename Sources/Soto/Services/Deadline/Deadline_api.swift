//===----------------------------------------------------------------------===//
//
// This source file is part of the Soto for AWS open source project
//
// Copyright (c) 2017-2024 the Soto project authors
// Licensed under Apache License v2.0
//
// See LICENSE.txt for license information
// See CONTRIBUTORS.txt for the list of Soto project authors
//
// SPDX-License-Identifier: Apache-2.0
//
//===----------------------------------------------------------------------===//

// THIS FILE IS AUTOMATICALLY GENERATED by https://github.com/soto-project/soto-codegenerator.
// DO NOT EDIT.

#if os(Linux) && compiler(<5.10)
// swift-corelibs-foundation hasn't been updated with Sendable conformances
@preconcurrency import Foundation
#else
import Foundation
#endif
@_exported import SotoCore

/// Service object for interacting with AWS Deadline service.
///
/// The Amazon Web Services Deadline Cloud API provides infrastructure and centralized management for your projects. Use the Deadline Cloud API to onboard users, assign projects, and attach permissions specific to their job function. With Deadline Cloud, content production teams can deploy resources for their workforce securely in the cloud, reducing the costs of added physical infrastructure. Keep your content production operations secure, while allowing your contributors to access the tools they need, such as scalable high-speed storage, licenses, and cost management services.
public struct Deadline: AWSService {
    // MARK: Member variables

    /// Client used for communication with AWS
    public let client: AWSClient
    /// Service configuration
    public let config: AWSServiceConfig

    // MARK: Initialization

    /// Initialize the Deadline client
    /// - parameters:
    ///     - client: AWSClient used to process requests
    ///     - region: Region of server you want to communicate with. This will override the partition parameter.
    ///     - partition: AWS partition where service resides, standard (.aws), china (.awscn), government (.awsusgov).
    ///     - endpoint: Custom endpoint URL to use instead of standard AWS servers
    ///     - middleware: Middleware chain used to edit requests before they are sent and responses before they are decoded 
    ///     - timeout: Timeout value for HTTP requests
    ///     - byteBufferAllocator: Allocator for ByteBuffers
    ///     - options: Service options
    public init(
        client: AWSClient,
        region: SotoCore.Region? = nil,
        partition: AWSPartition = .aws,
        endpoint: String? = nil,
        middleware: AWSMiddlewareProtocol? = nil,
        timeout: TimeAmount? = nil,
        byteBufferAllocator: ByteBufferAllocator = ByteBufferAllocator(),
        options: AWSServiceConfig.Options = []
    ) {
        self.client = client
        self.config = AWSServiceConfig(
            region: region,
            partition: region?.partition ?? partition,
            serviceName: "Deadline",
            serviceIdentifier: "deadline",
            serviceProtocol: .restjson,
            apiVersion: "2023-10-12",
            endpoint: endpoint,
            errorType: DeadlineErrorType.self,
            middleware: middleware,
            timeout: timeout,
            byteBufferAllocator: byteBufferAllocator,
            options: options
        )
    }





    // MARK: API Calls

    /// Assigns a farm membership level to a member.
    @Sendable
    @inlinable
    public func associateMemberToFarm(_ input: AssociateMemberToFarmRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> AssociateMemberToFarmResponse {
        try await self.client.execute(
            operation: "AssociateMemberToFarm", 
            path: "/2023-10-12/farms/{farmId}/members/{principalId}", 
            httpMethod: .PUT, 
            serviceConfig: self.config, 
            input: input, 
            hostPrefix: "management.", 
            logger: logger
        )
    }
    /// Assigns a farm membership level to a member.
    ///
    /// Parameters:
    ///   - farmId: The ID of the farm to associate with the member.
    ///   - identityStoreId: The identity store ID of the member to associate with the farm.
    ///   - membershipLevel: The principal's membership level for the associated farm.
    ///   - principalId: The member's principal ID to associate with the farm.
    ///   - principalType: The principal type of the member to associate with the farm.
    ///   - logger: Logger use during operation
    @inlinable
    public func associateMemberToFarm(
        farmId: String,
        identityStoreId: String,
        membershipLevel: MembershipLevel,
        principalId: String,
        principalType: DeadlinePrincipalType,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> AssociateMemberToFarmResponse {
        let input = AssociateMemberToFarmRequest(
            farmId: farmId, 
            identityStoreId: identityStoreId, 
            membershipLevel: membershipLevel, 
            principalId: principalId, 
            principalType: principalType
        )
        return try await self.associateMemberToFarm(input, logger: logger)
    }

    /// Assigns a fleet membership level to a member.
    @Sendable
    @inlinable
    public func associateMemberToFleet(_ input: AssociateMemberToFleetRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> AssociateMemberToFleetResponse {
        try await self.client.execute(
            operation: "AssociateMemberToFleet", 
            path: "/2023-10-12/farms/{farmId}/fleets/{fleetId}/members/{principalId}", 
            httpMethod: .PUT, 
            serviceConfig: self.config, 
            input: input, 
            hostPrefix: "management.", 
            logger: logger
        )
    }
    /// Assigns a fleet membership level to a member.
    ///
    /// Parameters:
    ///   - farmId: The farm ID of the fleet to associate with the member.
    ///   - fleetId: The ID of the fleet to associate with a member.
    ///   - identityStoreId: The member's identity store ID to associate with the fleet.
    ///   - membershipLevel: The principal's membership level for the associated fleet.
    ///   - principalId: The member's principal ID to associate with a fleet.
    ///   - principalType: The member's principal type to associate with the fleet.
    ///   - logger: Logger use during operation
    @inlinable
    public func associateMemberToFleet(
        farmId: String,
        fleetId: String,
        identityStoreId: String,
        membershipLevel: MembershipLevel,
        principalId: String,
        principalType: DeadlinePrincipalType,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> AssociateMemberToFleetResponse {
        let input = AssociateMemberToFleetRequest(
            farmId: farmId, 
            fleetId: fleetId, 
            identityStoreId: identityStoreId, 
            membershipLevel: membershipLevel, 
            principalId: principalId, 
            principalType: principalType
        )
        return try await self.associateMemberToFleet(input, logger: logger)
    }

    /// Assigns a job membership level to a member
    @Sendable
    @inlinable
    public func associateMemberToJob(_ input: AssociateMemberToJobRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> AssociateMemberToJobResponse {
        try await self.client.execute(
            operation: "AssociateMemberToJob", 
            path: "/2023-10-12/farms/{farmId}/queues/{queueId}/jobs/{jobId}/members/{principalId}", 
            httpMethod: .PUT, 
            serviceConfig: self.config, 
            input: input, 
            hostPrefix: "management.", 
            logger: logger
        )
    }
    /// Assigns a job membership level to a member
    ///
    /// Parameters:
    ///   - farmId: The farm ID of the job to associate with the member.
    ///   - identityStoreId: The member's identity store ID to associate with the job.
    ///   - jobId: The job ID to associate with the member.
    ///   - membershipLevel: The principal's membership level for the associated job.
    ///   - principalId: The member's principal ID to associate with the job.
    ///   - principalType: The member's principal type to associate with the job.
    ///   - queueId: The queue ID to associate to the member.
    ///   - logger: Logger use during operation
    @inlinable
    public func associateMemberToJob(
        farmId: String,
        identityStoreId: String,
        jobId: String,
        membershipLevel: MembershipLevel,
        principalId: String,
        principalType: DeadlinePrincipalType,
        queueId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> AssociateMemberToJobResponse {
        let input = AssociateMemberToJobRequest(
            farmId: farmId, 
            identityStoreId: identityStoreId, 
            jobId: jobId, 
            membershipLevel: membershipLevel, 
            principalId: principalId, 
            principalType: principalType, 
            queueId: queueId
        )
        return try await self.associateMemberToJob(input, logger: logger)
    }

    /// Assigns a queue membership level to a member
    @Sendable
    @inlinable
    public func associateMemberToQueue(_ input: AssociateMemberToQueueRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> AssociateMemberToQueueResponse {
        try await self.client.execute(
            operation: "AssociateMemberToQueue", 
            path: "/2023-10-12/farms/{farmId}/queues/{queueId}/members/{principalId}", 
            httpMethod: .PUT, 
            serviceConfig: self.config, 
            input: input, 
            hostPrefix: "management.", 
            logger: logger
        )
    }
    /// Assigns a queue membership level to a member
    ///
    /// Parameters:
    ///   - farmId: The farm ID of the queue to associate with the member.
    ///   - identityStoreId: The member's identity store ID to associate with the queue.
    ///   - membershipLevel: The principal's membership level for the associated queue.
    ///   - principalId: The member's principal ID to associate with the queue.
    ///   - principalType: The member's principal type to associate with the queue.
    ///   - queueId: The ID of the queue to associate to the member.
    ///   - logger: Logger use during operation
    @inlinable
    public func associateMemberToQueue(
        farmId: String,
        identityStoreId: String,
        membershipLevel: MembershipLevel,
        principalId: String,
        principalType: DeadlinePrincipalType,
        queueId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> AssociateMemberToQueueResponse {
        let input = AssociateMemberToQueueRequest(
            farmId: farmId, 
            identityStoreId: identityStoreId, 
            membershipLevel: membershipLevel, 
            principalId: principalId, 
            principalType: principalType, 
            queueId: queueId
        )
        return try await self.associateMemberToQueue(input, logger: logger)
    }

    /// Get Amazon Web Services credentials from the fleet role. The IAM permissions of the credentials are scoped down to have read-only access.
    @Sendable
    @inlinable
    public func assumeFleetRoleForRead(_ input: AssumeFleetRoleForReadRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> AssumeFleetRoleForReadResponse {
        try await self.client.execute(
            operation: "AssumeFleetRoleForRead", 
            path: "/2023-10-12/farms/{farmId}/fleets/{fleetId}/read-roles", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            hostPrefix: "management.", 
            logger: logger
        )
    }
    /// Get Amazon Web Services credentials from the fleet role. The IAM permissions of the credentials are scoped down to have read-only access.
    ///
    /// Parameters:
    ///   - farmId: The farm ID for the fleet's farm.
    ///   - fleetId: The fleet ID.
    ///   - logger: Logger use during operation
    @inlinable
    public func assumeFleetRoleForRead(
        farmId: String,
        fleetId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> AssumeFleetRoleForReadResponse {
        let input = AssumeFleetRoleForReadRequest(
            farmId: farmId, 
            fleetId: fleetId
        )
        return try await self.assumeFleetRoleForRead(input, logger: logger)
    }

    /// Get credentials from the fleet role for a worker.
    @Sendable
    @inlinable
    public func assumeFleetRoleForWorker(_ input: AssumeFleetRoleForWorkerRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> AssumeFleetRoleForWorkerResponse {
        try await self.client.execute(
            operation: "AssumeFleetRoleForWorker", 
            path: "/2023-10-12/farms/{farmId}/fleets/{fleetId}/workers/{workerId}/fleet-roles", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            hostPrefix: "scheduling.", 
            logger: logger
        )
    }
    /// Get credentials from the fleet role for a worker.
    ///
    /// Parameters:
    ///   - farmId: The farm ID for the fleet's farm.
    ///   - fleetId: The fleet ID that contains the worker.
    ///   - workerId: The ID of the worker assuming the fleet role.
    ///   - logger: Logger use during operation
    @inlinable
    public func assumeFleetRoleForWorker(
        farmId: String,
        fleetId: String,
        workerId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> AssumeFleetRoleForWorkerResponse {
        let input = AssumeFleetRoleForWorkerRequest(
            farmId: farmId, 
            fleetId: fleetId, 
            workerId: workerId
        )
        return try await self.assumeFleetRoleForWorker(input, logger: logger)
    }

    /// Gets Amazon Web Services credentials from the queue role. The IAM permissions of the credentials are scoped down to have read-only access.
    @Sendable
    @inlinable
    public func assumeQueueRoleForRead(_ input: AssumeQueueRoleForReadRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> AssumeQueueRoleForReadResponse {
        try await self.client.execute(
            operation: "AssumeQueueRoleForRead", 
            path: "/2023-10-12/farms/{farmId}/queues/{queueId}/read-roles", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            hostPrefix: "management.", 
            logger: logger
        )
    }
    /// Gets Amazon Web Services credentials from the queue role. The IAM permissions of the credentials are scoped down to have read-only access.
    ///
    /// Parameters:
    ///   - farmId: The farm ID of the farm containing the queue.
    ///   - queueId: The queue ID.
    ///   - logger: Logger use during operation
    @inlinable
    public func assumeQueueRoleForRead(
        farmId: String,
        queueId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> AssumeQueueRoleForReadResponse {
        let input = AssumeQueueRoleForReadRequest(
            farmId: farmId, 
            queueId: queueId
        )
        return try await self.assumeQueueRoleForRead(input, logger: logger)
    }

    /// Allows a user to assume a role for a queue.
    @Sendable
    @inlinable
    public func assumeQueueRoleForUser(_ input: AssumeQueueRoleForUserRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> AssumeQueueRoleForUserResponse {
        try await self.client.execute(
            operation: "AssumeQueueRoleForUser", 
            path: "/2023-10-12/farms/{farmId}/queues/{queueId}/user-roles", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            hostPrefix: "management.", 
            logger: logger
        )
    }
    /// Allows a user to assume a role for a queue.
    ///
    /// Parameters:
    ///   - farmId: The farm ID of the queue that the user assumes the role for.
    ///   - queueId: The queue ID of the queue that the user assumes the role for.
    ///   - logger: Logger use during operation
    @inlinable
    public func assumeQueueRoleForUser(
        farmId: String,
        queueId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> AssumeQueueRoleForUserResponse {
        let input = AssumeQueueRoleForUserRequest(
            farmId: farmId, 
            queueId: queueId
        )
        return try await self.assumeQueueRoleForUser(input, logger: logger)
    }

    /// Allows a worker to assume a queue role.
    @Sendable
    @inlinable
    public func assumeQueueRoleForWorker(_ input: AssumeQueueRoleForWorkerRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> AssumeQueueRoleForWorkerResponse {
        try await self.client.execute(
            operation: "AssumeQueueRoleForWorker", 
            path: "/2023-10-12/farms/{farmId}/fleets/{fleetId}/workers/{workerId}/queue-roles", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            hostPrefix: "scheduling.", 
            logger: logger
        )
    }
    /// Allows a worker to assume a queue role.
    ///
    /// Parameters:
    ///   - farmId: The farm ID of the worker assuming the queue role.
    ///   - fleetId: The fleet ID of the worker assuming the queue role.
    ///   - queueId: The queue ID of the worker assuming the queue role.
    ///   - workerId: The worker ID of the worker assuming the queue role.
    ///   - logger: Logger use during operation
    @inlinable
    public func assumeQueueRoleForWorker(
        farmId: String,
        fleetId: String,
        queueId: String,
        workerId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> AssumeQueueRoleForWorkerResponse {
        let input = AssumeQueueRoleForWorkerRequest(
            farmId: farmId, 
            fleetId: fleetId, 
            queueId: queueId, 
            workerId: workerId
        )
        return try await self.assumeQueueRoleForWorker(input, logger: logger)
    }

    /// Get batched job details for a worker.
    @Sendable
    @inlinable
    public func batchGetJobEntity(_ input: BatchGetJobEntityRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> BatchGetJobEntityResponse {
        try await self.client.execute(
            operation: "BatchGetJobEntity", 
            path: "/2023-10-12/farms/{farmId}/fleets/{fleetId}/workers/{workerId}/batchGetJobEntity", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            hostPrefix: "scheduling.", 
            logger: logger
        )
    }
    /// Get batched job details for a worker.
    ///
    /// Parameters:
    ///   - farmId: The farm ID of the worker that's fetching job details. The worker must have an assignment on a job to fetch job details.
    ///   - fleetId: The fleet ID of the worker that's fetching job details. The worker must have an assignment on a job to fetch job details.
    ///   - identifiers: The job identifiers to include within the job entity batch details.
    ///   - workerId: The worker ID of the worker containing the job details to get.
    ///   - logger: Logger use during operation
    @inlinable
    public func batchGetJobEntity(
        farmId: String,
        fleetId: String,
        identifiers: [JobEntityIdentifiersUnion],
        workerId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> BatchGetJobEntityResponse {
        let input = BatchGetJobEntityRequest(
            farmId: farmId, 
            fleetId: fleetId, 
            identifiers: identifiers, 
            workerId: workerId
        )
        return try await self.batchGetJobEntity(input, logger: logger)
    }

    /// Copies a job template to an Amazon S3 bucket.
    @Sendable
    @inlinable
    public func copyJobTemplate(_ input: CopyJobTemplateRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> CopyJobTemplateResponse {
        try await self.client.execute(
            operation: "CopyJobTemplate", 
            path: "/2023-10-12/farms/{farmId}/queues/{queueId}/jobs/{jobId}/template", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            hostPrefix: "management.", 
            logger: logger
        )
    }
    /// Copies a job template to an Amazon S3 bucket.
    ///
    /// Parameters:
    ///   - farmId: The farm ID to copy.
    ///   - jobId: The job ID to copy.
    ///   - queueId: The queue ID to copy.
    ///   - targetS3Location: The Amazon S3 bucket name and key where you would like to add a copy of the job template.
    ///   - logger: Logger use during operation
    @inlinable
    public func copyJobTemplate(
        farmId: String,
        jobId: String,
        queueId: String,
        targetS3Location: S3Location,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> CopyJobTemplateResponse {
        let input = CopyJobTemplateRequest(
            farmId: farmId, 
            jobId: jobId, 
            queueId: queueId, 
            targetS3Location: targetS3Location
        )
        return try await self.copyJobTemplate(input, logger: logger)
    }

    /// Creates a budget to set spending thresholds for your rendering activity.
    @Sendable
    @inlinable
    public func createBudget(_ input: CreateBudgetRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> CreateBudgetResponse {
        try await self.client.execute(
            operation: "CreateBudget", 
            path: "/2023-10-12/farms/{farmId}/budgets", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            hostPrefix: "management.", 
            logger: logger
        )
    }
    /// Creates a budget to set spending thresholds for your rendering activity.
    ///
    /// Parameters:
    ///   - actions: The budget actions to specify what happens when the budget runs out.
    ///   - approximateDollarLimit: The dollar limit based on consumed usage.
    ///   - clientToken: The unique token which the server uses to recognize retries of the same request.
    ///   - description: The description of the budget.  This field can store any content. Escape or encode this content before displaying it on a webpage or any other system that might interpret the content of this field.
    ///   - displayName: The display name of the budget.  This field can store any content. Escape or encode this content before displaying it on a webpage or any other system that might interpret the content of this field.
    ///   - farmId: The farm ID to include in this budget.
    ///   - schedule: The schedule to associate with this budget.
    ///   - usageTrackingResource: The queue ID provided to this budget to track usage.
    ///   - logger: Logger use during operation
    @inlinable
    public func createBudget(
        actions: [BudgetActionToAdd],
        approximateDollarLimit: Float,
        clientToken: String? = CreateBudgetRequest.idempotencyToken(),
        description: String? = nil,
        displayName: String,
        farmId: String,
        schedule: BudgetSchedule,
        usageTrackingResource: UsageTrackingResource,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> CreateBudgetResponse {
        let input = CreateBudgetRequest(
            actions: actions, 
            approximateDollarLimit: approximateDollarLimit, 
            clientToken: clientToken, 
            description: description, 
            displayName: displayName, 
            farmId: farmId, 
            schedule: schedule, 
            usageTrackingResource: usageTrackingResource
        )
        return try await self.createBudget(input, logger: logger)
    }

    /// Creates a farm to allow space for queues and fleets. Farms are the space where the components of your renders gather and are pieced together in the cloud. Farms contain budgets and allow you to enforce permissions. Deadline Cloud farms are a useful container for large projects.
    @Sendable
    @inlinable
    public func createFarm(_ input: CreateFarmRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> CreateFarmResponse {
        try await self.client.execute(
            operation: "CreateFarm", 
            path: "/2023-10-12/farms", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            hostPrefix: "management.", 
            logger: logger
        )
    }
    /// Creates a farm to allow space for queues and fleets. Farms are the space where the components of your renders gather and are pieced together in the cloud. Farms contain budgets and allow you to enforce permissions. Deadline Cloud farms are a useful container for large projects.
    ///
    /// Parameters:
    ///   - clientToken: The unique token which the server uses to recognize retries of the same request.
    ///   - description: The description of the farm.  This field can store any content. Escape or encode this content before displaying it on a webpage or any other system that might interpret the content of this field.
    ///   - displayName: The display name of the farm.  This field can store any content. Escape or encode this content before displaying it on a webpage or any other system that might interpret the content of this field.
    ///   - kmsKeyArn: The ARN of the KMS key to use on the farm.
    ///   - tags: The tags to add to your farm. Each tag consists of a tag key and a tag value. Tag keys and values are both required, but tag values can be empty strings.
    ///   - logger: Logger use during operation
    @inlinable
    public func createFarm(
        clientToken: String? = CreateFarmRequest.idempotencyToken(),
        description: String? = nil,
        displayName: String,
        kmsKeyArn: String? = nil,
        tags: [String: String]? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> CreateFarmResponse {
        let input = CreateFarmRequest(
            clientToken: clientToken, 
            description: description, 
            displayName: displayName, 
            kmsKeyArn: kmsKeyArn, 
            tags: tags
        )
        return try await self.createFarm(input, logger: logger)
    }

    /// Creates a fleet. Fleets gather information relating to compute, or capacity, for renders within your farms. You can choose to manage your own capacity or opt to have fleets fully managed by Deadline Cloud.
    @Sendable
    @inlinable
    public func createFleet(_ input: CreateFleetRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> CreateFleetResponse {
        try await self.client.execute(
            operation: "CreateFleet", 
            path: "/2023-10-12/farms/{farmId}/fleets", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            hostPrefix: "management.", 
            logger: logger
        )
    }
    /// Creates a fleet. Fleets gather information relating to compute, or capacity, for renders within your farms. You can choose to manage your own capacity or opt to have fleets fully managed by Deadline Cloud.
    ///
    /// Parameters:
    ///   - clientToken: The unique token which the server uses to recognize retries of the same request.
    ///   - configuration: The configuration settings for the fleet. Customer managed fleets are self-managed. Service managed Amazon EC2 fleets are managed by Deadline Cloud.
    ///   - description: The description of the fleet.  This field can store any content. Escape or encode this content before displaying it on a webpage or any other system that might interpret the content of this field.
    ///   - displayName: The display name of the fleet.  This field can store any content. Escape or encode this content before displaying it on a webpage or any other system that might interpret the content of this field.
    ///   - farmId: The farm ID of the farm to connect to the fleet.
    ///   - maxWorkerCount: The maximum number of workers for the fleet.
    ///   - minWorkerCount: The minimum number of workers for the fleet.
    ///   - roleArn: The IAM role ARN for the role that the fleet's workers will use.
    ///   - tags: Each tag consists of a tag key and a tag value. Tag keys and values are both required, but tag values can be empty strings.
    ///   - logger: Logger use during operation
    @inlinable
    public func createFleet(
        clientToken: String? = CreateFleetRequest.idempotencyToken(),
        configuration: FleetConfiguration,
        description: String? = nil,
        displayName: String,
        farmId: String,
        maxWorkerCount: Int,
        minWorkerCount: Int? = nil,
        roleArn: String,
        tags: [String: String]? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> CreateFleetResponse {
        let input = CreateFleetRequest(
            clientToken: clientToken, 
            configuration: configuration, 
            description: description, 
            displayName: displayName, 
            farmId: farmId, 
            maxWorkerCount: maxWorkerCount, 
            minWorkerCount: minWorkerCount, 
            roleArn: roleArn, 
            tags: tags
        )
        return try await self.createFleet(input, logger: logger)
    }

    /// Creates a job. A job is a set of instructions that AWS Deadline Cloud uses to schedule and run work on available workers. For more information, see Deadline Cloud jobs.
    @Sendable
    @inlinable
    public func createJob(_ input: CreateJobRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> CreateJobResponse {
        try await self.client.execute(
            operation: "CreateJob", 
            path: "/2023-10-12/farms/{farmId}/queues/{queueId}/jobs", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            hostPrefix: "management.", 
            logger: logger
        )
    }
    /// Creates a job. A job is a set of instructions that AWS Deadline Cloud uses to schedule and run work on available workers. For more information, see Deadline Cloud jobs.
    ///
    /// Parameters:
    ///   - attachments: The attachments for the job. Attach files required for the job to run to a render job.
    ///   - clientToken: The unique token which the server uses to recognize retries of the same request.
    ///   - farmId: The farm ID of the farm to connect to the job.
    ///   - maxFailedTasksCount: The number of task failures before the job stops running and is marked as FAILED.
    ///   - maxRetriesPerTask: The maximum number of retries for each task.
    ///   - parameters: The parameters for the job.
    ///   - priority: The priority of the job on a scale of 0 to 100. The highest priority (first scheduled) is 100. When two jobs have the same priority, the oldest job is scheduled first.
    ///   - queueId: The ID of the queue that the job is submitted to.
    ///   - sourceJobId: The job ID for the source job.
    ///   - storageProfileId: The storage profile ID for the storage profile to connect to the job.
    ///   - targetTaskRunStatus: The initial job status when it is created. Jobs that are created with a SUSPENDED status will not run until manually requeued.
    ///   - template: The job template to use for this job.
    ///   - templateType: The file type for the job template.
    ///   - logger: Logger use during operation
    @inlinable
    public func createJob(
        attachments: Attachments? = nil,
        clientToken: String? = CreateJobRequest.idempotencyToken(),
        farmId: String,
        maxFailedTasksCount: Int? = nil,
        maxRetriesPerTask: Int? = nil,
        parameters: [String: JobParameter]? = nil,
        priority: Int,
        queueId: String,
        sourceJobId: String? = nil,
        storageProfileId: String? = nil,
        targetTaskRunStatus: CreateJobTargetTaskRunStatus? = nil,
        template: String? = nil,
        templateType: JobTemplateType? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> CreateJobResponse {
        let input = CreateJobRequest(
            attachments: attachments, 
            clientToken: clientToken, 
            farmId: farmId, 
            maxFailedTasksCount: maxFailedTasksCount, 
            maxRetriesPerTask: maxRetriesPerTask, 
            parameters: parameters, 
            priority: priority, 
            queueId: queueId, 
            sourceJobId: sourceJobId, 
            storageProfileId: storageProfileId, 
            targetTaskRunStatus: targetTaskRunStatus, 
            template: template, 
            templateType: templateType
        )
        return try await self.createJob(input, logger: logger)
    }

    /// Creates a license endpoint to integrate your various licensed software used for rendering on Deadline Cloud.
    @Sendable
    @inlinable
    public func createLicenseEndpoint(_ input: CreateLicenseEndpointRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> CreateLicenseEndpointResponse {
        try await self.client.execute(
            operation: "CreateLicenseEndpoint", 
            path: "/2023-10-12/license-endpoints", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            hostPrefix: "management.", 
            logger: logger
        )
    }
    /// Creates a license endpoint to integrate your various licensed software used for rendering on Deadline Cloud.
    ///
    /// Parameters:
    ///   - clientToken: The unique token which the server uses to recognize retries of the same request.
    ///   - securityGroupIds: The security group IDs.
    ///   - subnetIds: The subnet IDs.
    ///   - tags: Each tag consists of a tag key and a tag value. Tag keys and values are both required, but tag values can be empty strings.
    ///   - vpcId: The VPC (virtual private cloud) ID to use with the license endpoint.
    ///   - logger: Logger use during operation
    @inlinable
    public func createLicenseEndpoint(
        clientToken: String? = CreateLicenseEndpointRequest.idempotencyToken(),
        securityGroupIds: [String],
        subnetIds: [String],
        tags: [String: String]? = nil,
        vpcId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> CreateLicenseEndpointResponse {
        let input = CreateLicenseEndpointRequest(
            clientToken: clientToken, 
            securityGroupIds: securityGroupIds, 
            subnetIds: subnetIds, 
            tags: tags, 
            vpcId: vpcId
        )
        return try await self.createLicenseEndpoint(input, logger: logger)
    }

    /// Creates an Amazon Web Services Deadline Cloud monitor that you can use to view your farms, queues, and fleets. After you submit a job, you can track the progress of the tasks and steps that make up the job, and then download the job's results.
    @Sendable
    @inlinable
    public func createMonitor(_ input: CreateMonitorRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> CreateMonitorResponse {
        try await self.client.execute(
            operation: "CreateMonitor", 
            path: "/2023-10-12/monitors", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            hostPrefix: "management.", 
            logger: logger
        )
    }
    /// Creates an Amazon Web Services Deadline Cloud monitor that you can use to view your farms, queues, and fleets. After you submit a job, you can track the progress of the tasks and steps that make up the job, and then download the job's results.
    ///
    /// Parameters:
    ///   - clientToken: The unique token which the server uses to recognize retries of the same request.
    ///   - displayName: The name that you give the monitor that is displayed in the Deadline Cloud console.  This field can store any content. Escape or encode this content before displaying it on a webpage or any other system that might interpret the content of this field.
    ///   - identityCenterInstanceArn: The Amazon Resource Name (ARN) of the IAM Identity Center instance that authenticates monitor users.
    ///   - roleArn: The Amazon Resource Name (ARN) of the IAM role that the monitor uses to connect to Deadline Cloud. Every user that signs in to the monitor using IAM Identity Center uses this role to access Deadline Cloud resources.
    ///   - subdomain: The subdomain to use when creating the monitor URL. The full URL of the monitor is subdomain.Region.deadlinecloud.amazonaws.com.
    ///   - logger: Logger use during operation
    @inlinable
    public func createMonitor(
        clientToken: String? = CreateMonitorRequest.idempotencyToken(),
        displayName: String,
        identityCenterInstanceArn: String,
        roleArn: String,
        subdomain: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> CreateMonitorResponse {
        let input = CreateMonitorRequest(
            clientToken: clientToken, 
            displayName: displayName, 
            identityCenterInstanceArn: identityCenterInstanceArn, 
            roleArn: roleArn, 
            subdomain: subdomain
        )
        return try await self.createMonitor(input, logger: logger)
    }

    /// Creates a queue to coordinate the order in which jobs run on a farm. A queue can also specify where to pull resources and indicate where to output completed jobs.
    @Sendable
    @inlinable
    public func createQueue(_ input: CreateQueueRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> CreateQueueResponse {
        try await self.client.execute(
            operation: "CreateQueue", 
            path: "/2023-10-12/farms/{farmId}/queues", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            hostPrefix: "management.", 
            logger: logger
        )
    }
    /// Creates a queue to coordinate the order in which jobs run on a farm. A queue can also specify where to pull resources and indicate where to output completed jobs.
    ///
    /// Parameters:
    ///   - allowedStorageProfileIds: The storage profile IDs to include in the queue.
    ///   - clientToken: The unique token which the server uses to recognize retries of the same request.
    ///   - defaultBudgetAction: The default action to take on a queue if a budget isn't configured.
    ///   - description: The description of the queue.  This field can store any content. Escape or encode this content before displaying it on a webpage or any other system that might interpret the content of this field.
    ///   - displayName: The display name of the queue.  This field can store any content. Escape or encode this content before displaying it on a webpage or any other system that might interpret the content of this field.
    ///   - farmId: The farm ID of the farm to connect to the queue.
    ///   - jobAttachmentSettings: The job attachment settings for the queue. These are the Amazon S3 bucket name and the Amazon S3 prefix.
    ///   - jobRunAsUser: The jobs in the queue run as the specified POSIX user.
    ///   - requiredFileSystemLocationNames: The file system location name to include in the queue.
    ///   - roleArn: The IAM role ARN that workers will use while running jobs for this queue.
    ///   - tags: Each tag consists of a tag key and a tag value. Tag keys and values are both required, but tag values can be empty strings.
    ///   - logger: Logger use during operation
    @inlinable
    public func createQueue(
        allowedStorageProfileIds: [String]? = nil,
        clientToken: String? = CreateQueueRequest.idempotencyToken(),
        defaultBudgetAction: DefaultQueueBudgetAction? = nil,
        description: String? = nil,
        displayName: String,
        farmId: String,
        jobAttachmentSettings: JobAttachmentSettings? = nil,
        jobRunAsUser: JobRunAsUser? = nil,
        requiredFileSystemLocationNames: [String]? = nil,
        roleArn: String? = nil,
        tags: [String: String]? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> CreateQueueResponse {
        let input = CreateQueueRequest(
            allowedStorageProfileIds: allowedStorageProfileIds, 
            clientToken: clientToken, 
            defaultBudgetAction: defaultBudgetAction, 
            description: description, 
            displayName: displayName, 
            farmId: farmId, 
            jobAttachmentSettings: jobAttachmentSettings, 
            jobRunAsUser: jobRunAsUser, 
            requiredFileSystemLocationNames: requiredFileSystemLocationNames, 
            roleArn: roleArn, 
            tags: tags
        )
        return try await self.createQueue(input, logger: logger)
    }

    /// Creates an environment for a queue that defines how jobs in the queue run.
    @Sendable
    @inlinable
    public func createQueueEnvironment(_ input: CreateQueueEnvironmentRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> CreateQueueEnvironmentResponse {
        try await self.client.execute(
            operation: "CreateQueueEnvironment", 
            path: "/2023-10-12/farms/{farmId}/queues/{queueId}/environments", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            hostPrefix: "management.", 
            logger: logger
        )
    }
    /// Creates an environment for a queue that defines how jobs in the queue run.
    ///
    /// Parameters:
    ///   - clientToken: The unique token which the server uses to recognize retries of the same request.
    ///   - farmId: The farm ID of the farm to connect to the environment.
    ///   - priority: Sets the priority of the environments in the queue from 0 to 10,000, where 0 is the highest priority. If two environments share the same priority value, the environment created first takes higher priority.
    ///   - queueId: The queue ID to connect the queue and environment.
    ///   - template: The environment template to use in the queue.
    ///   - templateType: The template's file type, JSON or YAML.
    ///   - logger: Logger use during operation
    @inlinable
    public func createQueueEnvironment(
        clientToken: String? = CreateQueueEnvironmentRequest.idempotencyToken(),
        farmId: String,
        priority: Int,
        queueId: String,
        template: String,
        templateType: EnvironmentTemplateType,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> CreateQueueEnvironmentResponse {
        let input = CreateQueueEnvironmentRequest(
            clientToken: clientToken, 
            farmId: farmId, 
            priority: priority, 
            queueId: queueId, 
            template: template, 
            templateType: templateType
        )
        return try await self.createQueueEnvironment(input, logger: logger)
    }

    /// Creates an association between a queue and a fleet.
    @Sendable
    @inlinable
    public func createQueueFleetAssociation(_ input: CreateQueueFleetAssociationRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> CreateQueueFleetAssociationResponse {
        try await self.client.execute(
            operation: "CreateQueueFleetAssociation", 
            path: "/2023-10-12/farms/{farmId}/queue-fleet-associations", 
            httpMethod: .PUT, 
            serviceConfig: self.config, 
            input: input, 
            hostPrefix: "management.", 
            logger: logger
        )
    }
    /// Creates an association between a queue and a fleet.
    ///
    /// Parameters:
    ///   - farmId: The ID of the farm that the queue and fleet belong to.
    ///   - fleetId: The fleet ID.
    ///   - queueId: The queue ID.
    ///   - logger: Logger use during operation
    @inlinable
    public func createQueueFleetAssociation(
        farmId: String,
        fleetId: String,
        queueId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> CreateQueueFleetAssociationResponse {
        let input = CreateQueueFleetAssociationRequest(
            farmId: farmId, 
            fleetId: fleetId, 
            queueId: queueId
        )
        return try await self.createQueueFleetAssociation(input, logger: logger)
    }

    /// Creates a storage profile that specifies the operating system, file type, and file location of resources used on a farm.
    @Sendable
    @inlinable
    public func createStorageProfile(_ input: CreateStorageProfileRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> CreateStorageProfileResponse {
        try await self.client.execute(
            operation: "CreateStorageProfile", 
            path: "/2023-10-12/farms/{farmId}/storage-profiles", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            hostPrefix: "management.", 
            logger: logger
        )
    }
    /// Creates a storage profile that specifies the operating system, file type, and file location of resources used on a farm.
    ///
    /// Parameters:
    ///   - clientToken: The unique token which the server uses to recognize retries of the same request.
    ///   - displayName: The display name of the storage profile.  This field can store any content. Escape or encode this content before displaying it on a webpage or any other system that might interpret the content of this field.
    ///   - farmId: The farm ID of the farm to connect to the storage profile.
    ///   - fileSystemLocations: File system paths to include in the storage profile.
    ///   - osFamily: The type of operating system (OS) for the storage profile.
    ///   - logger: Logger use during operation
    @inlinable
    public func createStorageProfile(
        clientToken: String? = CreateStorageProfileRequest.idempotencyToken(),
        displayName: String,
        farmId: String,
        fileSystemLocations: [FileSystemLocation]? = nil,
        osFamily: StorageProfileOperatingSystemFamily,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> CreateStorageProfileResponse {
        let input = CreateStorageProfileRequest(
            clientToken: clientToken, 
            displayName: displayName, 
            farmId: farmId, 
            fileSystemLocations: fileSystemLocations, 
            osFamily: osFamily
        )
        return try await self.createStorageProfile(input, logger: logger)
    }

    /// Creates a worker. A worker tells your instance how much processing power (vCPU), and memory (GiB) you’ll need to assemble the digital assets held within a particular instance. You can specify certain instance types to use, or let the worker know which instances types to exclude.
    @Sendable
    @inlinable
    public func createWorker(_ input: CreateWorkerRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> CreateWorkerResponse {
        try await self.client.execute(
            operation: "CreateWorker", 
            path: "/2023-10-12/farms/{farmId}/fleets/{fleetId}/workers", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            hostPrefix: "scheduling.", 
            logger: logger
        )
    }
    /// Creates a worker. A worker tells your instance how much processing power (vCPU), and memory (GiB) you’ll need to assemble the digital assets held within a particular instance. You can specify certain instance types to use, or let the worker know which instances types to exclude.
    ///
    /// Parameters:
    ///   - clientToken: The unique token which the server uses to recognize retries of the same request.
    ///   - farmId: The farm ID of the farm to connect to the worker.
    ///   - fleetId: The fleet ID to connect to the worker.
    ///   - hostProperties: The IP address and host name of the worker.
    ///   - logger: Logger use during operation
    @inlinable
    public func createWorker(
        clientToken: String? = CreateWorkerRequest.idempotencyToken(),
        farmId: String,
        fleetId: String,
        hostProperties: HostPropertiesRequest? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> CreateWorkerResponse {
        let input = CreateWorkerRequest(
            clientToken: clientToken, 
            farmId: farmId, 
            fleetId: fleetId, 
            hostProperties: hostProperties
        )
        return try await self.createWorker(input, logger: logger)
    }

    /// Deletes a budget.
    @Sendable
    @inlinable
    public func deleteBudget(_ input: DeleteBudgetRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> DeleteBudgetResponse {
        try await self.client.execute(
            operation: "DeleteBudget", 
            path: "/2023-10-12/farms/{farmId}/budgets/{budgetId}", 
            httpMethod: .DELETE, 
            serviceConfig: self.config, 
            input: input, 
            hostPrefix: "management.", 
            logger: logger
        )
    }
    /// Deletes a budget.
    ///
    /// Parameters:
    ///   - budgetId: The budget ID of the budget to delete.
    ///   - farmId: The farm ID of the farm to remove from the budget.
    ///   - logger: Logger use during operation
    @inlinable
    public func deleteBudget(
        budgetId: String,
        farmId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> DeleteBudgetResponse {
        let input = DeleteBudgetRequest(
            budgetId: budgetId, 
            farmId: farmId
        )
        return try await self.deleteBudget(input, logger: logger)
    }

    /// Deletes a farm.
    @Sendable
    @inlinable
    public func deleteFarm(_ input: DeleteFarmRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> DeleteFarmResponse {
        try await self.client.execute(
            operation: "DeleteFarm", 
            path: "/2023-10-12/farms/{farmId}", 
            httpMethod: .DELETE, 
            serviceConfig: self.config, 
            input: input, 
            hostPrefix: "management.", 
            logger: logger
        )
    }
    /// Deletes a farm.
    ///
    /// Parameters:
    ///   - farmId: The farm ID of the farm to delete.
    ///   - logger: Logger use during operation
    @inlinable
    public func deleteFarm(
        farmId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> DeleteFarmResponse {
        let input = DeleteFarmRequest(
            farmId: farmId
        )
        return try await self.deleteFarm(input, logger: logger)
    }

    /// Deletes a fleet.
    @Sendable
    @inlinable
    public func deleteFleet(_ input: DeleteFleetRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> DeleteFleetResponse {
        try await self.client.execute(
            operation: "DeleteFleet", 
            path: "/2023-10-12/farms/{farmId}/fleets/{fleetId}", 
            httpMethod: .DELETE, 
            serviceConfig: self.config, 
            input: input, 
            hostPrefix: "management.", 
            logger: logger
        )
    }
    /// Deletes a fleet.
    ///
    /// Parameters:
    ///   - clientToken: The unique token which the server uses to recognize retries of the same request.
    ///   - farmId: The farm ID of the farm to remove from the fleet.
    ///   - fleetId: The fleet ID of the fleet to delete.
    ///   - logger: Logger use during operation
    @inlinable
    public func deleteFleet(
        clientToken: String? = DeleteFleetRequest.idempotencyToken(),
        farmId: String,
        fleetId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> DeleteFleetResponse {
        let input = DeleteFleetRequest(
            clientToken: clientToken, 
            farmId: farmId, 
            fleetId: fleetId
        )
        return try await self.deleteFleet(input, logger: logger)
    }

    /// Deletes a license endpoint.
    @Sendable
    @inlinable
    public func deleteLicenseEndpoint(_ input: DeleteLicenseEndpointRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> DeleteLicenseEndpointResponse {
        try await self.client.execute(
            operation: "DeleteLicenseEndpoint", 
            path: "/2023-10-12/license-endpoints/{licenseEndpointId}", 
            httpMethod: .DELETE, 
            serviceConfig: self.config, 
            input: input, 
            hostPrefix: "management.", 
            logger: logger
        )
    }
    /// Deletes a license endpoint.
    ///
    /// Parameters:
    ///   - licenseEndpointId: The license endpoint ID of the license endpoint to delete.
    ///   - logger: Logger use during operation
    @inlinable
    public func deleteLicenseEndpoint(
        licenseEndpointId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> DeleteLicenseEndpointResponse {
        let input = DeleteLicenseEndpointRequest(
            licenseEndpointId: licenseEndpointId
        )
        return try await self.deleteLicenseEndpoint(input, logger: logger)
    }

    /// Deletes a metered product.
    @Sendable
    @inlinable
    public func deleteMeteredProduct(_ input: DeleteMeteredProductRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> DeleteMeteredProductResponse {
        try await self.client.execute(
            operation: "DeleteMeteredProduct", 
            path: "/2023-10-12/license-endpoints/{licenseEndpointId}/metered-products/{productId}", 
            httpMethod: .DELETE, 
            serviceConfig: self.config, 
            input: input, 
            hostPrefix: "management.", 
            logger: logger
        )
    }
    /// Deletes a metered product.
    ///
    /// Parameters:
    ///   - licenseEndpointId: The ID of the license endpoint from which to remove the metered product.
    ///   - productId: The product ID to remove from the license endpoint.
    ///   - logger: Logger use during operation
    @inlinable
    public func deleteMeteredProduct(
        licenseEndpointId: String,
        productId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> DeleteMeteredProductResponse {
        let input = DeleteMeteredProductRequest(
            licenseEndpointId: licenseEndpointId, 
            productId: productId
        )
        return try await self.deleteMeteredProduct(input, logger: logger)
    }

    /// Removes a Deadline Cloud monitor. After you delete a monitor, you can create a new one and attach farms to the monitor.
    @Sendable
    @inlinable
    public func deleteMonitor(_ input: DeleteMonitorRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> DeleteMonitorResponse {
        try await self.client.execute(
            operation: "DeleteMonitor", 
            path: "/2023-10-12/monitors/{monitorId}", 
            httpMethod: .DELETE, 
            serviceConfig: self.config, 
            input: input, 
            hostPrefix: "management.", 
            logger: logger
        )
    }
    /// Removes a Deadline Cloud monitor. After you delete a monitor, you can create a new one and attach farms to the monitor.
    ///
    /// Parameters:
    ///   - monitorId: The unique identifier of the monitor to delete. This ID is returned by the CreateMonitor operation, and is included in the response to the GetMonitor operation.
    ///   - logger: Logger use during operation
    @inlinable
    public func deleteMonitor(
        monitorId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> DeleteMonitorResponse {
        let input = DeleteMonitorRequest(
            monitorId: monitorId
        )
        return try await self.deleteMonitor(input, logger: logger)
    }

    /// Deletes a queue.  You can't recover the jobs in a queue if you delete the queue. Deleting the queue also deletes the jobs in that queue.
    @Sendable
    @inlinable
    public func deleteQueue(_ input: DeleteQueueRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> DeleteQueueResponse {
        try await self.client.execute(
            operation: "DeleteQueue", 
            path: "/2023-10-12/farms/{farmId}/queues/{queueId}", 
            httpMethod: .DELETE, 
            serviceConfig: self.config, 
            input: input, 
            hostPrefix: "management.", 
            logger: logger
        )
    }
    /// Deletes a queue.  You can't recover the jobs in a queue if you delete the queue. Deleting the queue also deletes the jobs in that queue.
    ///
    /// Parameters:
    ///   - farmId: The ID of the farm from which to remove the queue.
    ///   - queueId: The queue ID of the queue to delete.
    ///   - logger: Logger use during operation
    @inlinable
    public func deleteQueue(
        farmId: String,
        queueId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> DeleteQueueResponse {
        let input = DeleteQueueRequest(
            farmId: farmId, 
            queueId: queueId
        )
        return try await self.deleteQueue(input, logger: logger)
    }

    /// Deletes a queue environment.
    @Sendable
    @inlinable
    public func deleteQueueEnvironment(_ input: DeleteQueueEnvironmentRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> DeleteQueueEnvironmentResponse {
        try await self.client.execute(
            operation: "DeleteQueueEnvironment", 
            path: "/2023-10-12/farms/{farmId}/queues/{queueId}/environments/{queueEnvironmentId}", 
            httpMethod: .DELETE, 
            serviceConfig: self.config, 
            input: input, 
            hostPrefix: "management.", 
            logger: logger
        )
    }
    /// Deletes a queue environment.
    ///
    /// Parameters:
    ///   - farmId: The farm ID of the farm from which to remove the queue environment.
    ///   - queueEnvironmentId: The queue environment ID of the queue environment to delete.
    ///   - queueId: The queue ID of the queue environment to delete.
    ///   - logger: Logger use during operation
    @inlinable
    public func deleteQueueEnvironment(
        farmId: String,
        queueEnvironmentId: String,
        queueId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> DeleteQueueEnvironmentResponse {
        let input = DeleteQueueEnvironmentRequest(
            farmId: farmId, 
            queueEnvironmentId: queueEnvironmentId, 
            queueId: queueId
        )
        return try await self.deleteQueueEnvironment(input, logger: logger)
    }

    /// Deletes a queue-fleet association.
    @Sendable
    @inlinable
    public func deleteQueueFleetAssociation(_ input: DeleteQueueFleetAssociationRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> DeleteQueueFleetAssociationResponse {
        try await self.client.execute(
            operation: "DeleteQueueFleetAssociation", 
            path: "/2023-10-12/farms/{farmId}/queue-fleet-associations/{queueId}/{fleetId}", 
            httpMethod: .DELETE, 
            serviceConfig: self.config, 
            input: input, 
            hostPrefix: "management.", 
            logger: logger
        )
    }
    /// Deletes a queue-fleet association.
    ///
    /// Parameters:
    ///   - farmId: The farm ID of the farm that holds the queue-fleet association.
    ///   - fleetId: The fleet ID of the queue-fleet association.
    ///   - queueId: The queue ID of the queue-fleet association.
    ///   - logger: Logger use during operation
    @inlinable
    public func deleteQueueFleetAssociation(
        farmId: String,
        fleetId: String,
        queueId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> DeleteQueueFleetAssociationResponse {
        let input = DeleteQueueFleetAssociationRequest(
            farmId: farmId, 
            fleetId: fleetId, 
            queueId: queueId
        )
        return try await self.deleteQueueFleetAssociation(input, logger: logger)
    }

    /// Deletes a storage profile.
    @Sendable
    @inlinable
    public func deleteStorageProfile(_ input: DeleteStorageProfileRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> DeleteStorageProfileResponse {
        try await self.client.execute(
            operation: "DeleteStorageProfile", 
            path: "/2023-10-12/farms/{farmId}/storage-profiles/{storageProfileId}", 
            httpMethod: .DELETE, 
            serviceConfig: self.config, 
            input: input, 
            hostPrefix: "management.", 
            logger: logger
        )
    }
    /// Deletes a storage profile.
    ///
    /// Parameters:
    ///   - farmId: The farm ID of the farm from which to remove the storage profile.
    ///   - storageProfileId: The storage profile ID of the storage profile to delete.
    ///   - logger: Logger use during operation
    @inlinable
    public func deleteStorageProfile(
        farmId: String,
        storageProfileId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> DeleteStorageProfileResponse {
        let input = DeleteStorageProfileRequest(
            farmId: farmId, 
            storageProfileId: storageProfileId
        )
        return try await self.deleteStorageProfile(input, logger: logger)
    }

    /// Deletes a worker.
    @Sendable
    @inlinable
    public func deleteWorker(_ input: DeleteWorkerRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> DeleteWorkerResponse {
        try await self.client.execute(
            operation: "DeleteWorker", 
            path: "/2023-10-12/farms/{farmId}/fleets/{fleetId}/workers/{workerId}", 
            httpMethod: .DELETE, 
            serviceConfig: self.config, 
            input: input, 
            hostPrefix: "management.", 
            logger: logger
        )
    }
    /// Deletes a worker.
    ///
    /// Parameters:
    ///   - farmId: The farm ID of the worker to delete.
    ///   - fleetId: The fleet ID of the worker to delete.
    ///   - workerId: The worker ID of the worker to delete.
    ///   - logger: Logger use during operation
    @inlinable
    public func deleteWorker(
        farmId: String,
        fleetId: String,
        workerId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> DeleteWorkerResponse {
        let input = DeleteWorkerRequest(
            farmId: farmId, 
            fleetId: fleetId, 
            workerId: workerId
        )
        return try await self.deleteWorker(input, logger: logger)
    }

    /// Disassociates a member from a farm.
    @Sendable
    @inlinable
    public func disassociateMemberFromFarm(_ input: DisassociateMemberFromFarmRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> DisassociateMemberFromFarmResponse {
        try await self.client.execute(
            operation: "DisassociateMemberFromFarm", 
            path: "/2023-10-12/farms/{farmId}/members/{principalId}", 
            httpMethod: .DELETE, 
            serviceConfig: self.config, 
            input: input, 
            hostPrefix: "management.", 
            logger: logger
        )
    }
    /// Disassociates a member from a farm.
    ///
    /// Parameters:
    ///   - farmId: The farm ID of the farm to disassociate from the member.
    ///   - principalId: A member's principal ID to disassociate from a farm.
    ///   - logger: Logger use during operation
    @inlinable
    public func disassociateMemberFromFarm(
        farmId: String,
        principalId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> DisassociateMemberFromFarmResponse {
        let input = DisassociateMemberFromFarmRequest(
            farmId: farmId, 
            principalId: principalId
        )
        return try await self.disassociateMemberFromFarm(input, logger: logger)
    }

    /// Disassociates a member from a fleet.
    @Sendable
    @inlinable
    public func disassociateMemberFromFleet(_ input: DisassociateMemberFromFleetRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> DisassociateMemberFromFleetResponse {
        try await self.client.execute(
            operation: "DisassociateMemberFromFleet", 
            path: "/2023-10-12/farms/{farmId}/fleets/{fleetId}/members/{principalId}", 
            httpMethod: .DELETE, 
            serviceConfig: self.config, 
            input: input, 
            hostPrefix: "management.", 
            logger: logger
        )
    }
    /// Disassociates a member from a fleet.
    ///
    /// Parameters:
    ///   - farmId: The farm ID of the fleet to disassociate a member from.
    ///   - fleetId: The fleet ID of the fleet to from which to disassociate a member.
    ///   - principalId: A member's principal ID to disassociate from a fleet.
    ///   - logger: Logger use during operation
    @inlinable
    public func disassociateMemberFromFleet(
        farmId: String,
        fleetId: String,
        principalId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> DisassociateMemberFromFleetResponse {
        let input = DisassociateMemberFromFleetRequest(
            farmId: farmId, 
            fleetId: fleetId, 
            principalId: principalId
        )
        return try await self.disassociateMemberFromFleet(input, logger: logger)
    }

    /// Disassociates a member from a job.
    @Sendable
    @inlinable
    public func disassociateMemberFromJob(_ input: DisassociateMemberFromJobRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> DisassociateMemberFromJobResponse {
        try await self.client.execute(
            operation: "DisassociateMemberFromJob", 
            path: "/2023-10-12/farms/{farmId}/queues/{queueId}/jobs/{jobId}/members/{principalId}", 
            httpMethod: .DELETE, 
            serviceConfig: self.config, 
            input: input, 
            hostPrefix: "management.", 
            logger: logger
        )
    }
    /// Disassociates a member from a job.
    ///
    /// Parameters:
    ///   - farmId: The farm ID for the job to disassociate from the member.
    ///   - jobId: The job ID to disassociate from a member in a job.
    ///   - principalId: A member's principal ID to disassociate from a job.
    ///   - queueId: The queue ID connected to a job for which you're disassociating a member.
    ///   - logger: Logger use during operation
    @inlinable
    public func disassociateMemberFromJob(
        farmId: String,
        jobId: String,
        principalId: String,
        queueId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> DisassociateMemberFromJobResponse {
        let input = DisassociateMemberFromJobRequest(
            farmId: farmId, 
            jobId: jobId, 
            principalId: principalId, 
            queueId: queueId
        )
        return try await self.disassociateMemberFromJob(input, logger: logger)
    }

    /// Disassociates a member from a queue.
    @Sendable
    @inlinable
    public func disassociateMemberFromQueue(_ input: DisassociateMemberFromQueueRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> DisassociateMemberFromQueueResponse {
        try await self.client.execute(
            operation: "DisassociateMemberFromQueue", 
            path: "/2023-10-12/farms/{farmId}/queues/{queueId}/members/{principalId}", 
            httpMethod: .DELETE, 
            serviceConfig: self.config, 
            input: input, 
            hostPrefix: "management.", 
            logger: logger
        )
    }
    /// Disassociates a member from a queue.
    ///
    /// Parameters:
    ///   - farmId: The farm ID for the queue to disassociate from a member.
    ///   - principalId: A member's principal ID to disassociate from a queue.
    ///   - queueId: The queue ID of the queue in which you're disassociating from a member.
    ///   - logger: Logger use during operation
    @inlinable
    public func disassociateMemberFromQueue(
        farmId: String,
        principalId: String,
        queueId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> DisassociateMemberFromQueueResponse {
        let input = DisassociateMemberFromQueueRequest(
            farmId: farmId, 
            principalId: principalId, 
            queueId: queueId
        )
        return try await self.disassociateMemberFromQueue(input, logger: logger)
    }

    /// Get a budget.
    @Sendable
    @inlinable
    public func getBudget(_ input: GetBudgetRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> GetBudgetResponse {
        try await self.client.execute(
            operation: "GetBudget", 
            path: "/2023-10-12/farms/{farmId}/budgets/{budgetId}", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            hostPrefix: "management.", 
            logger: logger
        )
    }
    /// Get a budget.
    ///
    /// Parameters:
    ///   - budgetId: The budget ID.
    ///   - farmId: The farm ID of the farm connected to the budget.
    ///   - logger: Logger use during operation
    @inlinable
    public func getBudget(
        budgetId: String,
        farmId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> GetBudgetResponse {
        let input = GetBudgetRequest(
            budgetId: budgetId, 
            farmId: farmId
        )
        return try await self.getBudget(input, logger: logger)
    }

    /// Get a farm.
    @Sendable
    @inlinable
    public func getFarm(_ input: GetFarmRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> GetFarmResponse {
        try await self.client.execute(
            operation: "GetFarm", 
            path: "/2023-10-12/farms/{farmId}", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            hostPrefix: "management.", 
            logger: logger
        )
    }
    /// Get a farm.
    ///
    /// Parameters:
    ///   - farmId: The farm ID of the farm.
    ///   - logger: Logger use during operation
    @inlinable
    public func getFarm(
        farmId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> GetFarmResponse {
        let input = GetFarmRequest(
            farmId: farmId
        )
        return try await self.getFarm(input, logger: logger)
    }

    /// Get a fleet.
    @Sendable
    @inlinable
    public func getFleet(_ input: GetFleetRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> GetFleetResponse {
        try await self.client.execute(
            operation: "GetFleet", 
            path: "/2023-10-12/farms/{farmId}/fleets/{fleetId}", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            hostPrefix: "management.", 
            logger: logger
        )
    }
    /// Get a fleet.
    ///
    /// Parameters:
    ///   - farmId: The farm ID of the farm in the fleet.
    ///   - fleetId: The fleet ID of the fleet to get.
    ///   - logger: Logger use during operation
    @inlinable
    public func getFleet(
        farmId: String,
        fleetId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> GetFleetResponse {
        let input = GetFleetRequest(
            farmId: farmId, 
            fleetId: fleetId
        )
        return try await self.getFleet(input, logger: logger)
    }

    /// Gets a Deadline Cloud job.
    @Sendable
    @inlinable
    public func getJob(_ input: GetJobRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> GetJobResponse {
        try await self.client.execute(
            operation: "GetJob", 
            path: "/2023-10-12/farms/{farmId}/queues/{queueId}/jobs/{jobId}", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            hostPrefix: "management.", 
            logger: logger
        )
    }
    /// Gets a Deadline Cloud job.
    ///
    /// Parameters:
    ///   - farmId: The farm ID of the farm in the job.
    ///   - jobId: The job ID.
    ///   - queueId: The queue ID associated with the job.
    ///   - logger: Logger use during operation
    @inlinable
    public func getJob(
        farmId: String,
        jobId: String,
        queueId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> GetJobResponse {
        let input = GetJobRequest(
            farmId: farmId, 
            jobId: jobId, 
            queueId: queueId
        )
        return try await self.getJob(input, logger: logger)
    }

    /// Gets a licence endpoint.
    @Sendable
    @inlinable
    public func getLicenseEndpoint(_ input: GetLicenseEndpointRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> GetLicenseEndpointResponse {
        try await self.client.execute(
            operation: "GetLicenseEndpoint", 
            path: "/2023-10-12/license-endpoints/{licenseEndpointId}", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            hostPrefix: "management.", 
            logger: logger
        )
    }
    /// Gets a licence endpoint.
    ///
    /// Parameters:
    ///   - licenseEndpointId: The license endpoint ID.
    ///   - logger: Logger use during operation
    @inlinable
    public func getLicenseEndpoint(
        licenseEndpointId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> GetLicenseEndpointResponse {
        let input = GetLicenseEndpointRequest(
            licenseEndpointId: licenseEndpointId
        )
        return try await self.getLicenseEndpoint(input, logger: logger)
    }

    /// Gets information about the specified monitor.
    @Sendable
    @inlinable
    public func getMonitor(_ input: GetMonitorRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> GetMonitorResponse {
        try await self.client.execute(
            operation: "GetMonitor", 
            path: "/2023-10-12/monitors/{monitorId}", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            hostPrefix: "management.", 
            logger: logger
        )
    }
    /// Gets information about the specified monitor.
    ///
    /// Parameters:
    ///   - monitorId: The unique identifier for the monitor. This ID is returned by the CreateMonitor operation.
    ///   - logger: Logger use during operation
    @inlinable
    public func getMonitor(
        monitorId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> GetMonitorResponse {
        let input = GetMonitorRequest(
            monitorId: monitorId
        )
        return try await self.getMonitor(input, logger: logger)
    }

    /// Gets a queue.
    @Sendable
    @inlinable
    public func getQueue(_ input: GetQueueRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> GetQueueResponse {
        try await self.client.execute(
            operation: "GetQueue", 
            path: "/2023-10-12/farms/{farmId}/queues/{queueId}", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            hostPrefix: "management.", 
            logger: logger
        )
    }
    /// Gets a queue.
    ///
    /// Parameters:
    ///   - farmId: The farm ID of the farm in the queue.
    ///   - queueId: The queue ID for the queue to retrieve.
    ///   - logger: Logger use during operation
    @inlinable
    public func getQueue(
        farmId: String,
        queueId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> GetQueueResponse {
        let input = GetQueueRequest(
            farmId: farmId, 
            queueId: queueId
        )
        return try await self.getQueue(input, logger: logger)
    }

    /// Gets a queue environment.
    @Sendable
    @inlinable
    public func getQueueEnvironment(_ input: GetQueueEnvironmentRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> GetQueueEnvironmentResponse {
        try await self.client.execute(
            operation: "GetQueueEnvironment", 
            path: "/2023-10-12/farms/{farmId}/queues/{queueId}/environments/{queueEnvironmentId}", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            hostPrefix: "management.", 
            logger: logger
        )
    }
    /// Gets a queue environment.
    ///
    /// Parameters:
    ///   - farmId: The farm ID for the queue environment.
    ///   - queueEnvironmentId: The queue environment ID.
    ///   - queueId: The queue ID for the queue environment.
    ///   - logger: Logger use during operation
    @inlinable
    public func getQueueEnvironment(
        farmId: String,
        queueEnvironmentId: String,
        queueId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> GetQueueEnvironmentResponse {
        let input = GetQueueEnvironmentRequest(
            farmId: farmId, 
            queueEnvironmentId: queueEnvironmentId, 
            queueId: queueId
        )
        return try await self.getQueueEnvironment(input, logger: logger)
    }

    /// Gets a queue-fleet association.
    @Sendable
    @inlinable
    public func getQueueFleetAssociation(_ input: GetQueueFleetAssociationRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> GetQueueFleetAssociationResponse {
        try await self.client.execute(
            operation: "GetQueueFleetAssociation", 
            path: "/2023-10-12/farms/{farmId}/queue-fleet-associations/{queueId}/{fleetId}", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            hostPrefix: "management.", 
            logger: logger
        )
    }
    /// Gets a queue-fleet association.
    ///
    /// Parameters:
    ///   - farmId: The farm ID of the farm that contains the queue-fleet association.
    ///   - fleetId: The fleet ID for the queue-fleet association.
    ///   - queueId: The queue ID for the queue-fleet association.
    ///   - logger: Logger use during operation
    @inlinable
    public func getQueueFleetAssociation(
        farmId: String,
        fleetId: String,
        queueId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> GetQueueFleetAssociationResponse {
        let input = GetQueueFleetAssociationRequest(
            farmId: farmId, 
            fleetId: fleetId, 
            queueId: queueId
        )
        return try await self.getQueueFleetAssociation(input, logger: logger)
    }

    /// Gets a session.
    @Sendable
    @inlinable
    public func getSession(_ input: GetSessionRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> GetSessionResponse {
        try await self.client.execute(
            operation: "GetSession", 
            path: "/2023-10-12/farms/{farmId}/queues/{queueId}/jobs/{jobId}/sessions/{sessionId}", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            hostPrefix: "management.", 
            logger: logger
        )
    }
    /// Gets a session.
    ///
    /// Parameters:
    ///   - farmId: The farm ID for the session.
    ///   - jobId: The job ID for the session.
    ///   - queueId: The queue ID for the session.
    ///   - sessionId: The session ID.
    ///   - logger: Logger use during operation
    @inlinable
    public func getSession(
        farmId: String,
        jobId: String,
        queueId: String,
        sessionId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> GetSessionResponse {
        let input = GetSessionRequest(
            farmId: farmId, 
            jobId: jobId, 
            queueId: queueId, 
            sessionId: sessionId
        )
        return try await self.getSession(input, logger: logger)
    }

    /// Gets a session action for the job.
    @Sendable
    @inlinable
    public func getSessionAction(_ input: GetSessionActionRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> GetSessionActionResponse {
        try await self.client.execute(
            operation: "GetSessionAction", 
            path: "/2023-10-12/farms/{farmId}/queues/{queueId}/jobs/{jobId}/session-actions/{sessionActionId}", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            hostPrefix: "management.", 
            logger: logger
        )
    }
    /// Gets a session action for the job.
    ///
    /// Parameters:
    ///   - farmId: The farm ID for the session action.
    ///   - jobId: The job ID for the session.
    ///   - queueId: The queue ID for the session action.
    ///   - sessionActionId: The session action ID for the session.
    ///   - logger: Logger use during operation
    @inlinable
    public func getSessionAction(
        farmId: String,
        jobId: String,
        queueId: String,
        sessionActionId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> GetSessionActionResponse {
        let input = GetSessionActionRequest(
            farmId: farmId, 
            jobId: jobId, 
            queueId: queueId, 
            sessionActionId: sessionActionId
        )
        return try await self.getSessionAction(input, logger: logger)
    }

    /// Gets a set of statistics for queues or farms. Before you can call the GetSessionStatisticsAggregation operation, you must first call the StartSessionsStatisticsAggregation operation. Statistics are available for 1 hour after you call the StartSessionsStatisticsAggregation operation.
    @Sendable
    @inlinable
    public func getSessionsStatisticsAggregation(_ input: GetSessionsStatisticsAggregationRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> GetSessionsStatisticsAggregationResponse {
        try await self.client.execute(
            operation: "GetSessionsStatisticsAggregation", 
            path: "/2023-10-12/farms/{farmId}/sessions-statistics-aggregation", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            hostPrefix: "management.", 
            logger: logger
        )
    }
    /// Gets a set of statistics for queues or farms. Before you can call the GetSessionStatisticsAggregation operation, you must first call the StartSessionsStatisticsAggregation operation. Statistics are available for 1 hour after you call the StartSessionsStatisticsAggregation operation.
    ///
    /// Parameters:
    ///   - aggregationId: The identifier returned by the StartSessionsStatisticsAggregation operation that identifies the aggregated statistics.
    ///   - farmId: The identifier of the farm to include in the statistics. This should be the same as the farm ID used in the call to the StartSessionsStatisticsAggregation operation.
    ///   - maxResults: The maximum number of results to return. Use this parameter with NextToken to get results as a set of sequential pages.
    ///   - nextToken: The token for the next set of results, or null to start from the beginning.
    ///   - logger: Logger use during operation
    @inlinable
    public func getSessionsStatisticsAggregation(
        aggregationId: String,
        farmId: String,
        maxResults: Int? = nil,
        nextToken: String? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> GetSessionsStatisticsAggregationResponse {
        let input = GetSessionsStatisticsAggregationRequest(
            aggregationId: aggregationId, 
            farmId: farmId, 
            maxResults: maxResults, 
            nextToken: nextToken
        )
        return try await self.getSessionsStatisticsAggregation(input, logger: logger)
    }

    /// Gets a step.
    @Sendable
    @inlinable
    public func getStep(_ input: GetStepRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> GetStepResponse {
        try await self.client.execute(
            operation: "GetStep", 
            path: "/2023-10-12/farms/{farmId}/queues/{queueId}/jobs/{jobId}/steps/{stepId}", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            hostPrefix: "management.", 
            logger: logger
        )
    }
    /// Gets a step.
    ///
    /// Parameters:
    ///   - farmId: The farm ID for the step.
    ///   - jobId: The job ID for the step.
    ///   - queueId: The queue ID for the step.
    ///   - stepId: The step ID.
    ///   - logger: Logger use during operation
    @inlinable
    public func getStep(
        farmId: String,
        jobId: String,
        queueId: String,
        stepId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> GetStepResponse {
        let input = GetStepRequest(
            farmId: farmId, 
            jobId: jobId, 
            queueId: queueId, 
            stepId: stepId
        )
        return try await self.getStep(input, logger: logger)
    }

    /// Gets a storage profile.
    @Sendable
    @inlinable
    public func getStorageProfile(_ input: GetStorageProfileRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> GetStorageProfileResponse {
        try await self.client.execute(
            operation: "GetStorageProfile", 
            path: "/2023-10-12/farms/{farmId}/storage-profiles/{storageProfileId}", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            hostPrefix: "management.", 
            logger: logger
        )
    }
    /// Gets a storage profile.
    ///
    /// Parameters:
    ///   - farmId: The farm ID for the storage profile.
    ///   - storageProfileId: The storage profile ID.
    ///   - logger: Logger use during operation
    @inlinable
    public func getStorageProfile(
        farmId: String,
        storageProfileId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> GetStorageProfileResponse {
        let input = GetStorageProfileRequest(
            farmId: farmId, 
            storageProfileId: storageProfileId
        )
        return try await self.getStorageProfile(input, logger: logger)
    }

    /// Gets a storage profile for a queue.
    @Sendable
    @inlinable
    public func getStorageProfileForQueue(_ input: GetStorageProfileForQueueRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> GetStorageProfileForQueueResponse {
        try await self.client.execute(
            operation: "GetStorageProfileForQueue", 
            path: "/2023-10-12/farms/{farmId}/queues/{queueId}/storage-profiles/{storageProfileId}", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            hostPrefix: "management.", 
            logger: logger
        )
    }
    /// Gets a storage profile for a queue.
    ///
    /// Parameters:
    ///   - farmId: The farm ID for the queue in storage profile.
    ///   - queueId: The queue ID the queue in the storage profile.
    ///   - storageProfileId: The storage profile ID for the storage profile in the queue.
    ///   - logger: Logger use during operation
    @inlinable
    public func getStorageProfileForQueue(
        farmId: String,
        queueId: String,
        storageProfileId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> GetStorageProfileForQueueResponse {
        let input = GetStorageProfileForQueueRequest(
            farmId: farmId, 
            queueId: queueId, 
            storageProfileId: storageProfileId
        )
        return try await self.getStorageProfileForQueue(input, logger: logger)
    }

    /// Gets a task.
    @Sendable
    @inlinable
    public func getTask(_ input: GetTaskRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> GetTaskResponse {
        try await self.client.execute(
            operation: "GetTask", 
            path: "/2023-10-12/farms/{farmId}/queues/{queueId}/jobs/{jobId}/steps/{stepId}/tasks/{taskId}", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            hostPrefix: "management.", 
            logger: logger
        )
    }
    /// Gets a task.
    ///
    /// Parameters:
    ///   - farmId: The farm ID of the farm connected to the task.
    ///   - jobId: The job ID of the job connected to the task.
    ///   - queueId: The queue ID for the queue connected to the task.
    ///   - stepId: The step ID for the step connected to the task.
    ///   - taskId: The task ID.
    ///   - logger: Logger use during operation
    @inlinable
    public func getTask(
        farmId: String,
        jobId: String,
        queueId: String,
        stepId: String,
        taskId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> GetTaskResponse {
        let input = GetTaskRequest(
            farmId: farmId, 
            jobId: jobId, 
            queueId: queueId, 
            stepId: stepId, 
            taskId: taskId
        )
        return try await self.getTask(input, logger: logger)
    }

    /// Gets a worker.
    @Sendable
    @inlinable
    public func getWorker(_ input: GetWorkerRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> GetWorkerResponse {
        try await self.client.execute(
            operation: "GetWorker", 
            path: "/2023-10-12/farms/{farmId}/fleets/{fleetId}/workers/{workerId}", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            hostPrefix: "management.", 
            logger: logger
        )
    }
    /// Gets a worker.
    ///
    /// Parameters:
    ///   - farmId: The farm ID for the worker.
    ///   - fleetId: The fleet ID of the worker.
    ///   - workerId: The worker ID.
    ///   - logger: Logger use during operation
    @inlinable
    public func getWorker(
        farmId: String,
        fleetId: String,
        workerId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> GetWorkerResponse {
        let input = GetWorkerRequest(
            farmId: farmId, 
            fleetId: fleetId, 
            workerId: workerId
        )
        return try await self.getWorker(input, logger: logger)
    }

    /// A list of the available metered products.
    @Sendable
    @inlinable
    public func listAvailableMeteredProducts(_ input: ListAvailableMeteredProductsRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> ListAvailableMeteredProductsResponse {
        try await self.client.execute(
            operation: "ListAvailableMeteredProducts", 
            path: "/2023-10-12/metered-products", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            hostPrefix: "management.", 
            logger: logger
        )
    }
    /// A list of the available metered products.
    ///
    /// Parameters:
    ///   - maxResults: The maximum number of results to return. Use this parameter with NextToken to get results as a set of sequential pages.
    ///   - nextToken: The token for the next set of results, or null to start from the beginning.
    ///   - logger: Logger use during operation
    @inlinable
    public func listAvailableMeteredProducts(
        maxResults: Int? = nil,
        nextToken: String? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ListAvailableMeteredProductsResponse {
        let input = ListAvailableMeteredProductsRequest(
            maxResults: maxResults, 
            nextToken: nextToken
        )
        return try await self.listAvailableMeteredProducts(input, logger: logger)
    }

    /// A list of budgets in a farm.
    @Sendable
    @inlinable
    public func listBudgets(_ input: ListBudgetsRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> ListBudgetsResponse {
        try await self.client.execute(
            operation: "ListBudgets", 
            path: "/2023-10-12/farms/{farmId}/budgets", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            hostPrefix: "management.", 
            logger: logger
        )
    }
    /// A list of budgets in a farm.
    ///
    /// Parameters:
    ///   - farmId: The farm ID associated with the budgets.
    ///   - maxResults: The maximum number of results to return. Use this parameter with NextToken to get results as a set of sequential pages.
    ///   - nextToken: The token for the next set of results, or null to start from the beginning.
    ///   - status: The status to list for the budgets.
    ///   - logger: Logger use during operation
    @inlinable
    public func listBudgets(
        farmId: String,
        maxResults: Int? = nil,
        nextToken: String? = nil,
        status: BudgetStatus? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ListBudgetsResponse {
        let input = ListBudgetsRequest(
            farmId: farmId, 
            maxResults: maxResults, 
            nextToken: nextToken, 
            status: status
        )
        return try await self.listBudgets(input, logger: logger)
    }

    /// Lists the members of a farm.
    @Sendable
    @inlinable
    public func listFarmMembers(_ input: ListFarmMembersRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> ListFarmMembersResponse {
        try await self.client.execute(
            operation: "ListFarmMembers", 
            path: "/2023-10-12/farms/{farmId}/members", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            hostPrefix: "management.", 
            logger: logger
        )
    }
    /// Lists the members of a farm.
    ///
    /// Parameters:
    ///   - farmId: The farm ID.
    ///   - maxResults: The maximum number of results to return. Use this parameter with NextToken to get results as a set of sequential pages.
    ///   - nextToken: The token for the next set of results, or null to start from the beginning.
    ///   - logger: Logger use during operation
    @inlinable
    public func listFarmMembers(
        farmId: String,
        maxResults: Int? = nil,
        nextToken: String? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ListFarmMembersResponse {
        let input = ListFarmMembersRequest(
            farmId: farmId, 
            maxResults: maxResults, 
            nextToken: nextToken
        )
        return try await self.listFarmMembers(input, logger: logger)
    }

    /// Lists farms.
    @Sendable
    @inlinable
    public func listFarms(_ input: ListFarmsRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> ListFarmsResponse {
        try await self.client.execute(
            operation: "ListFarms", 
            path: "/2023-10-12/farms", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            hostPrefix: "management.", 
            logger: logger
        )
    }
    /// Lists farms.
    ///
    /// Parameters:
    ///   - maxResults: The maximum number of results to return. Use this parameter with NextToken to get results as a set of sequential pages.
    ///   - nextToken: The token for the next set of results, or null to start from the beginning.
    ///   - principalId: The principal ID of the member to list on the farm.
    ///   - logger: Logger use during operation
    @inlinable
    public func listFarms(
        maxResults: Int? = nil,
        nextToken: String? = nil,
        principalId: String? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ListFarmsResponse {
        let input = ListFarmsRequest(
            maxResults: maxResults, 
            nextToken: nextToken, 
            principalId: principalId
        )
        return try await self.listFarms(input, logger: logger)
    }

    /// Lists fleet members.
    @Sendable
    @inlinable
    public func listFleetMembers(_ input: ListFleetMembersRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> ListFleetMembersResponse {
        try await self.client.execute(
            operation: "ListFleetMembers", 
            path: "/2023-10-12/farms/{farmId}/fleets/{fleetId}/members", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            hostPrefix: "management.", 
            logger: logger
        )
    }
    /// Lists fleet members.
    ///
    /// Parameters:
    ///   - farmId: The farm ID of the fleet.
    ///   - fleetId: The fleet ID to include on the list.
    ///   - maxResults: The maximum number of results to return. Use this parameter with NextToken to get results as a set of sequential pages.
    ///   - nextToken: The token for the next set of results, or null to start from the beginning.
    ///   - logger: Logger use during operation
    @inlinable
    public func listFleetMembers(
        farmId: String,
        fleetId: String,
        maxResults: Int? = nil,
        nextToken: String? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ListFleetMembersResponse {
        let input = ListFleetMembersRequest(
            farmId: farmId, 
            fleetId: fleetId, 
            maxResults: maxResults, 
            nextToken: nextToken
        )
        return try await self.listFleetMembers(input, logger: logger)
    }

    /// Lists fleets.
    @Sendable
    @inlinable
    public func listFleets(_ input: ListFleetsRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> ListFleetsResponse {
        try await self.client.execute(
            operation: "ListFleets", 
            path: "/2023-10-12/farms/{farmId}/fleets", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            hostPrefix: "management.", 
            logger: logger
        )
    }
    /// Lists fleets.
    ///
    /// Parameters:
    ///   - displayName: The display names of a list of fleets.  This field can store any content. Escape or encode this content before displaying it on a webpage or any other system that might interpret the content of this field.
    ///   - farmId: The farm ID of the fleets.
    ///   - maxResults: The maximum number of results to return. Use this parameter with NextToken to get results as a set of sequential pages.
    ///   - nextToken: The token for the next set of results, or null to start from the beginning.
    ///   - principalId: The principal ID of the members to include in the fleet.
    ///   - status: The status of the fleet.
    ///   - logger: Logger use during operation
    @inlinable
    public func listFleets(
        displayName: String? = nil,
        farmId: String,
        maxResults: Int? = nil,
        nextToken: String? = nil,
        principalId: String? = nil,
        status: FleetStatus? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ListFleetsResponse {
        let input = ListFleetsRequest(
            displayName: displayName, 
            farmId: farmId, 
            maxResults: maxResults, 
            nextToken: nextToken, 
            principalId: principalId, 
            status: status
        )
        return try await self.listFleets(input, logger: logger)
    }

    /// Lists members on a job.
    @Sendable
    @inlinable
    public func listJobMembers(_ input: ListJobMembersRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> ListJobMembersResponse {
        try await self.client.execute(
            operation: "ListJobMembers", 
            path: "/2023-10-12/farms/{farmId}/queues/{queueId}/jobs/{jobId}/members", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            hostPrefix: "management.", 
            logger: logger
        )
    }
    /// Lists members on a job.
    ///
    /// Parameters:
    ///   - farmId: The farm ID of the job to list.
    ///   - jobId: The job ID to include on the list.
    ///   - maxResults: The maximum number of results to return. Use this parameter with NextToken to get results as a set of sequential pages.
    ///   - nextToken: The token for the next set of results, or null to start from the beginning.
    ///   - queueId: The queue ID to include on the list.
    ///   - logger: Logger use during operation
    @inlinable
    public func listJobMembers(
        farmId: String,
        jobId: String,
        maxResults: Int? = nil,
        nextToken: String? = nil,
        queueId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ListJobMembersResponse {
        let input = ListJobMembersRequest(
            farmId: farmId, 
            jobId: jobId, 
            maxResults: maxResults, 
            nextToken: nextToken, 
            queueId: queueId
        )
        return try await self.listJobMembers(input, logger: logger)
    }

    /// Lists parameter definitions of a job.
    @Sendable
    @inlinable
    public func listJobParameterDefinitions(_ input: ListJobParameterDefinitionsRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> ListJobParameterDefinitionsResponse {
        try await self.client.execute(
            operation: "ListJobParameterDefinitions", 
            path: "/2023-10-12/farms/{farmId}/queues/{queueId}/jobs/{jobId}/parameter-definitions", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            hostPrefix: "management.", 
            logger: logger
        )
    }
    /// Lists parameter definitions of a job.
    ///
    /// Parameters:
    ///   - farmId: The farm ID of the job to list.
    ///   - jobId: The job ID to include on the list.
    ///   - maxResults: The maximum number of results to return. Use this parameter with NextToken to get results as a set of sequential pages.
    ///   - nextToken: The token for the next set of results, or null to start from the beginning.
    ///   - queueId: The queue ID to include on the list.
    ///   - logger: Logger use during operation
    @inlinable
    public func listJobParameterDefinitions(
        farmId: String,
        jobId: String,
        maxResults: Int? = nil,
        nextToken: String? = nil,
        queueId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ListJobParameterDefinitionsResponse {
        let input = ListJobParameterDefinitionsRequest(
            farmId: farmId, 
            jobId: jobId, 
            maxResults: maxResults, 
            nextToken: nextToken, 
            queueId: queueId
        )
        return try await self.listJobParameterDefinitions(input, logger: logger)
    }

    /// Lists jobs.
    @Sendable
    @inlinable
    public func listJobs(_ input: ListJobsRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> ListJobsResponse {
        try await self.client.execute(
            operation: "ListJobs", 
            path: "/2023-10-12/farms/{farmId}/queues/{queueId}/jobs", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            hostPrefix: "management.", 
            logger: logger
        )
    }
    /// Lists jobs.
    ///
    /// Parameters:
    ///   - farmId: The farm ID for the jobs.
    ///   - maxResults: The maximum number of results to return. Use this parameter with NextToken to get results as a set of sequential pages.
    ///   - nextToken: The token for the next set of results, or null to start from the beginning.
    ///   - principalId: The principal ID of the members on the jobs.
    ///   - queueId: The queue ID for the job.
    ///   - logger: Logger use during operation
    @inlinable
    public func listJobs(
        farmId: String,
        maxResults: Int? = nil,
        nextToken: String? = nil,
        principalId: String? = nil,
        queueId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ListJobsResponse {
        let input = ListJobsRequest(
            farmId: farmId, 
            maxResults: maxResults, 
            nextToken: nextToken, 
            principalId: principalId, 
            queueId: queueId
        )
        return try await self.listJobs(input, logger: logger)
    }

    /// Lists license endpoints.
    @Sendable
    @inlinable
    public func listLicenseEndpoints(_ input: ListLicenseEndpointsRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> ListLicenseEndpointsResponse {
        try await self.client.execute(
            operation: "ListLicenseEndpoints", 
            path: "/2023-10-12/license-endpoints", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            hostPrefix: "management.", 
            logger: logger
        )
    }
    /// Lists license endpoints.
    ///
    /// Parameters:
    ///   - maxResults: The maximum number of results to return. Use this parameter with NextToken to get results as a set of sequential pages.
    ///   - nextToken: The token for the next set of results, or null to start from the beginning.
    ///   - logger: Logger use during operation
    @inlinable
    public func listLicenseEndpoints(
        maxResults: Int? = nil,
        nextToken: String? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ListLicenseEndpointsResponse {
        let input = ListLicenseEndpointsRequest(
            maxResults: maxResults, 
            nextToken: nextToken
        )
        return try await self.listLicenseEndpoints(input, logger: logger)
    }

    /// Lists metered products.
    @Sendable
    @inlinable
    public func listMeteredProducts(_ input: ListMeteredProductsRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> ListMeteredProductsResponse {
        try await self.client.execute(
            operation: "ListMeteredProducts", 
            path: "/2023-10-12/license-endpoints/{licenseEndpointId}/metered-products", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            hostPrefix: "management.", 
            logger: logger
        )
    }
    /// Lists metered products.
    ///
    /// Parameters:
    ///   - licenseEndpointId: The license endpoint ID to include on the list of metered products.
    ///   - maxResults: The maximum number of results to return. Use this parameter with NextToken to get results as a set of sequential pages.
    ///   - nextToken: The token for the next set of results, or null to start from the beginning.
    ///   - logger: Logger use during operation
    @inlinable
    public func listMeteredProducts(
        licenseEndpointId: String,
        maxResults: Int? = nil,
        nextToken: String? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ListMeteredProductsResponse {
        let input = ListMeteredProductsRequest(
            licenseEndpointId: licenseEndpointId, 
            maxResults: maxResults, 
            nextToken: nextToken
        )
        return try await self.listMeteredProducts(input, logger: logger)
    }

    /// Gets a list of your monitors in Deadline Cloud.
    @Sendable
    @inlinable
    public func listMonitors(_ input: ListMonitorsRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> ListMonitorsResponse {
        try await self.client.execute(
            operation: "ListMonitors", 
            path: "/2023-10-12/monitors", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            hostPrefix: "management.", 
            logger: logger
        )
    }
    /// Gets a list of your monitors in Deadline Cloud.
    ///
    /// Parameters:
    ///   - maxResults: The maximum number of results to return. Use this parameter with NextToken to get results as a set of sequential pages.
    ///   - nextToken: The token for the next set of results, or null to start from the beginning.
    ///   - logger: Logger use during operation
    @inlinable
    public func listMonitors(
        maxResults: Int? = nil,
        nextToken: String? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ListMonitorsResponse {
        let input = ListMonitorsRequest(
            maxResults: maxResults, 
            nextToken: nextToken
        )
        return try await self.listMonitors(input, logger: logger)
    }

    /// Lists queue environments.
    @Sendable
    @inlinable
    public func listQueueEnvironments(_ input: ListQueueEnvironmentsRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> ListQueueEnvironmentsResponse {
        try await self.client.execute(
            operation: "ListQueueEnvironments", 
            path: "/2023-10-12/farms/{farmId}/queues/{queueId}/environments", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            hostPrefix: "management.", 
            logger: logger
        )
    }
    /// Lists queue environments.
    ///
    /// Parameters:
    ///   - farmId: The farm ID for the queue environment list.
    ///   - maxResults: The maximum number of results to return. Use this parameter with NextToken to get results as a set of sequential pages.
    ///   - nextToken: The token for the next set of results, or null to start from the beginning.
    ///   - queueId: The queue ID for the queue environment list.
    ///   - logger: Logger use during operation
    @inlinable
    public func listQueueEnvironments(
        farmId: String,
        maxResults: Int? = nil,
        nextToken: String? = nil,
        queueId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ListQueueEnvironmentsResponse {
        let input = ListQueueEnvironmentsRequest(
            farmId: farmId, 
            maxResults: maxResults, 
            nextToken: nextToken, 
            queueId: queueId
        )
        return try await self.listQueueEnvironments(input, logger: logger)
    }

    /// Lists queue-fleet associations.
    @Sendable
    @inlinable
    public func listQueueFleetAssociations(_ input: ListQueueFleetAssociationsRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> ListQueueFleetAssociationsResponse {
        try await self.client.execute(
            operation: "ListQueueFleetAssociations", 
            path: "/2023-10-12/farms/{farmId}/queue-fleet-associations", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            hostPrefix: "management.", 
            logger: logger
        )
    }
    /// Lists queue-fleet associations.
    ///
    /// Parameters:
    ///   - farmId: The farm ID for the queue-fleet association list.
    ///   - fleetId: The fleet ID for the queue-fleet association list.
    ///   - maxResults: The maximum number of results to return. Use this parameter with NextToken to get results as a set of sequential pages.
    ///   - nextToken: The token for the next set of results, or null to start from the beginning.
    ///   - queueId: The queue ID for the queue-fleet association list.
    ///   - logger: Logger use during operation
    @inlinable
    public func listQueueFleetAssociations(
        farmId: String,
        fleetId: String? = nil,
        maxResults: Int? = nil,
        nextToken: String? = nil,
        queueId: String? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ListQueueFleetAssociationsResponse {
        let input = ListQueueFleetAssociationsRequest(
            farmId: farmId, 
            fleetId: fleetId, 
            maxResults: maxResults, 
            nextToken: nextToken, 
            queueId: queueId
        )
        return try await self.listQueueFleetAssociations(input, logger: logger)
    }

    /// Lists the members in a queue.
    @Sendable
    @inlinable
    public func listQueueMembers(_ input: ListQueueMembersRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> ListQueueMembersResponse {
        try await self.client.execute(
            operation: "ListQueueMembers", 
            path: "/2023-10-12/farms/{farmId}/queues/{queueId}/members", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            hostPrefix: "management.", 
            logger: logger
        )
    }
    /// Lists the members in a queue.
    ///
    /// Parameters:
    ///   - farmId: The farm ID for the queue.
    ///   - maxResults: The maximum number of results to return. Use this parameter with NextToken to get results as a set of sequential pages.
    ///   - nextToken: The token for the next set of results, or null to start from the beginning.
    ///   - queueId: The queue ID to include on the list.
    ///   - logger: Logger use during operation
    @inlinable
    public func listQueueMembers(
        farmId: String,
        maxResults: Int? = nil,
        nextToken: String? = nil,
        queueId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ListQueueMembersResponse {
        let input = ListQueueMembersRequest(
            farmId: farmId, 
            maxResults: maxResults, 
            nextToken: nextToken, 
            queueId: queueId
        )
        return try await self.listQueueMembers(input, logger: logger)
    }

    /// Lists queues.
    @Sendable
    @inlinable
    public func listQueues(_ input: ListQueuesRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> ListQueuesResponse {
        try await self.client.execute(
            operation: "ListQueues", 
            path: "/2023-10-12/farms/{farmId}/queues", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            hostPrefix: "management.", 
            logger: logger
        )
    }
    /// Lists queues.
    ///
    /// Parameters:
    ///   - farmId: The farm ID of the queue.
    ///   - maxResults: The maximum number of results to return. Use this parameter with NextToken to get results as a set of sequential pages.
    ///   - nextToken: The token for the next set of results, or null to start from the beginning.
    ///   - principalId: The principal IDs to include in the list of queues.
    ///   - status: The status of the queues listed.    ACTIVE–The queues are active.    SCHEDULING–The queues are scheduling.    SCHEDULING_BLOCKED–The queue scheduling is blocked for these queues.
    ///   - logger: Logger use during operation
    @inlinable
    public func listQueues(
        farmId: String,
        maxResults: Int? = nil,
        nextToken: String? = nil,
        principalId: String? = nil,
        status: QueueStatus? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ListQueuesResponse {
        let input = ListQueuesRequest(
            farmId: farmId, 
            maxResults: maxResults, 
            nextToken: nextToken, 
            principalId: principalId, 
            status: status
        )
        return try await self.listQueues(input, logger: logger)
    }

    /// Lists session actions.
    @Sendable
    @inlinable
    public func listSessionActions(_ input: ListSessionActionsRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> ListSessionActionsResponse {
        try await self.client.execute(
            operation: "ListSessionActions", 
            path: "/2023-10-12/farms/{farmId}/queues/{queueId}/jobs/{jobId}/session-actions", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            hostPrefix: "management.", 
            logger: logger
        )
    }
    /// Lists session actions.
    ///
    /// Parameters:
    ///   - farmId: The farm ID for the session actions list.
    ///   - jobId: The job ID for the session actions list.
    ///   - maxResults: The maximum number of results to return. Use this parameter with NextToken to get results as a set of sequential pages.
    ///   - nextToken: The token for the next set of results, or null to start from the beginning.
    ///   - queueId: The queue ID for the session actions list.
    ///   - sessionId: The session ID to include on the sessions action list.
    ///   - taskId: The task ID for the session actions list.
    ///   - logger: Logger use during operation
    @inlinable
    public func listSessionActions(
        farmId: String,
        jobId: String,
        maxResults: Int? = nil,
        nextToken: String? = nil,
        queueId: String,
        sessionId: String? = nil,
        taskId: String? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ListSessionActionsResponse {
        let input = ListSessionActionsRequest(
            farmId: farmId, 
            jobId: jobId, 
            maxResults: maxResults, 
            nextToken: nextToken, 
            queueId: queueId, 
            sessionId: sessionId, 
            taskId: taskId
        )
        return try await self.listSessionActions(input, logger: logger)
    }

    /// Lists sessions.
    @Sendable
    @inlinable
    public func listSessions(_ input: ListSessionsRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> ListSessionsResponse {
        try await self.client.execute(
            operation: "ListSessions", 
            path: "/2023-10-12/farms/{farmId}/queues/{queueId}/jobs/{jobId}/sessions", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            hostPrefix: "management.", 
            logger: logger
        )
    }
    /// Lists sessions.
    ///
    /// Parameters:
    ///   - farmId: The farm ID for the list of sessions.
    ///   - jobId: The job ID for the list of sessions.
    ///   - maxResults: The maximum number of results to return. Use this parameter with NextToken to get results as a set of sequential pages.
    ///   - nextToken: The token for the next set of results, or null to start from the beginning.
    ///   - queueId: The queue ID for the list of sessions
    ///   - logger: Logger use during operation
    @inlinable
    public func listSessions(
        farmId: String,
        jobId: String,
        maxResults: Int? = nil,
        nextToken: String? = nil,
        queueId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ListSessionsResponse {
        let input = ListSessionsRequest(
            farmId: farmId, 
            jobId: jobId, 
            maxResults: maxResults, 
            nextToken: nextToken, 
            queueId: queueId
        )
        return try await self.listSessions(input, logger: logger)
    }

    /// Lists sessions for a worker.
    @Sendable
    @inlinable
    public func listSessionsForWorker(_ input: ListSessionsForWorkerRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> ListSessionsForWorkerResponse {
        try await self.client.execute(
            operation: "ListSessionsForWorker", 
            path: "/2023-10-12/farms/{farmId}/fleets/{fleetId}/workers/{workerId}/sessions", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            hostPrefix: "management.", 
            logger: logger
        )
    }
    /// Lists sessions for a worker.
    ///
    /// Parameters:
    ///   - farmId: The farm ID for the session.
    ///   - fleetId: The fleet ID for the session.
    ///   - maxResults: The maximum number of results to return. Use this parameter with NextToken to get results as a set of sequential pages.
    ///   - nextToken: The token for the next set of results, or null to start from the beginning.
    ///   - workerId: The worker ID for the session.
    ///   - logger: Logger use during operation
    @inlinable
    public func listSessionsForWorker(
        farmId: String,
        fleetId: String,
        maxResults: Int? = nil,
        nextToken: String? = nil,
        workerId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ListSessionsForWorkerResponse {
        let input = ListSessionsForWorkerRequest(
            farmId: farmId, 
            fleetId: fleetId, 
            maxResults: maxResults, 
            nextToken: nextToken, 
            workerId: workerId
        )
        return try await self.listSessionsForWorker(input, logger: logger)
    }

    /// Lists step consumers.
    @Sendable
    @inlinable
    public func listStepConsumers(_ input: ListStepConsumersRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> ListStepConsumersResponse {
        try await self.client.execute(
            operation: "ListStepConsumers", 
            path: "/2023-10-12/farms/{farmId}/queues/{queueId}/jobs/{jobId}/steps/{stepId}/consumers", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            hostPrefix: "management.", 
            logger: logger
        )
    }
    /// Lists step consumers.
    ///
    /// Parameters:
    ///   - farmId: The farm ID for the list of step consumers.
    ///   - jobId: The job ID for the step consumer.
    ///   - maxResults: The maximum number of results to return. Use this parameter with NextToken to get results as a set of sequential pages.
    ///   - nextToken: The token for the next set of results, or null to start from the beginning.
    ///   - queueId: The queue ID for the step consumer.
    ///   - stepId: The step ID to include on the list.
    ///   - logger: Logger use during operation
    @inlinable
    public func listStepConsumers(
        farmId: String,
        jobId: String,
        maxResults: Int? = nil,
        nextToken: String? = nil,
        queueId: String,
        stepId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ListStepConsumersResponse {
        let input = ListStepConsumersRequest(
            farmId: farmId, 
            jobId: jobId, 
            maxResults: maxResults, 
            nextToken: nextToken, 
            queueId: queueId, 
            stepId: stepId
        )
        return try await self.listStepConsumers(input, logger: logger)
    }

    /// Lists the dependencies for a step.
    @Sendable
    @inlinable
    public func listStepDependencies(_ input: ListStepDependenciesRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> ListStepDependenciesResponse {
        try await self.client.execute(
            operation: "ListStepDependencies", 
            path: "/2023-10-12/farms/{farmId}/queues/{queueId}/jobs/{jobId}/steps/{stepId}/dependencies", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            hostPrefix: "management.", 
            logger: logger
        )
    }
    /// Lists the dependencies for a step.
    ///
    /// Parameters:
    ///   - farmId: The farm ID for the step dependencies list.
    ///   - jobId: The job ID for the step dependencies list.
    ///   - maxResults: The maximum number of results to return. Use this parameter with NextToken to get results as a set of sequential pages.
    ///   - nextToken: The token for the next set of results, or null to start from the beginning.
    ///   - queueId: The queue ID for the step dependencies list.
    ///   - stepId: The step ID to include on the list.
    ///   - logger: Logger use during operation
    @inlinable
    public func listStepDependencies(
        farmId: String,
        jobId: String,
        maxResults: Int? = nil,
        nextToken: String? = nil,
        queueId: String,
        stepId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ListStepDependenciesResponse {
        let input = ListStepDependenciesRequest(
            farmId: farmId, 
            jobId: jobId, 
            maxResults: maxResults, 
            nextToken: nextToken, 
            queueId: queueId, 
            stepId: stepId
        )
        return try await self.listStepDependencies(input, logger: logger)
    }

    /// Lists steps for a job.
    @Sendable
    @inlinable
    public func listSteps(_ input: ListStepsRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> ListStepsResponse {
        try await self.client.execute(
            operation: "ListSteps", 
            path: "/2023-10-12/farms/{farmId}/queues/{queueId}/jobs/{jobId}/steps", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            hostPrefix: "management.", 
            logger: logger
        )
    }
    /// Lists steps for a job.
    ///
    /// Parameters:
    ///   - farmId: The farm ID to include on the list of steps.
    ///   - jobId: The job ID to include on the list of steps.
    ///   - maxResults: The maximum number of results to return. Use this parameter with NextToken to get results as a set of sequential pages.
    ///   - nextToken: The token for the next set of results, or null to start from the beginning.
    ///   - queueId: The queue ID to include on the list of steps.
    ///   - logger: Logger use during operation
    @inlinable
    public func listSteps(
        farmId: String,
        jobId: String,
        maxResults: Int? = nil,
        nextToken: String? = nil,
        queueId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ListStepsResponse {
        let input = ListStepsRequest(
            farmId: farmId, 
            jobId: jobId, 
            maxResults: maxResults, 
            nextToken: nextToken, 
            queueId: queueId
        )
        return try await self.listSteps(input, logger: logger)
    }

    /// Lists storage profiles.
    @Sendable
    @inlinable
    public func listStorageProfiles(_ input: ListStorageProfilesRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> ListStorageProfilesResponse {
        try await self.client.execute(
            operation: "ListStorageProfiles", 
            path: "/2023-10-12/farms/{farmId}/storage-profiles", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            hostPrefix: "management.", 
            logger: logger
        )
    }
    /// Lists storage profiles.
    ///
    /// Parameters:
    ///   - farmId: The farm ID of the storage profile.
    ///   - maxResults: The maximum number of results to return. Use this parameter with NextToken to get results as a set of sequential pages.
    ///   - nextToken: The token for the next set of results, or null to start from the beginning.
    ///   - logger: Logger use during operation
    @inlinable
    public func listStorageProfiles(
        farmId: String,
        maxResults: Int? = nil,
        nextToken: String? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ListStorageProfilesResponse {
        let input = ListStorageProfilesRequest(
            farmId: farmId, 
            maxResults: maxResults, 
            nextToken: nextToken
        )
        return try await self.listStorageProfiles(input, logger: logger)
    }

    /// Lists storage profiles for a queue.
    @Sendable
    @inlinable
    public func listStorageProfilesForQueue(_ input: ListStorageProfilesForQueueRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> ListStorageProfilesForQueueResponse {
        try await self.client.execute(
            operation: "ListStorageProfilesForQueue", 
            path: "/2023-10-12/farms/{farmId}/queues/{queueId}/storage-profiles", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            hostPrefix: "management.", 
            logger: logger
        )
    }
    /// Lists storage profiles for a queue.
    ///
    /// Parameters:
    ///   - farmId: The farm ID of the queue's storage profile.
    ///   - maxResults: The maximum number of results to return. Use this parameter with NextToken to get results as a set of sequential pages.
    ///   - nextToken: The token for the next set of results, or null to start from the beginning.
    ///   - queueId: The queue ID for the storage profile.
    ///   - logger: Logger use during operation
    @inlinable
    public func listStorageProfilesForQueue(
        farmId: String,
        maxResults: Int? = nil,
        nextToken: String? = nil,
        queueId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ListStorageProfilesForQueueResponse {
        let input = ListStorageProfilesForQueueRequest(
            farmId: farmId, 
            maxResults: maxResults, 
            nextToken: nextToken, 
            queueId: queueId
        )
        return try await self.listStorageProfilesForQueue(input, logger: logger)
    }

    /// Lists tags for a resource.
    @Sendable
    @inlinable
    public func listTagsForResource(_ input: ListTagsForResourceRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> ListTagsForResourceResponse {
        try await self.client.execute(
            operation: "ListTagsForResource", 
            path: "/2023-10-12/tags/{resourceArn}", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            hostPrefix: "management.", 
            logger: logger
        )
    }
    /// Lists tags for a resource.
    ///
    /// Parameters:
    ///   - resourceArn: The resource ARN to list tags for.
    ///   - logger: Logger use during operation
    @inlinable
    public func listTagsForResource(
        resourceArn: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ListTagsForResourceResponse {
        let input = ListTagsForResourceRequest(
            resourceArn: resourceArn
        )
        return try await self.listTagsForResource(input, logger: logger)
    }

    /// Lists tasks for a job.
    @Sendable
    @inlinable
    public func listTasks(_ input: ListTasksRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> ListTasksResponse {
        try await self.client.execute(
            operation: "ListTasks", 
            path: "/2023-10-12/farms/{farmId}/queues/{queueId}/jobs/{jobId}/steps/{stepId}/tasks", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            hostPrefix: "management.", 
            logger: logger
        )
    }
    /// Lists tasks for a job.
    ///
    /// Parameters:
    ///   - farmId: The farm ID connected to the tasks.
    ///   - jobId: The job ID for the tasks.
    ///   - maxResults: The maximum number of results to return. Use this parameter with NextToken to get results as a set of sequential pages.
    ///   - nextToken: The token for the next set of results, or null to start from the beginning.
    ///   - queueId: The queue ID connected to the tasks.
    ///   - stepId: The step ID for the tasks.
    ///   - logger: Logger use during operation
    @inlinable
    public func listTasks(
        farmId: String,
        jobId: String,
        maxResults: Int? = nil,
        nextToken: String? = nil,
        queueId: String,
        stepId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ListTasksResponse {
        let input = ListTasksRequest(
            farmId: farmId, 
            jobId: jobId, 
            maxResults: maxResults, 
            nextToken: nextToken, 
            queueId: queueId, 
            stepId: stepId
        )
        return try await self.listTasks(input, logger: logger)
    }

    /// Lists workers.
    @Sendable
    @inlinable
    public func listWorkers(_ input: ListWorkersRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> ListWorkersResponse {
        try await self.client.execute(
            operation: "ListWorkers", 
            path: "/2023-10-12/farms/{farmId}/fleets/{fleetId}/workers", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            hostPrefix: "management.", 
            logger: logger
        )
    }
    /// Lists workers.
    ///
    /// Parameters:
    ///   - farmId: The farm ID connected to the workers.
    ///   - fleetId: The fleet ID of the workers.
    ///   - maxResults: The maximum number of results to return. Use this parameter with NextToken to get results as a set of sequential pages.
    ///   - nextToken: The token for the next set of results, or null to start from the beginning.
    ///   - logger: Logger use during operation
    @inlinable
    public func listWorkers(
        farmId: String,
        fleetId: String,
        maxResults: Int? = nil,
        nextToken: String? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ListWorkersResponse {
        let input = ListWorkersRequest(
            farmId: farmId, 
            fleetId: fleetId, 
            maxResults: maxResults, 
            nextToken: nextToken
        )
        return try await self.listWorkers(input, logger: logger)
    }

    /// Adds a metered product.
    @Sendable
    @inlinable
    public func putMeteredProduct(_ input: PutMeteredProductRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> PutMeteredProductResponse {
        try await self.client.execute(
            operation: "PutMeteredProduct", 
            path: "/2023-10-12/license-endpoints/{licenseEndpointId}/metered-products/{productId}", 
            httpMethod: .PUT, 
            serviceConfig: self.config, 
            input: input, 
            hostPrefix: "management.", 
            logger: logger
        )
    }
    /// Adds a metered product.
    ///
    /// Parameters:
    ///   - licenseEndpointId: The license endpoint ID to add to the metered product.
    ///   - productId: The product ID to add to the metered product.
    ///   - logger: Logger use during operation
    @inlinable
    public func putMeteredProduct(
        licenseEndpointId: String,
        productId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> PutMeteredProductResponse {
        let input = PutMeteredProductRequest(
            licenseEndpointId: licenseEndpointId, 
            productId: productId
        )
        return try await self.putMeteredProduct(input, logger: logger)
    }

    /// Searches for jobs.
    @Sendable
    @inlinable
    public func searchJobs(_ input: SearchJobsRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> SearchJobsResponse {
        try await self.client.execute(
            operation: "SearchJobs", 
            path: "/2023-10-12/farms/{farmId}/search/jobs", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            hostPrefix: "management.", 
            logger: logger
        )
    }
    /// Searches for jobs.
    ///
    /// Parameters:
    ///   - farmId: The farm ID of the job.
    ///   - filterExpressions: The filter expression, AND or OR, to use
    ///   - itemOffset: Defines how far into the scrollable list to start the return of results.
    ///   - pageSize: Specifies the number of items per page for the resource.
    ///   - queueIds: The queue ID to use in the job search.
    ///   - sortExpressions: The search terms for a resource.
    ///   - logger: Logger use during operation
    @inlinable
    public func searchJobs(
        farmId: String,
        filterExpressions: SearchGroupedFilterExpressions? = nil,
        itemOffset: Int,
        pageSize: Int? = nil,
        queueIds: [String],
        sortExpressions: [SearchSortExpression]? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> SearchJobsResponse {
        let input = SearchJobsRequest(
            farmId: farmId, 
            filterExpressions: filterExpressions, 
            itemOffset: itemOffset, 
            pageSize: pageSize, 
            queueIds: queueIds, 
            sortExpressions: sortExpressions
        )
        return try await self.searchJobs(input, logger: logger)
    }

    /// Searches for steps.
    @Sendable
    @inlinable
    public func searchSteps(_ input: SearchStepsRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> SearchStepsResponse {
        try await self.client.execute(
            operation: "SearchSteps", 
            path: "/2023-10-12/farms/{farmId}/search/steps", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            hostPrefix: "management.", 
            logger: logger
        )
    }
    /// Searches for steps.
    ///
    /// Parameters:
    ///   - farmId: The farm ID to use for the step search.
    ///   - filterExpressions: The filter expression, AND or OR, to use
    ///   - itemOffset: Defines how far into the scrollable list to start the return of results.
    ///   - jobId: The job ID to use in the step search.
    ///   - pageSize: Specifies the number of items per page for the resource.
    ///   - queueIds: The queue IDs in the step search.
    ///   - sortExpressions: The search terms for a resource.
    ///   - logger: Logger use during operation
    @inlinable
    public func searchSteps(
        farmId: String,
        filterExpressions: SearchGroupedFilterExpressions? = nil,
        itemOffset: Int,
        jobId: String? = nil,
        pageSize: Int? = nil,
        queueIds: [String],
        sortExpressions: [SearchSortExpression]? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> SearchStepsResponse {
        let input = SearchStepsRequest(
            farmId: farmId, 
            filterExpressions: filterExpressions, 
            itemOffset: itemOffset, 
            jobId: jobId, 
            pageSize: pageSize, 
            queueIds: queueIds, 
            sortExpressions: sortExpressions
        )
        return try await self.searchSteps(input, logger: logger)
    }

    /// Searches for tasks.
    @Sendable
    @inlinable
    public func searchTasks(_ input: SearchTasksRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> SearchTasksResponse {
        try await self.client.execute(
            operation: "SearchTasks", 
            path: "/2023-10-12/farms/{farmId}/search/tasks", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            hostPrefix: "management.", 
            logger: logger
        )
    }
    /// Searches for tasks.
    ///
    /// Parameters:
    ///   - farmId: The farm ID of the task.
    ///   - filterExpressions: The filter expression, AND or OR, to use
    ///   - itemOffset: Defines how far into the scrollable list to start the return of results.
    ///   - jobId: The job ID for the task search.
    ///   - pageSize: Specifies the number of items per page for the resource.
    ///   - queueIds: The queue IDs to include in the search.
    ///   - sortExpressions: The search terms for a resource.
    ///   - logger: Logger use during operation
    @inlinable
    public func searchTasks(
        farmId: String,
        filterExpressions: SearchGroupedFilterExpressions? = nil,
        itemOffset: Int,
        jobId: String? = nil,
        pageSize: Int? = nil,
        queueIds: [String],
        sortExpressions: [SearchSortExpression]? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> SearchTasksResponse {
        let input = SearchTasksRequest(
            farmId: farmId, 
            filterExpressions: filterExpressions, 
            itemOffset: itemOffset, 
            jobId: jobId, 
            pageSize: pageSize, 
            queueIds: queueIds, 
            sortExpressions: sortExpressions
        )
        return try await self.searchTasks(input, logger: logger)
    }

    /// Searches for workers.
    @Sendable
    @inlinable
    public func searchWorkers(_ input: SearchWorkersRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> SearchWorkersResponse {
        try await self.client.execute(
            operation: "SearchWorkers", 
            path: "/2023-10-12/farms/{farmId}/search/workers", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            hostPrefix: "management.", 
            logger: logger
        )
    }
    /// Searches for workers.
    ///
    /// Parameters:
    ///   - farmId: The farm ID in the workers search.
    ///   - filterExpressions: The filter expression, AND or OR, to use
    ///   - fleetIds: The fleet ID of the workers to search for.
    ///   - itemOffset: Defines how far into the scrollable list to start the return of results.
    ///   - pageSize: Specifies the number of items per page for the resource.
    ///   - sortExpressions: The search terms for a resource.
    ///   - logger: Logger use during operation
    @inlinable
    public func searchWorkers(
        farmId: String,
        filterExpressions: SearchGroupedFilterExpressions? = nil,
        fleetIds: [String],
        itemOffset: Int,
        pageSize: Int? = nil,
        sortExpressions: [SearchSortExpression]? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> SearchWorkersResponse {
        let input = SearchWorkersRequest(
            farmId: farmId, 
            filterExpressions: filterExpressions, 
            fleetIds: fleetIds, 
            itemOffset: itemOffset, 
            pageSize: pageSize, 
            sortExpressions: sortExpressions
        )
        return try await self.searchWorkers(input, logger: logger)
    }

    /// Starts an asynchronous request for getting aggregated statistics about queues and farms. Get the statistics using the GetSessionsStatisticsAggregation operation. You can only have one running aggregation for your Deadline Cloud farm. Call the GetSessionsStatisticsAggregation operation and check the status field to see if an aggregation is running. Statistics are available for 1 hour after you call the StartSessionsStatisticsAggregation operation.
    @Sendable
    @inlinable
    public func startSessionsStatisticsAggregation(_ input: StartSessionsStatisticsAggregationRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> StartSessionsStatisticsAggregationResponse {
        try await self.client.execute(
            operation: "StartSessionsStatisticsAggregation", 
            path: "/2023-10-12/farms/{farmId}/sessions-statistics-aggregation", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            hostPrefix: "management.", 
            logger: logger
        )
    }
    /// Starts an asynchronous request for getting aggregated statistics about queues and farms. Get the statistics using the GetSessionsStatisticsAggregation operation. You can only have one running aggregation for your Deadline Cloud farm. Call the GetSessionsStatisticsAggregation operation and check the status field to see if an aggregation is running. Statistics are available for 1 hour after you call the StartSessionsStatisticsAggregation operation.
    ///
    /// Parameters:
    ///   - endTime: The Linux timestamp of the date and time that the statistics end.
    ///   - farmId: The identifier of the farm that contains queues or fleets to return statistics for.
    ///   - groupBy: The field to use to group the statistics.
    ///   - period: The period to aggregate the statistics.
    ///   - resourceIds: A list of fleet IDs or queue IDs to gather statistics for.
    ///   - startTime: The Linux timestamp of the date and time that the statistics start.
    ///   - statistics: One to four statistics to return.
    ///   - timezone: The timezone to use for the statistics. Use UTC notation such as "UTC+8."
    ///   - logger: Logger use during operation
    @inlinable
    public func startSessionsStatisticsAggregation(
        endTime: Date,
        farmId: String,
        groupBy: [UsageGroupByField],
        period: Period? = nil,
        resourceIds: SessionsStatisticsResources,
        startTime: Date,
        statistics: [UsageStatistic],
        timezone: String? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> StartSessionsStatisticsAggregationResponse {
        let input = StartSessionsStatisticsAggregationRequest(
            endTime: endTime, 
            farmId: farmId, 
            groupBy: groupBy, 
            period: period, 
            resourceIds: resourceIds, 
            startTime: startTime, 
            statistics: statistics, 
            timezone: timezone
        )
        return try await self.startSessionsStatisticsAggregation(input, logger: logger)
    }

    /// Tags a resource using the resource's ARN and desired tags.
    @Sendable
    @inlinable
    public func tagResource(_ input: TagResourceRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> TagResourceResponse {
        try await self.client.execute(
            operation: "TagResource", 
            path: "/2023-10-12/tags/{resourceArn}", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            hostPrefix: "management.", 
            logger: logger
        )
    }
    /// Tags a resource using the resource's ARN and desired tags.
    ///
    /// Parameters:
    ///   - resourceArn: The ARN of the resource to apply tags to.
    ///   - tags: Each tag consists of a tag key and a tag value. Tag keys and values are both required, but tag values can be empty strings.
    ///   - logger: Logger use during operation
    @inlinable
    public func tagResource(
        resourceArn: String,
        tags: [String: String]? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> TagResourceResponse {
        let input = TagResourceRequest(
            resourceArn: resourceArn, 
            tags: tags
        )
        return try await self.tagResource(input, logger: logger)
    }

    /// Removes a tag from a resource using the resource's ARN and tag to remove.
    @Sendable
    @inlinable
    public func untagResource(_ input: UntagResourceRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> UntagResourceResponse {
        try await self.client.execute(
            operation: "UntagResource", 
            path: "/2023-10-12/tags/{resourceArn}", 
            httpMethod: .DELETE, 
            serviceConfig: self.config, 
            input: input, 
            hostPrefix: "management.", 
            logger: logger
        )
    }
    /// Removes a tag from a resource using the resource's ARN and tag to remove.
    ///
    /// Parameters:
    ///   - resourceArn: The ARN of the resource to remove the tag from.
    ///   - tagKeys: They keys of the tag.
    ///   - logger: Logger use during operation
    @inlinable
    public func untagResource(
        resourceArn: String,
        tagKeys: [String],
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> UntagResourceResponse {
        let input = UntagResourceRequest(
            resourceArn: resourceArn, 
            tagKeys: tagKeys
        )
        return try await self.untagResource(input, logger: logger)
    }

    /// Updates a budget that sets spending thresholds for rendering activity.
    @Sendable
    @inlinable
    public func updateBudget(_ input: UpdateBudgetRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> UpdateBudgetResponse {
        try await self.client.execute(
            operation: "UpdateBudget", 
            path: "/2023-10-12/farms/{farmId}/budgets/{budgetId}", 
            httpMethod: .PATCH, 
            serviceConfig: self.config, 
            input: input, 
            hostPrefix: "management.", 
            logger: logger
        )
    }
    /// Updates a budget that sets spending thresholds for rendering activity.
    ///
    /// Parameters:
    ///   - actionsToAdd: The budget actions to add. Budget actions specify what happens when the budget runs out.
    ///   - actionsToRemove: The budget actions to remove from the budget.
    ///   - approximateDollarLimit: The dollar limit to update on the budget. Based on consumed usage.
    ///   - budgetId: The budget ID to update.
    ///   - clientToken: The unique token which the server uses to recognize retries of the same request.
    ///   - description: The description of the budget to update.  This field can store any content. Escape or encode this content before displaying it on a webpage or any other system that might interpret the content of this field.
    ///   - displayName: The display name of the budget to update.  This field can store any content. Escape or encode this content before displaying it on a webpage or any other system that might interpret the content of this field.
    ///   - farmId: The farm ID of the budget to update.
    ///   - schedule: The schedule to update.
    ///   - status: Updates the status of the budget.    ACTIVE–The budget is being evaluated.    INACTIVE–The budget is inactive. This can include Expired, Canceled, or deleted Deleted statuses.
    ///   - logger: Logger use during operation
    @inlinable
    public func updateBudget(
        actionsToAdd: [BudgetActionToAdd]? = nil,
        actionsToRemove: [BudgetActionToRemove]? = nil,
        approximateDollarLimit: Float? = nil,
        budgetId: String,
        clientToken: String? = UpdateBudgetRequest.idempotencyToken(),
        description: String? = nil,
        displayName: String? = nil,
        farmId: String,
        schedule: BudgetSchedule? = nil,
        status: BudgetStatus? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> UpdateBudgetResponse {
        let input = UpdateBudgetRequest(
            actionsToAdd: actionsToAdd, 
            actionsToRemove: actionsToRemove, 
            approximateDollarLimit: approximateDollarLimit, 
            budgetId: budgetId, 
            clientToken: clientToken, 
            description: description, 
            displayName: displayName, 
            farmId: farmId, 
            schedule: schedule, 
            status: status
        )
        return try await self.updateBudget(input, logger: logger)
    }

    /// Updates a farm.
    @Sendable
    @inlinable
    public func updateFarm(_ input: UpdateFarmRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> UpdateFarmResponse {
        try await self.client.execute(
            operation: "UpdateFarm", 
            path: "/2023-10-12/farms/{farmId}", 
            httpMethod: .PATCH, 
            serviceConfig: self.config, 
            input: input, 
            hostPrefix: "management.", 
            logger: logger
        )
    }
    /// Updates a farm.
    ///
    /// Parameters:
    ///   - description: The description of the farm to update.  This field can store any content. Escape or encode this content before displaying it on a webpage or any other system that might interpret the content of this field.
    ///   - displayName: The display name of the farm to update.  This field can store any content. Escape or encode this content before displaying it on a webpage or any other system that might interpret the content of this field.
    ///   - farmId: The farm ID to update.
    ///   - logger: Logger use during operation
    @inlinable
    public func updateFarm(
        description: String? = nil,
        displayName: String? = nil,
        farmId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> UpdateFarmResponse {
        let input = UpdateFarmRequest(
            description: description, 
            displayName: displayName, 
            farmId: farmId
        )
        return try await self.updateFarm(input, logger: logger)
    }

    /// Updates a fleet.
    @Sendable
    @inlinable
    public func updateFleet(_ input: UpdateFleetRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> UpdateFleetResponse {
        try await self.client.execute(
            operation: "UpdateFleet", 
            path: "/2023-10-12/farms/{farmId}/fleets/{fleetId}", 
            httpMethod: .PATCH, 
            serviceConfig: self.config, 
            input: input, 
            hostPrefix: "management.", 
            logger: logger
        )
    }
    /// Updates a fleet.
    ///
    /// Parameters:
    ///   - clientToken: The unique token which the server uses to recognize retries of the same request.
    ///   - configuration: The fleet configuration to update.
    ///   - description: The description of the fleet to update.  This field can store any content. Escape or encode this content before displaying it on a webpage or any other system that might interpret the content of this field.
    ///   - displayName: The display name of the fleet to update.  This field can store any content. Escape or encode this content before displaying it on a webpage or any other system that might interpret the content of this field.
    ///   - farmId: The farm ID to update.
    ///   - fleetId: The fleet ID to update.
    ///   - maxWorkerCount: The maximum number of workers in the fleet.
    ///   - minWorkerCount: The minimum number of workers in the fleet.
    ///   - roleArn: The IAM role ARN that the fleet's workers assume while running jobs.
    ///   - logger: Logger use during operation
    @inlinable
    public func updateFleet(
        clientToken: String? = UpdateFleetRequest.idempotencyToken(),
        configuration: FleetConfiguration? = nil,
        description: String? = nil,
        displayName: String? = nil,
        farmId: String,
        fleetId: String,
        maxWorkerCount: Int? = nil,
        minWorkerCount: Int? = nil,
        roleArn: String? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> UpdateFleetResponse {
        let input = UpdateFleetRequest(
            clientToken: clientToken, 
            configuration: configuration, 
            description: description, 
            displayName: displayName, 
            farmId: farmId, 
            fleetId: fleetId, 
            maxWorkerCount: maxWorkerCount, 
            minWorkerCount: minWorkerCount, 
            roleArn: roleArn
        )
        return try await self.updateFleet(input, logger: logger)
    }

    /// Updates a job.  When you change the status of the job to ARCHIVED, the job can't be scheduled or archived.  An archived jobs and its steps and tasks are deleted after 120 days. The job can't be recovered.
    @Sendable
    @inlinable
    public func updateJob(_ input: UpdateJobRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> UpdateJobResponse {
        try await self.client.execute(
            operation: "UpdateJob", 
            path: "/2023-10-12/farms/{farmId}/queues/{queueId}/jobs/{jobId}", 
            httpMethod: .PATCH, 
            serviceConfig: self.config, 
            input: input, 
            hostPrefix: "management.", 
            logger: logger
        )
    }
    /// Updates a job.  When you change the status of the job to ARCHIVED, the job can't be scheduled or archived.  An archived jobs and its steps and tasks are deleted after 120 days. The job can't be recovered.
    ///
    /// Parameters:
    ///   - clientToken: The unique token which the server uses to recognize retries of the same request.
    ///   - farmId: The farm ID of the job to update.
    ///   - jobId: The job ID to update.
    ///   - lifecycleStatus: The status of a job in its lifecycle. When you change the status of the job to ARCHIVED, the job can't be scheduled or archived.  An archived jobs and its steps and tasks are deleted after 120 days. The job can't be recovered.
    ///   - maxFailedTasksCount: The number of task failures before the job stops running and is marked as FAILED.
    ///   - maxRetriesPerTask: The maximum number of retries for a job.
    ///   - priority: The job priority to update.
    ///   - queueId: The queue ID of the job to update.
    ///   - targetTaskRunStatus: The task status to update the job's tasks to.
    ///   - logger: Logger use during operation
    @inlinable
    public func updateJob(
        clientToken: String? = UpdateJobRequest.idempotencyToken(),
        farmId: String,
        jobId: String,
        lifecycleStatus: UpdateJobLifecycleStatus? = nil,
        maxFailedTasksCount: Int? = nil,
        maxRetriesPerTask: Int? = nil,
        priority: Int? = nil,
        queueId: String,
        targetTaskRunStatus: JobTargetTaskRunStatus? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> UpdateJobResponse {
        let input = UpdateJobRequest(
            clientToken: clientToken, 
            farmId: farmId, 
            jobId: jobId, 
            lifecycleStatus: lifecycleStatus, 
            maxFailedTasksCount: maxFailedTasksCount, 
            maxRetriesPerTask: maxRetriesPerTask, 
            priority: priority, 
            queueId: queueId, 
            targetTaskRunStatus: targetTaskRunStatus
        )
        return try await self.updateJob(input, logger: logger)
    }

    /// Modifies the settings for a Deadline Cloud monitor. You can modify one or all of the settings when you call UpdateMonitor.
    @Sendable
    @inlinable
    public func updateMonitor(_ input: UpdateMonitorRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> UpdateMonitorResponse {
        try await self.client.execute(
            operation: "UpdateMonitor", 
            path: "/2023-10-12/monitors/{monitorId}", 
            httpMethod: .PATCH, 
            serviceConfig: self.config, 
            input: input, 
            hostPrefix: "management.", 
            logger: logger
        )
    }
    /// Modifies the settings for a Deadline Cloud monitor. You can modify one or all of the settings when you call UpdateMonitor.
    ///
    /// Parameters:
    ///   - displayName: The new value to use for the monitor's display name.  This field can store any content. Escape or encode this content before displaying it on a webpage or any other system that might interpret the content of this field.
    ///   - monitorId: The unique identifier of the monitor to update.
    ///   - roleArn: The Amazon Resource Name (ARN) of the new IAM role to use with the monitor.
    ///   - subdomain: The new value of the subdomain to use when forming the monitor URL.
    ///   - logger: Logger use during operation
    @inlinable
    public func updateMonitor(
        displayName: String? = nil,
        monitorId: String,
        roleArn: String? = nil,
        subdomain: String? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> UpdateMonitorResponse {
        let input = UpdateMonitorRequest(
            displayName: displayName, 
            monitorId: monitorId, 
            roleArn: roleArn, 
            subdomain: subdomain
        )
        return try await self.updateMonitor(input, logger: logger)
    }

    /// Updates a queue.
    @Sendable
    @inlinable
    public func updateQueue(_ input: UpdateQueueRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> UpdateQueueResponse {
        try await self.client.execute(
            operation: "UpdateQueue", 
            path: "/2023-10-12/farms/{farmId}/queues/{queueId}", 
            httpMethod: .PATCH, 
            serviceConfig: self.config, 
            input: input, 
            hostPrefix: "management.", 
            logger: logger
        )
    }
    /// Updates a queue.
    ///
    /// Parameters:
    ///   - allowedStorageProfileIdsToAdd: The storage profile IDs to add.
    ///   - allowedStorageProfileIdsToRemove: The storage profile ID to remove.
    ///   - clientToken: The idempotency token to update in the queue.
    ///   - defaultBudgetAction: The default action to take for a queue update if a budget isn't configured.
    ///   - description: The description of the queue to update.  This field can store any content. Escape or encode this content before displaying it on a webpage or any other system that might interpret the content of this field.
    ///   - displayName: The display name of the queue to update.  This field can store any content. Escape or encode this content before displaying it on a webpage or any other system that might interpret the content of this field.
    ///   - farmId: The farm ID to update in the queue.
    ///   - jobAttachmentSettings: The job attachment settings to update for the queue.
    ///   - jobRunAsUser: Update the jobs in the queue to run as a specified POSIX user.
    ///   - queueId: The queue ID to update.
    ///   - requiredFileSystemLocationNamesToAdd: The required file system location names to add to the queue.
    ///   - requiredFileSystemLocationNamesToRemove: The required file system location names to remove from the queue.
    ///   - roleArn: The IAM role ARN that's used to run jobs from this queue.
    ///   - logger: Logger use during operation
    @inlinable
    public func updateQueue(
        allowedStorageProfileIdsToAdd: [String]? = nil,
        allowedStorageProfileIdsToRemove: [String]? = nil,
        clientToken: String? = UpdateQueueRequest.idempotencyToken(),
        defaultBudgetAction: DefaultQueueBudgetAction? = nil,
        description: String? = nil,
        displayName: String? = nil,
        farmId: String,
        jobAttachmentSettings: JobAttachmentSettings? = nil,
        jobRunAsUser: JobRunAsUser? = nil,
        queueId: String,
        requiredFileSystemLocationNamesToAdd: [String]? = nil,
        requiredFileSystemLocationNamesToRemove: [String]? = nil,
        roleArn: String? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> UpdateQueueResponse {
        let input = UpdateQueueRequest(
            allowedStorageProfileIdsToAdd: allowedStorageProfileIdsToAdd, 
            allowedStorageProfileIdsToRemove: allowedStorageProfileIdsToRemove, 
            clientToken: clientToken, 
            defaultBudgetAction: defaultBudgetAction, 
            description: description, 
            displayName: displayName, 
            farmId: farmId, 
            jobAttachmentSettings: jobAttachmentSettings, 
            jobRunAsUser: jobRunAsUser, 
            queueId: queueId, 
            requiredFileSystemLocationNamesToAdd: requiredFileSystemLocationNamesToAdd, 
            requiredFileSystemLocationNamesToRemove: requiredFileSystemLocationNamesToRemove, 
            roleArn: roleArn
        )
        return try await self.updateQueue(input, logger: logger)
    }

    /// Updates the queue environment.
    @Sendable
    @inlinable
    public func updateQueueEnvironment(_ input: UpdateQueueEnvironmentRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> UpdateQueueEnvironmentResponse {
        try await self.client.execute(
            operation: "UpdateQueueEnvironment", 
            path: "/2023-10-12/farms/{farmId}/queues/{queueId}/environments/{queueEnvironmentId}", 
            httpMethod: .PATCH, 
            serviceConfig: self.config, 
            input: input, 
            hostPrefix: "management.", 
            logger: logger
        )
    }
    /// Updates the queue environment.
    ///
    /// Parameters:
    ///   - clientToken: The unique token which the server uses to recognize retries of the same request.
    ///   - farmId: The farm ID of the queue environment to update.
    ///   - priority: The priority to update.
    ///   - queueEnvironmentId: The queue environment ID to update.
    ///   - queueId: The queue ID of the queue environment to update.
    ///   - template: The template to update.
    ///   - templateType: The template type to update.
    ///   - logger: Logger use during operation
    @inlinable
    public func updateQueueEnvironment(
        clientToken: String? = UpdateQueueEnvironmentRequest.idempotencyToken(),
        farmId: String,
        priority: Int? = nil,
        queueEnvironmentId: String,
        queueId: String,
        template: String? = nil,
        templateType: EnvironmentTemplateType? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> UpdateQueueEnvironmentResponse {
        let input = UpdateQueueEnvironmentRequest(
            clientToken: clientToken, 
            farmId: farmId, 
            priority: priority, 
            queueEnvironmentId: queueEnvironmentId, 
            queueId: queueId, 
            template: template, 
            templateType: templateType
        )
        return try await self.updateQueueEnvironment(input, logger: logger)
    }

    /// Updates a queue-fleet association.
    @Sendable
    @inlinable
    public func updateQueueFleetAssociation(_ input: UpdateQueueFleetAssociationRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> UpdateQueueFleetAssociationResponse {
        try await self.client.execute(
            operation: "UpdateQueueFleetAssociation", 
            path: "/2023-10-12/farms/{farmId}/queue-fleet-associations/{queueId}/{fleetId}", 
            httpMethod: .PATCH, 
            serviceConfig: self.config, 
            input: input, 
            hostPrefix: "management.", 
            logger: logger
        )
    }
    /// Updates a queue-fleet association.
    ///
    /// Parameters:
    ///   - farmId: The farm ID to update.
    ///   - fleetId: The fleet ID to update.
    ///   - queueId: The queue ID to update.
    ///   - status: The status to update.
    ///   - logger: Logger use during operation
    @inlinable
    public func updateQueueFleetAssociation(
        farmId: String,
        fleetId: String,
        queueId: String,
        status: UpdateQueueFleetAssociationStatus,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> UpdateQueueFleetAssociationResponse {
        let input = UpdateQueueFleetAssociationRequest(
            farmId: farmId, 
            fleetId: fleetId, 
            queueId: queueId, 
            status: status
        )
        return try await self.updateQueueFleetAssociation(input, logger: logger)
    }

    /// Updates a session.
    @Sendable
    @inlinable
    public func updateSession(_ input: UpdateSessionRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> UpdateSessionResponse {
        try await self.client.execute(
            operation: "UpdateSession", 
            path: "/2023-10-12/farms/{farmId}/queues/{queueId}/jobs/{jobId}/sessions/{sessionId}", 
            httpMethod: .PATCH, 
            serviceConfig: self.config, 
            input: input, 
            hostPrefix: "management.", 
            logger: logger
        )
    }
    /// Updates a session.
    ///
    /// Parameters:
    ///   - clientToken: The unique token which the server uses to recognize retries of the same request.
    ///   - farmId: The farm ID to update in the session.
    ///   - jobId: The job ID to update in the session.
    ///   - queueId: The queue ID to update in the session.
    ///   - sessionId: The session ID to update.
    ///   - targetLifecycleStatus: The life cycle status to update in the session.
    ///   - logger: Logger use during operation
    @inlinable
    public func updateSession(
        clientToken: String? = UpdateSessionRequest.idempotencyToken(),
        farmId: String,
        jobId: String,
        queueId: String,
        sessionId: String,
        targetLifecycleStatus: SessionLifecycleTargetStatus,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> UpdateSessionResponse {
        let input = UpdateSessionRequest(
            clientToken: clientToken, 
            farmId: farmId, 
            jobId: jobId, 
            queueId: queueId, 
            sessionId: sessionId, 
            targetLifecycleStatus: targetLifecycleStatus
        )
        return try await self.updateSession(input, logger: logger)
    }

    /// Updates a step.
    @Sendable
    @inlinable
    public func updateStep(_ input: UpdateStepRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> UpdateStepResponse {
        try await self.client.execute(
            operation: "UpdateStep", 
            path: "/2023-10-12/farms/{farmId}/queues/{queueId}/jobs/{jobId}/steps/{stepId}", 
            httpMethod: .PATCH, 
            serviceConfig: self.config, 
            input: input, 
            hostPrefix: "management.", 
            logger: logger
        )
    }
    /// Updates a step.
    ///
    /// Parameters:
    ///   - clientToken: The unique token which the server uses to recognize retries of the same request.
    ///   - farmId: The farm ID to update.
    ///   - jobId: The job ID to update.
    ///   - queueId: The queue ID to update.
    ///   - stepId: The step ID to update.
    ///   - targetTaskRunStatus: The task status to update the step's tasks to.
    ///   - logger: Logger use during operation
    @inlinable
    public func updateStep(
        clientToken: String? = UpdateStepRequest.idempotencyToken(),
        farmId: String,
        jobId: String,
        queueId: String,
        stepId: String,
        targetTaskRunStatus: StepTargetTaskRunStatus,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> UpdateStepResponse {
        let input = UpdateStepRequest(
            clientToken: clientToken, 
            farmId: farmId, 
            jobId: jobId, 
            queueId: queueId, 
            stepId: stepId, 
            targetTaskRunStatus: targetTaskRunStatus
        )
        return try await self.updateStep(input, logger: logger)
    }

    /// Updates a storage profile.
    @Sendable
    @inlinable
    public func updateStorageProfile(_ input: UpdateStorageProfileRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> UpdateStorageProfileResponse {
        try await self.client.execute(
            operation: "UpdateStorageProfile", 
            path: "/2023-10-12/farms/{farmId}/storage-profiles/{storageProfileId}", 
            httpMethod: .PATCH, 
            serviceConfig: self.config, 
            input: input, 
            hostPrefix: "management.", 
            logger: logger
        )
    }
    /// Updates a storage profile.
    ///
    /// Parameters:
    ///   - clientToken: The unique token which the server uses to recognize retries of the same request.
    ///   - displayName: The display name of the storage profile to update.  This field can store any content. Escape or encode this content before displaying it on a webpage or any other system that might interpret the content of this field.
    ///   - farmId: The farm ID to update.
    ///   - fileSystemLocationsToAdd: The file system location names to add.
    ///   - fileSystemLocationsToRemove: The file system location names to remove.
    ///   - osFamily: The OS system to update.
    ///   - storageProfileId: The storage profile ID to update.
    ///   - logger: Logger use during operation
    @inlinable
    public func updateStorageProfile(
        clientToken: String? = UpdateStorageProfileRequest.idempotencyToken(),
        displayName: String? = nil,
        farmId: String,
        fileSystemLocationsToAdd: [FileSystemLocation]? = nil,
        fileSystemLocationsToRemove: [FileSystemLocation]? = nil,
        osFamily: StorageProfileOperatingSystemFamily? = nil,
        storageProfileId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> UpdateStorageProfileResponse {
        let input = UpdateStorageProfileRequest(
            clientToken: clientToken, 
            displayName: displayName, 
            farmId: farmId, 
            fileSystemLocationsToAdd: fileSystemLocationsToAdd, 
            fileSystemLocationsToRemove: fileSystemLocationsToRemove, 
            osFamily: osFamily, 
            storageProfileId: storageProfileId
        )
        return try await self.updateStorageProfile(input, logger: logger)
    }

    /// Updates a task.
    @Sendable
    @inlinable
    public func updateTask(_ input: UpdateTaskRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> UpdateTaskResponse {
        try await self.client.execute(
            operation: "UpdateTask", 
            path: "/2023-10-12/farms/{farmId}/queues/{queueId}/jobs/{jobId}/steps/{stepId}/tasks/{taskId}", 
            httpMethod: .PATCH, 
            serviceConfig: self.config, 
            input: input, 
            hostPrefix: "management.", 
            logger: logger
        )
    }
    /// Updates a task.
    ///
    /// Parameters:
    ///   - clientToken: The unique token which the server uses to recognize retries of the same request.
    ///   - farmId: The farm ID to update.
    ///   - jobId: The job ID to update.
    ///   - queueId: The queue ID to update.
    ///   - stepId: The step ID to update.
    ///   - targetRunStatus: The run status with which to start the task.
    ///   - taskId: The task ID to update.
    ///   - logger: Logger use during operation
    @inlinable
    public func updateTask(
        clientToken: String? = UpdateTaskRequest.idempotencyToken(),
        farmId: String,
        jobId: String,
        queueId: String,
        stepId: String,
        targetRunStatus: TaskTargetRunStatus,
        taskId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> UpdateTaskResponse {
        let input = UpdateTaskRequest(
            clientToken: clientToken, 
            farmId: farmId, 
            jobId: jobId, 
            queueId: queueId, 
            stepId: stepId, 
            targetRunStatus: targetRunStatus, 
            taskId: taskId
        )
        return try await self.updateTask(input, logger: logger)
    }

    /// Updates a worker.
    @Sendable
    @inlinable
    public func updateWorker(_ input: UpdateWorkerRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> UpdateWorkerResponse {
        try await self.client.execute(
            operation: "UpdateWorker", 
            path: "/2023-10-12/farms/{farmId}/fleets/{fleetId}/workers/{workerId}", 
            httpMethod: .PATCH, 
            serviceConfig: self.config, 
            input: input, 
            hostPrefix: "scheduling.", 
            logger: logger
        )
    }
    /// Updates a worker.
    ///
    /// Parameters:
    ///   - capabilities: The worker capabilities to update.
    ///   - farmId: The farm ID to update.
    ///   - fleetId: The fleet ID to update.
    ///   - hostProperties: The host properties to update.
    ///   - status: The worker status to update.
    ///   - workerId: The worker ID to update.
    ///   - logger: Logger use during operation
    @inlinable
    public func updateWorker(
        capabilities: WorkerCapabilities? = nil,
        farmId: String,
        fleetId: String,
        hostProperties: HostPropertiesRequest? = nil,
        status: UpdatedWorkerStatus? = nil,
        workerId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> UpdateWorkerResponse {
        let input = UpdateWorkerRequest(
            capabilities: capabilities, 
            farmId: farmId, 
            fleetId: fleetId, 
            hostProperties: hostProperties, 
            status: status, 
            workerId: workerId
        )
        return try await self.updateWorker(input, logger: logger)
    }

    /// Updates the schedule for a worker.
    @Sendable
    @inlinable
    public func updateWorkerSchedule(_ input: UpdateWorkerScheduleRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> UpdateWorkerScheduleResponse {
        try await self.client.execute(
            operation: "UpdateWorkerSchedule", 
            path: "/2023-10-12/farms/{farmId}/fleets/{fleetId}/workers/{workerId}/schedule", 
            httpMethod: .PATCH, 
            serviceConfig: self.config, 
            input: input, 
            hostPrefix: "scheduling.", 
            logger: logger
        )
    }
    /// Updates the schedule for a worker.
    ///
    /// Parameters:
    ///   - farmId: The farm ID to update.
    ///   - fleetId: The fleet ID to update.
    ///   - updatedSessionActions: The session actions associated with the worker schedule to update.
    ///   - workerId: The worker ID to update.
    ///   - logger: Logger use during operation
    @inlinable
    public func updateWorkerSchedule(
        farmId: String,
        fleetId: String,
        updatedSessionActions: [String: UpdatedSessionActionInfo]? = nil,
        workerId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> UpdateWorkerScheduleResponse {
        let input = UpdateWorkerScheduleRequest(
            farmId: farmId, 
            fleetId: fleetId, 
            updatedSessionActions: updatedSessionActions, 
            workerId: workerId
        )
        return try await self.updateWorkerSchedule(input, logger: logger)
    }
}

extension Deadline {
    /// Initializer required by `AWSService.with(middlewares:timeout:byteBufferAllocator:options)`. You are not able to use this initializer directly as there are not public
    /// initializers for `AWSServiceConfig.Patch`. Please use `AWSService.with(middlewares:timeout:byteBufferAllocator:options)` instead.
    public init(from: Deadline, patch: AWSServiceConfig.Patch) {
        self.client = from.client
        self.config = from.config.with(patch: patch)
    }
}

// MARK: Paginators

@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension Deadline {
    /// Return PaginatorSequence for operation ``getSessionsStatisticsAggregation(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func getSessionsStatisticsAggregationPaginator(
        _ input: GetSessionsStatisticsAggregationRequest,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<GetSessionsStatisticsAggregationRequest, GetSessionsStatisticsAggregationResponse> {
        return .init(
            input: input,
            command: self.getSessionsStatisticsAggregation,
            inputKey: \GetSessionsStatisticsAggregationRequest.nextToken,
            outputKey: \GetSessionsStatisticsAggregationResponse.nextToken,
            logger: logger
        )
    }
    /// Return PaginatorSequence for operation ``getSessionsStatisticsAggregation(_:logger:)``.
    ///
    /// - Parameters:
    ///   - aggregationId: The identifier returned by the StartSessionsStatisticsAggregation operation that identifies the aggregated statistics.
    ///   - farmId: The identifier of the farm to include in the statistics. This should be the same as the farm ID used in the call to the StartSessionsStatisticsAggregation operation.
    ///   - maxResults: The maximum number of results to return. Use this parameter with NextToken to get results as a set of sequential pages.
    ///   - logger: Logger used for logging
    @inlinable
    public func getSessionsStatisticsAggregationPaginator(
        aggregationId: String,
        farmId: String,
        maxResults: Int? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) -> AWSClient.PaginatorSequence<GetSessionsStatisticsAggregationRequest, GetSessionsStatisticsAggregationResponse> {
        let input = GetSessionsStatisticsAggregationRequest(
            aggregationId: aggregationId, 
            farmId: farmId, 
            maxResults: maxResults
        )
        return self.getSessionsStatisticsAggregationPaginator(input, logger: logger)
    }

    /// Return PaginatorSequence for operation ``listAvailableMeteredProducts(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func listAvailableMeteredProductsPaginator(
        _ input: ListAvailableMeteredProductsRequest,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<ListAvailableMeteredProductsRequest, ListAvailableMeteredProductsResponse> {
        return .init(
            input: input,
            command: self.listAvailableMeteredProducts,
            inputKey: \ListAvailableMeteredProductsRequest.nextToken,
            outputKey: \ListAvailableMeteredProductsResponse.nextToken,
            logger: logger
        )
    }
    /// Return PaginatorSequence for operation ``listAvailableMeteredProducts(_:logger:)``.
    ///
    /// - Parameters:
    ///   - maxResults: The maximum number of results to return. Use this parameter with NextToken to get results as a set of sequential pages.
    ///   - logger: Logger used for logging
    @inlinable
    public func listAvailableMeteredProductsPaginator(
        maxResults: Int? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) -> AWSClient.PaginatorSequence<ListAvailableMeteredProductsRequest, ListAvailableMeteredProductsResponse> {
        let input = ListAvailableMeteredProductsRequest(
            maxResults: maxResults
        )
        return self.listAvailableMeteredProductsPaginator(input, logger: logger)
    }

    /// Return PaginatorSequence for operation ``listBudgets(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func listBudgetsPaginator(
        _ input: ListBudgetsRequest,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<ListBudgetsRequest, ListBudgetsResponse> {
        return .init(
            input: input,
            command: self.listBudgets,
            inputKey: \ListBudgetsRequest.nextToken,
            outputKey: \ListBudgetsResponse.nextToken,
            logger: logger
        )
    }
    /// Return PaginatorSequence for operation ``listBudgets(_:logger:)``.
    ///
    /// - Parameters:
    ///   - farmId: The farm ID associated with the budgets.
    ///   - maxResults: The maximum number of results to return. Use this parameter with NextToken to get results as a set of sequential pages.
    ///   - status: The status to list for the budgets.
    ///   - logger: Logger used for logging
    @inlinable
    public func listBudgetsPaginator(
        farmId: String,
        maxResults: Int? = nil,
        status: BudgetStatus? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) -> AWSClient.PaginatorSequence<ListBudgetsRequest, ListBudgetsResponse> {
        let input = ListBudgetsRequest(
            farmId: farmId, 
            maxResults: maxResults, 
            status: status
        )
        return self.listBudgetsPaginator(input, logger: logger)
    }

    /// Return PaginatorSequence for operation ``listFarmMembers(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func listFarmMembersPaginator(
        _ input: ListFarmMembersRequest,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<ListFarmMembersRequest, ListFarmMembersResponse> {
        return .init(
            input: input,
            command: self.listFarmMembers,
            inputKey: \ListFarmMembersRequest.nextToken,
            outputKey: \ListFarmMembersResponse.nextToken,
            logger: logger
        )
    }
    /// Return PaginatorSequence for operation ``listFarmMembers(_:logger:)``.
    ///
    /// - Parameters:
    ///   - farmId: The farm ID.
    ///   - maxResults: The maximum number of results to return. Use this parameter with NextToken to get results as a set of sequential pages.
    ///   - logger: Logger used for logging
    @inlinable
    public func listFarmMembersPaginator(
        farmId: String,
        maxResults: Int? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) -> AWSClient.PaginatorSequence<ListFarmMembersRequest, ListFarmMembersResponse> {
        let input = ListFarmMembersRequest(
            farmId: farmId, 
            maxResults: maxResults
        )
        return self.listFarmMembersPaginator(input, logger: logger)
    }

    /// Return PaginatorSequence for operation ``listFarms(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func listFarmsPaginator(
        _ input: ListFarmsRequest,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<ListFarmsRequest, ListFarmsResponse> {
        return .init(
            input: input,
            command: self.listFarms,
            inputKey: \ListFarmsRequest.nextToken,
            outputKey: \ListFarmsResponse.nextToken,
            logger: logger
        )
    }
    /// Return PaginatorSequence for operation ``listFarms(_:logger:)``.
    ///
    /// - Parameters:
    ///   - maxResults: The maximum number of results to return. Use this parameter with NextToken to get results as a set of sequential pages.
    ///   - principalId: The principal ID of the member to list on the farm.
    ///   - logger: Logger used for logging
    @inlinable
    public func listFarmsPaginator(
        maxResults: Int? = nil,
        principalId: String? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) -> AWSClient.PaginatorSequence<ListFarmsRequest, ListFarmsResponse> {
        let input = ListFarmsRequest(
            maxResults: maxResults, 
            principalId: principalId
        )
        return self.listFarmsPaginator(input, logger: logger)
    }

    /// Return PaginatorSequence for operation ``listFleetMembers(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func listFleetMembersPaginator(
        _ input: ListFleetMembersRequest,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<ListFleetMembersRequest, ListFleetMembersResponse> {
        return .init(
            input: input,
            command: self.listFleetMembers,
            inputKey: \ListFleetMembersRequest.nextToken,
            outputKey: \ListFleetMembersResponse.nextToken,
            logger: logger
        )
    }
    /// Return PaginatorSequence for operation ``listFleetMembers(_:logger:)``.
    ///
    /// - Parameters:
    ///   - farmId: The farm ID of the fleet.
    ///   - fleetId: The fleet ID to include on the list.
    ///   - maxResults: The maximum number of results to return. Use this parameter with NextToken to get results as a set of sequential pages.
    ///   - logger: Logger used for logging
    @inlinable
    public func listFleetMembersPaginator(
        farmId: String,
        fleetId: String,
        maxResults: Int? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) -> AWSClient.PaginatorSequence<ListFleetMembersRequest, ListFleetMembersResponse> {
        let input = ListFleetMembersRequest(
            farmId: farmId, 
            fleetId: fleetId, 
            maxResults: maxResults
        )
        return self.listFleetMembersPaginator(input, logger: logger)
    }

    /// Return PaginatorSequence for operation ``listFleets(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func listFleetsPaginator(
        _ input: ListFleetsRequest,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<ListFleetsRequest, ListFleetsResponse> {
        return .init(
            input: input,
            command: self.listFleets,
            inputKey: \ListFleetsRequest.nextToken,
            outputKey: \ListFleetsResponse.nextToken,
            logger: logger
        )
    }
    /// Return PaginatorSequence for operation ``listFleets(_:logger:)``.
    ///
    /// - Parameters:
    ///   - displayName: The display names of a list of fleets.  This field can store any content. Escape or encode this content before displaying it on a webpage or any other system that might interpret the content of this field.
    ///   - farmId: The farm ID of the fleets.
    ///   - maxResults: The maximum number of results to return. Use this parameter with NextToken to get results as a set of sequential pages.
    ///   - principalId: The principal ID of the members to include in the fleet.
    ///   - status: The status of the fleet.
    ///   - logger: Logger used for logging
    @inlinable
    public func listFleetsPaginator(
        displayName: String? = nil,
        farmId: String,
        maxResults: Int? = nil,
        principalId: String? = nil,
        status: FleetStatus? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) -> AWSClient.PaginatorSequence<ListFleetsRequest, ListFleetsResponse> {
        let input = ListFleetsRequest(
            displayName: displayName, 
            farmId: farmId, 
            maxResults: maxResults, 
            principalId: principalId, 
            status: status
        )
        return self.listFleetsPaginator(input, logger: logger)
    }

    /// Return PaginatorSequence for operation ``listJobMembers(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func listJobMembersPaginator(
        _ input: ListJobMembersRequest,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<ListJobMembersRequest, ListJobMembersResponse> {
        return .init(
            input: input,
            command: self.listJobMembers,
            inputKey: \ListJobMembersRequest.nextToken,
            outputKey: \ListJobMembersResponse.nextToken,
            logger: logger
        )
    }
    /// Return PaginatorSequence for operation ``listJobMembers(_:logger:)``.
    ///
    /// - Parameters:
    ///   - farmId: The farm ID of the job to list.
    ///   - jobId: The job ID to include on the list.
    ///   - maxResults: The maximum number of results to return. Use this parameter with NextToken to get results as a set of sequential pages.
    ///   - queueId: The queue ID to include on the list.
    ///   - logger: Logger used for logging
    @inlinable
    public func listJobMembersPaginator(
        farmId: String,
        jobId: String,
        maxResults: Int? = nil,
        queueId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) -> AWSClient.PaginatorSequence<ListJobMembersRequest, ListJobMembersResponse> {
        let input = ListJobMembersRequest(
            farmId: farmId, 
            jobId: jobId, 
            maxResults: maxResults, 
            queueId: queueId
        )
        return self.listJobMembersPaginator(input, logger: logger)
    }

    /// Return PaginatorSequence for operation ``listJobParameterDefinitions(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func listJobParameterDefinitionsPaginator(
        _ input: ListJobParameterDefinitionsRequest,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<ListJobParameterDefinitionsRequest, ListJobParameterDefinitionsResponse> {
        return .init(
            input: input,
            command: self.listJobParameterDefinitions,
            inputKey: \ListJobParameterDefinitionsRequest.nextToken,
            outputKey: \ListJobParameterDefinitionsResponse.nextToken,
            logger: logger
        )
    }
    /// Return PaginatorSequence for operation ``listJobParameterDefinitions(_:logger:)``.
    ///
    /// - Parameters:
    ///   - farmId: The farm ID of the job to list.
    ///   - jobId: The job ID to include on the list.
    ///   - maxResults: The maximum number of results to return. Use this parameter with NextToken to get results as a set of sequential pages.
    ///   - queueId: The queue ID to include on the list.
    ///   - logger: Logger used for logging
    @inlinable
    public func listJobParameterDefinitionsPaginator(
        farmId: String,
        jobId: String,
        maxResults: Int? = nil,
        queueId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) -> AWSClient.PaginatorSequence<ListJobParameterDefinitionsRequest, ListJobParameterDefinitionsResponse> {
        let input = ListJobParameterDefinitionsRequest(
            farmId: farmId, 
            jobId: jobId, 
            maxResults: maxResults, 
            queueId: queueId
        )
        return self.listJobParameterDefinitionsPaginator(input, logger: logger)
    }

    /// Return PaginatorSequence for operation ``listJobs(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func listJobsPaginator(
        _ input: ListJobsRequest,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<ListJobsRequest, ListJobsResponse> {
        return .init(
            input: input,
            command: self.listJobs,
            inputKey: \ListJobsRequest.nextToken,
            outputKey: \ListJobsResponse.nextToken,
            logger: logger
        )
    }
    /// Return PaginatorSequence for operation ``listJobs(_:logger:)``.
    ///
    /// - Parameters:
    ///   - farmId: The farm ID for the jobs.
    ///   - maxResults: The maximum number of results to return. Use this parameter with NextToken to get results as a set of sequential pages.
    ///   - principalId: The principal ID of the members on the jobs.
    ///   - queueId: The queue ID for the job.
    ///   - logger: Logger used for logging
    @inlinable
    public func listJobsPaginator(
        farmId: String,
        maxResults: Int? = nil,
        principalId: String? = nil,
        queueId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) -> AWSClient.PaginatorSequence<ListJobsRequest, ListJobsResponse> {
        let input = ListJobsRequest(
            farmId: farmId, 
            maxResults: maxResults, 
            principalId: principalId, 
            queueId: queueId
        )
        return self.listJobsPaginator(input, logger: logger)
    }

    /// Return PaginatorSequence for operation ``listLicenseEndpoints(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func listLicenseEndpointsPaginator(
        _ input: ListLicenseEndpointsRequest,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<ListLicenseEndpointsRequest, ListLicenseEndpointsResponse> {
        return .init(
            input: input,
            command: self.listLicenseEndpoints,
            inputKey: \ListLicenseEndpointsRequest.nextToken,
            outputKey: \ListLicenseEndpointsResponse.nextToken,
            logger: logger
        )
    }
    /// Return PaginatorSequence for operation ``listLicenseEndpoints(_:logger:)``.
    ///
    /// - Parameters:
    ///   - maxResults: The maximum number of results to return. Use this parameter with NextToken to get results as a set of sequential pages.
    ///   - logger: Logger used for logging
    @inlinable
    public func listLicenseEndpointsPaginator(
        maxResults: Int? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) -> AWSClient.PaginatorSequence<ListLicenseEndpointsRequest, ListLicenseEndpointsResponse> {
        let input = ListLicenseEndpointsRequest(
            maxResults: maxResults
        )
        return self.listLicenseEndpointsPaginator(input, logger: logger)
    }

    /// Return PaginatorSequence for operation ``listMeteredProducts(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func listMeteredProductsPaginator(
        _ input: ListMeteredProductsRequest,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<ListMeteredProductsRequest, ListMeteredProductsResponse> {
        return .init(
            input: input,
            command: self.listMeteredProducts,
            inputKey: \ListMeteredProductsRequest.nextToken,
            outputKey: \ListMeteredProductsResponse.nextToken,
            logger: logger
        )
    }
    /// Return PaginatorSequence for operation ``listMeteredProducts(_:logger:)``.
    ///
    /// - Parameters:
    ///   - licenseEndpointId: The license endpoint ID to include on the list of metered products.
    ///   - maxResults: The maximum number of results to return. Use this parameter with NextToken to get results as a set of sequential pages.
    ///   - logger: Logger used for logging
    @inlinable
    public func listMeteredProductsPaginator(
        licenseEndpointId: String,
        maxResults: Int? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) -> AWSClient.PaginatorSequence<ListMeteredProductsRequest, ListMeteredProductsResponse> {
        let input = ListMeteredProductsRequest(
            licenseEndpointId: licenseEndpointId, 
            maxResults: maxResults
        )
        return self.listMeteredProductsPaginator(input, logger: logger)
    }

    /// Return PaginatorSequence for operation ``listMonitors(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func listMonitorsPaginator(
        _ input: ListMonitorsRequest,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<ListMonitorsRequest, ListMonitorsResponse> {
        return .init(
            input: input,
            command: self.listMonitors,
            inputKey: \ListMonitorsRequest.nextToken,
            outputKey: \ListMonitorsResponse.nextToken,
            logger: logger
        )
    }
    /// Return PaginatorSequence for operation ``listMonitors(_:logger:)``.
    ///
    /// - Parameters:
    ///   - maxResults: The maximum number of results to return. Use this parameter with NextToken to get results as a set of sequential pages.
    ///   - logger: Logger used for logging
    @inlinable
    public func listMonitorsPaginator(
        maxResults: Int? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) -> AWSClient.PaginatorSequence<ListMonitorsRequest, ListMonitorsResponse> {
        let input = ListMonitorsRequest(
            maxResults: maxResults
        )
        return self.listMonitorsPaginator(input, logger: logger)
    }

    /// Return PaginatorSequence for operation ``listQueueEnvironments(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func listQueueEnvironmentsPaginator(
        _ input: ListQueueEnvironmentsRequest,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<ListQueueEnvironmentsRequest, ListQueueEnvironmentsResponse> {
        return .init(
            input: input,
            command: self.listQueueEnvironments,
            inputKey: \ListQueueEnvironmentsRequest.nextToken,
            outputKey: \ListQueueEnvironmentsResponse.nextToken,
            logger: logger
        )
    }
    /// Return PaginatorSequence for operation ``listQueueEnvironments(_:logger:)``.
    ///
    /// - Parameters:
    ///   - farmId: The farm ID for the queue environment list.
    ///   - maxResults: The maximum number of results to return. Use this parameter with NextToken to get results as a set of sequential pages.
    ///   - queueId: The queue ID for the queue environment list.
    ///   - logger: Logger used for logging
    @inlinable
    public func listQueueEnvironmentsPaginator(
        farmId: String,
        maxResults: Int? = nil,
        queueId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) -> AWSClient.PaginatorSequence<ListQueueEnvironmentsRequest, ListQueueEnvironmentsResponse> {
        let input = ListQueueEnvironmentsRequest(
            farmId: farmId, 
            maxResults: maxResults, 
            queueId: queueId
        )
        return self.listQueueEnvironmentsPaginator(input, logger: logger)
    }

    /// Return PaginatorSequence for operation ``listQueueFleetAssociations(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func listQueueFleetAssociationsPaginator(
        _ input: ListQueueFleetAssociationsRequest,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<ListQueueFleetAssociationsRequest, ListQueueFleetAssociationsResponse> {
        return .init(
            input: input,
            command: self.listQueueFleetAssociations,
            inputKey: \ListQueueFleetAssociationsRequest.nextToken,
            outputKey: \ListQueueFleetAssociationsResponse.nextToken,
            logger: logger
        )
    }
    /// Return PaginatorSequence for operation ``listQueueFleetAssociations(_:logger:)``.
    ///
    /// - Parameters:
    ///   - farmId: The farm ID for the queue-fleet association list.
    ///   - fleetId: The fleet ID for the queue-fleet association list.
    ///   - maxResults: The maximum number of results to return. Use this parameter with NextToken to get results as a set of sequential pages.
    ///   - queueId: The queue ID for the queue-fleet association list.
    ///   - logger: Logger used for logging
    @inlinable
    public func listQueueFleetAssociationsPaginator(
        farmId: String,
        fleetId: String? = nil,
        maxResults: Int? = nil,
        queueId: String? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) -> AWSClient.PaginatorSequence<ListQueueFleetAssociationsRequest, ListQueueFleetAssociationsResponse> {
        let input = ListQueueFleetAssociationsRequest(
            farmId: farmId, 
            fleetId: fleetId, 
            maxResults: maxResults, 
            queueId: queueId
        )
        return self.listQueueFleetAssociationsPaginator(input, logger: logger)
    }

    /// Return PaginatorSequence for operation ``listQueueMembers(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func listQueueMembersPaginator(
        _ input: ListQueueMembersRequest,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<ListQueueMembersRequest, ListQueueMembersResponse> {
        return .init(
            input: input,
            command: self.listQueueMembers,
            inputKey: \ListQueueMembersRequest.nextToken,
            outputKey: \ListQueueMembersResponse.nextToken,
            logger: logger
        )
    }
    /// Return PaginatorSequence for operation ``listQueueMembers(_:logger:)``.
    ///
    /// - Parameters:
    ///   - farmId: The farm ID for the queue.
    ///   - maxResults: The maximum number of results to return. Use this parameter with NextToken to get results as a set of sequential pages.
    ///   - queueId: The queue ID to include on the list.
    ///   - logger: Logger used for logging
    @inlinable
    public func listQueueMembersPaginator(
        farmId: String,
        maxResults: Int? = nil,
        queueId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) -> AWSClient.PaginatorSequence<ListQueueMembersRequest, ListQueueMembersResponse> {
        let input = ListQueueMembersRequest(
            farmId: farmId, 
            maxResults: maxResults, 
            queueId: queueId
        )
        return self.listQueueMembersPaginator(input, logger: logger)
    }

    /// Return PaginatorSequence for operation ``listQueues(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func listQueuesPaginator(
        _ input: ListQueuesRequest,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<ListQueuesRequest, ListQueuesResponse> {
        return .init(
            input: input,
            command: self.listQueues,
            inputKey: \ListQueuesRequest.nextToken,
            outputKey: \ListQueuesResponse.nextToken,
            logger: logger
        )
    }
    /// Return PaginatorSequence for operation ``listQueues(_:logger:)``.
    ///
    /// - Parameters:
    ///   - farmId: The farm ID of the queue.
    ///   - maxResults: The maximum number of results to return. Use this parameter with NextToken to get results as a set of sequential pages.
    ///   - principalId: The principal IDs to include in the list of queues.
    ///   - status: The status of the queues listed.    ACTIVE–The queues are active.    SCHEDULING–The queues are scheduling.    SCHEDULING_BLOCKED–The queue scheduling is blocked for these queues.
    ///   - logger: Logger used for logging
    @inlinable
    public func listQueuesPaginator(
        farmId: String,
        maxResults: Int? = nil,
        principalId: String? = nil,
        status: QueueStatus? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) -> AWSClient.PaginatorSequence<ListQueuesRequest, ListQueuesResponse> {
        let input = ListQueuesRequest(
            farmId: farmId, 
            maxResults: maxResults, 
            principalId: principalId, 
            status: status
        )
        return self.listQueuesPaginator(input, logger: logger)
    }

    /// Return PaginatorSequence for operation ``listSessionActions(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func listSessionActionsPaginator(
        _ input: ListSessionActionsRequest,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<ListSessionActionsRequest, ListSessionActionsResponse> {
        return .init(
            input: input,
            command: self.listSessionActions,
            inputKey: \ListSessionActionsRequest.nextToken,
            outputKey: \ListSessionActionsResponse.nextToken,
            logger: logger
        )
    }
    /// Return PaginatorSequence for operation ``listSessionActions(_:logger:)``.
    ///
    /// - Parameters:
    ///   - farmId: The farm ID for the session actions list.
    ///   - jobId: The job ID for the session actions list.
    ///   - maxResults: The maximum number of results to return. Use this parameter with NextToken to get results as a set of sequential pages.
    ///   - queueId: The queue ID for the session actions list.
    ///   - sessionId: The session ID to include on the sessions action list.
    ///   - taskId: The task ID for the session actions list.
    ///   - logger: Logger used for logging
    @inlinable
    public func listSessionActionsPaginator(
        farmId: String,
        jobId: String,
        maxResults: Int? = nil,
        queueId: String,
        sessionId: String? = nil,
        taskId: String? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) -> AWSClient.PaginatorSequence<ListSessionActionsRequest, ListSessionActionsResponse> {
        let input = ListSessionActionsRequest(
            farmId: farmId, 
            jobId: jobId, 
            maxResults: maxResults, 
            queueId: queueId, 
            sessionId: sessionId, 
            taskId: taskId
        )
        return self.listSessionActionsPaginator(input, logger: logger)
    }

    /// Return PaginatorSequence for operation ``listSessions(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func listSessionsPaginator(
        _ input: ListSessionsRequest,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<ListSessionsRequest, ListSessionsResponse> {
        return .init(
            input: input,
            command: self.listSessions,
            inputKey: \ListSessionsRequest.nextToken,
            outputKey: \ListSessionsResponse.nextToken,
            logger: logger
        )
    }
    /// Return PaginatorSequence for operation ``listSessions(_:logger:)``.
    ///
    /// - Parameters:
    ///   - farmId: The farm ID for the list of sessions.
    ///   - jobId: The job ID for the list of sessions.
    ///   - maxResults: The maximum number of results to return. Use this parameter with NextToken to get results as a set of sequential pages.
    ///   - queueId: The queue ID for the list of sessions
    ///   - logger: Logger used for logging
    @inlinable
    public func listSessionsPaginator(
        farmId: String,
        jobId: String,
        maxResults: Int? = nil,
        queueId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) -> AWSClient.PaginatorSequence<ListSessionsRequest, ListSessionsResponse> {
        let input = ListSessionsRequest(
            farmId: farmId, 
            jobId: jobId, 
            maxResults: maxResults, 
            queueId: queueId
        )
        return self.listSessionsPaginator(input, logger: logger)
    }

    /// Return PaginatorSequence for operation ``listSessionsForWorker(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func listSessionsForWorkerPaginator(
        _ input: ListSessionsForWorkerRequest,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<ListSessionsForWorkerRequest, ListSessionsForWorkerResponse> {
        return .init(
            input: input,
            command: self.listSessionsForWorker,
            inputKey: \ListSessionsForWorkerRequest.nextToken,
            outputKey: \ListSessionsForWorkerResponse.nextToken,
            logger: logger
        )
    }
    /// Return PaginatorSequence for operation ``listSessionsForWorker(_:logger:)``.
    ///
    /// - Parameters:
    ///   - farmId: The farm ID for the session.
    ///   - fleetId: The fleet ID for the session.
    ///   - maxResults: The maximum number of results to return. Use this parameter with NextToken to get results as a set of sequential pages.
    ///   - workerId: The worker ID for the session.
    ///   - logger: Logger used for logging
    @inlinable
    public func listSessionsForWorkerPaginator(
        farmId: String,
        fleetId: String,
        maxResults: Int? = nil,
        workerId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) -> AWSClient.PaginatorSequence<ListSessionsForWorkerRequest, ListSessionsForWorkerResponse> {
        let input = ListSessionsForWorkerRequest(
            farmId: farmId, 
            fleetId: fleetId, 
            maxResults: maxResults, 
            workerId: workerId
        )
        return self.listSessionsForWorkerPaginator(input, logger: logger)
    }

    /// Return PaginatorSequence for operation ``listStepConsumers(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func listStepConsumersPaginator(
        _ input: ListStepConsumersRequest,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<ListStepConsumersRequest, ListStepConsumersResponse> {
        return .init(
            input: input,
            command: self.listStepConsumers,
            inputKey: \ListStepConsumersRequest.nextToken,
            outputKey: \ListStepConsumersResponse.nextToken,
            logger: logger
        )
    }
    /// Return PaginatorSequence for operation ``listStepConsumers(_:logger:)``.
    ///
    /// - Parameters:
    ///   - farmId: The farm ID for the list of step consumers.
    ///   - jobId: The job ID for the step consumer.
    ///   - maxResults: The maximum number of results to return. Use this parameter with NextToken to get results as a set of sequential pages.
    ///   - queueId: The queue ID for the step consumer.
    ///   - stepId: The step ID to include on the list.
    ///   - logger: Logger used for logging
    @inlinable
    public func listStepConsumersPaginator(
        farmId: String,
        jobId: String,
        maxResults: Int? = nil,
        queueId: String,
        stepId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) -> AWSClient.PaginatorSequence<ListStepConsumersRequest, ListStepConsumersResponse> {
        let input = ListStepConsumersRequest(
            farmId: farmId, 
            jobId: jobId, 
            maxResults: maxResults, 
            queueId: queueId, 
            stepId: stepId
        )
        return self.listStepConsumersPaginator(input, logger: logger)
    }

    /// Return PaginatorSequence for operation ``listStepDependencies(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func listStepDependenciesPaginator(
        _ input: ListStepDependenciesRequest,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<ListStepDependenciesRequest, ListStepDependenciesResponse> {
        return .init(
            input: input,
            command: self.listStepDependencies,
            inputKey: \ListStepDependenciesRequest.nextToken,
            outputKey: \ListStepDependenciesResponse.nextToken,
            logger: logger
        )
    }
    /// Return PaginatorSequence for operation ``listStepDependencies(_:logger:)``.
    ///
    /// - Parameters:
    ///   - farmId: The farm ID for the step dependencies list.
    ///   - jobId: The job ID for the step dependencies list.
    ///   - maxResults: The maximum number of results to return. Use this parameter with NextToken to get results as a set of sequential pages.
    ///   - queueId: The queue ID for the step dependencies list.
    ///   - stepId: The step ID to include on the list.
    ///   - logger: Logger used for logging
    @inlinable
    public func listStepDependenciesPaginator(
        farmId: String,
        jobId: String,
        maxResults: Int? = nil,
        queueId: String,
        stepId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) -> AWSClient.PaginatorSequence<ListStepDependenciesRequest, ListStepDependenciesResponse> {
        let input = ListStepDependenciesRequest(
            farmId: farmId, 
            jobId: jobId, 
            maxResults: maxResults, 
            queueId: queueId, 
            stepId: stepId
        )
        return self.listStepDependenciesPaginator(input, logger: logger)
    }

    /// Return PaginatorSequence for operation ``listSteps(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func listStepsPaginator(
        _ input: ListStepsRequest,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<ListStepsRequest, ListStepsResponse> {
        return .init(
            input: input,
            command: self.listSteps,
            inputKey: \ListStepsRequest.nextToken,
            outputKey: \ListStepsResponse.nextToken,
            logger: logger
        )
    }
    /// Return PaginatorSequence for operation ``listSteps(_:logger:)``.
    ///
    /// - Parameters:
    ///   - farmId: The farm ID to include on the list of steps.
    ///   - jobId: The job ID to include on the list of steps.
    ///   - maxResults: The maximum number of results to return. Use this parameter with NextToken to get results as a set of sequential pages.
    ///   - queueId: The queue ID to include on the list of steps.
    ///   - logger: Logger used for logging
    @inlinable
    public func listStepsPaginator(
        farmId: String,
        jobId: String,
        maxResults: Int? = nil,
        queueId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) -> AWSClient.PaginatorSequence<ListStepsRequest, ListStepsResponse> {
        let input = ListStepsRequest(
            farmId: farmId, 
            jobId: jobId, 
            maxResults: maxResults, 
            queueId: queueId
        )
        return self.listStepsPaginator(input, logger: logger)
    }

    /// Return PaginatorSequence for operation ``listStorageProfiles(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func listStorageProfilesPaginator(
        _ input: ListStorageProfilesRequest,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<ListStorageProfilesRequest, ListStorageProfilesResponse> {
        return .init(
            input: input,
            command: self.listStorageProfiles,
            inputKey: \ListStorageProfilesRequest.nextToken,
            outputKey: \ListStorageProfilesResponse.nextToken,
            logger: logger
        )
    }
    /// Return PaginatorSequence for operation ``listStorageProfiles(_:logger:)``.
    ///
    /// - Parameters:
    ///   - farmId: The farm ID of the storage profile.
    ///   - maxResults: The maximum number of results to return. Use this parameter with NextToken to get results as a set of sequential pages.
    ///   - logger: Logger used for logging
    @inlinable
    public func listStorageProfilesPaginator(
        farmId: String,
        maxResults: Int? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) -> AWSClient.PaginatorSequence<ListStorageProfilesRequest, ListStorageProfilesResponse> {
        let input = ListStorageProfilesRequest(
            farmId: farmId, 
            maxResults: maxResults
        )
        return self.listStorageProfilesPaginator(input, logger: logger)
    }

    /// Return PaginatorSequence for operation ``listStorageProfilesForQueue(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func listStorageProfilesForQueuePaginator(
        _ input: ListStorageProfilesForQueueRequest,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<ListStorageProfilesForQueueRequest, ListStorageProfilesForQueueResponse> {
        return .init(
            input: input,
            command: self.listStorageProfilesForQueue,
            inputKey: \ListStorageProfilesForQueueRequest.nextToken,
            outputKey: \ListStorageProfilesForQueueResponse.nextToken,
            logger: logger
        )
    }
    /// Return PaginatorSequence for operation ``listStorageProfilesForQueue(_:logger:)``.
    ///
    /// - Parameters:
    ///   - farmId: The farm ID of the queue's storage profile.
    ///   - maxResults: The maximum number of results to return. Use this parameter with NextToken to get results as a set of sequential pages.
    ///   - queueId: The queue ID for the storage profile.
    ///   - logger: Logger used for logging
    @inlinable
    public func listStorageProfilesForQueuePaginator(
        farmId: String,
        maxResults: Int? = nil,
        queueId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) -> AWSClient.PaginatorSequence<ListStorageProfilesForQueueRequest, ListStorageProfilesForQueueResponse> {
        let input = ListStorageProfilesForQueueRequest(
            farmId: farmId, 
            maxResults: maxResults, 
            queueId: queueId
        )
        return self.listStorageProfilesForQueuePaginator(input, logger: logger)
    }

    /// Return PaginatorSequence for operation ``listTasks(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func listTasksPaginator(
        _ input: ListTasksRequest,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<ListTasksRequest, ListTasksResponse> {
        return .init(
            input: input,
            command: self.listTasks,
            inputKey: \ListTasksRequest.nextToken,
            outputKey: \ListTasksResponse.nextToken,
            logger: logger
        )
    }
    /// Return PaginatorSequence for operation ``listTasks(_:logger:)``.
    ///
    /// - Parameters:
    ///   - farmId: The farm ID connected to the tasks.
    ///   - jobId: The job ID for the tasks.
    ///   - maxResults: The maximum number of results to return. Use this parameter with NextToken to get results as a set of sequential pages.
    ///   - queueId: The queue ID connected to the tasks.
    ///   - stepId: The step ID for the tasks.
    ///   - logger: Logger used for logging
    @inlinable
    public func listTasksPaginator(
        farmId: String,
        jobId: String,
        maxResults: Int? = nil,
        queueId: String,
        stepId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) -> AWSClient.PaginatorSequence<ListTasksRequest, ListTasksResponse> {
        let input = ListTasksRequest(
            farmId: farmId, 
            jobId: jobId, 
            maxResults: maxResults, 
            queueId: queueId, 
            stepId: stepId
        )
        return self.listTasksPaginator(input, logger: logger)
    }

    /// Return PaginatorSequence for operation ``listWorkers(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func listWorkersPaginator(
        _ input: ListWorkersRequest,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<ListWorkersRequest, ListWorkersResponse> {
        return .init(
            input: input,
            command: self.listWorkers,
            inputKey: \ListWorkersRequest.nextToken,
            outputKey: \ListWorkersResponse.nextToken,
            logger: logger
        )
    }
    /// Return PaginatorSequence for operation ``listWorkers(_:logger:)``.
    ///
    /// - Parameters:
    ///   - farmId: The farm ID connected to the workers.
    ///   - fleetId: The fleet ID of the workers.
    ///   - maxResults: The maximum number of results to return. Use this parameter with NextToken to get results as a set of sequential pages.
    ///   - logger: Logger used for logging
    @inlinable
    public func listWorkersPaginator(
        farmId: String,
        fleetId: String,
        maxResults: Int? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) -> AWSClient.PaginatorSequence<ListWorkersRequest, ListWorkersResponse> {
        let input = ListWorkersRequest(
            farmId: farmId, 
            fleetId: fleetId, 
            maxResults: maxResults
        )
        return self.listWorkersPaginator(input, logger: logger)
    }
}

extension Deadline.GetSessionsStatisticsAggregationRequest: AWSPaginateToken {
    @inlinable
    public func usingPaginationToken(_ token: String) -> Deadline.GetSessionsStatisticsAggregationRequest {
        return .init(
            aggregationId: self.aggregationId,
            farmId: self.farmId,
            maxResults: self.maxResults,
            nextToken: token
        )
    }
}

extension Deadline.ListAvailableMeteredProductsRequest: AWSPaginateToken {
    @inlinable
    public func usingPaginationToken(_ token: String) -> Deadline.ListAvailableMeteredProductsRequest {
        return .init(
            maxResults: self.maxResults,
            nextToken: token
        )
    }
}

extension Deadline.ListBudgetsRequest: AWSPaginateToken {
    @inlinable
    public func usingPaginationToken(_ token: String) -> Deadline.ListBudgetsRequest {
        return .init(
            farmId: self.farmId,
            maxResults: self.maxResults,
            nextToken: token,
            status: self.status
        )
    }
}

extension Deadline.ListFarmMembersRequest: AWSPaginateToken {
    @inlinable
    public func usingPaginationToken(_ token: String) -> Deadline.ListFarmMembersRequest {
        return .init(
            farmId: self.farmId,
            maxResults: self.maxResults,
            nextToken: token
        )
    }
}

extension Deadline.ListFarmsRequest: AWSPaginateToken {
    @inlinable
    public func usingPaginationToken(_ token: String) -> Deadline.ListFarmsRequest {
        return .init(
            maxResults: self.maxResults,
            nextToken: token,
            principalId: self.principalId
        )
    }
}

extension Deadline.ListFleetMembersRequest: AWSPaginateToken {
    @inlinable
    public func usingPaginationToken(_ token: String) -> Deadline.ListFleetMembersRequest {
        return .init(
            farmId: self.farmId,
            fleetId: self.fleetId,
            maxResults: self.maxResults,
            nextToken: token
        )
    }
}

extension Deadline.ListFleetsRequest: AWSPaginateToken {
    @inlinable
    public func usingPaginationToken(_ token: String) -> Deadline.ListFleetsRequest {
        return .init(
            displayName: self.displayName,
            farmId: self.farmId,
            maxResults: self.maxResults,
            nextToken: token,
            principalId: self.principalId,
            status: self.status
        )
    }
}

extension Deadline.ListJobMembersRequest: AWSPaginateToken {
    @inlinable
    public func usingPaginationToken(_ token: String) -> Deadline.ListJobMembersRequest {
        return .init(
            farmId: self.farmId,
            jobId: self.jobId,
            maxResults: self.maxResults,
            nextToken: token,
            queueId: self.queueId
        )
    }
}

extension Deadline.ListJobParameterDefinitionsRequest: AWSPaginateToken {
    @inlinable
    public func usingPaginationToken(_ token: String) -> Deadline.ListJobParameterDefinitionsRequest {
        return .init(
            farmId: self.farmId,
            jobId: self.jobId,
            maxResults: self.maxResults,
            nextToken: token,
            queueId: self.queueId
        )
    }
}

extension Deadline.ListJobsRequest: AWSPaginateToken {
    @inlinable
    public func usingPaginationToken(_ token: String) -> Deadline.ListJobsRequest {
        return .init(
            farmId: self.farmId,
            maxResults: self.maxResults,
            nextToken: token,
            principalId: self.principalId,
            queueId: self.queueId
        )
    }
}

extension Deadline.ListLicenseEndpointsRequest: AWSPaginateToken {
    @inlinable
    public func usingPaginationToken(_ token: String) -> Deadline.ListLicenseEndpointsRequest {
        return .init(
            maxResults: self.maxResults,
            nextToken: token
        )
    }
}

extension Deadline.ListMeteredProductsRequest: AWSPaginateToken {
    @inlinable
    public func usingPaginationToken(_ token: String) -> Deadline.ListMeteredProductsRequest {
        return .init(
            licenseEndpointId: self.licenseEndpointId,
            maxResults: self.maxResults,
            nextToken: token
        )
    }
}

extension Deadline.ListMonitorsRequest: AWSPaginateToken {
    @inlinable
    public func usingPaginationToken(_ token: String) -> Deadline.ListMonitorsRequest {
        return .init(
            maxResults: self.maxResults,
            nextToken: token
        )
    }
}

extension Deadline.ListQueueEnvironmentsRequest: AWSPaginateToken {
    @inlinable
    public func usingPaginationToken(_ token: String) -> Deadline.ListQueueEnvironmentsRequest {
        return .init(
            farmId: self.farmId,
            maxResults: self.maxResults,
            nextToken: token,
            queueId: self.queueId
        )
    }
}

extension Deadline.ListQueueFleetAssociationsRequest: AWSPaginateToken {
    @inlinable
    public func usingPaginationToken(_ token: String) -> Deadline.ListQueueFleetAssociationsRequest {
        return .init(
            farmId: self.farmId,
            fleetId: self.fleetId,
            maxResults: self.maxResults,
            nextToken: token,
            queueId: self.queueId
        )
    }
}

extension Deadline.ListQueueMembersRequest: AWSPaginateToken {
    @inlinable
    public func usingPaginationToken(_ token: String) -> Deadline.ListQueueMembersRequest {
        return .init(
            farmId: self.farmId,
            maxResults: self.maxResults,
            nextToken: token,
            queueId: self.queueId
        )
    }
}

extension Deadline.ListQueuesRequest: AWSPaginateToken {
    @inlinable
    public func usingPaginationToken(_ token: String) -> Deadline.ListQueuesRequest {
        return .init(
            farmId: self.farmId,
            maxResults: self.maxResults,
            nextToken: token,
            principalId: self.principalId,
            status: self.status
        )
    }
}

extension Deadline.ListSessionActionsRequest: AWSPaginateToken {
    @inlinable
    public func usingPaginationToken(_ token: String) -> Deadline.ListSessionActionsRequest {
        return .init(
            farmId: self.farmId,
            jobId: self.jobId,
            maxResults: self.maxResults,
            nextToken: token,
            queueId: self.queueId,
            sessionId: self.sessionId,
            taskId: self.taskId
        )
    }
}

extension Deadline.ListSessionsForWorkerRequest: AWSPaginateToken {
    @inlinable
    public func usingPaginationToken(_ token: String) -> Deadline.ListSessionsForWorkerRequest {
        return .init(
            farmId: self.farmId,
            fleetId: self.fleetId,
            maxResults: self.maxResults,
            nextToken: token,
            workerId: self.workerId
        )
    }
}

extension Deadline.ListSessionsRequest: AWSPaginateToken {
    @inlinable
    public func usingPaginationToken(_ token: String) -> Deadline.ListSessionsRequest {
        return .init(
            farmId: self.farmId,
            jobId: self.jobId,
            maxResults: self.maxResults,
            nextToken: token,
            queueId: self.queueId
        )
    }
}

extension Deadline.ListStepConsumersRequest: AWSPaginateToken {
    @inlinable
    public func usingPaginationToken(_ token: String) -> Deadline.ListStepConsumersRequest {
        return .init(
            farmId: self.farmId,
            jobId: self.jobId,
            maxResults: self.maxResults,
            nextToken: token,
            queueId: self.queueId,
            stepId: self.stepId
        )
    }
}

extension Deadline.ListStepDependenciesRequest: AWSPaginateToken {
    @inlinable
    public func usingPaginationToken(_ token: String) -> Deadline.ListStepDependenciesRequest {
        return .init(
            farmId: self.farmId,
            jobId: self.jobId,
            maxResults: self.maxResults,
            nextToken: token,
            queueId: self.queueId,
            stepId: self.stepId
        )
    }
}

extension Deadline.ListStepsRequest: AWSPaginateToken {
    @inlinable
    public func usingPaginationToken(_ token: String) -> Deadline.ListStepsRequest {
        return .init(
            farmId: self.farmId,
            jobId: self.jobId,
            maxResults: self.maxResults,
            nextToken: token,
            queueId: self.queueId
        )
    }
}

extension Deadline.ListStorageProfilesForQueueRequest: AWSPaginateToken {
    @inlinable
    public func usingPaginationToken(_ token: String) -> Deadline.ListStorageProfilesForQueueRequest {
        return .init(
            farmId: self.farmId,
            maxResults: self.maxResults,
            nextToken: token,
            queueId: self.queueId
        )
    }
}

extension Deadline.ListStorageProfilesRequest: AWSPaginateToken {
    @inlinable
    public func usingPaginationToken(_ token: String) -> Deadline.ListStorageProfilesRequest {
        return .init(
            farmId: self.farmId,
            maxResults: self.maxResults,
            nextToken: token
        )
    }
}

extension Deadline.ListTasksRequest: AWSPaginateToken {
    @inlinable
    public func usingPaginationToken(_ token: String) -> Deadline.ListTasksRequest {
        return .init(
            farmId: self.farmId,
            jobId: self.jobId,
            maxResults: self.maxResults,
            nextToken: token,
            queueId: self.queueId,
            stepId: self.stepId
        )
    }
}

extension Deadline.ListWorkersRequest: AWSPaginateToken {
    @inlinable
    public func usingPaginationToken(_ token: String) -> Deadline.ListWorkersRequest {
        return .init(
            farmId: self.farmId,
            fleetId: self.fleetId,
            maxResults: self.maxResults,
            nextToken: token
        )
    }
}

// MARK: Waiters

@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension Deadline {
    /// Waiter for operation ``getFleet(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func waitUntilFleetActive(
        _ input: GetFleetRequest,
        maxWaitTime: TimeAmount? = nil,
        logger: Logger = AWSClient.loggingDisabled
    ) async throws {
        let waiter = AWSClient.Waiter<GetFleetRequest, _>(
            acceptors: [
                .init(state: .success, matcher: try! JMESPathMatcher("status", expected: "ACTIVE")),
                .init(state: .failure, matcher: try! JMESPathMatcher("status", expected: "CREATE_FAILED")),
                .init(state: .failure, matcher: try! JMESPathMatcher("status", expected: "UPDATE_FAILED")),
            ],
            minDelayTime: .seconds(5),
            maxDelayTime: .seconds(900),
            command: self.getFleet
        )
        return try await self.client.waitUntil(input, waiter: waiter, maxWaitTime: maxWaitTime, logger: logger)
    }
    /// Waiter for operation ``getFleet(_:logger:)``.
    ///
    /// - Parameters:
    ///   - farmId: The farm ID of the farm in the fleet.
    ///   - fleetId: The fleet ID of the fleet to get.
    ///   - logger: Logger used for logging
    @inlinable
    public func waitUntilFleetActive(
        farmId: String,
        fleetId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws {
        let input = GetFleetRequest(
            farmId: farmId, 
            fleetId: fleetId
        )
        try await self.waitUntilFleetActive(input, logger: logger)
    }

    /// Waiter for operation ``getJob(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func waitUntilJobCreateComplete(
        _ input: GetJobRequest,
        maxWaitTime: TimeAmount? = nil,
        logger: Logger = AWSClient.loggingDisabled
    ) async throws {
        let waiter = AWSClient.Waiter<GetJobRequest, _>(
            acceptors: [
                .init(state: .success, matcher: try! JMESPathMatcher("lifecycleStatus", expected: "CREATE_COMPLETE")),
                .init(state: .success, matcher: try! JMESPathMatcher("lifecycleStatus", expected: "UPDATE_IN_PROGRESS")),
                .init(state: .success, matcher: try! JMESPathMatcher("lifecycleStatus", expected: "UPDATE_FAILED")),
                .init(state: .success, matcher: try! JMESPathMatcher("lifecycleStatus", expected: "UPDATE_SUCCEEDED")),
                .init(state: .failure, matcher: try! JMESPathMatcher("lifecycleStatus", expected: "UPLOAD_FAILED")),
                .init(state: .failure, matcher: try! JMESPathMatcher("lifecycleStatus", expected: "CREATE_FAILED")),
            ],
            minDelayTime: .seconds(1),
            command: self.getJob
        )
        return try await self.client.waitUntil(input, waiter: waiter, maxWaitTime: maxWaitTime, logger: logger)
    }
    /// Waiter for operation ``getJob(_:logger:)``.
    ///
    /// - Parameters:
    ///   - farmId: The farm ID of the farm in the job.
    ///   - jobId: The job ID.
    ///   - queueId: The queue ID associated with the job.
    ///   - logger: Logger used for logging
    @inlinable
    public func waitUntilJobCreateComplete(
        farmId: String,
        jobId: String,
        queueId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws {
        let input = GetJobRequest(
            farmId: farmId, 
            jobId: jobId, 
            queueId: queueId
        )
        try await self.waitUntilJobCreateComplete(input, logger: logger)
    }

    /// Waiter for operation ``getLicenseEndpoint(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func waitUntilLicenseEndpointDeleted(
        _ input: GetLicenseEndpointRequest,
        maxWaitTime: TimeAmount? = nil,
        logger: Logger = AWSClient.loggingDisabled
    ) async throws {
        let waiter = AWSClient.Waiter<GetLicenseEndpointRequest, _>(
            acceptors: [
                .init(state: .success, matcher: AWSErrorCodeMatcher("ResourceNotFoundException")),
                .init(state: .failure, matcher: try! JMESPathMatcher("status", expected: "NOT_READY")),
            ],
            minDelayTime: .seconds(10),
            maxDelayTime: .seconds(2340),
            command: self.getLicenseEndpoint
        )
        return try await self.client.waitUntil(input, waiter: waiter, maxWaitTime: maxWaitTime, logger: logger)
    }
    /// Waiter for operation ``getLicenseEndpoint(_:logger:)``.
    ///
    /// - Parameters:
    ///   - licenseEndpointId: The license endpoint ID.
    ///   - logger: Logger used for logging
    @inlinable
    public func waitUntilLicenseEndpointDeleted(
        licenseEndpointId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws {
        let input = GetLicenseEndpointRequest(
            licenseEndpointId: licenseEndpointId
        )
        try await self.waitUntilLicenseEndpointDeleted(input, logger: logger)
    }

    /// Waiter for operation ``getLicenseEndpoint(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func waitUntilLicenseEndpointValid(
        _ input: GetLicenseEndpointRequest,
        maxWaitTime: TimeAmount? = nil,
        logger: Logger = AWSClient.loggingDisabled
    ) async throws {
        let waiter = AWSClient.Waiter<GetLicenseEndpointRequest, _>(
            acceptors: [
                .init(state: .success, matcher: try! JMESPathMatcher("status", expected: "READY")),
                .init(state: .failure, matcher: try! JMESPathMatcher("status", expected: "NOT_READY")),
            ],
            minDelayTime: .seconds(10),
            maxDelayTime: .seconds(1140),
            command: self.getLicenseEndpoint
        )
        return try await self.client.waitUntil(input, waiter: waiter, maxWaitTime: maxWaitTime, logger: logger)
    }
    /// Waiter for operation ``getLicenseEndpoint(_:logger:)``.
    ///
    /// - Parameters:
    ///   - licenseEndpointId: The license endpoint ID.
    ///   - logger: Logger used for logging
    @inlinable
    public func waitUntilLicenseEndpointValid(
        licenseEndpointId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws {
        let input = GetLicenseEndpointRequest(
            licenseEndpointId: licenseEndpointId
        )
        try await self.waitUntilLicenseEndpointValid(input, logger: logger)
    }

    /// Waiter for operation ``getQueueFleetAssociation(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func waitUntilQueueFleetAssociationStopped(
        _ input: GetQueueFleetAssociationRequest,
        maxWaitTime: TimeAmount? = nil,
        logger: Logger = AWSClient.loggingDisabled
    ) async throws {
        let waiter = AWSClient.Waiter<GetQueueFleetAssociationRequest, _>(
            acceptors: [
                .init(state: .success, matcher: try! JMESPathMatcher("status", expected: "STOPPED")),
            ],
            minDelayTime: .seconds(10),
            maxDelayTime: .seconds(600),
            command: self.getQueueFleetAssociation
        )
        return try await self.client.waitUntil(input, waiter: waiter, maxWaitTime: maxWaitTime, logger: logger)
    }
    /// Waiter for operation ``getQueueFleetAssociation(_:logger:)``.
    ///
    /// - Parameters:
    ///   - farmId: The farm ID of the farm that contains the queue-fleet association.
    ///   - fleetId: The fleet ID for the queue-fleet association.
    ///   - queueId: The queue ID for the queue-fleet association.
    ///   - logger: Logger used for logging
    @inlinable
    public func waitUntilQueueFleetAssociationStopped(
        farmId: String,
        fleetId: String,
        queueId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws {
        let input = GetQueueFleetAssociationRequest(
            farmId: farmId, 
            fleetId: fleetId, 
            queueId: queueId
        )
        try await self.waitUntilQueueFleetAssociationStopped(input, logger: logger)
    }

    /// Waiter for operation ``getQueue(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func waitUntilQueueScheduling(
        _ input: GetQueueRequest,
        maxWaitTime: TimeAmount? = nil,
        logger: Logger = AWSClient.loggingDisabled
    ) async throws {
        let waiter = AWSClient.Waiter<GetQueueRequest, _>(
            acceptors: [
                .init(state: .success, matcher: try! JMESPathMatcher("status", expected: "SCHEDULING")),
            ],
            minDelayTime: .seconds(10),
            maxDelayTime: .seconds(700),
            command: self.getQueue
        )
        return try await self.client.waitUntil(input, waiter: waiter, maxWaitTime: maxWaitTime, logger: logger)
    }
    /// Waiter for operation ``getQueue(_:logger:)``.
    ///
    /// - Parameters:
    ///   - farmId: The farm ID of the farm in the queue.
    ///   - queueId: The queue ID for the queue to retrieve.
    ///   - logger: Logger used for logging
    @inlinable
    public func waitUntilQueueScheduling(
        farmId: String,
        queueId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws {
        let input = GetQueueRequest(
            farmId: farmId, 
            queueId: queueId
        )
        try await self.waitUntilQueueScheduling(input, logger: logger)
    }

    /// Waiter for operation ``getQueue(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func waitUntilQueueSchedulingBlocked(
        _ input: GetQueueRequest,
        maxWaitTime: TimeAmount? = nil,
        logger: Logger = AWSClient.loggingDisabled
    ) async throws {
        let waiter = AWSClient.Waiter<GetQueueRequest, _>(
            acceptors: [
                .init(state: .success, matcher: try! JMESPathMatcher("status", expected: "SCHEDULING_BLOCKED")),
            ],
            minDelayTime: .seconds(10),
            maxDelayTime: .seconds(300),
            command: self.getQueue
        )
        return try await self.client.waitUntil(input, waiter: waiter, maxWaitTime: maxWaitTime, logger: logger)
    }
    /// Waiter for operation ``getQueue(_:logger:)``.
    ///
    /// - Parameters:
    ///   - farmId: The farm ID of the farm in the queue.
    ///   - queueId: The queue ID for the queue to retrieve.
    ///   - logger: Logger used for logging
    @inlinable
    public func waitUntilQueueSchedulingBlocked(
        farmId: String,
        queueId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws {
        let input = GetQueueRequest(
            farmId: farmId, 
            queueId: queueId
        )
        try await self.waitUntilQueueSchedulingBlocked(input, logger: logger)
    }
}
