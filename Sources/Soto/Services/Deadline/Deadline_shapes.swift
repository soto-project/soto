//===----------------------------------------------------------------------===//
//
// This source file is part of the Soto for AWS open source project
//
// Copyright (c) 2017-2024 the Soto project authors
// Licensed under Apache License v2.0
//
// See LICENSE.txt for license information
// See CONTRIBUTORS.txt for the list of Soto project authors
//
// SPDX-License-Identifier: Apache-2.0
//
//===----------------------------------------------------------------------===//

// THIS FILE IS AUTOMATICALLY GENERATED by https://github.com/soto-project/soto-codegenerator.
// DO NOT EDIT.

#if canImport(FoundationEssentials)
import FoundationEssentials
#else
import Foundation
#endif
@_spi(SotoInternal) import SotoCore

extension Deadline {
    // MARK: Enums

    public enum AcceleratorName: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case a10g = "a10g"
        case l4 = "l4"
        case l40s = "l40s"
        case t4 = "t4"
        public var description: String { return self.rawValue }
    }

    public enum AcceleratorType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        /// GPU accelerator type.
        case gpu = "gpu"
        public var description: String { return self.rawValue }
    }

    public enum AutoScalingMode: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case eventBasedAutoScaling = "EVENT_BASED_AUTO_SCALING"
        case noScaling = "NO_SCALING"
        public var description: String { return self.rawValue }
    }

    public enum AutoScalingStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case growing = "GROWING"
        case shrinking = "SHRINKING"
        case steady = "STEADY"
        public var description: String { return self.rawValue }
    }

    public enum BudgetActionType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case stopSchedulingAndCancelTasks = "STOP_SCHEDULING_AND_CANCEL_TASKS"
        case stopSchedulingAndCompleteTasks = "STOP_SCHEDULING_AND_COMPLETE_TASKS"
        public var description: String { return self.rawValue }
    }

    public enum BudgetStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case active = "ACTIVE"
        case inactive = "INACTIVE"
        public var description: String { return self.rawValue }
    }

    public enum ComparisonOperator: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case equal = "EQUAL"
        case greaterThan = "GREATER_THAN"
        case greaterThanEqualTo = "GREATER_THAN_EQUAL_TO"
        case lessThan = "LESS_THAN"
        case lessThanEqualTo = "LESS_THAN_EQUAL_TO"
        case notEqual = "NOT_EQUAL"
        public var description: String { return self.rawValue }
    }

    public enum CompletedStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case canceled = "CANCELED"
        case failed = "FAILED"
        case interrupted = "INTERRUPTED"
        case neverAttempted = "NEVER_ATTEMPTED"
        case succeeded = "SUCCEEDED"
        public var description: String { return self.rawValue }
    }

    public enum ConflictExceptionReason: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case concurrentModification = "CONCURRENT_MODIFICATION"
        case conflictException = "CONFLICT_EXCEPTION"
        case resourceAlreadyExists = "RESOURCE_ALREADY_EXISTS"
        case resourceInUse = "RESOURCE_IN_USE"
        case statusConflict = "STATUS_CONFLICT"
        public var description: String { return self.rawValue }
    }

    public enum CpuArchitectureType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case arm64 = "arm64"
        case x8664 = "x86_64"
        public var description: String { return self.rawValue }
    }

    public enum CreateJobTargetTaskRunStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case ready = "READY"
        case suspended = "SUSPENDED"
        public var description: String { return self.rawValue }
    }

    public enum CustomerManagedFleetOperatingSystemFamily: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case linux = "LINUX"
        case macos = "MACOS"
        case windows = "WINDOWS"
        public var description: String { return self.rawValue }
    }

    public enum DeadlinePrincipalType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case group = "GROUP"
        case user = "USER"
        public var description: String { return self.rawValue }
    }

    public enum DefaultQueueBudgetAction: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case none = "NONE"
        case stopSchedulingAndCancelTasks = "STOP_SCHEDULING_AND_CANCEL_TASKS"
        case stopSchedulingAndCompleteTasks = "STOP_SCHEDULING_AND_COMPLETE_TASKS"
        public var description: String { return self.rawValue }
    }

    public enum DependencyConsumerResolutionStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case resolved = "RESOLVED"
        case unresolved = "UNRESOLVED"
        public var description: String { return self.rawValue }
    }

    public enum DesiredWorkerStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case stopped = "STOPPED"
        public var description: String { return self.rawValue }
    }

    public enum Ec2MarketType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case onDemand = "on-demand"
        case spot = "spot"
        public var description: String { return self.rawValue }
    }

    public enum EnvironmentTemplateType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case json = "JSON"
        case yaml = "YAML"
        public var description: String { return self.rawValue }
    }

    public enum FileSystemLocationType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case local = "LOCAL"
        case shared = "SHARED"
        public var description: String { return self.rawValue }
    }

    public enum FleetStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case active = "ACTIVE"
        case createFailed = "CREATE_FAILED"
        case createInProgress = "CREATE_IN_PROGRESS"
        case updateFailed = "UPDATE_FAILED"
        case updateInProgress = "UPDATE_IN_PROGRESS"
        public var description: String { return self.rawValue }
    }

    public enum JobAttachmentsFileSystem: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case copied = "COPIED"
        case virtual = "VIRTUAL"
        public var description: String { return self.rawValue }
    }

    public enum JobEntityErrorCode: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case accessDeniedException = "AccessDeniedException"
        case conflictException = "ConflictException"
        case internalServerException = "InternalServerException"
        case maxPayloadSizeExceeded = "MaxPayloadSizeExceeded"
        case resourceNotFoundException = "ResourceNotFoundException"
        case validationException = "ValidationException"
        public var description: String { return self.rawValue }
    }

    public enum JobLifecycleStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case archived = "ARCHIVED"
        case createComplete = "CREATE_COMPLETE"
        case createFailed = "CREATE_FAILED"
        case createInProgress = "CREATE_IN_PROGRESS"
        case updateFailed = "UPDATE_FAILED"
        case updateInProgress = "UPDATE_IN_PROGRESS"
        case updateSucceeded = "UPDATE_SUCCEEDED"
        case uploadFailed = "UPLOAD_FAILED"
        case uploadInProgress = "UPLOAD_IN_PROGRESS"
        public var description: String { return self.rawValue }
    }

    public enum JobTargetTaskRunStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case canceled = "CANCELED"
        case failed = "FAILED"
        case pending = "PENDING"
        case ready = "READY"
        case succeeded = "SUCCEEDED"
        case suspended = "SUSPENDED"
        public var description: String { return self.rawValue }
    }

    public enum JobTemplateType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case json = "JSON"
        case yaml = "YAML"
        public var description: String { return self.rawValue }
    }

    public enum LicenseEndpointStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case createInProgress = "CREATE_IN_PROGRESS"
        case deleteInProgress = "DELETE_IN_PROGRESS"
        case notReady = "NOT_READY"
        case ready = "READY"
        public var description: String { return self.rawValue }
    }

    public enum LogicalOperator: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case and = "AND"
        case or = "OR"
        public var description: String { return self.rawValue }
    }

    public enum MembershipLevel: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case contributor = "CONTRIBUTOR"
        case manager = "MANAGER"
        case owner = "OWNER"
        case viewer = "VIEWER"
        public var description: String { return self.rawValue }
    }

    public enum PathFormat: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case posix = "posix"
        case windows = "windows"
        public var description: String { return self.rawValue }
    }

    public enum Period: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case daily = "DAILY"
        case hourly = "HOURLY"
        case monthly = "MONTHLY"
        case weekly = "WEEKLY"
        public var description: String { return self.rawValue }
    }

    public enum QueueBlockedReason: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case budgetThresholdReached = "BUDGET_THRESHOLD_REACHED"
        case noBudgetConfigured = "NO_BUDGET_CONFIGURED"
        public var description: String { return self.rawValue }
    }

    public enum QueueFleetAssociationStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case active = "ACTIVE"
        case stopSchedulingAndCancelTasks = "STOP_SCHEDULING_AND_CANCEL_TASKS"
        case stopSchedulingAndCompleteTasks = "STOP_SCHEDULING_AND_COMPLETE_TASKS"
        case stopped = "STOPPED"
        public var description: String { return self.rawValue }
    }

    public enum QueueLimitAssociationStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case active = "ACTIVE"
        case stopLimitUsageAndCancelTasks = "STOP_LIMIT_USAGE_AND_CANCEL_TASKS"
        case stopLimitUsageAndCompleteTasks = "STOP_LIMIT_USAGE_AND_COMPLETE_TASKS"
        case stopped = "STOPPED"
        public var description: String { return self.rawValue }
    }

    public enum QueueStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case idle = "IDLE"
        case scheduling = "SCHEDULING"
        case schedulingBlocked = "SCHEDULING_BLOCKED"
        public var description: String { return self.rawValue }
    }

    public enum RunAs: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case queueConfiguredUser = "QUEUE_CONFIGURED_USER"
        case workerAgentUser = "WORKER_AGENT_USER"
        public var description: String { return self.rawValue }
    }

    public enum SearchTermMatchingType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case contains = "CONTAINS"
        case fuzzyMatch = "FUZZY_MATCH"
        public var description: String { return self.rawValue }
    }

    public enum ServiceManagedFleetOperatingSystemFamily: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case linux = "LINUX"
        case windows = "WINDOWS"
        public var description: String { return self.rawValue }
    }

    public enum ServiceQuotaExceededExceptionReason: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case kmsKeyLimitExceeded = "KMS_KEY_LIMIT_EXCEEDED"
        case serviceQuotaExceededException = "SERVICE_QUOTA_EXCEEDED_EXCEPTION"
        public var description: String { return self.rawValue }
    }

    public enum SessionActionStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case assigned = "ASSIGNED"
        case canceled = "CANCELED"
        case canceling = "CANCELING"
        case failed = "FAILED"
        case interrupted = "INTERRUPTED"
        case neverAttempted = "NEVER_ATTEMPTED"
        case reclaimed = "RECLAIMED"
        case reclaiming = "RECLAIMING"
        case running = "RUNNING"
        case scheduled = "SCHEDULED"
        case succeeded = "SUCCEEDED"
        public var description: String { return self.rawValue }
    }

    public enum SessionLifecycleStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case ended = "ENDED"
        case started = "STARTED"
        case updateFailed = "UPDATE_FAILED"
        case updateInProgress = "UPDATE_IN_PROGRESS"
        case updateSucceeded = "UPDATE_SUCCEEDED"
        public var description: String { return self.rawValue }
    }

    public enum SessionLifecycleTargetStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case ended = "ENDED"
        public var description: String { return self.rawValue }
    }

    public enum SessionsStatisticsAggregationStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case completed = "COMPLETED"
        case failed = "FAILED"
        case inProgress = "IN_PROGRESS"
        case timeout = "TIMEOUT"
        public var description: String { return self.rawValue }
    }

    public enum SortOrder: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case ascending = "ASCENDING"
        case descending = "DESCENDING"
        public var description: String { return self.rawValue }
    }

    public enum StepLifecycleStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case createComplete = "CREATE_COMPLETE"
        case updateFailed = "UPDATE_FAILED"
        case updateInProgress = "UPDATE_IN_PROGRESS"
        case updateSucceeded = "UPDATE_SUCCEEDED"
        public var description: String { return self.rawValue }
    }

    public enum StepParameterType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case float = "FLOAT"
        case int = "INT"
        case path = "PATH"
        case string = "STRING"
        public var description: String { return self.rawValue }
    }

    public enum StepTargetTaskRunStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case canceled = "CANCELED"
        case failed = "FAILED"
        case pending = "PENDING"
        case ready = "READY"
        case succeeded = "SUCCEEDED"
        case suspended = "SUSPENDED"
        public var description: String { return self.rawValue }
    }

    public enum StorageProfileOperatingSystemFamily: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case linux = "LINUX"
        case macos = "MACOS"
        case windows = "WINDOWS"
        public var description: String { return self.rawValue }
    }

    public enum TaskRunStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case assigned = "ASSIGNED"
        case canceled = "CANCELED"
        case failed = "FAILED"
        case interrupting = "INTERRUPTING"
        case notCompatible = "NOT_COMPATIBLE"
        case pending = "PENDING"
        case ready = "READY"
        case running = "RUNNING"
        case scheduled = "SCHEDULED"
        case starting = "STARTING"
        case succeeded = "SUCCEEDED"
        case suspended = "SUSPENDED"
        public var description: String { return self.rawValue }
    }

    public enum TaskTargetRunStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case canceled = "CANCELED"
        case failed = "FAILED"
        case pending = "PENDING"
        case ready = "READY"
        case succeeded = "SUCCEEDED"
        case suspended = "SUSPENDED"
        public var description: String { return self.rawValue }
    }

    public enum UpdateJobLifecycleStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case archived = "ARCHIVED"
        public var description: String { return self.rawValue }
    }

    public enum UpdateQueueFleetAssociationStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case active = "ACTIVE"
        case stopSchedulingAndCancelTasks = "STOP_SCHEDULING_AND_CANCEL_TASKS"
        case stopSchedulingAndCompleteTasks = "STOP_SCHEDULING_AND_COMPLETE_TASKS"
        public var description: String { return self.rawValue }
    }

    public enum UpdateQueueLimitAssociationStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case active = "ACTIVE"
        case stopLimitUsageAndCancelTasks = "STOP_LIMIT_USAGE_AND_CANCEL_TASKS"
        case stopLimitUsageAndCompleteTasks = "STOP_LIMIT_USAGE_AND_COMPLETE_TASKS"
        public var description: String { return self.rawValue }
    }

    public enum UpdatedWorkerStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case started = "STARTED"
        case stopped = "STOPPED"
        case stopping = "STOPPING"
        public var description: String { return self.rawValue }
    }

    public enum UsageGroupByField: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case fleetId = "FLEET_ID"
        case instanceType = "INSTANCE_TYPE"
        case jobId = "JOB_ID"
        case licenseProduct = "LICENSE_PRODUCT"
        case queueId = "QUEUE_ID"
        case usageType = "USAGE_TYPE"
        case userId = "USER_ID"
        public var description: String { return self.rawValue }
    }

    public enum UsageStatistic: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case avg = "AVG"
        case max = "MAX"
        case min = "MIN"
        case sum = "SUM"
        public var description: String { return self.rawValue }
    }

    public enum UsageType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case compute = "COMPUTE"
        case license = "LICENSE"
        public var description: String { return self.rawValue }
    }

    public enum ValidationExceptionReason: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case cannotParse = "CANNOT_PARSE"
        case fieldValidationFailed = "FIELD_VALIDATION_FAILED"
        case other = "OTHER"
        case unknownOperation = "UNKNOWN_OPERATION"
        public var description: String { return self.rawValue }
    }

    public enum WorkerStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case created = "CREATED"
        case idle = "IDLE"
        case notCompatible = "NOT_COMPATIBLE"
        case notResponding = "NOT_RESPONDING"
        case running = "RUNNING"
        case started = "STARTED"
        case stopped = "STOPPED"
        case stopping = "STOPPING"
        public var description: String { return self.rawValue }
    }

    public enum AssignedSessionActionDefinition: AWSDecodableShape, Sendable {
        /// The environment a session starts on.
        case envEnter(AssignedEnvironmentEnterSessionActionDefinition)
        /// The environment a session exits from.
        case envExit(AssignedEnvironmentExitSessionActionDefinition)
        /// The job attachment to sync with an assigned session action.
        case syncInputJobAttachments(AssignedSyncInputJobAttachmentsSessionActionDefinition)
        /// The task run.
        case taskRun(AssignedTaskRunSessionActionDefinition)

        public init(from decoder: Decoder) throws {
            let container = try decoder.container(keyedBy: CodingKeys.self)
            guard container.allKeys.count == 1, let key = container.allKeys.first else {
                let context = DecodingError.Context(
                    codingPath: container.codingPath,
                    debugDescription: "Expected exactly one key, but got \(container.allKeys.count)"
                )
                throw DecodingError.dataCorrupted(context)
            }
            switch key {
            case .envEnter:
                let value = try container.decode(AssignedEnvironmentEnterSessionActionDefinition.self, forKey: .envEnter)
                self = .envEnter(value)
            case .envExit:
                let value = try container.decode(AssignedEnvironmentExitSessionActionDefinition.self, forKey: .envExit)
                self = .envExit(value)
            case .syncInputJobAttachments:
                let value = try container.decode(AssignedSyncInputJobAttachmentsSessionActionDefinition.self, forKey: .syncInputJobAttachments)
                self = .syncInputJobAttachments(value)
            case .taskRun:
                let value = try container.decode(AssignedTaskRunSessionActionDefinition.self, forKey: .taskRun)
                self = .taskRun(value)
            }
        }

        private enum CodingKeys: String, CodingKey {
            case envEnter = "envEnter"
            case envExit = "envExit"
            case syncInputJobAttachments = "syncInputJobAttachments"
            case taskRun = "taskRun"
        }
    }

    public enum FleetConfiguration: AWSEncodableShape & AWSDecodableShape, Sendable {
        /// The customer managed fleets within a fleet configuration.
        case customerManaged(CustomerManagedFleetConfiguration)
        /// The service managed Amazon EC2 instances for a fleet configuration.
        case serviceManagedEc2(ServiceManagedEc2FleetConfiguration)

        public init(from decoder: Decoder) throws {
            let container = try decoder.container(keyedBy: CodingKeys.self)
            guard container.allKeys.count == 1, let key = container.allKeys.first else {
                let context = DecodingError.Context(
                    codingPath: container.codingPath,
                    debugDescription: "Expected exactly one key, but got \(container.allKeys.count)"
                )
                throw DecodingError.dataCorrupted(context)
            }
            switch key {
            case .customerManaged:
                let value = try container.decode(CustomerManagedFleetConfiguration.self, forKey: .customerManaged)
                self = .customerManaged(value)
            case .serviceManagedEc2:
                let value = try container.decode(ServiceManagedEc2FleetConfiguration.self, forKey: .serviceManagedEc2)
                self = .serviceManagedEc2(value)
            }
        }

        public func encode(to encoder: Encoder) throws {
            var container = encoder.container(keyedBy: CodingKeys.self)
            switch self {
            case .customerManaged(let value):
                try container.encode(value, forKey: .customerManaged)
            case .serviceManagedEc2(let value):
                try container.encode(value, forKey: .serviceManagedEc2)
            }
        }

        public func validate(name: String) throws {
            switch self {
            case .customerManaged(let value):
                try value.validate(name: "\(name).customerManaged")
            case .serviceManagedEc2(let value):
                try value.validate(name: "\(name).serviceManagedEc2")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case customerManaged = "customerManaged"
            case serviceManagedEc2 = "serviceManagedEc2"
        }
    }

    public enum GetJobEntityError: AWSDecodableShape, Sendable {
        /// The environment details for the failed job entity.
        case environmentDetails(EnvironmentDetailsError)
        /// The job attachment details for the failed job entity.
        case jobAttachmentDetails(JobAttachmentDetailsError)
        /// The job details for the failed job entity.
        case jobDetails(JobDetailsError)
        /// The step details for the failed job entity.
        case stepDetails(StepDetailsError)

        public init(from decoder: Decoder) throws {
            let container = try decoder.container(keyedBy: CodingKeys.self)
            guard container.allKeys.count == 1, let key = container.allKeys.first else {
                let context = DecodingError.Context(
                    codingPath: container.codingPath,
                    debugDescription: "Expected exactly one key, but got \(container.allKeys.count)"
                )
                throw DecodingError.dataCorrupted(context)
            }
            switch key {
            case .environmentDetails:
                let value = try container.decode(EnvironmentDetailsError.self, forKey: .environmentDetails)
                self = .environmentDetails(value)
            case .jobAttachmentDetails:
                let value = try container.decode(JobAttachmentDetailsError.self, forKey: .jobAttachmentDetails)
                self = .jobAttachmentDetails(value)
            case .jobDetails:
                let value = try container.decode(JobDetailsError.self, forKey: .jobDetails)
                self = .jobDetails(value)
            case .stepDetails:
                let value = try container.decode(StepDetailsError.self, forKey: .stepDetails)
                self = .stepDetails(value)
            }
        }

        private enum CodingKeys: String, CodingKey {
            case environmentDetails = "environmentDetails"
            case jobAttachmentDetails = "jobAttachmentDetails"
            case jobDetails = "jobDetails"
            case stepDetails = "stepDetails"
        }
    }

    public enum JobEntity: AWSDecodableShape, Sendable {
        /// The environment details for the job entity.
        case environmentDetails(EnvironmentDetailsEntity)
        /// The job attachment details.
        case jobAttachmentDetails(JobAttachmentDetailsEntity)
        /// The job details.
        case jobDetails(JobDetailsEntity)
        /// The step details.
        case stepDetails(StepDetailsEntity)

        public init(from decoder: Decoder) throws {
            let container = try decoder.container(keyedBy: CodingKeys.self)
            guard container.allKeys.count == 1, let key = container.allKeys.first else {
                let context = DecodingError.Context(
                    codingPath: container.codingPath,
                    debugDescription: "Expected exactly one key, but got \(container.allKeys.count)"
                )
                throw DecodingError.dataCorrupted(context)
            }
            switch key {
            case .environmentDetails:
                let value = try container.decode(EnvironmentDetailsEntity.self, forKey: .environmentDetails)
                self = .environmentDetails(value)
            case .jobAttachmentDetails:
                let value = try container.decode(JobAttachmentDetailsEntity.self, forKey: .jobAttachmentDetails)
                self = .jobAttachmentDetails(value)
            case .jobDetails:
                let value = try container.decode(JobDetailsEntity.self, forKey: .jobDetails)
                self = .jobDetails(value)
            case .stepDetails:
                let value = try container.decode(StepDetailsEntity.self, forKey: .stepDetails)
                self = .stepDetails(value)
            }
        }

        private enum CodingKeys: String, CodingKey {
            case environmentDetails = "environmentDetails"
            case jobAttachmentDetails = "jobAttachmentDetails"
            case jobDetails = "jobDetails"
            case stepDetails = "stepDetails"
        }
    }

    public enum JobEntityIdentifiersUnion: AWSEncodableShape, Sendable {
        /// The environment details.
        case environmentDetails(EnvironmentDetailsIdentifiers)
        /// The job attachment details.
        case jobAttachmentDetails(JobAttachmentDetailsIdentifiers)
        /// The job details.
        case jobDetails(JobDetailsIdentifiers)
        /// The step details.
        case stepDetails(StepDetailsIdentifiers)

        public func encode(to encoder: Encoder) throws {
            var container = encoder.container(keyedBy: CodingKeys.self)
            switch self {
            case .environmentDetails(let value):
                try container.encode(value, forKey: .environmentDetails)
            case .jobAttachmentDetails(let value):
                try container.encode(value, forKey: .jobAttachmentDetails)
            case .jobDetails(let value):
                try container.encode(value, forKey: .jobDetails)
            case .stepDetails(let value):
                try container.encode(value, forKey: .stepDetails)
            }
        }

        public func validate(name: String) throws {
            switch self {
            case .environmentDetails(let value):
                try value.validate(name: "\(name).environmentDetails")
            case .jobAttachmentDetails(let value):
                try value.validate(name: "\(name).jobAttachmentDetails")
            case .jobDetails(let value):
                try value.validate(name: "\(name).jobDetails")
            case .stepDetails(let value):
                try value.validate(name: "\(name).stepDetails")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case environmentDetails = "environmentDetails"
            case jobAttachmentDetails = "jobAttachmentDetails"
            case jobDetails = "jobDetails"
            case stepDetails = "stepDetails"
        }
    }

    public enum JobParameter: AWSEncodableShape & AWSDecodableShape, Sendable {
        /// A double precision IEEE-754 floating point number represented as a string.
        case float(String)
        /// A signed integer represented as a string.
        case int(String)
        /// A file system path represented as a string.
        case path(String)
        /// A UTF-8 string.
        case string(String)

        public init(from decoder: Decoder) throws {
            let container = try decoder.container(keyedBy: CodingKeys.self)
            guard container.allKeys.count == 1, let key = container.allKeys.first else {
                let context = DecodingError.Context(
                    codingPath: container.codingPath,
                    debugDescription: "Expected exactly one key, but got \(container.allKeys.count)"
                )
                throw DecodingError.dataCorrupted(context)
            }
            switch key {
            case .float:
                let value = try container.decode(String.self, forKey: .float)
                self = .float(value)
            case .int:
                let value = try container.decode(String.self, forKey: .int)
                self = .int(value)
            case .path:
                let value = try container.decode(String.self, forKey: .path)
                self = .path(value)
            case .string:
                let value = try container.decode(String.self, forKey: .string)
                self = .string(value)
            }
        }

        public func encode(to encoder: Encoder) throws {
            var container = encoder.container(keyedBy: CodingKeys.self)
            switch self {
            case .float(let value):
                try container.encode(value, forKey: .float)
            case .int(let value):
                try container.encode(value, forKey: .int)
            case .path(let value):
                try container.encode(value, forKey: .path)
            case .string(let value):
                try container.encode(value, forKey: .string)
            }
        }

        public func validate(name: String) throws {
            switch self {
            case .float(let value):
                try self.validate(value, name: "float", parent: name, max: 26)
                try self.validate(value, name: "float", parent: name, min: 1)
                try self.validate(value, name: "float", parent: name, pattern: "^[-]?(0|[1-9][0-9]*)([.][0-9]+)?([eE][+-]?[0-9]+)?$")
            case .int(let value):
                try self.validate(value, name: "int", parent: name, max: 20)
                try self.validate(value, name: "int", parent: name, min: 1)
                try self.validate(value, name: "int", parent: name, pattern: "^[-]?(0|[1-9][0-9]*)$")
            case .path(let value):
                try self.validate(value, name: "path", parent: name, max: 1024)
            case .string(let value):
                try self.validate(value, name: "string", parent: name, max: 1024)
            }
        }

        private enum CodingKeys: String, CodingKey {
            case float = "float"
            case int = "int"
            case path = "path"
            case string = "string"
        }
    }

    public enum SearchFilterExpression: AWSEncodableShape, Sendable {
        /// Filters based on date and time.
        case dateTimeFilter(DateTimeFilterExpression)
        /// Filters by group.
        case groupFilter(SearchGroupedFilterExpressions)
        /// Filters by parameter.
        case parameterFilter(ParameterFilterExpression)
        /// Filters by a specified search term.
        case searchTermFilter(SearchTermFilterExpression)
        /// Filters by a string.
        case stringFilter(StringFilterExpression)

        public func encode(to encoder: Encoder) throws {
            var container = encoder.container(keyedBy: CodingKeys.self)
            switch self {
            case .dateTimeFilter(let value):
                try container.encode(value, forKey: .dateTimeFilter)
            case .groupFilter(let value):
                try container.encode(value, forKey: .groupFilter)
            case .parameterFilter(let value):
                try container.encode(value, forKey: .parameterFilter)
            case .searchTermFilter(let value):
                try container.encode(value, forKey: .searchTermFilter)
            case .stringFilter(let value):
                try container.encode(value, forKey: .stringFilter)
            }
        }

        public func validate(name: String) throws {
            switch self {
            case .groupFilter(let value):
                try value.validate(name: "\(name).groupFilter")
            case .parameterFilter(let value):
                try value.validate(name: "\(name).parameterFilter")
            case .searchTermFilter(let value):
                try value.validate(name: "\(name).searchTermFilter")
            case .stringFilter(let value):
                try value.validate(name: "\(name).stringFilter")
            default:
                break
            }
        }

        private enum CodingKeys: String, CodingKey {
            case dateTimeFilter = "dateTimeFilter"
            case groupFilter = "groupFilter"
            case parameterFilter = "parameterFilter"
            case searchTermFilter = "searchTermFilter"
            case stringFilter = "stringFilter"
        }
    }

    public enum SearchSortExpression: AWSEncodableShape, Sendable {
        /// Options for sorting by a field.
        case fieldSort(FieldSortExpression)
        /// Options for sorting by a parameter.
        case parameterSort(ParameterSortExpression)
        /// Options for sorting a particular user's jobs first.
        case userJobsFirst(UserJobsFirst)

        public func encode(to encoder: Encoder) throws {
            var container = encoder.container(keyedBy: CodingKeys.self)
            switch self {
            case .fieldSort(let value):
                try container.encode(value, forKey: .fieldSort)
            case .parameterSort(let value):
                try container.encode(value, forKey: .parameterSort)
            case .userJobsFirst(let value):
                try container.encode(value, forKey: .userJobsFirst)
            }
        }

        private enum CodingKeys: String, CodingKey {
            case fieldSort = "fieldSort"
            case parameterSort = "parameterSort"
            case userJobsFirst = "userJobsFirst"
        }
    }

    public enum SessionActionDefinition: AWSDecodableShape, Sendable {
        /// The environment to enter into.
        case envEnter(EnvironmentEnterSessionActionDefinition)
        /// The environment to exit from.
        case envExit(EnvironmentExitSessionActionDefinition)
        /// The job attachments to sync with a session action.
        case syncInputJobAttachments(SyncInputJobAttachmentsSessionActionDefinition)
        /// The task run in the session.
        case taskRun(TaskRunSessionActionDefinition)

        public init(from decoder: Decoder) throws {
            let container = try decoder.container(keyedBy: CodingKeys.self)
            guard container.allKeys.count == 1, let key = container.allKeys.first else {
                let context = DecodingError.Context(
                    codingPath: container.codingPath,
                    debugDescription: "Expected exactly one key, but got \(container.allKeys.count)"
                )
                throw DecodingError.dataCorrupted(context)
            }
            switch key {
            case .envEnter:
                let value = try container.decode(EnvironmentEnterSessionActionDefinition.self, forKey: .envEnter)
                self = .envEnter(value)
            case .envExit:
                let value = try container.decode(EnvironmentExitSessionActionDefinition.self, forKey: .envExit)
                self = .envExit(value)
            case .syncInputJobAttachments:
                let value = try container.decode(SyncInputJobAttachmentsSessionActionDefinition.self, forKey: .syncInputJobAttachments)
                self = .syncInputJobAttachments(value)
            case .taskRun:
                let value = try container.decode(TaskRunSessionActionDefinition.self, forKey: .taskRun)
                self = .taskRun(value)
            }
        }

        private enum CodingKeys: String, CodingKey {
            case envEnter = "envEnter"
            case envExit = "envExit"
            case syncInputJobAttachments = "syncInputJobAttachments"
            case taskRun = "taskRun"
        }
    }

    public enum SessionActionDefinitionSummary: AWSDecodableShape, Sendable {
        /// The environment to enter into.
        case envEnter(EnvironmentEnterSessionActionDefinitionSummary)
        /// The environment to exit from.
        case envExit(EnvironmentExitSessionActionDefinitionSummary)
        /// The job attachments to sync with the session action definition.
        case syncInputJobAttachments(SyncInputJobAttachmentsSessionActionDefinitionSummary)
        /// The task run.
        case taskRun(TaskRunSessionActionDefinitionSummary)

        public init(from decoder: Decoder) throws {
            let container = try decoder.container(keyedBy: CodingKeys.self)
            guard container.allKeys.count == 1, let key = container.allKeys.first else {
                let context = DecodingError.Context(
                    codingPath: container.codingPath,
                    debugDescription: "Expected exactly one key, but got \(container.allKeys.count)"
                )
                throw DecodingError.dataCorrupted(context)
            }
            switch key {
            case .envEnter:
                let value = try container.decode(EnvironmentEnterSessionActionDefinitionSummary.self, forKey: .envEnter)
                self = .envEnter(value)
            case .envExit:
                let value = try container.decode(EnvironmentExitSessionActionDefinitionSummary.self, forKey: .envExit)
                self = .envExit(value)
            case .syncInputJobAttachments:
                let value = try container.decode(SyncInputJobAttachmentsSessionActionDefinitionSummary.self, forKey: .syncInputJobAttachments)
                self = .syncInputJobAttachments(value)
            case .taskRun:
                let value = try container.decode(TaskRunSessionActionDefinitionSummary.self, forKey: .taskRun)
                self = .taskRun(value)
            }
        }

        private enum CodingKeys: String, CodingKey {
            case envEnter = "envEnter"
            case envExit = "envExit"
            case syncInputJobAttachments = "syncInputJobAttachments"
            case taskRun = "taskRun"
        }
    }

    public enum SessionsStatisticsResources: AWSEncodableShape, Sendable {
        /// One to 10 fleet IDs that specify the fleets to return statistics for. If you specify the fleetIds field, you can't specify the queueIds field.
        case fleetIds([String])
        /// One to 10 queue IDs that specify the queues to return statistics for. If you specify the queueIds field, you can't specify the fleetIds field.
        case queueIds([String])

        public func encode(to encoder: Encoder) throws {
            var container = encoder.container(keyedBy: CodingKeys.self)
            switch self {
            case .fleetIds(let value):
                try container.encode(value, forKey: .fleetIds)
            case .queueIds(let value):
                try container.encode(value, forKey: .queueIds)
            }
        }

        public func validate(name: String) throws {
            switch self {
            case .fleetIds(let value):
                try value.forEach {
                    try validate($0, name: "fleetIds[]", parent: name, pattern: "^fleet-[0-9a-f]{32}$")
                }
                try self.validate(value, name: "fleetIds", parent: name, min: 1)
            case .queueIds(let value):
                try value.forEach {
                    try validate($0, name: "queueIds[]", parent: name, pattern: "^queue-[0-9a-f]{32}$")
                }
                try self.validate(value, name: "queueIds", parent: name, min: 1)
            }
        }

        private enum CodingKeys: String, CodingKey {
            case fleetIds = "fleetIds"
            case queueIds = "queueIds"
        }
    }

    public enum TaskParameterValue: AWSDecodableShape, Sendable {
        /// A double precision IEEE-754 floating point number represented as a string.
        case float(String)
        /// A signed integer represented as a string.
        case int(String)
        /// A file system path represented as a string.
        case path(String)
        /// A UTF-8 string.
        case string(String)

        public init(from decoder: Decoder) throws {
            let container = try decoder.container(keyedBy: CodingKeys.self)
            guard container.allKeys.count == 1, let key = container.allKeys.first else {
                let context = DecodingError.Context(
                    codingPath: container.codingPath,
                    debugDescription: "Expected exactly one key, but got \(container.allKeys.count)"
                )
                throw DecodingError.dataCorrupted(context)
            }
            switch key {
            case .float:
                let value = try container.decode(String.self, forKey: .float)
                self = .float(value)
            case .int:
                let value = try container.decode(String.self, forKey: .int)
                self = .int(value)
            case .path:
                let value = try container.decode(String.self, forKey: .path)
                self = .path(value)
            case .string:
                let value = try container.decode(String.self, forKey: .string)
                self = .string(value)
            }
        }

        private enum CodingKeys: String, CodingKey {
            case float = "float"
            case int = "int"
            case path = "path"
            case string = "string"
        }
    }

    // MARK: Shapes

    public struct AcceleratorCapabilities: AWSEncodableShape & AWSDecodableShape {
        /// The number of GPU accelerators specified for worker hosts in this fleet.
        public let count: AcceleratorCountRange?
        /// A list of accelerator capabilities requested for this fleet. Only Amazon Elastic Compute Cloud instances that provide these capabilities will be used. For example, if you specify both L4 and T4 chips, Deadline Cloud will use Amazon EC2 instances that have either the L4 or the T4 chip installed.
        public let selections: [AcceleratorSelection]

        @inlinable
        public init(count: AcceleratorCountRange? = nil, selections: [AcceleratorSelection]) {
            self.count = count
            self.selections = selections
        }

        public func validate(name: String) throws {
            try self.count?.validate(name: "\(name).count")
            try self.selections.forEach {
                try $0.validate(name: "\(name).selections[]")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case count = "count"
            case selections = "selections"
        }
    }

    public struct AcceleratorCountRange: AWSEncodableShape & AWSDecodableShape {
        /// The maximum number of GPU accelerators in the worker host.
        public let max: Int?
        /// The minimum number of GPU accelerators in the worker host.
        public let min: Int

        @inlinable
        public init(max: Int? = nil, min: Int) {
            self.max = max
            self.min = min
        }

        public func validate(name: String) throws {
            try self.validate(self.max, name: "max", parent: name, max: 2147483647)
            try self.validate(self.max, name: "max", parent: name, min: 0)
            try self.validate(self.min, name: "min", parent: name, max: 2147483647)
            try self.validate(self.min, name: "min", parent: name, min: 0)
        }

        private enum CodingKeys: String, CodingKey {
            case max = "max"
            case min = "min"
        }
    }

    public struct AcceleratorSelection: AWSEncodableShape & AWSDecodableShape {
        /// The name of the chip used by the GPU accelerator. If you specify l4 as the name of the accelerator, you must specify latest or grid:r550 as the runtime. The available GPU accelerators are:    t4 - NVIDIA T4 Tensor Core GPU    a10g - NVIDIA A10G Tensor Core GPU    l4 - NVIDIA L4 Tensor Core GPU    l40s - NVIDIA L40S Tensor Core GPU
        public let name: AcceleratorName
        /// Specifies the runtime driver to use for the GPU accelerator. You must use the same runtime for all GPUs.  You can choose from the following runtimes:    latest - Use the latest runtime available for the chip. If you specify latest and a new version of the runtime is released, the new version of the runtime is used.    grid:r550 - NVIDIA vGPU software 17     grid:r535 - NVIDIA vGPU software 16    If you don't specify a runtime, Deadline Cloud uses latest as the default. However, if you have multiple accelerators and specify latest for some and leave others blank, Deadline Cloud raises an exception.
        public let runtime: String?

        @inlinable
        public init(name: AcceleratorName, runtime: String? = nil) {
            self.name = name
            self.runtime = runtime
        }

        public func validate(name: String) throws {
            try self.validate(self.runtime, name: "runtime", parent: name, max: 100)
            try self.validate(self.runtime, name: "runtime", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case name = "name"
            case runtime = "runtime"
        }
    }

    public struct AcceleratorTotalMemoryMiBRange: AWSEncodableShape & AWSDecodableShape {
        /// The maximum amount of memory to use for the accelerator, measured in MiB.
        public let max: Int?
        /// The minimum amount of memory to use for the accelerator, measured in MiB.
        public let min: Int

        @inlinable
        public init(max: Int? = nil, min: Int) {
            self.max = max
            self.min = min
        }

        public func validate(name: String) throws {
            try self.validate(self.max, name: "max", parent: name, max: 2147483647)
            try self.validate(self.max, name: "max", parent: name, min: 0)
            try self.validate(self.min, name: "min", parent: name, max: 2147483647)
            try self.validate(self.min, name: "min", parent: name, min: 0)
        }

        private enum CodingKeys: String, CodingKey {
            case max = "max"
            case min = "min"
        }
    }

    public struct AccessDeniedException: AWSErrorShape {
        /// Information about the resources in use when the exception was thrown.
        public let context: [String: String]?
        public let message: String

        @inlinable
        public init(context: [String: String]? = nil, message: String) {
            self.context = context
            self.message = message
        }

        private enum CodingKeys: String, CodingKey {
            case context = "context"
            case message = "message"
        }
    }

    public struct AcquiredLimit: AWSDecodableShape {
        /// The number of limit resources used.
        public let count: Int
        /// The unique identifier of the limit.
        public let limitId: String

        @inlinable
        public init(count: Int, limitId: String) {
            self.count = count
            self.limitId = limitId
        }

        private enum CodingKeys: String, CodingKey {
            case count = "count"
            case limitId = "limitId"
        }
    }

    public struct AssignedEnvironmentEnterSessionActionDefinition: AWSDecodableShape {
        /// The environment ID of the assigned environment at the start of a session.
        public let environmentId: String

        @inlinable
        public init(environmentId: String) {
            self.environmentId = environmentId
        }

        private enum CodingKeys: String, CodingKey {
            case environmentId = "environmentId"
        }
    }

    public struct AssignedEnvironmentExitSessionActionDefinition: AWSDecodableShape {
        /// The environment ID of the assigned environment when exiting a session.
        public let environmentId: String

        @inlinable
        public init(environmentId: String) {
            self.environmentId = environmentId
        }

        private enum CodingKeys: String, CodingKey {
            case environmentId = "environmentId"
        }
    }

    public struct AssignedSession: AWSDecodableShape {
        /// The job ID for the assigned session.
        public let jobId: String
        /// The log configuration for the worker's assigned session.
        public let logConfiguration: LogConfiguration
        /// The queue ID of the assigned session.
        public let queueId: String
        /// The session actions to apply to the assigned session.
        public let sessionActions: [AssignedSessionAction]

        @inlinable
        public init(jobId: String, logConfiguration: LogConfiguration, queueId: String, sessionActions: [AssignedSessionAction]) {
            self.jobId = jobId
            self.logConfiguration = logConfiguration
            self.queueId = queueId
            self.sessionActions = sessionActions
        }

        private enum CodingKeys: String, CodingKey {
            case jobId = "jobId"
            case logConfiguration = "logConfiguration"
            case queueId = "queueId"
            case sessionActions = "sessionActions"
        }
    }

    public struct AssignedSessionAction: AWSDecodableShape {
        /// The definition of the assigned session action.
        public let definition: AssignedSessionActionDefinition
        /// The session action ID for the assigned session.
        public let sessionActionId: String

        @inlinable
        public init(definition: AssignedSessionActionDefinition, sessionActionId: String) {
            self.definition = definition
            self.sessionActionId = sessionActionId
        }

        private enum CodingKeys: String, CodingKey {
            case definition = "definition"
            case sessionActionId = "sessionActionId"
        }
    }

    public struct AssignedSyncInputJobAttachmentsSessionActionDefinition: AWSDecodableShape {
        /// The step ID.
        public let stepId: String?

        @inlinable
        public init(stepId: String? = nil) {
            self.stepId = stepId
        }

        private enum CodingKeys: String, CodingKey {
            case stepId = "stepId"
        }
    }

    public struct AssignedTaskRunSessionActionDefinition: AWSDecodableShape {
        /// The parameters to include.
        public let parameters: [String: TaskParameterValue]
        /// The step ID.
        public let stepId: String
        /// The task ID.
        public let taskId: String?

        @inlinable
        public init(parameters: [String: TaskParameterValue], stepId: String, taskId: String? = nil) {
            self.parameters = parameters
            self.stepId = stepId
            self.taskId = taskId
        }

        private enum CodingKeys: String, CodingKey {
            case parameters = "parameters"
            case stepId = "stepId"
            case taskId = "taskId"
        }
    }

    public struct AssociateMemberToFarmRequest: AWSEncodableShape {
        /// The ID of the farm to associate with the member.
        public let farmId: String
        /// The identity store ID of the member to associate with the farm.
        public let identityStoreId: String
        /// The principal's membership level for the associated farm.
        public let membershipLevel: MembershipLevel
        /// The member's principal ID to associate with the farm.
        public let principalId: String
        /// The principal type of the member to associate with the farm.
        public let principalType: DeadlinePrincipalType

        @inlinable
        public init(farmId: String, identityStoreId: String, membershipLevel: MembershipLevel, principalId: String, principalType: DeadlinePrincipalType) {
            self.farmId = farmId
            self.identityStoreId = identityStoreId
            self.membershipLevel = membershipLevel
            self.principalId = principalId
            self.principalType = principalType
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.farmId, key: "farmId")
            try container.encode(self.identityStoreId, forKey: .identityStoreId)
            try container.encode(self.membershipLevel, forKey: .membershipLevel)
            request.encodePath(self.principalId, key: "principalId")
            try container.encode(self.principalType, forKey: .principalType)
        }

        public func validate(name: String) throws {
            try self.validate(self.farmId, name: "farmId", parent: name, pattern: "^farm-[0-9a-f]{32}$")
            try self.validate(self.identityStoreId, name: "identityStoreId", parent: name, max: 36)
            try self.validate(self.identityStoreId, name: "identityStoreId", parent: name, min: 1)
            try self.validate(self.identityStoreId, name: "identityStoreId", parent: name, pattern: "^d-[0-9a-f]{10}$|^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$")
            try self.validate(self.principalId, name: "principalId", parent: name, max: 47)
            try self.validate(self.principalId, name: "principalId", parent: name, min: 1)
            try self.validate(self.principalId, name: "principalId", parent: name, pattern: "^([0-9a-f]{10}-|)[A-Fa-f0-9]{8}-[A-Fa-f0-9]{4}-[A-Fa-f0-9]{4}-[A-Fa-f0-9]{4}-[A-Fa-f0-9]{12}$")
        }

        private enum CodingKeys: String, CodingKey {
            case identityStoreId = "identityStoreId"
            case membershipLevel = "membershipLevel"
            case principalType = "principalType"
        }
    }

    public struct AssociateMemberToFarmResponse: AWSDecodableShape {
        public init() {}
    }

    public struct AssociateMemberToFleetRequest: AWSEncodableShape {
        /// The farm ID of the fleet to associate with the member.
        public let farmId: String
        /// The ID of the fleet to associate with a member.
        public let fleetId: String
        /// The member's identity store ID to associate with the fleet.
        public let identityStoreId: String
        /// The principal's membership level for the associated fleet.
        public let membershipLevel: MembershipLevel
        /// The member's principal ID to associate with a fleet.
        public let principalId: String
        /// The member's principal type to associate with the fleet.
        public let principalType: DeadlinePrincipalType

        @inlinable
        public init(farmId: String, fleetId: String, identityStoreId: String, membershipLevel: MembershipLevel, principalId: String, principalType: DeadlinePrincipalType) {
            self.farmId = farmId
            self.fleetId = fleetId
            self.identityStoreId = identityStoreId
            self.membershipLevel = membershipLevel
            self.principalId = principalId
            self.principalType = principalType
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.farmId, key: "farmId")
            request.encodePath(self.fleetId, key: "fleetId")
            try container.encode(self.identityStoreId, forKey: .identityStoreId)
            try container.encode(self.membershipLevel, forKey: .membershipLevel)
            request.encodePath(self.principalId, key: "principalId")
            try container.encode(self.principalType, forKey: .principalType)
        }

        public func validate(name: String) throws {
            try self.validate(self.farmId, name: "farmId", parent: name, pattern: "^farm-[0-9a-f]{32}$")
            try self.validate(self.fleetId, name: "fleetId", parent: name, pattern: "^fleet-[0-9a-f]{32}$")
            try self.validate(self.identityStoreId, name: "identityStoreId", parent: name, max: 36)
            try self.validate(self.identityStoreId, name: "identityStoreId", parent: name, min: 1)
            try self.validate(self.identityStoreId, name: "identityStoreId", parent: name, pattern: "^d-[0-9a-f]{10}$|^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$")
            try self.validate(self.principalId, name: "principalId", parent: name, max: 47)
            try self.validate(self.principalId, name: "principalId", parent: name, min: 1)
            try self.validate(self.principalId, name: "principalId", parent: name, pattern: "^([0-9a-f]{10}-|)[A-Fa-f0-9]{8}-[A-Fa-f0-9]{4}-[A-Fa-f0-9]{4}-[A-Fa-f0-9]{4}-[A-Fa-f0-9]{12}$")
        }

        private enum CodingKeys: String, CodingKey {
            case identityStoreId = "identityStoreId"
            case membershipLevel = "membershipLevel"
            case principalType = "principalType"
        }
    }

    public struct AssociateMemberToFleetResponse: AWSDecodableShape {
        public init() {}
    }

    public struct AssociateMemberToJobRequest: AWSEncodableShape {
        /// The farm ID of the job to associate with the member.
        public let farmId: String
        /// The member's identity store ID to associate with the job.
        public let identityStoreId: String
        /// The job ID to associate with the member.
        public let jobId: String
        /// The principal's membership level for the associated job.
        public let membershipLevel: MembershipLevel
        /// The member's principal ID to associate with the job.
        public let principalId: String
        /// The member's principal type to associate with the job.
        public let principalType: DeadlinePrincipalType
        /// The queue ID to associate to the member.
        public let queueId: String

        @inlinable
        public init(farmId: String, identityStoreId: String, jobId: String, membershipLevel: MembershipLevel, principalId: String, principalType: DeadlinePrincipalType, queueId: String) {
            self.farmId = farmId
            self.identityStoreId = identityStoreId
            self.jobId = jobId
            self.membershipLevel = membershipLevel
            self.principalId = principalId
            self.principalType = principalType
            self.queueId = queueId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.farmId, key: "farmId")
            try container.encode(self.identityStoreId, forKey: .identityStoreId)
            request.encodePath(self.jobId, key: "jobId")
            try container.encode(self.membershipLevel, forKey: .membershipLevel)
            request.encodePath(self.principalId, key: "principalId")
            try container.encode(self.principalType, forKey: .principalType)
            request.encodePath(self.queueId, key: "queueId")
        }

        public func validate(name: String) throws {
            try self.validate(self.farmId, name: "farmId", parent: name, pattern: "^farm-[0-9a-f]{32}$")
            try self.validate(self.identityStoreId, name: "identityStoreId", parent: name, max: 36)
            try self.validate(self.identityStoreId, name: "identityStoreId", parent: name, min: 1)
            try self.validate(self.identityStoreId, name: "identityStoreId", parent: name, pattern: "^d-[0-9a-f]{10}$|^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$")
            try self.validate(self.jobId, name: "jobId", parent: name, pattern: "^job-[0-9a-f]{32}$")
            try self.validate(self.principalId, name: "principalId", parent: name, max: 47)
            try self.validate(self.principalId, name: "principalId", parent: name, min: 1)
            try self.validate(self.principalId, name: "principalId", parent: name, pattern: "^([0-9a-f]{10}-|)[A-Fa-f0-9]{8}-[A-Fa-f0-9]{4}-[A-Fa-f0-9]{4}-[A-Fa-f0-9]{4}-[A-Fa-f0-9]{12}$")
            try self.validate(self.queueId, name: "queueId", parent: name, pattern: "^queue-[0-9a-f]{32}$")
        }

        private enum CodingKeys: String, CodingKey {
            case identityStoreId = "identityStoreId"
            case membershipLevel = "membershipLevel"
            case principalType = "principalType"
        }
    }

    public struct AssociateMemberToJobResponse: AWSDecodableShape {
        public init() {}
    }

    public struct AssociateMemberToQueueRequest: AWSEncodableShape {
        /// The farm ID of the queue to associate with the member.
        public let farmId: String
        /// The member's identity store ID to associate with the queue.
        public let identityStoreId: String
        /// The principal's membership level for the associated queue.
        public let membershipLevel: MembershipLevel
        /// The member's principal ID to associate with the queue.
        public let principalId: String
        /// The member's principal type to associate with the queue.
        public let principalType: DeadlinePrincipalType
        /// The ID of the queue to associate to the member.
        public let queueId: String

        @inlinable
        public init(farmId: String, identityStoreId: String, membershipLevel: MembershipLevel, principalId: String, principalType: DeadlinePrincipalType, queueId: String) {
            self.farmId = farmId
            self.identityStoreId = identityStoreId
            self.membershipLevel = membershipLevel
            self.principalId = principalId
            self.principalType = principalType
            self.queueId = queueId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.farmId, key: "farmId")
            try container.encode(self.identityStoreId, forKey: .identityStoreId)
            try container.encode(self.membershipLevel, forKey: .membershipLevel)
            request.encodePath(self.principalId, key: "principalId")
            try container.encode(self.principalType, forKey: .principalType)
            request.encodePath(self.queueId, key: "queueId")
        }

        public func validate(name: String) throws {
            try self.validate(self.farmId, name: "farmId", parent: name, pattern: "^farm-[0-9a-f]{32}$")
            try self.validate(self.identityStoreId, name: "identityStoreId", parent: name, max: 36)
            try self.validate(self.identityStoreId, name: "identityStoreId", parent: name, min: 1)
            try self.validate(self.identityStoreId, name: "identityStoreId", parent: name, pattern: "^d-[0-9a-f]{10}$|^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$")
            try self.validate(self.principalId, name: "principalId", parent: name, max: 47)
            try self.validate(self.principalId, name: "principalId", parent: name, min: 1)
            try self.validate(self.principalId, name: "principalId", parent: name, pattern: "^([0-9a-f]{10}-|)[A-Fa-f0-9]{8}-[A-Fa-f0-9]{4}-[A-Fa-f0-9]{4}-[A-Fa-f0-9]{4}-[A-Fa-f0-9]{12}$")
            try self.validate(self.queueId, name: "queueId", parent: name, pattern: "^queue-[0-9a-f]{32}$")
        }

        private enum CodingKeys: String, CodingKey {
            case identityStoreId = "identityStoreId"
            case membershipLevel = "membershipLevel"
            case principalType = "principalType"
        }
    }

    public struct AssociateMemberToQueueResponse: AWSDecodableShape {
        public init() {}
    }

    public struct AssumeFleetRoleForReadRequest: AWSEncodableShape {
        /// The farm ID for the fleet's farm.
        public let farmId: String
        /// The fleet ID.
        public let fleetId: String

        @inlinable
        public init(farmId: String, fleetId: String) {
            self.farmId = farmId
            self.fleetId = fleetId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.farmId, key: "farmId")
            request.encodePath(self.fleetId, key: "fleetId")
        }

        public func validate(name: String) throws {
            try self.validate(self.farmId, name: "farmId", parent: name, pattern: "^farm-[0-9a-f]{32}$")
            try self.validate(self.fleetId, name: "fleetId", parent: name, pattern: "^fleet-[0-9a-f]{32}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct AssumeFleetRoleForReadResponse: AWSDecodableShape {
        /// The credentials for the fleet role.
        public let credentials: AwsCredentials

        @inlinable
        public init(credentials: AwsCredentials) {
            self.credentials = credentials
        }

        private enum CodingKeys: String, CodingKey {
            case credentials = "credentials"
        }
    }

    public struct AssumeFleetRoleForWorkerRequest: AWSEncodableShape {
        /// The farm ID for the fleet's farm.
        public let farmId: String
        /// The fleet ID that contains the worker.
        public let fleetId: String
        /// The ID of the worker assuming the fleet role.
        public let workerId: String

        @inlinable
        public init(farmId: String, fleetId: String, workerId: String) {
            self.farmId = farmId
            self.fleetId = fleetId
            self.workerId = workerId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.farmId, key: "farmId")
            request.encodePath(self.fleetId, key: "fleetId")
            request.encodePath(self.workerId, key: "workerId")
        }

        public func validate(name: String) throws {
            try self.validate(self.farmId, name: "farmId", parent: name, pattern: "^farm-[0-9a-f]{32}$")
            try self.validate(self.fleetId, name: "fleetId", parent: name, pattern: "^fleet-[0-9a-f]{32}$")
            try self.validate(self.workerId, name: "workerId", parent: name, pattern: "^worker-[0-9a-f]{32}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct AssumeFleetRoleForWorkerResponse: AWSDecodableShape {
        /// The credentials for the worker.
        public let credentials: AwsCredentials

        @inlinable
        public init(credentials: AwsCredentials) {
            self.credentials = credentials
        }

        private enum CodingKeys: String, CodingKey {
            case credentials = "credentials"
        }
    }

    public struct AssumeQueueRoleForReadRequest: AWSEncodableShape {
        /// The farm ID of the farm containing the queue.
        public let farmId: String
        /// The queue ID.
        public let queueId: String

        @inlinable
        public init(farmId: String, queueId: String) {
            self.farmId = farmId
            self.queueId = queueId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.farmId, key: "farmId")
            request.encodePath(self.queueId, key: "queueId")
        }

        public func validate(name: String) throws {
            try self.validate(self.farmId, name: "farmId", parent: name, pattern: "^farm-[0-9a-f]{32}$")
            try self.validate(self.queueId, name: "queueId", parent: name, pattern: "^queue-[0-9a-f]{32}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct AssumeQueueRoleForReadResponse: AWSDecodableShape {
        /// The credentials for the queue role.
        public let credentials: AwsCredentials

        @inlinable
        public init(credentials: AwsCredentials) {
            self.credentials = credentials
        }

        private enum CodingKeys: String, CodingKey {
            case credentials = "credentials"
        }
    }

    public struct AssumeQueueRoleForUserRequest: AWSEncodableShape {
        /// The farm ID of the queue that the user assumes the role for.
        public let farmId: String
        /// The queue ID of the queue that the user assumes the role for.
        public let queueId: String

        @inlinable
        public init(farmId: String, queueId: String) {
            self.farmId = farmId
            self.queueId = queueId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.farmId, key: "farmId")
            request.encodePath(self.queueId, key: "queueId")
        }

        public func validate(name: String) throws {
            try self.validate(self.farmId, name: "farmId", parent: name, pattern: "^farm-[0-9a-f]{32}$")
            try self.validate(self.queueId, name: "queueId", parent: name, pattern: "^queue-[0-9a-f]{32}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct AssumeQueueRoleForUserResponse: AWSDecodableShape {
        /// The credentials for the queue role that a user has access to.
        public let credentials: AwsCredentials

        @inlinable
        public init(credentials: AwsCredentials) {
            self.credentials = credentials
        }

        private enum CodingKeys: String, CodingKey {
            case credentials = "credentials"
        }
    }

    public struct AssumeQueueRoleForWorkerRequest: AWSEncodableShape {
        /// The farm ID of the worker assuming the queue role.
        public let farmId: String
        /// The fleet ID of the worker assuming the queue role.
        public let fleetId: String
        /// The queue ID of the worker assuming the queue role.
        public let queueId: String
        /// The worker ID of the worker assuming the queue role.
        public let workerId: String

        @inlinable
        public init(farmId: String, fleetId: String, queueId: String, workerId: String) {
            self.farmId = farmId
            self.fleetId = fleetId
            self.queueId = queueId
            self.workerId = workerId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.farmId, key: "farmId")
            request.encodePath(self.fleetId, key: "fleetId")
            request.encodeQuery(self.queueId, key: "queueId")
            request.encodePath(self.workerId, key: "workerId")
        }

        public func validate(name: String) throws {
            try self.validate(self.farmId, name: "farmId", parent: name, pattern: "^farm-[0-9a-f]{32}$")
            try self.validate(self.fleetId, name: "fleetId", parent: name, pattern: "^fleet-[0-9a-f]{32}$")
            try self.validate(self.queueId, name: "queueId", parent: name, pattern: "^queue-[0-9a-f]{32}$")
            try self.validate(self.workerId, name: "workerId", parent: name, pattern: "^worker-[0-9a-f]{32}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct AssumeQueueRoleForWorkerResponse: AWSDecodableShape {
        /// The Amazon Web Services credentials for the role that the worker is assuming.
        public let credentials: AwsCredentials?

        @inlinable
        public init(credentials: AwsCredentials? = nil) {
            self.credentials = credentials
        }

        private enum CodingKeys: String, CodingKey {
            case credentials = "credentials"
        }
    }

    public struct Attachments: AWSEncodableShape & AWSDecodableShape {
        /// The file system.
        public let fileSystem: JobAttachmentsFileSystem?
        /// A list of manifests which describe job attachment configurations.
        public let manifests: [ManifestProperties]

        @inlinable
        public init(fileSystem: JobAttachmentsFileSystem? = nil, manifests: [ManifestProperties]) {
            self.fileSystem = fileSystem
            self.manifests = manifests
        }

        public func validate(name: String) throws {
            try self.manifests.forEach {
                try $0.validate(name: "\(name).manifests[]")
            }
            try self.validate(self.manifests, name: "manifests", parent: name, max: 10)
            try self.validate(self.manifests, name: "manifests", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case fileSystem = "fileSystem"
            case manifests = "manifests"
        }
    }

    public struct AwsCredentials: AWSDecodableShape {
        /// The IAM access key ID.
        public let accessKeyId: String
        /// The expiration date and time of the IAM credentials.
        @CustomCoding<ISO8601DateCoder>
        public var expiration: Date
        /// The IAM secret access key.
        public let secretAccessKey: String
        /// The IAM session token
        public let sessionToken: String

        @inlinable
        public init(accessKeyId: String, expiration: Date, secretAccessKey: String, sessionToken: String) {
            self.accessKeyId = accessKeyId
            self.expiration = expiration
            self.secretAccessKey = secretAccessKey
            self.sessionToken = sessionToken
        }

        private enum CodingKeys: String, CodingKey {
            case accessKeyId = "accessKeyId"
            case expiration = "expiration"
            case secretAccessKey = "secretAccessKey"
            case sessionToken = "sessionToken"
        }
    }

    public struct BatchGetJobEntityRequest: AWSEncodableShape {
        /// The farm ID of the worker that's fetching job details. The worker must have an assignment on a job to fetch job details.
        public let farmId: String
        /// The fleet ID of the worker that's fetching job details. The worker must have an assignment on a job to fetch job details.
        public let fleetId: String
        /// The job identifiers to include within the job entity batch details.
        public let identifiers: [JobEntityIdentifiersUnion]
        /// The worker ID of the worker containing the job details to get.
        public let workerId: String

        @inlinable
        public init(farmId: String, fleetId: String, identifiers: [JobEntityIdentifiersUnion], workerId: String) {
            self.farmId = farmId
            self.fleetId = fleetId
            self.identifiers = identifiers
            self.workerId = workerId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.farmId, key: "farmId")
            request.encodePath(self.fleetId, key: "fleetId")
            try container.encode(self.identifiers, forKey: .identifiers)
            request.encodePath(self.workerId, key: "workerId")
        }

        public func validate(name: String) throws {
            try self.validate(self.farmId, name: "farmId", parent: name, pattern: "^farm-[0-9a-f]{32}$")
            try self.validate(self.fleetId, name: "fleetId", parent: name, pattern: "^fleet-[0-9a-f]{32}$")
            try self.identifiers.forEach {
                try $0.validate(name: "\(name).identifiers[]")
            }
            try self.validate(self.identifiers, name: "identifiers", parent: name, max: 10)
            try self.validate(self.identifiers, name: "identifiers", parent: name, min: 1)
            try self.validate(self.workerId, name: "workerId", parent: name, pattern: "^worker-[0-9a-f]{32}$")
        }

        private enum CodingKeys: String, CodingKey {
            case identifiers = "identifiers"
        }
    }

    public struct BatchGetJobEntityResponse: AWSDecodableShape {
        /// A list of the job entities, or details, in the batch.
        public let entities: [JobEntity]
        /// A list of errors from the job error logs for the batch.
        public let errors: [GetJobEntityError]

        @inlinable
        public init(entities: [JobEntity], errors: [GetJobEntityError]) {
            self.entities = entities
            self.errors = errors
        }

        private enum CodingKeys: String, CodingKey {
            case entities = "entities"
            case errors = "errors"
        }
    }

    public struct BudgetActionToAdd: AWSEncodableShape {
        /// A description for the budget action to add.  This field can store any content. Escape or encode this content before displaying it on a webpage or any other system that might interpret the content of this field.
        public let description: String?
        /// The percentage threshold for the budget action to add.
        public let thresholdPercentage: Float
        /// The type of budget action to add.
        public let type: BudgetActionType

        @inlinable
        public init(description: String? = nil, thresholdPercentage: Float, type: BudgetActionType) {
            self.description = description
            self.thresholdPercentage = thresholdPercentage
            self.type = type
        }

        public func validate(name: String) throws {
            try self.validate(self.description, name: "description", parent: name, max: 100)
            try self.validate(self.thresholdPercentage, name: "thresholdPercentage", parent: name, max: 100.0)
            try self.validate(self.thresholdPercentage, name: "thresholdPercentage", parent: name, min: 0.0)
        }

        private enum CodingKeys: String, CodingKey {
            case description = "description"
            case thresholdPercentage = "thresholdPercentage"
            case type = "type"
        }
    }

    public struct BudgetActionToRemove: AWSEncodableShape {
        /// The percentage threshold for the budget action to remove.
        public let thresholdPercentage: Float
        /// The type of budget action to remove.
        public let type: BudgetActionType

        @inlinable
        public init(thresholdPercentage: Float, type: BudgetActionType) {
            self.thresholdPercentage = thresholdPercentage
            self.type = type
        }

        public func validate(name: String) throws {
            try self.validate(self.thresholdPercentage, name: "thresholdPercentage", parent: name, max: 100.0)
            try self.validate(self.thresholdPercentage, name: "thresholdPercentage", parent: name, min: 0.0)
        }

        private enum CodingKeys: String, CodingKey {
            case thresholdPercentage = "thresholdPercentage"
            case type = "type"
        }
    }

    public struct BudgetSummary: AWSDecodableShape {
        /// The approximate dollar limit of the budget.
        public let approximateDollarLimit: Float
        /// The budget ID.
        public let budgetId: String
        /// The date and time the resource was created.
        @CustomCoding<ISO8601DateCoder>
        public var createdAt: Date
        /// The user or system that created this resource.
        public let createdBy: String
        /// The description of the budget summary.  This field can store any content. Escape or encode this content before displaying it on a webpage or any other system that might interpret the content of this field.
        public let description: String?
        /// The display name of the budget summary to update.  This field can store any content. Escape or encode this content before displaying it on a webpage or any other system that might interpret the content of this field.
        public let displayName: String
        /// The status of the budget.    ACTIVEThe budget is being evaluated.    INACTIVEThe budget is inactive. This can include Expired, Canceled, or deleted Deleted statuses.
        public let status: BudgetStatus
        /// The date and time the resource was updated.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var updatedAt: Date?
        /// The user or system that updated this resource.
        public let updatedBy: String?
        /// The consumed usage for the budget.
        public let usages: ConsumedUsages
        /// The resource used to track expenditure in the budget.
        public let usageTrackingResource: UsageTrackingResource

        @inlinable
        public init(approximateDollarLimit: Float, budgetId: String, createdAt: Date, createdBy: String, displayName: String, status: BudgetStatus, updatedAt: Date? = nil, updatedBy: String? = nil, usages: ConsumedUsages, usageTrackingResource: UsageTrackingResource) {
            self.approximateDollarLimit = approximateDollarLimit
            self.budgetId = budgetId
            self.createdAt = createdAt
            self.createdBy = createdBy
            self.description = nil
            self.displayName = displayName
            self.status = status
            self.updatedAt = updatedAt
            self.updatedBy = updatedBy
            self.usages = usages
            self.usageTrackingResource = usageTrackingResource
        }

        @available(*, deprecated, message: "Members description have been deprecated")
        @inlinable
        public init(approximateDollarLimit: Float, budgetId: String, createdAt: Date, createdBy: String, description: String? = nil, displayName: String, status: BudgetStatus, updatedAt: Date? = nil, updatedBy: String? = nil, usages: ConsumedUsages, usageTrackingResource: UsageTrackingResource) {
            self.approximateDollarLimit = approximateDollarLimit
            self.budgetId = budgetId
            self.createdAt = createdAt
            self.createdBy = createdBy
            self.description = description
            self.displayName = displayName
            self.status = status
            self.updatedAt = updatedAt
            self.updatedBy = updatedBy
            self.usages = usages
            self.usageTrackingResource = usageTrackingResource
        }

        private enum CodingKeys: String, CodingKey {
            case approximateDollarLimit = "approximateDollarLimit"
            case budgetId = "budgetId"
            case createdAt = "createdAt"
            case createdBy = "createdBy"
            case description = "description"
            case displayName = "displayName"
            case status = "status"
            case updatedAt = "updatedAt"
            case updatedBy = "updatedBy"
            case usages = "usages"
            case usageTrackingResource = "usageTrackingResource"
        }
    }

    public struct ConflictException: AWSErrorShape {
        /// Information about the resources in use when the exception was thrown.
        public let context: [String: String]?
        public let message: String
        /// A description of the error.
        public let reason: ConflictExceptionReason
        /// The identifier of the resource in use.
        public let resourceId: String
        /// The type of the resource in use.
        public let resourceType: String

        @inlinable
        public init(context: [String: String]? = nil, message: String, reason: ConflictExceptionReason, resourceId: String, resourceType: String) {
            self.context = context
            self.message = message
            self.reason = reason
            self.resourceId = resourceId
            self.resourceType = resourceType
        }

        private enum CodingKeys: String, CodingKey {
            case context = "context"
            case message = "message"
            case reason = "reason"
            case resourceId = "resourceId"
            case resourceType = "resourceType"
        }
    }

    public struct ConsumedUsages: AWSDecodableShape {
        /// The amount of the budget consumed.
        public let approximateDollarUsage: Float

        @inlinable
        public init(approximateDollarUsage: Float) {
            self.approximateDollarUsage = approximateDollarUsage
        }

        private enum CodingKeys: String, CodingKey {
            case approximateDollarUsage = "approximateDollarUsage"
        }
    }

    public struct CopyJobTemplateRequest: AWSEncodableShape {
        /// The farm ID to copy.
        public let farmId: String
        /// The job ID to copy.
        public let jobId: String
        /// The queue ID to copy.
        public let queueId: String
        /// The Amazon S3 bucket name and key where you would like to add a copy of the job template.
        public let targetS3Location: S3Location

        @inlinable
        public init(farmId: String, jobId: String, queueId: String, targetS3Location: S3Location) {
            self.farmId = farmId
            self.jobId = jobId
            self.queueId = queueId
            self.targetS3Location = targetS3Location
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.farmId, key: "farmId")
            request.encodePath(self.jobId, key: "jobId")
            request.encodePath(self.queueId, key: "queueId")
            try container.encode(self.targetS3Location, forKey: .targetS3Location)
        }

        public func validate(name: String) throws {
            try self.validate(self.farmId, name: "farmId", parent: name, pattern: "^farm-[0-9a-f]{32}$")
            try self.validate(self.jobId, name: "jobId", parent: name, pattern: "^job-[0-9a-f]{32}$")
            try self.validate(self.queueId, name: "queueId", parent: name, pattern: "^queue-[0-9a-f]{32}$")
            try self.targetS3Location.validate(name: "\(name).targetS3Location")
        }

        private enum CodingKeys: String, CodingKey {
            case targetS3Location = "targetS3Location"
        }
    }

    public struct CopyJobTemplateResponse: AWSDecodableShape {
        /// The format of the job template, either JSON or YAML.
        public let templateType: JobTemplateType

        @inlinable
        public init(templateType: JobTemplateType) {
            self.templateType = templateType
        }

        private enum CodingKeys: String, CodingKey {
            case templateType = "templateType"
        }
    }

    public struct CreateBudgetRequest: AWSEncodableShape {
        /// The budget actions to specify what happens when the budget runs out.
        public let actions: [BudgetActionToAdd]
        /// The dollar limit based on consumed usage.
        public let approximateDollarLimit: Float
        /// The unique token which the server uses to recognize retries of the same request.
        public let clientToken: String?
        /// The description of the budget.  This field can store any content. Escape or encode this content before displaying it on a webpage or any other system that might interpret the content of this field.
        public let description: String?
        /// The display name of the budget.  This field can store any content. Escape or encode this content before displaying it on a webpage or any other system that might interpret the content of this field.
        public let displayName: String
        /// The farm ID to include in this budget.
        public let farmId: String
        /// The schedule to associate with this budget.
        public let schedule: BudgetSchedule
        /// The queue ID provided to this budget to track usage.
        public let usageTrackingResource: UsageTrackingResource

        @inlinable
        public init(actions: [BudgetActionToAdd], approximateDollarLimit: Float, clientToken: String? = CreateBudgetRequest.idempotencyToken(), description: String? = nil, displayName: String, farmId: String, schedule: BudgetSchedule, usageTrackingResource: UsageTrackingResource) {
            self.actions = actions
            self.approximateDollarLimit = approximateDollarLimit
            self.clientToken = clientToken
            self.description = description
            self.displayName = displayName
            self.farmId = farmId
            self.schedule = schedule
            self.usageTrackingResource = usageTrackingResource
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encode(self.actions, forKey: .actions)
            try container.encode(self.approximateDollarLimit, forKey: .approximateDollarLimit)
            request.encodeHeader(self.clientToken, key: "X-Amz-Client-Token")
            try container.encodeIfPresent(self.description, forKey: .description)
            try container.encode(self.displayName, forKey: .displayName)
            request.encodePath(self.farmId, key: "farmId")
            try container.encode(self.schedule, forKey: .schedule)
            try container.encode(self.usageTrackingResource, forKey: .usageTrackingResource)
        }

        public func validate(name: String) throws {
            try self.actions.forEach {
                try $0.validate(name: "\(name).actions[]")
            }
            try self.validate(self.actions, name: "actions", parent: name, max: 10)
            try self.validate(self.approximateDollarLimit, name: "approximateDollarLimit", parent: name, min: 0.01)
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 64)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.validate(self.description, name: "description", parent: name, max: 100)
            try self.validate(self.displayName, name: "displayName", parent: name, max: 100)
            try self.validate(self.displayName, name: "displayName", parent: name, min: 1)
            try self.validate(self.farmId, name: "farmId", parent: name, pattern: "^farm-[0-9a-f]{32}$")
            try self.usageTrackingResource.validate(name: "\(name).usageTrackingResource")
        }

        private enum CodingKeys: String, CodingKey {
            case actions = "actions"
            case approximateDollarLimit = "approximateDollarLimit"
            case description = "description"
            case displayName = "displayName"
            case schedule = "schedule"
            case usageTrackingResource = "usageTrackingResource"
        }
    }

    public struct CreateBudgetResponse: AWSDecodableShape {
        /// The budget ID.
        public let budgetId: String

        @inlinable
        public init(budgetId: String) {
            self.budgetId = budgetId
        }

        private enum CodingKeys: String, CodingKey {
            case budgetId = "budgetId"
        }
    }

    public struct CreateFarmRequest: AWSEncodableShape {
        /// The unique token which the server uses to recognize retries of the same request.
        public let clientToken: String?
        /// The description of the farm.  This field can store any content. Escape or encode this content before displaying it on a webpage or any other system that might interpret the content of this field.
        public let description: String?
        /// The display name of the farm.  This field can store any content. Escape or encode this content before displaying it on a webpage or any other system that might interpret the content of this field.
        public let displayName: String
        /// The ARN of the KMS key to use on the farm.
        public let kmsKeyArn: String?
        /// The tags to add to your farm. Each tag consists of a tag key and a tag value. Tag keys and values are both required, but tag values can be empty strings.
        public let tags: [String: String]?

        @inlinable
        public init(clientToken: String? = CreateFarmRequest.idempotencyToken(), description: String? = nil, displayName: String, kmsKeyArn: String? = nil, tags: [String: String]? = nil) {
            self.clientToken = clientToken
            self.description = description
            self.displayName = displayName
            self.kmsKeyArn = kmsKeyArn
            self.tags = tags
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodeHeader(self.clientToken, key: "X-Amz-Client-Token")
            try container.encodeIfPresent(self.description, forKey: .description)
            try container.encode(self.displayName, forKey: .displayName)
            try container.encodeIfPresent(self.kmsKeyArn, forKey: .kmsKeyArn)
            try container.encodeIfPresent(self.tags, forKey: .tags)
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 64)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.validate(self.description, name: "description", parent: name, max: 100)
            try self.validate(self.displayName, name: "displayName", parent: name, max: 100)
            try self.validate(self.displayName, name: "displayName", parent: name, min: 1)
            try self.validate(self.kmsKeyArn, name: "kmsKeyArn", parent: name, pattern: "^arn:(aws[a-zA-Z-]*):kms:[a-z]{2}((-gov)|(-iso(b?)))?-[a-z]+-\\d{1}:\\d{12}:key/[\\w-]{1,120}$")
        }

        private enum CodingKeys: String, CodingKey {
            case description = "description"
            case displayName = "displayName"
            case kmsKeyArn = "kmsKeyArn"
            case tags = "tags"
        }
    }

    public struct CreateFarmResponse: AWSDecodableShape {
        /// The farm ID.
        public let farmId: String

        @inlinable
        public init(farmId: String) {
            self.farmId = farmId
        }

        private enum CodingKeys: String, CodingKey {
            case farmId = "farmId"
        }
    }

    public struct CreateFleetRequest: AWSEncodableShape {
        /// The unique token which the server uses to recognize retries of the same request.
        public let clientToken: String?
        /// The configuration settings for the fleet. Customer managed fleets are self-managed. Service managed Amazon EC2 fleets are managed by Deadline Cloud.
        public let configuration: FleetConfiguration
        /// The description of the fleet.  This field can store any content. Escape or encode this content before displaying it on a webpage or any other system that might interpret the content of this field.
        public let description: String?
        /// The display name of the fleet.  This field can store any content. Escape or encode this content before displaying it on a webpage or any other system that might interpret the content of this field.
        public let displayName: String
        /// The farm ID of the farm to connect to the fleet.
        public let farmId: String
        /// The maximum number of workers for the fleet.
        public let maxWorkerCount: Int
        /// The minimum number of workers for the fleet.
        public let minWorkerCount: Int?
        /// The IAM role ARN for the role that the fleet's workers will use.
        public let roleArn: String
        /// Each tag consists of a tag key and a tag value. Tag keys and values are both required, but tag values can be empty strings.
        public let tags: [String: String]?

        @inlinable
        public init(clientToken: String? = CreateFleetRequest.idempotencyToken(), configuration: FleetConfiguration, description: String? = nil, displayName: String, farmId: String, maxWorkerCount: Int, minWorkerCount: Int? = nil, roleArn: String, tags: [String: String]? = nil) {
            self.clientToken = clientToken
            self.configuration = configuration
            self.description = description
            self.displayName = displayName
            self.farmId = farmId
            self.maxWorkerCount = maxWorkerCount
            self.minWorkerCount = minWorkerCount
            self.roleArn = roleArn
            self.tags = tags
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodeHeader(self.clientToken, key: "X-Amz-Client-Token")
            try container.encode(self.configuration, forKey: .configuration)
            try container.encodeIfPresent(self.description, forKey: .description)
            try container.encode(self.displayName, forKey: .displayName)
            request.encodePath(self.farmId, key: "farmId")
            try container.encode(self.maxWorkerCount, forKey: .maxWorkerCount)
            try container.encodeIfPresent(self.minWorkerCount, forKey: .minWorkerCount)
            try container.encode(self.roleArn, forKey: .roleArn)
            try container.encodeIfPresent(self.tags, forKey: .tags)
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 64)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.configuration.validate(name: "\(name).configuration")
            try self.validate(self.description, name: "description", parent: name, max: 100)
            try self.validate(self.displayName, name: "displayName", parent: name, max: 100)
            try self.validate(self.displayName, name: "displayName", parent: name, min: 1)
            try self.validate(self.farmId, name: "farmId", parent: name, pattern: "^farm-[0-9a-f]{32}$")
            try self.validate(self.maxWorkerCount, name: "maxWorkerCount", parent: name, max: 2147483647)
            try self.validate(self.maxWorkerCount, name: "maxWorkerCount", parent: name, min: 0)
            try self.validate(self.minWorkerCount, name: "minWorkerCount", parent: name, max: 2147483647)
            try self.validate(self.minWorkerCount, name: "minWorkerCount", parent: name, min: 0)
            try self.validate(self.roleArn, name: "roleArn", parent: name, pattern: "^arn:(aws[a-zA-Z-]*):iam::\\d{12}:role(/[!-.0-~]+)*/[\\w+=,.@-]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case configuration = "configuration"
            case description = "description"
            case displayName = "displayName"
            case maxWorkerCount = "maxWorkerCount"
            case minWorkerCount = "minWorkerCount"
            case roleArn = "roleArn"
            case tags = "tags"
        }
    }

    public struct CreateFleetResponse: AWSDecodableShape {
        /// The fleet ID.
        public let fleetId: String

        @inlinable
        public init(fleetId: String) {
            self.fleetId = fleetId
        }

        private enum CodingKeys: String, CodingKey {
            case fleetId = "fleetId"
        }
    }

    public struct CreateJobRequest: AWSEncodableShape {
        /// The attachments for the job. Attach files required for the job to run to a render job.
        public let attachments: Attachments?
        /// The unique token which the server uses to recognize retries of the same request.
        public let clientToken: String?
        /// The farm ID of the farm to connect to the job.
        public let farmId: String
        /// The number of task failures before the job stops running and is marked as FAILED.
        public let maxFailedTasksCount: Int?
        /// The maximum number of retries for each task.
        public let maxRetriesPerTask: Int?
        /// The maximum number of worker hosts that can concurrently process a job. When the maxWorkerCount is reached, no more workers will be assigned to process the job, even if the fleets assigned to the job's queue has available workers. You can't set the maxWorkerCount to 0. If you set it to -1, there is no maximum number of workers. If you don't specify the maxWorkerCount, Deadline Cloud won't throttle the number of workers used to process the job.
        public let maxWorkerCount: Int?
        /// The parameters for the job.
        public let parameters: [String: JobParameter]?
        /// The priority of the job. The highest priority (first scheduled) is 100. When two jobs have the same priority, the oldest job is scheduled first.
        public let priority: Int
        /// The ID of the queue that the job is submitted to.
        public let queueId: String
        /// The job ID for the source job.
        public let sourceJobId: String?
        /// The storage profile ID for the storage profile to connect to the job.
        public let storageProfileId: String?
        /// The initial job status when it is created. Jobs that are created with a SUSPENDED status will not run until manually requeued.
        public let targetTaskRunStatus: CreateJobTargetTaskRunStatus?
        /// The job template to use for this job.
        public let template: String?
        /// The file type for the job template.
        public let templateType: JobTemplateType?

        @inlinable
        public init(attachments: Attachments? = nil, clientToken: String? = CreateJobRequest.idempotencyToken(), farmId: String, maxFailedTasksCount: Int? = nil, maxRetriesPerTask: Int? = nil, maxWorkerCount: Int? = nil, parameters: [String: JobParameter]? = nil, priority: Int, queueId: String, sourceJobId: String? = nil, storageProfileId: String? = nil, targetTaskRunStatus: CreateJobTargetTaskRunStatus? = nil, template: String? = nil, templateType: JobTemplateType? = nil) {
            self.attachments = attachments
            self.clientToken = clientToken
            self.farmId = farmId
            self.maxFailedTasksCount = maxFailedTasksCount
            self.maxRetriesPerTask = maxRetriesPerTask
            self.maxWorkerCount = maxWorkerCount
            self.parameters = parameters
            self.priority = priority
            self.queueId = queueId
            self.sourceJobId = sourceJobId
            self.storageProfileId = storageProfileId
            self.targetTaskRunStatus = targetTaskRunStatus
            self.template = template
            self.templateType = templateType
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.attachments, forKey: .attachments)
            request.encodeHeader(self.clientToken, key: "X-Amz-Client-Token")
            request.encodePath(self.farmId, key: "farmId")
            try container.encodeIfPresent(self.maxFailedTasksCount, forKey: .maxFailedTasksCount)
            try container.encodeIfPresent(self.maxRetriesPerTask, forKey: .maxRetriesPerTask)
            try container.encodeIfPresent(self.maxWorkerCount, forKey: .maxWorkerCount)
            try container.encodeIfPresent(self.parameters, forKey: .parameters)
            try container.encode(self.priority, forKey: .priority)
            request.encodePath(self.queueId, key: "queueId")
            try container.encodeIfPresent(self.sourceJobId, forKey: .sourceJobId)
            try container.encodeIfPresent(self.storageProfileId, forKey: .storageProfileId)
            try container.encodeIfPresent(self.targetTaskRunStatus, forKey: .targetTaskRunStatus)
            try container.encodeIfPresent(self.template, forKey: .template)
            try container.encodeIfPresent(self.templateType, forKey: .templateType)
        }

        public func validate(name: String) throws {
            try self.attachments?.validate(name: "\(name).attachments")
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 64)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.validate(self.farmId, name: "farmId", parent: name, pattern: "^farm-[0-9a-f]{32}$")
            try self.validate(self.maxFailedTasksCount, name: "maxFailedTasksCount", parent: name, max: 2147483647)
            try self.validate(self.maxFailedTasksCount, name: "maxFailedTasksCount", parent: name, min: 0)
            try self.validate(self.maxRetriesPerTask, name: "maxRetriesPerTask", parent: name, max: 2147483647)
            try self.validate(self.maxRetriesPerTask, name: "maxRetriesPerTask", parent: name, min: 0)
            try self.validate(self.maxWorkerCount, name: "maxWorkerCount", parent: name, max: 2147483647)
            try self.validate(self.maxWorkerCount, name: "maxWorkerCount", parent: name, min: -1)
            try self.parameters?.forEach {
                try $0.value.validate(name: "\(name).parameters[\"\($0.key)\"]")
            }
            try self.validate(self.priority, name: "priority", parent: name, max: 100)
            try self.validate(self.priority, name: "priority", parent: name, min: 0)
            try self.validate(self.queueId, name: "queueId", parent: name, pattern: "^queue-[0-9a-f]{32}$")
            try self.validate(self.sourceJobId, name: "sourceJobId", parent: name, pattern: "^job-[0-9a-f]{32}$")
            try self.validate(self.storageProfileId, name: "storageProfileId", parent: name, pattern: "^sp-[0-9a-f]{32}$")
            try self.validate(self.template, name: "template", parent: name, max: 300000)
            try self.validate(self.template, name: "template", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case attachments = "attachments"
            case maxFailedTasksCount = "maxFailedTasksCount"
            case maxRetriesPerTask = "maxRetriesPerTask"
            case maxWorkerCount = "maxWorkerCount"
            case parameters = "parameters"
            case priority = "priority"
            case sourceJobId = "sourceJobId"
            case storageProfileId = "storageProfileId"
            case targetTaskRunStatus = "targetTaskRunStatus"
            case template = "template"
            case templateType = "templateType"
        }
    }

    public struct CreateJobResponse: AWSDecodableShape {
        /// The job ID.
        public let jobId: String

        @inlinable
        public init(jobId: String) {
            self.jobId = jobId
        }

        private enum CodingKeys: String, CodingKey {
            case jobId = "jobId"
        }
    }

    public struct CreateLicenseEndpointRequest: AWSEncodableShape {
        /// The unique token which the server uses to recognize retries of the same request.
        public let clientToken: String?
        /// The security group IDs.
        public let securityGroupIds: [String]
        /// The subnet IDs.
        public let subnetIds: [String]
        /// Each tag consists of a tag key and a tag value. Tag keys and values are both required, but tag values can be empty strings.
        public let tags: [String: String]?
        /// The VPC (virtual private cloud) ID to use with the license endpoint.
        public let vpcId: String

        @inlinable
        public init(clientToken: String? = CreateLicenseEndpointRequest.idempotencyToken(), securityGroupIds: [String], subnetIds: [String], tags: [String: String]? = nil, vpcId: String) {
            self.clientToken = clientToken
            self.securityGroupIds = securityGroupIds
            self.subnetIds = subnetIds
            self.tags = tags
            self.vpcId = vpcId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodeHeader(self.clientToken, key: "X-Amz-Client-Token")
            try container.encode(self.securityGroupIds, forKey: .securityGroupIds)
            try container.encode(self.subnetIds, forKey: .subnetIds)
            try container.encodeIfPresent(self.tags, forKey: .tags)
            try container.encode(self.vpcId, forKey: .vpcId)
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 64)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.securityGroupIds.forEach {
                try validate($0, name: "securityGroupIds[]", parent: name, pattern: "^sg-[\\w]{1,120}$")
            }
            try self.validate(self.securityGroupIds, name: "securityGroupIds", parent: name, max: 10)
            try self.validate(self.securityGroupIds, name: "securityGroupIds", parent: name, min: 1)
            try self.subnetIds.forEach {
                try validate($0, name: "subnetIds[]", parent: name, max: 32)
                try validate($0, name: "subnetIds[]", parent: name, min: 1)
                try validate($0, name: "subnetIds[]", parent: name, pattern: "^subnet-[\\w]{1,120}$")
            }
            try self.validate(self.subnetIds, name: "subnetIds", parent: name, max: 10)
            try self.validate(self.subnetIds, name: "subnetIds", parent: name, min: 1)
            try self.validate(self.vpcId, name: "vpcId", parent: name, max: 32)
            try self.validate(self.vpcId, name: "vpcId", parent: name, min: 1)
            try self.validate(self.vpcId, name: "vpcId", parent: name, pattern: "^vpc-[\\w]{1,120}$")
        }

        private enum CodingKeys: String, CodingKey {
            case securityGroupIds = "securityGroupIds"
            case subnetIds = "subnetIds"
            case tags = "tags"
            case vpcId = "vpcId"
        }
    }

    public struct CreateLicenseEndpointResponse: AWSDecodableShape {
        /// The license endpoint ID.
        public let licenseEndpointId: String

        @inlinable
        public init(licenseEndpointId: String) {
            self.licenseEndpointId = licenseEndpointId
        }

        private enum CodingKeys: String, CodingKey {
            case licenseEndpointId = "licenseEndpointId"
        }
    }

    public struct CreateLimitRequest: AWSEncodableShape {
        /// The value that you specify as the name in the amounts field of the hostRequirements in a step of a job template to declare the limit requirement.
        public let amountRequirementName: String
        /// The unique token which the server uses to recognize retries of the same request.
        public let clientToken: String?
        /// A description of the limit. A description helps you identify the purpose of the limit.  This field can store any content. Escape or encode this content before displaying it on a webpage or any other system that might interpret the content of this field.
        public let description: String?
        /// The display name of the limit.  This field can store any content. Escape or encode this content before displaying it on a webpage or any other system that might interpret the content of this field.
        public let displayName: String
        /// The farm ID of the farm that contains the limit.
        public let farmId: String
        /// The maximum number of resources constrained by this limit. When all of the resources are in use, steps that require the limit won't be scheduled until the resource is available. The maxCount must not be 0. If the value is -1, there is no restriction on the number of resources that can be acquired for this limit.
        public let maxCount: Int

        @inlinable
        public init(amountRequirementName: String, clientToken: String? = CreateLimitRequest.idempotencyToken(), description: String? = nil, displayName: String, farmId: String, maxCount: Int) {
            self.amountRequirementName = amountRequirementName
            self.clientToken = clientToken
            self.description = description
            self.displayName = displayName
            self.farmId = farmId
            self.maxCount = maxCount
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encode(self.amountRequirementName, forKey: .amountRequirementName)
            request.encodeHeader(self.clientToken, key: "X-Amz-Client-Token")
            try container.encodeIfPresent(self.description, forKey: .description)
            try container.encode(self.displayName, forKey: .displayName)
            request.encodePath(self.farmId, key: "farmId")
            try container.encode(self.maxCount, forKey: .maxCount)
        }

        public func validate(name: String) throws {
            try self.validate(self.amountRequirementName, name: "amountRequirementName", parent: name, max: 1024)
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 64)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.validate(self.description, name: "description", parent: name, max: 100)
            try self.validate(self.displayName, name: "displayName", parent: name, max: 100)
            try self.validate(self.displayName, name: "displayName", parent: name, min: 1)
            try self.validate(self.farmId, name: "farmId", parent: name, pattern: "^farm-[0-9a-f]{32}$")
            try self.validate(self.maxCount, name: "maxCount", parent: name, max: 2147483647)
            try self.validate(self.maxCount, name: "maxCount", parent: name, min: -1)
        }

        private enum CodingKeys: String, CodingKey {
            case amountRequirementName = "amountRequirementName"
            case description = "description"
            case displayName = "displayName"
            case maxCount = "maxCount"
        }
    }

    public struct CreateLimitResponse: AWSDecodableShape {
        /// A unique identifier for the limit. Use this identifier in other operations, such as CreateQueueLimitAssociation and DeleteLimit.
        public let limitId: String

        @inlinable
        public init(limitId: String) {
            self.limitId = limitId
        }

        private enum CodingKeys: String, CodingKey {
            case limitId = "limitId"
        }
    }

    public struct CreateMonitorRequest: AWSEncodableShape {
        /// The unique token which the server uses to recognize retries of the same request.
        public let clientToken: String?
        /// The name that you give the monitor that is displayed in the Deadline Cloud console.  This field can store any content. Escape or encode this content before displaying it on a webpage or any other system that might interpret the content of this field.
        public let displayName: String
        /// The Amazon Resource Name (ARN) of the IAM Identity Center instance that authenticates monitor users.
        public let identityCenterInstanceArn: String
        /// The Amazon Resource Name (ARN) of the IAM role that the monitor uses to connect to Deadline Cloud. Every user that signs in to the monitor using IAM Identity Center uses this role to access Deadline Cloud resources.
        public let roleArn: String
        /// The subdomain to use when creating the monitor URL. The full URL of the monitor is subdomain.Region.deadlinecloud.amazonaws.com.
        public let subdomain: String

        @inlinable
        public init(clientToken: String? = CreateMonitorRequest.idempotencyToken(), displayName: String, identityCenterInstanceArn: String, roleArn: String, subdomain: String) {
            self.clientToken = clientToken
            self.displayName = displayName
            self.identityCenterInstanceArn = identityCenterInstanceArn
            self.roleArn = roleArn
            self.subdomain = subdomain
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodeHeader(self.clientToken, key: "X-Amz-Client-Token")
            try container.encode(self.displayName, forKey: .displayName)
            try container.encode(self.identityCenterInstanceArn, forKey: .identityCenterInstanceArn)
            try container.encode(self.roleArn, forKey: .roleArn)
            try container.encode(self.subdomain, forKey: .subdomain)
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 64)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.validate(self.displayName, name: "displayName", parent: name, max: 100)
            try self.validate(self.displayName, name: "displayName", parent: name, min: 1)
            try self.validate(self.identityCenterInstanceArn, name: "identityCenterInstanceArn", parent: name, pattern: "^arn:(aws|aws-us-gov|aws-cn|aws-iso|aws-iso-b):sso:::instance/(sso)?ins-[a-zA-Z0-9-.]{16}$")
            try self.validate(self.roleArn, name: "roleArn", parent: name, pattern: "^arn:(aws[a-zA-Z-]*):iam::\\d{12}:role(/[!-.0-~]+)*/[\\w+=,.@-]+$")
            try self.validate(self.subdomain, name: "subdomain", parent: name, pattern: "^[a-z0-9-]{1,100}$")
        }

        private enum CodingKeys: String, CodingKey {
            case displayName = "displayName"
            case identityCenterInstanceArn = "identityCenterInstanceArn"
            case roleArn = "roleArn"
            case subdomain = "subdomain"
        }
    }

    public struct CreateMonitorResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) that IAM Identity Center assigns to the monitor.
        public let identityCenterApplicationArn: String
        /// The unique identifier of the monitor.
        public let monitorId: String

        @inlinable
        public init(identityCenterApplicationArn: String, monitorId: String) {
            self.identityCenterApplicationArn = identityCenterApplicationArn
            self.monitorId = monitorId
        }

        private enum CodingKeys: String, CodingKey {
            case identityCenterApplicationArn = "identityCenterApplicationArn"
            case monitorId = "monitorId"
        }
    }

    public struct CreateQueueEnvironmentRequest: AWSEncodableShape {
        /// The unique token which the server uses to recognize retries of the same request.
        public let clientToken: String?
        /// The farm ID of the farm to connect to the environment.
        public let farmId: String
        /// Sets the priority of the environments in the queue from 0 to 10,000, where 0 is the highest priority (activated first and deactivated last). If two environments share the same priority value, the environment created first takes higher priority.
        public let priority: Int
        /// The queue ID to connect the queue and environment.
        public let queueId: String
        /// The environment template to use in the queue.
        public let template: String
        /// The template's file type, JSON or YAML.
        public let templateType: EnvironmentTemplateType

        @inlinable
        public init(clientToken: String? = CreateQueueEnvironmentRequest.idempotencyToken(), farmId: String, priority: Int, queueId: String, template: String, templateType: EnvironmentTemplateType) {
            self.clientToken = clientToken
            self.farmId = farmId
            self.priority = priority
            self.queueId = queueId
            self.template = template
            self.templateType = templateType
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodeHeader(self.clientToken, key: "X-Amz-Client-Token")
            request.encodePath(self.farmId, key: "farmId")
            try container.encode(self.priority, forKey: .priority)
            request.encodePath(self.queueId, key: "queueId")
            try container.encode(self.template, forKey: .template)
            try container.encode(self.templateType, forKey: .templateType)
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 64)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.validate(self.farmId, name: "farmId", parent: name, pattern: "^farm-[0-9a-f]{32}$")
            try self.validate(self.priority, name: "priority", parent: name, max: 10000)
            try self.validate(self.priority, name: "priority", parent: name, min: 0)
            try self.validate(self.queueId, name: "queueId", parent: name, pattern: "^queue-[0-9a-f]{32}$")
            try self.validate(self.template, name: "template", parent: name, max: 15000)
            try self.validate(self.template, name: "template", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case priority = "priority"
            case template = "template"
            case templateType = "templateType"
        }
    }

    public struct CreateQueueEnvironmentResponse: AWSDecodableShape {
        /// The queue environment ID.
        public let queueEnvironmentId: String

        @inlinable
        public init(queueEnvironmentId: String) {
            self.queueEnvironmentId = queueEnvironmentId
        }

        private enum CodingKeys: String, CodingKey {
            case queueEnvironmentId = "queueEnvironmentId"
        }
    }

    public struct CreateQueueFleetAssociationRequest: AWSEncodableShape {
        /// The ID of the farm that the queue and fleet belong to.
        public let farmId: String
        /// The fleet ID.
        public let fleetId: String
        /// The queue ID.
        public let queueId: String

        @inlinable
        public init(farmId: String, fleetId: String, queueId: String) {
            self.farmId = farmId
            self.fleetId = fleetId
            self.queueId = queueId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.farmId, key: "farmId")
            try container.encode(self.fleetId, forKey: .fleetId)
            try container.encode(self.queueId, forKey: .queueId)
        }

        public func validate(name: String) throws {
            try self.validate(self.farmId, name: "farmId", parent: name, pattern: "^farm-[0-9a-f]{32}$")
            try self.validate(self.fleetId, name: "fleetId", parent: name, pattern: "^fleet-[0-9a-f]{32}$")
            try self.validate(self.queueId, name: "queueId", parent: name, pattern: "^queue-[0-9a-f]{32}$")
        }

        private enum CodingKeys: String, CodingKey {
            case fleetId = "fleetId"
            case queueId = "queueId"
        }
    }

    public struct CreateQueueFleetAssociationResponse: AWSDecodableShape {
        public init() {}
    }

    public struct CreateQueueLimitAssociationRequest: AWSEncodableShape {
        /// The unique identifier of the farm that contains the queue and limit to associate.
        public let farmId: String
        /// The unique identifier of the limit to associate with the queue.
        public let limitId: String
        /// The unique identifier of the queue to associate with the limit.
        public let queueId: String

        @inlinable
        public init(farmId: String, limitId: String, queueId: String) {
            self.farmId = farmId
            self.limitId = limitId
            self.queueId = queueId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.farmId, key: "farmId")
            try container.encode(self.limitId, forKey: .limitId)
            try container.encode(self.queueId, forKey: .queueId)
        }

        public func validate(name: String) throws {
            try self.validate(self.farmId, name: "farmId", parent: name, pattern: "^farm-[0-9a-f]{32}$")
            try self.validate(self.limitId, name: "limitId", parent: name, pattern: "^limit-[0-9a-f]{32}$")
            try self.validate(self.queueId, name: "queueId", parent: name, pattern: "^queue-[0-9a-f]{32}$")
        }

        private enum CodingKeys: String, CodingKey {
            case limitId = "limitId"
            case queueId = "queueId"
        }
    }

    public struct CreateQueueLimitAssociationResponse: AWSDecodableShape {
        public init() {}
    }

    public struct CreateQueueRequest: AWSEncodableShape {
        /// The storage profile IDs to include in the queue.
        public let allowedStorageProfileIds: [String]?
        /// The unique token which the server uses to recognize retries of the same request.
        public let clientToken: String?
        /// The default action to take on a queue if a budget isn't configured.
        public let defaultBudgetAction: DefaultQueueBudgetAction?
        /// The description of the queue.  This field can store any content. Escape or encode this content before displaying it on a webpage or any other system that might interpret the content of this field.
        public let description: String?
        /// The display name of the queue.  This field can store any content. Escape or encode this content before displaying it on a webpage or any other system that might interpret the content of this field.
        public let displayName: String
        /// The farm ID of the farm to connect to the queue.
        public let farmId: String
        /// The job attachment settings for the queue. These are the Amazon S3 bucket name and the Amazon S3 prefix.
        public let jobAttachmentSettings: JobAttachmentSettings?
        /// The jobs in the queue run as the specified POSIX user.
        public let jobRunAsUser: JobRunAsUser?
        /// The file system location name to include in the queue.
        public let requiredFileSystemLocationNames: [String]?
        /// The IAM role ARN that workers will use while running jobs for this queue.
        public let roleArn: String?
        /// Each tag consists of a tag key and a tag value. Tag keys and values are both required, but tag values can be empty strings.
        public let tags: [String: String]?

        @inlinable
        public init(allowedStorageProfileIds: [String]? = nil, clientToken: String? = CreateQueueRequest.idempotencyToken(), defaultBudgetAction: DefaultQueueBudgetAction? = nil, description: String? = nil, displayName: String, farmId: String, jobAttachmentSettings: JobAttachmentSettings? = nil, jobRunAsUser: JobRunAsUser? = nil, requiredFileSystemLocationNames: [String]? = nil, roleArn: String? = nil, tags: [String: String]? = nil) {
            self.allowedStorageProfileIds = allowedStorageProfileIds
            self.clientToken = clientToken
            self.defaultBudgetAction = defaultBudgetAction
            self.description = description
            self.displayName = displayName
            self.farmId = farmId
            self.jobAttachmentSettings = jobAttachmentSettings
            self.jobRunAsUser = jobRunAsUser
            self.requiredFileSystemLocationNames = requiredFileSystemLocationNames
            self.roleArn = roleArn
            self.tags = tags
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.allowedStorageProfileIds, forKey: .allowedStorageProfileIds)
            request.encodeHeader(self.clientToken, key: "X-Amz-Client-Token")
            try container.encodeIfPresent(self.defaultBudgetAction, forKey: .defaultBudgetAction)
            try container.encodeIfPresent(self.description, forKey: .description)
            try container.encode(self.displayName, forKey: .displayName)
            request.encodePath(self.farmId, key: "farmId")
            try container.encodeIfPresent(self.jobAttachmentSettings, forKey: .jobAttachmentSettings)
            try container.encodeIfPresent(self.jobRunAsUser, forKey: .jobRunAsUser)
            try container.encodeIfPresent(self.requiredFileSystemLocationNames, forKey: .requiredFileSystemLocationNames)
            try container.encodeIfPresent(self.roleArn, forKey: .roleArn)
            try container.encodeIfPresent(self.tags, forKey: .tags)
        }

        public func validate(name: String) throws {
            try self.allowedStorageProfileIds?.forEach {
                try validate($0, name: "allowedStorageProfileIds[]", parent: name, pattern: "^sp-[0-9a-f]{32}$")
            }
            try self.validate(self.allowedStorageProfileIds, name: "allowedStorageProfileIds", parent: name, max: 20)
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 64)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.validate(self.description, name: "description", parent: name, max: 100)
            try self.validate(self.displayName, name: "displayName", parent: name, max: 100)
            try self.validate(self.displayName, name: "displayName", parent: name, min: 1)
            try self.validate(self.farmId, name: "farmId", parent: name, pattern: "^farm-[0-9a-f]{32}$")
            try self.jobAttachmentSettings?.validate(name: "\(name).jobAttachmentSettings")
            try self.requiredFileSystemLocationNames?.forEach {
                try validate($0, name: "requiredFileSystemLocationNames[]", parent: name, max: 64)
                try validate($0, name: "requiredFileSystemLocationNames[]", parent: name, min: 1)
                try validate($0, name: "requiredFileSystemLocationNames[]", parent: name, pattern: "^[0-9A-Za-z ]*$")
            }
            try self.validate(self.requiredFileSystemLocationNames, name: "requiredFileSystemLocationNames", parent: name, max: 20)
            try self.validate(self.roleArn, name: "roleArn", parent: name, pattern: "^arn:(aws[a-zA-Z-]*):iam::\\d{12}:role(/[!-.0-~]+)*/[\\w+=,.@-]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case allowedStorageProfileIds = "allowedStorageProfileIds"
            case defaultBudgetAction = "defaultBudgetAction"
            case description = "description"
            case displayName = "displayName"
            case jobAttachmentSettings = "jobAttachmentSettings"
            case jobRunAsUser = "jobRunAsUser"
            case requiredFileSystemLocationNames = "requiredFileSystemLocationNames"
            case roleArn = "roleArn"
            case tags = "tags"
        }
    }

    public struct CreateQueueResponse: AWSDecodableShape {
        /// The queue ID.
        public let queueId: String

        @inlinable
        public init(queueId: String) {
            self.queueId = queueId
        }

        private enum CodingKeys: String, CodingKey {
            case queueId = "queueId"
        }
    }

    public struct CreateStorageProfileRequest: AWSEncodableShape {
        /// The unique token which the server uses to recognize retries of the same request.
        public let clientToken: String?
        /// The display name of the storage profile.  This field can store any content. Escape or encode this content before displaying it on a webpage or any other system that might interpret the content of this field.
        public let displayName: String
        /// The farm ID of the farm to connect to the storage profile.
        public let farmId: String
        /// File system paths to include in the storage profile.
        public let fileSystemLocations: [FileSystemLocation]?
        /// The type of operating system (OS) for the storage profile.
        public let osFamily: StorageProfileOperatingSystemFamily

        @inlinable
        public init(clientToken: String? = CreateStorageProfileRequest.idempotencyToken(), displayName: String, farmId: String, fileSystemLocations: [FileSystemLocation]? = nil, osFamily: StorageProfileOperatingSystemFamily) {
            self.clientToken = clientToken
            self.displayName = displayName
            self.farmId = farmId
            self.fileSystemLocations = fileSystemLocations
            self.osFamily = osFamily
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodeHeader(self.clientToken, key: "X-Amz-Client-Token")
            try container.encode(self.displayName, forKey: .displayName)
            request.encodePath(self.farmId, key: "farmId")
            try container.encodeIfPresent(self.fileSystemLocations, forKey: .fileSystemLocations)
            try container.encode(self.osFamily, forKey: .osFamily)
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 64)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.validate(self.displayName, name: "displayName", parent: name, max: 100)
            try self.validate(self.displayName, name: "displayName", parent: name, min: 1)
            try self.validate(self.farmId, name: "farmId", parent: name, pattern: "^farm-[0-9a-f]{32}$")
            try self.fileSystemLocations?.forEach {
                try $0.validate(name: "\(name).fileSystemLocations[]")
            }
            try self.validate(self.fileSystemLocations, name: "fileSystemLocations", parent: name, max: 20)
        }

        private enum CodingKeys: String, CodingKey {
            case displayName = "displayName"
            case fileSystemLocations = "fileSystemLocations"
            case osFamily = "osFamily"
        }
    }

    public struct CreateStorageProfileResponse: AWSDecodableShape {
        /// The storage profile ID.
        public let storageProfileId: String

        @inlinable
        public init(storageProfileId: String) {
            self.storageProfileId = storageProfileId
        }

        private enum CodingKeys: String, CodingKey {
            case storageProfileId = "storageProfileId"
        }
    }

    public struct CreateWorkerRequest: AWSEncodableShape {
        /// The unique token which the server uses to recognize retries of the same request.
        public let clientToken: String?
        /// The farm ID of the farm to connect to the worker.
        public let farmId: String
        /// The fleet ID to connect to the worker.
        public let fleetId: String
        /// The IP address and host name of the worker.
        public let hostProperties: HostPropertiesRequest?

        @inlinable
        public init(clientToken: String? = CreateWorkerRequest.idempotencyToken(), farmId: String, fleetId: String, hostProperties: HostPropertiesRequest? = nil) {
            self.clientToken = clientToken
            self.farmId = farmId
            self.fleetId = fleetId
            self.hostProperties = hostProperties
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodeHeader(self.clientToken, key: "X-Amz-Client-Token")
            request.encodePath(self.farmId, key: "farmId")
            request.encodePath(self.fleetId, key: "fleetId")
            try container.encodeIfPresent(self.hostProperties, forKey: .hostProperties)
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 64)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.validate(self.farmId, name: "farmId", parent: name, pattern: "^farm-[0-9a-f]{32}$")
            try self.validate(self.fleetId, name: "fleetId", parent: name, pattern: "^fleet-[0-9a-f]{32}$")
            try self.hostProperties?.validate(name: "\(name).hostProperties")
        }

        private enum CodingKeys: String, CodingKey {
            case hostProperties = "hostProperties"
        }
    }

    public struct CreateWorkerResponse: AWSDecodableShape {
        /// The worker ID.
        public let workerId: String

        @inlinable
        public init(workerId: String) {
            self.workerId = workerId
        }

        private enum CodingKeys: String, CodingKey {
            case workerId = "workerId"
        }
    }

    public struct CustomerManagedFleetConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The Auto Scaling mode for the customer managed fleet configuration.
        public let mode: AutoScalingMode
        /// The storage profile ID.
        public let storageProfileId: String?
        /// The worker capabilities for a customer managed fleet configuration.
        public let workerCapabilities: CustomerManagedWorkerCapabilities

        @inlinable
        public init(mode: AutoScalingMode, storageProfileId: String? = nil, workerCapabilities: CustomerManagedWorkerCapabilities) {
            self.mode = mode
            self.storageProfileId = storageProfileId
            self.workerCapabilities = workerCapabilities
        }

        public func validate(name: String) throws {
            try self.validate(self.storageProfileId, name: "storageProfileId", parent: name, pattern: "^sp-[0-9a-f]{32}$")
            try self.workerCapabilities.validate(name: "\(name).workerCapabilities")
        }

        private enum CodingKeys: String, CodingKey {
            case mode = "mode"
            case storageProfileId = "storageProfileId"
            case workerCapabilities = "workerCapabilities"
        }
    }

    public struct CustomerManagedWorkerCapabilities: AWSEncodableShape & AWSDecodableShape {
        /// The range of the accelerator.
        public let acceleratorCount: AcceleratorCountRange?
        /// The total memory (MiB) for the customer managed worker capabilities.
        public let acceleratorTotalMemoryMiB: AcceleratorTotalMemoryMiBRange?
        /// The accelerator types for the customer managed worker capabilities.
        public let acceleratorTypes: [AcceleratorType]?
        /// The CPU architecture type for the customer managed worker capabilities.
        public let cpuArchitectureType: CpuArchitectureType
        /// Custom requirement ranges for customer managed worker capabilities.
        public let customAmounts: [FleetAmountCapability]?
        /// Custom attributes for the customer manged worker capabilities.
        public let customAttributes: [FleetAttributeCapability]?
        /// The memory (MiB).
        public let memoryMiB: MemoryMiBRange
        /// The operating system (OS) family.
        public let osFamily: CustomerManagedFleetOperatingSystemFamily
        /// The vCPU count for the customer manged worker capabilities.
        public let vCpuCount: VCpuCountRange

        @inlinable
        public init(acceleratorCount: AcceleratorCountRange? = nil, acceleratorTotalMemoryMiB: AcceleratorTotalMemoryMiBRange? = nil, acceleratorTypes: [AcceleratorType]? = nil, cpuArchitectureType: CpuArchitectureType, customAmounts: [FleetAmountCapability]? = nil, customAttributes: [FleetAttributeCapability]? = nil, memoryMiB: MemoryMiBRange, osFamily: CustomerManagedFleetOperatingSystemFamily, vCpuCount: VCpuCountRange) {
            self.acceleratorCount = acceleratorCount
            self.acceleratorTotalMemoryMiB = acceleratorTotalMemoryMiB
            self.acceleratorTypes = acceleratorTypes
            self.cpuArchitectureType = cpuArchitectureType
            self.customAmounts = customAmounts
            self.customAttributes = customAttributes
            self.memoryMiB = memoryMiB
            self.osFamily = osFamily
            self.vCpuCount = vCpuCount
        }

        public func validate(name: String) throws {
            try self.acceleratorCount?.validate(name: "\(name).acceleratorCount")
            try self.acceleratorTotalMemoryMiB?.validate(name: "\(name).acceleratorTotalMemoryMiB")
            try self.customAmounts?.forEach {
                try $0.validate(name: "\(name).customAmounts[]")
            }
            try self.validate(self.customAmounts, name: "customAmounts", parent: name, max: 15)
            try self.validate(self.customAmounts, name: "customAmounts", parent: name, min: 1)
            try self.customAttributes?.forEach {
                try $0.validate(name: "\(name).customAttributes[]")
            }
            try self.validate(self.customAttributes, name: "customAttributes", parent: name, max: 15)
            try self.validate(self.customAttributes, name: "customAttributes", parent: name, min: 1)
            try self.memoryMiB.validate(name: "\(name).memoryMiB")
            try self.vCpuCount.validate(name: "\(name).vCpuCount")
        }

        private enum CodingKeys: String, CodingKey {
            case acceleratorCount = "acceleratorCount"
            case acceleratorTotalMemoryMiB = "acceleratorTotalMemoryMiB"
            case acceleratorTypes = "acceleratorTypes"
            case cpuArchitectureType = "cpuArchitectureType"
            case customAmounts = "customAmounts"
            case customAttributes = "customAttributes"
            case memoryMiB = "memoryMiB"
            case osFamily = "osFamily"
            case vCpuCount = "vCpuCount"
        }
    }

    public struct DateTimeFilterExpression: AWSEncodableShape {
        /// The date and time.
        @CustomCoding<ISO8601DateCoder>
        public var dateTime: Date
        /// The name of the date-time field to filter on.
        public let name: String
        /// The type of comparison to use to filter the results.
        public let `operator`: ComparisonOperator

        @inlinable
        public init(dateTime: Date, name: String, operator: ComparisonOperator) {
            self.dateTime = dateTime
            self.name = name
            self.`operator` = `operator`
        }

        private enum CodingKeys: String, CodingKey {
            case dateTime = "dateTime"
            case name = "name"
            case `operator` = "operator"
        }
    }

    public struct DeleteBudgetRequest: AWSEncodableShape {
        /// The budget ID of the budget to delete.
        public let budgetId: String
        /// The farm ID of the farm to remove from the budget.
        public let farmId: String

        @inlinable
        public init(budgetId: String, farmId: String) {
            self.budgetId = budgetId
            self.farmId = farmId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.budgetId, key: "budgetId")
            request.encodePath(self.farmId, key: "farmId")
        }

        public func validate(name: String) throws {
            try self.validate(self.budgetId, name: "budgetId", parent: name, pattern: "^budget-[0-9a-f]{32}$")
            try self.validate(self.farmId, name: "farmId", parent: name, pattern: "^farm-[0-9a-f]{32}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteBudgetResponse: AWSDecodableShape {
        public init() {}
    }

    public struct DeleteFarmRequest: AWSEncodableShape {
        /// The farm ID of the farm to delete.
        public let farmId: String

        @inlinable
        public init(farmId: String) {
            self.farmId = farmId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.farmId, key: "farmId")
        }

        public func validate(name: String) throws {
            try self.validate(self.farmId, name: "farmId", parent: name, pattern: "^farm-[0-9a-f]{32}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteFarmResponse: AWSDecodableShape {
        public init() {}
    }

    public struct DeleteFleetRequest: AWSEncodableShape {
        /// The unique token which the server uses to recognize retries of the same request.
        public let clientToken: String?
        /// The farm ID of the farm to remove from the fleet.
        public let farmId: String
        /// The fleet ID of the fleet to delete.
        public let fleetId: String

        @inlinable
        public init(clientToken: String? = DeleteFleetRequest.idempotencyToken(), farmId: String, fleetId: String) {
            self.clientToken = clientToken
            self.farmId = farmId
            self.fleetId = fleetId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeHeader(self.clientToken, key: "X-Amz-Client-Token")
            request.encodePath(self.farmId, key: "farmId")
            request.encodePath(self.fleetId, key: "fleetId")
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 64)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.validate(self.farmId, name: "farmId", parent: name, pattern: "^farm-[0-9a-f]{32}$")
            try self.validate(self.fleetId, name: "fleetId", parent: name, pattern: "^fleet-[0-9a-f]{32}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteFleetResponse: AWSDecodableShape {
        public init() {}
    }

    public struct DeleteLicenseEndpointRequest: AWSEncodableShape {
        /// The license endpoint ID of the license endpoint to delete.
        public let licenseEndpointId: String

        @inlinable
        public init(licenseEndpointId: String) {
            self.licenseEndpointId = licenseEndpointId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.licenseEndpointId, key: "licenseEndpointId")
        }

        public func validate(name: String) throws {
            try self.validate(self.licenseEndpointId, name: "licenseEndpointId", parent: name, pattern: "^le-[0-9a-f]{32}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteLicenseEndpointResponse: AWSDecodableShape {
        public init() {}
    }

    public struct DeleteLimitRequest: AWSEncodableShape {
        /// The unique identifier of the farm that contains the limit to delete.
        public let farmId: String
        /// The unique identifier of the limit to delete.
        public let limitId: String

        @inlinable
        public init(farmId: String, limitId: String) {
            self.farmId = farmId
            self.limitId = limitId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.farmId, key: "farmId")
            request.encodePath(self.limitId, key: "limitId")
        }

        public func validate(name: String) throws {
            try self.validate(self.farmId, name: "farmId", parent: name, pattern: "^farm-[0-9a-f]{32}$")
            try self.validate(self.limitId, name: "limitId", parent: name, pattern: "^limit-[0-9a-f]{32}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteLimitResponse: AWSDecodableShape {
        public init() {}
    }

    public struct DeleteMeteredProductRequest: AWSEncodableShape {
        /// The ID of the license endpoint from which to remove the metered product.
        public let licenseEndpointId: String
        /// The product ID to remove from the license endpoint.
        public let productId: String

        @inlinable
        public init(licenseEndpointId: String, productId: String) {
            self.licenseEndpointId = licenseEndpointId
            self.productId = productId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.licenseEndpointId, key: "licenseEndpointId")
            request.encodePath(self.productId, key: "productId")
        }

        public func validate(name: String) throws {
            try self.validate(self.licenseEndpointId, name: "licenseEndpointId", parent: name, pattern: "^le-[0-9a-f]{32}$")
            try self.validate(self.productId, name: "productId", parent: name, pattern: "^[0-9a-z]{1,32}-[.0-9a-z]{1,32}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteMeteredProductResponse: AWSDecodableShape {
        public init() {}
    }

    public struct DeleteMonitorRequest: AWSEncodableShape {
        /// The unique identifier of the monitor to delete. This ID is returned by the CreateMonitor operation, and is included in the response to the GetMonitor operation.
        public let monitorId: String

        @inlinable
        public init(monitorId: String) {
            self.monitorId = monitorId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.monitorId, key: "monitorId")
        }

        public func validate(name: String) throws {
            try self.validate(self.monitorId, name: "monitorId", parent: name, pattern: "^monitor-[0-9a-f]{32}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteMonitorResponse: AWSDecodableShape {
        public init() {}
    }

    public struct DeleteQueueEnvironmentRequest: AWSEncodableShape {
        /// The farm ID of the farm from which to remove the queue environment.
        public let farmId: String
        /// The queue environment ID of the queue environment to delete.
        public let queueEnvironmentId: String
        /// The queue ID of the queue environment to delete.
        public let queueId: String

        @inlinable
        public init(farmId: String, queueEnvironmentId: String, queueId: String) {
            self.farmId = farmId
            self.queueEnvironmentId = queueEnvironmentId
            self.queueId = queueId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.farmId, key: "farmId")
            request.encodePath(self.queueEnvironmentId, key: "queueEnvironmentId")
            request.encodePath(self.queueId, key: "queueId")
        }

        public func validate(name: String) throws {
            try self.validate(self.farmId, name: "farmId", parent: name, pattern: "^farm-[0-9a-f]{32}$")
            try self.validate(self.queueEnvironmentId, name: "queueEnvironmentId", parent: name, pattern: "^queueenv-[0-9a-f]{32}$")
            try self.validate(self.queueId, name: "queueId", parent: name, pattern: "^queue-[0-9a-f]{32}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteQueueEnvironmentResponse: AWSDecodableShape {
        public init() {}
    }

    public struct DeleteQueueFleetAssociationRequest: AWSEncodableShape {
        /// The farm ID of the farm that holds the queue-fleet association.
        public let farmId: String
        /// The fleet ID of the queue-fleet association.
        public let fleetId: String
        /// The queue ID of the queue-fleet association.
        public let queueId: String

        @inlinable
        public init(farmId: String, fleetId: String, queueId: String) {
            self.farmId = farmId
            self.fleetId = fleetId
            self.queueId = queueId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.farmId, key: "farmId")
            request.encodePath(self.fleetId, key: "fleetId")
            request.encodePath(self.queueId, key: "queueId")
        }

        public func validate(name: String) throws {
            try self.validate(self.farmId, name: "farmId", parent: name, pattern: "^farm-[0-9a-f]{32}$")
            try self.validate(self.fleetId, name: "fleetId", parent: name, pattern: "^fleet-[0-9a-f]{32}$")
            try self.validate(self.queueId, name: "queueId", parent: name, pattern: "^queue-[0-9a-f]{32}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteQueueFleetAssociationResponse: AWSDecodableShape {
        public init() {}
    }

    public struct DeleteQueueLimitAssociationRequest: AWSEncodableShape {
        /// The unique identifier of the farm that contains the queue and limit to disassociate.
        public let farmId: String
        /// The unique identifier of the limit to disassociate.
        public let limitId: String
        /// The unique identifier of the queue to disassociate.
        public let queueId: String

        @inlinable
        public init(farmId: String, limitId: String, queueId: String) {
            self.farmId = farmId
            self.limitId = limitId
            self.queueId = queueId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.farmId, key: "farmId")
            request.encodePath(self.limitId, key: "limitId")
            request.encodePath(self.queueId, key: "queueId")
        }

        public func validate(name: String) throws {
            try self.validate(self.farmId, name: "farmId", parent: name, pattern: "^farm-[0-9a-f]{32}$")
            try self.validate(self.limitId, name: "limitId", parent: name, pattern: "^limit-[0-9a-f]{32}$")
            try self.validate(self.queueId, name: "queueId", parent: name, pattern: "^queue-[0-9a-f]{32}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteQueueLimitAssociationResponse: AWSDecodableShape {
        public init() {}
    }

    public struct DeleteQueueRequest: AWSEncodableShape {
        /// The ID of the farm from which to remove the queue.
        public let farmId: String
        /// The queue ID of the queue to delete.
        public let queueId: String

        @inlinable
        public init(farmId: String, queueId: String) {
            self.farmId = farmId
            self.queueId = queueId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.farmId, key: "farmId")
            request.encodePath(self.queueId, key: "queueId")
        }

        public func validate(name: String) throws {
            try self.validate(self.farmId, name: "farmId", parent: name, pattern: "^farm-[0-9a-f]{32}$")
            try self.validate(self.queueId, name: "queueId", parent: name, pattern: "^queue-[0-9a-f]{32}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteQueueResponse: AWSDecodableShape {
        public init() {}
    }

    public struct DeleteStorageProfileRequest: AWSEncodableShape {
        /// The farm ID of the farm from which to remove the storage profile.
        public let farmId: String
        /// The storage profile ID of the storage profile to delete.
        public let storageProfileId: String

        @inlinable
        public init(farmId: String, storageProfileId: String) {
            self.farmId = farmId
            self.storageProfileId = storageProfileId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.farmId, key: "farmId")
            request.encodePath(self.storageProfileId, key: "storageProfileId")
        }

        public func validate(name: String) throws {
            try self.validate(self.farmId, name: "farmId", parent: name, pattern: "^farm-[0-9a-f]{32}$")
            try self.validate(self.storageProfileId, name: "storageProfileId", parent: name, pattern: "^sp-[0-9a-f]{32}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteStorageProfileResponse: AWSDecodableShape {
        public init() {}
    }

    public struct DeleteWorkerRequest: AWSEncodableShape {
        /// The farm ID of the worker to delete.
        public let farmId: String
        /// The fleet ID of the worker to delete.
        public let fleetId: String
        /// The worker ID of the worker to delete.
        public let workerId: String

        @inlinable
        public init(farmId: String, fleetId: String, workerId: String) {
            self.farmId = farmId
            self.fleetId = fleetId
            self.workerId = workerId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.farmId, key: "farmId")
            request.encodePath(self.fleetId, key: "fleetId")
            request.encodePath(self.workerId, key: "workerId")
        }

        public func validate(name: String) throws {
            try self.validate(self.farmId, name: "farmId", parent: name, pattern: "^farm-[0-9a-f]{32}$")
            try self.validate(self.fleetId, name: "fleetId", parent: name, pattern: "^fleet-[0-9a-f]{32}$")
            try self.validate(self.workerId, name: "workerId", parent: name, pattern: "^worker-[0-9a-f]{32}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteWorkerResponse: AWSDecodableShape {
        public init() {}
    }

    public struct DependencyCounts: AWSDecodableShape {
        /// The number of consumers resolved.
        public let consumersResolved: Int
        /// The number of unresolved consumers.
        public let consumersUnresolved: Int
        /// The number of resolved dependencies.
        public let dependenciesResolved: Int
        /// The number of unresolved dependencies.
        public let dependenciesUnresolved: Int

        @inlinable
        public init(consumersResolved: Int, consumersUnresolved: Int, dependenciesResolved: Int, dependenciesUnresolved: Int) {
            self.consumersResolved = consumersResolved
            self.consumersUnresolved = consumersUnresolved
            self.dependenciesResolved = dependenciesResolved
            self.dependenciesUnresolved = dependenciesUnresolved
        }

        private enum CodingKeys: String, CodingKey {
            case consumersResolved = "consumersResolved"
            case consumersUnresolved = "consumersUnresolved"
            case dependenciesResolved = "dependenciesResolved"
            case dependenciesUnresolved = "dependenciesUnresolved"
        }
    }

    public struct DisassociateMemberFromFarmRequest: AWSEncodableShape {
        /// The farm ID of the farm to disassociate from the member.
        public let farmId: String
        /// A member's principal ID to disassociate from a farm.
        public let principalId: String

        @inlinable
        public init(farmId: String, principalId: String) {
            self.farmId = farmId
            self.principalId = principalId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.farmId, key: "farmId")
            request.encodePath(self.principalId, key: "principalId")
        }

        public func validate(name: String) throws {
            try self.validate(self.farmId, name: "farmId", parent: name, pattern: "^farm-[0-9a-f]{32}$")
            try self.validate(self.principalId, name: "principalId", parent: name, max: 47)
            try self.validate(self.principalId, name: "principalId", parent: name, min: 1)
            try self.validate(self.principalId, name: "principalId", parent: name, pattern: "^([0-9a-f]{10}-|)[A-Fa-f0-9]{8}-[A-Fa-f0-9]{4}-[A-Fa-f0-9]{4}-[A-Fa-f0-9]{4}-[A-Fa-f0-9]{12}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DisassociateMemberFromFarmResponse: AWSDecodableShape {
        public init() {}
    }

    public struct DisassociateMemberFromFleetRequest: AWSEncodableShape {
        /// The farm ID of the fleet to disassociate a member from.
        public let farmId: String
        /// The fleet ID of the fleet to from which to disassociate a member.
        public let fleetId: String
        /// A member's principal ID to disassociate from a fleet.
        public let principalId: String

        @inlinable
        public init(farmId: String, fleetId: String, principalId: String) {
            self.farmId = farmId
            self.fleetId = fleetId
            self.principalId = principalId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.farmId, key: "farmId")
            request.encodePath(self.fleetId, key: "fleetId")
            request.encodePath(self.principalId, key: "principalId")
        }

        public func validate(name: String) throws {
            try self.validate(self.farmId, name: "farmId", parent: name, pattern: "^farm-[0-9a-f]{32}$")
            try self.validate(self.fleetId, name: "fleetId", parent: name, pattern: "^fleet-[0-9a-f]{32}$")
            try self.validate(self.principalId, name: "principalId", parent: name, max: 47)
            try self.validate(self.principalId, name: "principalId", parent: name, min: 1)
            try self.validate(self.principalId, name: "principalId", parent: name, pattern: "^([0-9a-f]{10}-|)[A-Fa-f0-9]{8}-[A-Fa-f0-9]{4}-[A-Fa-f0-9]{4}-[A-Fa-f0-9]{4}-[A-Fa-f0-9]{12}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DisassociateMemberFromFleetResponse: AWSDecodableShape {
        public init() {}
    }

    public struct DisassociateMemberFromJobRequest: AWSEncodableShape {
        /// The farm ID for the job to disassociate from the member.
        public let farmId: String
        /// The job ID to disassociate from a member in a job.
        public let jobId: String
        /// A member's principal ID to disassociate from a job.
        public let principalId: String
        /// The queue ID connected to a job for which you're disassociating a member.
        public let queueId: String

        @inlinable
        public init(farmId: String, jobId: String, principalId: String, queueId: String) {
            self.farmId = farmId
            self.jobId = jobId
            self.principalId = principalId
            self.queueId = queueId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.farmId, key: "farmId")
            request.encodePath(self.jobId, key: "jobId")
            request.encodePath(self.principalId, key: "principalId")
            request.encodePath(self.queueId, key: "queueId")
        }

        public func validate(name: String) throws {
            try self.validate(self.farmId, name: "farmId", parent: name, pattern: "^farm-[0-9a-f]{32}$")
            try self.validate(self.jobId, name: "jobId", parent: name, pattern: "^job-[0-9a-f]{32}$")
            try self.validate(self.principalId, name: "principalId", parent: name, max: 47)
            try self.validate(self.principalId, name: "principalId", parent: name, min: 1)
            try self.validate(self.principalId, name: "principalId", parent: name, pattern: "^([0-9a-f]{10}-|)[A-Fa-f0-9]{8}-[A-Fa-f0-9]{4}-[A-Fa-f0-9]{4}-[A-Fa-f0-9]{4}-[A-Fa-f0-9]{12}$")
            try self.validate(self.queueId, name: "queueId", parent: name, pattern: "^queue-[0-9a-f]{32}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DisassociateMemberFromJobResponse: AWSDecodableShape {
        public init() {}
    }

    public struct DisassociateMemberFromQueueRequest: AWSEncodableShape {
        /// The farm ID for the queue to disassociate from a member.
        public let farmId: String
        /// A member's principal ID to disassociate from a queue.
        public let principalId: String
        /// The queue ID of the queue in which you're disassociating from a member.
        public let queueId: String

        @inlinable
        public init(farmId: String, principalId: String, queueId: String) {
            self.farmId = farmId
            self.principalId = principalId
            self.queueId = queueId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.farmId, key: "farmId")
            request.encodePath(self.principalId, key: "principalId")
            request.encodePath(self.queueId, key: "queueId")
        }

        public func validate(name: String) throws {
            try self.validate(self.farmId, name: "farmId", parent: name, pattern: "^farm-[0-9a-f]{32}$")
            try self.validate(self.principalId, name: "principalId", parent: name, max: 47)
            try self.validate(self.principalId, name: "principalId", parent: name, min: 1)
            try self.validate(self.principalId, name: "principalId", parent: name, pattern: "^([0-9a-f]{10}-|)[A-Fa-f0-9]{8}-[A-Fa-f0-9]{4}-[A-Fa-f0-9]{4}-[A-Fa-f0-9]{4}-[A-Fa-f0-9]{12}$")
            try self.validate(self.queueId, name: "queueId", parent: name, pattern: "^queue-[0-9a-f]{32}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DisassociateMemberFromQueueResponse: AWSDecodableShape {
        public init() {}
    }

    public struct Ec2EbsVolume: AWSEncodableShape & AWSDecodableShape {
        /// The IOPS per volume.
        public let iops: Int?
        /// The EBS volume size in GiB.
        public let sizeGiB: Int?
        /// The throughput per volume in MiB.
        public let throughputMiB: Int?

        @inlinable
        public init(iops: Int? = nil, sizeGiB: Int? = nil, throughputMiB: Int? = nil) {
            self.iops = iops
            self.sizeGiB = sizeGiB
            self.throughputMiB = throughputMiB
        }

        public func validate(name: String) throws {
            try self.validate(self.iops, name: "iops", parent: name, max: 16000)
            try self.validate(self.iops, name: "iops", parent: name, min: 3000)
            try self.validate(self.throughputMiB, name: "throughputMiB", parent: name, max: 1000)
            try self.validate(self.throughputMiB, name: "throughputMiB", parent: name, min: 125)
        }

        private enum CodingKeys: String, CodingKey {
            case iops = "iops"
            case sizeGiB = "sizeGiB"
            case throughputMiB = "throughputMiB"
        }
    }

    public struct EnvironmentDetailsEntity: AWSDecodableShape {
        /// The environment ID.
        public let environmentId: String
        /// The job ID.
        public let jobId: String
        /// The schema version in the environment.
        public let schemaVersion: String
        /// The template used for the environment.
        public let template: AWSDocument

        @inlinable
        public init(environmentId: String, jobId: String, schemaVersion: String, template: AWSDocument) {
            self.environmentId = environmentId
            self.jobId = jobId
            self.schemaVersion = schemaVersion
            self.template = template
        }

        private enum CodingKeys: String, CodingKey {
            case environmentId = "environmentId"
            case jobId = "jobId"
            case schemaVersion = "schemaVersion"
            case template = "template"
        }
    }

    public struct EnvironmentDetailsError: AWSDecodableShape {
        /// The error code.
        public let code: JobEntityErrorCode
        /// The environment ID.
        public let environmentId: String
        /// The job ID.
        public let jobId: String
        /// The error message detailing the error's cause.
        public let message: String

        @inlinable
        public init(code: JobEntityErrorCode, environmentId: String, jobId: String, message: String) {
            self.code = code
            self.environmentId = environmentId
            self.jobId = jobId
            self.message = message
        }

        private enum CodingKeys: String, CodingKey {
            case code = "code"
            case environmentId = "environmentId"
            case jobId = "jobId"
            case message = "message"
        }
    }

    public struct EnvironmentDetailsIdentifiers: AWSEncodableShape {
        /// The environment ID.
        public let environmentId: String
        /// The job ID.
        public let jobId: String

        @inlinable
        public init(environmentId: String, jobId: String) {
            self.environmentId = environmentId
            self.jobId = jobId
        }

        public func validate(name: String) throws {
            try self.validate(self.environmentId, name: "environmentId", parent: name, max: 1024)
            try self.validate(self.environmentId, name: "environmentId", parent: name, min: 1)
            try self.validate(self.environmentId, name: "environmentId", parent: name, pattern: "^(STEP:step-[0-9a-f]{32}:.*)|(JOB:job-[0-9a-f]{32}:.*)$")
            try self.validate(self.jobId, name: "jobId", parent: name, pattern: "^job-[0-9a-f]{32}$")
        }

        private enum CodingKeys: String, CodingKey {
            case environmentId = "environmentId"
            case jobId = "jobId"
        }
    }

    public struct EnvironmentEnterSessionActionDefinition: AWSDecodableShape {
        /// The environment ID.
        public let environmentId: String

        @inlinable
        public init(environmentId: String) {
            self.environmentId = environmentId
        }

        private enum CodingKeys: String, CodingKey {
            case environmentId = "environmentId"
        }
    }

    public struct EnvironmentEnterSessionActionDefinitionSummary: AWSDecodableShape {
        /// The environment ID.
        public let environmentId: String

        @inlinable
        public init(environmentId: String) {
            self.environmentId = environmentId
        }

        private enum CodingKeys: String, CodingKey {
            case environmentId = "environmentId"
        }
    }

    public struct EnvironmentExitSessionActionDefinition: AWSDecodableShape {
        /// The environment ID.
        public let environmentId: String

        @inlinable
        public init(environmentId: String) {
            self.environmentId = environmentId
        }

        private enum CodingKeys: String, CodingKey {
            case environmentId = "environmentId"
        }
    }

    public struct EnvironmentExitSessionActionDefinitionSummary: AWSDecodableShape {
        /// The environment ID.
        public let environmentId: String

        @inlinable
        public init(environmentId: String) {
            self.environmentId = environmentId
        }

        private enum CodingKeys: String, CodingKey {
            case environmentId = "environmentId"
        }
    }

    public struct FarmMember: AWSDecodableShape {
        /// The farm ID of the farm member.
        public let farmId: String
        /// The identity store ID of the farm member.
        public let identityStoreId: String
        /// The farm member's membership level.
        public let membershipLevel: MembershipLevel
        /// The principal ID of the farm member.
        public let principalId: String
        /// The principal type of the farm member.
        public let principalType: DeadlinePrincipalType

        @inlinable
        public init(farmId: String, identityStoreId: String, membershipLevel: MembershipLevel, principalId: String, principalType: DeadlinePrincipalType) {
            self.farmId = farmId
            self.identityStoreId = identityStoreId
            self.membershipLevel = membershipLevel
            self.principalId = principalId
            self.principalType = principalType
        }

        private enum CodingKeys: String, CodingKey {
            case farmId = "farmId"
            case identityStoreId = "identityStoreId"
            case membershipLevel = "membershipLevel"
            case principalId = "principalId"
            case principalType = "principalType"
        }
    }

    public struct FarmSummary: AWSDecodableShape {
        /// The date and time the resource was created.
        @CustomCoding<ISO8601DateCoder>
        public var createdAt: Date
        /// The user or system that created this resource.
        public let createdBy: String
        /// The display name of the farm.  This field can store any content. Escape or encode this content before displaying it on a webpage or any other system that might interpret the content of this field.
        public let displayName: String
        /// The farm ID.
        public let farmId: String
        /// The ARN for the KMS key.
        public let kmsKeyArn: String?
        /// The date and time the resource was updated.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var updatedAt: Date?
        /// The user or system that updated this resource.
        public let updatedBy: String?

        @inlinable
        public init(createdAt: Date, createdBy: String, displayName: String, farmId: String, kmsKeyArn: String? = nil, updatedAt: Date? = nil, updatedBy: String? = nil) {
            self.createdAt = createdAt
            self.createdBy = createdBy
            self.displayName = displayName
            self.farmId = farmId
            self.kmsKeyArn = kmsKeyArn
            self.updatedAt = updatedAt
            self.updatedBy = updatedBy
        }

        private enum CodingKeys: String, CodingKey {
            case createdAt = "createdAt"
            case createdBy = "createdBy"
            case displayName = "displayName"
            case farmId = "farmId"
            case kmsKeyArn = "kmsKeyArn"
            case updatedAt = "updatedAt"
            case updatedBy = "updatedBy"
        }
    }

    public struct FieldSortExpression: AWSEncodableShape {
        /// The name of the field.
        public let name: String
        /// The sort order for the field.
        public let sortOrder: SortOrder

        @inlinable
        public init(name: String, sortOrder: SortOrder) {
            self.name = name
            self.sortOrder = sortOrder
        }

        private enum CodingKeys: String, CodingKey {
            case name = "name"
            case sortOrder = "sortOrder"
        }
    }

    public struct FileSystemLocation: AWSEncodableShape & AWSDecodableShape {
        /// The location name.
        public let name: String
        /// The file path.
        public let path: String
        /// The type of file.
        public let type: FileSystemLocationType

        @inlinable
        public init(name: String, path: String, type: FileSystemLocationType) {
            self.name = name
            self.path = path
            self.type = type
        }

        public func validate(name: String) throws {
            try self.validate(self.name, name: "name", parent: name, max: 64)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[0-9A-Za-z ]*$")
            try self.validate(self.path, name: "path", parent: name, max: 1024)
        }

        private enum CodingKeys: String, CodingKey {
            case name = "name"
            case path = "path"
            case type = "type"
        }
    }

    public struct FixedBudgetSchedule: AWSEncodableShape & AWSDecodableShape {
        /// When the budget ends.
        @CustomCoding<ISO8601DateCoder>
        public var endTime: Date
        /// When the budget starts.
        @CustomCoding<ISO8601DateCoder>
        public var startTime: Date

        @inlinable
        public init(endTime: Date, startTime: Date) {
            self.endTime = endTime
            self.startTime = startTime
        }

        private enum CodingKeys: String, CodingKey {
            case endTime = "endTime"
            case startTime = "startTime"
        }
    }

    public struct FleetAmountCapability: AWSEncodableShape & AWSDecodableShape {
        /// The maximum amount of the fleet worker capability.
        public let max: Float?
        /// The minimum amount of fleet worker capability.
        public let min: Float
        /// The name of the fleet capability.
        public let name: String

        @inlinable
        public init(max: Float? = nil, min: Float, name: String) {
            self.max = max
            self.min = min
            self.name = name
        }

        public func validate(name: String) throws {
            try self.validate(self.name, name: "name", parent: name, max: 100)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^([a-zA-Z][a-zA-Z0-9]{0,63}:)?amount(\\.[a-zA-Z][a-zA-Z0-9]{0,63})+$")
        }

        private enum CodingKeys: String, CodingKey {
            case max = "max"
            case min = "min"
            case name = "name"
        }
    }

    public struct FleetAttributeCapability: AWSEncodableShape & AWSDecodableShape {
        /// The name of the fleet attribute capability for the worker.
        public let name: String
        /// The number of fleet attribute capabilities.
        public let values: [String]

        @inlinable
        public init(name: String, values: [String]) {
            self.name = name
            self.values = values
        }

        public func validate(name: String) throws {
            try self.validate(self.name, name: "name", parent: name, max: 100)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^([a-zA-Z][a-zA-Z0-9]{0,63}:)?attr(\\.[a-zA-Z][a-zA-Z0-9]{0,63})+$")
            try self.values.forEach {
                try validate($0, name: "values[]", parent: name, max: 100)
                try validate($0, name: "values[]", parent: name, min: 1)
                try validate($0, name: "values[]", parent: name, pattern: "^[a-zA-Z_]([a-zA-Z0-9_\\-]{0,99})$")
            }
            try self.validate(self.values, name: "values", parent: name, max: 10)
            try self.validate(self.values, name: "values", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case name = "name"
            case values = "values"
        }
    }

    public struct FleetCapabilities: AWSDecodableShape {
        /// Amount capabilities of the fleet.
        public let amounts: [FleetAmountCapability]?
        /// Attribute capabilities of the fleet.
        public let attributes: [FleetAttributeCapability]?

        @inlinable
        public init(amounts: [FleetAmountCapability]? = nil, attributes: [FleetAttributeCapability]? = nil) {
            self.amounts = amounts
            self.attributes = attributes
        }

        private enum CodingKeys: String, CodingKey {
            case amounts = "amounts"
            case attributes = "attributes"
        }
    }

    public struct FleetMember: AWSDecodableShape {
        /// The farm ID.
        public let farmId: String
        /// The fleet ID.
        public let fleetId: String
        /// The identity store ID.
        public let identityStoreId: String
        /// The fleet member's membership level.
        public let membershipLevel: MembershipLevel
        /// The principal ID of the fleet member.
        public let principalId: String
        /// The principal type of the fleet member.
        public let principalType: DeadlinePrincipalType

        @inlinable
        public init(farmId: String, fleetId: String, identityStoreId: String, membershipLevel: MembershipLevel, principalId: String, principalType: DeadlinePrincipalType) {
            self.farmId = farmId
            self.fleetId = fleetId
            self.identityStoreId = identityStoreId
            self.membershipLevel = membershipLevel
            self.principalId = principalId
            self.principalType = principalType
        }

        private enum CodingKeys: String, CodingKey {
            case farmId = "farmId"
            case fleetId = "fleetId"
            case identityStoreId = "identityStoreId"
            case membershipLevel = "membershipLevel"
            case principalId = "principalId"
            case principalType = "principalType"
        }
    }

    public struct FleetSummary: AWSDecodableShape {
        /// The Auto Scaling status of a fleet.
        public let autoScalingStatus: AutoScalingStatus?
        /// The configuration details for the fleet.
        public let configuration: FleetConfiguration
        /// The date and time the resource was created.
        @CustomCoding<ISO8601DateCoder>
        public var createdAt: Date
        /// The user or system that created this resource.
        public let createdBy: String
        /// The display name of the fleet summary to update.  This field can store any content. Escape or encode this content before displaying it on a webpage or any other system that might interpret the content of this field.
        public let displayName: String
        /// The farm ID.
        public let farmId: String
        /// The fleet ID.
        public let fleetId: String
        /// The maximum number of workers specified in the fleet.
        public let maxWorkerCount: Int
        /// The minimum number of workers in the fleet.
        public let minWorkerCount: Int
        /// The status of the fleet.
        public let status: FleetStatus
        /// The target number of workers in a fleet.
        public let targetWorkerCount: Int?
        /// The date and time the resource was updated.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var updatedAt: Date?
        /// The user or system that updated this resource.
        public let updatedBy: String?
        /// The number of workers in the fleet summary.
        public let workerCount: Int

        @inlinable
        public init(autoScalingStatus: AutoScalingStatus? = nil, configuration: FleetConfiguration, createdAt: Date, createdBy: String, displayName: String, farmId: String, fleetId: String, maxWorkerCount: Int, minWorkerCount: Int, status: FleetStatus, targetWorkerCount: Int? = nil, updatedAt: Date? = nil, updatedBy: String? = nil, workerCount: Int) {
            self.autoScalingStatus = autoScalingStatus
            self.configuration = configuration
            self.createdAt = createdAt
            self.createdBy = createdBy
            self.displayName = displayName
            self.farmId = farmId
            self.fleetId = fleetId
            self.maxWorkerCount = maxWorkerCount
            self.minWorkerCount = minWorkerCount
            self.status = status
            self.targetWorkerCount = targetWorkerCount
            self.updatedAt = updatedAt
            self.updatedBy = updatedBy
            self.workerCount = workerCount
        }

        private enum CodingKeys: String, CodingKey {
            case autoScalingStatus = "autoScalingStatus"
            case configuration = "configuration"
            case createdAt = "createdAt"
            case createdBy = "createdBy"
            case displayName = "displayName"
            case farmId = "farmId"
            case fleetId = "fleetId"
            case maxWorkerCount = "maxWorkerCount"
            case minWorkerCount = "minWorkerCount"
            case status = "status"
            case targetWorkerCount = "targetWorkerCount"
            case updatedAt = "updatedAt"
            case updatedBy = "updatedBy"
            case workerCount = "workerCount"
        }
    }

    public struct GetBudgetRequest: AWSEncodableShape {
        /// The budget ID.
        public let budgetId: String
        /// The farm ID of the farm connected to the budget.
        public let farmId: String

        @inlinable
        public init(budgetId: String, farmId: String) {
            self.budgetId = budgetId
            self.farmId = farmId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.budgetId, key: "budgetId")
            request.encodePath(self.farmId, key: "farmId")
        }

        public func validate(name: String) throws {
            try self.validate(self.budgetId, name: "budgetId", parent: name, pattern: "^budget-[0-9a-f]{32}$")
            try self.validate(self.farmId, name: "farmId", parent: name, pattern: "^farm-[0-9a-f]{32}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetBudgetResponse: AWSDecodableShape {
        /// The budget actions for the budget.
        public let actions: [ResponseBudgetAction]
        /// The consumed usage limit for the budget.
        public let approximateDollarLimit: Float
        /// The budget ID.
        public let budgetId: String
        /// The date and time the resource was created.
        @CustomCoding<ISO8601DateCoder>
        public var createdAt: Date
        /// The user or system that created this resource.
        public let createdBy: String
        /// The description of the budget.  This field can store any content. Escape or encode this content before displaying it on a webpage or any other system that might interpret the content of this field.
        public let description: String?
        /// The display name of the budget.  This field can store any content. Escape or encode this content before displaying it on a webpage or any other system that might interpret the content of this field.
        public let displayName: String
        /// The date and time the queue stopped.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var queueStoppedAt: Date?
        /// The budget schedule.
        public let schedule: BudgetSchedule
        /// The status of the budget.    ACTIVEGet a budget being evaluated.    INACTIVEGet an inactive budget. This can include expired, canceled, or deleted statuses.
        public let status: BudgetStatus
        /// The date and time the resource was updated.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var updatedAt: Date?
        /// The user or system that updated this resource.
        public let updatedBy: String?
        /// The usages of the budget.
        public let usages: ConsumedUsages
        /// The resource that the budget is tracking usage for.
        public let usageTrackingResource: UsageTrackingResource

        @inlinable
        public init(actions: [ResponseBudgetAction], approximateDollarLimit: Float, budgetId: String, createdAt: Date, createdBy: String, description: String? = nil, displayName: String, queueStoppedAt: Date? = nil, schedule: BudgetSchedule, status: BudgetStatus, updatedAt: Date? = nil, updatedBy: String? = nil, usages: ConsumedUsages, usageTrackingResource: UsageTrackingResource) {
            self.actions = actions
            self.approximateDollarLimit = approximateDollarLimit
            self.budgetId = budgetId
            self.createdAt = createdAt
            self.createdBy = createdBy
            self.description = description
            self.displayName = displayName
            self.queueStoppedAt = queueStoppedAt
            self.schedule = schedule
            self.status = status
            self.updatedAt = updatedAt
            self.updatedBy = updatedBy
            self.usages = usages
            self.usageTrackingResource = usageTrackingResource
        }

        private enum CodingKeys: String, CodingKey {
            case actions = "actions"
            case approximateDollarLimit = "approximateDollarLimit"
            case budgetId = "budgetId"
            case createdAt = "createdAt"
            case createdBy = "createdBy"
            case description = "description"
            case displayName = "displayName"
            case queueStoppedAt = "queueStoppedAt"
            case schedule = "schedule"
            case status = "status"
            case updatedAt = "updatedAt"
            case updatedBy = "updatedBy"
            case usages = "usages"
            case usageTrackingResource = "usageTrackingResource"
        }
    }

    public struct GetFarmRequest: AWSEncodableShape {
        /// The farm ID of the farm.
        public let farmId: String

        @inlinable
        public init(farmId: String) {
            self.farmId = farmId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.farmId, key: "farmId")
        }

        public func validate(name: String) throws {
            try self.validate(self.farmId, name: "farmId", parent: name, pattern: "^farm-[0-9a-f]{32}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetFarmResponse: AWSDecodableShape {
        /// The date and time the resource was created.
        @CustomCoding<ISO8601DateCoder>
        public var createdAt: Date
        /// The user or system that created this resource.
        public let createdBy: String
        /// The description of the farm.  This field can store any content. Escape or encode this content before displaying it on a webpage or any other system that might interpret the content of this field.
        public let description: String?
        /// The display name of the farm.  This field can store any content. Escape or encode this content before displaying it on a webpage or any other system that might interpret the content of this field.
        public let displayName: String
        /// The farm ID of the farm to get.
        public let farmId: String
        /// The ARN of the KMS key used on the farm.
        public let kmsKeyArn: String
        /// The date and time the resource was updated.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var updatedAt: Date?
        /// The user or system that updated this resource.
        public let updatedBy: String?

        @inlinable
        public init(createdAt: Date, createdBy: String, description: String? = nil, displayName: String, farmId: String, kmsKeyArn: String, updatedAt: Date? = nil, updatedBy: String? = nil) {
            self.createdAt = createdAt
            self.createdBy = createdBy
            self.description = description
            self.displayName = displayName
            self.farmId = farmId
            self.kmsKeyArn = kmsKeyArn
            self.updatedAt = updatedAt
            self.updatedBy = updatedBy
        }

        private enum CodingKeys: String, CodingKey {
            case createdAt = "createdAt"
            case createdBy = "createdBy"
            case description = "description"
            case displayName = "displayName"
            case farmId = "farmId"
            case kmsKeyArn = "kmsKeyArn"
            case updatedAt = "updatedAt"
            case updatedBy = "updatedBy"
        }
    }

    public struct GetFleetRequest: AWSEncodableShape {
        /// The farm ID of the farm in the fleet.
        public let farmId: String
        /// The fleet ID of the fleet to get.
        public let fleetId: String

        @inlinable
        public init(farmId: String, fleetId: String) {
            self.farmId = farmId
            self.fleetId = fleetId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.farmId, key: "farmId")
            request.encodePath(self.fleetId, key: "fleetId")
        }

        public func validate(name: String) throws {
            try self.validate(self.farmId, name: "farmId", parent: name, pattern: "^farm-[0-9a-f]{32}$")
            try self.validate(self.fleetId, name: "fleetId", parent: name, pattern: "^fleet-[0-9a-f]{32}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetFleetResponse: AWSDecodableShape {
        /// The Auto Scaling status of the fleet. Either GROWING, STEADY, or SHRINKING.
        public let autoScalingStatus: AutoScalingStatus?
        /// Outlines what the fleet is capable of for minimums, maximums, and naming, in addition to attribute names and values.
        public let capabilities: FleetCapabilities?
        /// The configuration setting for the fleet.
        public let configuration: FleetConfiguration
        /// The date and time the resource was created.
        @CustomCoding<ISO8601DateCoder>
        public var createdAt: Date
        /// The user or system that created this resource.
        public let createdBy: String
        /// The description of the fleet.  This field can store any content. Escape or encode this content before displaying it on a webpage or any other system that might interpret the content of this field.
        public let description: String?
        /// The display name of the fleet.  This field can store any content. Escape or encode this content before displaying it on a webpage or any other system that might interpret the content of this field.
        public let displayName: String
        /// The farm ID of the farm in the fleet.
        public let farmId: String
        /// The fleet ID.
        public let fleetId: String
        /// The maximum number of workers specified in the fleet.
        public let maxWorkerCount: Int
        /// The minimum number of workers specified in the fleet.
        public let minWorkerCount: Int
        /// The IAM role ARN.
        public let roleArn: String
        /// The Auto Scaling status of the fleet.
        public let status: FleetStatus
        /// The number of target workers in the fleet.
        public let targetWorkerCount: Int?
        /// The date and time the resource was updated.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var updatedAt: Date?
        /// The user or system that updated this resource.
        public let updatedBy: String?
        /// The number of workers in the fleet.
        public let workerCount: Int

        @inlinable
        public init(autoScalingStatus: AutoScalingStatus? = nil, capabilities: FleetCapabilities? = nil, configuration: FleetConfiguration, createdAt: Date, createdBy: String, description: String? = nil, displayName: String, farmId: String, fleetId: String, maxWorkerCount: Int, minWorkerCount: Int, roleArn: String, status: FleetStatus, targetWorkerCount: Int? = nil, updatedAt: Date? = nil, updatedBy: String? = nil, workerCount: Int) {
            self.autoScalingStatus = autoScalingStatus
            self.capabilities = capabilities
            self.configuration = configuration
            self.createdAt = createdAt
            self.createdBy = createdBy
            self.description = description
            self.displayName = displayName
            self.farmId = farmId
            self.fleetId = fleetId
            self.maxWorkerCount = maxWorkerCount
            self.minWorkerCount = minWorkerCount
            self.roleArn = roleArn
            self.status = status
            self.targetWorkerCount = targetWorkerCount
            self.updatedAt = updatedAt
            self.updatedBy = updatedBy
            self.workerCount = workerCount
        }

        private enum CodingKeys: String, CodingKey {
            case autoScalingStatus = "autoScalingStatus"
            case capabilities = "capabilities"
            case configuration = "configuration"
            case createdAt = "createdAt"
            case createdBy = "createdBy"
            case description = "description"
            case displayName = "displayName"
            case farmId = "farmId"
            case fleetId = "fleetId"
            case maxWorkerCount = "maxWorkerCount"
            case minWorkerCount = "minWorkerCount"
            case roleArn = "roleArn"
            case status = "status"
            case targetWorkerCount = "targetWorkerCount"
            case updatedAt = "updatedAt"
            case updatedBy = "updatedBy"
            case workerCount = "workerCount"
        }
    }

    public struct GetJobRequest: AWSEncodableShape {
        /// The farm ID of the farm in the job.
        public let farmId: String
        /// The job ID.
        public let jobId: String
        /// The queue ID associated with the job.
        public let queueId: String

        @inlinable
        public init(farmId: String, jobId: String, queueId: String) {
            self.farmId = farmId
            self.jobId = jobId
            self.queueId = queueId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.farmId, key: "farmId")
            request.encodePath(self.jobId, key: "jobId")
            request.encodePath(self.queueId, key: "queueId")
        }

        public func validate(name: String) throws {
            try self.validate(self.farmId, name: "farmId", parent: name, pattern: "^farm-[0-9a-f]{32}$")
            try self.validate(self.jobId, name: "jobId", parent: name, pattern: "^job-[0-9a-f]{32}$")
            try self.validate(self.queueId, name: "queueId", parent: name, pattern: "^queue-[0-9a-f]{32}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetJobResponse: AWSDecodableShape {
        /// The attachments for the job.
        public let attachments: Attachments?
        /// The date and time the resource was created.
        @CustomCoding<ISO8601DateCoder>
        public var createdAt: Date
        /// The user or system that created this resource.
        public let createdBy: String
        /// The description of the job.  This field can store any content. Escape or encode this content before displaying it on a webpage or any other system that might interpret the content of this field.
        public let description: String?
        /// The date and time the resource ended running.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var endedAt: Date?
        /// The job ID.
        public let jobId: String
        /// The life cycle status for the job.
        public let lifecycleStatus: JobLifecycleStatus
        /// A message that communicates the status of the life cycle for the job.
        public let lifecycleStatusMessage: String
        /// The number of task failures before the job stops running and is marked as FAILED.
        public let maxFailedTasksCount: Int?
        /// The maximum number of retries per failed tasks.
        public let maxRetriesPerTask: Int?
        /// The maximum number of worker hosts that can concurrently process a job. When the maxWorkerCount is reached, no more workers will be assigned to process the job, even if the fleets assigned to the job's queue has available workers. If you don't set the maxWorkerCount when you create a job, this value is not returned in the response.
        public let maxWorkerCount: Int?
        /// The name of the job.
        public let name: String
        /// The parameters for the job.
        public let parameters: [String: JobParameter]?
        /// The job priority.
        public let priority: Int
        /// The job ID for the source job.
        public let sourceJobId: String?
        /// The date and time the resource started running.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var startedAt: Date?
        /// The storage profile ID associated with the job.
        public let storageProfileId: String?
        /// The task status with which the job started.
        public let targetTaskRunStatus: JobTargetTaskRunStatus?
        /// The task run status for the job.
        public let taskRunStatus: TaskRunStatus?
        /// The number of tasks running on the job.
        public let taskRunStatusCounts: [TaskRunStatus: Int]?
        /// The date and time the resource was updated.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var updatedAt: Date?
        /// The user or system that updated this resource.
        public let updatedBy: String?

        @inlinable
        public init(attachments: Attachments? = nil, createdAt: Date, createdBy: String, description: String? = nil, endedAt: Date? = nil, jobId: String, lifecycleStatus: JobLifecycleStatus, lifecycleStatusMessage: String, maxFailedTasksCount: Int? = nil, maxRetriesPerTask: Int? = nil, maxWorkerCount: Int? = nil, name: String, parameters: [String: JobParameter]? = nil, priority: Int, sourceJobId: String? = nil, startedAt: Date? = nil, storageProfileId: String? = nil, targetTaskRunStatus: JobTargetTaskRunStatus? = nil, taskRunStatus: TaskRunStatus? = nil, taskRunStatusCounts: [TaskRunStatus: Int]? = nil, updatedAt: Date? = nil, updatedBy: String? = nil) {
            self.attachments = attachments
            self.createdAt = createdAt
            self.createdBy = createdBy
            self.description = description
            self.endedAt = endedAt
            self.jobId = jobId
            self.lifecycleStatus = lifecycleStatus
            self.lifecycleStatusMessage = lifecycleStatusMessage
            self.maxFailedTasksCount = maxFailedTasksCount
            self.maxRetriesPerTask = maxRetriesPerTask
            self.maxWorkerCount = maxWorkerCount
            self.name = name
            self.parameters = parameters
            self.priority = priority
            self.sourceJobId = sourceJobId
            self.startedAt = startedAt
            self.storageProfileId = storageProfileId
            self.targetTaskRunStatus = targetTaskRunStatus
            self.taskRunStatus = taskRunStatus
            self.taskRunStatusCounts = taskRunStatusCounts
            self.updatedAt = updatedAt
            self.updatedBy = updatedBy
        }

        private enum CodingKeys: String, CodingKey {
            case attachments = "attachments"
            case createdAt = "createdAt"
            case createdBy = "createdBy"
            case description = "description"
            case endedAt = "endedAt"
            case jobId = "jobId"
            case lifecycleStatus = "lifecycleStatus"
            case lifecycleStatusMessage = "lifecycleStatusMessage"
            case maxFailedTasksCount = "maxFailedTasksCount"
            case maxRetriesPerTask = "maxRetriesPerTask"
            case maxWorkerCount = "maxWorkerCount"
            case name = "name"
            case parameters = "parameters"
            case priority = "priority"
            case sourceJobId = "sourceJobId"
            case startedAt = "startedAt"
            case storageProfileId = "storageProfileId"
            case targetTaskRunStatus = "targetTaskRunStatus"
            case taskRunStatus = "taskRunStatus"
            case taskRunStatusCounts = "taskRunStatusCounts"
            case updatedAt = "updatedAt"
            case updatedBy = "updatedBy"
        }
    }

    public struct GetLicenseEndpointRequest: AWSEncodableShape {
        /// The license endpoint ID.
        public let licenseEndpointId: String

        @inlinable
        public init(licenseEndpointId: String) {
            self.licenseEndpointId = licenseEndpointId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.licenseEndpointId, key: "licenseEndpointId")
        }

        public func validate(name: String) throws {
            try self.validate(self.licenseEndpointId, name: "licenseEndpointId", parent: name, pattern: "^le-[0-9a-f]{32}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetLicenseEndpointResponse: AWSDecodableShape {
        /// The DNS name.
        public let dnsName: String?
        /// The license endpoint ID.
        public let licenseEndpointId: String
        /// The security group IDs for the license endpoint.
        public let securityGroupIds: [String]?
        /// The status of the license endpoint.
        public let status: LicenseEndpointStatus
        /// The status message of the license endpoint.
        public let statusMessage: String
        /// The subnet IDs.
        public let subnetIds: [String]?
        /// The VCP(virtual private cloud) ID associated with the license endpoint.
        public let vpcId: String?

        @inlinable
        public init(dnsName: String? = nil, licenseEndpointId: String, securityGroupIds: [String]? = nil, status: LicenseEndpointStatus, statusMessage: String, subnetIds: [String]? = nil, vpcId: String? = nil) {
            self.dnsName = dnsName
            self.licenseEndpointId = licenseEndpointId
            self.securityGroupIds = securityGroupIds
            self.status = status
            self.statusMessage = statusMessage
            self.subnetIds = subnetIds
            self.vpcId = vpcId
        }

        private enum CodingKeys: String, CodingKey {
            case dnsName = "dnsName"
            case licenseEndpointId = "licenseEndpointId"
            case securityGroupIds = "securityGroupIds"
            case status = "status"
            case statusMessage = "statusMessage"
            case subnetIds = "subnetIds"
            case vpcId = "vpcId"
        }
    }

    public struct GetLimitRequest: AWSEncodableShape {
        /// The unique identifier of the farm that contains the limit.
        public let farmId: String
        /// The unique identifier of the limit to return.
        public let limitId: String

        @inlinable
        public init(farmId: String, limitId: String) {
            self.farmId = farmId
            self.limitId = limitId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.farmId, key: "farmId")
            request.encodePath(self.limitId, key: "limitId")
        }

        public func validate(name: String) throws {
            try self.validate(self.farmId, name: "farmId", parent: name, pattern: "^farm-[0-9a-f]{32}$")
            try self.validate(self.limitId, name: "limitId", parent: name, pattern: "^limit-[0-9a-f]{32}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetLimitResponse: AWSDecodableShape {
        /// The value that you specify as the name in the amounts field of the hostRequirements in a step of a job template to declare the limit requirement.
        public let amountRequirementName: String
        /// The Unix timestamp of the date and time that the limit was created.
        @CustomCoding<ISO8601DateCoder>
        public var createdAt: Date
        /// The user identifier of the person that created the limit.
        public let createdBy: String
        /// The number of resources from the limit that are being used by jobs. The result is delayed and may not be the count at the time that you called the operation.
        public let currentCount: Int
        /// The description of the limit that helps identify what the limit is used for.  This field can store any content. Escape or encode this content before displaying it on a webpage or any other system that might interpret the content of this field.
        public let description: String?
        /// The display name of the limit.  This field can store any content. Escape or encode this content before displaying it on a webpage or any other system that might interpret the content of this field.
        public let displayName: String
        /// The unique identifier of the farm that contains the limit.
        public let farmId: String
        /// The unique identifier of the limit.
        public let limitId: String
        /// The maximum number of resources constrained by this limit. When all of the resources are in use, steps that require the limit won't be scheduled until the resource is available. The maxValue must not be 0. If the value is -1, there is no restriction on the number of resources that can be acquired for this limit.
        public let maxCount: Int
        /// The Unix timestamp of the date and time that the limit was last updated.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var updatedAt: Date?
        /// The user identifier of the person that last updated the limit.
        public let updatedBy: String?

        @inlinable
        public init(amountRequirementName: String, createdAt: Date, createdBy: String, currentCount: Int, description: String? = nil, displayName: String, farmId: String, limitId: String, maxCount: Int, updatedAt: Date? = nil, updatedBy: String? = nil) {
            self.amountRequirementName = amountRequirementName
            self.createdAt = createdAt
            self.createdBy = createdBy
            self.currentCount = currentCount
            self.description = description
            self.displayName = displayName
            self.farmId = farmId
            self.limitId = limitId
            self.maxCount = maxCount
            self.updatedAt = updatedAt
            self.updatedBy = updatedBy
        }

        private enum CodingKeys: String, CodingKey {
            case amountRequirementName = "amountRequirementName"
            case createdAt = "createdAt"
            case createdBy = "createdBy"
            case currentCount = "currentCount"
            case description = "description"
            case displayName = "displayName"
            case farmId = "farmId"
            case limitId = "limitId"
            case maxCount = "maxCount"
            case updatedAt = "updatedAt"
            case updatedBy = "updatedBy"
        }
    }

    public struct GetMonitorRequest: AWSEncodableShape {
        /// The unique identifier for the monitor. This ID is returned by the CreateMonitor operation.
        public let monitorId: String

        @inlinable
        public init(monitorId: String) {
            self.monitorId = monitorId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.monitorId, key: "monitorId")
        }

        public func validate(name: String) throws {
            try self.validate(self.monitorId, name: "monitorId", parent: name, pattern: "^monitor-[0-9a-f]{32}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetMonitorResponse: AWSDecodableShape {
        /// The UNIX timestamp of the date and time that the monitor was created.
        @CustomCoding<ISO8601DateCoder>
        public var createdAt: Date
        /// The user name of the person that created the monitor.
        public let createdBy: String
        /// The name used to identify the monitor on the Deadline Cloud console.  This field can store any content. Escape or encode this content before displaying it on a webpage or any other system that might interpret the content of this field.
        public let displayName: String
        /// The Amazon Resource Name (ARN) that the IAM Identity Center assigned to the monitor when it was created.
        public let identityCenterApplicationArn: String
        /// The Amazon Resource Name (ARN) of the IAM Identity Center instance responsible for authenticating monitor users.
        public let identityCenterInstanceArn: String
        /// The unique identifier for the monitor.
        public let monitorId: String
        /// The Amazon Resource Name (ARN) of the IAM role for the monitor. Users of the monitor use this role to access Deadline Cloud resources.
        public let roleArn: String
        /// The subdomain used for the monitor URL. The full URL of the monitor is subdomain.Region.deadlinecloud.amazonaws.com.
        public let subdomain: String
        /// The UNIX timestamp of the last date and time that the monitor was updated.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var updatedAt: Date?
        /// The user name of the person that last updated the monitor.
        public let updatedBy: String?
        /// The complete URL of the monitor. The full URL of the monitor is subdomain.Region.deadlinecloud.amazonaws.com.
        public let url: String

        @inlinable
        public init(createdAt: Date, createdBy: String, displayName: String, identityCenterApplicationArn: String, identityCenterInstanceArn: String, monitorId: String, roleArn: String, subdomain: String, updatedAt: Date? = nil, updatedBy: String? = nil, url: String) {
            self.createdAt = createdAt
            self.createdBy = createdBy
            self.displayName = displayName
            self.identityCenterApplicationArn = identityCenterApplicationArn
            self.identityCenterInstanceArn = identityCenterInstanceArn
            self.monitorId = monitorId
            self.roleArn = roleArn
            self.subdomain = subdomain
            self.updatedAt = updatedAt
            self.updatedBy = updatedBy
            self.url = url
        }

        private enum CodingKeys: String, CodingKey {
            case createdAt = "createdAt"
            case createdBy = "createdBy"
            case displayName = "displayName"
            case identityCenterApplicationArn = "identityCenterApplicationArn"
            case identityCenterInstanceArn = "identityCenterInstanceArn"
            case monitorId = "monitorId"
            case roleArn = "roleArn"
            case subdomain = "subdomain"
            case updatedAt = "updatedAt"
            case updatedBy = "updatedBy"
            case url = "url"
        }
    }

    public struct GetQueueEnvironmentRequest: AWSEncodableShape {
        /// The farm ID for the queue environment.
        public let farmId: String
        /// The queue environment ID.
        public let queueEnvironmentId: String
        /// The queue ID for the queue environment.
        public let queueId: String

        @inlinable
        public init(farmId: String, queueEnvironmentId: String, queueId: String) {
            self.farmId = farmId
            self.queueEnvironmentId = queueEnvironmentId
            self.queueId = queueId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.farmId, key: "farmId")
            request.encodePath(self.queueEnvironmentId, key: "queueEnvironmentId")
            request.encodePath(self.queueId, key: "queueId")
        }

        public func validate(name: String) throws {
            try self.validate(self.farmId, name: "farmId", parent: name, pattern: "^farm-[0-9a-f]{32}$")
            try self.validate(self.queueEnvironmentId, name: "queueEnvironmentId", parent: name, pattern: "^queueenv-[0-9a-f]{32}$")
            try self.validate(self.queueId, name: "queueId", parent: name, pattern: "^queue-[0-9a-f]{32}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetQueueEnvironmentResponse: AWSDecodableShape {
        /// The date and time the resource was created.
        @CustomCoding<ISO8601DateCoder>
        public var createdAt: Date
        /// The user or system that created this resource.&gt;
        public let createdBy: String
        /// The name of the queue environment.
        public let name: String
        /// The priority of the queue environment.
        public let priority: Int
        /// The queue environment ID.
        public let queueEnvironmentId: String
        /// The template for the queue environment.
        public let template: String
        /// The type of template for the queue environment.
        public let templateType: EnvironmentTemplateType
        /// The date and time the resource was updated.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var updatedAt: Date?
        /// The user or system that updated this resource.
        public let updatedBy: String?

        @inlinable
        public init(createdAt: Date, createdBy: String, name: String, priority: Int, queueEnvironmentId: String, template: String, templateType: EnvironmentTemplateType, updatedAt: Date? = nil, updatedBy: String? = nil) {
            self.createdAt = createdAt
            self.createdBy = createdBy
            self.name = name
            self.priority = priority
            self.queueEnvironmentId = queueEnvironmentId
            self.template = template
            self.templateType = templateType
            self.updatedAt = updatedAt
            self.updatedBy = updatedBy
        }

        private enum CodingKeys: String, CodingKey {
            case createdAt = "createdAt"
            case createdBy = "createdBy"
            case name = "name"
            case priority = "priority"
            case queueEnvironmentId = "queueEnvironmentId"
            case template = "template"
            case templateType = "templateType"
            case updatedAt = "updatedAt"
            case updatedBy = "updatedBy"
        }
    }

    public struct GetQueueFleetAssociationRequest: AWSEncodableShape {
        /// The farm ID of the farm that contains the queue-fleet association.
        public let farmId: String
        /// The fleet ID for the queue-fleet association.
        public let fleetId: String
        /// The queue ID for the queue-fleet association.
        public let queueId: String

        @inlinable
        public init(farmId: String, fleetId: String, queueId: String) {
            self.farmId = farmId
            self.fleetId = fleetId
            self.queueId = queueId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.farmId, key: "farmId")
            request.encodePath(self.fleetId, key: "fleetId")
            request.encodePath(self.queueId, key: "queueId")
        }

        public func validate(name: String) throws {
            try self.validate(self.farmId, name: "farmId", parent: name, pattern: "^farm-[0-9a-f]{32}$")
            try self.validate(self.fleetId, name: "fleetId", parent: name, pattern: "^fleet-[0-9a-f]{32}$")
            try self.validate(self.queueId, name: "queueId", parent: name, pattern: "^queue-[0-9a-f]{32}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetQueueFleetAssociationResponse: AWSDecodableShape {
        /// The date and time the resource was created.
        @CustomCoding<ISO8601DateCoder>
        public var createdAt: Date
        /// The user or system that created this resource.
        public let createdBy: String
        /// The fleet ID for the queue-fleet association.
        public let fleetId: String
        /// The queue ID for the queue-fleet association.
        public let queueId: String
        /// The status of the queue-fleet association.
        public let status: QueueFleetAssociationStatus
        /// The date and time the resource was updated.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var updatedAt: Date?
        /// The user or system that updated this resource.
        public let updatedBy: String?

        @inlinable
        public init(createdAt: Date, createdBy: String, fleetId: String, queueId: String, status: QueueFleetAssociationStatus, updatedAt: Date? = nil, updatedBy: String? = nil) {
            self.createdAt = createdAt
            self.createdBy = createdBy
            self.fleetId = fleetId
            self.queueId = queueId
            self.status = status
            self.updatedAt = updatedAt
            self.updatedBy = updatedBy
        }

        private enum CodingKeys: String, CodingKey {
            case createdAt = "createdAt"
            case createdBy = "createdBy"
            case fleetId = "fleetId"
            case queueId = "queueId"
            case status = "status"
            case updatedAt = "updatedAt"
            case updatedBy = "updatedBy"
        }
    }

    public struct GetQueueLimitAssociationRequest: AWSEncodableShape {
        /// The unique identifier of the farm that contains the associated queue and limit.
        public let farmId: String
        /// The unique identifier of the limit associated with the queue.
        public let limitId: String
        /// The unique identifier of the queue associated with the limit.
        public let queueId: String

        @inlinable
        public init(farmId: String, limitId: String, queueId: String) {
            self.farmId = farmId
            self.limitId = limitId
            self.queueId = queueId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.farmId, key: "farmId")
            request.encodePath(self.limitId, key: "limitId")
            request.encodePath(self.queueId, key: "queueId")
        }

        public func validate(name: String) throws {
            try self.validate(self.farmId, name: "farmId", parent: name, pattern: "^farm-[0-9a-f]{32}$")
            try self.validate(self.limitId, name: "limitId", parent: name, pattern: "^limit-[0-9a-f]{32}$")
            try self.validate(self.queueId, name: "queueId", parent: name, pattern: "^queue-[0-9a-f]{32}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetQueueLimitAssociationResponse: AWSDecodableShape {
        /// The Unix timestamp of the date and time that the association was created.
        @CustomCoding<ISO8601DateCoder>
        public var createdAt: Date
        /// The user identifier of the person that created the association.
        public let createdBy: String
        /// The unique identifier of the limit associated with the queue.
        public let limitId: String
        /// The unique identifier of the queue associated with the limit.
        public let queueId: String
        /// The current status of the limit.
        public let status: QueueLimitAssociationStatus
        /// The Unix timestamp of the date and time that the association was last updated.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var updatedAt: Date?
        /// The user identifier of the person that last updated the association.
        public let updatedBy: String?

        @inlinable
        public init(createdAt: Date, createdBy: String, limitId: String, queueId: String, status: QueueLimitAssociationStatus, updatedAt: Date? = nil, updatedBy: String? = nil) {
            self.createdAt = createdAt
            self.createdBy = createdBy
            self.limitId = limitId
            self.queueId = queueId
            self.status = status
            self.updatedAt = updatedAt
            self.updatedBy = updatedBy
        }

        private enum CodingKeys: String, CodingKey {
            case createdAt = "createdAt"
            case createdBy = "createdBy"
            case limitId = "limitId"
            case queueId = "queueId"
            case status = "status"
            case updatedAt = "updatedAt"
            case updatedBy = "updatedBy"
        }
    }

    public struct GetQueueRequest: AWSEncodableShape {
        /// The farm ID of the farm in the queue.
        public let farmId: String
        /// The queue ID for the queue to retrieve.
        public let queueId: String

        @inlinable
        public init(farmId: String, queueId: String) {
            self.farmId = farmId
            self.queueId = queueId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.farmId, key: "farmId")
            request.encodePath(self.queueId, key: "queueId")
        }

        public func validate(name: String) throws {
            try self.validate(self.farmId, name: "farmId", parent: name, pattern: "^farm-[0-9a-f]{32}$")
            try self.validate(self.queueId, name: "queueId", parent: name, pattern: "^queue-[0-9a-f]{32}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetQueueResponse: AWSDecodableShape {
        /// The storage profile IDs for the queue.
        public let allowedStorageProfileIds: [String]?
        /// The reason the queue was blocked.
        public let blockedReason: QueueBlockedReason?
        /// The date and time the resource was created.
        @CustomCoding<ISO8601DateCoder>
        public var createdAt: Date
        /// The user or system that created this resource.
        public let createdBy: String
        /// The default action taken on a queue if a budget wasn't configured.
        public let defaultBudgetAction: DefaultQueueBudgetAction
        /// The description of the queue.  This field can store any content. Escape or encode this content before displaying it on a webpage or any other system that might interpret the content of this field.
        public let description: String?
        /// The display name of the queue.  This field can store any content. Escape or encode this content before displaying it on a webpage or any other system that might interpret the content of this field.
        public let displayName: String
        /// The farm ID for the queue.
        public let farmId: String
        /// The job attachment settings for the queue.
        public let jobAttachmentSettings: JobAttachmentSettings?
        /// The jobs in the queue ran as this specified POSIX user.
        public let jobRunAsUser: JobRunAsUser?
        /// The queue ID.
        public let queueId: String
        /// A list of the required file system location names in the queue.
        public let requiredFileSystemLocationNames: [String]?
        /// The IAM role ARN.
        public let roleArn: String?
        /// The status of the queue.    ACTIVEThe queue is active.    SCHEDULINGThe queue is scheduling.    SCHEDULING_BLOCKEDThe queue scheduling is blocked. See the provided reason.
        public let status: QueueStatus
        /// The date and time the resource was updated.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var updatedAt: Date?
        /// The user or system that updated this resource.
        public let updatedBy: String?

        @inlinable
        public init(allowedStorageProfileIds: [String]? = nil, blockedReason: QueueBlockedReason? = nil, createdAt: Date, createdBy: String, defaultBudgetAction: DefaultQueueBudgetAction, description: String? = nil, displayName: String, farmId: String, jobAttachmentSettings: JobAttachmentSettings? = nil, jobRunAsUser: JobRunAsUser? = nil, queueId: String, requiredFileSystemLocationNames: [String]? = nil, roleArn: String? = nil, status: QueueStatus, updatedAt: Date? = nil, updatedBy: String? = nil) {
            self.allowedStorageProfileIds = allowedStorageProfileIds
            self.blockedReason = blockedReason
            self.createdAt = createdAt
            self.createdBy = createdBy
            self.defaultBudgetAction = defaultBudgetAction
            self.description = description
            self.displayName = displayName
            self.farmId = farmId
            self.jobAttachmentSettings = jobAttachmentSettings
            self.jobRunAsUser = jobRunAsUser
            self.queueId = queueId
            self.requiredFileSystemLocationNames = requiredFileSystemLocationNames
            self.roleArn = roleArn
            self.status = status
            self.updatedAt = updatedAt
            self.updatedBy = updatedBy
        }

        private enum CodingKeys: String, CodingKey {
            case allowedStorageProfileIds = "allowedStorageProfileIds"
            case blockedReason = "blockedReason"
            case createdAt = "createdAt"
            case createdBy = "createdBy"
            case defaultBudgetAction = "defaultBudgetAction"
            case description = "description"
            case displayName = "displayName"
            case farmId = "farmId"
            case jobAttachmentSettings = "jobAttachmentSettings"
            case jobRunAsUser = "jobRunAsUser"
            case queueId = "queueId"
            case requiredFileSystemLocationNames = "requiredFileSystemLocationNames"
            case roleArn = "roleArn"
            case status = "status"
            case updatedAt = "updatedAt"
            case updatedBy = "updatedBy"
        }
    }

    public struct GetSessionActionRequest: AWSEncodableShape {
        /// The farm ID for the session action.
        public let farmId: String
        /// The job ID for the session.
        public let jobId: String
        /// The queue ID for the session action.
        public let queueId: String
        /// The session action ID for the session.
        public let sessionActionId: String

        @inlinable
        public init(farmId: String, jobId: String, queueId: String, sessionActionId: String) {
            self.farmId = farmId
            self.jobId = jobId
            self.queueId = queueId
            self.sessionActionId = sessionActionId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.farmId, key: "farmId")
            request.encodePath(self.jobId, key: "jobId")
            request.encodePath(self.queueId, key: "queueId")
            request.encodePath(self.sessionActionId, key: "sessionActionId")
        }

        public func validate(name: String) throws {
            try self.validate(self.farmId, name: "farmId", parent: name, pattern: "^farm-[0-9a-f]{32}$")
            try self.validate(self.jobId, name: "jobId", parent: name, pattern: "^job-[0-9a-f]{32}$")
            try self.validate(self.queueId, name: "queueId", parent: name, pattern: "^queue-[0-9a-f]{32}$")
            try self.validate(self.sessionActionId, name: "sessionActionId", parent: name, pattern: "^sessionaction-[0-9a-f]{32}-(0|([1-9][0-9]{0,9}))$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetSessionActionResponse: AWSDecodableShape {
        /// The limits and their amounts acquired during a session action. If no limits were acquired during the session, this field isn't returned.
        public let acquiredLimits: [AcquiredLimit]?
        /// The session action definition.
        public let definition: SessionActionDefinition
        /// The date and time the resource ended running.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var endedAt: Date?
        /// The process exit code. The default Deadline Cloud worker agent converts unsigned 32-bit exit codes to signed 32-bit exit codes.
        public let processExitCode: Int?
        /// The message that communicates the progress of the session action.
        public let progressMessage: String?
        /// The percentage completed for a session action.
        public let progressPercent: Float?
        /// The session action ID.
        public let sessionActionId: String
        /// The session ID for the session action.
        public let sessionId: String
        /// The date and time the resource started running.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var startedAt: Date?
        /// The status of the session action.
        public let status: SessionActionStatus
        /// The Linux timestamp of the date and time the session action was last updated.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var workerUpdatedAt: Date?

        @inlinable
        public init(acquiredLimits: [AcquiredLimit]? = nil, definition: SessionActionDefinition, endedAt: Date? = nil, processExitCode: Int? = nil, progressMessage: String? = nil, progressPercent: Float? = nil, sessionActionId: String, sessionId: String, startedAt: Date? = nil, status: SessionActionStatus, workerUpdatedAt: Date? = nil) {
            self.acquiredLimits = acquiredLimits
            self.definition = definition
            self.endedAt = endedAt
            self.processExitCode = processExitCode
            self.progressMessage = progressMessage
            self.progressPercent = progressPercent
            self.sessionActionId = sessionActionId
            self.sessionId = sessionId
            self.startedAt = startedAt
            self.status = status
            self.workerUpdatedAt = workerUpdatedAt
        }

        private enum CodingKeys: String, CodingKey {
            case acquiredLimits = "acquiredLimits"
            case definition = "definition"
            case endedAt = "endedAt"
            case processExitCode = "processExitCode"
            case progressMessage = "progressMessage"
            case progressPercent = "progressPercent"
            case sessionActionId = "sessionActionId"
            case sessionId = "sessionId"
            case startedAt = "startedAt"
            case status = "status"
            case workerUpdatedAt = "workerUpdatedAt"
        }
    }

    public struct GetSessionRequest: AWSEncodableShape {
        /// The farm ID for the session.
        public let farmId: String
        /// The job ID for the session.
        public let jobId: String
        /// The queue ID for the session.
        public let queueId: String
        /// The session ID.
        public let sessionId: String

        @inlinable
        public init(farmId: String, jobId: String, queueId: String, sessionId: String) {
            self.farmId = farmId
            self.jobId = jobId
            self.queueId = queueId
            self.sessionId = sessionId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.farmId, key: "farmId")
            request.encodePath(self.jobId, key: "jobId")
            request.encodePath(self.queueId, key: "queueId")
            request.encodePath(self.sessionId, key: "sessionId")
        }

        public func validate(name: String) throws {
            try self.validate(self.farmId, name: "farmId", parent: name, pattern: "^farm-[0-9a-f]{32}$")
            try self.validate(self.jobId, name: "jobId", parent: name, pattern: "^job-[0-9a-f]{32}$")
            try self.validate(self.queueId, name: "queueId", parent: name, pattern: "^queue-[0-9a-f]{32}$")
            try self.validate(self.sessionId, name: "sessionId", parent: name, pattern: "^session-[0-9a-f]{32}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetSessionResponse: AWSDecodableShape {
        /// The date and time the resource ended running.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var endedAt: Date?
        /// The fleet ID for the session.
        public let fleetId: String
        /// Provides the Amazon EC2 properties of the host.
        public let hostProperties: HostPropertiesResponse?
        /// The life cycle status of the session.
        public let lifecycleStatus: SessionLifecycleStatus
        /// The session log.
        public let log: LogConfiguration
        /// The session ID.
        public let sessionId: String
        /// The date and time the resource started running.
        @CustomCoding<ISO8601DateCoder>
        public var startedAt: Date
        /// The life cycle status with which the session started.
        public let targetLifecycleStatus: SessionLifecycleTargetStatus?
        /// The date and time the resource was updated.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var updatedAt: Date?
        /// The user or system that updated this resource.
        public let updatedBy: String?
        /// The worker ID for the session.
        public let workerId: String
        /// The worker log for the session.
        public let workerLog: LogConfiguration?

        @inlinable
        public init(endedAt: Date? = nil, fleetId: String, hostProperties: HostPropertiesResponse? = nil, lifecycleStatus: SessionLifecycleStatus, log: LogConfiguration, sessionId: String, startedAt: Date, targetLifecycleStatus: SessionLifecycleTargetStatus? = nil, updatedAt: Date? = nil, updatedBy: String? = nil, workerId: String, workerLog: LogConfiguration? = nil) {
            self.endedAt = endedAt
            self.fleetId = fleetId
            self.hostProperties = hostProperties
            self.lifecycleStatus = lifecycleStatus
            self.log = log
            self.sessionId = sessionId
            self.startedAt = startedAt
            self.targetLifecycleStatus = targetLifecycleStatus
            self.updatedAt = updatedAt
            self.updatedBy = updatedBy
            self.workerId = workerId
            self.workerLog = workerLog
        }

        private enum CodingKeys: String, CodingKey {
            case endedAt = "endedAt"
            case fleetId = "fleetId"
            case hostProperties = "hostProperties"
            case lifecycleStatus = "lifecycleStatus"
            case log = "log"
            case sessionId = "sessionId"
            case startedAt = "startedAt"
            case targetLifecycleStatus = "targetLifecycleStatus"
            case updatedAt = "updatedAt"
            case updatedBy = "updatedBy"
            case workerId = "workerId"
            case workerLog = "workerLog"
        }
    }

    public struct GetSessionsStatisticsAggregationRequest: AWSEncodableShape {
        /// The identifier returned by the StartSessionsStatisticsAggregation operation that identifies the aggregated statistics.
        public let aggregationId: String
        /// The identifier of the farm to include in the statistics. This should be the same as the farm ID used in the call to the StartSessionsStatisticsAggregation operation.
        public let farmId: String
        /// The maximum number of results to return. Use this parameter with NextToken to get results as a set of sequential pages.
        public let maxResults: Int?
        /// The token for the next set of results, or null to start from the beginning.
        public let nextToken: String?

        @inlinable
        public init(aggregationId: String, farmId: String, maxResults: Int? = nil, nextToken: String? = nil) {
            self.aggregationId = aggregationId
            self.farmId = farmId
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.aggregationId, key: "aggregationId")
            request.encodePath(self.farmId, key: "farmId")
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
        }

        public func validate(name: String) throws {
            try self.validate(self.aggregationId, name: "aggregationId", parent: name, pattern: "^[0-9a-f]{32}$")
            try self.validate(self.farmId, name: "farmId", parent: name, pattern: "^farm-[0-9a-f]{32}$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetSessionsStatisticsAggregationResponse: AWSDecodableShape {
        /// If Deadline Cloud returns nextToken, then there are more results available. The value of nextToken is a unique pagination token for each page. To retrieve the next page, call the operation again using the returned token. Keep all other arguments unchanged. If no results remain, then nextToken is set to null. Each pagination token expires after 24 hours. If you provide a token that isn't valid, then you receive an HTTP 400 ValidationException error.
        public let nextToken: String?
        /// The statistics for the specified fleets or queues.
        public let statistics: [Statistics]?
        /// The status of the aggregated results. An aggregation may fail or time out if the results are too large. If this happens, you can call the StartSessionsStatisticsAggregation operation after you reduce the aggregation time frame, reduce the number of queues or fleets in the aggregation, or increase the period length. If you call the StartSessionsStatisticsAggregation  operation when the status is IN_PROGRESS, you will receive a ThrottlingException.
        public let status: SessionsStatisticsAggregationStatus
        /// A message that describes the status.
        public let statusMessage: String?

        @inlinable
        public init(nextToken: String? = nil, statistics: [Statistics]? = nil, status: SessionsStatisticsAggregationStatus, statusMessage: String? = nil) {
            self.nextToken = nextToken
            self.statistics = statistics
            self.status = status
            self.statusMessage = statusMessage
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "nextToken"
            case statistics = "statistics"
            case status = "status"
            case statusMessage = "statusMessage"
        }
    }

    public struct GetStepRequest: AWSEncodableShape {
        /// The farm ID for the step.
        public let farmId: String
        /// The job ID for the step.
        public let jobId: String
        /// The queue ID for the step.
        public let queueId: String
        /// The step ID.
        public let stepId: String

        @inlinable
        public init(farmId: String, jobId: String, queueId: String, stepId: String) {
            self.farmId = farmId
            self.jobId = jobId
            self.queueId = queueId
            self.stepId = stepId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.farmId, key: "farmId")
            request.encodePath(self.jobId, key: "jobId")
            request.encodePath(self.queueId, key: "queueId")
            request.encodePath(self.stepId, key: "stepId")
        }

        public func validate(name: String) throws {
            try self.validate(self.farmId, name: "farmId", parent: name, pattern: "^farm-[0-9a-f]{32}$")
            try self.validate(self.jobId, name: "jobId", parent: name, pattern: "^job-[0-9a-f]{32}$")
            try self.validate(self.queueId, name: "queueId", parent: name, pattern: "^queue-[0-9a-f]{32}$")
            try self.validate(self.stepId, name: "stepId", parent: name, pattern: "^step-[0-9a-f]{32}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetStepResponse: AWSDecodableShape {
        /// The date and time the resource was created.
        @CustomCoding<ISO8601DateCoder>
        public var createdAt: Date
        /// The user or system that created this resource.
        public let createdBy: String
        /// The number of dependencies in the step.
        public let dependencyCounts: DependencyCounts?
        /// The description of the step.  This field can store any content. Escape or encode this content before displaying it on a webpage or any other system that might interpret the content of this field.
        public let description: String?
        /// The date and time the resource ended running.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var endedAt: Date?
        /// The life cycle status of the step.
        public let lifecycleStatus: StepLifecycleStatus
        /// A message that describes the lifecycle status of the step.
        public let lifecycleStatusMessage: String?
        /// The name of the step.
        public let name: String
        /// A list of step parameters and the combination expression for the step.
        public let parameterSpace: ParameterSpace?
        /// The required capabilities of the step.
        public let requiredCapabilities: StepRequiredCapabilities?
        /// The date and time the resource started running.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var startedAt: Date?
        /// The step ID.
        public let stepId: String
        /// The task status with which the job started.
        public let targetTaskRunStatus: StepTargetTaskRunStatus?
        /// The task run status for the job.
        public let taskRunStatus: TaskRunStatus
        /// The number of tasks running on the job.
        public let taskRunStatusCounts: [TaskRunStatus: Int]
        /// The date and time the resource was updated.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var updatedAt: Date?
        /// The user or system that updated this resource.
        public let updatedBy: String?

        @inlinable
        public init(createdAt: Date, createdBy: String, dependencyCounts: DependencyCounts? = nil, description: String? = nil, endedAt: Date? = nil, lifecycleStatus: StepLifecycleStatus, lifecycleStatusMessage: String? = nil, name: String, parameterSpace: ParameterSpace? = nil, requiredCapabilities: StepRequiredCapabilities? = nil, startedAt: Date? = nil, stepId: String, targetTaskRunStatus: StepTargetTaskRunStatus? = nil, taskRunStatus: TaskRunStatus, taskRunStatusCounts: [TaskRunStatus: Int], updatedAt: Date? = nil, updatedBy: String? = nil) {
            self.createdAt = createdAt
            self.createdBy = createdBy
            self.dependencyCounts = dependencyCounts
            self.description = description
            self.endedAt = endedAt
            self.lifecycleStatus = lifecycleStatus
            self.lifecycleStatusMessage = lifecycleStatusMessage
            self.name = name
            self.parameterSpace = parameterSpace
            self.requiredCapabilities = requiredCapabilities
            self.startedAt = startedAt
            self.stepId = stepId
            self.targetTaskRunStatus = targetTaskRunStatus
            self.taskRunStatus = taskRunStatus
            self.taskRunStatusCounts = taskRunStatusCounts
            self.updatedAt = updatedAt
            self.updatedBy = updatedBy
        }

        private enum CodingKeys: String, CodingKey {
            case createdAt = "createdAt"
            case createdBy = "createdBy"
            case dependencyCounts = "dependencyCounts"
            case description = "description"
            case endedAt = "endedAt"
            case lifecycleStatus = "lifecycleStatus"
            case lifecycleStatusMessage = "lifecycleStatusMessage"
            case name = "name"
            case parameterSpace = "parameterSpace"
            case requiredCapabilities = "requiredCapabilities"
            case startedAt = "startedAt"
            case stepId = "stepId"
            case targetTaskRunStatus = "targetTaskRunStatus"
            case taskRunStatus = "taskRunStatus"
            case taskRunStatusCounts = "taskRunStatusCounts"
            case updatedAt = "updatedAt"
            case updatedBy = "updatedBy"
        }
    }

    public struct GetStorageProfileForQueueRequest: AWSEncodableShape {
        /// The farm ID for the queue in storage profile.
        public let farmId: String
        /// The queue ID the queue in the storage profile.
        public let queueId: String
        /// The storage profile ID for the storage profile in the queue.
        public let storageProfileId: String

        @inlinable
        public init(farmId: String, queueId: String, storageProfileId: String) {
            self.farmId = farmId
            self.queueId = queueId
            self.storageProfileId = storageProfileId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.farmId, key: "farmId")
            request.encodePath(self.queueId, key: "queueId")
            request.encodePath(self.storageProfileId, key: "storageProfileId")
        }

        public func validate(name: String) throws {
            try self.validate(self.farmId, name: "farmId", parent: name, pattern: "^farm-[0-9a-f]{32}$")
            try self.validate(self.queueId, name: "queueId", parent: name, pattern: "^queue-[0-9a-f]{32}$")
            try self.validate(self.storageProfileId, name: "storageProfileId", parent: name, pattern: "^sp-[0-9a-f]{32}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetStorageProfileForQueueResponse: AWSDecodableShape {
        /// The display name of the storage profile connected to a queue.  This field can store any content. Escape or encode this content before displaying it on a webpage or any other system that might interpret the content of this field.
        public let displayName: String
        /// The location of the files for the storage profile within the queue.
        public let fileSystemLocations: [FileSystemLocation]?
        /// The operating system of the storage profile in the queue.
        public let osFamily: StorageProfileOperatingSystemFamily
        /// The storage profile ID.
        public let storageProfileId: String

        @inlinable
        public init(displayName: String, fileSystemLocations: [FileSystemLocation]? = nil, osFamily: StorageProfileOperatingSystemFamily, storageProfileId: String) {
            self.displayName = displayName
            self.fileSystemLocations = fileSystemLocations
            self.osFamily = osFamily
            self.storageProfileId = storageProfileId
        }

        private enum CodingKeys: String, CodingKey {
            case displayName = "displayName"
            case fileSystemLocations = "fileSystemLocations"
            case osFamily = "osFamily"
            case storageProfileId = "storageProfileId"
        }
    }

    public struct GetStorageProfileRequest: AWSEncodableShape {
        /// The farm ID for the storage profile.
        public let farmId: String
        /// The storage profile ID.
        public let storageProfileId: String

        @inlinable
        public init(farmId: String, storageProfileId: String) {
            self.farmId = farmId
            self.storageProfileId = storageProfileId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.farmId, key: "farmId")
            request.encodePath(self.storageProfileId, key: "storageProfileId")
        }

        public func validate(name: String) throws {
            try self.validate(self.farmId, name: "farmId", parent: name, pattern: "^farm-[0-9a-f]{32}$")
            try self.validate(self.storageProfileId, name: "storageProfileId", parent: name, pattern: "^sp-[0-9a-f]{32}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetStorageProfileResponse: AWSDecodableShape {
        /// The date and time the resource was created.
        @CustomCoding<ISO8601DateCoder>
        public var createdAt: Date
        /// The user or system that created this resource.
        public let createdBy: String
        /// The display name of the storage profile.  This field can store any content. Escape or encode this content before displaying it on a webpage or any other system that might interpret the content of this field.
        public let displayName: String
        /// The location of the files for the storage profile.
        public let fileSystemLocations: [FileSystemLocation]?
        /// The operating system (OS) for the storage profile.
        public let osFamily: StorageProfileOperatingSystemFamily
        /// The storage profile ID.
        public let storageProfileId: String
        /// The date and time the resource was updated.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var updatedAt: Date?
        /// The user or system that updated this resource.
        public let updatedBy: String?

        @inlinable
        public init(createdAt: Date, createdBy: String, displayName: String, fileSystemLocations: [FileSystemLocation]? = nil, osFamily: StorageProfileOperatingSystemFamily, storageProfileId: String, updatedAt: Date? = nil, updatedBy: String? = nil) {
            self.createdAt = createdAt
            self.createdBy = createdBy
            self.displayName = displayName
            self.fileSystemLocations = fileSystemLocations
            self.osFamily = osFamily
            self.storageProfileId = storageProfileId
            self.updatedAt = updatedAt
            self.updatedBy = updatedBy
        }

        private enum CodingKeys: String, CodingKey {
            case createdAt = "createdAt"
            case createdBy = "createdBy"
            case displayName = "displayName"
            case fileSystemLocations = "fileSystemLocations"
            case osFamily = "osFamily"
            case storageProfileId = "storageProfileId"
            case updatedAt = "updatedAt"
            case updatedBy = "updatedBy"
        }
    }

    public struct GetTaskRequest: AWSEncodableShape {
        /// The farm ID of the farm connected to the task.
        public let farmId: String
        /// The job ID of the job connected to the task.
        public let jobId: String
        /// The queue ID for the queue connected to the task.
        public let queueId: String
        /// The step ID for the step connected to the task.
        public let stepId: String
        /// The task ID.
        public let taskId: String

        @inlinable
        public init(farmId: String, jobId: String, queueId: String, stepId: String, taskId: String) {
            self.farmId = farmId
            self.jobId = jobId
            self.queueId = queueId
            self.stepId = stepId
            self.taskId = taskId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.farmId, key: "farmId")
            request.encodePath(self.jobId, key: "jobId")
            request.encodePath(self.queueId, key: "queueId")
            request.encodePath(self.stepId, key: "stepId")
            request.encodePath(self.taskId, key: "taskId")
        }

        public func validate(name: String) throws {
            try self.validate(self.farmId, name: "farmId", parent: name, pattern: "^farm-[0-9a-f]{32}$")
            try self.validate(self.jobId, name: "jobId", parent: name, pattern: "^job-[0-9a-f]{32}$")
            try self.validate(self.queueId, name: "queueId", parent: name, pattern: "^queue-[0-9a-f]{32}$")
            try self.validate(self.stepId, name: "stepId", parent: name, pattern: "^step-[0-9a-f]{32}$")
            try self.validate(self.taskId, name: "taskId", parent: name, pattern: "^task-[0-9a-f]{32}-(0|([1-9][0-9]{0,9}))$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetTaskResponse: AWSDecodableShape {
        /// The date and time the resource was created.
        @CustomCoding<ISO8601DateCoder>
        public var createdAt: Date
        /// The user or system that created this resource.
        public let createdBy: String
        /// The date and time the resource ended running.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var endedAt: Date?
        /// The number of times that the task failed and was retried.
        public let failureRetryCount: Int?
        /// The latest session ID for the task.
        public let latestSessionActionId: String?
        /// The parameters for the task.
        public let parameters: [String: TaskParameterValue]?
        /// The run status for the task.
        public let runStatus: TaskRunStatus
        /// The date and time the resource started running.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var startedAt: Date?
        /// The run status with which to start the task.
        public let targetRunStatus: TaskTargetRunStatus?
        /// The task ID.
        public let taskId: String
        /// The date and time the resource was updated.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var updatedAt: Date?
        /// The user or system that updated this resource.
        public let updatedBy: String?

        @inlinable
        public init(createdAt: Date, createdBy: String, endedAt: Date? = nil, failureRetryCount: Int? = nil, latestSessionActionId: String? = nil, parameters: [String: TaskParameterValue]? = nil, runStatus: TaskRunStatus, startedAt: Date? = nil, targetRunStatus: TaskTargetRunStatus? = nil, taskId: String, updatedAt: Date? = nil, updatedBy: String? = nil) {
            self.createdAt = createdAt
            self.createdBy = createdBy
            self.endedAt = endedAt
            self.failureRetryCount = failureRetryCount
            self.latestSessionActionId = latestSessionActionId
            self.parameters = parameters
            self.runStatus = runStatus
            self.startedAt = startedAt
            self.targetRunStatus = targetRunStatus
            self.taskId = taskId
            self.updatedAt = updatedAt
            self.updatedBy = updatedBy
        }

        private enum CodingKeys: String, CodingKey {
            case createdAt = "createdAt"
            case createdBy = "createdBy"
            case endedAt = "endedAt"
            case failureRetryCount = "failureRetryCount"
            case latestSessionActionId = "latestSessionActionId"
            case parameters = "parameters"
            case runStatus = "runStatus"
            case startedAt = "startedAt"
            case targetRunStatus = "targetRunStatus"
            case taskId = "taskId"
            case updatedAt = "updatedAt"
            case updatedBy = "updatedBy"
        }
    }

    public struct GetWorkerRequest: AWSEncodableShape {
        /// The farm ID for the worker.
        public let farmId: String
        /// The fleet ID of the worker.
        public let fleetId: String
        /// The worker ID.
        public let workerId: String

        @inlinable
        public init(farmId: String, fleetId: String, workerId: String) {
            self.farmId = farmId
            self.fleetId = fleetId
            self.workerId = workerId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.farmId, key: "farmId")
            request.encodePath(self.fleetId, key: "fleetId")
            request.encodePath(self.workerId, key: "workerId")
        }

        public func validate(name: String) throws {
            try self.validate(self.farmId, name: "farmId", parent: name, pattern: "^farm-[0-9a-f]{32}$")
            try self.validate(self.fleetId, name: "fleetId", parent: name, pattern: "^fleet-[0-9a-f]{32}$")
            try self.validate(self.workerId, name: "workerId", parent: name, pattern: "^worker-[0-9a-f]{32}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetWorkerResponse: AWSDecodableShape {
        /// The date and time the resource was created.
        @CustomCoding<ISO8601DateCoder>
        public var createdAt: Date
        /// The user or system that created this resource.
        public let createdBy: String
        /// The farm ID.
        public let farmId: String
        /// The fleet ID.
        public let fleetId: String
        /// The host properties for the worker.
        public let hostProperties: HostPropertiesResponse?
        /// The logs for the associated worker.
        public let log: LogConfiguration?
        /// The status of the worker.
        public let status: WorkerStatus
        /// The date and time the resource was updated.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var updatedAt: Date?
        /// The user or system that updated this resource.
        public let updatedBy: String?
        /// The worker ID.
        public let workerId: String

        @inlinable
        public init(createdAt: Date, createdBy: String, farmId: String, fleetId: String, hostProperties: HostPropertiesResponse? = nil, log: LogConfiguration? = nil, status: WorkerStatus, updatedAt: Date? = nil, updatedBy: String? = nil, workerId: String) {
            self.createdAt = createdAt
            self.createdBy = createdBy
            self.farmId = farmId
            self.fleetId = fleetId
            self.hostProperties = hostProperties
            self.log = log
            self.status = status
            self.updatedAt = updatedAt
            self.updatedBy = updatedBy
            self.workerId = workerId
        }

        private enum CodingKeys: String, CodingKey {
            case createdAt = "createdAt"
            case createdBy = "createdBy"
            case farmId = "farmId"
            case fleetId = "fleetId"
            case hostProperties = "hostProperties"
            case log = "log"
            case status = "status"
            case updatedAt = "updatedAt"
            case updatedBy = "updatedBy"
            case workerId = "workerId"
        }
    }

    public struct HostPropertiesRequest: AWSEncodableShape {
        /// The host name.
        public let hostName: String?
        /// The IP address of the host.
        public let ipAddresses: IpAddresses?

        @inlinable
        public init(hostName: String? = nil, ipAddresses: IpAddresses? = nil) {
            self.hostName = hostName
            self.ipAddresses = ipAddresses
        }

        public func validate(name: String) throws {
            try self.validate(self.hostName, name: "hostName", parent: name, pattern: "^[a-zA-Z0-9_\\.\\-]{0,255}$")
            try self.ipAddresses?.validate(name: "\(name).ipAddresses")
        }

        private enum CodingKeys: String, CodingKey {
            case hostName = "hostName"
            case ipAddresses = "ipAddresses"
        }
    }

    public struct HostPropertiesResponse: AWSDecodableShape {
        /// The ARN of the host EC2 instance.
        public let ec2InstanceArn: String?
        /// The instance type of the host EC2 instance.
        public let ec2InstanceType: String?
        /// The host name.
        public let hostName: String?
        /// The IP address of the host.
        public let ipAddresses: IpAddresses?

        @inlinable
        public init(ec2InstanceArn: String? = nil, ec2InstanceType: String? = nil, hostName: String? = nil, ipAddresses: IpAddresses? = nil) {
            self.ec2InstanceArn = ec2InstanceArn
            self.ec2InstanceType = ec2InstanceType
            self.hostName = hostName
            self.ipAddresses = ipAddresses
        }

        private enum CodingKeys: String, CodingKey {
            case ec2InstanceArn = "ec2InstanceArn"
            case ec2InstanceType = "ec2InstanceType"
            case hostName = "hostName"
            case ipAddresses = "ipAddresses"
        }
    }

    public struct InternalServerErrorException: AWSErrorShape {
        public let message: String
        /// The number of seconds a client should wait before retrying the request.
        public let retryAfterSeconds: Int?

        @inlinable
        public init(message: String, retryAfterSeconds: Int? = nil) {
            self.message = message
            self.retryAfterSeconds = retryAfterSeconds
        }

        public init(from decoder: Decoder) throws {
            let response = decoder.userInfo[.awsResponse]! as! ResponseDecodingContainer
            let container = try decoder.container(keyedBy: CodingKeys.self)
            self.message = try container.decode(String.self, forKey: .message)
            self.retryAfterSeconds = try response.decodeHeaderIfPresent(Int.self, key: "Retry-After")
        }

        private enum CodingKeys: String, CodingKey {
            case message = "message"
        }
    }

    public struct IpAddresses: AWSEncodableShape & AWSDecodableShape {
        /// The IpV4 address of the network.
        public let ipV4Addresses: [String]?
        /// The IpV6 address for the network and node component.
        public let ipV6Addresses: [String]?

        @inlinable
        public init(ipV4Addresses: [String]? = nil, ipV6Addresses: [String]? = nil) {
            self.ipV4Addresses = ipV4Addresses
            self.ipV6Addresses = ipV6Addresses
        }

        public func validate(name: String) throws {
            try self.ipV4Addresses?.forEach {
                try validate($0, name: "ipV4Addresses[]", parent: name, pattern: "^(?:[0-9]{1,3}\\.){3}[0-9]{1,3}$")
            }
            try self.ipV6Addresses?.forEach {
                try validate($0, name: "ipV6Addresses[]", parent: name, pattern: "^(?:[A-F0-9]{1,4}:){7}[A-F0-9]{1,4}$")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case ipV4Addresses = "ipV4Addresses"
            case ipV6Addresses = "ipV6Addresses"
        }
    }

    public struct JobAttachmentDetailsEntity: AWSDecodableShape {
        /// The job attachments.
        public let attachments: Attachments
        /// The job ID.
        public let jobId: String

        @inlinable
        public init(attachments: Attachments, jobId: String) {
            self.attachments = attachments
            self.jobId = jobId
        }

        private enum CodingKeys: String, CodingKey {
            case attachments = "attachments"
            case jobId = "jobId"
        }
    }

    public struct JobAttachmentDetailsError: AWSDecodableShape {
        /// The error code.
        public let code: JobEntityErrorCode
        /// The job ID.
        public let jobId: String
        /// The error message detailing the error's cause.
        public let message: String

        @inlinable
        public init(code: JobEntityErrorCode, jobId: String, message: String) {
            self.code = code
            self.jobId = jobId
            self.message = message
        }

        private enum CodingKeys: String, CodingKey {
            case code = "code"
            case jobId = "jobId"
            case message = "message"
        }
    }

    public struct JobAttachmentDetailsIdentifiers: AWSEncodableShape {
        /// The job ID.
        public let jobId: String

        @inlinable
        public init(jobId: String) {
            self.jobId = jobId
        }

        public func validate(name: String) throws {
            try self.validate(self.jobId, name: "jobId", parent: name, pattern: "^job-[0-9a-f]{32}$")
        }

        private enum CodingKeys: String, CodingKey {
            case jobId = "jobId"
        }
    }

    public struct JobAttachmentSettings: AWSEncodableShape & AWSDecodableShape {
        /// The root prefix.
        public let rootPrefix: String
        /// The Amazon S3 bucket name.
        public let s3BucketName: String

        @inlinable
        public init(rootPrefix: String, s3BucketName: String) {
            self.rootPrefix = rootPrefix
            self.s3BucketName = s3BucketName
        }

        public func validate(name: String) throws {
            try self.validate(self.rootPrefix, name: "rootPrefix", parent: name, max: 63)
            try self.validate(self.rootPrefix, name: "rootPrefix", parent: name, min: 1)
            try self.validate(self.rootPrefix, name: "rootPrefix", parent: name, pattern: "^[a-zA-Z0-9-_/]+$")
            try self.validate(self.s3BucketName, name: "s3BucketName", parent: name, max: 255)
            try self.validate(self.s3BucketName, name: "s3BucketName", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case rootPrefix = "rootPrefix"
            case s3BucketName = "s3BucketName"
        }
    }

    public struct JobDetailsEntity: AWSDecodableShape {
        /// The job attachment settings.
        public let jobAttachmentSettings: JobAttachmentSettings?
        /// The job ID.
        public let jobId: String
        /// The user name and group that the job uses when run.
        public let jobRunAsUser: JobRunAsUser?
        /// The log group name.
        public let logGroupName: String
        /// The parameters.
        public let parameters: [String: JobParameter]?
        /// The path mapping rules.
        public let pathMappingRules: [PathMappingRule]?
        /// The queue role ARN.
        public let queueRoleArn: String?
        /// The schema version.
        public let schemaVersion: String

        @inlinable
        public init(jobAttachmentSettings: JobAttachmentSettings? = nil, jobId: String, jobRunAsUser: JobRunAsUser? = nil, logGroupName: String, parameters: [String: JobParameter]? = nil, pathMappingRules: [PathMappingRule]? = nil, queueRoleArn: String? = nil, schemaVersion: String) {
            self.jobAttachmentSettings = jobAttachmentSettings
            self.jobId = jobId
            self.jobRunAsUser = jobRunAsUser
            self.logGroupName = logGroupName
            self.parameters = parameters
            self.pathMappingRules = pathMappingRules
            self.queueRoleArn = queueRoleArn
            self.schemaVersion = schemaVersion
        }

        private enum CodingKeys: String, CodingKey {
            case jobAttachmentSettings = "jobAttachmentSettings"
            case jobId = "jobId"
            case jobRunAsUser = "jobRunAsUser"
            case logGroupName = "logGroupName"
            case parameters = "parameters"
            case pathMappingRules = "pathMappingRules"
            case queueRoleArn = "queueRoleArn"
            case schemaVersion = "schemaVersion"
        }
    }

    public struct JobDetailsError: AWSDecodableShape {
        /// The error code.
        public let code: JobEntityErrorCode
        /// The job ID.
        public let jobId: String
        /// The error message detailing the error's cause.
        public let message: String

        @inlinable
        public init(code: JobEntityErrorCode, jobId: String, message: String) {
            self.code = code
            self.jobId = jobId
            self.message = message
        }

        private enum CodingKeys: String, CodingKey {
            case code = "code"
            case jobId = "jobId"
            case message = "message"
        }
    }

    public struct JobDetailsIdentifiers: AWSEncodableShape {
        /// The job ID.
        public let jobId: String

        @inlinable
        public init(jobId: String) {
            self.jobId = jobId
        }

        public func validate(name: String) throws {
            try self.validate(self.jobId, name: "jobId", parent: name, pattern: "^job-[0-9a-f]{32}$")
        }

        private enum CodingKeys: String, CodingKey {
            case jobId = "jobId"
        }
    }

    public struct JobMember: AWSDecodableShape {
        /// The farm ID.
        public let farmId: String
        /// The identity store ID.
        public let identityStoreId: String
        /// The job ID.
        public let jobId: String
        /// The job member's membership level.
        public let membershipLevel: MembershipLevel
        /// The principal ID of the job member.
        public let principalId: String
        /// The principal type of the job member.
        public let principalType: DeadlinePrincipalType
        /// The queue ID.
        public let queueId: String

        @inlinable
        public init(farmId: String, identityStoreId: String, jobId: String, membershipLevel: MembershipLevel, principalId: String, principalType: DeadlinePrincipalType, queueId: String) {
            self.farmId = farmId
            self.identityStoreId = identityStoreId
            self.jobId = jobId
            self.membershipLevel = membershipLevel
            self.principalId = principalId
            self.principalType = principalType
            self.queueId = queueId
        }

        private enum CodingKeys: String, CodingKey {
            case farmId = "farmId"
            case identityStoreId = "identityStoreId"
            case jobId = "jobId"
            case membershipLevel = "membershipLevel"
            case principalId = "principalId"
            case principalType = "principalType"
            case queueId = "queueId"
        }
    }

    public struct JobRunAsUser: AWSEncodableShape & AWSDecodableShape {
        /// The user and group that the jobs in the queue run as.
        public let posix: PosixUser?
        /// Specifies whether the job should run using the queue's system user or if the job should run using the worker agent system user.
        public let runAs: RunAs
        /// Identifies a Microsoft Windows user.
        public let windows: WindowsUser?

        @inlinable
        public init(posix: PosixUser? = nil, runAs: RunAs, windows: WindowsUser? = nil) {
            self.posix = posix
            self.runAs = runAs
            self.windows = windows
        }

        private enum CodingKeys: String, CodingKey {
            case posix = "posix"
            case runAs = "runAs"
            case windows = "windows"
        }
    }

    public struct JobSearchSummary: AWSDecodableShape {
        /// The date and time the resource was created.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var createdAt: Date?
        /// The user or system that created this resource.
        public let createdBy: String?
        /// The date and time the resource ended running.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var endedAt: Date?
        /// The job ID.
        public let jobId: String?
        /// The job parameters.
        public let jobParameters: [String: JobParameter]?
        /// The life cycle status.
        public let lifecycleStatus: JobLifecycleStatus?
        /// The life cycle status message.
        public let lifecycleStatusMessage: String?
        /// The number of task failures before the job stops running and is marked as FAILED.
        public let maxFailedTasksCount: Int?
        /// The maximum number of retries for a job.
        public let maxRetriesPerTask: Int?
        /// The maximum number of worker hosts that can concurrently process a job. When the maxWorkerCount is reached, no more workers will be assigned to process the job, even if the fleets assigned to the job's queue has available workers. You can't set the maxWorkerCount to 0. If you set it to -1, there is no maximum number of workers. If you don't specify the maxWorkerCount, the default is -1.
        public let maxWorkerCount: Int?
        /// The job name.
        public let name: String?
        /// The job priority.
        public let priority: Int?
        /// The queue ID.
        public let queueId: String?
        /// The job ID for the source job.
        public let sourceJobId: String?
        /// The date and time the resource started running.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var startedAt: Date?
        /// The task status to start with on the job.
        public let targetTaskRunStatus: JobTargetTaskRunStatus?
        /// The task run status for the job.    PENDINGpending and waiting for resources.    READYready to be processed.    ASSIGNEDassigned and will run next on a worker.    SCHEDULEDscheduled to be run on a worker.    INTERRUPTINGbeing interrupted.    RUNNINGrunning on a worker.    SUSPENDEDthe task is suspended.    CANCELEDthe task has been canceled.    FAILEDthe task has failed.    SUCCEEDEDthe task has succeeded.
        public let taskRunStatus: TaskRunStatus?
        /// The number of tasks running on the job.
        public let taskRunStatusCounts: [TaskRunStatus: Int]?

        @inlinable
        public init(createdAt: Date? = nil, createdBy: String? = nil, endedAt: Date? = nil, jobId: String? = nil, jobParameters: [String: JobParameter]? = nil, lifecycleStatus: JobLifecycleStatus? = nil, lifecycleStatusMessage: String? = nil, maxFailedTasksCount: Int? = nil, maxRetriesPerTask: Int? = nil, maxWorkerCount: Int? = nil, name: String? = nil, priority: Int? = nil, queueId: String? = nil, sourceJobId: String? = nil, startedAt: Date? = nil, targetTaskRunStatus: JobTargetTaskRunStatus? = nil, taskRunStatus: TaskRunStatus? = nil, taskRunStatusCounts: [TaskRunStatus: Int]? = nil) {
            self.createdAt = createdAt
            self.createdBy = createdBy
            self.endedAt = endedAt
            self.jobId = jobId
            self.jobParameters = jobParameters
            self.lifecycleStatus = lifecycleStatus
            self.lifecycleStatusMessage = lifecycleStatusMessage
            self.maxFailedTasksCount = maxFailedTasksCount
            self.maxRetriesPerTask = maxRetriesPerTask
            self.maxWorkerCount = maxWorkerCount
            self.name = name
            self.priority = priority
            self.queueId = queueId
            self.sourceJobId = sourceJobId
            self.startedAt = startedAt
            self.targetTaskRunStatus = targetTaskRunStatus
            self.taskRunStatus = taskRunStatus
            self.taskRunStatusCounts = taskRunStatusCounts
        }

        private enum CodingKeys: String, CodingKey {
            case createdAt = "createdAt"
            case createdBy = "createdBy"
            case endedAt = "endedAt"
            case jobId = "jobId"
            case jobParameters = "jobParameters"
            case lifecycleStatus = "lifecycleStatus"
            case lifecycleStatusMessage = "lifecycleStatusMessage"
            case maxFailedTasksCount = "maxFailedTasksCount"
            case maxRetriesPerTask = "maxRetriesPerTask"
            case maxWorkerCount = "maxWorkerCount"
            case name = "name"
            case priority = "priority"
            case queueId = "queueId"
            case sourceJobId = "sourceJobId"
            case startedAt = "startedAt"
            case targetTaskRunStatus = "targetTaskRunStatus"
            case taskRunStatus = "taskRunStatus"
            case taskRunStatusCounts = "taskRunStatusCounts"
        }
    }

    public struct JobSummary: AWSDecodableShape {
        /// The date and time the resource was created.
        @CustomCoding<ISO8601DateCoder>
        public var createdAt: Date
        /// The user or system that created this resource.
        public let createdBy: String
        /// The date and time the resource ended running.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var endedAt: Date?
        /// The job ID.
        public let jobId: String
        /// The life cycle status.
        public let lifecycleStatus: JobLifecycleStatus
        /// The life cycle status message.
        public let lifecycleStatusMessage: String
        /// The number of task failures before the job stops running and is marked as FAILED.
        public let maxFailedTasksCount: Int?
        /// The maximum number of retries for a job.
        public let maxRetriesPerTask: Int?
        /// The maximum number of worker hosts that can concurrently process a job. When the maxWorkerCount is reached, no more workers will be assigned to process the job, even if the fleets assigned to the job's queue has available workers. You can't set the maxWorkerCount to 0. If you set it to -1, there is no maximum number of workers. If you don't specify the maxWorkerCount, the default is -1.
        public let maxWorkerCount: Int?
        /// The job name.
        public let name: String
        /// The job priority.
        public let priority: Int
        /// The job ID for the source job.
        public let sourceJobId: String?
        /// The date and time the resource started running.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var startedAt: Date?
        /// The task status to start with on the job.
        public let targetTaskRunStatus: JobTargetTaskRunStatus?
        /// The task run status for the job.    PENDINGpending and waiting for resources.    READYready to be processed.    ASSIGNEDassigned and will run next on a worker.    SCHEDULEDscheduled to be run on a worker.    INTERRUPTINGbeing interrupted.    RUNNINGrunning on a worker.    SUSPENDEDthe task is suspended.    CANCELEDthe task has been canceled.    FAILEDthe task has failed.    SUCCEEDEDthe task has succeeded.
        public let taskRunStatus: TaskRunStatus?
        /// The number of tasks running on the job.
        public let taskRunStatusCounts: [TaskRunStatus: Int]?
        /// The date and time the resource was updated.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var updatedAt: Date?
        /// The user or system that updated this resource.
        public let updatedBy: String?

        @inlinable
        public init(createdAt: Date, createdBy: String, endedAt: Date? = nil, jobId: String, lifecycleStatus: JobLifecycleStatus, lifecycleStatusMessage: String, maxFailedTasksCount: Int? = nil, maxRetriesPerTask: Int? = nil, maxWorkerCount: Int? = nil, name: String, priority: Int, sourceJobId: String? = nil, startedAt: Date? = nil, targetTaskRunStatus: JobTargetTaskRunStatus? = nil, taskRunStatus: TaskRunStatus? = nil, taskRunStatusCounts: [TaskRunStatus: Int]? = nil, updatedAt: Date? = nil, updatedBy: String? = nil) {
            self.createdAt = createdAt
            self.createdBy = createdBy
            self.endedAt = endedAt
            self.jobId = jobId
            self.lifecycleStatus = lifecycleStatus
            self.lifecycleStatusMessage = lifecycleStatusMessage
            self.maxFailedTasksCount = maxFailedTasksCount
            self.maxRetriesPerTask = maxRetriesPerTask
            self.maxWorkerCount = maxWorkerCount
            self.name = name
            self.priority = priority
            self.sourceJobId = sourceJobId
            self.startedAt = startedAt
            self.targetTaskRunStatus = targetTaskRunStatus
            self.taskRunStatus = taskRunStatus
            self.taskRunStatusCounts = taskRunStatusCounts
            self.updatedAt = updatedAt
            self.updatedBy = updatedBy
        }

        private enum CodingKeys: String, CodingKey {
            case createdAt = "createdAt"
            case createdBy = "createdBy"
            case endedAt = "endedAt"
            case jobId = "jobId"
            case lifecycleStatus = "lifecycleStatus"
            case lifecycleStatusMessage = "lifecycleStatusMessage"
            case maxFailedTasksCount = "maxFailedTasksCount"
            case maxRetriesPerTask = "maxRetriesPerTask"
            case maxWorkerCount = "maxWorkerCount"
            case name = "name"
            case priority = "priority"
            case sourceJobId = "sourceJobId"
            case startedAt = "startedAt"
            case targetTaskRunStatus = "targetTaskRunStatus"
            case taskRunStatus = "taskRunStatus"
            case taskRunStatusCounts = "taskRunStatusCounts"
            case updatedAt = "updatedAt"
            case updatedBy = "updatedBy"
        }
    }

    public struct LicenseEndpointSummary: AWSDecodableShape {
        /// The license endpoint ID.
        public let licenseEndpointId: String?
        /// The status of the license endpoint.
        public let status: LicenseEndpointStatus?
        /// The status message of the license endpoint.
        public let statusMessage: String?
        /// The VCP(virtual private cloud) ID associated with the license endpoint.
        public let vpcId: String?

        @inlinable
        public init(licenseEndpointId: String? = nil, status: LicenseEndpointStatus? = nil, statusMessage: String? = nil, vpcId: String? = nil) {
            self.licenseEndpointId = licenseEndpointId
            self.status = status
            self.statusMessage = statusMessage
            self.vpcId = vpcId
        }

        private enum CodingKeys: String, CodingKey {
            case licenseEndpointId = "licenseEndpointId"
            case status = "status"
            case statusMessage = "statusMessage"
            case vpcId = "vpcId"
        }
    }

    public struct LimitSummary: AWSDecodableShape {
        /// The value that you specify as the name in the amounts field of the hostRequirements in a step of a job template to declare the limit requirement.
        public let amountRequirementName: String
        /// The Unix timestamp of the date and time that the limit was created.
        @CustomCoding<ISO8601DateCoder>
        public var createdAt: Date
        /// The user identifier of the person that created the limit.
        public let createdBy: String
        /// The number of resources from the limit that are being used by jobs. The result is delayed and may not be the count at the time that you called the operation.
        public let currentCount: Int
        /// The name of the limit used in lists to identify the limit.  This field can store any content. Escape or encode this content before displaying it on a webpage or any other system that might interpret the content of this field.
        public let displayName: String
        /// The unique identifier of the farm that contains the limit.
        public let farmId: String
        /// The unique identifier of the limit.
        public let limitId: String
        /// The maximum number of resources constrained by this limit. When all of the resources are in use, steps that require the limit won't be scheduled until the resource is available. The maxValue must not be 0. If the value is -1, there is no restriction on the number of resources that can be acquired for this limit.
        public let maxCount: Int
        /// The Unix timestamp of the date and time that the limit was last updated.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var updatedAt: Date?
        /// The user identifier of the person that last updated the limit.
        public let updatedBy: String?

        @inlinable
        public init(amountRequirementName: String, createdAt: Date, createdBy: String, currentCount: Int, displayName: String, farmId: String, limitId: String, maxCount: Int, updatedAt: Date? = nil, updatedBy: String? = nil) {
            self.amountRequirementName = amountRequirementName
            self.createdAt = createdAt
            self.createdBy = createdBy
            self.currentCount = currentCount
            self.displayName = displayName
            self.farmId = farmId
            self.limitId = limitId
            self.maxCount = maxCount
            self.updatedAt = updatedAt
            self.updatedBy = updatedBy
        }

        private enum CodingKeys: String, CodingKey {
            case amountRequirementName = "amountRequirementName"
            case createdAt = "createdAt"
            case createdBy = "createdBy"
            case currentCount = "currentCount"
            case displayName = "displayName"
            case farmId = "farmId"
            case limitId = "limitId"
            case maxCount = "maxCount"
            case updatedAt = "updatedAt"
            case updatedBy = "updatedBy"
        }
    }

    public struct ListAvailableMeteredProductsRequest: AWSEncodableShape {
        /// The maximum number of results to return. Use this parameter with NextToken to get results as a set of sequential pages.
        public let maxResults: Int?
        /// The token for the next set of results, or null to start from the beginning.
        public let nextToken: String?

        @inlinable
        public init(maxResults: Int? = nil, nextToken: String? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListAvailableMeteredProductsResponse: AWSDecodableShape {
        /// The metered products.
        public let meteredProducts: [MeteredProductSummary]
        /// If Deadline Cloud returns nextToken, then there are more results available. The value of nextToken is a unique pagination token for each page. To retrieve the next page, call the operation again using the returned token. Keep all other arguments unchanged. If no results remain, then nextToken is set to null. Each pagination token expires after 24 hours. If you provide a token that isn't valid, then you receive an HTTP 400 ValidationException error.
        public let nextToken: String?

        @inlinable
        public init(meteredProducts: [MeteredProductSummary], nextToken: String? = nil) {
            self.meteredProducts = meteredProducts
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case meteredProducts = "meteredProducts"
            case nextToken = "nextToken"
        }
    }

    public struct ListBudgetsRequest: AWSEncodableShape {
        /// The farm ID associated with the budgets.
        public let farmId: String
        /// The maximum number of results to return. Use this parameter with NextToken to get results as a set of sequential pages.
        public let maxResults: Int?
        /// The token for the next set of results, or null to start from the beginning.
        public let nextToken: String?
        /// The status to list for the budgets.
        public let status: BudgetStatus?

        @inlinable
        public init(farmId: String, maxResults: Int? = nil, nextToken: String? = nil, status: BudgetStatus? = nil) {
            self.farmId = farmId
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.status = status
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.farmId, key: "farmId")
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
            request.encodeQuery(self.status, key: "status")
        }

        public func validate(name: String) throws {
            try self.validate(self.farmId, name: "farmId", parent: name, pattern: "^farm-[0-9a-f]{32}$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListBudgetsResponse: AWSDecodableShape {
        /// The budgets to include on the list.
        public let budgets: [BudgetSummary]
        /// If Deadline Cloud returns nextToken, then there are more results available. The value of nextToken is a unique pagination token for each page. To retrieve the next page, call the operation again using the returned token. Keep all other arguments unchanged. If no results remain, then nextToken is set to null. Each pagination token expires after 24 hours. If you provide a token that isn't valid, then you receive an HTTP 400 ValidationException error.
        public let nextToken: String?

        @inlinable
        public init(budgets: [BudgetSummary], nextToken: String? = nil) {
            self.budgets = budgets
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case budgets = "budgets"
            case nextToken = "nextToken"
        }
    }

    public struct ListFarmMembersRequest: AWSEncodableShape {
        /// The farm ID.
        public let farmId: String
        /// The maximum number of results to return. Use this parameter with NextToken to get results as a set of sequential pages.
        public let maxResults: Int?
        /// The token for the next set of results, or null to start from the beginning.
        public let nextToken: String?

        @inlinable
        public init(farmId: String, maxResults: Int? = nil, nextToken: String? = nil) {
            self.farmId = farmId
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.farmId, key: "farmId")
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
        }

        public func validate(name: String) throws {
            try self.validate(self.farmId, name: "farmId", parent: name, pattern: "^farm-[0-9a-f]{32}$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListFarmMembersResponse: AWSDecodableShape {
        /// The members on the list.
        public let members: [FarmMember]
        /// If Deadline Cloud returns nextToken, then there are more results available. The value of nextToken is a unique pagination token for each page. To retrieve the next page, call the operation again using the returned token. Keep all other arguments unchanged. If no results remain, then nextToken is set to null. Each pagination token expires after 24 hours. If you provide a token that isn't valid, then you receive an HTTP 400 ValidationException error.
        public let nextToken: String?

        @inlinable
        public init(members: [FarmMember], nextToken: String? = nil) {
            self.members = members
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case members = "members"
            case nextToken = "nextToken"
        }
    }

    public struct ListFarmsRequest: AWSEncodableShape {
        /// The maximum number of results to return. Use this parameter with NextToken to get results as a set of sequential pages.
        public let maxResults: Int?
        /// The token for the next set of results, or null to start from the beginning.
        public let nextToken: String?
        /// The principal ID of the member to list on the farm.
        public let principalId: String?

        @inlinable
        public init(maxResults: Int? = nil, nextToken: String? = nil, principalId: String? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.principalId = principalId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
            request.encodeQuery(self.principalId, key: "principalId")
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.principalId, name: "principalId", parent: name, max: 47)
            try self.validate(self.principalId, name: "principalId", parent: name, min: 1)
            try self.validate(self.principalId, name: "principalId", parent: name, pattern: "^([0-9a-f]{10}-|)[A-Fa-f0-9]{8}-[A-Fa-f0-9]{4}-[A-Fa-f0-9]{4}-[A-Fa-f0-9]{4}-[A-Fa-f0-9]{12}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListFarmsResponse: AWSDecodableShape {
        /// Farms on the list.
        public let farms: [FarmSummary]
        /// If Deadline Cloud returns nextToken, then there are more results available. The value of nextToken is a unique pagination token for each page. To retrieve the next page, call the operation again using the returned token. Keep all other arguments unchanged. If no results remain, then nextToken is set to null. Each pagination token expires after 24 hours. If you provide a token that isn't valid, then you receive an HTTP 400 ValidationException error.
        public let nextToken: String?

        @inlinable
        public init(farms: [FarmSummary], nextToken: String? = nil) {
            self.farms = farms
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case farms = "farms"
            case nextToken = "nextToken"
        }
    }

    public struct ListFleetMembersRequest: AWSEncodableShape {
        /// The farm ID of the fleet.
        public let farmId: String
        /// The fleet ID to include on the list.
        public let fleetId: String
        /// The maximum number of results to return. Use this parameter with NextToken to get results as a set of sequential pages.
        public let maxResults: Int?
        /// The token for the next set of results, or null to start from the beginning.
        public let nextToken: String?

        @inlinable
        public init(farmId: String, fleetId: String, maxResults: Int? = nil, nextToken: String? = nil) {
            self.farmId = farmId
            self.fleetId = fleetId
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.farmId, key: "farmId")
            request.encodePath(self.fleetId, key: "fleetId")
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
        }

        public func validate(name: String) throws {
            try self.validate(self.farmId, name: "farmId", parent: name, pattern: "^farm-[0-9a-f]{32}$")
            try self.validate(self.fleetId, name: "fleetId", parent: name, pattern: "^fleet-[0-9a-f]{32}$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListFleetMembersResponse: AWSDecodableShape {
        /// The members on the list.
        public let members: [FleetMember]
        /// If Deadline Cloud returns nextToken, then there are more results available. The value of nextToken is a unique pagination token for each page. To retrieve the next page, call the operation again using the returned token. Keep all other arguments unchanged. If no results remain, then nextToken is set to null. Each pagination token expires after 24 hours. If you provide a token that isn't valid, then you receive an HTTP 400 ValidationException error.
        public let nextToken: String?

        @inlinable
        public init(members: [FleetMember], nextToken: String? = nil) {
            self.members = members
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case members = "members"
            case nextToken = "nextToken"
        }
    }

    public struct ListFleetsRequest: AWSEncodableShape {
        /// The display names of a list of fleets.  This field can store any content. Escape or encode this content before displaying it on a webpage or any other system that might interpret the content of this field.
        public let displayName: String?
        /// The farm ID of the fleets.
        public let farmId: String
        /// The maximum number of results to return. Use this parameter with NextToken to get results as a set of sequential pages.
        public let maxResults: Int?
        /// The token for the next set of results, or null to start from the beginning.
        public let nextToken: String?
        /// The principal ID of the members to include in the fleet.
        public let principalId: String?
        /// The status of the fleet.
        public let status: FleetStatus?

        @inlinable
        public init(displayName: String? = nil, farmId: String, maxResults: Int? = nil, nextToken: String? = nil, principalId: String? = nil, status: FleetStatus? = nil) {
            self.displayName = displayName
            self.farmId = farmId
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.principalId = principalId
            self.status = status
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.displayName, key: "displayName")
            request.encodePath(self.farmId, key: "farmId")
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
            request.encodeQuery(self.principalId, key: "principalId")
            request.encodeQuery(self.status, key: "status")
        }

        public func validate(name: String) throws {
            try self.validate(self.displayName, name: "displayName", parent: name, max: 100)
            try self.validate(self.displayName, name: "displayName", parent: name, min: 1)
            try self.validate(self.farmId, name: "farmId", parent: name, pattern: "^farm-[0-9a-f]{32}$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.principalId, name: "principalId", parent: name, max: 47)
            try self.validate(self.principalId, name: "principalId", parent: name, min: 1)
            try self.validate(self.principalId, name: "principalId", parent: name, pattern: "^([0-9a-f]{10}-|)[A-Fa-f0-9]{8}-[A-Fa-f0-9]{4}-[A-Fa-f0-9]{4}-[A-Fa-f0-9]{4}-[A-Fa-f0-9]{12}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListFleetsResponse: AWSDecodableShape {
        /// The fleets on the list.
        public let fleets: [FleetSummary]
        /// If Deadline Cloud returns nextToken, then there are more results available. The value of nextToken is a unique pagination token for each page. To retrieve the next page, call the operation again using the returned token. Keep all other arguments unchanged. If no results remain, then nextToken is set to null. Each pagination token expires after 24 hours. If you provide a token that isn't valid, then you receive an HTTP 400 ValidationException error.
        public let nextToken: String?

        @inlinable
        public init(fleets: [FleetSummary], nextToken: String? = nil) {
            self.fleets = fleets
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case fleets = "fleets"
            case nextToken = "nextToken"
        }
    }

    public struct ListJobMembersRequest: AWSEncodableShape {
        /// The farm ID of the job to list.
        public let farmId: String
        /// The job ID to include on the list.
        public let jobId: String
        /// The maximum number of results to return. Use this parameter with NextToken to get results as a set of sequential pages.
        public let maxResults: Int?
        /// The token for the next set of results, or null to start from the beginning.
        public let nextToken: String?
        /// The queue ID to include on the list.
        public let queueId: String

        @inlinable
        public init(farmId: String, jobId: String, maxResults: Int? = nil, nextToken: String? = nil, queueId: String) {
            self.farmId = farmId
            self.jobId = jobId
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.queueId = queueId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.farmId, key: "farmId")
            request.encodePath(self.jobId, key: "jobId")
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
            request.encodePath(self.queueId, key: "queueId")
        }

        public func validate(name: String) throws {
            try self.validate(self.farmId, name: "farmId", parent: name, pattern: "^farm-[0-9a-f]{32}$")
            try self.validate(self.jobId, name: "jobId", parent: name, pattern: "^job-[0-9a-f]{32}$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.queueId, name: "queueId", parent: name, pattern: "^queue-[0-9a-f]{32}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListJobMembersResponse: AWSDecodableShape {
        /// The members on the list.
        public let members: [JobMember]
        /// If Deadline Cloud returns nextToken, then there are more results available. The value of nextToken is a unique pagination token for each page. To retrieve the next page, call the operation again using the returned token. Keep all other arguments unchanged. If no results remain, then nextToken is set to null. Each pagination token expires after 24 hours. If you provide a token that isn't valid, then you receive an HTTP 400 ValidationException error.
        public let nextToken: String?

        @inlinable
        public init(members: [JobMember], nextToken: String? = nil) {
            self.members = members
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case members = "members"
            case nextToken = "nextToken"
        }
    }

    public struct ListJobParameterDefinitionsRequest: AWSEncodableShape {
        /// The farm ID of the job to list.
        public let farmId: String
        /// The job ID to include on the list.
        public let jobId: String
        /// The maximum number of results to return. Use this parameter with NextToken to get results as a set of sequential pages.
        public let maxResults: Int?
        /// The token for the next set of results, or null to start from the beginning.
        public let nextToken: String?
        /// The queue ID to include on the list.
        public let queueId: String

        @inlinable
        public init(farmId: String, jobId: String, maxResults: Int? = nil, nextToken: String? = nil, queueId: String) {
            self.farmId = farmId
            self.jobId = jobId
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.queueId = queueId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.farmId, key: "farmId")
            request.encodePath(self.jobId, key: "jobId")
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
            request.encodePath(self.queueId, key: "queueId")
        }

        public func validate(name: String) throws {
            try self.validate(self.farmId, name: "farmId", parent: name, pattern: "^farm-[0-9a-f]{32}$")
            try self.validate(self.jobId, name: "jobId", parent: name, pattern: "^job-[0-9a-f]{32}$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.queueId, name: "queueId", parent: name, pattern: "^queue-[0-9a-f]{32}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListJobParameterDefinitionsResponse: AWSDecodableShape {
        /// Lists parameter definitions of a job.
        public let jobParameterDefinitions: [AWSDocument]
        /// If Deadline Cloud returns nextToken, then there are more results available. The value of nextToken is a unique pagination token for each page. To retrieve the next page, call the operation again using the returned token. Keep all other arguments unchanged. If no results remain, then nextToken is set to null. Each pagination token expires after 24 hours. If you provide a token that isn't valid, then you receive an HTTP 400 ValidationException error.
        public let nextToken: String?

        @inlinable
        public init(jobParameterDefinitions: [AWSDocument], nextToken: String? = nil) {
            self.jobParameterDefinitions = jobParameterDefinitions
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case jobParameterDefinitions = "jobParameterDefinitions"
            case nextToken = "nextToken"
        }
    }

    public struct ListJobsRequest: AWSEncodableShape {
        /// The farm ID for the jobs.
        public let farmId: String
        /// The maximum number of results to return. Use this parameter with NextToken to get results as a set of sequential pages.
        public let maxResults: Int?
        /// The token for the next set of results, or null to start from the beginning.
        public let nextToken: String?
        /// The principal ID of the members on the jobs.
        public let principalId: String?
        /// The queue ID for the job.
        public let queueId: String

        @inlinable
        public init(farmId: String, maxResults: Int? = nil, nextToken: String? = nil, principalId: String? = nil, queueId: String) {
            self.farmId = farmId
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.principalId = principalId
            self.queueId = queueId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.farmId, key: "farmId")
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
            request.encodeQuery(self.principalId, key: "principalId")
            request.encodePath(self.queueId, key: "queueId")
        }

        public func validate(name: String) throws {
            try self.validate(self.farmId, name: "farmId", parent: name, pattern: "^farm-[0-9a-f]{32}$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.principalId, name: "principalId", parent: name, max: 47)
            try self.validate(self.principalId, name: "principalId", parent: name, min: 1)
            try self.validate(self.principalId, name: "principalId", parent: name, pattern: "^([0-9a-f]{10}-|)[A-Fa-f0-9]{8}-[A-Fa-f0-9]{4}-[A-Fa-f0-9]{4}-[A-Fa-f0-9]{4}-[A-Fa-f0-9]{12}$")
            try self.validate(self.queueId, name: "queueId", parent: name, pattern: "^queue-[0-9a-f]{32}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListJobsResponse: AWSDecodableShape {
        /// The jobs on the list.
        public let jobs: [JobSummary]
        /// If Deadline Cloud returns nextToken, then there are more results available. The value of nextToken is a unique pagination token for each page. To retrieve the next page, call the operation again using the returned token. Keep all other arguments unchanged. If no results remain, then nextToken is set to null. Each pagination token expires after 24 hours. If you provide a token that isn't valid, then you receive an HTTP 400 ValidationException error.
        public let nextToken: String?

        @inlinable
        public init(jobs: [JobSummary], nextToken: String? = nil) {
            self.jobs = jobs
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case jobs = "jobs"
            case nextToken = "nextToken"
        }
    }

    public struct ListLicenseEndpointsRequest: AWSEncodableShape {
        /// The maximum number of results to return. Use this parameter with NextToken to get results as a set of sequential pages.
        public let maxResults: Int?
        /// The token for the next set of results, or null to start from the beginning.
        public let nextToken: String?

        @inlinable
        public init(maxResults: Int? = nil, nextToken: String? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListLicenseEndpointsResponse: AWSDecodableShape {
        /// The license endpoints.
        public let licenseEndpoints: [LicenseEndpointSummary]
        /// If Deadline Cloud returns nextToken, then there are more results available. The value of nextToken is a unique pagination token for each page. To retrieve the next page, call the operation again using the returned token. Keep all other arguments unchanged. If no results remain, then nextToken is set to null. Each pagination token expires after 24 hours. If you provide a token that isn't valid, then you receive an HTTP 400 ValidationException error.
        public let nextToken: String?

        @inlinable
        public init(licenseEndpoints: [LicenseEndpointSummary], nextToken: String? = nil) {
            self.licenseEndpoints = licenseEndpoints
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case licenseEndpoints = "licenseEndpoints"
            case nextToken = "nextToken"
        }
    }

    public struct ListLimitsRequest: AWSEncodableShape {
        /// The unique identifier of the farm that contains the limits.
        public let farmId: String
        /// The maximum number of limits to return in each page of results.
        public let maxResults: Int?
        /// The token for the next set of results, or null to start from the beginning.
        public let nextToken: String?

        @inlinable
        public init(farmId: String, maxResults: Int? = nil, nextToken: String? = nil) {
            self.farmId = farmId
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.farmId, key: "farmId")
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
        }

        public func validate(name: String) throws {
            try self.validate(self.farmId, name: "farmId", parent: name, pattern: "^farm-[0-9a-f]{32}$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListLimitsResponse: AWSDecodableShape {
        /// A list of limits that the farm contains.
        public let limits: [LimitSummary]
        /// If Deadline Cloud returns nextToken, then there are more results available. The value of nextToken is a unique pagination token for each page. To retrieve the next page, call the operation again using the returned token. Keep all other arguments unchanged. If no results remain, then nextToken is set to null. Each pagination token expires after 24 hours. If you provide a token that isn't valid, then you receive an HTTP 400 ValidationException error.
        public let nextToken: String?

        @inlinable
        public init(limits: [LimitSummary], nextToken: String? = nil) {
            self.limits = limits
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case limits = "limits"
            case nextToken = "nextToken"
        }
    }

    public struct ListMeteredProductsRequest: AWSEncodableShape {
        /// The license endpoint ID to include on the list of metered products.
        public let licenseEndpointId: String
        /// The maximum number of results to return. Use this parameter with NextToken to get results as a set of sequential pages.
        public let maxResults: Int?
        /// The token for the next set of results, or null to start from the beginning.
        public let nextToken: String?

        @inlinable
        public init(licenseEndpointId: String, maxResults: Int? = nil, nextToken: String? = nil) {
            self.licenseEndpointId = licenseEndpointId
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.licenseEndpointId, key: "licenseEndpointId")
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
        }

        public func validate(name: String) throws {
            try self.validate(self.licenseEndpointId, name: "licenseEndpointId", parent: name, pattern: "^le-[0-9a-f]{32}$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListMeteredProductsResponse: AWSDecodableShape {
        /// The metered products to list.
        public let meteredProducts: [MeteredProductSummary]
        /// If Deadline Cloud returns nextToken, then there are more results available. The value of nextToken is a unique pagination token for each page. To retrieve the next page, call the operation again using the returned token. Keep all other arguments unchanged. If no results remain, then nextToken is set to null. Each pagination token expires after 24 hours. If you provide a token that isn't valid, then you receive an HTTP 400 ValidationException error.
        public let nextToken: String?

        @inlinable
        public init(meteredProducts: [MeteredProductSummary], nextToken: String? = nil) {
            self.meteredProducts = meteredProducts
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case meteredProducts = "meteredProducts"
            case nextToken = "nextToken"
        }
    }

    public struct ListMonitorsRequest: AWSEncodableShape {
        /// The maximum number of results to return. Use this parameter with NextToken to get results as a set of sequential pages.
        public let maxResults: Int?
        /// The token for the next set of results, or null to start from the beginning.
        public let nextToken: String?

        @inlinable
        public init(maxResults: Int? = nil, nextToken: String? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListMonitorsResponse: AWSDecodableShape {
        /// A list of MonitorSummary objects that describe your monitors in the Deadline Cloud.
        public let monitors: [MonitorSummary]
        /// If Deadline Cloud returns nextToken, then there are more results available. The value of nextToken is a unique pagination token for each page. To retrieve the next page, call the operation again using the returned token. Keep all other arguments unchanged. If no results remain, then nextToken is set to null. Each pagination token expires after 24 hours. If you provide a token that isn't valid, then you receive an HTTP 400 ValidationException error.
        public let nextToken: String?

        @inlinable
        public init(monitors: [MonitorSummary], nextToken: String? = nil) {
            self.monitors = monitors
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case monitors = "monitors"
            case nextToken = "nextToken"
        }
    }

    public struct ListQueueEnvironmentsRequest: AWSEncodableShape {
        /// The farm ID for the queue environment list.
        public let farmId: String
        /// The maximum number of results to return. Use this parameter with NextToken to get results as a set of sequential pages.
        public let maxResults: Int?
        /// The token for the next set of results, or null to start from the beginning.
        public let nextToken: String?
        /// The queue ID for the queue environment list.
        public let queueId: String

        @inlinable
        public init(farmId: String, maxResults: Int? = nil, nextToken: String? = nil, queueId: String) {
            self.farmId = farmId
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.queueId = queueId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.farmId, key: "farmId")
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
            request.encodePath(self.queueId, key: "queueId")
        }

        public func validate(name: String) throws {
            try self.validate(self.farmId, name: "farmId", parent: name, pattern: "^farm-[0-9a-f]{32}$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.queueId, name: "queueId", parent: name, pattern: "^queue-[0-9a-f]{32}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListQueueEnvironmentsResponse: AWSDecodableShape {
        /// The environments to include in the queue environments list.
        public let environments: [QueueEnvironmentSummary]
        /// If Deadline Cloud returns nextToken, then there are more results available. The value of nextToken is a unique pagination token for each page. To retrieve the next page, call the operation again using the returned token. Keep all other arguments unchanged. If no results remain, then nextToken is set to null. Each pagination token expires after 24 hours. If you provide a token that isn't valid, then you receive an HTTP 400 ValidationException error.
        public let nextToken: String?

        @inlinable
        public init(environments: [QueueEnvironmentSummary], nextToken: String? = nil) {
            self.environments = environments
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case environments = "environments"
            case nextToken = "nextToken"
        }
    }

    public struct ListQueueFleetAssociationsRequest: AWSEncodableShape {
        /// The farm ID for the queue-fleet association list.
        public let farmId: String
        /// The fleet ID for the queue-fleet association list.
        public let fleetId: String?
        /// The maximum number of results to return. Use this parameter with NextToken to get results as a set of sequential pages.
        public let maxResults: Int?
        /// The token for the next set of results, or null to start from the beginning.
        public let nextToken: String?
        /// The queue ID for the queue-fleet association list.
        public let queueId: String?

        @inlinable
        public init(farmId: String, fleetId: String? = nil, maxResults: Int? = nil, nextToken: String? = nil, queueId: String? = nil) {
            self.farmId = farmId
            self.fleetId = fleetId
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.queueId = queueId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.farmId, key: "farmId")
            request.encodeQuery(self.fleetId, key: "fleetId")
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
            request.encodeQuery(self.queueId, key: "queueId")
        }

        public func validate(name: String) throws {
            try self.validate(self.farmId, name: "farmId", parent: name, pattern: "^farm-[0-9a-f]{32}$")
            try self.validate(self.fleetId, name: "fleetId", parent: name, pattern: "^fleet-[0-9a-f]{32}$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.queueId, name: "queueId", parent: name, pattern: "^queue-[0-9a-f]{32}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListQueueFleetAssociationsResponse: AWSDecodableShape {
        /// If Deadline Cloud returns nextToken, then there are more results available. The value of nextToken is a unique pagination token for each page. To retrieve the next page, call the operation again using the returned token. Keep all other arguments unchanged. If no results remain, then nextToken is set to null. Each pagination token expires after 24 hours. If you provide a token that isn't valid, then you receive an HTTP 400 ValidationException error.
        public let nextToken: String?
        /// The queue-fleet associations on the list.
        public let queueFleetAssociations: [QueueFleetAssociationSummary]

        @inlinable
        public init(nextToken: String? = nil, queueFleetAssociations: [QueueFleetAssociationSummary]) {
            self.nextToken = nextToken
            self.queueFleetAssociations = queueFleetAssociations
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "nextToken"
            case queueFleetAssociations = "queueFleetAssociations"
        }
    }

    public struct ListQueueLimitAssociationsRequest: AWSEncodableShape {
        /// The unique identifier of the farm that contains the limits and associations.
        public let farmId: String
        /// Specifies that the operation should return only the queue limit associations for the specified limit. If you specify both the queueId and the limitId, only the specified limit is returned if it exists.
        public let limitId: String?
        /// The maximum number of associations to return in each page of results.
        public let maxResults: Int?
        /// The token for the next set of results, or null to start from the beginning.
        public let nextToken: String?
        /// Specifies that the operation should return only the queue limit associations for the specified queue. If you specify both the queueId and the limitId, only the specified limit is returned if it exists.
        public let queueId: String?

        @inlinable
        public init(farmId: String, limitId: String? = nil, maxResults: Int? = nil, nextToken: String? = nil, queueId: String? = nil) {
            self.farmId = farmId
            self.limitId = limitId
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.queueId = queueId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.farmId, key: "farmId")
            request.encodeQuery(self.limitId, key: "limitId")
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
            request.encodeQuery(self.queueId, key: "queueId")
        }

        public func validate(name: String) throws {
            try self.validate(self.farmId, name: "farmId", parent: name, pattern: "^farm-[0-9a-f]{32}$")
            try self.validate(self.limitId, name: "limitId", parent: name, pattern: "^limit-[0-9a-f]{32}$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.queueId, name: "queueId", parent: name, pattern: "^queue-[0-9a-f]{32}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListQueueLimitAssociationsResponse: AWSDecodableShape {
        /// If Deadline Cloud returns nextToken, then there are more results available. The value of nextToken is a unique pagination token for each page. To retrieve the next page, call the operation again using the returned token. Keep all other arguments unchanged. If no results remain, then nextToken is set to null. Each pagination token expires after 24 hours. If you provide a token that isn't valid, then you receive an HTTP 400 ValidationException error.
        public let nextToken: String?
        /// A list of associations between limits and queues in the farm specified in the request.
        public let queueLimitAssociations: [QueueLimitAssociationSummary]

        @inlinable
        public init(nextToken: String? = nil, queueLimitAssociations: [QueueLimitAssociationSummary]) {
            self.nextToken = nextToken
            self.queueLimitAssociations = queueLimitAssociations
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "nextToken"
            case queueLimitAssociations = "queueLimitAssociations"
        }
    }

    public struct ListQueueMembersRequest: AWSEncodableShape {
        /// The farm ID for the queue.
        public let farmId: String
        /// The maximum number of results to return. Use this parameter with NextToken to get results as a set of sequential pages.
        public let maxResults: Int?
        /// The token for the next set of results, or null to start from the beginning.
        public let nextToken: String?
        /// The queue ID to include on the list.
        public let queueId: String

        @inlinable
        public init(farmId: String, maxResults: Int? = nil, nextToken: String? = nil, queueId: String) {
            self.farmId = farmId
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.queueId = queueId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.farmId, key: "farmId")
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
            request.encodePath(self.queueId, key: "queueId")
        }

        public func validate(name: String) throws {
            try self.validate(self.farmId, name: "farmId", parent: name, pattern: "^farm-[0-9a-f]{32}$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.queueId, name: "queueId", parent: name, pattern: "^queue-[0-9a-f]{32}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListQueueMembersResponse: AWSDecodableShape {
        /// The members on the list.
        public let members: [QueueMember]
        /// If Deadline Cloud returns nextToken, then there are more results available. The value of nextToken is a unique pagination token for each page. To retrieve the next page, call the operation again using the returned token. Keep all other arguments unchanged. If no results remain, then nextToken is set to null. Each pagination token expires after 24 hours. If you provide a token that isn't valid, then you receive an HTTP 400 ValidationException error.
        public let nextToken: String?

        @inlinable
        public init(members: [QueueMember], nextToken: String? = nil) {
            self.members = members
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case members = "members"
            case nextToken = "nextToken"
        }
    }

    public struct ListQueuesRequest: AWSEncodableShape {
        /// The farm ID of the queue.
        public let farmId: String
        /// The maximum number of results to return. Use this parameter with NextToken to get results as a set of sequential pages.
        public let maxResults: Int?
        /// The token for the next set of results, or null to start from the beginning.
        public let nextToken: String?
        /// The principal IDs to include in the list of queues.
        public let principalId: String?
        /// The status of the queues listed.    ACTIVEThe queues are active.    SCHEDULINGThe queues are scheduling.    SCHEDULING_BLOCKEDThe queue scheduling is blocked for these queues.
        public let status: QueueStatus?

        @inlinable
        public init(farmId: String, maxResults: Int? = nil, nextToken: String? = nil, principalId: String? = nil, status: QueueStatus? = nil) {
            self.farmId = farmId
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.principalId = principalId
            self.status = status
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.farmId, key: "farmId")
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
            request.encodeQuery(self.principalId, key: "principalId")
            request.encodeQuery(self.status, key: "status")
        }

        public func validate(name: String) throws {
            try self.validate(self.farmId, name: "farmId", parent: name, pattern: "^farm-[0-9a-f]{32}$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.principalId, name: "principalId", parent: name, max: 47)
            try self.validate(self.principalId, name: "principalId", parent: name, min: 1)
            try self.validate(self.principalId, name: "principalId", parent: name, pattern: "^([0-9a-f]{10}-|)[A-Fa-f0-9]{8}-[A-Fa-f0-9]{4}-[A-Fa-f0-9]{4}-[A-Fa-f0-9]{4}-[A-Fa-f0-9]{12}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListQueuesResponse: AWSDecodableShape {
        /// If Deadline Cloud returns nextToken, then there are more results available. The value of nextToken is a unique pagination token for each page. To retrieve the next page, call the operation again using the returned token. Keep all other arguments unchanged. If no results remain, then nextToken is set to null. Each pagination token expires after 24 hours. If you provide a token that isn't valid, then you receive an HTTP 400 ValidationException error.
        public let nextToken: String?
        /// The queues on the list.
        public let queues: [QueueSummary]

        @inlinable
        public init(nextToken: String? = nil, queues: [QueueSummary]) {
            self.nextToken = nextToken
            self.queues = queues
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "nextToken"
            case queues = "queues"
        }
    }

    public struct ListSessionActionsRequest: AWSEncodableShape {
        /// The farm ID for the session actions list.
        public let farmId: String
        /// The job ID for the session actions list.
        public let jobId: String
        /// The maximum number of results to return. Use this parameter with NextToken to get results as a set of sequential pages.
        public let maxResults: Int?
        /// The token for the next set of results, or null to start from the beginning.
        public let nextToken: String?
        /// The queue ID for the session actions list.
        public let queueId: String
        /// The session ID to include on the sessions action list.
        public let sessionId: String?
        /// The task ID for the session actions list.
        public let taskId: String?

        @inlinable
        public init(farmId: String, jobId: String, maxResults: Int? = nil, nextToken: String? = nil, queueId: String, sessionId: String? = nil, taskId: String? = nil) {
            self.farmId = farmId
            self.jobId = jobId
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.queueId = queueId
            self.sessionId = sessionId
            self.taskId = taskId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.farmId, key: "farmId")
            request.encodePath(self.jobId, key: "jobId")
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
            request.encodePath(self.queueId, key: "queueId")
            request.encodeQuery(self.sessionId, key: "sessionId")
            request.encodeQuery(self.taskId, key: "taskId")
        }

        public func validate(name: String) throws {
            try self.validate(self.farmId, name: "farmId", parent: name, pattern: "^farm-[0-9a-f]{32}$")
            try self.validate(self.jobId, name: "jobId", parent: name, pattern: "^job-[0-9a-f]{32}$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.queueId, name: "queueId", parent: name, pattern: "^queue-[0-9a-f]{32}$")
            try self.validate(self.sessionId, name: "sessionId", parent: name, pattern: "^session-[0-9a-f]{32}$")
            try self.validate(self.taskId, name: "taskId", parent: name, pattern: "^task-[0-9a-f]{32}-(0|([1-9][0-9]{0,9}))$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListSessionActionsResponse: AWSDecodableShape {
        /// If Deadline Cloud returns nextToken, then there are more results available. The value of nextToken is a unique pagination token for each page. To retrieve the next page, call the operation again using the returned token. Keep all other arguments unchanged. If no results remain, then nextToken is set to null. Each pagination token expires after 24 hours. If you provide a token that isn't valid, then you receive an HTTP 400 ValidationException error.
        public let nextToken: String?
        /// The session actions.
        public let sessionActions: [SessionActionSummary]

        @inlinable
        public init(nextToken: String? = nil, sessionActions: [SessionActionSummary]) {
            self.nextToken = nextToken
            self.sessionActions = sessionActions
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "nextToken"
            case sessionActions = "sessionActions"
        }
    }

    public struct ListSessionsForWorkerRequest: AWSEncodableShape {
        /// The farm ID for the session.
        public let farmId: String
        /// The fleet ID for the session.
        public let fleetId: String
        /// The maximum number of results to return. Use this parameter with NextToken to get results as a set of sequential pages.
        public let maxResults: Int?
        /// The token for the next set of results, or null to start from the beginning.
        public let nextToken: String?
        /// The worker ID for the session.
        public let workerId: String

        @inlinable
        public init(farmId: String, fleetId: String, maxResults: Int? = nil, nextToken: String? = nil, workerId: String) {
            self.farmId = farmId
            self.fleetId = fleetId
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.workerId = workerId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.farmId, key: "farmId")
            request.encodePath(self.fleetId, key: "fleetId")
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
            request.encodePath(self.workerId, key: "workerId")
        }

        public func validate(name: String) throws {
            try self.validate(self.farmId, name: "farmId", parent: name, pattern: "^farm-[0-9a-f]{32}$")
            try self.validate(self.fleetId, name: "fleetId", parent: name, pattern: "^fleet-[0-9a-f]{32}$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.workerId, name: "workerId", parent: name, pattern: "^worker-[0-9a-f]{32}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListSessionsForWorkerResponse: AWSDecodableShape {
        /// The token for the next set of results, or null to start from the beginning.
        public let nextToken: String?
        /// The sessions in the response.
        public let sessions: [WorkerSessionSummary]

        @inlinable
        public init(nextToken: String? = nil, sessions: [WorkerSessionSummary]) {
            self.nextToken = nextToken
            self.sessions = sessions
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "nextToken"
            case sessions = "sessions"
        }
    }

    public struct ListSessionsRequest: AWSEncodableShape {
        /// The farm ID for the list of sessions.
        public let farmId: String
        /// The job ID for the list of sessions.
        public let jobId: String
        /// The maximum number of results to return. Use this parameter with NextToken to get results as a set of sequential pages.
        public let maxResults: Int?
        /// The token for the next set of results, or null to start from the beginning.
        public let nextToken: String?
        /// The queue ID for the list of sessions
        public let queueId: String

        @inlinable
        public init(farmId: String, jobId: String, maxResults: Int? = nil, nextToken: String? = nil, queueId: String) {
            self.farmId = farmId
            self.jobId = jobId
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.queueId = queueId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.farmId, key: "farmId")
            request.encodePath(self.jobId, key: "jobId")
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
            request.encodePath(self.queueId, key: "queueId")
        }

        public func validate(name: String) throws {
            try self.validate(self.farmId, name: "farmId", parent: name, pattern: "^farm-[0-9a-f]{32}$")
            try self.validate(self.jobId, name: "jobId", parent: name, pattern: "^job-[0-9a-f]{32}$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.queueId, name: "queueId", parent: name, pattern: "^queue-[0-9a-f]{32}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListSessionsResponse: AWSDecodableShape {
        /// If Deadline Cloud returns nextToken, then there are more results available. The value of nextToken is a unique pagination token for each page. To retrieve the next page, call the operation again using the returned token. Keep all other arguments unchanged. If no results remain, then nextToken is set to null. Each pagination token expires after 24 hours. If you provide a token that isn't valid, then you receive an HTTP 400 ValidationException error.
        public let nextToken: String?
        /// The sessions on the list.
        public let sessions: [SessionSummary]

        @inlinable
        public init(nextToken: String? = nil, sessions: [SessionSummary]) {
            self.nextToken = nextToken
            self.sessions = sessions
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "nextToken"
            case sessions = "sessions"
        }
    }

    public struct ListStepConsumersRequest: AWSEncodableShape {
        /// The farm ID for the list of step consumers.
        public let farmId: String
        /// The job ID for the step consumer.
        public let jobId: String
        /// The maximum number of results to return. Use this parameter with NextToken to get results as a set of sequential pages.
        public let maxResults: Int?
        /// The token for the next set of results, or null to start from the beginning.
        public let nextToken: String?
        /// The queue ID for the step consumer.
        public let queueId: String
        /// The step ID to include on the list.
        public let stepId: String

        @inlinable
        public init(farmId: String, jobId: String, maxResults: Int? = nil, nextToken: String? = nil, queueId: String, stepId: String) {
            self.farmId = farmId
            self.jobId = jobId
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.queueId = queueId
            self.stepId = stepId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.farmId, key: "farmId")
            request.encodePath(self.jobId, key: "jobId")
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
            request.encodePath(self.queueId, key: "queueId")
            request.encodePath(self.stepId, key: "stepId")
        }

        public func validate(name: String) throws {
            try self.validate(self.farmId, name: "farmId", parent: name, pattern: "^farm-[0-9a-f]{32}$")
            try self.validate(self.jobId, name: "jobId", parent: name, pattern: "^job-[0-9a-f]{32}$")
            try self.validate(self.queueId, name: "queueId", parent: name, pattern: "^queue-[0-9a-f]{32}$")
            try self.validate(self.stepId, name: "stepId", parent: name, pattern: "^step-[0-9a-f]{32}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListStepConsumersResponse: AWSDecodableShape {
        /// The consumers on the list.
        public let consumers: [StepConsumer]
        /// If Deadline Cloud returns nextToken, then there are more results available. The value of nextToken is a unique pagination token for each page. To retrieve the next page, call the operation again using the returned token. Keep all other arguments unchanged. If no results remain, then nextToken is set to null. Each pagination token expires after 24 hours. If you provide a token that isn't valid, then you receive an HTTP 400 ValidationException error.
        public let nextToken: String?

        @inlinable
        public init(consumers: [StepConsumer], nextToken: String? = nil) {
            self.consumers = consumers
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case consumers = "consumers"
            case nextToken = "nextToken"
        }
    }

    public struct ListStepDependenciesRequest: AWSEncodableShape {
        /// The farm ID for the step dependencies list.
        public let farmId: String
        /// The job ID for the step dependencies list.
        public let jobId: String
        /// The maximum number of results to return. Use this parameter with NextToken to get results as a set of sequential pages.
        public let maxResults: Int?
        /// The token for the next set of results, or null to start from the beginning.
        public let nextToken: String?
        /// The queue ID for the step dependencies list.
        public let queueId: String
        /// The step ID to include on the list.
        public let stepId: String

        @inlinable
        public init(farmId: String, jobId: String, maxResults: Int? = nil, nextToken: String? = nil, queueId: String, stepId: String) {
            self.farmId = farmId
            self.jobId = jobId
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.queueId = queueId
            self.stepId = stepId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.farmId, key: "farmId")
            request.encodePath(self.jobId, key: "jobId")
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
            request.encodePath(self.queueId, key: "queueId")
            request.encodePath(self.stepId, key: "stepId")
        }

        public func validate(name: String) throws {
            try self.validate(self.farmId, name: "farmId", parent: name, pattern: "^farm-[0-9a-f]{32}$")
            try self.validate(self.jobId, name: "jobId", parent: name, pattern: "^job-[0-9a-f]{32}$")
            try self.validate(self.queueId, name: "queueId", parent: name, pattern: "^queue-[0-9a-f]{32}$")
            try self.validate(self.stepId, name: "stepId", parent: name, pattern: "^step-[0-9a-f]{32}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListStepDependenciesResponse: AWSDecodableShape {
        /// The dependencies on the list.
        public let dependencies: [StepDependency]
        /// If Deadline Cloud returns nextToken, then there are more results available. The value of nextToken is a unique pagination token for each page. To retrieve the next page, call the operation again using the returned token. Keep all other arguments unchanged. If no results remain, then nextToken is set to null. Each pagination token expires after 24 hours. If you provide a token that isn't valid, then you receive an HTTP 400 ValidationException error.
        public let nextToken: String?

        @inlinable
        public init(dependencies: [StepDependency], nextToken: String? = nil) {
            self.dependencies = dependencies
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case dependencies = "dependencies"
            case nextToken = "nextToken"
        }
    }

    public struct ListStepsRequest: AWSEncodableShape {
        /// The farm ID to include on the list of steps.
        public let farmId: String
        /// The job ID to include on the list of steps.
        public let jobId: String
        /// The maximum number of results to return. Use this parameter with NextToken to get results as a set of sequential pages.
        public let maxResults: Int?
        /// The token for the next set of results, or null to start from the beginning.
        public let nextToken: String?
        /// The queue ID to include on the list of steps.
        public let queueId: String

        @inlinable
        public init(farmId: String, jobId: String, maxResults: Int? = nil, nextToken: String? = nil, queueId: String) {
            self.farmId = farmId
            self.jobId = jobId
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.queueId = queueId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.farmId, key: "farmId")
            request.encodePath(self.jobId, key: "jobId")
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
            request.encodePath(self.queueId, key: "queueId")
        }

        public func validate(name: String) throws {
            try self.validate(self.farmId, name: "farmId", parent: name, pattern: "^farm-[0-9a-f]{32}$")
            try self.validate(self.jobId, name: "jobId", parent: name, pattern: "^job-[0-9a-f]{32}$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.queueId, name: "queueId", parent: name, pattern: "^queue-[0-9a-f]{32}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListStepsResponse: AWSDecodableShape {
        /// If Deadline Cloud returns nextToken, then there are more results available. The value of nextToken is a unique pagination token for each page. To retrieve the next page, call the operation again using the returned token. Keep all other arguments unchanged. If no results remain, then nextToken is set to null. Each pagination token expires after 24 hours. If you provide a token that isn't valid, then you receive an HTTP 400 ValidationException error.
        public let nextToken: String?
        /// The steps on the list.
        public let steps: [StepSummary]

        @inlinable
        public init(nextToken: String? = nil, steps: [StepSummary]) {
            self.nextToken = nextToken
            self.steps = steps
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "nextToken"
            case steps = "steps"
        }
    }

    public struct ListStorageProfilesForQueueRequest: AWSEncodableShape {
        /// The farm ID of the queue's storage profile.
        public let farmId: String
        /// The maximum number of results to return. Use this parameter with NextToken to get results as a set of sequential pages.
        public let maxResults: Int?
        /// The token for the next set of results, or null to start from the beginning.
        public let nextToken: String?
        /// The queue ID for the storage profile.
        public let queueId: String

        @inlinable
        public init(farmId: String, maxResults: Int? = nil, nextToken: String? = nil, queueId: String) {
            self.farmId = farmId
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.queueId = queueId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.farmId, key: "farmId")
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
            request.encodePath(self.queueId, key: "queueId")
        }

        public func validate(name: String) throws {
            try self.validate(self.farmId, name: "farmId", parent: name, pattern: "^farm-[0-9a-f]{32}$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.queueId, name: "queueId", parent: name, pattern: "^queue-[0-9a-f]{32}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListStorageProfilesForQueueResponse: AWSDecodableShape {
        /// If Deadline Cloud returns nextToken, then there are more results available. The value of nextToken is a unique pagination token for each page. To retrieve the next page, call the operation again using the returned token. Keep all other arguments unchanged. If no results remain, then nextToken is set to null. Each pagination token expires after 24 hours. If you provide a token that isn't valid, then you receive an HTTP 400 ValidationException error.
        public let nextToken: String?
        /// The storage profiles in the queue.
        public let storageProfiles: [StorageProfileSummary]

        @inlinable
        public init(nextToken: String? = nil, storageProfiles: [StorageProfileSummary]) {
            self.nextToken = nextToken
            self.storageProfiles = storageProfiles
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "nextToken"
            case storageProfiles = "storageProfiles"
        }
    }

    public struct ListStorageProfilesRequest: AWSEncodableShape {
        /// The farm ID of the storage profile.
        public let farmId: String
        /// The maximum number of results to return. Use this parameter with NextToken to get results as a set of sequential pages.
        public let maxResults: Int?
        /// The token for the next set of results, or null to start from the beginning.
        public let nextToken: String?

        @inlinable
        public init(farmId: String, maxResults: Int? = nil, nextToken: String? = nil) {
            self.farmId = farmId
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.farmId, key: "farmId")
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
        }

        public func validate(name: String) throws {
            try self.validate(self.farmId, name: "farmId", parent: name, pattern: "^farm-[0-9a-f]{32}$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListStorageProfilesResponse: AWSDecodableShape {
        /// If Deadline Cloud returns nextToken, then there are more results available. The value of nextToken is a unique pagination token for each page. To retrieve the next page, call the operation again using the returned token. Keep all other arguments unchanged. If no results remain, then nextToken is set to null. Each pagination token expires after 24 hours. If you provide a token that isn't valid, then you receive an HTTP 400 ValidationException error.
        public let nextToken: String?
        /// The storage profiles.
        public let storageProfiles: [StorageProfileSummary]

        @inlinable
        public init(nextToken: String? = nil, storageProfiles: [StorageProfileSummary]) {
            self.nextToken = nextToken
            self.storageProfiles = storageProfiles
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "nextToken"
            case storageProfiles = "storageProfiles"
        }
    }

    public struct ListTagsForResourceRequest: AWSEncodableShape {
        /// The resource ARN to list tags for.
        public let resourceArn: String

        @inlinable
        public init(resourceArn: String) {
            self.resourceArn = resourceArn
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.resourceArn, key: "resourceArn")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListTagsForResourceResponse: AWSDecodableShape {
        /// Each tag consists of a tag key and a tag value. Tag keys and values are both required, but tag values can be empty strings.
        public let tags: [String: String]?

        @inlinable
        public init(tags: [String: String]? = nil) {
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case tags = "tags"
        }
    }

    public struct ListTasksRequest: AWSEncodableShape {
        /// The farm ID connected to the tasks.
        public let farmId: String
        /// The job ID for the tasks.
        public let jobId: String
        /// The maximum number of results to return. Use this parameter with NextToken to get results as a set of sequential pages.
        public let maxResults: Int?
        /// The token for the next set of results, or null to start from the beginning.
        public let nextToken: String?
        /// The queue ID connected to the tasks.
        public let queueId: String
        /// The step ID for the tasks.
        public let stepId: String

        @inlinable
        public init(farmId: String, jobId: String, maxResults: Int? = nil, nextToken: String? = nil, queueId: String, stepId: String) {
            self.farmId = farmId
            self.jobId = jobId
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.queueId = queueId
            self.stepId = stepId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.farmId, key: "farmId")
            request.encodePath(self.jobId, key: "jobId")
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
            request.encodePath(self.queueId, key: "queueId")
            request.encodePath(self.stepId, key: "stepId")
        }

        public func validate(name: String) throws {
            try self.validate(self.farmId, name: "farmId", parent: name, pattern: "^farm-[0-9a-f]{32}$")
            try self.validate(self.jobId, name: "jobId", parent: name, pattern: "^job-[0-9a-f]{32}$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.queueId, name: "queueId", parent: name, pattern: "^queue-[0-9a-f]{32}$")
            try self.validate(self.stepId, name: "stepId", parent: name, pattern: "^step-[0-9a-f]{32}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListTasksResponse: AWSDecodableShape {
        /// If Deadline Cloud returns nextToken, then there are more results available. The value of nextToken is a unique pagination token for each page. To retrieve the next page, call the operation again using the returned token. Keep all other arguments unchanged. If no results remain, then nextToken is set to null. Each pagination token expires after 24 hours. If you provide a token that isn't valid, then you receive an HTTP 400 ValidationException error.
        public let nextToken: String?
        /// Tasks for the job.
        public let tasks: [TaskSummary]

        @inlinable
        public init(nextToken: String? = nil, tasks: [TaskSummary]) {
            self.nextToken = nextToken
            self.tasks = tasks
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "nextToken"
            case tasks = "tasks"
        }
    }

    public struct ListWorkersRequest: AWSEncodableShape {
        /// The farm ID connected to the workers.
        public let farmId: String
        /// The fleet ID of the workers.
        public let fleetId: String
        /// The maximum number of results to return. Use this parameter with NextToken to get results as a set of sequential pages.
        public let maxResults: Int?
        /// The token for the next set of results, or null to start from the beginning.
        public let nextToken: String?

        @inlinable
        public init(farmId: String, fleetId: String, maxResults: Int? = nil, nextToken: String? = nil) {
            self.farmId = farmId
            self.fleetId = fleetId
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.farmId, key: "farmId")
            request.encodePath(self.fleetId, key: "fleetId")
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
        }

        public func validate(name: String) throws {
            try self.validate(self.farmId, name: "farmId", parent: name, pattern: "^farm-[0-9a-f]{32}$")
            try self.validate(self.fleetId, name: "fleetId", parent: name, pattern: "^fleet-[0-9a-f]{32}$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListWorkersResponse: AWSDecodableShape {
        /// If Deadline Cloud returns nextToken, then there are more results available. The value of nextToken is a unique pagination token for each page. To retrieve the next page, call the operation again using the returned token. Keep all other arguments unchanged. If no results remain, then nextToken is set to null. Each pagination token expires after 24 hours. If you provide a token that isn't valid, then you receive an HTTP 400 ValidationException error.
        public let nextToken: String?
        /// The workers on the list.
        public let workers: [WorkerSummary]

        @inlinable
        public init(nextToken: String? = nil, workers: [WorkerSummary]) {
            self.nextToken = nextToken
            self.workers = workers
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "nextToken"
            case workers = "workers"
        }
    }

    public struct LogConfiguration: AWSDecodableShape {
        /// The log configuration error details.
        public let error: String?
        /// The log drivers for worker related logs.
        public let logDriver: String
        /// The options for a log driver.
        public let options: [String: String]?
        /// The parameters for the log configuration.
        public let parameters: [String: String]?

        @inlinable
        public init(error: String? = nil, logDriver: String, options: [String: String]? = nil, parameters: [String: String]? = nil) {
            self.error = error
            self.logDriver = logDriver
            self.options = options
            self.parameters = parameters
        }

        private enum CodingKeys: String, CodingKey {
            case error = "error"
            case logDriver = "logDriver"
            case options = "options"
            case parameters = "parameters"
        }
    }

    public struct ManifestProperties: AWSEncodableShape & AWSDecodableShape {
        /// The file system location name.
        public let fileSystemLocationName: String?
        /// The hash value of the file.
        public let inputManifestHash: String?
        /// The file path.
        public let inputManifestPath: String?
        /// The file path relative to the directory.
        public let outputRelativeDirectories: [String]?
        /// The file's root path.
        public let rootPath: String
        /// The format of the root path.
        public let rootPathFormat: PathFormat

        @inlinable
        public init(fileSystemLocationName: String? = nil, inputManifestHash: String? = nil, inputManifestPath: String? = nil, outputRelativeDirectories: [String]? = nil, rootPath: String, rootPathFormat: PathFormat) {
            self.fileSystemLocationName = fileSystemLocationName
            self.inputManifestHash = inputManifestHash
            self.inputManifestPath = inputManifestPath
            self.outputRelativeDirectories = outputRelativeDirectories
            self.rootPath = rootPath
            self.rootPathFormat = rootPathFormat
        }

        public func validate(name: String) throws {
            try self.validate(self.fileSystemLocationName, name: "fileSystemLocationName", parent: name, max: 64)
            try self.validate(self.fileSystemLocationName, name: "fileSystemLocationName", parent: name, min: 1)
            try self.validate(self.fileSystemLocationName, name: "fileSystemLocationName", parent: name, pattern: "^[0-9A-Za-z ]*$")
            try self.validate(self.outputRelativeDirectories, name: "outputRelativeDirectories", parent: name, max: 100)
        }

        private enum CodingKeys: String, CodingKey {
            case fileSystemLocationName = "fileSystemLocationName"
            case inputManifestHash = "inputManifestHash"
            case inputManifestPath = "inputManifestPath"
            case outputRelativeDirectories = "outputRelativeDirectories"
            case rootPath = "rootPath"
            case rootPathFormat = "rootPathFormat"
        }
    }

    public struct MemoryMiBRange: AWSEncodableShape & AWSDecodableShape {
        /// The maximum amount of memory (in MiB).
        public let max: Int?
        /// The minimum amount of memory (in MiB).
        public let min: Int

        @inlinable
        public init(max: Int? = nil, min: Int) {
            self.max = max
            self.min = min
        }

        public func validate(name: String) throws {
            try self.validate(self.max, name: "max", parent: name, max: 2147483647)
            try self.validate(self.max, name: "max", parent: name, min: 512)
            try self.validate(self.min, name: "min", parent: name, max: 2147483647)
            try self.validate(self.min, name: "min", parent: name, min: 512)
        }

        private enum CodingKeys: String, CodingKey {
            case max = "max"
            case min = "min"
        }
    }

    public struct MeteredProductSummary: AWSDecodableShape {
        /// The family to which the metered product belongs.
        public let family: String
        /// The port on which the metered product should run.
        public let port: Int
        /// The product ID.
        public let productId: String
        /// The vendor.
        public let vendor: String

        @inlinable
        public init(family: String, port: Int, productId: String, vendor: String) {
            self.family = family
            self.port = port
            self.productId = productId
            self.vendor = vendor
        }

        private enum CodingKeys: String, CodingKey {
            case family = "family"
            case port = "port"
            case productId = "productId"
            case vendor = "vendor"
        }
    }

    public struct MonitorSummary: AWSDecodableShape {
        /// The UNIX timestamp of the date and time that the monitor was created.
        @CustomCoding<ISO8601DateCoder>
        public var createdAt: Date
        /// The user name of the person that created the monitor.
        public let createdBy: String
        /// The name of the monitor that displays on the Deadline Cloud console.  This field can store any content. Escape or encode this content before displaying it on a webpage or any other system that might interpret the content of this field.
        public let displayName: String
        /// The Amazon Resource Name (ARN) that the IAM Identity Center assigned to the monitor when it was created.
        public let identityCenterApplicationArn: String
        /// The Amazon Resource Name (ARN) of the IAM Identity Center instance responsible for authenticating monitor users.
        public let identityCenterInstanceArn: String
        /// The unique identifier for the monitor.
        public let monitorId: String
        /// The Amazon Resource Name (ARN) of the IAM role for the monitor. Users of the monitor use this role to access Deadline Cloud resources.
        public let roleArn: String
        /// The subdomain used for the monitor URL. The full URL of the monitor is subdomain.Region.deadlinecloud.amazonaws.com.
        public let subdomain: String
        /// The UNIX timestamp of the date and time that the monitor was last updated.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var updatedAt: Date?
        /// The user name of the person that last updated the monitor.
        public let updatedBy: String?
        /// The complete URL of the monitor. The full URL of the monitor is subdomain.Region.deadlinecloud.amazonaws.com.
        public let url: String

        @inlinable
        public init(createdAt: Date, createdBy: String, displayName: String, identityCenterApplicationArn: String, identityCenterInstanceArn: String, monitorId: String, roleArn: String, subdomain: String, updatedAt: Date? = nil, updatedBy: String? = nil, url: String) {
            self.createdAt = createdAt
            self.createdBy = createdBy
            self.displayName = displayName
            self.identityCenterApplicationArn = identityCenterApplicationArn
            self.identityCenterInstanceArn = identityCenterInstanceArn
            self.monitorId = monitorId
            self.roleArn = roleArn
            self.subdomain = subdomain
            self.updatedAt = updatedAt
            self.updatedBy = updatedBy
            self.url = url
        }

        private enum CodingKeys: String, CodingKey {
            case createdAt = "createdAt"
            case createdBy = "createdBy"
            case displayName = "displayName"
            case identityCenterApplicationArn = "identityCenterApplicationArn"
            case identityCenterInstanceArn = "identityCenterInstanceArn"
            case monitorId = "monitorId"
            case roleArn = "roleArn"
            case subdomain = "subdomain"
            case updatedAt = "updatedAt"
            case updatedBy = "updatedBy"
            case url = "url"
        }
    }

    public struct ParameterFilterExpression: AWSEncodableShape {
        /// The name of the parameter to filter on.
        public let name: String
        /// The type of comparison to use to filter results.
        public let `operator`: ComparisonOperator
        /// The parameter's value.
        public let value: String

        @inlinable
        public init(name: String, operator: ComparisonOperator, value: String) {
            self.name = name
            self.`operator` = `operator`
            self.value = value
        }

        public func validate(name: String) throws {
            try self.validate(self.value, name: "value", parent: name, max: 256)
            try self.validate(self.value, name: "value", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case name = "name"
            case `operator` = "operator"
            case value = "value"
        }
    }

    public struct ParameterSortExpression: AWSEncodableShape {
        /// The parameter name to sort by.
        public let name: String
        /// The sort order for the parameter.
        public let sortOrder: SortOrder

        @inlinable
        public init(name: String, sortOrder: SortOrder) {
            self.name = name
            self.sortOrder = sortOrder
        }

        private enum CodingKeys: String, CodingKey {
            case name = "name"
            case sortOrder = "sortOrder"
        }
    }

    public struct ParameterSpace: AWSDecodableShape {
        /// The combination expression to use in the search.
        public let combination: String?
        /// The parameters to search for.
        public let parameters: [StepParameter]

        @inlinable
        public init(combination: String? = nil, parameters: [StepParameter]) {
            self.combination = combination
            self.parameters = parameters
        }

        private enum CodingKeys: String, CodingKey {
            case combination = "combination"
            case parameters = "parameters"
        }
    }

    public struct PathMappingRule: AWSDecodableShape {
        /// The destination path.
        public let destinationPath: String
        /// The source path.
        public let sourcePath: String
        /// The source path format.
        public let sourcePathFormat: PathFormat

        @inlinable
        public init(destinationPath: String, sourcePath: String, sourcePathFormat: PathFormat) {
            self.destinationPath = destinationPath
            self.sourcePath = sourcePath
            self.sourcePathFormat = sourcePathFormat
        }

        private enum CodingKeys: String, CodingKey {
            case destinationPath = "destinationPath"
            case sourcePath = "sourcePath"
            case sourcePathFormat = "sourcePathFormat"
        }
    }

    public struct PosixUser: AWSEncodableShape & AWSDecodableShape {
        /// The name of the POSIX user's group.
        public let group: String
        /// The name of the POSIX user.
        public let user: String

        @inlinable
        public init(group: String, user: String) {
            self.group = group
            self.user = user
        }

        private enum CodingKeys: String, CodingKey {
            case group = "group"
            case user = "user"
        }
    }

    public struct PutMeteredProductRequest: AWSEncodableShape {
        /// The license endpoint ID to add to the metered product.
        public let licenseEndpointId: String
        /// The product ID to add to the metered product.
        public let productId: String

        @inlinable
        public init(licenseEndpointId: String, productId: String) {
            self.licenseEndpointId = licenseEndpointId
            self.productId = productId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.licenseEndpointId, key: "licenseEndpointId")
            request.encodePath(self.productId, key: "productId")
        }

        public func validate(name: String) throws {
            try self.validate(self.licenseEndpointId, name: "licenseEndpointId", parent: name, pattern: "^le-[0-9a-f]{32}$")
            try self.validate(self.productId, name: "productId", parent: name, pattern: "^[0-9a-z]{1,32}-[.0-9a-z]{1,32}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct PutMeteredProductResponse: AWSDecodableShape {
        public init() {}
    }

    public struct QueueEnvironmentSummary: AWSDecodableShape {
        /// The name of the queue environment.
        public let name: String
        /// The queue environment's priority.
        public let priority: Int
        /// The queue environment ID.
        public let queueEnvironmentId: String

        @inlinable
        public init(name: String, priority: Int, queueEnvironmentId: String) {
            self.name = name
            self.priority = priority
            self.queueEnvironmentId = queueEnvironmentId
        }

        private enum CodingKeys: String, CodingKey {
            case name = "name"
            case priority = "priority"
            case queueEnvironmentId = "queueEnvironmentId"
        }
    }

    public struct QueueFleetAssociationSummary: AWSDecodableShape {
        /// The date and time the resource was created.
        @CustomCoding<ISO8601DateCoder>
        public var createdAt: Date
        /// The user or system that created this resource.
        public let createdBy: String
        /// The fleet ID.
        public let fleetId: String
        /// The queue ID.
        public let queueId: String
        /// The status of task scheduling in the queue-fleet association.    ACTIVEAssociation is active.    STOP_SCHEDULING_AND_COMPLETE_TASKSAssociation has stopped scheduling new tasks and is completing current tasks.    STOP_SCHEDULING_AND_CANCEL_TASKSAssociation has stopped scheduling new tasks and is canceling current tasks.    STOPPEDAssociation has been stopped.
        public let status: QueueFleetAssociationStatus
        /// The date and time the resource was updated.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var updatedAt: Date?
        /// The user or system that updated this resource.
        public let updatedBy: String?

        @inlinable
        public init(createdAt: Date, createdBy: String, fleetId: String, queueId: String, status: QueueFleetAssociationStatus, updatedAt: Date? = nil, updatedBy: String? = nil) {
            self.createdAt = createdAt
            self.createdBy = createdBy
            self.fleetId = fleetId
            self.queueId = queueId
            self.status = status
            self.updatedAt = updatedAt
            self.updatedBy = updatedBy
        }

        private enum CodingKeys: String, CodingKey {
            case createdAt = "createdAt"
            case createdBy = "createdBy"
            case fleetId = "fleetId"
            case queueId = "queueId"
            case status = "status"
            case updatedAt = "updatedAt"
            case updatedBy = "updatedBy"
        }
    }

    public struct QueueLimitAssociationSummary: AWSDecodableShape {
        /// The Unix timestamp of the date and time that the association was created.
        @CustomCoding<ISO8601DateCoder>
        public var createdAt: Date
        /// The user identifier of the person that created the association.
        public let createdBy: String
        /// The unique identifier of the limit in the association.
        public let limitId: String
        /// The unique identifier of the queue in the association.
        public let queueId: String
        /// The status of task scheduling in the queue-limit association.    ACTIVE - Association is active.    STOP_LIMIT_USAGE_AND_COMPLETE_TASKS - Association has stopped scheduling new tasks and is completing current tasks.    STOP_LIMIT_USAGE_AND_CANCEL_TASKS - Association has stopped scheduling new tasks and is canceling current tasks.    STOPPED - Association has been stopped.
        public let status: QueueLimitAssociationStatus
        /// The Unix timestamp of the date and time that the association was last updated.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var updatedAt: Date?
        /// The user identifier of the person that updated the association.
        public let updatedBy: String?

        @inlinable
        public init(createdAt: Date, createdBy: String, limitId: String, queueId: String, status: QueueLimitAssociationStatus, updatedAt: Date? = nil, updatedBy: String? = nil) {
            self.createdAt = createdAt
            self.createdBy = createdBy
            self.limitId = limitId
            self.queueId = queueId
            self.status = status
            self.updatedAt = updatedAt
            self.updatedBy = updatedBy
        }

        private enum CodingKeys: String, CodingKey {
            case createdAt = "createdAt"
            case createdBy = "createdBy"
            case limitId = "limitId"
            case queueId = "queueId"
            case status = "status"
            case updatedAt = "updatedAt"
            case updatedBy = "updatedBy"
        }
    }

    public struct QueueMember: AWSDecodableShape {
        /// The farm ID.
        public let farmId: String
        /// The identity store ID.
        public let identityStoreId: String
        /// The queue member's membership level.
        public let membershipLevel: MembershipLevel
        /// The principal ID of the queue member.
        public let principalId: String
        /// The principal type of the queue member.
        public let principalType: DeadlinePrincipalType
        /// The queue ID.
        public let queueId: String

        @inlinable
        public init(farmId: String, identityStoreId: String, membershipLevel: MembershipLevel, principalId: String, principalType: DeadlinePrincipalType, queueId: String) {
            self.farmId = farmId
            self.identityStoreId = identityStoreId
            self.membershipLevel = membershipLevel
            self.principalId = principalId
            self.principalType = principalType
            self.queueId = queueId
        }

        private enum CodingKeys: String, CodingKey {
            case farmId = "farmId"
            case identityStoreId = "identityStoreId"
            case membershipLevel = "membershipLevel"
            case principalId = "principalId"
            case principalType = "principalType"
            case queueId = "queueId"
        }
    }

    public struct QueueSummary: AWSDecodableShape {
        /// The reason the queue is blocked, if applicable.
        public let blockedReason: QueueBlockedReason?
        /// The date and time the resource was created.
        @CustomCoding<ISO8601DateCoder>
        public var createdAt: Date
        /// The user or system that created this resource.
        public let createdBy: String
        /// The default action taken on a queue summary if a budget wasn't configured.
        public let defaultBudgetAction: DefaultQueueBudgetAction
        /// The display name of the queue summary to update.  This field can store any content. Escape or encode this content before displaying it on a webpage or any other system that might interpret the content of this field.
        public let displayName: String
        /// The farm ID.
        public let farmId: String
        /// The queue ID.
        public let queueId: String
        /// That status of the queue.
        public let status: QueueStatus
        /// The date and time the resource was updated.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var updatedAt: Date?
        /// The user or system that updated this resource.
        public let updatedBy: String?

        @inlinable
        public init(blockedReason: QueueBlockedReason? = nil, createdAt: Date, createdBy: String, defaultBudgetAction: DefaultQueueBudgetAction, displayName: String, farmId: String, queueId: String, status: QueueStatus, updatedAt: Date? = nil, updatedBy: String? = nil) {
            self.blockedReason = blockedReason
            self.createdAt = createdAt
            self.createdBy = createdBy
            self.defaultBudgetAction = defaultBudgetAction
            self.displayName = displayName
            self.farmId = farmId
            self.queueId = queueId
            self.status = status
            self.updatedAt = updatedAt
            self.updatedBy = updatedBy
        }

        private enum CodingKeys: String, CodingKey {
            case blockedReason = "blockedReason"
            case createdAt = "createdAt"
            case createdBy = "createdBy"
            case defaultBudgetAction = "defaultBudgetAction"
            case displayName = "displayName"
            case farmId = "farmId"
            case queueId = "queueId"
            case status = "status"
            case updatedAt = "updatedAt"
            case updatedBy = "updatedBy"
        }
    }

    public struct ResourceNotFoundException: AWSErrorShape {
        /// Information about the resources in use when the exception was thrown.
        public let context: [String: String]?
        public let message: String
        /// The identifier of the resource that couldn't be found.
        public let resourceId: String
        /// The type of the resource that couldn't be found.
        public let resourceType: String

        @inlinable
        public init(context: [String: String]? = nil, message: String, resourceId: String, resourceType: String) {
            self.context = context
            self.message = message
            self.resourceId = resourceId
            self.resourceType = resourceType
        }

        private enum CodingKeys: String, CodingKey {
            case context = "context"
            case message = "message"
            case resourceId = "resourceId"
            case resourceType = "resourceType"
        }
    }

    public struct ResponseBudgetAction: AWSDecodableShape {
        /// The budget action description.  This field can store any content. Escape or encode this content before displaying it on a webpage or any other system that might interpret the content of this field.
        public let description: String?
        /// The percentage threshold for the budget.
        public let thresholdPercentage: Float
        /// The action taken on the budget once scheduling stops.
        public let type: BudgetActionType

        @inlinable
        public init(description: String? = nil, thresholdPercentage: Float, type: BudgetActionType) {
            self.description = description
            self.thresholdPercentage = thresholdPercentage
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case description = "description"
            case thresholdPercentage = "thresholdPercentage"
            case type = "type"
        }
    }

    public struct S3Location: AWSEncodableShape {
        /// The name of the Amazon S3 bucket.
        public let bucketName: String
        /// The Amazon S3 object key that uniquely identifies the Amazon S3 bucket.
        public let key: String

        @inlinable
        public init(bucketName: String, key: String) {
            self.bucketName = bucketName
            self.key = key
        }

        public func validate(name: String) throws {
            try self.validate(self.bucketName, name: "bucketName", parent: name, max: 255)
            try self.validate(self.bucketName, name: "bucketName", parent: name, min: 1)
            try self.validate(self.key, name: "key", parent: name, max: 1024)
            try self.validate(self.key, name: "key", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case bucketName = "bucketName"
            case key = "key"
        }
    }

    public struct SearchGroupedFilterExpressions: AWSEncodableShape {
        /// The filters to use for the search.
        public let filters: [SearchFilterExpression]
        /// The operators to include in the search.
        public let `operator`: LogicalOperator

        @inlinable
        public init(filters: [SearchFilterExpression], operator: LogicalOperator) {
            self.filters = filters
            self.`operator` = `operator`
        }

        public func validate(name: String) throws {
            try self.filters.forEach {
                try $0.validate(name: "\(name).filters[]")
            }
            try self.validate(self.filters, name: "filters", parent: name, max: 3)
            try self.validate(self.filters, name: "filters", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case filters = "filters"
            case `operator` = "operator"
        }
    }

    public struct SearchJobsRequest: AWSEncodableShape {
        /// The farm ID of the job.
        public let farmId: String
        /// The filter expression, AND or OR, to use
        /// when searching among a group of search strings in a resource.
        /// You can use two groupings per search each within parenthesis ().
        public let filterExpressions: SearchGroupedFilterExpressions?
        /// Defines how far into the scrollable list to start the return of results.
        public let itemOffset: Int
        /// Specifies the number of items per page for the resource.
        public let pageSize: Int?
        /// The queue ID to use in the job search.
        public let queueIds: [String]
        /// The search terms for a resource.
        public let sortExpressions: [SearchSortExpression]?

        @inlinable
        public init(farmId: String, filterExpressions: SearchGroupedFilterExpressions? = nil, itemOffset: Int, pageSize: Int? = nil, queueIds: [String], sortExpressions: [SearchSortExpression]? = nil) {
            self.farmId = farmId
            self.filterExpressions = filterExpressions
            self.itemOffset = itemOffset
            self.pageSize = pageSize
            self.queueIds = queueIds
            self.sortExpressions = sortExpressions
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.farmId, key: "farmId")
            try container.encodeIfPresent(self.filterExpressions, forKey: .filterExpressions)
            try container.encode(self.itemOffset, forKey: .itemOffset)
            try container.encodeIfPresent(self.pageSize, forKey: .pageSize)
            try container.encode(self.queueIds, forKey: .queueIds)
            try container.encodeIfPresent(self.sortExpressions, forKey: .sortExpressions)
        }

        public func validate(name: String) throws {
            try self.validate(self.farmId, name: "farmId", parent: name, pattern: "^farm-[0-9a-f]{32}$")
            try self.filterExpressions?.validate(name: "\(name).filterExpressions")
            try self.queueIds.forEach {
                try validate($0, name: "queueIds[]", parent: name, pattern: "^queue-[0-9a-f]{32}$")
            }
            try self.validate(self.queueIds, name: "queueIds", parent: name, min: 1)
            try self.validate(self.sortExpressions, name: "sortExpressions", parent: name, max: 5)
            try self.validate(self.sortExpressions, name: "sortExpressions", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case filterExpressions = "filterExpressions"
            case itemOffset = "itemOffset"
            case pageSize = "pageSize"
            case queueIds = "queueIds"
            case sortExpressions = "sortExpressions"
        }
    }

    public struct SearchJobsResponse: AWSDecodableShape {
        /// The jobs in the search.
        public let jobs: [JobSearchSummary]
        /// The next incremental starting point after the defined itemOffset.
        public let nextItemOffset: Int?
        /// The total number of results in the search.
        public let totalResults: Int

        @inlinable
        public init(jobs: [JobSearchSummary], nextItemOffset: Int? = nil, totalResults: Int) {
            self.jobs = jobs
            self.nextItemOffset = nextItemOffset
            self.totalResults = totalResults
        }

        private enum CodingKeys: String, CodingKey {
            case jobs = "jobs"
            case nextItemOffset = "nextItemOffset"
            case totalResults = "totalResults"
        }
    }

    public struct SearchStepsRequest: AWSEncodableShape {
        /// The farm ID to use for the step search.
        public let farmId: String
        /// The filter expression, AND or OR, to use
        /// when searching among a group of search strings in a resource.
        /// You can use two groupings per search each within parenthesis ().
        public let filterExpressions: SearchGroupedFilterExpressions?
        /// Defines how far into the scrollable list to start the return of results.
        public let itemOffset: Int
        /// The job ID to use in the step search.
        public let jobId: String?
        /// Specifies the number of items per page for the resource.
        public let pageSize: Int?
        /// The queue IDs in the step search.
        public let queueIds: [String]
        /// The search terms for a resource.
        public let sortExpressions: [SearchSortExpression]?

        @inlinable
        public init(farmId: String, filterExpressions: SearchGroupedFilterExpressions? = nil, itemOffset: Int, jobId: String? = nil, pageSize: Int? = nil, queueIds: [String], sortExpressions: [SearchSortExpression]? = nil) {
            self.farmId = farmId
            self.filterExpressions = filterExpressions
            self.itemOffset = itemOffset
            self.jobId = jobId
            self.pageSize = pageSize
            self.queueIds = queueIds
            self.sortExpressions = sortExpressions
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.farmId, key: "farmId")
            try container.encodeIfPresent(self.filterExpressions, forKey: .filterExpressions)
            try container.encode(self.itemOffset, forKey: .itemOffset)
            try container.encodeIfPresent(self.jobId, forKey: .jobId)
            try container.encodeIfPresent(self.pageSize, forKey: .pageSize)
            try container.encode(self.queueIds, forKey: .queueIds)
            try container.encodeIfPresent(self.sortExpressions, forKey: .sortExpressions)
        }

        public func validate(name: String) throws {
            try self.validate(self.farmId, name: "farmId", parent: name, pattern: "^farm-[0-9a-f]{32}$")
            try self.filterExpressions?.validate(name: "\(name).filterExpressions")
            try self.validate(self.jobId, name: "jobId", parent: name, pattern: "^job-[0-9a-f]{32}$")
            try self.queueIds.forEach {
                try validate($0, name: "queueIds[]", parent: name, pattern: "^queue-[0-9a-f]{32}$")
            }
            try self.validate(self.queueIds, name: "queueIds", parent: name, min: 1)
            try self.validate(self.sortExpressions, name: "sortExpressions", parent: name, max: 5)
            try self.validate(self.sortExpressions, name: "sortExpressions", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case filterExpressions = "filterExpressions"
            case itemOffset = "itemOffset"
            case jobId = "jobId"
            case pageSize = "pageSize"
            case queueIds = "queueIds"
            case sortExpressions = "sortExpressions"
        }
    }

    public struct SearchStepsResponse: AWSDecodableShape {
        /// The next incremental starting point after the defined itemOffset.
        public let nextItemOffset: Int?
        /// The steps in the search.
        public let steps: [StepSearchSummary]
        /// The total number of results in the search.
        public let totalResults: Int

        @inlinable
        public init(nextItemOffset: Int? = nil, steps: [StepSearchSummary], totalResults: Int) {
            self.nextItemOffset = nextItemOffset
            self.steps = steps
            self.totalResults = totalResults
        }

        private enum CodingKeys: String, CodingKey {
            case nextItemOffset = "nextItemOffset"
            case steps = "steps"
            case totalResults = "totalResults"
        }
    }

    public struct SearchTasksRequest: AWSEncodableShape {
        /// The farm ID of the task.
        public let farmId: String
        /// The filter expression, AND or OR, to use
        /// when searching among a group of search strings in a resource.
        /// You can use two groupings per search each within parenthesis ().
        public let filterExpressions: SearchGroupedFilterExpressions?
        /// Defines how far into the scrollable list to start the return of results.
        public let itemOffset: Int
        /// The job ID for the task search.
        public let jobId: String?
        /// Specifies the number of items per page for the resource.
        public let pageSize: Int?
        /// The queue IDs to include in the search.
        public let queueIds: [String]
        /// The search terms for a resource.
        public let sortExpressions: [SearchSortExpression]?

        @inlinable
        public init(farmId: String, filterExpressions: SearchGroupedFilterExpressions? = nil, itemOffset: Int, jobId: String? = nil, pageSize: Int? = nil, queueIds: [String], sortExpressions: [SearchSortExpression]? = nil) {
            self.farmId = farmId
            self.filterExpressions = filterExpressions
            self.itemOffset = itemOffset
            self.jobId = jobId
            self.pageSize = pageSize
            self.queueIds = queueIds
            self.sortExpressions = sortExpressions
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.farmId, key: "farmId")
            try container.encodeIfPresent(self.filterExpressions, forKey: .filterExpressions)
            try container.encode(self.itemOffset, forKey: .itemOffset)
            try container.encodeIfPresent(self.jobId, forKey: .jobId)
            try container.encodeIfPresent(self.pageSize, forKey: .pageSize)
            try container.encode(self.queueIds, forKey: .queueIds)
            try container.encodeIfPresent(self.sortExpressions, forKey: .sortExpressions)
        }

        public func validate(name: String) throws {
            try self.validate(self.farmId, name: "farmId", parent: name, pattern: "^farm-[0-9a-f]{32}$")
            try self.filterExpressions?.validate(name: "\(name).filterExpressions")
            try self.validate(self.jobId, name: "jobId", parent: name, pattern: "^job-[0-9a-f]{32}$")
            try self.queueIds.forEach {
                try validate($0, name: "queueIds[]", parent: name, pattern: "^queue-[0-9a-f]{32}$")
            }
            try self.validate(self.queueIds, name: "queueIds", parent: name, min: 1)
            try self.validate(self.sortExpressions, name: "sortExpressions", parent: name, max: 5)
            try self.validate(self.sortExpressions, name: "sortExpressions", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case filterExpressions = "filterExpressions"
            case itemOffset = "itemOffset"
            case jobId = "jobId"
            case pageSize = "pageSize"
            case queueIds = "queueIds"
            case sortExpressions = "sortExpressions"
        }
    }

    public struct SearchTasksResponse: AWSDecodableShape {
        /// The next incremental starting point after the defined itemOffset.
        public let nextItemOffset: Int?
        /// Tasks in the search.
        public let tasks: [TaskSearchSummary]
        /// The total number of results in the search.
        public let totalResults: Int

        @inlinable
        public init(nextItemOffset: Int? = nil, tasks: [TaskSearchSummary], totalResults: Int) {
            self.nextItemOffset = nextItemOffset
            self.tasks = tasks
            self.totalResults = totalResults
        }

        private enum CodingKeys: String, CodingKey {
            case nextItemOffset = "nextItemOffset"
            case tasks = "tasks"
            case totalResults = "totalResults"
        }
    }

    public struct SearchTermFilterExpression: AWSEncodableShape {
        /// Specifies how Deadline Cloud matches your search term in the results. If you don't specify a matchType the default is FUZZY_MATCH.    FUZZY_MATCH - Matches if a portion of the search term is found in the result.    CONTAINS - Matches if the exact search term is contained in the result.
        public let matchType: SearchTermMatchingType?
        /// The term to search for.
        public let searchTerm: String

        @inlinable
        public init(matchType: SearchTermMatchingType? = nil, searchTerm: String) {
            self.matchType = matchType
            self.searchTerm = searchTerm
        }

        public func validate(name: String) throws {
            try self.validate(self.searchTerm, name: "searchTerm", parent: name, max: 256)
            try self.validate(self.searchTerm, name: "searchTerm", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case matchType = "matchType"
            case searchTerm = "searchTerm"
        }
    }

    public struct SearchWorkersRequest: AWSEncodableShape {
        /// The farm ID in the workers search.
        public let farmId: String
        /// The filter expression, AND or OR, to use
        /// when searching among a group of search strings in a resource.
        /// You can use two groupings per search each within parenthesis ().
        public let filterExpressions: SearchGroupedFilterExpressions?
        /// The fleet ID of the workers to search for.
        public let fleetIds: [String]
        /// Defines how far into the scrollable list to start the return of results.
        public let itemOffset: Int
        /// Specifies the number of items per page for the resource.
        public let pageSize: Int?
        /// The search terms for a resource.
        public let sortExpressions: [SearchSortExpression]?

        @inlinable
        public init(farmId: String, filterExpressions: SearchGroupedFilterExpressions? = nil, fleetIds: [String], itemOffset: Int, pageSize: Int? = nil, sortExpressions: [SearchSortExpression]? = nil) {
            self.farmId = farmId
            self.filterExpressions = filterExpressions
            self.fleetIds = fleetIds
            self.itemOffset = itemOffset
            self.pageSize = pageSize
            self.sortExpressions = sortExpressions
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.farmId, key: "farmId")
            try container.encodeIfPresent(self.filterExpressions, forKey: .filterExpressions)
            try container.encode(self.fleetIds, forKey: .fleetIds)
            try container.encode(self.itemOffset, forKey: .itemOffset)
            try container.encodeIfPresent(self.pageSize, forKey: .pageSize)
            try container.encodeIfPresent(self.sortExpressions, forKey: .sortExpressions)
        }

        public func validate(name: String) throws {
            try self.validate(self.farmId, name: "farmId", parent: name, pattern: "^farm-[0-9a-f]{32}$")
            try self.filterExpressions?.validate(name: "\(name).filterExpressions")
            try self.fleetIds.forEach {
                try validate($0, name: "fleetIds[]", parent: name, pattern: "^fleet-[0-9a-f]{32}$")
            }
            try self.validate(self.fleetIds, name: "fleetIds", parent: name, min: 1)
            try self.validate(self.sortExpressions, name: "sortExpressions", parent: name, max: 5)
            try self.validate(self.sortExpressions, name: "sortExpressions", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case filterExpressions = "filterExpressions"
            case fleetIds = "fleetIds"
            case itemOffset = "itemOffset"
            case pageSize = "pageSize"
            case sortExpressions = "sortExpressions"
        }
    }

    public struct SearchWorkersResponse: AWSDecodableShape {
        /// The next incremental starting point after the defined itemOffset.
        public let nextItemOffset: Int?
        /// The total number of results in the search.
        public let totalResults: Int
        /// The workers for the search.
        public let workers: [WorkerSearchSummary]

        @inlinable
        public init(nextItemOffset: Int? = nil, totalResults: Int, workers: [WorkerSearchSummary]) {
            self.nextItemOffset = nextItemOffset
            self.totalResults = totalResults
            self.workers = workers
        }

        private enum CodingKeys: String, CodingKey {
            case nextItemOffset = "nextItemOffset"
            case totalResults = "totalResults"
            case workers = "workers"
        }
    }

    public struct ServiceManagedEc2FleetConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The Amazon EC2 instance capabilities.
        public let instanceCapabilities: ServiceManagedEc2InstanceCapabilities
        /// The Amazon EC2 market type.
        public let instanceMarketOptions: ServiceManagedEc2InstanceMarketOptions

        @inlinable
        public init(instanceCapabilities: ServiceManagedEc2InstanceCapabilities, instanceMarketOptions: ServiceManagedEc2InstanceMarketOptions) {
            self.instanceCapabilities = instanceCapabilities
            self.instanceMarketOptions = instanceMarketOptions
        }

        public func validate(name: String) throws {
            try self.instanceCapabilities.validate(name: "\(name).instanceCapabilities")
        }

        private enum CodingKeys: String, CodingKey {
            case instanceCapabilities = "instanceCapabilities"
            case instanceMarketOptions = "instanceMarketOptions"
        }
    }

    public struct ServiceManagedEc2InstanceCapabilities: AWSEncodableShape & AWSDecodableShape {
        /// Describes the GPU accelerator capabilities required for worker host instances in this fleet.
        public let acceleratorCapabilities: AcceleratorCapabilities?
        /// The allowable Amazon EC2 instance types.
        public let allowedInstanceTypes: [String]?
        /// The CPU architecture type.
        public let cpuArchitectureType: CpuArchitectureType
        /// The custom capability amounts to require for instances in this fleet.
        public let customAmounts: [FleetAmountCapability]?
        /// The custom capability attributes to require for instances in this fleet.
        public let customAttributes: [FleetAttributeCapability]?
        /// The instance types to exclude from the fleet.
        public let excludedInstanceTypes: [String]?
        /// The memory, as MiB, for the Amazon EC2 instance type.
        public let memoryMiB: MemoryMiBRange
        /// The operating system (OS) family.
        public let osFamily: ServiceManagedFleetOperatingSystemFamily
        /// The root EBS volume.
        public let rootEbsVolume: Ec2EbsVolume?
        /// The amount of vCPU to require for instances in this fleet.
        public let vCpuCount: VCpuCountRange

        @inlinable
        public init(acceleratorCapabilities: AcceleratorCapabilities? = nil, allowedInstanceTypes: [String]? = nil, cpuArchitectureType: CpuArchitectureType, customAmounts: [FleetAmountCapability]? = nil, customAttributes: [FleetAttributeCapability]? = nil, excludedInstanceTypes: [String]? = nil, memoryMiB: MemoryMiBRange, osFamily: ServiceManagedFleetOperatingSystemFamily, rootEbsVolume: Ec2EbsVolume? = nil, vCpuCount: VCpuCountRange) {
            self.acceleratorCapabilities = acceleratorCapabilities
            self.allowedInstanceTypes = allowedInstanceTypes
            self.cpuArchitectureType = cpuArchitectureType
            self.customAmounts = customAmounts
            self.customAttributes = customAttributes
            self.excludedInstanceTypes = excludedInstanceTypes
            self.memoryMiB = memoryMiB
            self.osFamily = osFamily
            self.rootEbsVolume = rootEbsVolume
            self.vCpuCount = vCpuCount
        }

        public func validate(name: String) throws {
            try self.acceleratorCapabilities?.validate(name: "\(name).acceleratorCapabilities")
            try self.allowedInstanceTypes?.forEach {
                try validate($0, name: "allowedInstanceTypes[]", parent: name, pattern: "^[a-zA-Z0-9]+\\.[a-zA-Z0-9]+$")
            }
            try self.validate(self.allowedInstanceTypes, name: "allowedInstanceTypes", parent: name, max: 100)
            try self.validate(self.allowedInstanceTypes, name: "allowedInstanceTypes", parent: name, min: 1)
            try self.customAmounts?.forEach {
                try $0.validate(name: "\(name).customAmounts[]")
            }
            try self.validate(self.customAmounts, name: "customAmounts", parent: name, max: 15)
            try self.validate(self.customAmounts, name: "customAmounts", parent: name, min: 1)
            try self.customAttributes?.forEach {
                try $0.validate(name: "\(name).customAttributes[]")
            }
            try self.validate(self.customAttributes, name: "customAttributes", parent: name, max: 15)
            try self.validate(self.customAttributes, name: "customAttributes", parent: name, min: 1)
            try self.excludedInstanceTypes?.forEach {
                try validate($0, name: "excludedInstanceTypes[]", parent: name, pattern: "^[a-zA-Z0-9]+\\.[a-zA-Z0-9]+$")
            }
            try self.validate(self.excludedInstanceTypes, name: "excludedInstanceTypes", parent: name, max: 100)
            try self.validate(self.excludedInstanceTypes, name: "excludedInstanceTypes", parent: name, min: 1)
            try self.memoryMiB.validate(name: "\(name).memoryMiB")
            try self.rootEbsVolume?.validate(name: "\(name).rootEbsVolume")
            try self.vCpuCount.validate(name: "\(name).vCpuCount")
        }

        private enum CodingKeys: String, CodingKey {
            case acceleratorCapabilities = "acceleratorCapabilities"
            case allowedInstanceTypes = "allowedInstanceTypes"
            case cpuArchitectureType = "cpuArchitectureType"
            case customAmounts = "customAmounts"
            case customAttributes = "customAttributes"
            case excludedInstanceTypes = "excludedInstanceTypes"
            case memoryMiB = "memoryMiB"
            case osFamily = "osFamily"
            case rootEbsVolume = "rootEbsVolume"
            case vCpuCount = "vCpuCount"
        }
    }

    public struct ServiceManagedEc2InstanceMarketOptions: AWSEncodableShape & AWSDecodableShape {
        /// The Amazon EC2 instance type.
        public let type: Ec2MarketType

        @inlinable
        public init(type: Ec2MarketType) {
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case type = "type"
        }
    }

    public struct ServiceQuotaExceededException: AWSErrorShape {
        /// Information about the resources in use when the exception was thrown.
        public let context: [String: String]?
        public let message: String
        /// Identifies the quota that has been exceeded.
        public let quotaCode: String
        /// A string that describes the reason the quota was exceeded.
        public let reason: ServiceQuotaExceededExceptionReason
        /// The identifier of the affected resource.
        public let resourceId: String?
        /// The type of the affected resource
        public let resourceType: String
        /// Identifies the service that exceeded the quota.
        public let serviceCode: String

        @inlinable
        public init(context: [String: String]? = nil, message: String, quotaCode: String, reason: ServiceQuotaExceededExceptionReason, resourceId: String? = nil, resourceType: String, serviceCode: String) {
            self.context = context
            self.message = message
            self.quotaCode = quotaCode
            self.reason = reason
            self.resourceId = resourceId
            self.resourceType = resourceType
            self.serviceCode = serviceCode
        }

        private enum CodingKeys: String, CodingKey {
            case context = "context"
            case message = "message"
            case quotaCode = "quotaCode"
            case reason = "reason"
            case resourceId = "resourceId"
            case resourceType = "resourceType"
            case serviceCode = "serviceCode"
        }
    }

    public struct SessionActionSummary: AWSDecodableShape {
        /// The session action definition.
        public let definition: SessionActionDefinitionSummary
        /// The date and time the resource ended running.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var endedAt: Date?
        /// The completion percentage for the session action.
        public let progressPercent: Float?
        /// The session action ID.
        public let sessionActionId: String
        /// The date and time the resource started running.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var startedAt: Date?
        /// The status of the session action.
        public let status: SessionActionStatus
        /// The Linux timestamp of the last date and time that the session action was updated.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var workerUpdatedAt: Date?

        @inlinable
        public init(definition: SessionActionDefinitionSummary, endedAt: Date? = nil, progressPercent: Float? = nil, sessionActionId: String, startedAt: Date? = nil, status: SessionActionStatus, workerUpdatedAt: Date? = nil) {
            self.definition = definition
            self.endedAt = endedAt
            self.progressPercent = progressPercent
            self.sessionActionId = sessionActionId
            self.startedAt = startedAt
            self.status = status
            self.workerUpdatedAt = workerUpdatedAt
        }

        private enum CodingKeys: String, CodingKey {
            case definition = "definition"
            case endedAt = "endedAt"
            case progressPercent = "progressPercent"
            case sessionActionId = "sessionActionId"
            case startedAt = "startedAt"
            case status = "status"
            case workerUpdatedAt = "workerUpdatedAt"
        }
    }

    public struct SessionSummary: AWSDecodableShape {
        /// The date and time the resource ended running.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var endedAt: Date?
        /// The fleet ID.
        public let fleetId: String
        /// The life cycle status for the session.
        public let lifecycleStatus: SessionLifecycleStatus
        /// The session ID.
        public let sessionId: String
        /// The date and time the resource started running.
        @CustomCoding<ISO8601DateCoder>
        public var startedAt: Date
        /// The target life cycle status for the session.
        public let targetLifecycleStatus: SessionLifecycleTargetStatus?
        /// The date and time the resource was updated.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var updatedAt: Date?
        /// The user or system that updated this resource.
        public let updatedBy: String?
        /// The worker ID.
        public let workerId: String

        @inlinable
        public init(endedAt: Date? = nil, fleetId: String, lifecycleStatus: SessionLifecycleStatus, sessionId: String, startedAt: Date, targetLifecycleStatus: SessionLifecycleTargetStatus? = nil, updatedAt: Date? = nil, updatedBy: String? = nil, workerId: String) {
            self.endedAt = endedAt
            self.fleetId = fleetId
            self.lifecycleStatus = lifecycleStatus
            self.sessionId = sessionId
            self.startedAt = startedAt
            self.targetLifecycleStatus = targetLifecycleStatus
            self.updatedAt = updatedAt
            self.updatedBy = updatedBy
            self.workerId = workerId
        }

        private enum CodingKeys: String, CodingKey {
            case endedAt = "endedAt"
            case fleetId = "fleetId"
            case lifecycleStatus = "lifecycleStatus"
            case sessionId = "sessionId"
            case startedAt = "startedAt"
            case targetLifecycleStatus = "targetLifecycleStatus"
            case updatedAt = "updatedAt"
            case updatedBy = "updatedBy"
            case workerId = "workerId"
        }
    }

    public struct StartSessionsStatisticsAggregationRequest: AWSEncodableShape {
        /// The Linux timestamp of the date and time that the statistics end.
        @CustomCoding<ISO8601DateCoder>
        public var endTime: Date
        /// The identifier of the farm that contains queues or fleets to return statistics for.
        public let farmId: String
        /// The field to use to group the statistics.
        public let groupBy: [UsageGroupByField]
        /// The period to aggregate the statistics.
        public let period: Period?
        /// A list of fleet IDs or queue IDs to gather statistics for.
        public let resourceIds: SessionsStatisticsResources
        /// The Linux timestamp of the date and time that the statistics start.
        @CustomCoding<ISO8601DateCoder>
        public var startTime: Date
        /// One to four statistics to return.
        public let statistics: [UsageStatistic]
        /// The timezone to use for the statistics. Use UTC notation such as "UTC+8."
        public let timezone: String?

        @inlinable
        public init(endTime: Date, farmId: String, groupBy: [UsageGroupByField], period: Period? = nil, resourceIds: SessionsStatisticsResources, startTime: Date, statistics: [UsageStatistic], timezone: String? = nil) {
            self.endTime = endTime
            self.farmId = farmId
            self.groupBy = groupBy
            self.period = period
            self.resourceIds = resourceIds
            self.startTime = startTime
            self.statistics = statistics
            self.timezone = timezone
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encode(self.endTime, forKey: .endTime)
            request.encodePath(self.farmId, key: "farmId")
            try container.encode(self.groupBy, forKey: .groupBy)
            try container.encodeIfPresent(self.period, forKey: .period)
            try container.encode(self.resourceIds, forKey: .resourceIds)
            try container.encode(self.startTime, forKey: .startTime)
            try container.encode(self.statistics, forKey: .statistics)
            try container.encodeIfPresent(self.timezone, forKey: .timezone)
        }

        public func validate(name: String) throws {
            try self.validate(self.farmId, name: "farmId", parent: name, pattern: "^farm-[0-9a-f]{32}$")
            try self.validate(self.groupBy, name: "groupBy", parent: name, max: 2)
            try self.validate(self.groupBy, name: "groupBy", parent: name, min: 1)
            try self.resourceIds.validate(name: "\(name).resourceIds")
            try self.validate(self.statistics, name: "statistics", parent: name, max: 4)
            try self.validate(self.statistics, name: "statistics", parent: name, min: 1)
            try self.validate(self.timezone, name: "timezone", parent: name, max: 9)
            try self.validate(self.timezone, name: "timezone", parent: name, min: 9)
            try self.validate(self.timezone, name: "timezone", parent: name, pattern: "^UTC[-+][01][0-9]:(30|00)$")
        }

        private enum CodingKeys: String, CodingKey {
            case endTime = "endTime"
            case groupBy = "groupBy"
            case period = "period"
            case resourceIds = "resourceIds"
            case startTime = "startTime"
            case statistics = "statistics"
            case timezone = "timezone"
        }
    }

    public struct StartSessionsStatisticsAggregationResponse: AWSDecodableShape {
        /// A unique identifier for the aggregated statistics. Use this identifier with the GetAggregatedStatisticsForSessions operation to return the statistics.
        public let aggregationId: String

        @inlinable
        public init(aggregationId: String) {
            self.aggregationId = aggregationId
        }

        private enum CodingKeys: String, CodingKey {
            case aggregationId = "aggregationId"
        }
    }

    public struct Statistics: AWSDecodableShape {
        /// The end time for the aggregation.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var aggregationEndTime: Date?
        /// The start time for the aggregation.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var aggregationStartTime: Date?
        /// How the statistics should appear in USD. Options include: minimum, maximum, average or sum.
        public let costInUsd: Stats
        /// The number of instances in a list of statistics.
        public let count: Int
        /// The fleet ID.
        public let fleetId: String?
        /// The type of instance.
        public let instanceType: String?
        /// The job ID.
        public let jobId: String?
        /// The job name.
        public let jobName: String?
        /// The licensed product.
        public let licenseProduct: String?
        /// The queue ID.
        public let queueId: String?
        /// The total aggregated runtime.
        public let runtimeInSeconds: Stats
        /// The type of usage for the statistics.
        public let usageType: UsageType?
        /// The user ID.
        public let userId: String?

        @inlinable
        public init(aggregationEndTime: Date? = nil, aggregationStartTime: Date? = nil, costInUsd: Stats, count: Int, fleetId: String? = nil, instanceType: String? = nil, jobId: String? = nil, jobName: String? = nil, licenseProduct: String? = nil, queueId: String? = nil, runtimeInSeconds: Stats, usageType: UsageType? = nil, userId: String? = nil) {
            self.aggregationEndTime = aggregationEndTime
            self.aggregationStartTime = aggregationStartTime
            self.costInUsd = costInUsd
            self.count = count
            self.fleetId = fleetId
            self.instanceType = instanceType
            self.jobId = jobId
            self.jobName = jobName
            self.licenseProduct = licenseProduct
            self.queueId = queueId
            self.runtimeInSeconds = runtimeInSeconds
            self.usageType = usageType
            self.userId = userId
        }

        private enum CodingKeys: String, CodingKey {
            case aggregationEndTime = "aggregationEndTime"
            case aggregationStartTime = "aggregationStartTime"
            case costInUsd = "costInUsd"
            case count = "count"
            case fleetId = "fleetId"
            case instanceType = "instanceType"
            case jobId = "jobId"
            case jobName = "jobName"
            case licenseProduct = "licenseProduct"
            case queueId = "queueId"
            case runtimeInSeconds = "runtimeInSeconds"
            case usageType = "usageType"
            case userId = "userId"
        }
    }

    public struct Stats: AWSDecodableShape {
        /// The average of the usage statistics.
        public let avg: Double?
        /// The maximum among the usage statistics.
        public let max: Double?
        /// The minimum of the usage statistics.
        public let min: Double?
        /// The sum of the usage statistics.
        public let sum: Double?

        @inlinable
        public init(avg: Double? = nil, max: Double? = nil, min: Double? = nil, sum: Double? = nil) {
            self.avg = avg
            self.max = max
            self.min = min
            self.sum = sum
        }

        private enum CodingKeys: String, CodingKey {
            case avg = "avg"
            case max = "max"
            case min = "min"
            case sum = "sum"
        }
    }

    public struct StepAmountCapability: AWSDecodableShape {
        /// The maximum amount.
        public let max: Double?
        /// The minimum amount.
        public let min: Double?
        /// The name of the step.
        public let name: String
        /// The amount value.
        public let value: Double?

        @inlinable
        public init(max: Double? = nil, min: Double? = nil, name: String, value: Double? = nil) {
            self.max = max
            self.min = min
            self.name = name
            self.value = value
        }

        private enum CodingKeys: String, CodingKey {
            case max = "max"
            case min = "min"
            case name = "name"
            case value = "value"
        }
    }

    public struct StepAttributeCapability: AWSDecodableShape {
        /// Requires all of the step attribute values.
        public let allOf: [String]?
        /// Requires any of the step attributes in a given list.
        public let anyOf: [String]?
        /// The name of the step attribute.
        public let name: String

        @inlinable
        public init(allOf: [String]? = nil, anyOf: [String]? = nil, name: String) {
            self.allOf = allOf
            self.anyOf = anyOf
            self.name = name
        }

        private enum CodingKeys: String, CodingKey {
            case allOf = "allOf"
            case anyOf = "anyOf"
            case name = "name"
        }
    }

    public struct StepConsumer: AWSDecodableShape {
        /// The step consumer status.
        public let status: DependencyConsumerResolutionStatus
        /// The step ID.
        public let stepId: String

        @inlinable
        public init(status: DependencyConsumerResolutionStatus, stepId: String) {
            self.status = status
            self.stepId = stepId
        }

        private enum CodingKeys: String, CodingKey {
            case status = "status"
            case stepId = "stepId"
        }
    }

    public struct StepDependency: AWSDecodableShape {
        /// The step dependency status.
        public let status: DependencyConsumerResolutionStatus
        /// The step ID.
        public let stepId: String

        @inlinable
        public init(status: DependencyConsumerResolutionStatus, stepId: String) {
            self.status = status
            self.stepId = stepId
        }

        private enum CodingKeys: String, CodingKey {
            case status = "status"
            case stepId = "stepId"
        }
    }

    public struct StepDetailsEntity: AWSDecodableShape {
        /// The dependencies for a step.
        public let dependencies: [String]
        /// The job ID.
        public let jobId: String
        /// The schema version for a step template.
        public let schemaVersion: String
        /// The step ID.
        public let stepId: String
        /// The template for a step.
        public let template: AWSDocument

        @inlinable
        public init(dependencies: [String], jobId: String, schemaVersion: String, stepId: String, template: AWSDocument) {
            self.dependencies = dependencies
            self.jobId = jobId
            self.schemaVersion = schemaVersion
            self.stepId = stepId
            self.template = template
        }

        private enum CodingKeys: String, CodingKey {
            case dependencies = "dependencies"
            case jobId = "jobId"
            case schemaVersion = "schemaVersion"
            case stepId = "stepId"
            case template = "template"
        }
    }

    public struct StepDetailsError: AWSDecodableShape {
        /// The error code.
        public let code: JobEntityErrorCode
        /// The job ID.
        public let jobId: String
        /// The error message detailing the error's cause.
        public let message: String
        /// The step ID.
        public let stepId: String

        @inlinable
        public init(code: JobEntityErrorCode, jobId: String, message: String, stepId: String) {
            self.code = code
            self.jobId = jobId
            self.message = message
            self.stepId = stepId
        }

        private enum CodingKeys: String, CodingKey {
            case code = "code"
            case jobId = "jobId"
            case message = "message"
            case stepId = "stepId"
        }
    }

    public struct StepDetailsIdentifiers: AWSEncodableShape {
        /// The job ID.
        public let jobId: String
        /// The step ID.
        public let stepId: String

        @inlinable
        public init(jobId: String, stepId: String) {
            self.jobId = jobId
            self.stepId = stepId
        }

        public func validate(name: String) throws {
            try self.validate(self.jobId, name: "jobId", parent: name, pattern: "^job-[0-9a-f]{32}$")
            try self.validate(self.stepId, name: "stepId", parent: name, pattern: "^step-[0-9a-f]{32}$")
        }

        private enum CodingKeys: String, CodingKey {
            case jobId = "jobId"
            case stepId = "stepId"
        }
    }

    public struct StepParameter: AWSDecodableShape {
        /// The name of the parameter.
        public let name: String
        /// The data type of the parameter.
        public let type: StepParameterType

        @inlinable
        public init(name: String, type: StepParameterType) {
            self.name = name
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case name = "name"
            case type = "type"
        }
    }

    public struct StepRequiredCapabilities: AWSDecodableShape {
        /// The capability amounts that the step requires.
        public let amounts: [StepAmountCapability]
        /// The capability attributes that the step requires.
        public let attributes: [StepAttributeCapability]

        @inlinable
        public init(amounts: [StepAmountCapability], attributes: [StepAttributeCapability]) {
            self.amounts = amounts
            self.attributes = attributes
        }

        private enum CodingKeys: String, CodingKey {
            case amounts = "amounts"
            case attributes = "attributes"
        }
    }

    public struct StepSearchSummary: AWSDecodableShape {
        /// The date and time the resource was created.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var createdAt: Date?
        /// The date and time the resource ended running.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var endedAt: Date?
        /// The job ID.
        public let jobId: String?
        /// The life cycle status.
        public let lifecycleStatus: StepLifecycleStatus?
        /// The life cycle status message.
        public let lifecycleStatusMessage: String?
        /// The step name.
        public let name: String?
        /// The parameters and combination expressions for the search.
        public let parameterSpace: ParameterSpace?
        /// The queue ID.
        public let queueId: String?
        /// The date and time the resource started running.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var startedAt: Date?
        /// The step ID.
        public let stepId: String?
        /// The task status to start with on the job.
        public let targetTaskRunStatus: StepTargetTaskRunStatus?
        /// The task run status for the job.    PENDINGpending and waiting for resources.    READYready to be processed.    ASSIGNEDassigned and will run next on a worker.    SCHEDULEDscheduled to be run on a worker.    INTERRUPTINGbeing interrupted.    RUNNINGrunning on a worker.    SUSPENDEDthe task is suspended.    CANCELEDthe task has been canceled.    FAILEDthe task has failed.    SUCCEEDEDthe task has succeeded.
        public let taskRunStatus: TaskRunStatus?
        /// The number of tasks running on the job.
        public let taskRunStatusCounts: [TaskRunStatus: Int]?

        @inlinable
        public init(createdAt: Date? = nil, endedAt: Date? = nil, jobId: String? = nil, lifecycleStatus: StepLifecycleStatus? = nil, lifecycleStatusMessage: String? = nil, name: String? = nil, parameterSpace: ParameterSpace? = nil, queueId: String? = nil, startedAt: Date? = nil, stepId: String? = nil, targetTaskRunStatus: StepTargetTaskRunStatus? = nil, taskRunStatus: TaskRunStatus? = nil, taskRunStatusCounts: [TaskRunStatus: Int]? = nil) {
            self.createdAt = createdAt
            self.endedAt = endedAt
            self.jobId = jobId
            self.lifecycleStatus = lifecycleStatus
            self.lifecycleStatusMessage = lifecycleStatusMessage
            self.name = name
            self.parameterSpace = parameterSpace
            self.queueId = queueId
            self.startedAt = startedAt
            self.stepId = stepId
            self.targetTaskRunStatus = targetTaskRunStatus
            self.taskRunStatus = taskRunStatus
            self.taskRunStatusCounts = taskRunStatusCounts
        }

        private enum CodingKeys: String, CodingKey {
            case createdAt = "createdAt"
            case endedAt = "endedAt"
            case jobId = "jobId"
            case lifecycleStatus = "lifecycleStatus"
            case lifecycleStatusMessage = "lifecycleStatusMessage"
            case name = "name"
            case parameterSpace = "parameterSpace"
            case queueId = "queueId"
            case startedAt = "startedAt"
            case stepId = "stepId"
            case targetTaskRunStatus = "targetTaskRunStatus"
            case taskRunStatus = "taskRunStatus"
            case taskRunStatusCounts = "taskRunStatusCounts"
        }
    }

    public struct StepSummary: AWSDecodableShape {
        /// The date and time the resource was created.
        @CustomCoding<ISO8601DateCoder>
        public var createdAt: Date
        /// The user or system that created this resource.
        public let createdBy: String
        /// The number of dependencies for the step.
        public let dependencyCounts: DependencyCounts?
        /// The date and time the resource ended running.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var endedAt: Date?
        /// The life cycle status.
        public let lifecycleStatus: StepLifecycleStatus
        /// A message that describes the lifecycle of the step.
        public let lifecycleStatusMessage: String?
        /// The name of the step.
        public let name: String
        /// The date and time the resource started running.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var startedAt: Date?
        /// The step ID.
        public let stepId: String
        /// The task status to start with on the job.
        public let targetTaskRunStatus: StepTargetTaskRunStatus?
        /// The task run status for the job.    PENDINGpending and waiting for resources.    READYready to process.    ASSIGNEDassigned and will run next on a worker.    SCHEDULEDscheduled to run on a worker.    INTERRUPTINGbeing interrupted.    RUNNINGrunning on a worker.    SUSPENDEDthe task is suspended.    CANCELEDthe task has been canceled.    FAILEDthe task has failed.    SUCCEEDEDthe task has succeeded.
        public let taskRunStatus: TaskRunStatus
        /// The number of tasks running on the job.
        public let taskRunStatusCounts: [TaskRunStatus: Int]
        /// The date and time the resource was updated.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var updatedAt: Date?
        /// The user or system that updated this resource.
        public let updatedBy: String?

        @inlinable
        public init(createdAt: Date, createdBy: String, dependencyCounts: DependencyCounts? = nil, endedAt: Date? = nil, lifecycleStatus: StepLifecycleStatus, lifecycleStatusMessage: String? = nil, name: String, startedAt: Date? = nil, stepId: String, targetTaskRunStatus: StepTargetTaskRunStatus? = nil, taskRunStatus: TaskRunStatus, taskRunStatusCounts: [TaskRunStatus: Int], updatedAt: Date? = nil, updatedBy: String? = nil) {
            self.createdAt = createdAt
            self.createdBy = createdBy
            self.dependencyCounts = dependencyCounts
            self.endedAt = endedAt
            self.lifecycleStatus = lifecycleStatus
            self.lifecycleStatusMessage = lifecycleStatusMessage
            self.name = name
            self.startedAt = startedAt
            self.stepId = stepId
            self.targetTaskRunStatus = targetTaskRunStatus
            self.taskRunStatus = taskRunStatus
            self.taskRunStatusCounts = taskRunStatusCounts
            self.updatedAt = updatedAt
            self.updatedBy = updatedBy
        }

        private enum CodingKeys: String, CodingKey {
            case createdAt = "createdAt"
            case createdBy = "createdBy"
            case dependencyCounts = "dependencyCounts"
            case endedAt = "endedAt"
            case lifecycleStatus = "lifecycleStatus"
            case lifecycleStatusMessage = "lifecycleStatusMessage"
            case name = "name"
            case startedAt = "startedAt"
            case stepId = "stepId"
            case targetTaskRunStatus = "targetTaskRunStatus"
            case taskRunStatus = "taskRunStatus"
            case taskRunStatusCounts = "taskRunStatusCounts"
            case updatedAt = "updatedAt"
            case updatedBy = "updatedBy"
        }
    }

    public struct StorageProfileSummary: AWSDecodableShape {
        /// The display name of the storage profile summary to update.  This field can store any content. Escape or encode this content before displaying it on a webpage or any other system that might interpret the content of this field.
        public let displayName: String
        /// The operating system (OS) family.
        public let osFamily: StorageProfileOperatingSystemFamily
        /// The storage profile ID.
        public let storageProfileId: String

        @inlinable
        public init(displayName: String, osFamily: StorageProfileOperatingSystemFamily, storageProfileId: String) {
            self.displayName = displayName
            self.osFamily = osFamily
            self.storageProfileId = storageProfileId
        }

        private enum CodingKeys: String, CodingKey {
            case displayName = "displayName"
            case osFamily = "osFamily"
            case storageProfileId = "storageProfileId"
        }
    }

    public struct StringFilterExpression: AWSEncodableShape {
        /// The field name to search.
        public let name: String
        /// The type of comparison to use for this search.
        public let `operator`: ComparisonOperator
        /// The string to search for.
        public let value: String

        @inlinable
        public init(name: String, operator: ComparisonOperator, value: String) {
            self.name = name
            self.`operator` = `operator`
            self.value = value
        }

        public func validate(name: String) throws {
            try self.validate(self.value, name: "value", parent: name, max: 256)
            try self.validate(self.value, name: "value", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case name = "name"
            case `operator` = "operator"
            case value = "value"
        }
    }

    public struct SyncInputJobAttachmentsSessionActionDefinition: AWSDecodableShape {
        /// The step ID for the step in the job attachment.
        public let stepId: String?

        @inlinable
        public init(stepId: String? = nil) {
            self.stepId = stepId
        }

        private enum CodingKeys: String, CodingKey {
            case stepId = "stepId"
        }
    }

    public struct SyncInputJobAttachmentsSessionActionDefinitionSummary: AWSDecodableShape {
        /// The step ID of the step in the job attachment.
        public let stepId: String?

        @inlinable
        public init(stepId: String? = nil) {
            self.stepId = stepId
        }

        private enum CodingKeys: String, CodingKey {
            case stepId = "stepId"
        }
    }

    public struct TagResourceRequest: AWSEncodableShape {
        /// The ARN of the resource to apply tags to.
        public let resourceArn: String
        /// Each tag consists of a tag key and a tag value. Tag keys and values are both required, but tag values can be empty strings.
        public let tags: [String: String]?

        @inlinable
        public init(resourceArn: String, tags: [String: String]? = nil) {
            self.resourceArn = resourceArn
            self.tags = tags
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.resourceArn, key: "resourceArn")
            try container.encodeIfPresent(self.tags, forKey: .tags)
        }

        private enum CodingKeys: String, CodingKey {
            case tags = "tags"
        }
    }

    public struct TagResourceResponse: AWSDecodableShape {
        public init() {}
    }

    public struct TaskRunSessionActionDefinition: AWSDecodableShape {
        /// The task parameters.
        public let parameters: [String: TaskParameterValue]
        /// The step ID.
        public let stepId: String
        /// The task ID.
        public let taskId: String?

        @inlinable
        public init(parameters: [String: TaskParameterValue], stepId: String, taskId: String? = nil) {
            self.parameters = parameters
            self.stepId = stepId
            self.taskId = taskId
        }

        private enum CodingKeys: String, CodingKey {
            case parameters = "parameters"
            case stepId = "stepId"
            case taskId = "taskId"
        }
    }

    public struct TaskRunSessionActionDefinitionSummary: AWSDecodableShape {
        /// The step ID.
        public let stepId: String
        /// The task ID.
        public let taskId: String?

        @inlinable
        public init(stepId: String, taskId: String? = nil) {
            self.stepId = stepId
            self.taskId = taskId
        }

        private enum CodingKeys: String, CodingKey {
            case stepId = "stepId"
            case taskId = "taskId"
        }
    }

    public struct TaskSearchSummary: AWSDecodableShape {
        /// The date and time the resource ended running.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var endedAt: Date?
        /// The number of times that the task failed and was retried.
        public let failureRetryCount: Int?
        /// The job ID.
        public let jobId: String?
        /// The parameters to search for.
        public let parameters: [String: TaskParameterValue]?
        /// The queue ID.
        public let queueId: String?
        /// The run status of the task.
        public let runStatus: TaskRunStatus?
        /// The date and time the resource started running.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var startedAt: Date?
        /// The step ID.
        public let stepId: String?
        /// The run status that the task is being updated to.
        public let targetRunStatus: TaskTargetRunStatus?
        /// The task ID.
        public let taskId: String?

        @inlinable
        public init(endedAt: Date? = nil, failureRetryCount: Int? = nil, jobId: String? = nil, parameters: [String: TaskParameterValue]? = nil, queueId: String? = nil, runStatus: TaskRunStatus? = nil, startedAt: Date? = nil, stepId: String? = nil, targetRunStatus: TaskTargetRunStatus? = nil, taskId: String? = nil) {
            self.endedAt = endedAt
            self.failureRetryCount = failureRetryCount
            self.jobId = jobId
            self.parameters = parameters
            self.queueId = queueId
            self.runStatus = runStatus
            self.startedAt = startedAt
            self.stepId = stepId
            self.targetRunStatus = targetRunStatus
            self.taskId = taskId
        }

        private enum CodingKeys: String, CodingKey {
            case endedAt = "endedAt"
            case failureRetryCount = "failureRetryCount"
            case jobId = "jobId"
            case parameters = "parameters"
            case queueId = "queueId"
            case runStatus = "runStatus"
            case startedAt = "startedAt"
            case stepId = "stepId"
            case targetRunStatus = "targetRunStatus"
            case taskId = "taskId"
        }
    }

    public struct TaskSummary: AWSDecodableShape {
        /// The date and time the resource was created.
        @CustomCoding<ISO8601DateCoder>
        public var createdAt: Date
        /// The user or system that created this resource.
        public let createdBy: String
        /// The date and time the resource ended running.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var endedAt: Date?
        /// The number of times that the task failed and was retried.
        public let failureRetryCount: Int?
        /// The latest session action for the task.
        public let latestSessionActionId: String?
        /// The task parameters.
        public let parameters: [String: TaskParameterValue]?
        /// The run status of the task.
        public let runStatus: TaskRunStatus
        /// The date and time the resource started running.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var startedAt: Date?
        /// The run status on which the started.
        public let targetRunStatus: TaskTargetRunStatus?
        /// The task ID.
        public let taskId: String
        /// The date and time the resource was updated.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var updatedAt: Date?
        /// The user or system that updated this resource.
        public let updatedBy: String?

        @inlinable
        public init(createdAt: Date, createdBy: String, endedAt: Date? = nil, failureRetryCount: Int? = nil, latestSessionActionId: String? = nil, parameters: [String: TaskParameterValue]? = nil, runStatus: TaskRunStatus, startedAt: Date? = nil, targetRunStatus: TaskTargetRunStatus? = nil, taskId: String, updatedAt: Date? = nil, updatedBy: String? = nil) {
            self.createdAt = createdAt
            self.createdBy = createdBy
            self.endedAt = endedAt
            self.failureRetryCount = failureRetryCount
            self.latestSessionActionId = latestSessionActionId
            self.parameters = parameters
            self.runStatus = runStatus
            self.startedAt = startedAt
            self.targetRunStatus = targetRunStatus
            self.taskId = taskId
            self.updatedAt = updatedAt
            self.updatedBy = updatedBy
        }

        private enum CodingKeys: String, CodingKey {
            case createdAt = "createdAt"
            case createdBy = "createdBy"
            case endedAt = "endedAt"
            case failureRetryCount = "failureRetryCount"
            case latestSessionActionId = "latestSessionActionId"
            case parameters = "parameters"
            case runStatus = "runStatus"
            case startedAt = "startedAt"
            case targetRunStatus = "targetRunStatus"
            case taskId = "taskId"
            case updatedAt = "updatedAt"
            case updatedBy = "updatedBy"
        }
    }

    public struct ThrottlingException: AWSErrorShape {
        /// Information about the resources in use when the exception was thrown.
        public let context: [String: String]?
        public let message: String
        /// Identifies the quota that is being throttled.
        public let quotaCode: String?
        /// The number of seconds a client should wait before retrying the request.
        public let retryAfterSeconds: Int?
        /// Identifies the service that is being throttled.
        public let serviceCode: String?

        @inlinable
        public init(context: [String: String]? = nil, message: String, quotaCode: String? = nil, retryAfterSeconds: Int? = nil, serviceCode: String? = nil) {
            self.context = context
            self.message = message
            self.quotaCode = quotaCode
            self.retryAfterSeconds = retryAfterSeconds
            self.serviceCode = serviceCode
        }

        public init(from decoder: Decoder) throws {
            let response = decoder.userInfo[.awsResponse]! as! ResponseDecodingContainer
            let container = try decoder.container(keyedBy: CodingKeys.self)
            self.context = try container.decodeIfPresent([String: String].self, forKey: .context)
            self.message = try container.decode(String.self, forKey: .message)
            self.quotaCode = try container.decodeIfPresent(String.self, forKey: .quotaCode)
            self.retryAfterSeconds = try response.decodeHeaderIfPresent(Int.self, key: "Retry-After")
            self.serviceCode = try container.decodeIfPresent(String.self, forKey: .serviceCode)
        }

        private enum CodingKeys: String, CodingKey {
            case context = "context"
            case message = "message"
            case quotaCode = "quotaCode"
            case serviceCode = "serviceCode"
        }
    }

    public struct UntagResourceRequest: AWSEncodableShape {
        /// The ARN of the resource to remove the tag from.
        public let resourceArn: String
        /// They keys of the tag.
        public let tagKeys: [String]

        @inlinable
        public init(resourceArn: String, tagKeys: [String]) {
            self.resourceArn = resourceArn
            self.tagKeys = tagKeys
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.resourceArn, key: "resourceArn")
            request.encodeQuery(self.tagKeys, key: "tagKeys")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct UntagResourceResponse: AWSDecodableShape {
        public init() {}
    }

    public struct UpdateBudgetRequest: AWSEncodableShape {
        /// The budget actions to add. Budget actions specify what happens when the budget runs out.
        public let actionsToAdd: [BudgetActionToAdd]?
        /// The budget actions to remove from the budget.
        public let actionsToRemove: [BudgetActionToRemove]?
        /// The dollar limit to update on the budget. Based on consumed usage.
        public let approximateDollarLimit: Float?
        /// The budget ID to update.
        public let budgetId: String
        /// The unique token which the server uses to recognize retries of the same request.
        public let clientToken: String?
        /// The description of the budget to update.  This field can store any content. Escape or encode this content before displaying it on a webpage or any other system that might interpret the content of this field.
        public let description: String?
        /// The display name of the budget to update.  This field can store any content. Escape or encode this content before displaying it on a webpage or any other system that might interpret the content of this field.
        public let displayName: String?
        /// The farm ID of the budget to update.
        public let farmId: String
        /// The schedule to update.
        public let schedule: BudgetSchedule?
        /// Updates the status of the budget.    ACTIVEThe budget is being evaluated.    INACTIVEThe budget is inactive. This can include Expired, Canceled, or deleted Deleted statuses.
        public let status: BudgetStatus?

        @inlinable
        public init(actionsToAdd: [BudgetActionToAdd]? = nil, actionsToRemove: [BudgetActionToRemove]? = nil, approximateDollarLimit: Float? = nil, budgetId: String, clientToken: String? = UpdateBudgetRequest.idempotencyToken(), description: String? = nil, displayName: String? = nil, farmId: String, schedule: BudgetSchedule? = nil, status: BudgetStatus? = nil) {
            self.actionsToAdd = actionsToAdd
            self.actionsToRemove = actionsToRemove
            self.approximateDollarLimit = approximateDollarLimit
            self.budgetId = budgetId
            self.clientToken = clientToken
            self.description = description
            self.displayName = displayName
            self.farmId = farmId
            self.schedule = schedule
            self.status = status
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.actionsToAdd, forKey: .actionsToAdd)
            try container.encodeIfPresent(self.actionsToRemove, forKey: .actionsToRemove)
            try container.encodeIfPresent(self.approximateDollarLimit, forKey: .approximateDollarLimit)
            request.encodePath(self.budgetId, key: "budgetId")
            request.encodeHeader(self.clientToken, key: "X-Amz-Client-Token")
            try container.encodeIfPresent(self.description, forKey: .description)
            try container.encodeIfPresent(self.displayName, forKey: .displayName)
            request.encodePath(self.farmId, key: "farmId")
            try container.encodeIfPresent(self.schedule, forKey: .schedule)
            try container.encodeIfPresent(self.status, forKey: .status)
        }

        public func validate(name: String) throws {
            try self.actionsToAdd?.forEach {
                try $0.validate(name: "\(name).actionsToAdd[]")
            }
            try self.validate(self.actionsToAdd, name: "actionsToAdd", parent: name, max: 10)
            try self.actionsToRemove?.forEach {
                try $0.validate(name: "\(name).actionsToRemove[]")
            }
            try self.validate(self.actionsToRemove, name: "actionsToRemove", parent: name, max: 10)
            try self.validate(self.approximateDollarLimit, name: "approximateDollarLimit", parent: name, min: 0.01)
            try self.validate(self.budgetId, name: "budgetId", parent: name, pattern: "^budget-[0-9a-f]{32}$")
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 64)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.validate(self.description, name: "description", parent: name, max: 100)
            try self.validate(self.displayName, name: "displayName", parent: name, max: 100)
            try self.validate(self.displayName, name: "displayName", parent: name, min: 1)
            try self.validate(self.farmId, name: "farmId", parent: name, pattern: "^farm-[0-9a-f]{32}$")
        }

        private enum CodingKeys: String, CodingKey {
            case actionsToAdd = "actionsToAdd"
            case actionsToRemove = "actionsToRemove"
            case approximateDollarLimit = "approximateDollarLimit"
            case description = "description"
            case displayName = "displayName"
            case schedule = "schedule"
            case status = "status"
        }
    }

    public struct UpdateBudgetResponse: AWSDecodableShape {
        public init() {}
    }

    public struct UpdateFarmRequest: AWSEncodableShape {
        /// The description of the farm to update.  This field can store any content. Escape or encode this content before displaying it on a webpage or any other system that might interpret the content of this field.
        public let description: String?
        /// The display name of the farm to update.  This field can store any content. Escape or encode this content before displaying it on a webpage or any other system that might interpret the content of this field.
        public let displayName: String?
        /// The farm ID to update.
        public let farmId: String

        @inlinable
        public init(description: String? = nil, displayName: String? = nil, farmId: String) {
            self.description = description
            self.displayName = displayName
            self.farmId = farmId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.description, forKey: .description)
            try container.encodeIfPresent(self.displayName, forKey: .displayName)
            request.encodePath(self.farmId, key: "farmId")
        }

        public func validate(name: String) throws {
            try self.validate(self.description, name: "description", parent: name, max: 100)
            try self.validate(self.displayName, name: "displayName", parent: name, max: 100)
            try self.validate(self.displayName, name: "displayName", parent: name, min: 1)
            try self.validate(self.farmId, name: "farmId", parent: name, pattern: "^farm-[0-9a-f]{32}$")
        }

        private enum CodingKeys: String, CodingKey {
            case description = "description"
            case displayName = "displayName"
        }
    }

    public struct UpdateFarmResponse: AWSDecodableShape {
        public init() {}
    }

    public struct UpdateFleetRequest: AWSEncodableShape {
        /// The unique token which the server uses to recognize retries of the same request.
        public let clientToken: String?
        /// The fleet configuration to update.
        public let configuration: FleetConfiguration?
        /// The description of the fleet to update.  This field can store any content. Escape or encode this content before displaying it on a webpage or any other system that might interpret the content of this field.
        public let description: String?
        /// The display name of the fleet to update.  This field can store any content. Escape or encode this content before displaying it on a webpage or any other system that might interpret the content of this field.
        public let displayName: String?
        /// The farm ID to update.
        public let farmId: String
        /// The fleet ID to update.
        public let fleetId: String
        /// The maximum number of workers in the fleet.
        public let maxWorkerCount: Int?
        /// The minimum number of workers in the fleet.
        public let minWorkerCount: Int?
        /// The IAM role ARN that the fleet's workers assume while running jobs.
        public let roleArn: String?

        @inlinable
        public init(clientToken: String? = UpdateFleetRequest.idempotencyToken(), configuration: FleetConfiguration? = nil, description: String? = nil, displayName: String? = nil, farmId: String, fleetId: String, maxWorkerCount: Int? = nil, minWorkerCount: Int? = nil, roleArn: String? = nil) {
            self.clientToken = clientToken
            self.configuration = configuration
            self.description = description
            self.displayName = displayName
            self.farmId = farmId
            self.fleetId = fleetId
            self.maxWorkerCount = maxWorkerCount
            self.minWorkerCount = minWorkerCount
            self.roleArn = roleArn
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodeHeader(self.clientToken, key: "X-Amz-Client-Token")
            try container.encodeIfPresent(self.configuration, forKey: .configuration)
            try container.encodeIfPresent(self.description, forKey: .description)
            try container.encodeIfPresent(self.displayName, forKey: .displayName)
            request.encodePath(self.farmId, key: "farmId")
            request.encodePath(self.fleetId, key: "fleetId")
            try container.encodeIfPresent(self.maxWorkerCount, forKey: .maxWorkerCount)
            try container.encodeIfPresent(self.minWorkerCount, forKey: .minWorkerCount)
            try container.encodeIfPresent(self.roleArn, forKey: .roleArn)
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 64)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.configuration?.validate(name: "\(name).configuration")
            try self.validate(self.description, name: "description", parent: name, max: 100)
            try self.validate(self.displayName, name: "displayName", parent: name, max: 100)
            try self.validate(self.displayName, name: "displayName", parent: name, min: 1)
            try self.validate(self.farmId, name: "farmId", parent: name, pattern: "^farm-[0-9a-f]{32}$")
            try self.validate(self.fleetId, name: "fleetId", parent: name, pattern: "^fleet-[0-9a-f]{32}$")
            try self.validate(self.maxWorkerCount, name: "maxWorkerCount", parent: name, max: 2147483647)
            try self.validate(self.maxWorkerCount, name: "maxWorkerCount", parent: name, min: 0)
            try self.validate(self.minWorkerCount, name: "minWorkerCount", parent: name, max: 2147483647)
            try self.validate(self.minWorkerCount, name: "minWorkerCount", parent: name, min: 0)
            try self.validate(self.roleArn, name: "roleArn", parent: name, pattern: "^arn:(aws[a-zA-Z-]*):iam::\\d{12}:role(/[!-.0-~]+)*/[\\w+=,.@-]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case configuration = "configuration"
            case description = "description"
            case displayName = "displayName"
            case maxWorkerCount = "maxWorkerCount"
            case minWorkerCount = "minWorkerCount"
            case roleArn = "roleArn"
        }
    }

    public struct UpdateFleetResponse: AWSDecodableShape {
        public init() {}
    }

    public struct UpdateJobRequest: AWSEncodableShape {
        /// The unique token which the server uses to recognize retries of the same request.
        public let clientToken: String?
        /// The farm ID of the job to update.
        public let farmId: String
        /// The job ID to update.
        public let jobId: String
        /// The status of a job in its lifecycle. When you change the status of the job to ARCHIVED, the job can't be scheduled or archived.  An archived jobs and its steps and tasks are deleted after 120 days. The job can't be recovered.
        public let lifecycleStatus: UpdateJobLifecycleStatus?
        /// The number of task failures before the job stops running and is marked as FAILED.
        public let maxFailedTasksCount: Int?
        /// The maximum number of retries for a job.
        public let maxRetriesPerTask: Int?
        /// The maximum number of worker hosts that can concurrently process a job. When the maxWorkerCount is reached, no more workers will be assigned to process the job, even if the fleets assigned to the job's queue has available workers. You can't set the maxWorkerCount to 0. If you set it to -1, there is no maximum number of workers. If you don't specify the maxWorkerCount, the default is -1. The maximum number of workers that can process tasks in the job.
        public let maxWorkerCount: Int?
        /// The job priority to update.
        public let priority: Int?
        /// The queue ID of the job to update.
        public let queueId: String
        /// The task status to update the job's tasks to.
        public let targetTaskRunStatus: JobTargetTaskRunStatus?

        @inlinable
        public init(clientToken: String? = UpdateJobRequest.idempotencyToken(), farmId: String, jobId: String, lifecycleStatus: UpdateJobLifecycleStatus? = nil, maxFailedTasksCount: Int? = nil, maxRetriesPerTask: Int? = nil, maxWorkerCount: Int? = nil, priority: Int? = nil, queueId: String, targetTaskRunStatus: JobTargetTaskRunStatus? = nil) {
            self.clientToken = clientToken
            self.farmId = farmId
            self.jobId = jobId
            self.lifecycleStatus = lifecycleStatus
            self.maxFailedTasksCount = maxFailedTasksCount
            self.maxRetriesPerTask = maxRetriesPerTask
            self.maxWorkerCount = maxWorkerCount
            self.priority = priority
            self.queueId = queueId
            self.targetTaskRunStatus = targetTaskRunStatus
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodeHeader(self.clientToken, key: "X-Amz-Client-Token")
            request.encodePath(self.farmId, key: "farmId")
            request.encodePath(self.jobId, key: "jobId")
            try container.encodeIfPresent(self.lifecycleStatus, forKey: .lifecycleStatus)
            try container.encodeIfPresent(self.maxFailedTasksCount, forKey: .maxFailedTasksCount)
            try container.encodeIfPresent(self.maxRetriesPerTask, forKey: .maxRetriesPerTask)
            try container.encodeIfPresent(self.maxWorkerCount, forKey: .maxWorkerCount)
            try container.encodeIfPresent(self.priority, forKey: .priority)
            request.encodePath(self.queueId, key: "queueId")
            try container.encodeIfPresent(self.targetTaskRunStatus, forKey: .targetTaskRunStatus)
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 64)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.validate(self.farmId, name: "farmId", parent: name, pattern: "^farm-[0-9a-f]{32}$")
            try self.validate(self.jobId, name: "jobId", parent: name, pattern: "^job-[0-9a-f]{32}$")
            try self.validate(self.maxFailedTasksCount, name: "maxFailedTasksCount", parent: name, max: 2147483647)
            try self.validate(self.maxFailedTasksCount, name: "maxFailedTasksCount", parent: name, min: 0)
            try self.validate(self.maxRetriesPerTask, name: "maxRetriesPerTask", parent: name, max: 2147483647)
            try self.validate(self.maxRetriesPerTask, name: "maxRetriesPerTask", parent: name, min: 0)
            try self.validate(self.maxWorkerCount, name: "maxWorkerCount", parent: name, max: 2147483647)
            try self.validate(self.maxWorkerCount, name: "maxWorkerCount", parent: name, min: -1)
            try self.validate(self.priority, name: "priority", parent: name, max: 100)
            try self.validate(self.priority, name: "priority", parent: name, min: 0)
            try self.validate(self.queueId, name: "queueId", parent: name, pattern: "^queue-[0-9a-f]{32}$")
        }

        private enum CodingKeys: String, CodingKey {
            case lifecycleStatus = "lifecycleStatus"
            case maxFailedTasksCount = "maxFailedTasksCount"
            case maxRetriesPerTask = "maxRetriesPerTask"
            case maxWorkerCount = "maxWorkerCount"
            case priority = "priority"
            case targetTaskRunStatus = "targetTaskRunStatus"
        }
    }

    public struct UpdateJobResponse: AWSDecodableShape {
        public init() {}
    }

    public struct UpdateLimitRequest: AWSEncodableShape {
        /// The new description of the limit.  This field can store any content. Escape or encode this content before displaying it on a webpage or any other system that might interpret the content of this field.
        public let description: String?
        /// The new display name of the limit.  This field can store any content. Escape or encode this content before displaying it on a webpage or any other system that might interpret the content of this field.
        public let displayName: String?
        /// The unique identifier of the farm that contains the limit.
        public let farmId: String
        /// The unique identifier of the limit to update.
        public let limitId: String
        /// The maximum number of resources constrained by this limit. When all of the resources are in use, steps that require the limit won't be scheduled until the resource is available. If more than the new maximum number is currently in use, running jobs finish but no new jobs are started until the number of resources in use is below the new maximum number. The maxCount must not be 0. If the value is -1, there is no restriction on the number of resources that can be acquired for this limit.
        public let maxCount: Int?

        @inlinable
        public init(description: String? = nil, displayName: String? = nil, farmId: String, limitId: String, maxCount: Int? = nil) {
            self.description = description
            self.displayName = displayName
            self.farmId = farmId
            self.limitId = limitId
            self.maxCount = maxCount
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.description, forKey: .description)
            try container.encodeIfPresent(self.displayName, forKey: .displayName)
            request.encodePath(self.farmId, key: "farmId")
            request.encodePath(self.limitId, key: "limitId")
            try container.encodeIfPresent(self.maxCount, forKey: .maxCount)
        }

        public func validate(name: String) throws {
            try self.validate(self.description, name: "description", parent: name, max: 100)
            try self.validate(self.displayName, name: "displayName", parent: name, max: 100)
            try self.validate(self.displayName, name: "displayName", parent: name, min: 1)
            try self.validate(self.farmId, name: "farmId", parent: name, pattern: "^farm-[0-9a-f]{32}$")
            try self.validate(self.limitId, name: "limitId", parent: name, pattern: "^limit-[0-9a-f]{32}$")
            try self.validate(self.maxCount, name: "maxCount", parent: name, max: 2147483647)
            try self.validate(self.maxCount, name: "maxCount", parent: name, min: -1)
        }

        private enum CodingKeys: String, CodingKey {
            case description = "description"
            case displayName = "displayName"
            case maxCount = "maxCount"
        }
    }

    public struct UpdateLimitResponse: AWSDecodableShape {
        public init() {}
    }

    public struct UpdateMonitorRequest: AWSEncodableShape {
        /// The new value to use for the monitor's display name.  This field can store any content. Escape or encode this content before displaying it on a webpage or any other system that might interpret the content of this field.
        public let displayName: String?
        /// The unique identifier of the monitor to update.
        public let monitorId: String
        /// The Amazon Resource Name (ARN) of the new IAM role to use with the monitor.
        public let roleArn: String?
        /// The new value of the subdomain to use when forming the monitor URL.
        public let subdomain: String?

        @inlinable
        public init(displayName: String? = nil, monitorId: String, roleArn: String? = nil, subdomain: String? = nil) {
            self.displayName = displayName
            self.monitorId = monitorId
            self.roleArn = roleArn
            self.subdomain = subdomain
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.displayName, forKey: .displayName)
            request.encodePath(self.monitorId, key: "monitorId")
            try container.encodeIfPresent(self.roleArn, forKey: .roleArn)
            try container.encodeIfPresent(self.subdomain, forKey: .subdomain)
        }

        public func validate(name: String) throws {
            try self.validate(self.displayName, name: "displayName", parent: name, max: 100)
            try self.validate(self.displayName, name: "displayName", parent: name, min: 1)
            try self.validate(self.monitorId, name: "monitorId", parent: name, pattern: "^monitor-[0-9a-f]{32}$")
            try self.validate(self.roleArn, name: "roleArn", parent: name, pattern: "^arn:(aws[a-zA-Z-]*):iam::\\d{12}:role(/[!-.0-~]+)*/[\\w+=,.@-]+$")
            try self.validate(self.subdomain, name: "subdomain", parent: name, pattern: "^[a-z0-9-]{1,100}$")
        }

        private enum CodingKeys: String, CodingKey {
            case displayName = "displayName"
            case roleArn = "roleArn"
            case subdomain = "subdomain"
        }
    }

    public struct UpdateMonitorResponse: AWSDecodableShape {
        public init() {}
    }

    public struct UpdateQueueEnvironmentRequest: AWSEncodableShape {
        /// The unique token which the server uses to recognize retries of the same request.
        public let clientToken: String?
        /// The farm ID of the queue environment to update.
        public let farmId: String
        /// The priority to update.
        public let priority: Int?
        /// The queue environment ID to update.
        public let queueEnvironmentId: String
        /// The queue ID of the queue environment to update.
        public let queueId: String
        /// The template to update.
        public let template: String?
        /// The template type to update.
        public let templateType: EnvironmentTemplateType?

        @inlinable
        public init(clientToken: String? = UpdateQueueEnvironmentRequest.idempotencyToken(), farmId: String, priority: Int? = nil, queueEnvironmentId: String, queueId: String, template: String? = nil, templateType: EnvironmentTemplateType? = nil) {
            self.clientToken = clientToken
            self.farmId = farmId
            self.priority = priority
            self.queueEnvironmentId = queueEnvironmentId
            self.queueId = queueId
            self.template = template
            self.templateType = templateType
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodeHeader(self.clientToken, key: "X-Amz-Client-Token")
            request.encodePath(self.farmId, key: "farmId")
            try container.encodeIfPresent(self.priority, forKey: .priority)
            request.encodePath(self.queueEnvironmentId, key: "queueEnvironmentId")
            request.encodePath(self.queueId, key: "queueId")
            try container.encodeIfPresent(self.template, forKey: .template)
            try container.encodeIfPresent(self.templateType, forKey: .templateType)
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 64)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.validate(self.farmId, name: "farmId", parent: name, pattern: "^farm-[0-9a-f]{32}$")
            try self.validate(self.priority, name: "priority", parent: name, max: 10000)
            try self.validate(self.priority, name: "priority", parent: name, min: 0)
            try self.validate(self.queueEnvironmentId, name: "queueEnvironmentId", parent: name, pattern: "^queueenv-[0-9a-f]{32}$")
            try self.validate(self.queueId, name: "queueId", parent: name, pattern: "^queue-[0-9a-f]{32}$")
            try self.validate(self.template, name: "template", parent: name, max: 15000)
            try self.validate(self.template, name: "template", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case priority = "priority"
            case template = "template"
            case templateType = "templateType"
        }
    }

    public struct UpdateQueueEnvironmentResponse: AWSDecodableShape {
        public init() {}
    }

    public struct UpdateQueueFleetAssociationRequest: AWSEncodableShape {
        /// The farm ID to update.
        public let farmId: String
        /// The fleet ID to update.
        public let fleetId: String
        /// The queue ID to update.
        public let queueId: String
        /// The status to update.
        public let status: UpdateQueueFleetAssociationStatus

        @inlinable
        public init(farmId: String, fleetId: String, queueId: String, status: UpdateQueueFleetAssociationStatus) {
            self.farmId = farmId
            self.fleetId = fleetId
            self.queueId = queueId
            self.status = status
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.farmId, key: "farmId")
            request.encodePath(self.fleetId, key: "fleetId")
            request.encodePath(self.queueId, key: "queueId")
            try container.encode(self.status, forKey: .status)
        }

        public func validate(name: String) throws {
            try self.validate(self.farmId, name: "farmId", parent: name, pattern: "^farm-[0-9a-f]{32}$")
            try self.validate(self.fleetId, name: "fleetId", parent: name, pattern: "^fleet-[0-9a-f]{32}$")
            try self.validate(self.queueId, name: "queueId", parent: name, pattern: "^queue-[0-9a-f]{32}$")
        }

        private enum CodingKeys: String, CodingKey {
            case status = "status"
        }
    }

    public struct UpdateQueueFleetAssociationResponse: AWSDecodableShape {
        public init() {}
    }

    public struct UpdateQueueLimitAssociationRequest: AWSEncodableShape {
        /// The unique identifier of the farm that contains the associated queues and limits.
        public let farmId: String
        /// The unique identifier of the limit associated to the queue.
        public let limitId: String
        /// The unique identifier of the queue associated to the limit.
        public let queueId: String
        /// Sets the status of the limit. You can mark the limit active, or you can stop usage of the limit and either complete existing tasks or cancel any existing tasks immediately.
        public let status: UpdateQueueLimitAssociationStatus

        @inlinable
        public init(farmId: String, limitId: String, queueId: String, status: UpdateQueueLimitAssociationStatus) {
            self.farmId = farmId
            self.limitId = limitId
            self.queueId = queueId
            self.status = status
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.farmId, key: "farmId")
            request.encodePath(self.limitId, key: "limitId")
            request.encodePath(self.queueId, key: "queueId")
            try container.encode(self.status, forKey: .status)
        }

        public func validate(name: String) throws {
            try self.validate(self.farmId, name: "farmId", parent: name, pattern: "^farm-[0-9a-f]{32}$")
            try self.validate(self.limitId, name: "limitId", parent: name, pattern: "^limit-[0-9a-f]{32}$")
            try self.validate(self.queueId, name: "queueId", parent: name, pattern: "^queue-[0-9a-f]{32}$")
        }

        private enum CodingKeys: String, CodingKey {
            case status = "status"
        }
    }

    public struct UpdateQueueLimitAssociationResponse: AWSDecodableShape {
        public init() {}
    }

    public struct UpdateQueueRequest: AWSEncodableShape {
        /// The storage profile IDs to add.
        public let allowedStorageProfileIdsToAdd: [String]?
        /// The storage profile ID to remove.
        public let allowedStorageProfileIdsToRemove: [String]?
        /// The idempotency token to update in the queue.
        public let clientToken: String?
        /// The default action to take for a queue update if a budget isn't configured.
        public let defaultBudgetAction: DefaultQueueBudgetAction?
        /// The description of the queue to update.  This field can store any content. Escape or encode this content before displaying it on a webpage or any other system that might interpret the content of this field.
        public let description: String?
        /// The display name of the queue to update.  This field can store any content. Escape or encode this content before displaying it on a webpage or any other system that might interpret the content of this field.
        public let displayName: String?
        /// The farm ID to update in the queue.
        public let farmId: String
        /// The job attachment settings to update for the queue.
        public let jobAttachmentSettings: JobAttachmentSettings?
        /// Update the jobs in the queue to run as a specified POSIX user.
        public let jobRunAsUser: JobRunAsUser?
        /// The queue ID to update.
        public let queueId: String
        /// The required file system location names to add to the queue.
        public let requiredFileSystemLocationNamesToAdd: [String]?
        /// The required file system location names to remove from the queue.
        public let requiredFileSystemLocationNamesToRemove: [String]?
        /// The IAM role ARN that's used to run jobs from this queue.
        public let roleArn: String?

        @inlinable
        public init(allowedStorageProfileIdsToAdd: [String]? = nil, allowedStorageProfileIdsToRemove: [String]? = nil, clientToken: String? = UpdateQueueRequest.idempotencyToken(), defaultBudgetAction: DefaultQueueBudgetAction? = nil, description: String? = nil, displayName: String? = nil, farmId: String, jobAttachmentSettings: JobAttachmentSettings? = nil, jobRunAsUser: JobRunAsUser? = nil, queueId: String, requiredFileSystemLocationNamesToAdd: [String]? = nil, requiredFileSystemLocationNamesToRemove: [String]? = nil, roleArn: String? = nil) {
            self.allowedStorageProfileIdsToAdd = allowedStorageProfileIdsToAdd
            self.allowedStorageProfileIdsToRemove = allowedStorageProfileIdsToRemove
            self.clientToken = clientToken
            self.defaultBudgetAction = defaultBudgetAction
            self.description = description
            self.displayName = displayName
            self.farmId = farmId
            self.jobAttachmentSettings = jobAttachmentSettings
            self.jobRunAsUser = jobRunAsUser
            self.queueId = queueId
            self.requiredFileSystemLocationNamesToAdd = requiredFileSystemLocationNamesToAdd
            self.requiredFileSystemLocationNamesToRemove = requiredFileSystemLocationNamesToRemove
            self.roleArn = roleArn
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.allowedStorageProfileIdsToAdd, forKey: .allowedStorageProfileIdsToAdd)
            try container.encodeIfPresent(self.allowedStorageProfileIdsToRemove, forKey: .allowedStorageProfileIdsToRemove)
            request.encodeHeader(self.clientToken, key: "X-Amz-Client-Token")
            try container.encodeIfPresent(self.defaultBudgetAction, forKey: .defaultBudgetAction)
            try container.encodeIfPresent(self.description, forKey: .description)
            try container.encodeIfPresent(self.displayName, forKey: .displayName)
            request.encodePath(self.farmId, key: "farmId")
            try container.encodeIfPresent(self.jobAttachmentSettings, forKey: .jobAttachmentSettings)
            try container.encodeIfPresent(self.jobRunAsUser, forKey: .jobRunAsUser)
            request.encodePath(self.queueId, key: "queueId")
            try container.encodeIfPresent(self.requiredFileSystemLocationNamesToAdd, forKey: .requiredFileSystemLocationNamesToAdd)
            try container.encodeIfPresent(self.requiredFileSystemLocationNamesToRemove, forKey: .requiredFileSystemLocationNamesToRemove)
            try container.encodeIfPresent(self.roleArn, forKey: .roleArn)
        }

        public func validate(name: String) throws {
            try self.allowedStorageProfileIdsToAdd?.forEach {
                try validate($0, name: "allowedStorageProfileIdsToAdd[]", parent: name, pattern: "^sp-[0-9a-f]{32}$")
            }
            try self.validate(self.allowedStorageProfileIdsToAdd, name: "allowedStorageProfileIdsToAdd", parent: name, max: 20)
            try self.allowedStorageProfileIdsToRemove?.forEach {
                try validate($0, name: "allowedStorageProfileIdsToRemove[]", parent: name, pattern: "^sp-[0-9a-f]{32}$")
            }
            try self.validate(self.allowedStorageProfileIdsToRemove, name: "allowedStorageProfileIdsToRemove", parent: name, max: 20)
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 64)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.validate(self.description, name: "description", parent: name, max: 100)
            try self.validate(self.displayName, name: "displayName", parent: name, max: 100)
            try self.validate(self.displayName, name: "displayName", parent: name, min: 1)
            try self.validate(self.farmId, name: "farmId", parent: name, pattern: "^farm-[0-9a-f]{32}$")
            try self.jobAttachmentSettings?.validate(name: "\(name).jobAttachmentSettings")
            try self.validate(self.queueId, name: "queueId", parent: name, pattern: "^queue-[0-9a-f]{32}$")
            try self.requiredFileSystemLocationNamesToAdd?.forEach {
                try validate($0, name: "requiredFileSystemLocationNamesToAdd[]", parent: name, max: 64)
                try validate($0, name: "requiredFileSystemLocationNamesToAdd[]", parent: name, min: 1)
                try validate($0, name: "requiredFileSystemLocationNamesToAdd[]", parent: name, pattern: "^[0-9A-Za-z ]*$")
            }
            try self.validate(self.requiredFileSystemLocationNamesToAdd, name: "requiredFileSystemLocationNamesToAdd", parent: name, max: 20)
            try self.requiredFileSystemLocationNamesToRemove?.forEach {
                try validate($0, name: "requiredFileSystemLocationNamesToRemove[]", parent: name, max: 64)
                try validate($0, name: "requiredFileSystemLocationNamesToRemove[]", parent: name, min: 1)
                try validate($0, name: "requiredFileSystemLocationNamesToRemove[]", parent: name, pattern: "^[0-9A-Za-z ]*$")
            }
            try self.validate(self.requiredFileSystemLocationNamesToRemove, name: "requiredFileSystemLocationNamesToRemove", parent: name, max: 20)
            try self.validate(self.roleArn, name: "roleArn", parent: name, pattern: "^arn:(aws[a-zA-Z-]*):iam::\\d{12}:role(/[!-.0-~]+)*/[\\w+=,.@-]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case allowedStorageProfileIdsToAdd = "allowedStorageProfileIdsToAdd"
            case allowedStorageProfileIdsToRemove = "allowedStorageProfileIdsToRemove"
            case defaultBudgetAction = "defaultBudgetAction"
            case description = "description"
            case displayName = "displayName"
            case jobAttachmentSettings = "jobAttachmentSettings"
            case jobRunAsUser = "jobRunAsUser"
            case requiredFileSystemLocationNamesToAdd = "requiredFileSystemLocationNamesToAdd"
            case requiredFileSystemLocationNamesToRemove = "requiredFileSystemLocationNamesToRemove"
            case roleArn = "roleArn"
        }
    }

    public struct UpdateQueueResponse: AWSDecodableShape {
        public init() {}
    }

    public struct UpdateSessionRequest: AWSEncodableShape {
        /// The unique token which the server uses to recognize retries of the same request.
        public let clientToken: String?
        /// The farm ID to update in the session.
        public let farmId: String
        /// The job ID to update in the session.
        public let jobId: String
        /// The queue ID to update in the session.
        public let queueId: String
        /// The session ID to update.
        public let sessionId: String
        /// The life cycle status to update in the session.
        public let targetLifecycleStatus: SessionLifecycleTargetStatus

        @inlinable
        public init(clientToken: String? = UpdateSessionRequest.idempotencyToken(), farmId: String, jobId: String, queueId: String, sessionId: String, targetLifecycleStatus: SessionLifecycleTargetStatus) {
            self.clientToken = clientToken
            self.farmId = farmId
            self.jobId = jobId
            self.queueId = queueId
            self.sessionId = sessionId
            self.targetLifecycleStatus = targetLifecycleStatus
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodeHeader(self.clientToken, key: "X-Amz-Client-Token")
            request.encodePath(self.farmId, key: "farmId")
            request.encodePath(self.jobId, key: "jobId")
            request.encodePath(self.queueId, key: "queueId")
            request.encodePath(self.sessionId, key: "sessionId")
            try container.encode(self.targetLifecycleStatus, forKey: .targetLifecycleStatus)
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 64)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.validate(self.farmId, name: "farmId", parent: name, pattern: "^farm-[0-9a-f]{32}$")
            try self.validate(self.jobId, name: "jobId", parent: name, pattern: "^job-[0-9a-f]{32}$")
            try self.validate(self.queueId, name: "queueId", parent: name, pattern: "^queue-[0-9a-f]{32}$")
            try self.validate(self.sessionId, name: "sessionId", parent: name, pattern: "^session-[0-9a-f]{32}$")
        }

        private enum CodingKeys: String, CodingKey {
            case targetLifecycleStatus = "targetLifecycleStatus"
        }
    }

    public struct UpdateSessionResponse: AWSDecodableShape {
        public init() {}
    }

    public struct UpdateStepRequest: AWSEncodableShape {
        /// The unique token which the server uses to recognize retries of the same request.
        public let clientToken: String?
        /// The farm ID to update.
        public let farmId: String
        /// The job ID to update.
        public let jobId: String
        /// The queue ID to update.
        public let queueId: String
        /// The step ID to update.
        public let stepId: String
        /// The task status to update the step's tasks to.
        public let targetTaskRunStatus: StepTargetTaskRunStatus

        @inlinable
        public init(clientToken: String? = UpdateStepRequest.idempotencyToken(), farmId: String, jobId: String, queueId: String, stepId: String, targetTaskRunStatus: StepTargetTaskRunStatus) {
            self.clientToken = clientToken
            self.farmId = farmId
            self.jobId = jobId
            self.queueId = queueId
            self.stepId = stepId
            self.targetTaskRunStatus = targetTaskRunStatus
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodeHeader(self.clientToken, key: "X-Amz-Client-Token")
            request.encodePath(self.farmId, key: "farmId")
            request.encodePath(self.jobId, key: "jobId")
            request.encodePath(self.queueId, key: "queueId")
            request.encodePath(self.stepId, key: "stepId")
            try container.encode(self.targetTaskRunStatus, forKey: .targetTaskRunStatus)
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 64)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.validate(self.farmId, name: "farmId", parent: name, pattern: "^farm-[0-9a-f]{32}$")
            try self.validate(self.jobId, name: "jobId", parent: name, pattern: "^job-[0-9a-f]{32}$")
            try self.validate(self.queueId, name: "queueId", parent: name, pattern: "^queue-[0-9a-f]{32}$")
            try self.validate(self.stepId, name: "stepId", parent: name, pattern: "^step-[0-9a-f]{32}$")
        }

        private enum CodingKeys: String, CodingKey {
            case targetTaskRunStatus = "targetTaskRunStatus"
        }
    }

    public struct UpdateStepResponse: AWSDecodableShape {
        public init() {}
    }

    public struct UpdateStorageProfileRequest: AWSEncodableShape {
        /// The unique token which the server uses to recognize retries of the same request.
        public let clientToken: String?
        /// The display name of the storage profile to update.  This field can store any content. Escape or encode this content before displaying it on a webpage or any other system that might interpret the content of this field.
        public let displayName: String?
        /// The farm ID to update.
        public let farmId: String
        /// The file system location names to add.
        public let fileSystemLocationsToAdd: [FileSystemLocation]?
        /// The file system location names to remove.
        public let fileSystemLocationsToRemove: [FileSystemLocation]?
        /// The OS system to update.
        public let osFamily: StorageProfileOperatingSystemFamily?
        /// The storage profile ID to update.
        public let storageProfileId: String

        @inlinable
        public init(clientToken: String? = UpdateStorageProfileRequest.idempotencyToken(), displayName: String? = nil, farmId: String, fileSystemLocationsToAdd: [FileSystemLocation]? = nil, fileSystemLocationsToRemove: [FileSystemLocation]? = nil, osFamily: StorageProfileOperatingSystemFamily? = nil, storageProfileId: String) {
            self.clientToken = clientToken
            self.displayName = displayName
            self.farmId = farmId
            self.fileSystemLocationsToAdd = fileSystemLocationsToAdd
            self.fileSystemLocationsToRemove = fileSystemLocationsToRemove
            self.osFamily = osFamily
            self.storageProfileId = storageProfileId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodeHeader(self.clientToken, key: "X-Amz-Client-Token")
            try container.encodeIfPresent(self.displayName, forKey: .displayName)
            request.encodePath(self.farmId, key: "farmId")
            try container.encodeIfPresent(self.fileSystemLocationsToAdd, forKey: .fileSystemLocationsToAdd)
            try container.encodeIfPresent(self.fileSystemLocationsToRemove, forKey: .fileSystemLocationsToRemove)
            try container.encodeIfPresent(self.osFamily, forKey: .osFamily)
            request.encodePath(self.storageProfileId, key: "storageProfileId")
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 64)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.validate(self.displayName, name: "displayName", parent: name, max: 100)
            try self.validate(self.displayName, name: "displayName", parent: name, min: 1)
            try self.validate(self.farmId, name: "farmId", parent: name, pattern: "^farm-[0-9a-f]{32}$")
            try self.fileSystemLocationsToAdd?.forEach {
                try $0.validate(name: "\(name).fileSystemLocationsToAdd[]")
            }
            try self.validate(self.fileSystemLocationsToAdd, name: "fileSystemLocationsToAdd", parent: name, max: 20)
            try self.fileSystemLocationsToRemove?.forEach {
                try $0.validate(name: "\(name).fileSystemLocationsToRemove[]")
            }
            try self.validate(self.fileSystemLocationsToRemove, name: "fileSystemLocationsToRemove", parent: name, max: 20)
            try self.validate(self.storageProfileId, name: "storageProfileId", parent: name, pattern: "^sp-[0-9a-f]{32}$")
        }

        private enum CodingKeys: String, CodingKey {
            case displayName = "displayName"
            case fileSystemLocationsToAdd = "fileSystemLocationsToAdd"
            case fileSystemLocationsToRemove = "fileSystemLocationsToRemove"
            case osFamily = "osFamily"
        }
    }

    public struct UpdateStorageProfileResponse: AWSDecodableShape {
        public init() {}
    }

    public struct UpdateTaskRequest: AWSEncodableShape {
        /// The unique token which the server uses to recognize retries of the same request.
        public let clientToken: String?
        /// The farm ID to update.
        public let farmId: String
        /// The job ID to update.
        public let jobId: String
        /// The queue ID to update.
        public let queueId: String
        /// The step ID to update.
        public let stepId: String
        /// The run status with which to start the task.
        public let targetRunStatus: TaskTargetRunStatus
        /// The task ID to update.
        public let taskId: String

        @inlinable
        public init(clientToken: String? = UpdateTaskRequest.idempotencyToken(), farmId: String, jobId: String, queueId: String, stepId: String, targetRunStatus: TaskTargetRunStatus, taskId: String) {
            self.clientToken = clientToken
            self.farmId = farmId
            self.jobId = jobId
            self.queueId = queueId
            self.stepId = stepId
            self.targetRunStatus = targetRunStatus
            self.taskId = taskId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodeHeader(self.clientToken, key: "X-Amz-Client-Token")
            request.encodePath(self.farmId, key: "farmId")
            request.encodePath(self.jobId, key: "jobId")
            request.encodePath(self.queueId, key: "queueId")
            request.encodePath(self.stepId, key: "stepId")
            try container.encode(self.targetRunStatus, forKey: .targetRunStatus)
            request.encodePath(self.taskId, key: "taskId")
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 64)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.validate(self.farmId, name: "farmId", parent: name, pattern: "^farm-[0-9a-f]{32}$")
            try self.validate(self.jobId, name: "jobId", parent: name, pattern: "^job-[0-9a-f]{32}$")
            try self.validate(self.queueId, name: "queueId", parent: name, pattern: "^queue-[0-9a-f]{32}$")
            try self.validate(self.stepId, name: "stepId", parent: name, pattern: "^step-[0-9a-f]{32}$")
            try self.validate(self.taskId, name: "taskId", parent: name, pattern: "^task-[0-9a-f]{32}-(0|([1-9][0-9]{0,9}))$")
        }

        private enum CodingKeys: String, CodingKey {
            case targetRunStatus = "targetRunStatus"
        }
    }

    public struct UpdateTaskResponse: AWSDecodableShape {
        public init() {}
    }

    public struct UpdateWorkerRequest: AWSEncodableShape {
        /// The worker capabilities to update.
        public let capabilities: WorkerCapabilities?
        /// The farm ID to update.
        public let farmId: String
        /// The fleet ID to update.
        public let fleetId: String
        /// The host properties to update.
        public let hostProperties: HostPropertiesRequest?
        /// The worker status to update.
        public let status: UpdatedWorkerStatus?
        /// The worker ID to update.
        public let workerId: String

        @inlinable
        public init(capabilities: WorkerCapabilities? = nil, farmId: String, fleetId: String, hostProperties: HostPropertiesRequest? = nil, status: UpdatedWorkerStatus? = nil, workerId: String) {
            self.capabilities = capabilities
            self.farmId = farmId
            self.fleetId = fleetId
            self.hostProperties = hostProperties
            self.status = status
            self.workerId = workerId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.capabilities, forKey: .capabilities)
            request.encodePath(self.farmId, key: "farmId")
            request.encodePath(self.fleetId, key: "fleetId")
            try container.encodeIfPresent(self.hostProperties, forKey: .hostProperties)
            try container.encodeIfPresent(self.status, forKey: .status)
            request.encodePath(self.workerId, key: "workerId")
        }

        public func validate(name: String) throws {
            try self.capabilities?.validate(name: "\(name).capabilities")
            try self.validate(self.farmId, name: "farmId", parent: name, pattern: "^farm-[0-9a-f]{32}$")
            try self.validate(self.fleetId, name: "fleetId", parent: name, pattern: "^fleet-[0-9a-f]{32}$")
            try self.hostProperties?.validate(name: "\(name).hostProperties")
            try self.validate(self.workerId, name: "workerId", parent: name, pattern: "^worker-[0-9a-f]{32}$")
        }

        private enum CodingKeys: String, CodingKey {
            case capabilities = "capabilities"
            case hostProperties = "hostProperties"
            case status = "status"
        }
    }

    public struct UpdateWorkerResponse: AWSDecodableShape {
        /// The worker log to update.
        public let log: LogConfiguration?

        @inlinable
        public init(log: LogConfiguration? = nil) {
            self.log = log
        }

        private enum CodingKeys: String, CodingKey {
            case log = "log"
        }
    }

    public struct UpdateWorkerScheduleRequest: AWSEncodableShape {
        /// The farm ID to update.
        public let farmId: String
        /// The fleet ID to update.
        public let fleetId: String
        /// The session actions associated with the worker schedule to update.
        public let updatedSessionActions: [String: UpdatedSessionActionInfo]?
        /// The worker ID to update.
        public let workerId: String

        @inlinable
        public init(farmId: String, fleetId: String, updatedSessionActions: [String: UpdatedSessionActionInfo]? = nil, workerId: String) {
            self.farmId = farmId
            self.fleetId = fleetId
            self.updatedSessionActions = updatedSessionActions
            self.workerId = workerId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.farmId, key: "farmId")
            request.encodePath(self.fleetId, key: "fleetId")
            try container.encodeIfPresent(self.updatedSessionActions, forKey: .updatedSessionActions)
            request.encodePath(self.workerId, key: "workerId")
        }

        public func validate(name: String) throws {
            try self.validate(self.farmId, name: "farmId", parent: name, pattern: "^farm-[0-9a-f]{32}$")
            try self.validate(self.fleetId, name: "fleetId", parent: name, pattern: "^fleet-[0-9a-f]{32}$")
            try self.updatedSessionActions?.forEach {
                try validate($0.key, name: "updatedSessionActions.key", parent: name, pattern: "^sessionaction-[0-9a-f]{32}-(0|([1-9][0-9]{0,9}))$")
                try $0.value.validate(name: "\(name).updatedSessionActions[\"\($0.key)\"]")
            }
            try self.validate(self.workerId, name: "workerId", parent: name, pattern: "^worker-[0-9a-f]{32}$")
        }

        private enum CodingKeys: String, CodingKey {
            case updatedSessionActions = "updatedSessionActions"
        }
    }

    public struct UpdateWorkerScheduleResponse: AWSDecodableShape {
        /// The assigned sessions to update.
        public let assignedSessions: [String: AssignedSession]
        /// The session actions associated with the worker schedule to cancel.
        public let cancelSessionActions: [String: [String]]
        /// The status to update the worker to.
        public let desiredWorkerStatus: DesiredWorkerStatus?
        /// Updates the time interval (in seconds) for the schedule.
        public let updateIntervalSeconds: Int

        @inlinable
        public init(assignedSessions: [String: AssignedSession], cancelSessionActions: [String: [String]], desiredWorkerStatus: DesiredWorkerStatus? = nil, updateIntervalSeconds: Int) {
            self.assignedSessions = assignedSessions
            self.cancelSessionActions = cancelSessionActions
            self.desiredWorkerStatus = desiredWorkerStatus
            self.updateIntervalSeconds = updateIntervalSeconds
        }

        private enum CodingKeys: String, CodingKey {
            case assignedSessions = "assignedSessions"
            case cancelSessionActions = "cancelSessionActions"
            case desiredWorkerStatus = "desiredWorkerStatus"
            case updateIntervalSeconds = "updateIntervalSeconds"
        }
    }

    public struct UpdatedSessionActionInfo: AWSEncodableShape {
        /// The status of the session upon completion.
        public let completedStatus: CompletedStatus?
        /// The date and time the resource ended running.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var endedAt: Date?
        /// The process exit code. The default Deadline Cloud worker agent converts unsigned 32-bit exit codes to signed 32-bit exit codes.
        public let processExitCode: Int?
        /// A message to indicate the progress of the updated session action.
        public let progressMessage: String?
        /// The percentage completed.
        public let progressPercent: Float?
        /// The date and time the resource started running.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var startedAt: Date?
        /// The updated time.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var updatedAt: Date?

        @inlinable
        public init(completedStatus: CompletedStatus? = nil, endedAt: Date? = nil, processExitCode: Int? = nil, progressMessage: String? = nil, progressPercent: Float? = nil, startedAt: Date? = nil, updatedAt: Date? = nil) {
            self.completedStatus = completedStatus
            self.endedAt = endedAt
            self.processExitCode = processExitCode
            self.progressMessage = progressMessage
            self.progressPercent = progressPercent
            self.startedAt = startedAt
            self.updatedAt = updatedAt
        }

        public func validate(name: String) throws {
            try self.validate(self.processExitCode, name: "processExitCode", parent: name, max: 2147483647)
            try self.validate(self.processExitCode, name: "processExitCode", parent: name, min: -2147483648)
            try self.validate(self.progressMessage, name: "progressMessage", parent: name, max: 4096)
            try self.validate(self.progressPercent, name: "progressPercent", parent: name, max: 100.0)
            try self.validate(self.progressPercent, name: "progressPercent", parent: name, min: 0.0)
        }

        private enum CodingKeys: String, CodingKey {
            case completedStatus = "completedStatus"
            case endedAt = "endedAt"
            case processExitCode = "processExitCode"
            case progressMessage = "progressMessage"
            case progressPercent = "progressPercent"
            case startedAt = "startedAt"
            case updatedAt = "updatedAt"
        }
    }

    public struct UserJobsFirst: AWSEncodableShape {
        /// The user's ID.
        public let userIdentityId: String

        @inlinable
        public init(userIdentityId: String) {
            self.userIdentityId = userIdentityId
        }

        private enum CodingKeys: String, CodingKey {
            case userIdentityId = "userIdentityId"
        }
    }

    public struct VCpuCountRange: AWSEncodableShape & AWSDecodableShape {
        /// The maximum amount of vCPU.
        public let max: Int?
        /// The minimum amount of vCPU.
        public let min: Int

        @inlinable
        public init(max: Int? = nil, min: Int) {
            self.max = max
            self.min = min
        }

        public func validate(name: String) throws {
            try self.validate(self.max, name: "max", parent: name, max: 10000)
            try self.validate(self.max, name: "max", parent: name, min: 1)
            try self.validate(self.min, name: "min", parent: name, max: 10000)
            try self.validate(self.min, name: "min", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case max = "max"
            case min = "min"
        }
    }

    public struct ValidationException: AWSErrorShape {
        /// Information about the resources in use when the exception was thrown.
        public let context: [String: String]?
        /// A list of fields that failed validation.
        public let fieldList: [ValidationExceptionField]?
        public let message: String
        /// The reason that the request failed validation.
        public let reason: ValidationExceptionReason

        @inlinable
        public init(context: [String: String]? = nil, fieldList: [ValidationExceptionField]? = nil, message: String, reason: ValidationExceptionReason) {
            self.context = context
            self.fieldList = fieldList
            self.message = message
            self.reason = reason
        }

        private enum CodingKeys: String, CodingKey {
            case context = "context"
            case fieldList = "fieldList"
            case message = "message"
            case reason = "reason"
        }
    }

    public struct ValidationExceptionField: AWSDecodableShape {
        /// The error message for the validation exception.
        public let message: String
        /// The name of the validation exception.
        public let name: String

        @inlinable
        public init(message: String, name: String) {
            self.message = message
            self.name = name
        }

        private enum CodingKeys: String, CodingKey {
            case message = "message"
            case name = "name"
        }
    }

    public struct WindowsUser: AWSEncodableShape & AWSDecodableShape {
        /// The password ARN for the Windows user.
        public let passwordArn: String
        /// The user.
        public let user: String

        @inlinable
        public init(passwordArn: String, user: String) {
            self.passwordArn = passwordArn
            self.user = user
        }

        private enum CodingKeys: String, CodingKey {
            case passwordArn = "passwordArn"
            case user = "user"
        }
    }

    public struct WorkerAmountCapability: AWSEncodableShape {
        /// The name of the worker amount capability.
        public let name: String
        /// The value of the worker amount capability.
        public let value: Float

        @inlinable
        public init(name: String, value: Float) {
            self.name = name
            self.value = value
        }

        public func validate(name: String) throws {
            try self.validate(self.name, name: "name", parent: name, max: 100)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^([a-zA-Z][a-zA-Z0-9]{0,63}:)?amount(\\.[a-zA-Z][a-zA-Z0-9]{0,63})+$")
        }

        private enum CodingKeys: String, CodingKey {
            case name = "name"
            case value = "value"
        }
    }

    public struct WorkerAttributeCapability: AWSEncodableShape {
        /// The name of the worker attribute capability.
        public let name: String
        /// The values of the worker amount capability.
        public let values: [String]

        @inlinable
        public init(name: String, values: [String]) {
            self.name = name
            self.values = values
        }

        public func validate(name: String) throws {
            try self.validate(self.name, name: "name", parent: name, max: 100)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^([a-zA-Z][a-zA-Z0-9]{0,63}:)?attr(\\.[a-zA-Z][a-zA-Z0-9]{0,63})+$")
            try self.values.forEach {
                try validate($0, name: "values[]", parent: name, max: 100)
                try validate($0, name: "values[]", parent: name, min: 1)
                try validate($0, name: "values[]", parent: name, pattern: "^[a-zA-Z_]([a-zA-Z0-9_\\-]{0,99})$")
            }
            try self.validate(self.values, name: "values", parent: name, max: 10)
            try self.validate(self.values, name: "values", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case name = "name"
            case values = "values"
        }
    }

    public struct WorkerCapabilities: AWSEncodableShape {
        /// The worker capabilities amounts on a list of worker capabilities.
        public let amounts: [WorkerAmountCapability]
        /// The worker attribute capabilities in the list of attribute capabilities.
        public let attributes: [WorkerAttributeCapability]

        @inlinable
        public init(amounts: [WorkerAmountCapability], attributes: [WorkerAttributeCapability]) {
            self.amounts = amounts
            self.attributes = attributes
        }

        public func validate(name: String) throws {
            try self.amounts.forEach {
                try $0.validate(name: "\(name).amounts[]")
            }
            try self.validate(self.amounts, name: "amounts", parent: name, max: 17)
            try self.validate(self.amounts, name: "amounts", parent: name, min: 2)
            try self.attributes.forEach {
                try $0.validate(name: "\(name).attributes[]")
            }
            try self.validate(self.attributes, name: "attributes", parent: name, max: 17)
            try self.validate(self.attributes, name: "attributes", parent: name, min: 2)
        }

        private enum CodingKeys: String, CodingKey {
            case amounts = "amounts"
            case attributes = "attributes"
        }
    }

    public struct WorkerSearchSummary: AWSDecodableShape {
        /// The date and time the resource was created.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var createdAt: Date?
        /// The user or system that created this resource.
        public let createdBy: String?
        /// The fleet ID.
        public let fleetId: String?
        /// Provides the Amazon EC2 instance properties of the worker host.
        public let hostProperties: HostPropertiesResponse?
        /// The status of the worker search.
        public let status: WorkerStatus?
        /// The date and time the resource was updated.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var updatedAt: Date?
        /// The user or system that updated this resource.
        public let updatedBy: String?
        /// The worker ID.
        public let workerId: String?

        @inlinable
        public init(createdAt: Date? = nil, createdBy: String? = nil, fleetId: String? = nil, hostProperties: HostPropertiesResponse? = nil, status: WorkerStatus? = nil, updatedAt: Date? = nil, updatedBy: String? = nil, workerId: String? = nil) {
            self.createdAt = createdAt
            self.createdBy = createdBy
            self.fleetId = fleetId
            self.hostProperties = hostProperties
            self.status = status
            self.updatedAt = updatedAt
            self.updatedBy = updatedBy
            self.workerId = workerId
        }

        private enum CodingKeys: String, CodingKey {
            case createdAt = "createdAt"
            case createdBy = "createdBy"
            case fleetId = "fleetId"
            case hostProperties = "hostProperties"
            case status = "status"
            case updatedAt = "updatedAt"
            case updatedBy = "updatedBy"
            case workerId = "workerId"
        }
    }

    public struct WorkerSessionSummary: AWSDecodableShape {
        /// The date and time the resource ended running.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var endedAt: Date?
        /// The job ID for the job associated with the worker's session.
        public let jobId: String
        /// The life cycle status for the worker's session.
        public let lifecycleStatus: SessionLifecycleStatus
        /// The queue ID for the queue associated to the worker.
        public let queueId: String
        /// The session ID for the session action.
        public let sessionId: String
        /// The date and time the resource started running.
        @CustomCoding<ISO8601DateCoder>
        public var startedAt: Date
        /// The life cycle status
        public let targetLifecycleStatus: SessionLifecycleTargetStatus?

        @inlinable
        public init(endedAt: Date? = nil, jobId: String, lifecycleStatus: SessionLifecycleStatus, queueId: String, sessionId: String, startedAt: Date, targetLifecycleStatus: SessionLifecycleTargetStatus? = nil) {
            self.endedAt = endedAt
            self.jobId = jobId
            self.lifecycleStatus = lifecycleStatus
            self.queueId = queueId
            self.sessionId = sessionId
            self.startedAt = startedAt
            self.targetLifecycleStatus = targetLifecycleStatus
        }

        private enum CodingKeys: String, CodingKey {
            case endedAt = "endedAt"
            case jobId = "jobId"
            case lifecycleStatus = "lifecycleStatus"
            case queueId = "queueId"
            case sessionId = "sessionId"
            case startedAt = "startedAt"
            case targetLifecycleStatus = "targetLifecycleStatus"
        }
    }

    public struct WorkerSummary: AWSDecodableShape {
        /// The date and time the resource was created.
        @CustomCoding<ISO8601DateCoder>
        public var createdAt: Date
        /// The user or system that created this resource.
        public let createdBy: String
        /// The farm ID.
        public let farmId: String
        /// The fleet ID.
        public let fleetId: String
        /// The host properties of the worker.
        public let hostProperties: HostPropertiesResponse?
        /// The log configuration for the worker.
        public let log: LogConfiguration?
        /// The status of the worker.
        public let status: WorkerStatus
        /// The date and time the resource was updated.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var updatedAt: Date?
        /// The user or system that updated this resource.
        public let updatedBy: String?
        /// The worker ID.
        public let workerId: String

        @inlinable
        public init(createdAt: Date, createdBy: String, farmId: String, fleetId: String, hostProperties: HostPropertiesResponse? = nil, log: LogConfiguration? = nil, status: WorkerStatus, updatedAt: Date? = nil, updatedBy: String? = nil, workerId: String) {
            self.createdAt = createdAt
            self.createdBy = createdBy
            self.farmId = farmId
            self.fleetId = fleetId
            self.hostProperties = hostProperties
            self.log = log
            self.status = status
            self.updatedAt = updatedAt
            self.updatedBy = updatedBy
            self.workerId = workerId
        }

        private enum CodingKeys: String, CodingKey {
            case createdAt = "createdAt"
            case createdBy = "createdBy"
            case farmId = "farmId"
            case fleetId = "fleetId"
            case hostProperties = "hostProperties"
            case log = "log"
            case status = "status"
            case updatedAt = "updatedAt"
            case updatedBy = "updatedBy"
            case workerId = "workerId"
        }
    }

    public struct BudgetSchedule: AWSEncodableShape & AWSDecodableShape {
        /// The fixed start and end time of the budget's schedule.
        public let fixed: FixedBudgetSchedule?

        @inlinable
        public init(fixed: FixedBudgetSchedule? = nil) {
            self.fixed = fixed
        }

        private enum CodingKeys: String, CodingKey {
            case fixed = "fixed"
        }
    }

    public struct UsageTrackingResource: AWSEncodableShape & AWSDecodableShape {
        /// The queue ID.
        public let queueId: String?

        @inlinable
        public init(queueId: String? = nil) {
            self.queueId = queueId
        }

        public func validate(name: String) throws {
            try self.validate(self.queueId, name: "queueId", parent: name, pattern: "^queue-[0-9a-f]{32}$")
        }

        private enum CodingKeys: String, CodingKey {
            case queueId = "queueId"
        }
    }
}

// MARK: - Errors

/// Error enum for Deadline
public struct DeadlineErrorType: AWSErrorType {
    enum Code: String {
        case accessDeniedException = "AccessDeniedException"
        case conflictException = "ConflictException"
        case internalServerErrorException = "InternalServerErrorException"
        case resourceNotFoundException = "ResourceNotFoundException"
        case serviceQuotaExceededException = "ServiceQuotaExceededException"
        case throttlingException = "ThrottlingException"
        case validationException = "ValidationException"
    }

    private let error: Code
    public let context: AWSErrorContext?

    /// initialize Deadline
    public init?(errorCode: String, context: AWSErrorContext) {
        guard let error = Code(rawValue: errorCode) else { return nil }
        self.error = error
        self.context = context
    }

    internal init(_ error: Code) {
        self.error = error
        self.context = nil
    }

    /// return error code string
    public var errorCode: String { self.error.rawValue }

    /// You don't have permission to perform the action.
    public static var accessDeniedException: Self { .init(.accessDeniedException) }
    /// Your request has conflicting operations. This can occur if you're trying to perform more than one operation on the same resource at the same time.
    public static var conflictException: Self { .init(.conflictException) }
    /// Deadline Cloud can't process your request right now. Try again later.
    public static var internalServerErrorException: Self { .init(.internalServerErrorException) }
    /// The requested resource can't be found.
    public static var resourceNotFoundException: Self { .init(.resourceNotFoundException) }
    /// You exceeded your service quota. Service quotas, also referred to as limits, are the maximum number of service resources or operations for your Amazon Web Services account.
    public static var serviceQuotaExceededException: Self { .init(.serviceQuotaExceededException) }
    /// Your request exceeded a request rate quota.
    public static var throttlingException: Self { .init(.throttlingException) }
    /// The request isn't valid. This can occur if your request contains malformed JSON or unsupported characters.
    public static var validationException: Self { .init(.validationException) }
}

extension DeadlineErrorType: AWSServiceErrorType {
    public static let errorCodeMap: [String: AWSErrorShape.Type] = [
        "AccessDeniedException": Deadline.AccessDeniedException.self,
        "ConflictException": Deadline.ConflictException.self,
        "InternalServerErrorException": Deadline.InternalServerErrorException.self,
        "ResourceNotFoundException": Deadline.ResourceNotFoundException.self,
        "ServiceQuotaExceededException": Deadline.ServiceQuotaExceededException.self,
        "ThrottlingException": Deadline.ThrottlingException.self,
        "ValidationException": Deadline.ValidationException.self
    ]
}

extension DeadlineErrorType: Equatable {
    public static func == (lhs: DeadlineErrorType, rhs: DeadlineErrorType) -> Bool {
        lhs.error == rhs.error
    }
}

extension DeadlineErrorType: CustomStringConvertible {
    public var description: String {
        return "\(self.error.rawValue): \(self.message ?? "")"
    }
}
