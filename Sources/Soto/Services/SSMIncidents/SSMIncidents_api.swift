//===----------------------------------------------------------------------===//
//
// This source file is part of the Soto for AWS open source project
//
// Copyright (c) 2017-2024 the Soto project authors
// Licensed under Apache License v2.0
//
// See LICENSE.txt for license information
// See CONTRIBUTORS.txt for the list of Soto project authors
//
// SPDX-License-Identifier: Apache-2.0
//
//===----------------------------------------------------------------------===//

// THIS FILE IS AUTOMATICALLY GENERATED by https://github.com/soto-project/soto-codegenerator.
// DO NOT EDIT.

#if canImport(FoundationEssentials)
import FoundationEssentials
#else
import Foundation
#endif
@_exported import SotoCore

/// Service object for interacting with AWS SSMIncidents service.
///
/// Systems Manager Incident Manager is an incident management console designed to help users mitigate and recover from incidents affecting their Amazon Web Services-hosted applications. An incident is any unplanned interruption or reduction in quality of services.  Incident Manager increases incident resolution by notifying responders of impact, highlighting relevant troubleshooting data, and providing collaboration tools to get services back up and running. To achieve the primary goal of reducing the time-to-resolution of critical incidents, Incident Manager automates response plans and enables responder team escalation.
public struct SSMIncidents: AWSService {
    // MARK: Member variables

    /// Client used for communication with AWS
    public let client: AWSClient
    /// Service configuration
    public let config: AWSServiceConfig

    // MARK: Initialization

    /// Initialize the SSMIncidents client
    /// - parameters:
    ///     - client: AWSClient used to process requests
    ///     - region: Region of server you want to communicate with. This will override the partition parameter.
    ///     - partition: AWS partition where service resides, standard (.aws), china (.awscn), government (.awsusgov).
    ///     - endpoint: Custom endpoint URL to use instead of standard AWS servers
    ///     - middleware: Middleware chain used to edit requests before they are sent and responses before they are decoded 
    ///     - timeout: Timeout value for HTTP requests
    ///     - byteBufferAllocator: Allocator for ByteBuffers
    ///     - options: Service options
    public init(
        client: AWSClient,
        region: SotoCore.Region? = nil,
        partition: AWSPartition = .aws,
        endpoint: String? = nil,
        middleware: AWSMiddlewareProtocol? = nil,
        timeout: TimeAmount? = nil,
        byteBufferAllocator: ByteBufferAllocator = ByteBufferAllocator(),
        options: AWSServiceConfig.Options = []
    ) {
        self.client = client
        self.config = AWSServiceConfig(
            region: region,
            partition: region?.partition ?? partition,
            serviceName: "SSMIncidents",
            serviceIdentifier: "ssm-incidents",
            serviceProtocol: .restjson,
            apiVersion: "2018-05-10",
            endpoint: endpoint,
            variantEndpoints: Self.variantEndpoints,
            errorType: SSMIncidentsErrorType.self,
            middleware: middleware,
            timeout: timeout,
            byteBufferAllocator: byteBufferAllocator,
            options: options
        )
    }




    /// FIPS and dualstack endpoints
    static var variantEndpoints: [EndpointVariantType: AWSServiceConfig.EndpointVariant] {[
        [.dualstack]: .init(endpoints: [
            "ap-northeast-1": "ssm-incidents.ap-northeast-1.api.aws",
            "ap-northeast-2": "ssm-incidents.ap-northeast-2.api.aws",
            "ap-south-1": "ssm-incidents.ap-south-1.api.aws",
            "ap-southeast-1": "ssm-incidents.ap-southeast-1.api.aws",
            "ap-southeast-2": "ssm-incidents.ap-southeast-2.api.aws",
            "ca-central-1": "ssm-incidents.ca-central-1.api.aws",
            "eu-central-1": "ssm-incidents.eu-central-1.api.aws",
            "eu-north-1": "ssm-incidents.eu-north-1.api.aws",
            "eu-west-1": "ssm-incidents.eu-west-1.api.aws",
            "eu-west-2": "ssm-incidents.eu-west-2.api.aws",
            "eu-west-3": "ssm-incidents.eu-west-3.api.aws",
            "sa-east-1": "ssm-incidents.sa-east-1.api.aws",
            "us-east-1": "ssm-incidents.us-east-1.api.aws",
            "us-east-2": "ssm-incidents.us-east-2.api.aws",
            "us-west-1": "ssm-incidents.us-west-1.api.aws",
            "us-west-2": "ssm-incidents.us-west-2.api.aws"
        ]),
        [.dualstack, .fips]: .init(endpoints: [
            "ca-central-1": "ssm-incidents-fips.ca-central-1.api.aws",
            "us-east-1": "ssm-incidents-fips.us-east-1.api.aws",
            "us-east-2": "ssm-incidents-fips.us-east-2.api.aws",
            "us-west-1": "ssm-incidents-fips.us-west-1.api.aws",
            "us-west-2": "ssm-incidents-fips.us-west-2.api.aws"
        ]),
        [.fips]: .init(endpoints: [
            "ca-central-1": "ssm-incidents-fips.ca-central-1.amazonaws.com",
            "us-east-1": "ssm-incidents-fips.us-east-1.amazonaws.com",
            "us-east-2": "ssm-incidents-fips.us-east-2.amazonaws.com",
            "us-west-1": "ssm-incidents-fips.us-west-1.amazonaws.com",
            "us-west-2": "ssm-incidents-fips.us-west-2.amazonaws.com"
        ])
    ]}

    // MARK: API Calls

    /// Retrieves details about all specified findings for an incident, including descriptive details about each finding. A finding represents a recent application environment change made by an CodeDeploy deployment or an CloudFormation stack creation or update that can be investigated as a potential cause of the incident.
    @Sendable
    @inlinable
    public func batchGetIncidentFindings(_ input: BatchGetIncidentFindingsInput, logger: Logger = AWSClient.loggingDisabled) async throws -> BatchGetIncidentFindingsOutput {
        try await self.client.execute(
            operation: "BatchGetIncidentFindings", 
            path: "/batchGetIncidentFindings", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Retrieves details about all specified findings for an incident, including descriptive details about each finding. A finding represents a recent application environment change made by an CodeDeploy deployment or an CloudFormation stack creation or update that can be investigated as a potential cause of the incident.
    ///
    /// Parameters:
    ///   - findingIds: A list of IDs of findings for which you want to view details.
    ///   - incidentRecordArn: The Amazon Resource Name (ARN) of the incident for which you want to view finding details.
    ///   - logger: Logger use during operation
    @inlinable
    public func batchGetIncidentFindings(
        findingIds: [String],
        incidentRecordArn: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> BatchGetIncidentFindingsOutput {
        let input = BatchGetIncidentFindingsInput(
            findingIds: findingIds, 
            incidentRecordArn: incidentRecordArn
        )
        return try await self.batchGetIncidentFindings(input, logger: logger)
    }

    /// A replication set replicates and encrypts your data to the provided Regions with the provided KMS key.
    @Sendable
    @inlinable
    public func createReplicationSet(_ input: CreateReplicationSetInput, logger: Logger = AWSClient.loggingDisabled) async throws -> CreateReplicationSetOutput {
        try await self.client.execute(
            operation: "CreateReplicationSet", 
            path: "/createReplicationSet", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// A replication set replicates and encrypts your data to the provided Regions with the provided KMS key.
    ///
    /// Parameters:
    ///   - clientToken: A token that ensures that the operation is called only once with the specified details.
    ///   - regions: The Regions that Incident Manager replicates your data to. You can have up to three Regions in your replication set.
    ///   - tags: A list of tags to add to the replication set.
    ///   - logger: Logger use during operation
    @inlinable
    public func createReplicationSet(
        clientToken: String? = CreateReplicationSetInput.idempotencyToken(),
        regions: [String: RegionMapInputValue],
        tags: [String: String]? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> CreateReplicationSetOutput {
        let input = CreateReplicationSetInput(
            clientToken: clientToken, 
            regions: regions, 
            tags: tags
        )
        return try await self.createReplicationSet(input, logger: logger)
    }

    /// Creates a response plan that automates the initial response to incidents. A response plan engages contacts, starts chat channel collaboration, and initiates runbooks at the beginning of an incident.
    @Sendable
    @inlinable
    public func createResponsePlan(_ input: CreateResponsePlanInput, logger: Logger = AWSClient.loggingDisabled) async throws -> CreateResponsePlanOutput {
        try await self.client.execute(
            operation: "CreateResponsePlan", 
            path: "/createResponsePlan", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Creates a response plan that automates the initial response to incidents. A response plan engages contacts, starts chat channel collaboration, and initiates runbooks at the beginning of an incident.
    ///
    /// Parameters:
    ///   - actions: The actions that the response plan starts at the beginning of an incident.
    ///   - chatChannel: The Chatbot chat channel used for collaboration during an incident.
    ///   - clientToken: A token ensuring that the operation is called only once with the specified details.
    ///   - displayName: The long format of the response plan name. This field can contain spaces.
    ///   - engagements: The Amazon Resource Name (ARN) for the contacts and escalation plans that the response plan engages during an incident.
    ///   - incidentTemplate: Details used to create an incident when using this response plan.
    ///   - integrations: Information about third-party services integrated into the response plan.
    ///   - name: The short format name of the response plan. Can't include spaces.
    ///   - tags: A list of tags that you are adding to the response plan.
    ///   - logger: Logger use during operation
    @inlinable
    public func createResponsePlan(
        actions: [Action]? = nil,
        chatChannel: ChatChannel? = nil,
        clientToken: String? = CreateResponsePlanInput.idempotencyToken(),
        displayName: String? = nil,
        engagements: [String]? = nil,
        incidentTemplate: IncidentTemplate,
        integrations: [Integration]? = nil,
        name: String,
        tags: [String: String]? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> CreateResponsePlanOutput {
        let input = CreateResponsePlanInput(
            actions: actions, 
            chatChannel: chatChannel, 
            clientToken: clientToken, 
            displayName: displayName, 
            engagements: engagements, 
            incidentTemplate: incidentTemplate, 
            integrations: integrations, 
            name: name, 
            tags: tags
        )
        return try await self.createResponsePlan(input, logger: logger)
    }

    /// Creates a custom timeline event on the incident details page of an incident record. Incident Manager automatically creates timeline events that mark key moments during an incident. You can create custom timeline events to mark important events that Incident Manager can detect automatically.
    @Sendable
    @inlinable
    public func createTimelineEvent(_ input: CreateTimelineEventInput, logger: Logger = AWSClient.loggingDisabled) async throws -> CreateTimelineEventOutput {
        try await self.client.execute(
            operation: "CreateTimelineEvent", 
            path: "/createTimelineEvent", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Creates a custom timeline event on the incident details page of an incident record. Incident Manager automatically creates timeline events that mark key moments during an incident. You can create custom timeline events to mark important events that Incident Manager can detect automatically.
    ///
    /// Parameters:
    ///   - clientToken: A token that ensures that a client calls the action only once with the specified details.
    ///   - eventData: A short description of the event.
    ///   - eventReferences: Adds one or more references to the TimelineEvent. A reference is an Amazon Web Services resource involved or associated with the incident. To specify a reference, enter its Amazon Resource Name (ARN). You can also specify a related item associated with a resource. For example, to specify an Amazon DynamoDB (DynamoDB) table as a resource, use the table's ARN. You can also specify an Amazon CloudWatch metric associated with the DynamoDB table as a related item.
    ///   - eventTime: The timestamp for when the event occurred.
    ///   - eventType: The type of event. You can create timeline events of type Custom Event and Note. To make a Note-type event appear on the Incident notes panel in the console, specify eventType as Noteand enter the Amazon Resource Name (ARN) of the incident as the value for eventReference.
    ///   - incidentRecordArn: The Amazon Resource Name (ARN) of the incident record that the action adds the incident to.
    ///   - logger: Logger use during operation
    @inlinable
    public func createTimelineEvent(
        clientToken: String? = CreateTimelineEventInput.idempotencyToken(),
        eventData: String,
        eventReferences: [EventReference]? = nil,
        eventTime: Date,
        eventType: String,
        incidentRecordArn: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> CreateTimelineEventOutput {
        let input = CreateTimelineEventInput(
            clientToken: clientToken, 
            eventData: eventData, 
            eventReferences: eventReferences, 
            eventTime: eventTime, 
            eventType: eventType, 
            incidentRecordArn: incidentRecordArn
        )
        return try await self.createTimelineEvent(input, logger: logger)
    }

    /// Delete an incident record from Incident Manager.
    @Sendable
    @inlinable
    public func deleteIncidentRecord(_ input: DeleteIncidentRecordInput, logger: Logger = AWSClient.loggingDisabled) async throws -> DeleteIncidentRecordOutput {
        try await self.client.execute(
            operation: "DeleteIncidentRecord", 
            path: "/deleteIncidentRecord", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Delete an incident record from Incident Manager.
    ///
    /// Parameters:
    ///   - arn: The Amazon Resource Name (ARN) of the incident record you are deleting.
    ///   - logger: Logger use during operation
    @inlinable
    public func deleteIncidentRecord(
        arn: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> DeleteIncidentRecordOutput {
        let input = DeleteIncidentRecordInput(
            arn: arn
        )
        return try await self.deleteIncidentRecord(input, logger: logger)
    }

    /// Deletes all Regions in your replication set. Deleting the replication set deletes all Incident Manager data.
    @Sendable
    @inlinable
    public func deleteReplicationSet(_ input: DeleteReplicationSetInput, logger: Logger = AWSClient.loggingDisabled) async throws -> DeleteReplicationSetOutput {
        try await self.client.execute(
            operation: "DeleteReplicationSet", 
            path: "/deleteReplicationSet", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Deletes all Regions in your replication set. Deleting the replication set deletes all Incident Manager data.
    ///
    /// Parameters:
    ///   - arn: The Amazon Resource Name (ARN) of the replication set you're deleting.
    ///   - logger: Logger use during operation
    @inlinable
    public func deleteReplicationSet(
        arn: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> DeleteReplicationSetOutput {
        let input = DeleteReplicationSetInput(
            arn: arn
        )
        return try await self.deleteReplicationSet(input, logger: logger)
    }

    /// Deletes the resource policy that Resource Access Manager uses to share your Incident Manager resource.
    @Sendable
    @inlinable
    public func deleteResourcePolicy(_ input: DeleteResourcePolicyInput, logger: Logger = AWSClient.loggingDisabled) async throws -> DeleteResourcePolicyOutput {
        try await self.client.execute(
            operation: "DeleteResourcePolicy", 
            path: "/deleteResourcePolicy", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Deletes the resource policy that Resource Access Manager uses to share your Incident Manager resource.
    ///
    /// Parameters:
    ///   - policyId: The ID of the resource policy you're deleting.
    ///   - resourceArn: The Amazon Resource Name (ARN) of the resource you're deleting the policy from.
    ///   - logger: Logger use during operation
    @inlinable
    public func deleteResourcePolicy(
        policyId: String,
        resourceArn: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> DeleteResourcePolicyOutput {
        let input = DeleteResourcePolicyInput(
            policyId: policyId, 
            resourceArn: resourceArn
        )
        return try await self.deleteResourcePolicy(input, logger: logger)
    }

    /// Deletes the specified response plan. Deleting a response plan stops all linked CloudWatch alarms and EventBridge events from creating an incident with this response plan.
    @Sendable
    @inlinable
    public func deleteResponsePlan(_ input: DeleteResponsePlanInput, logger: Logger = AWSClient.loggingDisabled) async throws -> DeleteResponsePlanOutput {
        try await self.client.execute(
            operation: "DeleteResponsePlan", 
            path: "/deleteResponsePlan", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Deletes the specified response plan. Deleting a response plan stops all linked CloudWatch alarms and EventBridge events from creating an incident with this response plan.
    ///
    /// Parameters:
    ///   - arn: The Amazon Resource Name (ARN) of the response plan.
    ///   - logger: Logger use during operation
    @inlinable
    public func deleteResponsePlan(
        arn: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> DeleteResponsePlanOutput {
        let input = DeleteResponsePlanInput(
            arn: arn
        )
        return try await self.deleteResponsePlan(input, logger: logger)
    }

    /// Deletes a timeline event from an incident.
    @Sendable
    @inlinable
    public func deleteTimelineEvent(_ input: DeleteTimelineEventInput, logger: Logger = AWSClient.loggingDisabled) async throws -> DeleteTimelineEventOutput {
        try await self.client.execute(
            operation: "DeleteTimelineEvent", 
            path: "/deleteTimelineEvent", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Deletes a timeline event from an incident.
    ///
    /// Parameters:
    ///   - eventId: The ID of the event to update. You can use ListTimelineEvents to find an event's ID.
    ///   - incidentRecordArn: The Amazon Resource Name (ARN) of the incident that includes the timeline event.
    ///   - logger: Logger use during operation
    @inlinable
    public func deleteTimelineEvent(
        eventId: String,
        incidentRecordArn: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> DeleteTimelineEventOutput {
        let input = DeleteTimelineEventInput(
            eventId: eventId, 
            incidentRecordArn: incidentRecordArn
        )
        return try await self.deleteTimelineEvent(input, logger: logger)
    }

    /// Returns the details for the specified incident record.
    @Sendable
    @inlinable
    public func getIncidentRecord(_ input: GetIncidentRecordInput, logger: Logger = AWSClient.loggingDisabled) async throws -> GetIncidentRecordOutput {
        try await self.client.execute(
            operation: "GetIncidentRecord", 
            path: "/getIncidentRecord", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Returns the details for the specified incident record.
    ///
    /// Parameters:
    ///   - arn: The Amazon Resource Name (ARN) of the incident record.
    ///   - logger: Logger use during operation
    @inlinable
    public func getIncidentRecord(
        arn: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> GetIncidentRecordOutput {
        let input = GetIncidentRecordInput(
            arn: arn
        )
        return try await self.getIncidentRecord(input, logger: logger)
    }

    /// Retrieve your Incident Manager replication set.
    @Sendable
    @inlinable
    public func getReplicationSet(_ input: GetReplicationSetInput, logger: Logger = AWSClient.loggingDisabled) async throws -> GetReplicationSetOutput {
        try await self.client.execute(
            operation: "GetReplicationSet", 
            path: "/getReplicationSet", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Retrieve your Incident Manager replication set.
    ///
    /// Parameters:
    ///   - arn: The Amazon Resource Name (ARN) of the replication set you want to retrieve.
    ///   - logger: Logger use during operation
    @inlinable
    public func getReplicationSet(
        arn: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> GetReplicationSetOutput {
        let input = GetReplicationSetInput(
            arn: arn
        )
        return try await self.getReplicationSet(input, logger: logger)
    }

    /// Retrieves the resource policies attached to the specified response plan.
    @Sendable
    @inlinable
    public func getResourcePolicies(_ input: GetResourcePoliciesInput, logger: Logger = AWSClient.loggingDisabled) async throws -> GetResourcePoliciesOutput {
        try await self.client.execute(
            operation: "GetResourcePolicies", 
            path: "/getResourcePolicies", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Retrieves the resource policies attached to the specified response plan.
    ///
    /// Parameters:
    ///   - maxResults: The maximum number of resource policies to display for each page of results.
    ///   - nextToken: The pagination token for the next set of items to return. (You received this token from a previous call.)
    ///   - resourceArn: The Amazon Resource Name (ARN) of the response plan with the attached resource policy.
    ///   - logger: Logger use during operation
    @inlinable
    public func getResourcePolicies(
        maxResults: Int? = nil,
        nextToken: String? = nil,
        resourceArn: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> GetResourcePoliciesOutput {
        let input = GetResourcePoliciesInput(
            maxResults: maxResults, 
            nextToken: nextToken, 
            resourceArn: resourceArn
        )
        return try await self.getResourcePolicies(input, logger: logger)
    }

    /// Retrieves the details of the specified response plan.
    @Sendable
    @inlinable
    public func getResponsePlan(_ input: GetResponsePlanInput, logger: Logger = AWSClient.loggingDisabled) async throws -> GetResponsePlanOutput {
        try await self.client.execute(
            operation: "GetResponsePlan", 
            path: "/getResponsePlan", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Retrieves the details of the specified response plan.
    ///
    /// Parameters:
    ///   - arn: The Amazon Resource Name (ARN) of the response plan.
    ///   - logger: Logger use during operation
    @inlinable
    public func getResponsePlan(
        arn: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> GetResponsePlanOutput {
        let input = GetResponsePlanInput(
            arn: arn
        )
        return try await self.getResponsePlan(input, logger: logger)
    }

    /// Retrieves a timeline event based on its ID and incident record.
    @Sendable
    @inlinable
    public func getTimelineEvent(_ input: GetTimelineEventInput, logger: Logger = AWSClient.loggingDisabled) async throws -> GetTimelineEventOutput {
        try await self.client.execute(
            operation: "GetTimelineEvent", 
            path: "/getTimelineEvent", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Retrieves a timeline event based on its ID and incident record.
    ///
    /// Parameters:
    ///   - eventId: The ID of the event. You can get an event's ID when you create it, or by using ListTimelineEvents.
    ///   - incidentRecordArn: The Amazon Resource Name (ARN) of the incident that includes the timeline event.
    ///   - logger: Logger use during operation
    @inlinable
    public func getTimelineEvent(
        eventId: String,
        incidentRecordArn: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> GetTimelineEventOutput {
        let input = GetTimelineEventInput(
            eventId: eventId, 
            incidentRecordArn: incidentRecordArn
        )
        return try await self.getTimelineEvent(input, logger: logger)
    }

    /// Retrieves a list of the IDs of findings, plus their last modified times, that have been identified for a specified incident. A finding represents a recent application environment change made by an CloudFormation stack creation or update or an CodeDeploy deployment that can be investigated as a potential cause of the incident.
    @Sendable
    @inlinable
    public func listIncidentFindings(_ input: ListIncidentFindingsInput, logger: Logger = AWSClient.loggingDisabled) async throws -> ListIncidentFindingsOutput {
        try await self.client.execute(
            operation: "ListIncidentFindings", 
            path: "/listIncidentFindings", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Retrieves a list of the IDs of findings, plus their last modified times, that have been identified for a specified incident. A finding represents a recent application environment change made by an CloudFormation stack creation or update or an CodeDeploy deployment that can be investigated as a potential cause of the incident.
    ///
    /// Parameters:
    ///   - incidentRecordArn: The Amazon Resource Name (ARN) of the incident for which you want to view associated findings.
    ///   - maxResults: The maximum number of findings to retrieve per call.
    ///   - nextToken: The pagination token for the next set of items to return. (You received this token from a previous call.)
    ///   - logger: Logger use during operation
    @inlinable
    public func listIncidentFindings(
        incidentRecordArn: String,
        maxResults: Int? = nil,
        nextToken: String? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ListIncidentFindingsOutput {
        let input = ListIncidentFindingsInput(
            incidentRecordArn: incidentRecordArn, 
            maxResults: maxResults, 
            nextToken: nextToken
        )
        return try await self.listIncidentFindings(input, logger: logger)
    }

    /// Lists all incident records in your account. Use this command to retrieve the Amazon Resource Name (ARN) of the incident record you want to update.
    @Sendable
    @inlinable
    public func listIncidentRecords(_ input: ListIncidentRecordsInput, logger: Logger = AWSClient.loggingDisabled) async throws -> ListIncidentRecordsOutput {
        try await self.client.execute(
            operation: "ListIncidentRecords", 
            path: "/listIncidentRecords", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Lists all incident records in your account. Use this command to retrieve the Amazon Resource Name (ARN) of the incident record you want to update.
    ///
    /// Parameters:
    ///   - filters: Filters the list of incident records you want to search through. You can filter on the following keys:    creationTime     impact     status     createdBy    Note the following when when you use Filters:   If you don't specify a Filter, the response includes all incident records.   If you specify more than one filter in a single request, the response returns incident records that match all filters.   If you specify a filter with more than one value, the response returns incident records that match any of the values provided.
    ///   - maxResults: The maximum number of results per page.
    ///   - nextToken: The pagination token for the next set of items to return. (You received this token from a previous call.)
    ///   - logger: Logger use during operation
    @inlinable
    public func listIncidentRecords(
        filters: [Filter]? = nil,
        maxResults: Int? = nil,
        nextToken: String? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ListIncidentRecordsOutput {
        let input = ListIncidentRecordsInput(
            filters: filters, 
            maxResults: maxResults, 
            nextToken: nextToken
        )
        return try await self.listIncidentRecords(input, logger: logger)
    }

    /// List all related items for an incident record.
    @Sendable
    @inlinable
    public func listRelatedItems(_ input: ListRelatedItemsInput, logger: Logger = AWSClient.loggingDisabled) async throws -> ListRelatedItemsOutput {
        try await self.client.execute(
            operation: "ListRelatedItems", 
            path: "/listRelatedItems", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// List all related items for an incident record.
    ///
    /// Parameters:
    ///   - incidentRecordArn: The Amazon Resource Name (ARN) of the incident record containing the listed related items.
    ///   - maxResults: The maximum number of related items per page.
    ///   - nextToken: The pagination token for the next set of items to return. (You received this token from a previous call.)
    ///   - logger: Logger use during operation
    @inlinable
    public func listRelatedItems(
        incidentRecordArn: String,
        maxResults: Int? = nil,
        nextToken: String? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ListRelatedItemsOutput {
        let input = ListRelatedItemsInput(
            incidentRecordArn: incidentRecordArn, 
            maxResults: maxResults, 
            nextToken: nextToken
        )
        return try await self.listRelatedItems(input, logger: logger)
    }

    /// Lists details about the replication set configured in your account.
    @Sendable
    @inlinable
    public func listReplicationSets(_ input: ListReplicationSetsInput, logger: Logger = AWSClient.loggingDisabled) async throws -> ListReplicationSetsOutput {
        try await self.client.execute(
            operation: "ListReplicationSets", 
            path: "/listReplicationSets", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Lists details about the replication set configured in your account.
    ///
    /// Parameters:
    ///   - maxResults: The maximum number of results per page.
    ///   - nextToken: The pagination token for the next set of items to return. (You received this token from a previous call.)
    ///   - logger: Logger use during operation
    @inlinable
    public func listReplicationSets(
        maxResults: Int? = nil,
        nextToken: String? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ListReplicationSetsOutput {
        let input = ListReplicationSetsInput(
            maxResults: maxResults, 
            nextToken: nextToken
        )
        return try await self.listReplicationSets(input, logger: logger)
    }

    /// Lists all response plans in your account.
    @Sendable
    @inlinable
    public func listResponsePlans(_ input: ListResponsePlansInput, logger: Logger = AWSClient.loggingDisabled) async throws -> ListResponsePlansOutput {
        try await self.client.execute(
            operation: "ListResponsePlans", 
            path: "/listResponsePlans", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Lists all response plans in your account.
    ///
    /// Parameters:
    ///   - maxResults: The maximum number of response plans per page.
    ///   - nextToken: The pagination token for the next set of items to return. (You received this token from a previous call.)
    ///   - logger: Logger use during operation
    @inlinable
    public func listResponsePlans(
        maxResults: Int? = nil,
        nextToken: String? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ListResponsePlansOutput {
        let input = ListResponsePlansInput(
            maxResults: maxResults, 
            nextToken: nextToken
        )
        return try await self.listResponsePlans(input, logger: logger)
    }

    /// Lists the tags that are attached to the specified response plan or incident.
    @Sendable
    @inlinable
    public func listTagsForResource(_ input: ListTagsForResourceRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> ListTagsForResourceResponse {
        try await self.client.execute(
            operation: "ListTagsForResource", 
            path: "/tags/{resourceArn}", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Lists the tags that are attached to the specified response plan or incident.
    ///
    /// Parameters:
    ///   - resourceArn: The Amazon Resource Name (ARN) of the response plan or incident.
    ///   - logger: Logger use during operation
    @inlinable
    public func listTagsForResource(
        resourceArn: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ListTagsForResourceResponse {
        let input = ListTagsForResourceRequest(
            resourceArn: resourceArn
        )
        return try await self.listTagsForResource(input, logger: logger)
    }

    /// Lists timeline events for the specified incident record.
    @Sendable
    @inlinable
    public func listTimelineEvents(_ input: ListTimelineEventsInput, logger: Logger = AWSClient.loggingDisabled) async throws -> ListTimelineEventsOutput {
        try await self.client.execute(
            operation: "ListTimelineEvents", 
            path: "/listTimelineEvents", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Lists timeline events for the specified incident record.
    ///
    /// Parameters:
    ///   - filters: Filters the timeline events based on the provided conditional values. You can filter timeline events with the following keys:    eventReference     eventTime     eventType    Note the following when deciding how to use Filters:   If you don't specify a Filter, the response includes all timeline events.   If you specify more than one filter in a single request, the response returns timeline events that match all filters.   If you specify a filter with more than one value, the response returns timeline events that match any of the values provided.
    ///   - incidentRecordArn: The Amazon Resource Name (ARN) of the incident that includes the timeline event.
    ///   - maxResults: The maximum number of results per page.
    ///   - nextToken: The pagination token for the next set of items to return. (You received this token from a previous call.)
    ///   - sortBy: Sort timeline events by the specified key value pair.
    ///   - sortOrder: Sorts the order of timeline events by the value specified in the sortBy field.
    ///   - logger: Logger use during operation
    @inlinable
    public func listTimelineEvents(
        filters: [Filter]? = nil,
        incidentRecordArn: String,
        maxResults: Int? = nil,
        nextToken: String? = nil,
        sortBy: TimelineEventSort? = nil,
        sortOrder: SortOrder? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ListTimelineEventsOutput {
        let input = ListTimelineEventsInput(
            filters: filters, 
            incidentRecordArn: incidentRecordArn, 
            maxResults: maxResults, 
            nextToken: nextToken, 
            sortBy: sortBy, 
            sortOrder: sortOrder
        )
        return try await self.listTimelineEvents(input, logger: logger)
    }

    /// Adds a resource policy to the specified response plan. The resource policy is used to share the response plan using Resource Access Manager (RAM). For more information about cross-account sharing, see Cross-Region and cross-account incident management.
    @Sendable
    @inlinable
    public func putResourcePolicy(_ input: PutResourcePolicyInput, logger: Logger = AWSClient.loggingDisabled) async throws -> PutResourcePolicyOutput {
        try await self.client.execute(
            operation: "PutResourcePolicy", 
            path: "/putResourcePolicy", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Adds a resource policy to the specified response plan. The resource policy is used to share the response plan using Resource Access Manager (RAM). For more information about cross-account sharing, see Cross-Region and cross-account incident management.
    ///
    /// Parameters:
    ///   - policy: Details of the resource policy.
    ///   - resourceArn: The Amazon Resource Name (ARN) of the response plan to add the resource policy to.
    ///   - logger: Logger use during operation
    @inlinable
    public func putResourcePolicy(
        policy: String,
        resourceArn: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> PutResourcePolicyOutput {
        let input = PutResourcePolicyInput(
            policy: policy, 
            resourceArn: resourceArn
        )
        return try await self.putResourcePolicy(input, logger: logger)
    }

    /// Used to start an incident from CloudWatch alarms, EventBridge events, or manually.
    @Sendable
    @inlinable
    public func startIncident(_ input: StartIncidentInput, logger: Logger = AWSClient.loggingDisabled) async throws -> StartIncidentOutput {
        try await self.client.execute(
            operation: "StartIncident", 
            path: "/startIncident", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Used to start an incident from CloudWatch alarms, EventBridge events, or manually.
    ///
    /// Parameters:
    ///   - clientToken: A token ensuring that the operation is called only once with the specified details.
    ///   - impact: Defines the impact to the customers. Providing an impact overwrites the impact provided by a response plan.  Supported impact codes     1 - Critical    2 - High    3 - Medium    4 - Low    5 - No Impact
    ///   - relatedItems: Add related items to the incident for other responders to use. Related items are Amazon Web Services resources, external links, or files uploaded to an Amazon S3 bucket.
    ///   - responsePlanArn: The Amazon Resource Name (ARN) of the response plan that pre-defines summary, chat channels, Amazon SNS topics, runbooks, title, and impact of the incident.
    ///   - title: Provide a title for the incident. Providing a title overwrites the title provided by the response plan.
    ///   - triggerDetails: Details of what created the incident record in Incident Manager.
    ///   - logger: Logger use during operation
    @inlinable
    public func startIncident(
        clientToken: String? = StartIncidentInput.idempotencyToken(),
        impact: Int? = nil,
        relatedItems: [RelatedItem]? = nil,
        responsePlanArn: String,
        title: String? = nil,
        triggerDetails: TriggerDetails? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> StartIncidentOutput {
        let input = StartIncidentInput(
            clientToken: clientToken, 
            impact: impact, 
            relatedItems: relatedItems, 
            responsePlanArn: responsePlanArn, 
            title: title, 
            triggerDetails: triggerDetails
        )
        return try await self.startIncident(input, logger: logger)
    }

    /// Adds a tag to a response plan.
    @Sendable
    @inlinable
    public func tagResource(_ input: TagResourceRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> TagResourceResponse {
        try await self.client.execute(
            operation: "TagResource", 
            path: "/tags/{resourceArn}", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Adds a tag to a response plan.
    ///
    /// Parameters:
    ///   - resourceArn: The Amazon Resource Name (ARN) of the response plan you're adding the tags to.
    ///   - tags: A list of tags to add to the response plan.
    ///   - logger: Logger use during operation
    @inlinable
    public func tagResource(
        resourceArn: String,
        tags: [String: String],
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> TagResourceResponse {
        let input = TagResourceRequest(
            resourceArn: resourceArn, 
            tags: tags
        )
        return try await self.tagResource(input, logger: logger)
    }

    /// Removes a tag from a resource.
    @Sendable
    @inlinable
    public func untagResource(_ input: UntagResourceRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> UntagResourceResponse {
        try await self.client.execute(
            operation: "UntagResource", 
            path: "/tags/{resourceArn}", 
            httpMethod: .DELETE, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Removes a tag from a resource.
    ///
    /// Parameters:
    ///   - resourceArn: The Amazon Resource Name (ARN) of the response plan you're removing a tag from.
    ///   - tagKeys: The name of the tag to remove from the response plan.
    ///   - logger: Logger use during operation
    @inlinable
    public func untagResource(
        resourceArn: String,
        tagKeys: [String],
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> UntagResourceResponse {
        let input = UntagResourceRequest(
            resourceArn: resourceArn, 
            tagKeys: tagKeys
        )
        return try await self.untagResource(input, logger: logger)
    }

    /// Update deletion protection to either allow or deny deletion of the final Region in a replication set.
    @Sendable
    @inlinable
    public func updateDeletionProtection(_ input: UpdateDeletionProtectionInput, logger: Logger = AWSClient.loggingDisabled) async throws -> UpdateDeletionProtectionOutput {
        try await self.client.execute(
            operation: "UpdateDeletionProtection", 
            path: "/updateDeletionProtection", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Update deletion protection to either allow or deny deletion of the final Region in a replication set.
    ///
    /// Parameters:
    ///   - arn: The Amazon Resource Name (ARN) of the replication set to update.
    ///   - clientToken: A token that ensures that the operation is called only once with the specified details.
    ///   - deletionProtected: Specifies if deletion protection is turned on or off in your account.
    ///   - logger: Logger use during operation
    @inlinable
    public func updateDeletionProtection(
        arn: String,
        clientToken: String? = UpdateDeletionProtectionInput.idempotencyToken(),
        deletionProtected: Bool,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> UpdateDeletionProtectionOutput {
        let input = UpdateDeletionProtectionInput(
            arn: arn, 
            clientToken: clientToken, 
            deletionProtected: deletionProtected
        )
        return try await self.updateDeletionProtection(input, logger: logger)
    }

    /// Update the details of an incident record. You can use this operation to update an incident record from the defined chat channel. For more information about using actions in chat channels, see Interacting through chat.
    @Sendable
    @inlinable
    public func updateIncidentRecord(_ input: UpdateIncidentRecordInput, logger: Logger = AWSClient.loggingDisabled) async throws -> UpdateIncidentRecordOutput {
        try await self.client.execute(
            operation: "UpdateIncidentRecord", 
            path: "/updateIncidentRecord", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Update the details of an incident record. You can use this operation to update an incident record from the defined chat channel. For more information about using actions in chat channels, see Interacting through chat.
    ///
    /// Parameters:
    ///   - arn: The Amazon Resource Name (ARN) of the incident record you are updating.
    ///   - chatChannel: The Chatbot chat channel where responders can collaborate.
    ///   - clientToken: A token that ensures that a client calls the operation only once with the specified details.
    ///   - impact: Defines the impact of the incident to customers and applications. If you provide an impact for an incident, it overwrites the impact provided by the response plan.  Supported impact codes     1 - Critical    2 - High    3 - Medium    4 - Low    5 - No Impact
    ///   - notificationTargets: The Amazon SNS targets that Incident Manager notifies when a client updates an incident. Using multiple SNS topics creates redundancy in the event that a Region is down during the incident.
    ///   - status: The status of the incident. Possible statuses are Open or Resolved.
    ///   - summary: A longer description of what occurred during the incident.
    ///   - title: A brief description of the incident.
    ///   - logger: Logger use during operation
    @inlinable
    public func updateIncidentRecord(
        arn: String,
        chatChannel: ChatChannel? = nil,
        clientToken: String? = UpdateIncidentRecordInput.idempotencyToken(),
        impact: Int? = nil,
        notificationTargets: [NotificationTargetItem]? = nil,
        status: IncidentRecordStatus? = nil,
        summary: String? = nil,
        title: String? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> UpdateIncidentRecordOutput {
        let input = UpdateIncidentRecordInput(
            arn: arn, 
            chatChannel: chatChannel, 
            clientToken: clientToken, 
            impact: impact, 
            notificationTargets: notificationTargets, 
            status: status, 
            summary: summary, 
            title: title
        )
        return try await self.updateIncidentRecord(input, logger: logger)
    }

    /// Add or remove related items from the related items tab of an incident record.
    @Sendable
    @inlinable
    public func updateRelatedItems(_ input: UpdateRelatedItemsInput, logger: Logger = AWSClient.loggingDisabled) async throws -> UpdateRelatedItemsOutput {
        try await self.client.execute(
            operation: "UpdateRelatedItems", 
            path: "/updateRelatedItems", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Add or remove related items from the related items tab of an incident record.
    ///
    /// Parameters:
    ///   - clientToken: A token that ensures that a client calls the operation only once with the specified details.
    ///   - incidentRecordArn: The Amazon Resource Name (ARN) of the incident record that contains the related items that you update.
    ///   - relatedItemsUpdate: Details about the item that you are add to, or delete from, an incident.
    ///   - logger: Logger use during operation
    @inlinable
    public func updateRelatedItems(
        clientToken: String? = UpdateRelatedItemsInput.idempotencyToken(),
        incidentRecordArn: String,
        relatedItemsUpdate: RelatedItemsUpdate,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> UpdateRelatedItemsOutput {
        let input = UpdateRelatedItemsInput(
            clientToken: clientToken, 
            incidentRecordArn: incidentRecordArn, 
            relatedItemsUpdate: relatedItemsUpdate
        )
        return try await self.updateRelatedItems(input, logger: logger)
    }

    /// Add or delete Regions from your replication set.
    @Sendable
    @inlinable
    public func updateReplicationSet(_ input: UpdateReplicationSetInput, logger: Logger = AWSClient.loggingDisabled) async throws -> UpdateReplicationSetOutput {
        try await self.client.execute(
            operation: "UpdateReplicationSet", 
            path: "/updateReplicationSet", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Add or delete Regions from your replication set.
    ///
    /// Parameters:
    ///   - actions: An action to add or delete a Region.
    ///   - arn: The Amazon Resource Name (ARN) of the replication set you're updating.
    ///   - clientToken: A token that ensures that the operation is called only once with the specified details.
    ///   - logger: Logger use during operation
    @inlinable
    public func updateReplicationSet(
        actions: [UpdateReplicationSetAction],
        arn: String,
        clientToken: String? = UpdateReplicationSetInput.idempotencyToken(),
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> UpdateReplicationSetOutput {
        let input = UpdateReplicationSetInput(
            actions: actions, 
            arn: arn, 
            clientToken: clientToken
        )
        return try await self.updateReplicationSet(input, logger: logger)
    }

    /// Updates the specified response plan.
    @Sendable
    @inlinable
    public func updateResponsePlan(_ input: UpdateResponsePlanInput, logger: Logger = AWSClient.loggingDisabled) async throws -> UpdateResponsePlanOutput {
        try await self.client.execute(
            operation: "UpdateResponsePlan", 
            path: "/updateResponsePlan", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Updates the specified response plan.
    ///
    /// Parameters:
    ///   - actions: The actions that this response plan takes at the beginning of an incident.
    ///   - arn: The Amazon Resource Name (ARN) of the response plan.
    ///   - chatChannel: The Chatbot chat channel used for collaboration during an incident. Use the empty structure to remove the chat channel from the response plan.
    ///   - clientToken: A token ensuring that the operation is called only once with the specified details.
    ///   - displayName: The long format name of the response plan. The display name can't contain spaces.
    ///   - engagements: The Amazon Resource Name (ARN) for the contacts and escalation plans that the response plan engages during an incident.
    ///   - incidentTemplateDedupeString: The string Incident Manager uses to prevent duplicate incidents from being created by the same incident in the same account.
    ///   - incidentTemplateImpact: Defines the impact to the customers. Providing an impact overwrites the impact provided by a response plan.  Supported impact codes     1 - Critical    2 - High    3 - Medium    4 - Low    5 - No Impact
    ///   - incidentTemplateNotificationTargets: The Amazon SNS targets that are notified when updates are made to an incident.
    ///   - incidentTemplateSummary: A brief summary of the incident. This typically contains what has happened, what's currently happening, and next steps.
    ///   - incidentTemplateTags: Tags to assign to the template. When the StartIncident API action is called, Incident Manager assigns the tags specified in the template to the incident. To call this action, you must also have permission to call the TagResource API action for the incident record resource.
    ///   - incidentTemplateTitle: The short format name of the incident. The title can't contain spaces.
    ///   - integrations: Information about third-party services integrated into the response plan.
    ///   - logger: Logger use during operation
    @inlinable
    public func updateResponsePlan(
        actions: [Action]? = nil,
        arn: String,
        chatChannel: ChatChannel? = nil,
        clientToken: String? = UpdateResponsePlanInput.idempotencyToken(),
        displayName: String? = nil,
        engagements: [String]? = nil,
        incidentTemplateDedupeString: String? = nil,
        incidentTemplateImpact: Int? = nil,
        incidentTemplateNotificationTargets: [NotificationTargetItem]? = nil,
        incidentTemplateSummary: String? = nil,
        incidentTemplateTags: [String: String]? = nil,
        incidentTemplateTitle: String? = nil,
        integrations: [Integration]? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> UpdateResponsePlanOutput {
        let input = UpdateResponsePlanInput(
            actions: actions, 
            arn: arn, 
            chatChannel: chatChannel, 
            clientToken: clientToken, 
            displayName: displayName, 
            engagements: engagements, 
            incidentTemplateDedupeString: incidentTemplateDedupeString, 
            incidentTemplateImpact: incidentTemplateImpact, 
            incidentTemplateNotificationTargets: incidentTemplateNotificationTargets, 
            incidentTemplateSummary: incidentTemplateSummary, 
            incidentTemplateTags: incidentTemplateTags, 
            incidentTemplateTitle: incidentTemplateTitle, 
            integrations: integrations
        )
        return try await self.updateResponsePlan(input, logger: logger)
    }

    /// Updates a timeline event. You can update events of type Custom Event.
    @Sendable
    @inlinable
    public func updateTimelineEvent(_ input: UpdateTimelineEventInput, logger: Logger = AWSClient.loggingDisabled) async throws -> UpdateTimelineEventOutput {
        try await self.client.execute(
            operation: "UpdateTimelineEvent", 
            path: "/updateTimelineEvent", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Updates a timeline event. You can update events of type Custom Event.
    ///
    /// Parameters:
    ///   - clientToken: A token that ensures that a client calls the operation only once with the specified details.
    ///   - eventData: A short description of the event.
    ///   - eventId: The ID of the event to update. You can use ListTimelineEvents to find an event's ID.
    ///   - eventReferences: Updates all existing references in a TimelineEvent. A reference is an Amazon Web Services resource involved or associated with the incident. To specify a reference, enter its Amazon Resource Name (ARN). You can also specify a related item associated with that resource. For example, to specify an Amazon DynamoDB (DynamoDB) table as a resource, use its ARN. You can also specify an Amazon CloudWatch metric associated with the DynamoDB table as a related item.  This update action overrides all existing references. If you want to keep existing references, you must specify them in the call. If you don't, this action removes any existing references and enters only new references.
    ///   - eventTime: The timestamp for when the event occurred.
    ///   - eventType: The type of event. You can update events of type Custom Event and Note.
    ///   - incidentRecordArn: The Amazon Resource Name (ARN) of the incident that includes the timeline event.
    ///   - logger: Logger use during operation
    @inlinable
    public func updateTimelineEvent(
        clientToken: String? = UpdateTimelineEventInput.idempotencyToken(),
        eventData: String? = nil,
        eventId: String,
        eventReferences: [EventReference]? = nil,
        eventTime: Date? = nil,
        eventType: String? = nil,
        incidentRecordArn: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> UpdateTimelineEventOutput {
        let input = UpdateTimelineEventInput(
            clientToken: clientToken, 
            eventData: eventData, 
            eventId: eventId, 
            eventReferences: eventReferences, 
            eventTime: eventTime, 
            eventType: eventType, 
            incidentRecordArn: incidentRecordArn
        )
        return try await self.updateTimelineEvent(input, logger: logger)
    }
}

extension SSMIncidents {
    /// Initializer required by `AWSService.with(middlewares:timeout:byteBufferAllocator:options)`. You are not able to use this initializer directly as there are not public
    /// initializers for `AWSServiceConfig.Patch`. Please use `AWSService.with(middlewares:timeout:byteBufferAllocator:options)` instead.
    public init(from: SSMIncidents, patch: AWSServiceConfig.Patch) {
        self.client = from.client
        self.config = from.config.with(patch: patch)
    }
}

// MARK: Paginators

@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension SSMIncidents {
    /// Return PaginatorSequence for operation ``getResourcePolicies(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func getResourcePoliciesPaginator(
        _ input: GetResourcePoliciesInput,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<GetResourcePoliciesInput, GetResourcePoliciesOutput> {
        return .init(
            input: input,
            command: self.getResourcePolicies,
            inputKey: \GetResourcePoliciesInput.nextToken,
            outputKey: \GetResourcePoliciesOutput.nextToken,
            logger: logger
        )
    }
    /// Return PaginatorSequence for operation ``getResourcePolicies(_:logger:)``.
    ///
    /// - Parameters:
    ///   - maxResults: The maximum number of resource policies to display for each page of results.
    ///   - resourceArn: The Amazon Resource Name (ARN) of the response plan with the attached resource policy.
    ///   - logger: Logger used for logging
    @inlinable
    public func getResourcePoliciesPaginator(
        maxResults: Int? = nil,
        resourceArn: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) -> AWSClient.PaginatorSequence<GetResourcePoliciesInput, GetResourcePoliciesOutput> {
        let input = GetResourcePoliciesInput(
            maxResults: maxResults, 
            resourceArn: resourceArn
        )
        return self.getResourcePoliciesPaginator(input, logger: logger)
    }

    /// Return PaginatorSequence for operation ``listIncidentFindings(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func listIncidentFindingsPaginator(
        _ input: ListIncidentFindingsInput,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<ListIncidentFindingsInput, ListIncidentFindingsOutput> {
        return .init(
            input: input,
            command: self.listIncidentFindings,
            inputKey: \ListIncidentFindingsInput.nextToken,
            outputKey: \ListIncidentFindingsOutput.nextToken,
            logger: logger
        )
    }
    /// Return PaginatorSequence for operation ``listIncidentFindings(_:logger:)``.
    ///
    /// - Parameters:
    ///   - incidentRecordArn: The Amazon Resource Name (ARN) of the incident for which you want to view associated findings.
    ///   - maxResults: The maximum number of findings to retrieve per call.
    ///   - logger: Logger used for logging
    @inlinable
    public func listIncidentFindingsPaginator(
        incidentRecordArn: String,
        maxResults: Int? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) -> AWSClient.PaginatorSequence<ListIncidentFindingsInput, ListIncidentFindingsOutput> {
        let input = ListIncidentFindingsInput(
            incidentRecordArn: incidentRecordArn, 
            maxResults: maxResults
        )
        return self.listIncidentFindingsPaginator(input, logger: logger)
    }

    /// Return PaginatorSequence for operation ``listIncidentRecords(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func listIncidentRecordsPaginator(
        _ input: ListIncidentRecordsInput,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<ListIncidentRecordsInput, ListIncidentRecordsOutput> {
        return .init(
            input: input,
            command: self.listIncidentRecords,
            inputKey: \ListIncidentRecordsInput.nextToken,
            outputKey: \ListIncidentRecordsOutput.nextToken,
            logger: logger
        )
    }
    /// Return PaginatorSequence for operation ``listIncidentRecords(_:logger:)``.
    ///
    /// - Parameters:
    ///   - filters: Filters the list of incident records you want to search through. You can filter on the following keys:    creationTime     impact     status     createdBy    Note the following when when you use Filters:   If you don't specify a Filter, the response includes all incident records.   If you specify more than one filter in a single request, the response returns incident records that match all filters.   If you specify a filter with more than one value, the response returns incident records that match any of the values provided.
    ///   - maxResults: The maximum number of results per page.
    ///   - logger: Logger used for logging
    @inlinable
    public func listIncidentRecordsPaginator(
        filters: [Filter]? = nil,
        maxResults: Int? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) -> AWSClient.PaginatorSequence<ListIncidentRecordsInput, ListIncidentRecordsOutput> {
        let input = ListIncidentRecordsInput(
            filters: filters, 
            maxResults: maxResults
        )
        return self.listIncidentRecordsPaginator(input, logger: logger)
    }

    /// Return PaginatorSequence for operation ``listRelatedItems(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func listRelatedItemsPaginator(
        _ input: ListRelatedItemsInput,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<ListRelatedItemsInput, ListRelatedItemsOutput> {
        return .init(
            input: input,
            command: self.listRelatedItems,
            inputKey: \ListRelatedItemsInput.nextToken,
            outputKey: \ListRelatedItemsOutput.nextToken,
            logger: logger
        )
    }
    /// Return PaginatorSequence for operation ``listRelatedItems(_:logger:)``.
    ///
    /// - Parameters:
    ///   - incidentRecordArn: The Amazon Resource Name (ARN) of the incident record containing the listed related items.
    ///   - maxResults: The maximum number of related items per page.
    ///   - logger: Logger used for logging
    @inlinable
    public func listRelatedItemsPaginator(
        incidentRecordArn: String,
        maxResults: Int? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) -> AWSClient.PaginatorSequence<ListRelatedItemsInput, ListRelatedItemsOutput> {
        let input = ListRelatedItemsInput(
            incidentRecordArn: incidentRecordArn, 
            maxResults: maxResults
        )
        return self.listRelatedItemsPaginator(input, logger: logger)
    }

    /// Return PaginatorSequence for operation ``listReplicationSets(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func listReplicationSetsPaginator(
        _ input: ListReplicationSetsInput,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<ListReplicationSetsInput, ListReplicationSetsOutput> {
        return .init(
            input: input,
            command: self.listReplicationSets,
            inputKey: \ListReplicationSetsInput.nextToken,
            outputKey: \ListReplicationSetsOutput.nextToken,
            logger: logger
        )
    }
    /// Return PaginatorSequence for operation ``listReplicationSets(_:logger:)``.
    ///
    /// - Parameters:
    ///   - maxResults: The maximum number of results per page.
    ///   - logger: Logger used for logging
    @inlinable
    public func listReplicationSetsPaginator(
        maxResults: Int? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) -> AWSClient.PaginatorSequence<ListReplicationSetsInput, ListReplicationSetsOutput> {
        let input = ListReplicationSetsInput(
            maxResults: maxResults
        )
        return self.listReplicationSetsPaginator(input, logger: logger)
    }

    /// Return PaginatorSequence for operation ``listResponsePlans(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func listResponsePlansPaginator(
        _ input: ListResponsePlansInput,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<ListResponsePlansInput, ListResponsePlansOutput> {
        return .init(
            input: input,
            command: self.listResponsePlans,
            inputKey: \ListResponsePlansInput.nextToken,
            outputKey: \ListResponsePlansOutput.nextToken,
            logger: logger
        )
    }
    /// Return PaginatorSequence for operation ``listResponsePlans(_:logger:)``.
    ///
    /// - Parameters:
    ///   - maxResults: The maximum number of response plans per page.
    ///   - logger: Logger used for logging
    @inlinable
    public func listResponsePlansPaginator(
        maxResults: Int? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) -> AWSClient.PaginatorSequence<ListResponsePlansInput, ListResponsePlansOutput> {
        let input = ListResponsePlansInput(
            maxResults: maxResults
        )
        return self.listResponsePlansPaginator(input, logger: logger)
    }

    /// Return PaginatorSequence for operation ``listTimelineEvents(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func listTimelineEventsPaginator(
        _ input: ListTimelineEventsInput,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<ListTimelineEventsInput, ListTimelineEventsOutput> {
        return .init(
            input: input,
            command: self.listTimelineEvents,
            inputKey: \ListTimelineEventsInput.nextToken,
            outputKey: \ListTimelineEventsOutput.nextToken,
            logger: logger
        )
    }
    /// Return PaginatorSequence for operation ``listTimelineEvents(_:logger:)``.
    ///
    /// - Parameters:
    ///   - filters: Filters the timeline events based on the provided conditional values. You can filter timeline events with the following keys:    eventReference     eventTime     eventType    Note the following when deciding how to use Filters:   If you don't specify a Filter, the response includes all timeline events.   If you specify more than one filter in a single request, the response returns timeline events that match all filters.   If you specify a filter with more than one value, the response returns timeline events that match any of the values provided.
    ///   - incidentRecordArn: The Amazon Resource Name (ARN) of the incident that includes the timeline event.
    ///   - maxResults: The maximum number of results per page.
    ///   - sortBy: Sort timeline events by the specified key value pair.
    ///   - sortOrder: Sorts the order of timeline events by the value specified in the sortBy field.
    ///   - logger: Logger used for logging
    @inlinable
    public func listTimelineEventsPaginator(
        filters: [Filter]? = nil,
        incidentRecordArn: String,
        maxResults: Int? = nil,
        sortBy: TimelineEventSort? = nil,
        sortOrder: SortOrder? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) -> AWSClient.PaginatorSequence<ListTimelineEventsInput, ListTimelineEventsOutput> {
        let input = ListTimelineEventsInput(
            filters: filters, 
            incidentRecordArn: incidentRecordArn, 
            maxResults: maxResults, 
            sortBy: sortBy, 
            sortOrder: sortOrder
        )
        return self.listTimelineEventsPaginator(input, logger: logger)
    }
}

extension SSMIncidents.GetResourcePoliciesInput: AWSPaginateToken {
    @inlinable
    public func usingPaginationToken(_ token: String) -> SSMIncidents.GetResourcePoliciesInput {
        return .init(
            maxResults: self.maxResults,
            nextToken: token,
            resourceArn: self.resourceArn
        )
    }
}

extension SSMIncidents.ListIncidentFindingsInput: AWSPaginateToken {
    @inlinable
    public func usingPaginationToken(_ token: String) -> SSMIncidents.ListIncidentFindingsInput {
        return .init(
            incidentRecordArn: self.incidentRecordArn,
            maxResults: self.maxResults,
            nextToken: token
        )
    }
}

extension SSMIncidents.ListIncidentRecordsInput: AWSPaginateToken {
    @inlinable
    public func usingPaginationToken(_ token: String) -> SSMIncidents.ListIncidentRecordsInput {
        return .init(
            filters: self.filters,
            maxResults: self.maxResults,
            nextToken: token
        )
    }
}

extension SSMIncidents.ListRelatedItemsInput: AWSPaginateToken {
    @inlinable
    public func usingPaginationToken(_ token: String) -> SSMIncidents.ListRelatedItemsInput {
        return .init(
            incidentRecordArn: self.incidentRecordArn,
            maxResults: self.maxResults,
            nextToken: token
        )
    }
}

extension SSMIncidents.ListReplicationSetsInput: AWSPaginateToken {
    @inlinable
    public func usingPaginationToken(_ token: String) -> SSMIncidents.ListReplicationSetsInput {
        return .init(
            maxResults: self.maxResults,
            nextToken: token
        )
    }
}

extension SSMIncidents.ListResponsePlansInput: AWSPaginateToken {
    @inlinable
    public func usingPaginationToken(_ token: String) -> SSMIncidents.ListResponsePlansInput {
        return .init(
            maxResults: self.maxResults,
            nextToken: token
        )
    }
}

extension SSMIncidents.ListTimelineEventsInput: AWSPaginateToken {
    @inlinable
    public func usingPaginationToken(_ token: String) -> SSMIncidents.ListTimelineEventsInput {
        return .init(
            filters: self.filters,
            incidentRecordArn: self.incidentRecordArn,
            maxResults: self.maxResults,
            nextToken: token,
            sortBy: self.sortBy,
            sortOrder: self.sortOrder
        )
    }
}

// MARK: Waiters

@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension SSMIncidents {
    /// Waiter for operation ``getReplicationSet(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func waitUntilWaitForReplicationSetActive(
        _ input: GetReplicationSetInput,
        maxWaitTime: TimeAmount? = nil,
        logger: Logger = AWSClient.loggingDisabled
    ) async throws {
        let waiter = AWSClient.Waiter<GetReplicationSetInput, _>(
            acceptors: [
                .init(state: .success, matcher: try! JMESPathMatcher("replicationSet.status", expected: "ACTIVE")),
                .init(state: .retry, matcher: try! JMESPathMatcher("replicationSet.status", expected: "CREATING")),
                .init(state: .retry, matcher: try! JMESPathMatcher("replicationSet.status", expected: "UPDATING")),
                .init(state: .failure, matcher: try! JMESPathMatcher("replicationSet.status", expected: "FAILED")),
            ],
            minDelayTime: .seconds(30),
            maxDelayTime: .seconds(30),
            command: self.getReplicationSet
        )
        return try await self.client.waitUntil(input, waiter: waiter, maxWaitTime: maxWaitTime, logger: logger)
    }
    /// Waiter for operation ``getReplicationSet(_:logger:)``.
    ///
    /// - Parameters:
    ///   - arn: The Amazon Resource Name (ARN) of the replication set you want to retrieve.
    ///   - logger: Logger used for logging
    @inlinable
    public func waitUntilWaitForReplicationSetActive(
        arn: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws {
        let input = GetReplicationSetInput(
            arn: arn
        )
        try await self.waitUntilWaitForReplicationSetActive(input, logger: logger)
    }

    /// Waiter for operation ``getReplicationSet(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func waitUntilWaitForReplicationSetDeleted(
        _ input: GetReplicationSetInput,
        maxWaitTime: TimeAmount? = nil,
        logger: Logger = AWSClient.loggingDisabled
    ) async throws {
        let waiter = AWSClient.Waiter<GetReplicationSetInput, _>(
            acceptors: [
                .init(state: .success, matcher: AWSErrorCodeMatcher("ResourceNotFoundException")),
                .init(state: .retry, matcher: try! JMESPathMatcher("replicationSet.status", expected: "DELETING")),
                .init(state: .failure, matcher: try! JMESPathMatcher("replicationSet.status", expected: "FAILED")),
            ],
            minDelayTime: .seconds(30),
            maxDelayTime: .seconds(30),
            command: self.getReplicationSet
        )
        return try await self.client.waitUntil(input, waiter: waiter, maxWaitTime: maxWaitTime, logger: logger)
    }
    /// Waiter for operation ``getReplicationSet(_:logger:)``.
    ///
    /// - Parameters:
    ///   - arn: The Amazon Resource Name (ARN) of the replication set you want to retrieve.
    ///   - logger: Logger used for logging
    @inlinable
    public func waitUntilWaitForReplicationSetDeleted(
        arn: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws {
        let input = GetReplicationSetInput(
            arn: arn
        )
        try await self.waitUntilWaitForReplicationSetDeleted(input, logger: logger)
    }
}
