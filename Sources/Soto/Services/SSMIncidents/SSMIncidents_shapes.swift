//===----------------------------------------------------------------------===//
//
// This source file is part of the Soto for AWS open source project
//
// Copyright (c) 2017-2023 the Soto project authors
// Licensed under Apache License v2.0
//
// See LICENSE.txt for license information
// See CONTRIBUTORS.txt for the list of Soto project authors
//
// SPDX-License-Identifier: Apache-2.0
//
//===----------------------------------------------------------------------===//

// THIS FILE IS AUTOMATICALLY GENERATED by https://github.com/soto-project/soto-codegenerator.
// DO NOT EDIT.

#if os(Linux) && compiler(<5.10)
// swift-corelibs-foundation hasn't been updated with Sendable conformances
@preconcurrency import Foundation
#else
import Foundation
#endif
@_spi(SotoInternal) import SotoCore

extension SSMIncidents {
    // MARK: Enums

    public enum IncidentRecordStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case open = "OPEN"
        case resolved = "RESOLVED"
        public var description: String { return self.rawValue }
    }

    public enum ItemType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case analysis = "ANALYSIS"
        case attachment = "ATTACHMENT"
        case automation = "AUTOMATION"
        case incident = "INCIDENT"
        case involvedResource = "INVOLVED_RESOURCE"
        case metric = "METRIC"
        case other = "OTHER"
        case parent = "PARENT"
        case task = "TASK"
        public var description: String { return self.rawValue }
    }

    public enum RegionStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        /// All operations have completed successfully and the region is ready to use
        case active = "ACTIVE"
        /// The region is in the process of being created.
        case creating = "CREATING"
        /// The region is in the process of being deleted.
        case deleting = "DELETING"
        /// The region is not healthy and we cannot automatically fix it.
        case failed = "FAILED"
        public var description: String { return self.rawValue }
    }

    public enum ReplicationSetStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        /// All operations have completed successfully and the replication set is ready to use
        case active = "ACTIVE"
        /// Replication set is in the process of being created.
        case creating = "CREATING"
        /// Replication set is in the process of being deleted.
        case deleting = "DELETING"
        /// Replication set is not healthy and we cannot fix it.
        case failed = "FAILED"
        /// Replication set is in the process of being updated.
        case updating = "UPDATING"
        public var description: String { return self.rawValue }
    }

    public enum SortOrder: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case ascending = "ASCENDING"
        case descending = "DESCENDING"
        public var description: String { return self.rawValue }
    }

    public enum SsmTargetAccount: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case impactedAccount = "IMPACTED_ACCOUNT"
        case responsePlanOwnerAccount = "RESPONSE_PLAN_OWNER_ACCOUNT"
        public var description: String { return self.rawValue }
    }

    public enum TimelineEventSort: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case eventTime = "EVENT_TIME"
        public var description: String { return self.rawValue }
    }

    public enum VariableType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case incidentRecordArn = "INCIDENT_RECORD_ARN"
        case involvedResources = "INVOLVED_RESOURCES"
        public var description: String { return self.rawValue }
    }

    public enum AttributeValueList: AWSEncodableShape, Sendable {
        /// The list of integer values that the filter matches.
        case integerValues([Int])
        /// The list of string values that the filter matches.
        case stringValues([String])

        public func encode(to encoder: Encoder) throws {
            var container = encoder.container(keyedBy: CodingKeys.self)
            switch self {
            case .integerValues(let value):
                try container.encode(value, forKey: .integerValues)
            case .stringValues(let value):
                try container.encode(value, forKey: .stringValues)
            }
        }

        public func validate(name: String) throws {
            switch self {
            case .integerValues(let value):
                try self.validate(value, name: "integerValues", parent: name, max: 100)
            case .stringValues(let value):
                try self.validate(value, name: "stringValues", parent: name, max: 100)
            }
        }

        private enum CodingKeys: String, CodingKey {
            case integerValues = "integerValues"
            case stringValues = "stringValues"
        }
    }

    public enum ChatChannel: AWSEncodableShape & AWSDecodableShape, Sendable {
        /// The Amazon SNS targets that Chatbot uses to notify the chat channel of updates to an incident. You can also make updates to the incident through the chat channel by using the Amazon SNS topics.
        case chatbotSns([String])
        /// Used to remove the chat channel from an incident record or response plan.
        case empty(EmptyChatChannel)

        public init(from decoder: Decoder) throws {
            let container = try decoder.container(keyedBy: CodingKeys.self)
            guard container.allKeys.count == 1, let key = container.allKeys.first else {
                let context = DecodingError.Context(
                    codingPath: container.codingPath,
                    debugDescription: "Expected exactly one key, but got \(container.allKeys.count)"
                )
                throw DecodingError.dataCorrupted(context)
            }
            switch key {
            case .chatbotSns:
                let value = try container.decode([String].self, forKey: .chatbotSns)
                self = .chatbotSns(value)
            case .empty:
                let value = try container.decode(EmptyChatChannel.self, forKey: .empty)
                self = .empty(value)
            }
        }

        public func encode(to encoder: Encoder) throws {
            var container = encoder.container(keyedBy: CodingKeys.self)
            switch self {
            case .chatbotSns(let value):
                try container.encode(value, forKey: .chatbotSns)
            case .empty(let value):
                try container.encode(value, forKey: .empty)
            }
        }

        public func validate(name: String) throws {
            switch self {
            case .chatbotSns(let value):
                try value.forEach {
                    try validate($0, name: "chatbotSns[]", parent: name, max: 1000)
                }
                try self.validate(value, name: "chatbotSns", parent: name, max: 5)
                try self.validate(value, name: "chatbotSns", parent: name, min: 1)
            default:
                break
            }
        }

        private enum CodingKeys: String, CodingKey {
            case chatbotSns = "chatbotSns"
            case empty = "empty"
        }
    }

    public enum Condition: AWSEncodableShape, Sendable {
        /// After the specified timestamp.
        case after(Date)
        /// Before the specified timestamp
        case before(Date)
        /// The value is equal to the provided string or integer.
        case equals(AttributeValueList)

        public func encode(to encoder: Encoder) throws {
            var container = encoder.container(keyedBy: CodingKeys.self)
            switch self {
            case .after(let value):
                try container.encode(value, forKey: .after)
            case .before(let value):
                try container.encode(value, forKey: .before)
            case .equals(let value):
                try container.encode(value, forKey: .equals)
            }
        }

        public func validate(name: String) throws {
            switch self {
            case .equals(let value):
                try value.validate(name: "\(name).equals")
            default:
                break
            }
        }

        private enum CodingKeys: String, CodingKey {
            case after = "after"
            case before = "before"
            case equals = "equals"
        }
    }

    public enum EventReference: AWSEncodableShape & AWSDecodableShape, Sendable {
        /// The ID of a RelatedItem referenced in a TimelineEvent.
        case relatedItemId(String)
        /// The Amazon Resource Name (ARN) of an Amazon Web Services resource referenced in a TimelineEvent.
        case resource(String)

        public init(from decoder: Decoder) throws {
            let container = try decoder.container(keyedBy: CodingKeys.self)
            guard container.allKeys.count == 1, let key = container.allKeys.first else {
                let context = DecodingError.Context(
                    codingPath: container.codingPath,
                    debugDescription: "Expected exactly one key, but got \(container.allKeys.count)"
                )
                throw DecodingError.dataCorrupted(context)
            }
            switch key {
            case .relatedItemId:
                let value = try container.decode(String.self, forKey: .relatedItemId)
                self = .relatedItemId(value)
            case .resource:
                let value = try container.decode(String.self, forKey: .resource)
                self = .resource(value)
            }
        }

        public func encode(to encoder: Encoder) throws {
            var container = encoder.container(keyedBy: CodingKeys.self)
            switch self {
            case .relatedItemId(let value):
                try container.encode(value, forKey: .relatedItemId)
            case .resource(let value):
                try container.encode(value, forKey: .resource)
            }
        }

        public func validate(name: String) throws {
            switch self {
            case .relatedItemId(let value):
                try self.validate(value, name: "relatedItemId", parent: name, max: 200)
                try self.validate(value, name: "relatedItemId", parent: name, pattern: "^related-item/(ANALYSIS|INCIDENT|METRIC|PARENT|ATTACHMENT|OTHER|AUTOMATION|INVOLVED_RESOURCE|TASK)/([0-9]|[A-F]){32}$")
            case .resource(let value):
                try self.validate(value, name: "resource", parent: name, max: 1000)
                try self.validate(value, name: "resource", parent: name, pattern: "^arn:aws(-cn|-us-gov)?:[a-z0-9-]*:[a-z0-9-]*:([0-9]{12})?:.+$")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case relatedItemId = "relatedItemId"
            case resource = "resource"
        }
    }

    public enum FindingDetails: AWSDecodableShape, Sendable {
        /// Information about the CloudFormation stack creation or update associated with the finding.
        case cloudFormationStackUpdate(CloudFormationStackUpdate)
        /// Information about the CodeDeploy deployment associated with the finding.
        case codeDeployDeployment(CodeDeployDeployment)

        public init(from decoder: Decoder) throws {
            let container = try decoder.container(keyedBy: CodingKeys.self)
            guard container.allKeys.count == 1, let key = container.allKeys.first else {
                let context = DecodingError.Context(
                    codingPath: container.codingPath,
                    debugDescription: "Expected exactly one key, but got \(container.allKeys.count)"
                )
                throw DecodingError.dataCorrupted(context)
            }
            switch key {
            case .cloudFormationStackUpdate:
                let value = try container.decode(CloudFormationStackUpdate.self, forKey: .cloudFormationStackUpdate)
                self = .cloudFormationStackUpdate(value)
            case .codeDeployDeployment:
                let value = try container.decode(CodeDeployDeployment.self, forKey: .codeDeployDeployment)
                self = .codeDeployDeployment(value)
            }
        }

        private enum CodingKeys: String, CodingKey {
            case cloudFormationStackUpdate = "cloudFormationStackUpdate"
            case codeDeployDeployment = "codeDeployDeployment"
        }
    }

    public enum ItemValue: AWSEncodableShape & AWSDecodableShape, Sendable {
        /// The Amazon Resource Name (ARN) of the related item, if the related item is an Amazon resource.
        case arn(String)
        /// The metric definition, if the related item is a metric in Amazon CloudWatch.
        case metricDefinition(String)
        /// Details about an incident that is associated with a PagerDuty incident.
        case pagerDutyIncidentDetail(PagerDutyIncidentDetail)
        /// The URL, if the related item is a non-Amazon Web Services resource.
        case url(String)

        public init(from decoder: Decoder) throws {
            let container = try decoder.container(keyedBy: CodingKeys.self)
            guard container.allKeys.count == 1, let key = container.allKeys.first else {
                let context = DecodingError.Context(
                    codingPath: container.codingPath,
                    debugDescription: "Expected exactly one key, but got \(container.allKeys.count)"
                )
                throw DecodingError.dataCorrupted(context)
            }
            switch key {
            case .arn:
                let value = try container.decode(String.self, forKey: .arn)
                self = .arn(value)
            case .metricDefinition:
                let value = try container.decode(String.self, forKey: .metricDefinition)
                self = .metricDefinition(value)
            case .pagerDutyIncidentDetail:
                let value = try container.decode(PagerDutyIncidentDetail.self, forKey: .pagerDutyIncidentDetail)
                self = .pagerDutyIncidentDetail(value)
            case .url:
                let value = try container.decode(String.self, forKey: .url)
                self = .url(value)
            }
        }

        public func encode(to encoder: Encoder) throws {
            var container = encoder.container(keyedBy: CodingKeys.self)
            switch self {
            case .arn(let value):
                try container.encode(value, forKey: .arn)
            case .metricDefinition(let value):
                try container.encode(value, forKey: .metricDefinition)
            case .pagerDutyIncidentDetail(let value):
                try container.encode(value, forKey: .pagerDutyIncidentDetail)
            case .url(let value):
                try container.encode(value, forKey: .url)
            }
        }

        public func validate(name: String) throws {
            switch self {
            case .arn(let value):
                try self.validate(value, name: "arn", parent: name, max: 1000)
                try self.validate(value, name: "arn", parent: name, pattern: "^arn:aws(-cn|-us-gov)?:[a-z0-9-]*:[a-z0-9-]*:([0-9]{12})?:.+$")
            case .metricDefinition(let value):
                try self.validate(value, name: "metricDefinition", parent: name, max: 4000)
            case .url(let value):
                try self.validate(value, name: "url", parent: name, max: 1000)
            default:
                break
            }
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case metricDefinition = "metricDefinition"
            case pagerDutyIncidentDetail = "pagerDutyIncidentDetail"
            case url = "url"
        }
    }

    public enum RelatedItemsUpdate: AWSEncodableShape, Sendable {
        /// Details about the related item you're adding.
        case itemToAdd(RelatedItem)
        /// Details about the related item you're deleting.
        case itemToRemove(ItemIdentifier)

        public func encode(to encoder: Encoder) throws {
            var container = encoder.container(keyedBy: CodingKeys.self)
            switch self {
            case .itemToAdd(let value):
                try container.encode(value, forKey: .itemToAdd)
            case .itemToRemove(let value):
                try container.encode(value, forKey: .itemToRemove)
            }
        }

        public func validate(name: String) throws {
            switch self {
            case .itemToAdd(let value):
                try value.validate(name: "\(name).itemToAdd")
            case .itemToRemove(let value):
                try value.validate(name: "\(name).itemToRemove")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case itemToAdd = "itemToAdd"
            case itemToRemove = "itemToRemove"
        }
    }

    public enum UpdateReplicationSetAction: AWSEncodableShape, Sendable {
        /// Details about the Amazon Web Services Region that you're adding to the replication set.
        case addRegionAction(AddRegionAction)
        /// Details about the Amazon Web Services Region that you're deleting to the replication set.
        case deleteRegionAction(DeleteRegionAction)

        public func encode(to encoder: Encoder) throws {
            var container = encoder.container(keyedBy: CodingKeys.self)
            switch self {
            case .addRegionAction(let value):
                try container.encode(value, forKey: .addRegionAction)
            case .deleteRegionAction(let value):
                try container.encode(value, forKey: .deleteRegionAction)
            }
        }

        public func validate(name: String) throws {
            switch self {
            case .addRegionAction(let value):
                try value.validate(name: "\(name).addRegionAction")
            case .deleteRegionAction(let value):
                try value.validate(name: "\(name).deleteRegionAction")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case addRegionAction = "addRegionAction"
            case deleteRegionAction = "deleteRegionAction"
        }
    }

    // MARK: Shapes

    public struct AddRegionAction: AWSEncodableShape {
        /// The Amazon Web Services Region name to add to the replication set.
        public let regionName: String
        /// The KMS key ID to use to encrypt your replication set.
        public let sseKmsKeyId: String?

        public init(regionName: String, sseKmsKeyId: String? = nil) {
            self.regionName = regionName
            self.sseKmsKeyId = sseKmsKeyId
        }

        public func validate(name: String) throws {
            try self.validate(self.regionName, name: "regionName", parent: name, max: 20)
            try self.validate(self.sseKmsKeyId, name: "sseKmsKeyId", parent: name, max: 2048)
        }

        private enum CodingKeys: String, CodingKey {
            case regionName = "regionName"
            case sseKmsKeyId = "sseKmsKeyId"
        }
    }

    public struct BatchGetIncidentFindingsError: AWSDecodableShape {
        /// The code associated with an error that was returned for a BatchGetIncidentFindings operation.
        public let code: String
        /// The ID of a specified finding for which an error was returned for a BatchGetIncidentFindings operation.
        public let findingId: String
        /// The description for an error that was returned for a BatchGetIncidentFindings operation.
        public let message: String

        public init(code: String, findingId: String, message: String) {
            self.code = code
            self.findingId = findingId
            self.message = message
        }

        private enum CodingKeys: String, CodingKey {
            case code = "code"
            case findingId = "findingId"
            case message = "message"
        }
    }

    public struct BatchGetIncidentFindingsInput: AWSEncodableShape {
        /// A list of IDs of findings for which you want to view details.
        public let findingIds: [String]
        /// The Amazon Resource Name (ARN) of the incident for which you want to view finding details.
        public let incidentRecordArn: String

        public init(findingIds: [String], incidentRecordArn: String) {
            self.findingIds = findingIds
            self.incidentRecordArn = incidentRecordArn
        }

        public func validate(name: String) throws {
            try self.findingIds.forEach {
                try validate($0, name: "findingIds[]", parent: name, max: 128)
            }
            try self.validate(self.findingIds, name: "findingIds", parent: name, max: 20)
            try self.validate(self.incidentRecordArn, name: "incidentRecordArn", parent: name, max: 1000)
            try self.validate(self.incidentRecordArn, name: "incidentRecordArn", parent: name, pattern: "^arn:aws(-cn|-us-gov)?:[a-z0-9-]*:[a-z0-9-]*:([0-9]{12})?:.+$")
        }

        private enum CodingKeys: String, CodingKey {
            case findingIds = "findingIds"
            case incidentRecordArn = "incidentRecordArn"
        }
    }

    public struct BatchGetIncidentFindingsOutput: AWSDecodableShape {
        /// A list of errors encountered during the operation.
        public let errors: [BatchGetIncidentFindingsError]
        /// Information about the requested findings.
        public let findings: [Finding]

        public init(errors: [BatchGetIncidentFindingsError], findings: [Finding]) {
            self.errors = errors
            self.findings = findings
        }

        private enum CodingKeys: String, CodingKey {
            case errors = "errors"
            case findings = "findings"
        }
    }

    public struct CloudFormationStackUpdate: AWSDecodableShape {
        /// The timestamp for when the CloudFormation stack creation or update ended. Not reported for deployments that are still in progress.
        public let endTime: Date?
        /// The Amazon Resource Name (ARN) of the CloudFormation stack involved in the update.
        public let stackArn: String
        /// The timestamp for when the CloudFormation stack creation or update began.
        public let startTime: Date

        public init(endTime: Date? = nil, stackArn: String, startTime: Date) {
            self.endTime = endTime
            self.stackArn = stackArn
            self.startTime = startTime
        }

        private enum CodingKeys: String, CodingKey {
            case endTime = "endTime"
            case stackArn = "stackArn"
            case startTime = "startTime"
        }
    }

    public struct CodeDeployDeployment: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the CodeDeploy deployment group associated with the deployment.
        public let deploymentGroupArn: String
        /// The ID of the CodeDeploy deployment.
        public let deploymentId: String
        /// The timestamp for when the CodeDeploy deployment ended. Not reported for deployments that are still in progress.
        public let endTime: Date?
        /// The timestamp for when the CodeDeploy deployment began.
        public let startTime: Date

        public init(deploymentGroupArn: String, deploymentId: String, endTime: Date? = nil, startTime: Date) {
            self.deploymentGroupArn = deploymentGroupArn
            self.deploymentId = deploymentId
            self.endTime = endTime
            self.startTime = startTime
        }

        private enum CodingKeys: String, CodingKey {
            case deploymentGroupArn = "deploymentGroupArn"
            case deploymentId = "deploymentId"
            case endTime = "endTime"
            case startTime = "startTime"
        }
    }

    public struct CreateReplicationSetInput: AWSEncodableShape {
        /// A token that ensures that the operation is called only once with the specified details.
        public let clientToken: String?
        /// The Regions that Incident Manager replicates your data to. You can have up to three Regions in your replication set.
        public let regions: [String: RegionMapInputValue]
        /// A list of tags to add to the replication set.
        public let tags: [String: String]?

        public init(clientToken: String? = CreateReplicationSetInput.idempotencyToken(), regions: [String: RegionMapInputValue], tags: [String: String]? = nil) {
            self.clientToken = clientToken
            self.regions = regions
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 128)
            try self.regions.forEach {
                try validate($0.key, name: "regions.key", parent: name, max: 20)
                try $0.value.validate(name: "\(name).regions[\"\($0.key)\"]")
            }
            try self.validate(self.regions, name: "regions", parent: name, max: 3)
            try self.validate(self.regions, name: "regions", parent: name, min: 1)
            try self.tags?.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.key, name: "tags.key", parent: name, pattern: "^(?!aws:)[A-Za-z0-9 _=@:.+-/]+$")
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, pattern: "^[A-Za-z0-9 _=@:.+-/]*$")
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 50)
            try self.validate(self.tags, name: "tags", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "clientToken"
            case regions = "regions"
            case tags = "tags"
        }
    }

    public struct CreateReplicationSetOutput: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the replication set.
        public let arn: String

        public init(arn: String) {
            self.arn = arn
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
        }
    }

    public struct CreateResponsePlanInput: AWSEncodableShape {
        /// The actions that the response plan starts at the beginning of an incident.
        public let actions: [Action]?
        /// The Chatbot chat channel used for collaboration during an incident.
        public let chatChannel: ChatChannel?
        /// A token ensuring that the operation is called only once with the specified details.
        public let clientToken: String?
        /// The long format of the response plan name. This field can contain spaces.
        public let displayName: String?
        /// The Amazon Resource Name (ARN) for the contacts and escalation plans that the response plan engages during an incident.
        public let engagements: [String]?
        /// Details used to create an incident when using this response plan.
        public let incidentTemplate: IncidentTemplate
        /// Information about third-party services integrated into the response plan.
        public let integrations: [Integration]?
        /// The short format name of the response plan. Can't include spaces.
        public let name: String
        /// A list of tags that you are adding to the response plan.
        public let tags: [String: String]?

        public init(actions: [Action]? = nil, chatChannel: ChatChannel? = nil, clientToken: String? = CreateResponsePlanInput.idempotencyToken(), displayName: String? = nil, engagements: [String]? = nil, incidentTemplate: IncidentTemplate, integrations: [Integration]? = nil, name: String, tags: [String: String]? = nil) {
            self.actions = actions
            self.chatChannel = chatChannel
            self.clientToken = clientToken
            self.displayName = displayName
            self.engagements = engagements
            self.incidentTemplate = incidentTemplate
            self.integrations = integrations
            self.name = name
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.actions?.forEach {
                try $0.validate(name: "\(name).actions[]")
            }
            try self.validate(self.actions, name: "actions", parent: name, max: 1)
            try self.chatChannel?.validate(name: "\(name).chatChannel")
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 128)
            try self.validate(self.displayName, name: "displayName", parent: name, max: 200)
            try self.engagements?.forEach {
                try validate($0, name: "engagements[]", parent: name, max: 2048)
                try validate($0, name: "engagements[]", parent: name, pattern: "^arn:aws(-cn|-us-gov)?:ssm-contacts:[a-z0-9-]*:([0-9]{12}):contact/[a-z0-9_-]+$")
            }
            try self.validate(self.engagements, name: "engagements", parent: name, max: 5)
            try self.incidentTemplate.validate(name: "\(name).incidentTemplate")
            try self.validate(self.integrations, name: "integrations", parent: name, max: 1)
            try self.validate(self.name, name: "name", parent: name, max: 200)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[a-zA-Z0-9-_]*$")
            try self.tags?.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.key, name: "tags.key", parent: name, pattern: "^(?!aws:)[A-Za-z0-9 _=@:.+-/]+$")
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, pattern: "^[A-Za-z0-9 _=@:.+-/]*$")
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 50)
            try self.validate(self.tags, name: "tags", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case actions = "actions"
            case chatChannel = "chatChannel"
            case clientToken = "clientToken"
            case displayName = "displayName"
            case engagements = "engagements"
            case incidentTemplate = "incidentTemplate"
            case integrations = "integrations"
            case name = "name"
            case tags = "tags"
        }
    }

    public struct CreateResponsePlanOutput: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the response plan.
        public let arn: String

        public init(arn: String) {
            self.arn = arn
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
        }
    }

    public struct CreateTimelineEventInput: AWSEncodableShape {
        /// A token that ensures that a client calls the action only once with the specified details.
        public let clientToken: String?
        /// A short description of the event.
        public let eventData: String
        /// Adds one or more references to the TimelineEvent. A reference is an Amazon Web Services resource involved or associated with the incident. To specify a reference, enter its Amazon Resource Name (ARN). You can also specify a related item associated with a resource. For example, to specify an Amazon DynamoDB (DynamoDB) table as a resource, use the table's ARN. You can also specify an Amazon CloudWatch metric associated with the DynamoDB table as a related item.
        public let eventReferences: [EventReference]?
        /// The timestamp for when the event occurred.
        public let eventTime: Date
        /// The type of event. You can create timeline events of type Custom Event and Note. To make a Note-type event appear on the Incident notes panel in the console, specify eventType as Noteand enter the Amazon Resource Name (ARN) of the incident as the value for eventReference.
        public let eventType: String
        /// The Amazon Resource Name (ARN) of the incident record that the action adds the incident to.
        public let incidentRecordArn: String

        public init(clientToken: String? = CreateTimelineEventInput.idempotencyToken(), eventData: String, eventReferences: [EventReference]? = nil, eventTime: Date, eventType: String, incidentRecordArn: String) {
            self.clientToken = clientToken
            self.eventData = eventData
            self.eventReferences = eventReferences
            self.eventTime = eventTime
            self.eventType = eventType
            self.incidentRecordArn = incidentRecordArn
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 128)
            try self.validate(self.eventData, name: "eventData", parent: name, max: 12000)
            try self.eventReferences?.forEach {
                try $0.validate(name: "\(name).eventReferences[]")
            }
            try self.validate(self.eventReferences, name: "eventReferences", parent: name, max: 10)
            try self.validate(self.eventType, name: "eventType", parent: name, max: 100)
            try self.validate(self.incidentRecordArn, name: "incidentRecordArn", parent: name, max: 1000)
            try self.validate(self.incidentRecordArn, name: "incidentRecordArn", parent: name, pattern: "^arn:aws(-cn|-us-gov)?:[a-z0-9-]*:[a-z0-9-]*:([0-9]{12})?:.+$")
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "clientToken"
            case eventData = "eventData"
            case eventReferences = "eventReferences"
            case eventTime = "eventTime"
            case eventType = "eventType"
            case incidentRecordArn = "incidentRecordArn"
        }
    }

    public struct CreateTimelineEventOutput: AWSDecodableShape {
        /// The ID of the event for easy reference later.
        public let eventId: String
        /// The ARN of the incident record that you added the event to.
        public let incidentRecordArn: String

        public init(eventId: String, incidentRecordArn: String) {
            self.eventId = eventId
            self.incidentRecordArn = incidentRecordArn
        }

        private enum CodingKeys: String, CodingKey {
            case eventId = "eventId"
            case incidentRecordArn = "incidentRecordArn"
        }
    }

    public struct DeleteIncidentRecordInput: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the incident record you are deleting.
        public let arn: String

        public init(arn: String) {
            self.arn = arn
        }

        public func validate(name: String) throws {
            try self.validate(self.arn, name: "arn", parent: name, max: 1000)
            try self.validate(self.arn, name: "arn", parent: name, pattern: "^arn:aws(-cn|-us-gov)?:[a-z0-9-]*:[a-z0-9-]*:([0-9]{12})?:.+$")
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
        }
    }

    public struct DeleteIncidentRecordOutput: AWSDecodableShape {
        public init() {}
    }

    public struct DeleteRegionAction: AWSEncodableShape {
        /// The name of the Amazon Web Services Region you're deleting from the replication set.
        public let regionName: String

        public init(regionName: String) {
            self.regionName = regionName
        }

        public func validate(name: String) throws {
            try self.validate(self.regionName, name: "regionName", parent: name, max: 20)
        }

        private enum CodingKeys: String, CodingKey {
            case regionName = "regionName"
        }
    }

    public struct DeleteReplicationSetInput: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the replication set you're deleting.
        public let arn: String

        public init(arn: String) {
            self.arn = arn
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.arn, key: "arn")
        }

        public func validate(name: String) throws {
            try self.validate(self.arn, name: "arn", parent: name, max: 1000)
            try self.validate(self.arn, name: "arn", parent: name, pattern: "^arn:aws(-cn|-us-gov)?:[a-z0-9-]*:[a-z0-9-]*:([0-9]{12})?:.+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteReplicationSetOutput: AWSDecodableShape {
        public init() {}
    }

    public struct DeleteResourcePolicyInput: AWSEncodableShape {
        /// The ID of the resource policy you're deleting.
        public let policyId: String
        /// The Amazon Resource Name (ARN) of the resource you're deleting the policy from.
        public let resourceArn: String

        public init(policyId: String, resourceArn: String) {
            self.policyId = policyId
            self.resourceArn = resourceArn
        }

        public func validate(name: String) throws {
            try self.validate(self.policyId, name: "policyId", parent: name, max: 256)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, max: 1000)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, pattern: "^arn:aws(-cn|-us-gov)?:[a-z0-9-]*:[a-z0-9-]*:([0-9]{12})?:.+$")
        }

        private enum CodingKeys: String, CodingKey {
            case policyId = "policyId"
            case resourceArn = "resourceArn"
        }
    }

    public struct DeleteResourcePolicyOutput: AWSDecodableShape {
        public init() {}
    }

    public struct DeleteResponsePlanInput: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the response plan.
        public let arn: String

        public init(arn: String) {
            self.arn = arn
        }

        public func validate(name: String) throws {
            try self.validate(self.arn, name: "arn", parent: name, max: 1000)
            try self.validate(self.arn, name: "arn", parent: name, pattern: "^arn:aws(-cn|-us-gov)?:[a-z0-9-]*:[a-z0-9-]*:([0-9]{12})?:.+$")
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
        }
    }

    public struct DeleteResponsePlanOutput: AWSDecodableShape {
        public init() {}
    }

    public struct DeleteTimelineEventInput: AWSEncodableShape {
        /// The ID of the event to update. You can use ListTimelineEvents to find an event's ID.
        public let eventId: String
        /// The Amazon Resource Name (ARN) of the incident that includes the timeline event.
        public let incidentRecordArn: String

        public init(eventId: String, incidentRecordArn: String) {
            self.eventId = eventId
            self.incidentRecordArn = incidentRecordArn
        }

        public func validate(name: String) throws {
            try self.validate(self.eventId, name: "eventId", parent: name, max: 50)
            try self.validate(self.incidentRecordArn, name: "incidentRecordArn", parent: name, max: 1000)
            try self.validate(self.incidentRecordArn, name: "incidentRecordArn", parent: name, pattern: "^arn:aws(-cn|-us-gov)?:[a-z0-9-]*:[a-z0-9-]*:([0-9]{12})?:.+$")
        }

        private enum CodingKeys: String, CodingKey {
            case eventId = "eventId"
            case incidentRecordArn = "incidentRecordArn"
        }
    }

    public struct DeleteTimelineEventOutput: AWSDecodableShape {
        public init() {}
    }

    public struct EmptyChatChannel: AWSEncodableShape & AWSDecodableShape {
        public init() {}
    }

    public struct EventSummary: AWSDecodableShape {
        /// The timeline event ID.
        public let eventId: String
        /// A list of references in a TimelineEvent.
        public let eventReferences: [EventReference]?
        /// The timestamp for when the event occurred.
        public let eventTime: Date
        /// The type of event. The timeline event must be Custom Event or Note.
        public let eventType: String
        /// The timestamp for when the timeline event was last updated.
        public let eventUpdatedTime: Date
        /// The Amazon Resource Name (ARN) of the incident that the event happened during.
        public let incidentRecordArn: String

        public init(eventId: String, eventReferences: [EventReference]? = nil, eventTime: Date, eventType: String, eventUpdatedTime: Date, incidentRecordArn: String) {
            self.eventId = eventId
            self.eventReferences = eventReferences
            self.eventTime = eventTime
            self.eventType = eventType
            self.eventUpdatedTime = eventUpdatedTime
            self.incidentRecordArn = incidentRecordArn
        }

        private enum CodingKeys: String, CodingKey {
            case eventId = "eventId"
            case eventReferences = "eventReferences"
            case eventTime = "eventTime"
            case eventType = "eventType"
            case eventUpdatedTime = "eventUpdatedTime"
            case incidentRecordArn = "incidentRecordArn"
        }
    }

    public struct Filter: AWSEncodableShape {
        /// The condition accepts before or after a specified time, equal to a string, or equal to an integer.
        public let condition: Condition
        /// The key that you're filtering on.
        public let key: String

        public init(condition: Condition, key: String) {
            self.condition = condition
            self.key = key
        }

        public func validate(name: String) throws {
            try self.condition.validate(name: "\(name).condition")
        }

        private enum CodingKeys: String, CodingKey {
            case condition = "condition"
            case key = "key"
        }
    }

    public struct Finding: AWSDecodableShape {
        /// The timestamp for when a finding was created.
        public let creationTime: Date
        /// Details about the finding.
        public let details: FindingDetails?
        /// The ID assigned to the finding.
        public let id: String
        /// The timestamp for when the finding was most recently updated with additional information.
        public let lastModifiedTime: Date

        public init(creationTime: Date, details: FindingDetails? = nil, id: String, lastModifiedTime: Date) {
            self.creationTime = creationTime
            self.details = details
            self.id = id
            self.lastModifiedTime = lastModifiedTime
        }

        private enum CodingKeys: String, CodingKey {
            case creationTime = "creationTime"
            case details = "details"
            case id = "id"
            case lastModifiedTime = "lastModifiedTime"
        }
    }

    public struct FindingSummary: AWSDecodableShape {
        /// The ID of the finding.
        public let id: String
        /// The timestamp for when the finding was last updated.
        public let lastModifiedTime: Date

        public init(id: String, lastModifiedTime: Date) {
            self.id = id
            self.lastModifiedTime = lastModifiedTime
        }

        private enum CodingKeys: String, CodingKey {
            case id = "id"
            case lastModifiedTime = "lastModifiedTime"
        }
    }

    public struct GetIncidentRecordInput: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the incident record.
        public let arn: String

        public init(arn: String) {
            self.arn = arn
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.arn, key: "arn")
        }

        public func validate(name: String) throws {
            try self.validate(self.arn, name: "arn", parent: name, max: 1000)
            try self.validate(self.arn, name: "arn", parent: name, pattern: "^arn:aws(-cn|-us-gov)?:[a-z0-9-]*:[a-z0-9-]*:([0-9]{12})?:.+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetIncidentRecordOutput: AWSDecodableShape {
        /// Details the structure of the incident record.
        public let incidentRecord: IncidentRecord

        public init(incidentRecord: IncidentRecord) {
            self.incidentRecord = incidentRecord
        }

        private enum CodingKeys: String, CodingKey {
            case incidentRecord = "incidentRecord"
        }
    }

    public struct GetReplicationSetInput: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the replication set you want to retrieve.
        public let arn: String

        public init(arn: String) {
            self.arn = arn
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.arn, key: "arn")
        }

        public func validate(name: String) throws {
            try self.validate(self.arn, name: "arn", parent: name, max: 1000)
            try self.validate(self.arn, name: "arn", parent: name, pattern: "^arn:aws(-cn|-us-gov)?:[a-z0-9-]*:[a-z0-9-]*:([0-9]{12})?:.+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetReplicationSetOutput: AWSDecodableShape {
        /// Details of the replication set.
        public let replicationSet: ReplicationSet

        public init(replicationSet: ReplicationSet) {
            self.replicationSet = replicationSet
        }

        private enum CodingKeys: String, CodingKey {
            case replicationSet = "replicationSet"
        }
    }

    public struct GetResourcePoliciesInput: AWSEncodableShape {
        /// The maximum number of resource policies to display for each page of results.
        public let maxResults: Int?
        /// The pagination token for the next set of items to return. (You received this token from a previous call.)
        public let nextToken: String?
        /// The Amazon Resource Name (ARN) of the response plan with the attached resource policy.
        public let resourceArn: String

        public init(maxResults: Int? = nil, nextToken: String? = nil, resourceArn: String) {
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.resourceArn = resourceArn
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.maxResults, forKey: .maxResults)
            try container.encodeIfPresent(self.nextToken, forKey: .nextToken)
            request.encodeQuery(self.resourceArn, key: "resourceArn")
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 2000)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, max: 1000)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, pattern: "^arn:aws(-cn|-us-gov)?:[a-z0-9-]*:[a-z0-9-]*:([0-9]{12})?:.+$")
        }

        private enum CodingKeys: String, CodingKey {
            case maxResults = "maxResults"
            case nextToken = "nextToken"
        }
    }

    public struct GetResourcePoliciesOutput: AWSDecodableShape {
        /// The pagination token to use when requesting the next set of items. If there are no additional items to return, the string is null.
        public let nextToken: String?
        /// Details about the resource policy attached to the response plan.
        public let resourcePolicies: [ResourcePolicy]

        public init(nextToken: String? = nil, resourcePolicies: [ResourcePolicy]) {
            self.nextToken = nextToken
            self.resourcePolicies = resourcePolicies
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "nextToken"
            case resourcePolicies = "resourcePolicies"
        }
    }

    public struct GetResponsePlanInput: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the response plan.
        public let arn: String

        public init(arn: String) {
            self.arn = arn
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.arn, key: "arn")
        }

        public func validate(name: String) throws {
            try self.validate(self.arn, name: "arn", parent: name, max: 1000)
            try self.validate(self.arn, name: "arn", parent: name, pattern: "^arn:aws(-cn|-us-gov)?:[a-z0-9-]*:[a-z0-9-]*:([0-9]{12})?:.+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetResponsePlanOutput: AWSDecodableShape {
        /// The actions that this response plan takes at the beginning of the incident.
        public let actions: [Action]?
        /// The ARN of the response plan.
        public let arn: String
        /// The Chatbot chat channel used for collaboration during an incident.
        public let chatChannel: ChatChannel?
        /// The long format name of the response plan. Can contain spaces.
        public let displayName: String?
        /// The Amazon Resource Name (ARN) for the contacts and escalation plans that the response plan engages during an incident.
        public let engagements: [String]?
        /// Details used to create the incident when using this response plan.
        public let incidentTemplate: IncidentTemplate
        /// Information about third-party services integrated into the Incident Manager response plan.
        public let integrations: [Integration]?
        /// The short format name of the response plan. The name can't contain spaces.
        public let name: String

        public init(actions: [Action]? = nil, arn: String, chatChannel: ChatChannel? = nil, displayName: String? = nil, engagements: [String]? = nil, incidentTemplate: IncidentTemplate, integrations: [Integration]? = nil, name: String) {
            self.actions = actions
            self.arn = arn
            self.chatChannel = chatChannel
            self.displayName = displayName
            self.engagements = engagements
            self.incidentTemplate = incidentTemplate
            self.integrations = integrations
            self.name = name
        }

        private enum CodingKeys: String, CodingKey {
            case actions = "actions"
            case arn = "arn"
            case chatChannel = "chatChannel"
            case displayName = "displayName"
            case engagements = "engagements"
            case incidentTemplate = "incidentTemplate"
            case integrations = "integrations"
            case name = "name"
        }
    }

    public struct GetTimelineEventInput: AWSEncodableShape {
        /// The ID of the event. You can get an event's ID when you create it, or by using ListTimelineEvents.
        public let eventId: String
        /// The Amazon Resource Name (ARN) of the incident that includes the timeline event.
        public let incidentRecordArn: String

        public init(eventId: String, incidentRecordArn: String) {
            self.eventId = eventId
            self.incidentRecordArn = incidentRecordArn
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.eventId, key: "eventId")
            request.encodeQuery(self.incidentRecordArn, key: "incidentRecordArn")
        }

        public func validate(name: String) throws {
            try self.validate(self.eventId, name: "eventId", parent: name, max: 50)
            try self.validate(self.incidentRecordArn, name: "incidentRecordArn", parent: name, max: 1000)
            try self.validate(self.incidentRecordArn, name: "incidentRecordArn", parent: name, pattern: "^arn:aws(-cn|-us-gov)?:[a-z0-9-]*:[a-z0-9-]*:([0-9]{12})?:.+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetTimelineEventOutput: AWSDecodableShape {
        /// Details about the timeline event.
        public let event: TimelineEvent

        public init(event: TimelineEvent) {
            self.event = event
        }

        private enum CodingKeys: String, CodingKey {
            case event = "event"
        }
    }

    public struct IncidentRecord: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the incident record.
        public let arn: String
        /// The runbook, or automation document, that's run at the beginning of the incident.
        public let automationExecutions: [AutomationExecution]?
        /// The chat channel used for collaboration during an incident.
        public let chatChannel: ChatChannel?
        /// The timestamp for when Incident Manager created the incident record.
        public let creationTime: Date
        /// The string Incident Manager uses to prevent duplicate incidents from being created by the same incident in the same account.
        public let dedupeString: String
        /// The impact of the incident on customers and applications.  Supported impact codes     1 - Critical    2 - High    3 - Medium    4 - Low    5 - No Impact
        public let impact: Int
        /// Details about the action that started the incident.
        public let incidentRecordSource: IncidentRecordSource
        /// Who modified the incident most recently.
        public let lastModifiedBy: String
        /// The timestamp for when the incident was most recently modified.
        public let lastModifiedTime: Date
        /// The Amazon SNS targets that are notified when updates are made to an incident.
        public let notificationTargets: [NotificationTargetItem]?
        /// The timestamp for when the incident was resolved. This appears as a timeline event.
        public let resolvedTime: Date?
        /// The current status of the incident.
        public let status: IncidentRecordStatus
        /// The summary of the incident. The summary is a brief synopsis of what occurred, what's currently happening, and context of the incident.
        public let summary: String?
        /// The title of the incident.
        public let title: String

        public init(arn: String, automationExecutions: [AutomationExecution]? = nil, chatChannel: ChatChannel? = nil, creationTime: Date, dedupeString: String, impact: Int, incidentRecordSource: IncidentRecordSource, lastModifiedBy: String, lastModifiedTime: Date, notificationTargets: [NotificationTargetItem]? = nil, resolvedTime: Date? = nil, status: IncidentRecordStatus, summary: String? = nil, title: String) {
            self.arn = arn
            self.automationExecutions = automationExecutions
            self.chatChannel = chatChannel
            self.creationTime = creationTime
            self.dedupeString = dedupeString
            self.impact = impact
            self.incidentRecordSource = incidentRecordSource
            self.lastModifiedBy = lastModifiedBy
            self.lastModifiedTime = lastModifiedTime
            self.notificationTargets = notificationTargets
            self.resolvedTime = resolvedTime
            self.status = status
            self.summary = summary
            self.title = title
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case automationExecutions = "automationExecutions"
            case chatChannel = "chatChannel"
            case creationTime = "creationTime"
            case dedupeString = "dedupeString"
            case impact = "impact"
            case incidentRecordSource = "incidentRecordSource"
            case lastModifiedBy = "lastModifiedBy"
            case lastModifiedTime = "lastModifiedTime"
            case notificationTargets = "notificationTargets"
            case resolvedTime = "resolvedTime"
            case status = "status"
            case summary = "summary"
            case title = "title"
        }
    }

    public struct IncidentRecordSource: AWSDecodableShape {
        /// The principal that started the incident.
        public let createdBy: String
        /// The service principal that assumed the role specified in createdBy. If no service principal assumed the role this will be left blank.
        public let invokedBy: String?
        /// The resource that caused the incident to be created.
        public let resourceArn: String?
        /// The service that started the incident. This can be manually created from Incident Manager, automatically created using an Amazon CloudWatch alarm, or Amazon EventBridge event.
        public let source: String

        public init(createdBy: String, invokedBy: String? = nil, resourceArn: String? = nil, source: String) {
            self.createdBy = createdBy
            self.invokedBy = invokedBy
            self.resourceArn = resourceArn
            self.source = source
        }

        private enum CodingKeys: String, CodingKey {
            case createdBy = "createdBy"
            case invokedBy = "invokedBy"
            case resourceArn = "resourceArn"
            case source = "source"
        }
    }

    public struct IncidentRecordSummary: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the incident.
        public let arn: String
        /// The timestamp for when the incident was created.
        public let creationTime: Date
        /// Defines the impact to customers and applications.
        public let impact: Int
        /// What caused Incident Manager to create the incident.
        public let incidentRecordSource: IncidentRecordSource
        /// The timestamp for when the incident was resolved.
        public let resolvedTime: Date?
        /// The current status of the incident.
        public let status: IncidentRecordStatus
        /// The title of the incident. This value is either provided by the response plan or overwritten on creation.
        public let title: String

        public init(arn: String, creationTime: Date, impact: Int, incidentRecordSource: IncidentRecordSource, resolvedTime: Date? = nil, status: IncidentRecordStatus, title: String) {
            self.arn = arn
            self.creationTime = creationTime
            self.impact = impact
            self.incidentRecordSource = incidentRecordSource
            self.resolvedTime = resolvedTime
            self.status = status
            self.title = title
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case creationTime = "creationTime"
            case impact = "impact"
            case incidentRecordSource = "incidentRecordSource"
            case resolvedTime = "resolvedTime"
            case status = "status"
            case title = "title"
        }
    }

    public struct IncidentTemplate: AWSEncodableShape & AWSDecodableShape {
        /// The string Incident Manager uses to prevent the same root cause from creating multiple incidents in the same account. A deduplication string is a term or phrase the system uses to check for duplicate incidents. If you specify a deduplication string, Incident Manager searches for open incidents that contain the same string in the dedupeString field when it creates the incident. If a duplicate is detected, Incident Manager deduplicates the newer incident into the existing incident.  By default, Incident Manager automatically deduplicates multiple incidents created by the same Amazon CloudWatch alarm or Amazon EventBridge event. You don't have to enter your own deduplication string to prevent duplication for these resource types.
        public let dedupeString: String?
        /// The impact of the incident on your customers and applications.  Supported impact codes     1 - Critical    2 - High    3 - Medium    4 - Low    5 - No Impact
        public let impact: Int
        /// Tags to assign to the template. When the StartIncident API action is called, Incident Manager assigns the tags specified in the template to the incident.
        public let incidentTags: [String: String]?
        /// The Amazon SNS targets that are notified when updates are made to an incident.
        public let notificationTargets: [NotificationTargetItem]?
        /// The summary of the incident. The summary is a brief synopsis of what occurred, what's currently happening, and context.
        public let summary: String?
        /// The title of the incident.
        public let title: String

        public init(dedupeString: String? = nil, impact: Int, incidentTags: [String: String]? = nil, notificationTargets: [NotificationTargetItem]? = nil, summary: String? = nil, title: String) {
            self.dedupeString = dedupeString
            self.impact = impact
            self.incidentTags = incidentTags
            self.notificationTargets = notificationTargets
            self.summary = summary
            self.title = title
        }

        public func validate(name: String) throws {
            try self.validate(self.dedupeString, name: "dedupeString", parent: name, max: 1000)
            try self.validate(self.impact, name: "impact", parent: name, max: 5)
            try self.validate(self.impact, name: "impact", parent: name, min: 1)
            try self.incidentTags?.forEach {
                try validate($0.key, name: "incidentTags.key", parent: name, max: 128)
                try validate($0.key, name: "incidentTags.key", parent: name, min: 1)
                try validate($0.key, name: "incidentTags.key", parent: name, pattern: "^(?!aws:)[A-Za-z0-9 _=@:.+-/]+$")
                try validate($0.value, name: "incidentTags[\"\($0.key)\"]", parent: name, max: 256)
                try validate($0.value, name: "incidentTags[\"\($0.key)\"]", parent: name, pattern: "^[A-Za-z0-9 _=@:.+-/]*$")
            }
            try self.validate(self.incidentTags, name: "incidentTags", parent: name, max: 50)
            try self.validate(self.incidentTags, name: "incidentTags", parent: name, min: 1)
            try self.notificationTargets?.forEach {
                try $0.validate(name: "\(name).notificationTargets[]")
            }
            try self.validate(self.notificationTargets, name: "notificationTargets", parent: name, max: 10)
            try self.validate(self.summary, name: "summary", parent: name, max: 8000)
            try self.validate(self.title, name: "title", parent: name, max: 200)
        }

        private enum CodingKeys: String, CodingKey {
            case dedupeString = "dedupeString"
            case impact = "impact"
            case incidentTags = "incidentTags"
            case notificationTargets = "notificationTargets"
            case summary = "summary"
            case title = "title"
        }
    }

    public struct ItemIdentifier: AWSEncodableShape & AWSDecodableShape {
        /// The type of related item.
        public let type: ItemType
        /// Details about the related item.
        public let value: ItemValue

        public init(type: ItemType, value: ItemValue) {
            self.type = type
            self.value = value
        }

        public func validate(name: String) throws {
            try self.value.validate(name: "\(name).value")
        }

        private enum CodingKeys: String, CodingKey {
            case type = "type"
            case value = "value"
        }
    }

    public struct ListIncidentFindingsInput: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the incident for which you want to view associated findings.
        public let incidentRecordArn: String
        /// The maximum number of findings to retrieve per call.
        public let maxResults: Int?
        /// The pagination token for the next set of items to return. (You received this token from a previous call.)
        public let nextToken: String?

        public init(incidentRecordArn: String, maxResults: Int? = nil, nextToken: String? = nil) {
            self.incidentRecordArn = incidentRecordArn
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.validate(self.incidentRecordArn, name: "incidentRecordArn", parent: name, max: 1000)
            try self.validate(self.incidentRecordArn, name: "incidentRecordArn", parent: name, pattern: "^arn:aws(-cn|-us-gov)?:[a-z0-9-]*:[a-z0-9-]*:([0-9]{12})?:.+$")
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 2000)
        }

        private enum CodingKeys: String, CodingKey {
            case incidentRecordArn = "incidentRecordArn"
            case maxResults = "maxResults"
            case nextToken = "nextToken"
        }
    }

    public struct ListIncidentFindingsOutput: AWSDecodableShape {
        /// A list of findings that represent deployments that might be the potential cause of the incident.
        public let findings: [FindingSummary]
        /// The pagination token to use when requesting the next set of items. If there are no additional items to return, the string is null.
        public let nextToken: String?

        public init(findings: [FindingSummary], nextToken: String? = nil) {
            self.findings = findings
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case findings = "findings"
            case nextToken = "nextToken"
        }
    }

    public struct ListIncidentRecordsInput: AWSEncodableShape {
        /// Filters the list of incident records you want to search through. You can filter on the following keys:    creationTime     impact     status     createdBy    Note the following when when you use Filters:   If you don't specify a Filter, the response includes all incident records.   If you specify more than one filter in a single request, the response returns incident records that match all filters.   If you specify a filter with more than one value, the response returns incident records that match any of the values provided.
        public let filters: [Filter]?
        /// The maximum number of results per page.
        public let maxResults: Int?
        /// The pagination token for the next set of items to return. (You received this token from a previous call.)
        public let nextToken: String?

        public init(filters: [Filter]? = nil, maxResults: Int? = nil, nextToken: String? = nil) {
            self.filters = filters
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.filters?.forEach {
                try $0.validate(name: "\(name).filters[]")
            }
            try self.validate(self.filters, name: "filters", parent: name, max: 5)
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 2000)
        }

        private enum CodingKeys: String, CodingKey {
            case filters = "filters"
            case maxResults = "maxResults"
            case nextToken = "nextToken"
        }
    }

    public struct ListIncidentRecordsOutput: AWSDecodableShape {
        /// The details of each listed incident record.
        public let incidentRecordSummaries: [IncidentRecordSummary]
        /// The pagination token to use when requesting the next set of items. If there are no additional items to return, the string is null.
        public let nextToken: String?

        public init(incidentRecordSummaries: [IncidentRecordSummary], nextToken: String? = nil) {
            self.incidentRecordSummaries = incidentRecordSummaries
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case incidentRecordSummaries = "incidentRecordSummaries"
            case nextToken = "nextToken"
        }
    }

    public struct ListRelatedItemsInput: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the incident record containing the listed related items.
        public let incidentRecordArn: String
        /// The maximum number of related items per page.
        public let maxResults: Int?
        /// The pagination token for the next set of items to return. (You received this token from a previous call.)
        public let nextToken: String?

        public init(incidentRecordArn: String, maxResults: Int? = nil, nextToken: String? = nil) {
            self.incidentRecordArn = incidentRecordArn
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.validate(self.incidentRecordArn, name: "incidentRecordArn", parent: name, max: 1000)
            try self.validate(self.incidentRecordArn, name: "incidentRecordArn", parent: name, pattern: "^arn:aws(-cn|-us-gov)?:[a-z0-9-]*:[a-z0-9-]*:([0-9]{12})?:.+$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 2000)
        }

        private enum CodingKeys: String, CodingKey {
            case incidentRecordArn = "incidentRecordArn"
            case maxResults = "maxResults"
            case nextToken = "nextToken"
        }
    }

    public struct ListRelatedItemsOutput: AWSDecodableShape {
        /// The pagination token to use when requesting the next set of items. If there are no additional items to return, the string is null.
        public let nextToken: String?
        /// Details about each related item.
        public let relatedItems: [RelatedItem]

        public init(nextToken: String? = nil, relatedItems: [RelatedItem]) {
            self.nextToken = nextToken
            self.relatedItems = relatedItems
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "nextToken"
            case relatedItems = "relatedItems"
        }
    }

    public struct ListReplicationSetsInput: AWSEncodableShape {
        /// The maximum number of results per page.
        public let maxResults: Int?
        /// The pagination token for the next set of items to return. (You received this token from a previous call.)
        public let nextToken: String?

        public init(maxResults: Int? = nil, nextToken: String? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 2000)
        }

        private enum CodingKeys: String, CodingKey {
            case maxResults = "maxResults"
            case nextToken = "nextToken"
        }
    }

    public struct ListReplicationSetsOutput: AWSDecodableShape {
        /// The pagination token to use when requesting the next set of items. If there are no additional items to return, the string is null.
        public let nextToken: String?
        /// The Amazon Resource Name (ARN) of the list replication set.
        public let replicationSetArns: [String]

        public init(nextToken: String? = nil, replicationSetArns: [String]) {
            self.nextToken = nextToken
            self.replicationSetArns = replicationSetArns
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "nextToken"
            case replicationSetArns = "replicationSetArns"
        }
    }

    public struct ListResponsePlansInput: AWSEncodableShape {
        /// The maximum number of response plans per page.
        public let maxResults: Int?
        /// The pagination token for the next set of items to return. (You received this token from a previous call.)
        public let nextToken: String?

        public init(maxResults: Int? = nil, nextToken: String? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 2000)
        }

        private enum CodingKeys: String, CodingKey {
            case maxResults = "maxResults"
            case nextToken = "nextToken"
        }
    }

    public struct ListResponsePlansOutput: AWSDecodableShape {
        /// The pagination token to use when requesting the next set of items. If there are no additional items to return, the string is null.
        public let nextToken: String?
        /// Details of each response plan.
        public let responsePlanSummaries: [ResponsePlanSummary]

        public init(nextToken: String? = nil, responsePlanSummaries: [ResponsePlanSummary]) {
            self.nextToken = nextToken
            self.responsePlanSummaries = responsePlanSummaries
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "nextToken"
            case responsePlanSummaries = "responsePlanSummaries"
        }
    }

    public struct ListTagsForResourceRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the response plan or incident.
        public let resourceArn: String

        public init(resourceArn: String) {
            self.resourceArn = resourceArn
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.resourceArn, key: "resourceArn")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListTagsForResourceResponse: AWSDecodableShape {
        /// A list of tags for the response plan or incident.
        public let tags: [String: String]

        public init(tags: [String: String]) {
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case tags = "tags"
        }
    }

    public struct ListTimelineEventsInput: AWSEncodableShape {
        /// Filters the timeline events based on the provided conditional values. You can filter timeline events with the following keys:    eventReference     eventTime     eventType    Note the following when deciding how to use Filters:   If you don't specify a Filter, the response includes all timeline events.   If you specify more than one filter in a single request, the response returns timeline events that match all filters.   If you specify a filter with more than one value, the response returns timeline events that match any of the values provided.
        public let filters: [Filter]?
        /// The Amazon Resource Name (ARN) of the incident that includes the timeline event.
        public let incidentRecordArn: String
        /// The maximum number of results per page.
        public let maxResults: Int?
        /// The pagination token for the next set of items to return. (You received this token from a previous call.)
        public let nextToken: String?
        /// Sort timeline events by the specified key value pair.
        public let sortBy: TimelineEventSort?
        /// Sorts the order of timeline events by the value specified in the sortBy field.
        public let sortOrder: SortOrder?

        public init(filters: [Filter]? = nil, incidentRecordArn: String, maxResults: Int? = nil, nextToken: String? = nil, sortBy: TimelineEventSort? = nil, sortOrder: SortOrder? = nil) {
            self.filters = filters
            self.incidentRecordArn = incidentRecordArn
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.sortBy = sortBy
            self.sortOrder = sortOrder
        }

        public func validate(name: String) throws {
            try self.filters?.forEach {
                try $0.validate(name: "\(name).filters[]")
            }
            try self.validate(self.filters, name: "filters", parent: name, max: 5)
            try self.validate(self.incidentRecordArn, name: "incidentRecordArn", parent: name, max: 1000)
            try self.validate(self.incidentRecordArn, name: "incidentRecordArn", parent: name, pattern: "^arn:aws(-cn|-us-gov)?:[a-z0-9-]*:[a-z0-9-]*:([0-9]{12})?:.+$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 2000)
        }

        private enum CodingKeys: String, CodingKey {
            case filters = "filters"
            case incidentRecordArn = "incidentRecordArn"
            case maxResults = "maxResults"
            case nextToken = "nextToken"
            case sortBy = "sortBy"
            case sortOrder = "sortOrder"
        }
    }

    public struct ListTimelineEventsOutput: AWSDecodableShape {
        /// Details about each event that occurred during the incident.
        public let eventSummaries: [EventSummary]
        /// The pagination token to use when requesting the next set of items. If there are no additional items to return, the string is null.
        public let nextToken: String?

        public init(eventSummaries: [EventSummary], nextToken: String? = nil) {
            self.eventSummaries = eventSummaries
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case eventSummaries = "eventSummaries"
            case nextToken = "nextToken"
        }
    }

    public struct PagerDutyConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The name of the PagerDuty configuration.
        public let name: String
        /// Details about the PagerDuty service associated with the configuration.
        public let pagerDutyIncidentConfiguration: PagerDutyIncidentConfiguration
        /// The ID of the Amazon Web Services Secrets Manager secret that stores your PagerDuty key, either a General Access REST API Key or User Token REST API Key, and other user credentials.
        public let secretId: String

        public init(name: String, pagerDutyIncidentConfiguration: PagerDutyIncidentConfiguration, secretId: String) {
            self.name = name
            self.pagerDutyIncidentConfiguration = pagerDutyIncidentConfiguration
            self.secretId = secretId
        }

        private enum CodingKeys: String, CodingKey {
            case name = "name"
            case pagerDutyIncidentConfiguration = "pagerDutyIncidentConfiguration"
            case secretId = "secretId"
        }
    }

    public struct PagerDutyIncidentConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The ID of the PagerDuty service that the response plan associates with an incident when it launches.
        public let serviceId: String

        public init(serviceId: String) {
            self.serviceId = serviceId
        }

        private enum CodingKeys: String, CodingKey {
            case serviceId = "serviceId"
        }
    }

    public struct PagerDutyIncidentDetail: AWSEncodableShape & AWSDecodableShape {
        /// Indicates whether to resolve the PagerDuty incident when you resolve the associated Incident Manager incident.
        public let autoResolve: Bool?
        /// The ID of the incident associated with the PagerDuty service for the response plan.
        public let id: String
        /// The ID of the Amazon Web Services Secrets Manager secret that stores your PagerDuty key, either a General Access REST API Key or User Token REST API Key, and other user credentials.
        public let secretId: String?

        public init(autoResolve: Bool? = nil, id: String, secretId: String? = nil) {
            self.autoResolve = autoResolve
            self.id = id
            self.secretId = secretId
        }

        private enum CodingKeys: String, CodingKey {
            case autoResolve = "autoResolve"
            case id = "id"
            case secretId = "secretId"
        }
    }

    public struct PutResourcePolicyInput: AWSEncodableShape {
        /// Details of the resource policy.
        public let policy: String
        /// The Amazon Resource Name (ARN) of the response plan to add the resource policy to.
        public let resourceArn: String

        public init(policy: String, resourceArn: String) {
            self.policy = policy
            self.resourceArn = resourceArn
        }

        public func validate(name: String) throws {
            try self.validate(self.policy, name: "policy", parent: name, max: 4000)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, max: 1000)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, pattern: "^arn:aws(-cn|-us-gov)?:[a-z0-9-]*:[a-z0-9-]*:([0-9]{12})?:.+$")
        }

        private enum CodingKeys: String, CodingKey {
            case policy = "policy"
            case resourceArn = "resourceArn"
        }
    }

    public struct PutResourcePolicyOutput: AWSDecodableShape {
        /// The ID of the resource policy.
        public let policyId: String

        public init(policyId: String) {
            self.policyId = policyId
        }

        private enum CodingKeys: String, CodingKey {
            case policyId = "policyId"
        }
    }

    public struct RegionInfo: AWSDecodableShape {
        /// The ID of the KMS key used to encrypt the data in this Amazon Web Services Region.
        public let sseKmsKeyId: String?
        /// The status of the Amazon Web Services Region in the replication set.
        public let status: RegionStatus
        /// Information displayed about the status of the Amazon Web Services Region.
        public let statusMessage: String?
        /// The timestamp for when Incident Manager updated the status of the Amazon Web Services Region.
        public let statusUpdateDateTime: Date

        public init(sseKmsKeyId: String? = nil, status: RegionStatus, statusMessage: String? = nil, statusUpdateDateTime: Date) {
            self.sseKmsKeyId = sseKmsKeyId
            self.status = status
            self.statusMessage = statusMessage
            self.statusUpdateDateTime = statusUpdateDateTime
        }

        private enum CodingKeys: String, CodingKey {
            case sseKmsKeyId = "sseKmsKeyId"
            case status = "status"
            case statusMessage = "statusMessage"
            case statusUpdateDateTime = "statusUpdateDateTime"
        }
    }

    public struct RegionMapInputValue: AWSEncodableShape {
        /// The KMS key used to encrypt the data in your replication set.
        public let sseKmsKeyId: String?

        public init(sseKmsKeyId: String? = nil) {
            self.sseKmsKeyId = sseKmsKeyId
        }

        public func validate(name: String) throws {
            try self.validate(self.sseKmsKeyId, name: "sseKmsKeyId", parent: name, max: 2048)
        }

        private enum CodingKeys: String, CodingKey {
            case sseKmsKeyId = "sseKmsKeyId"
        }
    }

    public struct RelatedItem: AWSEncodableShape & AWSDecodableShape {
        /// A unique ID for a RelatedItem.  Don't specify this parameter when you add a RelatedItem by using the UpdateRelatedItems API action.
        public let generatedId: String?
        /// Details about the related item.
        public let identifier: ItemIdentifier
        /// The title of the related item.
        public let title: String?

        public init(generatedId: String? = nil, identifier: ItemIdentifier, title: String? = nil) {
            self.generatedId = generatedId
            self.identifier = identifier
            self.title = title
        }

        public func validate(name: String) throws {
            try self.validate(self.generatedId, name: "generatedId", parent: name, max: 200)
            try self.validate(self.generatedId, name: "generatedId", parent: name, pattern: "^related-item/(ANALYSIS|INCIDENT|METRIC|PARENT|ATTACHMENT|OTHER|AUTOMATION|INVOLVED_RESOURCE|TASK)/([0-9]|[A-F]){32}$")
            try self.identifier.validate(name: "\(name).identifier")
        }

        private enum CodingKeys: String, CodingKey {
            case generatedId = "generatedId"
            case identifier = "identifier"
            case title = "title"
        }
    }

    public struct ReplicationSet: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the replication set.
        public let arn: String?
        /// Details about who created the replication set.
        public let createdBy: String
        /// When the replication set was created.
        public let createdTime: Date
        /// Determines if the replication set deletion protection is enabled or not. If deletion protection is enabled, you can't delete the last Amazon Web Services Region in the replication set.
        public let deletionProtected: Bool
        /// Who last modified the replication set.
        public let lastModifiedBy: String
        /// When the replication set was last updated.
        public let lastModifiedTime: Date
        /// The map between each Amazon Web Services Region in your replication set and the KMS key that's used to encrypt the data in that Region.
        public let regionMap: [String: RegionInfo]
        /// The status of the replication set. If the replication set is still pending, you can't use Incident Manager functionality.
        public let status: ReplicationSetStatus

        public init(arn: String? = nil, createdBy: String, createdTime: Date, deletionProtected: Bool, lastModifiedBy: String, lastModifiedTime: Date, regionMap: [String: RegionInfo], status: ReplicationSetStatus) {
            self.arn = arn
            self.createdBy = createdBy
            self.createdTime = createdTime
            self.deletionProtected = deletionProtected
            self.lastModifiedBy = lastModifiedBy
            self.lastModifiedTime = lastModifiedTime
            self.regionMap = regionMap
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case createdBy = "createdBy"
            case createdTime = "createdTime"
            case deletionProtected = "deletionProtected"
            case lastModifiedBy = "lastModifiedBy"
            case lastModifiedTime = "lastModifiedTime"
            case regionMap = "regionMap"
            case status = "status"
        }
    }

    public struct ResourcePolicy: AWSDecodableShape {
        /// The JSON blob that describes the policy.
        public let policyDocument: String
        /// The ID of the resource policy.
        public let policyId: String
        /// The Amazon Web Services Region that policy allows resources to be used in.
        public let ramResourceShareRegion: String

        public init(policyDocument: String, policyId: String, ramResourceShareRegion: String) {
            self.policyDocument = policyDocument
            self.policyId = policyId
            self.ramResourceShareRegion = ramResourceShareRegion
        }

        private enum CodingKeys: String, CodingKey {
            case policyDocument = "policyDocument"
            case policyId = "policyId"
            case ramResourceShareRegion = "ramResourceShareRegion"
        }
    }

    public struct ResponsePlanSummary: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the response plan.
        public let arn: String
        /// The human readable name of the response plan. This can include spaces.
        public let displayName: String?
        /// The name of the response plan. This can't include spaces.
        public let name: String

        public init(arn: String, displayName: String? = nil, name: String) {
            self.arn = arn
            self.displayName = displayName
            self.name = name
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case displayName = "displayName"
            case name = "name"
        }
    }

    public struct SsmAutomation: AWSEncodableShape & AWSDecodableShape {
        /// The automation document's name.
        public let documentName: String
        /// The automation document's version to use when running.
        public let documentVersion: String?
        /// The key-value pair to resolve dynamic parameter values when processing a Systems Manager Automation runbook.
        public let dynamicParameters: [String: DynamicSsmParameterValue]?
        /// The key-value pair parameters to use when running the automation document.
        public let parameters: [String: [String]]?
        /// The Amazon Resource Name (ARN) of the role that the automation document will assume when running commands.
        public let roleArn: String
        /// The account that the automation document will be run in. This can be in either the management account or an application account.
        public let targetAccount: SsmTargetAccount?

        public init(documentName: String, documentVersion: String? = nil, dynamicParameters: [String: DynamicSsmParameterValue]? = nil, parameters: [String: [String]]? = nil, roleArn: String, targetAccount: SsmTargetAccount? = nil) {
            self.documentName = documentName
            self.documentVersion = documentVersion
            self.dynamicParameters = dynamicParameters
            self.parameters = parameters
            self.roleArn = roleArn
            self.targetAccount = targetAccount
        }

        public func validate(name: String) throws {
            try self.validate(self.dynamicParameters, name: "dynamicParameters", parent: name, max: 200)
            try self.validate(self.dynamicParameters, name: "dynamicParameters", parent: name, min: 1)
            try self.parameters?.forEach {
                try validate($0.value, name: "parameters[\"\($0.key)\"]", parent: name, max: 100)
            }
            try self.validate(self.parameters, name: "parameters", parent: name, max: 200)
            try self.validate(self.parameters, name: "parameters", parent: name, min: 1)
            try self.validate(self.roleArn, name: "roleArn", parent: name, max: 1000)
            try self.validate(self.roleArn, name: "roleArn", parent: name, pattern: "^arn:aws(-cn|-us-gov)?:iam::([0-9]{12})?:role/.+$")
        }

        private enum CodingKeys: String, CodingKey {
            case documentName = "documentName"
            case documentVersion = "documentVersion"
            case dynamicParameters = "dynamicParameters"
            case parameters = "parameters"
            case roleArn = "roleArn"
            case targetAccount = "targetAccount"
        }
    }

    public struct StartIncidentInput: AWSEncodableShape {
        /// A token ensuring that the operation is called only once with the specified details.
        public let clientToken: String?
        /// Defines the impact to the customers. Providing an impact overwrites the impact provided by a response plan.  Supported impact codes     1 - Critical    2 - High    3 - Medium    4 - Low    5 - No Impact
        public let impact: Int?
        /// Add related items to the incident for other responders to use. Related items are Amazon Web Services resources, external links, or files uploaded to an Amazon S3 bucket.
        public let relatedItems: [RelatedItem]?
        /// The Amazon Resource Name (ARN) of the response plan that pre-defines summary, chat channels, Amazon SNS topics, runbooks, title, and impact of the incident.
        public let responsePlanArn: String
        /// Provide a title for the incident. Providing a title overwrites the title provided by the response plan.
        public let title: String?
        /// Details of what created the incident record in Incident Manager.
        public let triggerDetails: TriggerDetails?

        public init(clientToken: String? = StartIncidentInput.idempotencyToken(), impact: Int? = nil, relatedItems: [RelatedItem]? = nil, responsePlanArn: String, title: String? = nil, triggerDetails: TriggerDetails? = nil) {
            self.clientToken = clientToken
            self.impact = impact
            self.relatedItems = relatedItems
            self.responsePlanArn = responsePlanArn
            self.title = title
            self.triggerDetails = triggerDetails
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 128)
            try self.validate(self.impact, name: "impact", parent: name, max: 5)
            try self.validate(self.impact, name: "impact", parent: name, min: 1)
            try self.relatedItems?.forEach {
                try $0.validate(name: "\(name).relatedItems[]")
            }
            try self.validate(self.relatedItems, name: "relatedItems", parent: name, max: 100)
            try self.validate(self.responsePlanArn, name: "responsePlanArn", parent: name, max: 1000)
            try self.validate(self.responsePlanArn, name: "responsePlanArn", parent: name, pattern: "^arn:aws(-cn|-us-gov)?:[a-z0-9-]*:[a-z0-9-]*:([0-9]{12})?:.+$")
            try self.validate(self.title, name: "title", parent: name, max: 200)
            try self.triggerDetails?.validate(name: "\(name).triggerDetails")
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "clientToken"
            case impact = "impact"
            case relatedItems = "relatedItems"
            case responsePlanArn = "responsePlanArn"
            case title = "title"
            case triggerDetails = "triggerDetails"
        }
    }

    public struct StartIncidentOutput: AWSDecodableShape {
        /// The ARN of the newly created incident record.
        public let incidentRecordArn: String

        public init(incidentRecordArn: String) {
            self.incidentRecordArn = incidentRecordArn
        }

        private enum CodingKeys: String, CodingKey {
            case incidentRecordArn = "incidentRecordArn"
        }
    }

    public struct TagResourceRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the response plan you're adding the tags to.
        public let resourceArn: String
        /// A list of tags to add to the response plan.
        public let tags: [String: String]

        public init(resourceArn: String, tags: [String: String]) {
            self.resourceArn = resourceArn
            self.tags = tags
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.resourceArn, key: "resourceArn")
            try container.encode(self.tags, forKey: .tags)
        }

        public func validate(name: String) throws {
            try self.tags.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.key, name: "tags.key", parent: name, pattern: "^(?!aws:)[A-Za-z0-9 _=@:.+-/]+$")
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, pattern: "^[A-Za-z0-9 _=@:.+-/]*$")
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 50)
            try self.validate(self.tags, name: "tags", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case tags = "tags"
        }
    }

    public struct TagResourceResponse: AWSDecodableShape {
        public init() {}
    }

    public struct TimelineEvent: AWSDecodableShape {
        /// A short description of the event.
        public let eventData: String
        /// The ID of the timeline event.
        public let eventId: String
        /// A list of references in a TimelineEvent.
        public let eventReferences: [EventReference]?
        /// The timestamp for when the event occurred.
        public let eventTime: Date
        /// The type of event that occurred. Currently Incident Manager supports only the Custom Event and Note types.
        public let eventType: String
        /// The timestamp for when the timeline event was last updated.
        public let eventUpdatedTime: Date
        /// The Amazon Resource Name (ARN) of the incident that the event occurred during.
        public let incidentRecordArn: String

        public init(eventData: String, eventId: String, eventReferences: [EventReference]? = nil, eventTime: Date, eventType: String, eventUpdatedTime: Date, incidentRecordArn: String) {
            self.eventData = eventData
            self.eventId = eventId
            self.eventReferences = eventReferences
            self.eventTime = eventTime
            self.eventType = eventType
            self.eventUpdatedTime = eventUpdatedTime
            self.incidentRecordArn = incidentRecordArn
        }

        private enum CodingKeys: String, CodingKey {
            case eventData = "eventData"
            case eventId = "eventId"
            case eventReferences = "eventReferences"
            case eventTime = "eventTime"
            case eventType = "eventType"
            case eventUpdatedTime = "eventUpdatedTime"
            case incidentRecordArn = "incidentRecordArn"
        }
    }

    public struct TriggerDetails: AWSEncodableShape {
        /// Raw data passed from either Amazon EventBridge, Amazon CloudWatch, or Incident Manager when an incident is created.
        public let rawData: String?
        /// Identifies the service that sourced the event. All events sourced from within Amazon Web Services begin with "aws." Customer-generated events can have any value here, as long as it doesn't begin with "aws." We recommend the use of Java package-name style reverse domain-name strings.
        public let source: String
        /// The timestamp for when the incident was detected.
        public let timestamp: Date
        /// The Amazon Resource Name (ARN) of the source that detected the incident.
        public let triggerArn: String?

        public init(rawData: String? = nil, source: String, timestamp: Date, triggerArn: String? = nil) {
            self.rawData = rawData
            self.source = source
            self.timestamp = timestamp
            self.triggerArn = triggerArn
        }

        public func validate(name: String) throws {
            try self.validate(self.rawData, name: "rawData", parent: name, max: 10000)
            try self.validate(self.source, name: "source", parent: name, max: 50)
            try self.validate(self.triggerArn, name: "triggerArn", parent: name, max: 1000)
            try self.validate(self.triggerArn, name: "triggerArn", parent: name, pattern: "^arn:aws(-cn|-us-gov)?:[a-z0-9-]*:[a-z0-9-]*:([0-9]{12})?:.+$")
        }

        private enum CodingKeys: String, CodingKey {
            case rawData = "rawData"
            case source = "source"
            case timestamp = "timestamp"
            case triggerArn = "triggerArn"
        }
    }

    public struct UntagResourceRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the response plan you're removing a tag from.
        public let resourceArn: String
        /// The name of the tag to remove from the response plan.
        public let tagKeys: [String]

        public init(resourceArn: String, tagKeys: [String]) {
            self.resourceArn = resourceArn
            self.tagKeys = tagKeys
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.resourceArn, key: "resourceArn")
            request.encodeQuery(self.tagKeys, key: "tagKeys")
        }

        public func validate(name: String) throws {
            try self.tagKeys.forEach {
                try validate($0, name: "tagKeys[]", parent: name, max: 128)
                try validate($0, name: "tagKeys[]", parent: name, min: 1)
                try validate($0, name: "tagKeys[]", parent: name, pattern: "^(?!aws:)[A-Za-z0-9 _=@:.+-/]+$")
            }
            try self.validate(self.tagKeys, name: "tagKeys", parent: name, max: 50)
            try self.validate(self.tagKeys, name: "tagKeys", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct UntagResourceResponse: AWSDecodableShape {
        public init() {}
    }

    public struct UpdateDeletionProtectionInput: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the replication set to update.
        public let arn: String
        /// A token that ensures that the operation is called only once with the specified details.
        public let clientToken: String?
        /// Specifies if deletion protection is turned on or off in your account.
        public let deletionProtected: Bool

        public init(arn: String, clientToken: String? = UpdateDeletionProtectionInput.idempotencyToken(), deletionProtected: Bool) {
            self.arn = arn
            self.clientToken = clientToken
            self.deletionProtected = deletionProtected
        }

        public func validate(name: String) throws {
            try self.validate(self.arn, name: "arn", parent: name, max: 1000)
            try self.validate(self.arn, name: "arn", parent: name, pattern: "^arn:aws(-cn|-us-gov)?:[a-z0-9-]*:[a-z0-9-]*:([0-9]{12})?:.+$")
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 128)
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case clientToken = "clientToken"
            case deletionProtected = "deletionProtected"
        }
    }

    public struct UpdateDeletionProtectionOutput: AWSDecodableShape {
        public init() {}
    }

    public struct UpdateIncidentRecordInput: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the incident record you are updating.
        public let arn: String
        /// The Chatbot chat channel where responders can collaborate.
        public let chatChannel: ChatChannel?
        /// A token that ensures that a client calls the operation only once with the specified details.
        public let clientToken: String?
        /// Defines the impact of the incident to customers and applications. If you provide an impact for an incident, it overwrites the impact provided by the response plan.  Supported impact codes     1 - Critical    2 - High    3 - Medium    4 - Low    5 - No Impact
        public let impact: Int?
        /// The Amazon SNS targets that Incident Manager notifies when a client updates an incident. Using multiple SNS topics creates redundancy in the event that a Region is down during the incident.
        public let notificationTargets: [NotificationTargetItem]?
        /// The status of the incident. Possible statuses are Open or Resolved.
        public let status: IncidentRecordStatus?
        /// A longer description of what occurred during the incident.
        public let summary: String?
        /// A brief description of the incident.
        public let title: String?

        public init(arn: String, chatChannel: ChatChannel? = nil, clientToken: String? = UpdateIncidentRecordInput.idempotencyToken(), impact: Int? = nil, notificationTargets: [NotificationTargetItem]? = nil, status: IncidentRecordStatus? = nil, summary: String? = nil, title: String? = nil) {
            self.arn = arn
            self.chatChannel = chatChannel
            self.clientToken = clientToken
            self.impact = impact
            self.notificationTargets = notificationTargets
            self.status = status
            self.summary = summary
            self.title = title
        }

        public func validate(name: String) throws {
            try self.validate(self.arn, name: "arn", parent: name, max: 1000)
            try self.validate(self.arn, name: "arn", parent: name, pattern: "^arn:aws(-cn|-us-gov)?:[a-z0-9-]*:[a-z0-9-]*:([0-9]{12})?:.+$")
            try self.chatChannel?.validate(name: "\(name).chatChannel")
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 128)
            try self.validate(self.impact, name: "impact", parent: name, max: 5)
            try self.validate(self.impact, name: "impact", parent: name, min: 1)
            try self.notificationTargets?.forEach {
                try $0.validate(name: "\(name).notificationTargets[]")
            }
            try self.validate(self.notificationTargets, name: "notificationTargets", parent: name, max: 10)
            try self.validate(self.summary, name: "summary", parent: name, max: 8000)
            try self.validate(self.title, name: "title", parent: name, max: 200)
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case chatChannel = "chatChannel"
            case clientToken = "clientToken"
            case impact = "impact"
            case notificationTargets = "notificationTargets"
            case status = "status"
            case summary = "summary"
            case title = "title"
        }
    }

    public struct UpdateIncidentRecordOutput: AWSDecodableShape {
        public init() {}
    }

    public struct UpdateRelatedItemsInput: AWSEncodableShape {
        /// A token that ensures that a client calls the operation only once with the specified details.
        public let clientToken: String?
        /// The Amazon Resource Name (ARN) of the incident record that contains the related items that you update.
        public let incidentRecordArn: String
        /// Details about the item that you are add to, or delete from, an incident.
        public let relatedItemsUpdate: RelatedItemsUpdate

        public init(clientToken: String? = UpdateRelatedItemsInput.idempotencyToken(), incidentRecordArn: String, relatedItemsUpdate: RelatedItemsUpdate) {
            self.clientToken = clientToken
            self.incidentRecordArn = incidentRecordArn
            self.relatedItemsUpdate = relatedItemsUpdate
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 128)
            try self.validate(self.incidentRecordArn, name: "incidentRecordArn", parent: name, max: 1000)
            try self.validate(self.incidentRecordArn, name: "incidentRecordArn", parent: name, pattern: "^arn:aws(-cn|-us-gov)?:[a-z0-9-]*:[a-z0-9-]*:([0-9]{12})?:.+$")
            try self.relatedItemsUpdate.validate(name: "\(name).relatedItemsUpdate")
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "clientToken"
            case incidentRecordArn = "incidentRecordArn"
            case relatedItemsUpdate = "relatedItemsUpdate"
        }
    }

    public struct UpdateRelatedItemsOutput: AWSDecodableShape {
        public init() {}
    }

    public struct UpdateReplicationSetInput: AWSEncodableShape {
        /// An action to add or delete a Region.
        public let actions: [UpdateReplicationSetAction]
        /// The Amazon Resource Name (ARN) of the replication set you're updating.
        public let arn: String
        /// A token that ensures that the operation is called only once with the specified details.
        public let clientToken: String?

        public init(actions: [UpdateReplicationSetAction], arn: String, clientToken: String? = UpdateReplicationSetInput.idempotencyToken()) {
            self.actions = actions
            self.arn = arn
            self.clientToken = clientToken
        }

        public func validate(name: String) throws {
            try self.actions.forEach {
                try $0.validate(name: "\(name).actions[]")
            }
            try self.validate(self.arn, name: "arn", parent: name, max: 1000)
            try self.validate(self.arn, name: "arn", parent: name, pattern: "^arn:aws(-cn|-us-gov)?:[a-z0-9-]*:[a-z0-9-]*:([0-9]{12})?:.+$")
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 128)
        }

        private enum CodingKeys: String, CodingKey {
            case actions = "actions"
            case arn = "arn"
            case clientToken = "clientToken"
        }
    }

    public struct UpdateReplicationSetOutput: AWSDecodableShape {
        public init() {}
    }

    public struct UpdateResponsePlanInput: AWSEncodableShape {
        /// The actions that this response plan takes at the beginning of an incident.
        public let actions: [Action]?
        /// The Amazon Resource Name (ARN) of the response plan.
        public let arn: String
        /// The Chatbot chat channel used for collaboration during an incident. Use the empty structure to remove the chat channel from the response plan.
        public let chatChannel: ChatChannel?
        /// A token ensuring that the operation is called only once with the specified details.
        public let clientToken: String?
        /// The long format name of the response plan. The display name can't contain spaces.
        public let displayName: String?
        /// The Amazon Resource Name (ARN) for the contacts and escalation plans that the response plan engages during an incident.
        public let engagements: [String]?
        /// The string Incident Manager uses to prevent duplicate incidents from being created by the same incident in the same account.
        public let incidentTemplateDedupeString: String?
        /// Defines the impact to the customers. Providing an impact overwrites the impact provided by a response plan.  Supported impact codes     1 - Critical    2 - High    3 - Medium    4 - Low    5 - No Impact
        public let incidentTemplateImpact: Int?
        /// The Amazon SNS targets that are notified when updates are made to an incident.
        public let incidentTemplateNotificationTargets: [NotificationTargetItem]?
        /// A brief summary of the incident. This typically contains what has happened, what's currently happening, and next steps.
        public let incidentTemplateSummary: String?
        /// Tags to assign to the template. When the StartIncident API action is called, Incident Manager assigns the tags specified in the template to the incident. To call this action, you must also have permission to call the TagResource API action for the incident record resource.
        public let incidentTemplateTags: [String: String]?
        /// The short format name of the incident. The title can't contain spaces.
        public let incidentTemplateTitle: String?
        /// Information about third-party services integrated into the response plan.
        public let integrations: [Integration]?

        public init(actions: [Action]? = nil, arn: String, chatChannel: ChatChannel? = nil, clientToken: String? = UpdateResponsePlanInput.idempotencyToken(), displayName: String? = nil, engagements: [String]? = nil, incidentTemplateDedupeString: String? = nil, incidentTemplateImpact: Int? = nil, incidentTemplateNotificationTargets: [NotificationTargetItem]? = nil, incidentTemplateSummary: String? = nil, incidentTemplateTags: [String: String]? = nil, incidentTemplateTitle: String? = nil, integrations: [Integration]? = nil) {
            self.actions = actions
            self.arn = arn
            self.chatChannel = chatChannel
            self.clientToken = clientToken
            self.displayName = displayName
            self.engagements = engagements
            self.incidentTemplateDedupeString = incidentTemplateDedupeString
            self.incidentTemplateImpact = incidentTemplateImpact
            self.incidentTemplateNotificationTargets = incidentTemplateNotificationTargets
            self.incidentTemplateSummary = incidentTemplateSummary
            self.incidentTemplateTags = incidentTemplateTags
            self.incidentTemplateTitle = incidentTemplateTitle
            self.integrations = integrations
        }

        public func validate(name: String) throws {
            try self.actions?.forEach {
                try $0.validate(name: "\(name).actions[]")
            }
            try self.validate(self.actions, name: "actions", parent: name, max: 1)
            try self.validate(self.arn, name: "arn", parent: name, max: 1000)
            try self.validate(self.arn, name: "arn", parent: name, pattern: "^arn:aws(-cn|-us-gov)?:[a-z0-9-]*:[a-z0-9-]*:([0-9]{12})?:.+$")
            try self.chatChannel?.validate(name: "\(name).chatChannel")
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 128)
            try self.validate(self.displayName, name: "displayName", parent: name, max: 200)
            try self.engagements?.forEach {
                try validate($0, name: "engagements[]", parent: name, max: 2048)
                try validate($0, name: "engagements[]", parent: name, pattern: "^arn:aws(-cn|-us-gov)?:ssm-contacts:[a-z0-9-]*:([0-9]{12}):contact/[a-z0-9_-]+$")
            }
            try self.validate(self.engagements, name: "engagements", parent: name, max: 5)
            try self.validate(self.incidentTemplateDedupeString, name: "incidentTemplateDedupeString", parent: name, max: 1000)
            try self.validate(self.incidentTemplateImpact, name: "incidentTemplateImpact", parent: name, max: 5)
            try self.validate(self.incidentTemplateImpact, name: "incidentTemplateImpact", parent: name, min: 1)
            try self.incidentTemplateNotificationTargets?.forEach {
                try $0.validate(name: "\(name).incidentTemplateNotificationTargets[]")
            }
            try self.validate(self.incidentTemplateNotificationTargets, name: "incidentTemplateNotificationTargets", parent: name, max: 10)
            try self.validate(self.incidentTemplateSummary, name: "incidentTemplateSummary", parent: name, max: 8000)
            try self.incidentTemplateTags?.forEach {
                try validate($0.key, name: "incidentTemplateTags.key", parent: name, max: 128)
                try validate($0.key, name: "incidentTemplateTags.key", parent: name, min: 1)
                try validate($0.key, name: "incidentTemplateTags.key", parent: name, pattern: "^(?!aws:)[A-Za-z0-9 _=@:.+-/]+$")
                try validate($0.value, name: "incidentTemplateTags[\"\($0.key)\"]", parent: name, max: 256)
                try validate($0.value, name: "incidentTemplateTags[\"\($0.key)\"]", parent: name, pattern: "^[A-Za-z0-9 _=@:.+-/]*$")
            }
            try self.validate(self.incidentTemplateTags, name: "incidentTemplateTags", parent: name, max: 50)
            try self.validate(self.incidentTemplateTitle, name: "incidentTemplateTitle", parent: name, max: 200)
            try self.validate(self.integrations, name: "integrations", parent: name, max: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case actions = "actions"
            case arn = "arn"
            case chatChannel = "chatChannel"
            case clientToken = "clientToken"
            case displayName = "displayName"
            case engagements = "engagements"
            case incidentTemplateDedupeString = "incidentTemplateDedupeString"
            case incidentTemplateImpact = "incidentTemplateImpact"
            case incidentTemplateNotificationTargets = "incidentTemplateNotificationTargets"
            case incidentTemplateSummary = "incidentTemplateSummary"
            case incidentTemplateTags = "incidentTemplateTags"
            case incidentTemplateTitle = "incidentTemplateTitle"
            case integrations = "integrations"
        }
    }

    public struct UpdateResponsePlanOutput: AWSDecodableShape {
        public init() {}
    }

    public struct UpdateTimelineEventInput: AWSEncodableShape {
        /// A token that ensures that a client calls the operation only once with the specified details.
        public let clientToken: String?
        /// A short description of the event.
        public let eventData: String?
        /// The ID of the event to update. You can use ListTimelineEvents to find an event's ID.
        public let eventId: String
        /// Updates all existing references in a TimelineEvent. A reference is an Amazon Web Services resource involved or associated with the incident. To specify a reference, enter its Amazon Resource Name (ARN). You can also specify a related item associated with that resource. For example, to specify an Amazon DynamoDB (DynamoDB) table as a resource, use its ARN. You can also specify an Amazon CloudWatch metric associated with the DynamoDB table as a related item.  This update action overrides all existing references. If you want to keep existing references, you must specify them in the call. If you don't, this action removes any existing references and enters only new references.
        public let eventReferences: [EventReference]?
        /// The timestamp for when the event occurred.
        public let eventTime: Date?
        /// The type of event. You can update events of type Custom Event and Note.
        public let eventType: String?
        /// The Amazon Resource Name (ARN) of the incident that includes the timeline event.
        public let incidentRecordArn: String

        public init(clientToken: String? = UpdateTimelineEventInput.idempotencyToken(), eventData: String? = nil, eventId: String, eventReferences: [EventReference]? = nil, eventTime: Date? = nil, eventType: String? = nil, incidentRecordArn: String) {
            self.clientToken = clientToken
            self.eventData = eventData
            self.eventId = eventId
            self.eventReferences = eventReferences
            self.eventTime = eventTime
            self.eventType = eventType
            self.incidentRecordArn = incidentRecordArn
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 128)
            try self.validate(self.eventData, name: "eventData", parent: name, max: 12000)
            try self.validate(self.eventId, name: "eventId", parent: name, max: 50)
            try self.eventReferences?.forEach {
                try $0.validate(name: "\(name).eventReferences[]")
            }
            try self.validate(self.eventReferences, name: "eventReferences", parent: name, max: 10)
            try self.validate(self.eventType, name: "eventType", parent: name, max: 100)
            try self.validate(self.incidentRecordArn, name: "incidentRecordArn", parent: name, max: 1000)
            try self.validate(self.incidentRecordArn, name: "incidentRecordArn", parent: name, pattern: "^arn:aws(-cn|-us-gov)?:[a-z0-9-]*:[a-z0-9-]*:([0-9]{12})?:.+$")
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "clientToken"
            case eventData = "eventData"
            case eventId = "eventId"
            case eventReferences = "eventReferences"
            case eventTime = "eventTime"
            case eventType = "eventType"
            case incidentRecordArn = "incidentRecordArn"
        }
    }

    public struct UpdateTimelineEventOutput: AWSDecodableShape {
        public init() {}
    }

    public struct Action: AWSEncodableShape & AWSDecodableShape {
        /// The Systems Manager automation document to start as the runbook at the beginning of the incident.
        public let ssmAutomation: SsmAutomation?

        public init(ssmAutomation: SsmAutomation? = nil) {
            self.ssmAutomation = ssmAutomation
        }

        public func validate(name: String) throws {
            try self.ssmAutomation?.validate(name: "\(name).ssmAutomation")
        }

        private enum CodingKeys: String, CodingKey {
            case ssmAutomation = "ssmAutomation"
        }
    }

    public struct AutomationExecution: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the automation process.
        public let ssmExecutionArn: String?

        public init(ssmExecutionArn: String? = nil) {
            self.ssmExecutionArn = ssmExecutionArn
        }

        private enum CodingKeys: String, CodingKey {
            case ssmExecutionArn = "ssmExecutionArn"
        }
    }

    public struct DynamicSsmParameterValue: AWSEncodableShape & AWSDecodableShape {
        /// Variable dynamic parameters. A parameter value is determined when an incident is created.
        public let variable: VariableType?

        public init(variable: VariableType? = nil) {
            self.variable = variable
        }

        private enum CodingKeys: String, CodingKey {
            case variable = "variable"
        }
    }

    public struct Integration: AWSEncodableShape & AWSDecodableShape {
        /// Information about the PagerDuty service where the response plan creates an incident.
        public let pagerDutyConfiguration: PagerDutyConfiguration?

        public init(pagerDutyConfiguration: PagerDutyConfiguration? = nil) {
            self.pagerDutyConfiguration = pagerDutyConfiguration
        }

        private enum CodingKeys: String, CodingKey {
            case pagerDutyConfiguration = "pagerDutyConfiguration"
        }
    }

    public struct NotificationTargetItem: AWSEncodableShape & AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the SNS topic.
        public let snsTopicArn: String?

        public init(snsTopicArn: String? = nil) {
            self.snsTopicArn = snsTopicArn
        }

        public func validate(name: String) throws {
            try self.validate(self.snsTopicArn, name: "snsTopicArn", parent: name, max: 1000)
            try self.validate(self.snsTopicArn, name: "snsTopicArn", parent: name, pattern: "^arn:aws(-cn|-us-gov)?:[a-z0-9-]*:[a-z0-9-]*:([0-9]{12})?:.+$")
        }

        private enum CodingKeys: String, CodingKey {
            case snsTopicArn = "snsTopicArn"
        }
    }
}

// MARK: - Errors

/// Error enum for SSMIncidents
public struct SSMIncidentsErrorType: AWSErrorType {
    enum Code: String {
        case accessDeniedException = "AccessDeniedException"
        case conflictException = "ConflictException"
        case internalServerException = "InternalServerException"
        case resourceNotFoundException = "ResourceNotFoundException"
        case serviceQuotaExceededException = "ServiceQuotaExceededException"
        case throttlingException = "ThrottlingException"
        case validationException = "ValidationException"
    }

    private let error: Code
    public let context: AWSErrorContext?

    /// initialize SSMIncidents
    public init?(errorCode: String, context: AWSErrorContext) {
        guard let error = Code(rawValue: errorCode) else { return nil }
        self.error = error
        self.context = context
    }

    internal init(_ error: Code) {
        self.error = error
        self.context = nil
    }

    /// return error code string
    public var errorCode: String { self.error.rawValue }

    /// You don't have sufficient access to perform this operation.
    public static var accessDeniedException: Self { .init(.accessDeniedException) }
    /// Updating or deleting a resource causes an inconsistent state.
    public static var conflictException: Self { .init(.conflictException) }
    /// The request processing has failed because of an unknown error, exception or failure.
    public static var internalServerException: Self { .init(.internalServerException) }
    /// Request references a resource which doesn't exist.
    public static var resourceNotFoundException: Self { .init(.resourceNotFoundException) }
    /// Request would cause a service quota to be exceeded.
    public static var serviceQuotaExceededException: Self { .init(.serviceQuotaExceededException) }
    /// The request was denied due to request throttling.
    public static var throttlingException: Self { .init(.throttlingException) }
    /// The input fails to satisfy the constraints specified by an Amazon Web Services service.
    public static var validationException: Self { .init(.validationException) }
}

extension SSMIncidentsErrorType: Equatable {
    public static func == (lhs: SSMIncidentsErrorType, rhs: SSMIncidentsErrorType) -> Bool {
        lhs.error == rhs.error
    }
}

extension SSMIncidentsErrorType: CustomStringConvertible {
    public var description: String {
        return "\(self.error.rawValue): \(self.message ?? "")"
    }
}
