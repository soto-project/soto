//===----------------------------------------------------------------------===//
//
// This source file is part of the Soto for AWS open source project
//
// Copyright (c) 2017-2021 the Soto project authors
// Licensed under Apache License v2.0
//
// See LICENSE.txt for license information
// See CONTRIBUTORS.txt for the list of Soto project authors
//
// SPDX-License-Identifier: Apache-2.0
//
//===----------------------------------------------------------------------===//

// THIS FILE IS AUTOMATICALLY GENERATED by https://github.com/soto-project/soto/tree/main/CodeGenerator. DO NOT EDIT.

import Foundation
import SotoCore

extension SSMIncidents {
    // MARK: Enums

    public enum IncidentRecordStatus: String, CustomStringConvertible, Codable {
        case open = "OPEN"
        case resolved = "RESOLVED"
        public var description: String { return self.rawValue }
    }

    public enum ItemType: String, CustomStringConvertible, Codable {
        case analysis = "ANALYSIS"
        case attachment = "ATTACHMENT"
        case incident = "INCIDENT"
        case metric = "METRIC"
        case other = "OTHER"
        case parent = "PARENT"
        public var description: String { return self.rawValue }
    }

    public enum RegionStatus: String, CustomStringConvertible, Codable {
        case active = "ACTIVE"
        case creating = "CREATING"
        case deleting = "DELETING"
        case failed = "FAILED"
        public var description: String { return self.rawValue }
    }

    public enum ReplicationSetStatus: String, CustomStringConvertible, Codable {
        case active = "ACTIVE"
        case creating = "CREATING"
        case deleting = "DELETING"
        case failed = "FAILED"
        case updating = "UPDATING"
        public var description: String { return self.rawValue }
    }

    public enum SortOrder: String, CustomStringConvertible, Codable {
        case ascending = "ASCENDING"
        case descending = "DESCENDING"
        public var description: String { return self.rawValue }
    }

    public enum SsmTargetAccount: String, CustomStringConvertible, Codable {
        case impactedAccount = "IMPACTED_ACCOUNT"
        case responsePlanOwnerAccount = "RESPONSE_PLAN_OWNER_ACCOUNT"
        public var description: String { return self.rawValue }
    }

    public enum TimelineEventSort: String, CustomStringConvertible, Codable {
        case eventTime = "EVENT_TIME"
        public var description: String { return self.rawValue }
    }

    // MARK: Shapes

    public struct Action: AWSEncodableShape & AWSDecodableShape {
        /// The Systems Manager automation document to start as the runbook at the beginning of the incident.
        public let ssmAutomation: SsmAutomation?

        public init(ssmAutomation: SsmAutomation? = nil) {
            self.ssmAutomation = ssmAutomation
        }

        public func validate(name: String) throws {
            try self.ssmAutomation?.validate(name: "\(name).ssmAutomation")
        }

        private enum CodingKeys: String, CodingKey {
            case ssmAutomation
        }
    }

    public struct AddRegionAction: AWSEncodableShape {
        /// The Region name to add to the replication set.
        public let regionName: String
        /// The KMS key ID to use to encrypt your replication set.
        public let sseKmsKeyId: String?

        public init(regionName: String, sseKmsKeyId: String? = nil) {
            self.regionName = regionName
            self.sseKmsKeyId = sseKmsKeyId
        }

        public func validate(name: String) throws {
            try self.validate(self.regionName, name: "regionName", parent: name, max: 20)
            try self.validate(self.regionName, name: "regionName", parent: name, min: 0)
            try self.validate(self.sseKmsKeyId, name: "sseKmsKeyId", parent: name, max: 2048)
            try self.validate(self.sseKmsKeyId, name: "sseKmsKeyId", parent: name, min: 0)
        }

        private enum CodingKeys: String, CodingKey {
            case regionName
            case sseKmsKeyId
        }
    }

    public struct AttributeValueList: AWSEncodableShape {
        /// The list of integer values that the filter matches.
        public let integerValues: [Int]?
        /// The list of string values that the filter matches.
        public let stringValues: [String]?

        public init(integerValues: [Int]? = nil, stringValues: [String]? = nil) {
            self.integerValues = integerValues
            self.stringValues = stringValues
        }

        public func validate(name: String) throws {
            try self.validate(self.integerValues, name: "integerValues", parent: name, max: 100)
            try self.validate(self.integerValues, name: "integerValues", parent: name, min: 0)
            try self.stringValues?.forEach {
                try validate($0, name: "stringValues[]", parent: name, max: 1000)
                try validate($0, name: "stringValues[]", parent: name, min: 0)
            }
            try self.validate(self.stringValues, name: "stringValues", parent: name, max: 100)
            try self.validate(self.stringValues, name: "stringValues", parent: name, min: 0)
        }

        private enum CodingKeys: String, CodingKey {
            case integerValues
            case stringValues
        }
    }

    public struct AutomationExecution: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the automation process.
        public let ssmExecutionArn: String?

        public init(ssmExecutionArn: String? = nil) {
            self.ssmExecutionArn = ssmExecutionArn
        }

        private enum CodingKeys: String, CodingKey {
            case ssmExecutionArn
        }
    }

    public struct ChatChannel: AWSEncodableShape & AWSDecodableShape {
        /// The SNS targets that AWS Chatbot uses to notify the chat channel of updates to an incident. You can also make updates to the incident through the chat channel by using the SNS topics.
        public let chatbotSns: [String]?
        /// Used to remove the chat channel from an incident record or response plan.
        public let empty: EmptyChatChannel?

        public init(chatbotSns: [String]? = nil, empty: EmptyChatChannel? = nil) {
            self.chatbotSns = chatbotSns
            self.empty = empty
        }

        public func validate(name: String) throws {
            try self.chatbotSns?.forEach {
                try validate($0, name: "chatbotSns[]", parent: name, max: 1000)
                try validate($0, name: "chatbotSns[]", parent: name, min: 0)
            }
            try self.validate(self.chatbotSns, name: "chatbotSns", parent: name, max: 5)
            try self.validate(self.chatbotSns, name: "chatbotSns", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case chatbotSns
            case empty
        }
    }

    public struct Condition: AWSEncodableShape {
        /// After the specified timestamp.
        public let after: Date?
        /// Before the specified timestamp
        public let before: Date?
        /// The value is equal to the provided string or integer.
        public let equals: AttributeValueList?

        public init(after: Date? = nil, before: Date? = nil, equals: AttributeValueList? = nil) {
            self.after = after
            self.before = before
            self.equals = equals
        }

        public func validate(name: String) throws {
            try self.equals?.validate(name: "\(name).equals")
        }

        private enum CodingKeys: String, CodingKey {
            case after
            case before
            case equals
        }
    }

    public struct CreateReplicationSetInput: AWSEncodableShape {
        /// A token ensuring that the action is called only once with the specified details.
        public let clientToken: String?
        /// The Regions that Incident Manager replicates your data to. You can have up to three Regions in your replication set.
        public let regions: [String: RegionMapInputValue]

        public init(clientToken: String? = CreateReplicationSetInput.idempotencyToken(), regions: [String: RegionMapInputValue]) {
            self.clientToken = clientToken
            self.regions = regions
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 128)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 0)
            try self.regions.forEach {
                try validate($0.key, name: "regions.key", parent: name, max: 20)
                try validate($0.key, name: "regions.key", parent: name, min: 0)
                try $0.value.validate(name: "\(name).regions[\"\($0.key)\"]")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken
            case regions
        }
    }

    public struct CreateReplicationSetOutput: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the replication set.
        public let arn: String

        public init(arn: String) {
            self.arn = arn
        }

        private enum CodingKeys: String, CodingKey {
            case arn
        }
    }

    public struct CreateResponsePlanInput: AWSEncodableShape {
        /// The actions that the response plan starts at the beginning of an incident.
        public let actions: [Action]?
        /// The AWS Chatbot chat channel used for collaboration during an incident.
        public let chatChannel: ChatChannel?
        /// A token ensuring that the action is called only once with the specified details.
        public let clientToken: String?
        /// The long format of the response plan name. This field can contain spaces.
        public let displayName: String?
        /// The contacts and escalation plans that the response plan engages during an incident.
        public let engagements: [String]?
        /// Details used to create an incident when using this response plan.
        public let incidentTemplate: IncidentTemplate
        /// The short format name of the response plan. Can't include spaces.
        public let name: String
        /// A list of tags that you are adding to the response plan.
        public let tags: [String: String]?

        public init(actions: [Action]? = nil, chatChannel: ChatChannel? = nil, clientToken: String? = CreateResponsePlanInput.idempotencyToken(), displayName: String? = nil, engagements: [String]? = nil, incidentTemplate: IncidentTemplate, name: String, tags: [String: String]? = nil) {
            self.actions = actions
            self.chatChannel = chatChannel
            self.clientToken = clientToken
            self.displayName = displayName
            self.engagements = engagements
            self.incidentTemplate = incidentTemplate
            self.name = name
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.actions?.forEach {
                try $0.validate(name: "\(name).actions[]")
            }
            try self.validate(self.actions, name: "actions", parent: name, max: 1)
            try self.validate(self.actions, name: "actions", parent: name, min: 0)
            try self.chatChannel?.validate(name: "\(name).chatChannel")
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 128)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 0)
            try self.validate(self.displayName, name: "displayName", parent: name, max: 200)
            try self.validate(self.displayName, name: "displayName", parent: name, min: 0)
            try self.engagements?.forEach {
                try validate($0, name: "engagements[]", parent: name, max: 2048)
                try validate($0, name: "engagements[]", parent: name, min: 0)
                try validate($0, name: "engagements[]", parent: name, pattern: "^arn:[-\\w+=/,.@]+:ssm-contacts:[-\\w+=/,.@]*:[0-9]+:([\\w+=/,.@:-]+)*$")
            }
            try self.validate(self.engagements, name: "engagements", parent: name, max: 5)
            try self.validate(self.engagements, name: "engagements", parent: name, min: 0)
            try self.incidentTemplate.validate(name: "\(name).incidentTemplate")
            try self.validate(self.name, name: "name", parent: name, max: 200)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[a-zA-Z0-9-_]*$")
            try self.tags?.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.key, name: "tags.key", parent: name, pattern: "^(?!aws:)[A-Za-z0-9 _=@:.+-/]+$")
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, min: 0)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, pattern: "^[A-Za-z0-9 _=@:.+-/]*$")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case actions
            case chatChannel
            case clientToken
            case displayName
            case engagements
            case incidentTemplate
            case name
            case tags
        }
    }

    public struct CreateResponsePlanOutput: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the response plan.
        public let arn: String

        public init(arn: String) {
            self.arn = arn
        }

        private enum CodingKeys: String, CodingKey {
            case arn
        }
    }

    public struct CreateTimelineEventInput: AWSEncodableShape {
        /// A token ensuring that the action is called only once with the specified details.
        public let clientToken: String
        /// A short description of the event.
        public let eventData: String
        /// The time that the event occurred.
        public let eventTime: Date
        /// The type of the event. You can create timeline events of type Custom Event.
        public let eventType: String
        /// The Amazon Resource Name (ARN) of the incident record you are adding the event to.
        public let incidentRecordArn: String

        public init(clientToken: String = CreateTimelineEventInput.idempotencyToken(), eventData: String, eventTime: Date, eventType: String, incidentRecordArn: String) {
            self.clientToken = clientToken
            self.eventData = eventData
            self.eventTime = eventTime
            self.eventType = eventType
            self.incidentRecordArn = incidentRecordArn
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 128)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 0)
            try self.validate(self.eventData, name: "eventData", parent: name, max: 6000)
            try self.validate(self.eventData, name: "eventData", parent: name, min: 0)
            try self.validate(self.eventType, name: "eventType", parent: name, max: 100)
            try self.validate(self.eventType, name: "eventType", parent: name, min: 0)
            try self.validate(self.incidentRecordArn, name: "incidentRecordArn", parent: name, max: 1000)
            try self.validate(self.incidentRecordArn, name: "incidentRecordArn", parent: name, min: 0)
            try self.validate(self.incidentRecordArn, name: "incidentRecordArn", parent: name, pattern: "^arn:aws(-cn|-us-gov)?:[a-z0-9-]*:[a-z0-9-]*:([0-9]{12})?:.+$")
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken
            case eventData
            case eventTime
            case eventType
            case incidentRecordArn
        }
    }

    public struct CreateTimelineEventOutput: AWSDecodableShape {
        /// The ID of the event for easy reference later.
        public let eventId: String
        /// The ARN of the incident record that you added the event to.
        public let incidentRecordArn: String

        public init(eventId: String, incidentRecordArn: String) {
            self.eventId = eventId
            self.incidentRecordArn = incidentRecordArn
        }

        private enum CodingKeys: String, CodingKey {
            case eventId
            case incidentRecordArn
        }
    }

    public struct DeleteIncidentRecordInput: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the incident record you are deleting.
        public let arn: String

        public init(arn: String) {
            self.arn = arn
        }

        public func validate(name: String) throws {
            try self.validate(self.arn, name: "arn", parent: name, max: 1000)
            try self.validate(self.arn, name: "arn", parent: name, min: 0)
            try self.validate(self.arn, name: "arn", parent: name, pattern: "^arn:aws(-cn|-us-gov)?:[a-z0-9-]*:[a-z0-9-]*:([0-9]{12})?:.+$")
        }

        private enum CodingKeys: String, CodingKey {
            case arn
        }
    }

    public struct DeleteIncidentRecordOutput: AWSDecodableShape {
        public init() {}
    }

    public struct DeleteRegionAction: AWSEncodableShape {
        /// The name of the Region you're deleting from the replication set.
        public let regionName: String

        public init(regionName: String) {
            self.regionName = regionName
        }

        public func validate(name: String) throws {
            try self.validate(self.regionName, name: "regionName", parent: name, max: 20)
            try self.validate(self.regionName, name: "regionName", parent: name, min: 0)
        }

        private enum CodingKeys: String, CodingKey {
            case regionName
        }
    }

    public struct DeleteReplicationSetInput: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "arn", location: .querystring(locationName: "arn"))
        ]

        /// The Amazon Resource Name (ARN) of the replication set you're deleting.
        public let arn: String

        public init(arn: String) {
            self.arn = arn
        }

        public func validate(name: String) throws {
            try self.validate(self.arn, name: "arn", parent: name, max: 1000)
            try self.validate(self.arn, name: "arn", parent: name, min: 0)
            try self.validate(self.arn, name: "arn", parent: name, pattern: "^arn:aws(-cn|-us-gov)?:[a-z0-9-]*:[a-z0-9-]*:([0-9]{12})?:.+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteReplicationSetOutput: AWSDecodableShape {
        public init() {}
    }

    public struct DeleteResourcePolicyInput: AWSEncodableShape {
        /// The ID of the resource policy you're deleting.
        public let policyId: String
        /// The Amazon Resource Name (ARN) of the resource you're deleting the policy from.
        public let resourceArn: String

        public init(policyId: String, resourceArn: String) {
            self.policyId = policyId
            self.resourceArn = resourceArn
        }

        public func validate(name: String) throws {
            try self.validate(self.policyId, name: "policyId", parent: name, max: 256)
            try self.validate(self.policyId, name: "policyId", parent: name, min: 0)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, max: 1000)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, min: 0)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, pattern: "^arn:aws(-cn|-us-gov)?:[a-z0-9-]*:[a-z0-9-]*:([0-9]{12})?:.+$")
        }

        private enum CodingKeys: String, CodingKey {
            case policyId
            case resourceArn
        }
    }

    public struct DeleteResourcePolicyOutput: AWSDecodableShape {
        public init() {}
    }

    public struct DeleteResponsePlanInput: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the response plan.
        public let arn: String

        public init(arn: String) {
            self.arn = arn
        }

        public func validate(name: String) throws {
            try self.validate(self.arn, name: "arn", parent: name, max: 1000)
            try self.validate(self.arn, name: "arn", parent: name, min: 0)
            try self.validate(self.arn, name: "arn", parent: name, pattern: "^arn:aws(-cn|-us-gov)?:[a-z0-9-]*:[a-z0-9-]*:([0-9]{12})?:.+$")
        }

        private enum CodingKeys: String, CodingKey {
            case arn
        }
    }

    public struct DeleteResponsePlanOutput: AWSDecodableShape {
        public init() {}
    }

    public struct DeleteTimelineEventInput: AWSEncodableShape {
        /// The ID of the event you are updating. You can find this by using ListTimelineEvents.
        public let eventId: String
        /// The Amazon Resource Name (ARN) of the incident that the event is part of.
        public let incidentRecordArn: String

        public init(eventId: String, incidentRecordArn: String) {
            self.eventId = eventId
            self.incidentRecordArn = incidentRecordArn
        }

        public func validate(name: String) throws {
            try self.validate(self.eventId, name: "eventId", parent: name, max: 50)
            try self.validate(self.eventId, name: "eventId", parent: name, min: 0)
            try self.validate(self.incidentRecordArn, name: "incidentRecordArn", parent: name, max: 1000)
            try self.validate(self.incidentRecordArn, name: "incidentRecordArn", parent: name, min: 0)
            try self.validate(self.incidentRecordArn, name: "incidentRecordArn", parent: name, pattern: "^arn:aws(-cn|-us-gov)?:[a-z0-9-]*:[a-z0-9-]*:([0-9]{12})?:.+$")
        }

        private enum CodingKeys: String, CodingKey {
            case eventId
            case incidentRecordArn
        }
    }

    public struct DeleteTimelineEventOutput: AWSDecodableShape {
        public init() {}
    }

    public struct EmptyChatChannel: AWSEncodableShape & AWSDecodableShape {
        public init() {}
    }

    public struct EventSummary: AWSDecodableShape {
        /// The timeline event ID.
        public let eventId: String
        /// The time that the event occurred.
        public let eventTime: Date
        /// The type of event. The timeline event must be Custom Event.
        public let eventType: String
        /// The time that the timeline event was last updated.
        public let eventUpdatedTime: Date
        /// The Amazon Resource Name (ARN) of the incident that the event happened during.
        public let incidentRecordArn: String

        public init(eventId: String, eventTime: Date, eventType: String, eventUpdatedTime: Date, incidentRecordArn: String) {
            self.eventId = eventId
            self.eventTime = eventTime
            self.eventType = eventType
            self.eventUpdatedTime = eventUpdatedTime
            self.incidentRecordArn = incidentRecordArn
        }

        private enum CodingKeys: String, CodingKey {
            case eventId
            case eventTime
            case eventType
            case eventUpdatedTime
            case incidentRecordArn
        }
    }

    public struct Filter: AWSEncodableShape {
        /// The condition accepts before or after a specified time, equal to a string, or equal to an integer.
        public let condition: Condition
        /// The key that you're filtering on.
        public let key: String

        public init(condition: Condition, key: String) {
            self.condition = condition
            self.key = key
        }

        public func validate(name: String) throws {
            try self.condition.validate(name: "\(name).condition")
            try self.validate(self.key, name: "key", parent: name, max: 50)
            try self.validate(self.key, name: "key", parent: name, min: 0)
        }

        private enum CodingKeys: String, CodingKey {
            case condition
            case key
        }
    }

    public struct GetIncidentRecordInput: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "arn", location: .querystring(locationName: "arn"))
        ]

        /// The Amazon Resource Name (ARN) of the incident record.
        public let arn: String

        public init(arn: String) {
            self.arn = arn
        }

        public func validate(name: String) throws {
            try self.validate(self.arn, name: "arn", parent: name, max: 1000)
            try self.validate(self.arn, name: "arn", parent: name, min: 0)
            try self.validate(self.arn, name: "arn", parent: name, pattern: "^arn:aws(-cn|-us-gov)?:[a-z0-9-]*:[a-z0-9-]*:([0-9]{12})?:.+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetIncidentRecordOutput: AWSDecodableShape {
        /// Details structure of the incident record.
        public let incidentRecord: IncidentRecord

        public init(incidentRecord: IncidentRecord) {
            self.incidentRecord = incidentRecord
        }

        private enum CodingKeys: String, CodingKey {
            case incidentRecord
        }
    }

    public struct GetReplicationSetInput: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "arn", location: .querystring(locationName: "arn"))
        ]

        /// The Amazon Resource Name (ARN) of the replication set you want to retrieve.
        public let arn: String

        public init(arn: String) {
            self.arn = arn
        }

        public func validate(name: String) throws {
            try self.validate(self.arn, name: "arn", parent: name, max: 1000)
            try self.validate(self.arn, name: "arn", parent: name, min: 0)
            try self.validate(self.arn, name: "arn", parent: name, pattern: "^arn:aws(-cn|-us-gov)?:[a-z0-9-]*:[a-z0-9-]*:([0-9]{12})?:.+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetReplicationSetOutput: AWSDecodableShape {
        /// Details of the replication set.
        public let replicationSet: ReplicationSet

        public init(replicationSet: ReplicationSet) {
            self.replicationSet = replicationSet
        }

        private enum CodingKeys: String, CodingKey {
            case replicationSet
        }
    }

    public struct GetResourcePoliciesInput: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "resourceArn", location: .querystring(locationName: "resourceArn"))
        ]

        /// The maximum number of resource policies to display per page of results.
        public let maxResults: Int?
        /// The pagination token to continue to the next page of results.
        public let nextToken: String?
        /// The Amazon Resource Name (ARN) of the response plan with the attached resource policy.
        public let resourceArn: String

        public init(maxResults: Int? = nil, nextToken: String? = nil, resourceArn: String) {
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.resourceArn = resourceArn
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 1000)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 0)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, max: 1000)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, min: 0)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, pattern: "^arn:aws(-cn|-us-gov)?:[a-z0-9-]*:[a-z0-9-]*:([0-9]{12})?:.+$")
        }

        private enum CodingKeys: String, CodingKey {
            case maxResults
            case nextToken
        }
    }

    public struct GetResourcePoliciesOutput: AWSDecodableShape {
        /// The pagination token to continue to the next page of results.
        public let nextToken: String?
        /// Details about the resource policy attached to the response plan.
        public let resourcePolicies: [ResourcePolicy]

        public init(nextToken: String? = nil, resourcePolicies: [ResourcePolicy]) {
            self.nextToken = nextToken
            self.resourcePolicies = resourcePolicies
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken
            case resourcePolicies
        }
    }

    public struct GetResponsePlanInput: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "arn", location: .querystring(locationName: "arn"))
        ]

        /// The Amazon Resource Name (ARN) of the response plan.
        public let arn: String

        public init(arn: String) {
            self.arn = arn
        }

        public func validate(name: String) throws {
            try self.validate(self.arn, name: "arn", parent: name, max: 1000)
            try self.validate(self.arn, name: "arn", parent: name, min: 0)
            try self.validate(self.arn, name: "arn", parent: name, pattern: "^arn:aws(-cn|-us-gov)?:[a-z0-9-]*:[a-z0-9-]*:([0-9]{12})?:.+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetResponsePlanOutput: AWSDecodableShape {
        /// The actions that this response plan takes at the beginning of the incident.
        public let actions: [Action]?
        /// The ARN of the response plan.
        public let arn: String
        /// The AWS Chatbot chat channel used for collaboration during an incident.
        public let chatChannel: ChatChannel?
        /// The long format name of the response plan. Can contain spaces.
        public let displayName: String?
        /// The contacts and escalation plans that the response plan engages during an incident.
        public let engagements: [String]?
        /// Details used to create the incident when using this response plan.
        public let incidentTemplate: IncidentTemplate
        /// The short format name of the response plan. Can't contain spaces.
        public let name: String

        public init(actions: [Action]? = nil, arn: String, chatChannel: ChatChannel? = nil, displayName: String? = nil, engagements: [String]? = nil, incidentTemplate: IncidentTemplate, name: String) {
            self.actions = actions
            self.arn = arn
            self.chatChannel = chatChannel
            self.displayName = displayName
            self.engagements = engagements
            self.incidentTemplate = incidentTemplate
            self.name = name
        }

        private enum CodingKeys: String, CodingKey {
            case actions
            case arn
            case chatChannel
            case displayName
            case engagements
            case incidentTemplate
            case name
        }
    }

    public struct GetTimelineEventInput: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "eventId", location: .querystring(locationName: "eventId")),
            AWSMemberEncoding(label: "incidentRecordArn", location: .querystring(locationName: "incidentRecordArn"))
        ]

        /// The ID of the event. You can get an event's ID when you create it or by using ListTimelineEvents.
        public let eventId: String
        /// The Amazon Resource Name (ARN) of the incident that the timeline event is part of.
        public let incidentRecordArn: String

        public init(eventId: String, incidentRecordArn: String) {
            self.eventId = eventId
            self.incidentRecordArn = incidentRecordArn
        }

        public func validate(name: String) throws {
            try self.validate(self.eventId, name: "eventId", parent: name, max: 50)
            try self.validate(self.eventId, name: "eventId", parent: name, min: 0)
            try self.validate(self.incidentRecordArn, name: "incidentRecordArn", parent: name, max: 1000)
            try self.validate(self.incidentRecordArn, name: "incidentRecordArn", parent: name, min: 0)
            try self.validate(self.incidentRecordArn, name: "incidentRecordArn", parent: name, pattern: "^arn:aws(-cn|-us-gov)?:[a-z0-9-]*:[a-z0-9-]*:([0-9]{12})?:.+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetTimelineEventOutput: AWSDecodableShape {
        /// Details about the timeline event.
        public let event: TimelineEvent

        public init(event: TimelineEvent) {
            self.event = event
        }

        private enum CodingKeys: String, CodingKey {
            case event
        }
    }

    public struct IncidentRecord: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the incident record.
        public let arn: String
        /// The runbook, or automation document, that's run at the beginning of the incident.
        public let automationExecutions: [AutomationExecution]?
        /// The chat channel used for collaboration during an incident.
        public let chatChannel: ChatChannel?
        /// The time that Incident Manager created the incident record.
        public let creationTime: Date
        /// The string Incident Manager uses to prevent duplicate incidents from being created by the same incident.
        public let dedupeString: String
        /// The impact of the incident on customers and applications.
        public let impact: Int
        /// Details about the action that started the incident.
        public let incidentRecordSource: IncidentRecordSource
        /// Who modified the incident most recently.
        public let lastModifiedBy: String
        /// The time at which the incident was most recently modified.
        public let lastModifiedTime: Date
        /// The SNS targets that AWS Chatbot uses to notify the chat channels and perform actions on the incident record.
        public let notificationTargets: [NotificationTargetItem]?
        /// The time at which the incident was resolved. This appears as a timeline event.
        public let resolvedTime: Date?
        /// The current status of the incident.
        public let status: IncidentRecordStatus
        /// The summary of the incident. The summary is a brief synopsis of what occurred, what is currently happening, and context.
        public let summary: String?
        /// The title of the incident.
        public let title: String

        public init(arn: String, automationExecutions: [AutomationExecution]? = nil, chatChannel: ChatChannel? = nil, creationTime: Date, dedupeString: String, impact: Int, incidentRecordSource: IncidentRecordSource, lastModifiedBy: String, lastModifiedTime: Date, notificationTargets: [NotificationTargetItem]? = nil, resolvedTime: Date? = nil, status: IncidentRecordStatus, summary: String? = nil, title: String) {
            self.arn = arn
            self.automationExecutions = automationExecutions
            self.chatChannel = chatChannel
            self.creationTime = creationTime
            self.dedupeString = dedupeString
            self.impact = impact
            self.incidentRecordSource = incidentRecordSource
            self.lastModifiedBy = lastModifiedBy
            self.lastModifiedTime = lastModifiedTime
            self.notificationTargets = notificationTargets
            self.resolvedTime = resolvedTime
            self.status = status
            self.summary = summary
            self.title = title
        }

        private enum CodingKeys: String, CodingKey {
            case arn
            case automationExecutions
            case chatChannel
            case creationTime
            case dedupeString
            case impact
            case incidentRecordSource
            case lastModifiedBy
            case lastModifiedTime
            case notificationTargets
            case resolvedTime
            case status
            case summary
            case title
        }
    }

    public struct IncidentRecordSource: AWSDecodableShape {
        /// The principal that started the incident.
        public let createdBy: String
        /// The principal the assumed the role specified of the createdBy.
        public let invokedBy: String?
        /// The resource that caused the incident to be created.
        public let resourceArn: String?
        /// The service that started the incident. This can be manually created from Incident Manager, automatically created using an AWS CloudWatch alarm, or Amazon EventBridge event.
        public let source: String

        public init(createdBy: String, invokedBy: String? = nil, resourceArn: String? = nil, source: String) {
            self.createdBy = createdBy
            self.invokedBy = invokedBy
            self.resourceArn = resourceArn
            self.source = source
        }

        private enum CodingKeys: String, CodingKey {
            case createdBy
            case invokedBy
            case resourceArn
            case source
        }
    }

    public struct IncidentRecordSummary: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the incident.
        public let arn: String
        /// The time the incident was created.
        public let creationTime: Date
        /// Defines the impact to customers and applications.
        public let impact: Int
        /// What caused Incident Manager to create the incident.
        public let incidentRecordSource: IncidentRecordSource
        /// The time the incident was resolved.
        public let resolvedTime: Date?
        /// The current status of the incident.
        public let status: IncidentRecordStatus
        /// The title of the incident. This value is either provided by the response plan or overwritten on creation.
        public let title: String

        public init(arn: String, creationTime: Date, impact: Int, incidentRecordSource: IncidentRecordSource, resolvedTime: Date? = nil, status: IncidentRecordStatus, title: String) {
            self.arn = arn
            self.creationTime = creationTime
            self.impact = impact
            self.incidentRecordSource = incidentRecordSource
            self.resolvedTime = resolvedTime
            self.status = status
            self.title = title
        }

        private enum CodingKeys: String, CodingKey {
            case arn
            case creationTime
            case impact
            case incidentRecordSource
            case resolvedTime
            case status
            case title
        }
    }

    public struct IncidentTemplate: AWSEncodableShape & AWSDecodableShape {
        /// Used to stop Incident Manager from creating multiple incident records for the same incident.
        public let dedupeString: String?
        /// The impact of the incident on your customers and applications.
        public let impact: Int
        /// The SNS targets that AWS Chatbot uses to notify the chat channel of updates to an incident. You can also make updates to the incident through the chat channel using the SNS topics.
        public let notificationTargets: [NotificationTargetItem]?
        /// The summary of the incident. The summary is a brief synopsis of what occurred, what's currently happening, and context.
        public let summary: String?
        /// The title of the incident.
        public let title: String

        public init(dedupeString: String? = nil, impact: Int, notificationTargets: [NotificationTargetItem]? = nil, summary: String? = nil, title: String) {
            self.dedupeString = dedupeString
            self.impact = impact
            self.notificationTargets = notificationTargets
            self.summary = summary
            self.title = title
        }

        public func validate(name: String) throws {
            try self.validate(self.dedupeString, name: "dedupeString", parent: name, max: 1000)
            try self.validate(self.dedupeString, name: "dedupeString", parent: name, min: 0)
            try self.validate(self.impact, name: "impact", parent: name, max: 5)
            try self.validate(self.impact, name: "impact", parent: name, min: 1)
            try self.notificationTargets?.forEach {
                try $0.validate(name: "\(name).notificationTargets[]")
            }
            try self.validate(self.notificationTargets, name: "notificationTargets", parent: name, max: 10)
            try self.validate(self.notificationTargets, name: "notificationTargets", parent: name, min: 0)
            try self.validate(self.summary, name: "summary", parent: name, max: 4000)
            try self.validate(self.summary, name: "summary", parent: name, min: 0)
            try self.validate(self.title, name: "title", parent: name, max: 200)
            try self.validate(self.title, name: "title", parent: name, min: 0)
        }

        private enum CodingKeys: String, CodingKey {
            case dedupeString
            case impact
            case notificationTargets
            case summary
            case title
        }
    }

    public struct ItemIdentifier: AWSEncodableShape & AWSDecodableShape {
        /// The type of related item. Incident Manager supports the following types:    ANALYSIS     INCIDENT     METRIC     PARENT     ATTACHMENT     OTHER
        public let type: ItemType
        /// Details about the related item.
        public let value: ItemValue

        public init(type: ItemType, value: ItemValue) {
            self.type = type
            self.value = value
        }

        public func validate(name: String) throws {
            try self.value.validate(name: "\(name).value")
        }

        private enum CodingKeys: String, CodingKey {
            case type
            case value
        }
    }

    public struct ItemValue: AWSEncodableShape & AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the related item, if the related item is an Amazon resource.
        public let arn: String?
        /// The metric definition, if the related item is a metric in CloudWatch.
        public let metricDefinition: String?
        /// The URL, if the related item is a non-AWS resource.
        public let url: String?

        public init(arn: String? = nil, metricDefinition: String? = nil, url: String? = nil) {
            self.arn = arn
            self.metricDefinition = metricDefinition
            self.url = url
        }

        public func validate(name: String) throws {
            try self.validate(self.arn, name: "arn", parent: name, max: 1000)
            try self.validate(self.arn, name: "arn", parent: name, min: 0)
            try self.validate(self.arn, name: "arn", parent: name, pattern: "^arn:aws(-cn|-us-gov)?:[a-z0-9-]*:[a-z0-9-]*:([0-9]{12})?:.+$")
            try self.validate(self.metricDefinition, name: "metricDefinition", parent: name, max: 4000)
            try self.validate(self.metricDefinition, name: "metricDefinition", parent: name, min: 0)
            try self.validate(self.url, name: "url", parent: name, max: 1000)
            try self.validate(self.url, name: "url", parent: name, min: 0)
        }

        private enum CodingKeys: String, CodingKey {
            case arn
            case metricDefinition
            case url
        }
    }

    public struct ListIncidentRecordsInput: AWSEncodableShape {
        /// Filter the list of incident records you are searching through. You can filter on the following keys:    creationTime     impact     status     createdBy
        public let filters: [Filter]?
        /// The maximum number of results per page.
        public let maxResults: Int?
        /// The pagination token to continue to the next page of results.
        public let nextToken: String?

        public init(filters: [Filter]? = nil, maxResults: Int? = nil, nextToken: String? = nil) {
            self.filters = filters
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.filters?.forEach {
                try $0.validate(name: "\(name).filters[]")
            }
            try self.validate(self.filters, name: "filters", parent: name, max: 5)
            try self.validate(self.filters, name: "filters", parent: name, min: 0)
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 1000)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 0)
        }

        private enum CodingKeys: String, CodingKey {
            case filters
            case maxResults
            case nextToken
        }
    }

    public struct ListIncidentRecordsOutput: AWSDecodableShape {
        /// The details of each listed incident record.
        public let incidentRecordSummaries: [IncidentRecordSummary]
        /// The pagination token to continue to the next page of results.
        public let nextToken: String?

        public init(incidentRecordSummaries: [IncidentRecordSummary], nextToken: String? = nil) {
            self.incidentRecordSummaries = incidentRecordSummaries
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case incidentRecordSummaries
            case nextToken
        }
    }

    public struct ListRelatedItemsInput: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the incident record that you are listing related items for.
        public let incidentRecordArn: String
        /// The maximum number of related items per page.
        public let maxResults: Int?
        /// The pagination token to continue to the next page of results.
        public let nextToken: String?

        public init(incidentRecordArn: String, maxResults: Int? = nil, nextToken: String? = nil) {
            self.incidentRecordArn = incidentRecordArn
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.validate(self.incidentRecordArn, name: "incidentRecordArn", parent: name, max: 1000)
            try self.validate(self.incidentRecordArn, name: "incidentRecordArn", parent: name, min: 0)
            try self.validate(self.incidentRecordArn, name: "incidentRecordArn", parent: name, pattern: "^arn:aws(-cn|-us-gov)?:[a-z0-9-]*:[a-z0-9-]*:([0-9]{12})?:.+$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 1000)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 0)
        }

        private enum CodingKeys: String, CodingKey {
            case incidentRecordArn
            case maxResults
            case nextToken
        }
    }

    public struct ListRelatedItemsOutput: AWSDecodableShape {
        /// The pagination token to continue to the next page of results.
        public let nextToken: String?
        /// Details about each related item.
        public let relatedItems: [RelatedItem]

        public init(nextToken: String? = nil, relatedItems: [RelatedItem]) {
            self.nextToken = nextToken
            self.relatedItems = relatedItems
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken
            case relatedItems
        }
    }

    public struct ListReplicationSetsInput: AWSEncodableShape {
        /// The maximum number of results per page.
        public let maxResults: Int?
        /// The pagination token to continue to the next page of results.
        public let nextToken: String?

        public init(maxResults: Int? = nil, nextToken: String? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 1000)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 0)
        }

        private enum CodingKeys: String, CodingKey {
            case maxResults
            case nextToken
        }
    }

    public struct ListReplicationSetsOutput: AWSDecodableShape {
        /// The pagination token to continue to the next page of results.
        public let nextToken: String?
        /// The Amazon Resource Name (ARN) of the list replication set.
        public let replicationSetArns: [String]

        public init(nextToken: String? = nil, replicationSetArns: [String]) {
            self.nextToken = nextToken
            self.replicationSetArns = replicationSetArns
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken
            case replicationSetArns
        }
    }

    public struct ListResponsePlansInput: AWSEncodableShape {
        /// The maximum number of response plans per page.
        public let maxResults: Int?
        /// The pagination token to continue to the next page of results.
        public let nextToken: String?

        public init(maxResults: Int? = nil, nextToken: String? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 1000)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 0)
        }

        private enum CodingKeys: String, CodingKey {
            case maxResults
            case nextToken
        }
    }

    public struct ListResponsePlansOutput: AWSDecodableShape {
        /// The pagination token to continue to the next page of results.
        public let nextToken: String?
        /// Details of each response plan.
        public let responsePlanSummaries: [ResponsePlanSummary]

        public init(nextToken: String? = nil, responsePlanSummaries: [ResponsePlanSummary]) {
            self.nextToken = nextToken
            self.responsePlanSummaries = responsePlanSummaries
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken
            case responsePlanSummaries
        }
    }

    public struct ListTagsForResourceRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "resourceArn", location: .uri(locationName: "resourceArn"))
        ]

        /// The Amazon Resource Name (ARN) of the response plan.
        public let resourceArn: String

        public init(resourceArn: String) {
            self.resourceArn = resourceArn
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListTagsForResourceResponse: AWSDecodableShape {
        /// A list of tags for the response plan.
        public let tags: [String: String]

        public init(tags: [String: String]) {
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case tags
        }
    }

    public struct ListTimelineEventsInput: AWSEncodableShape {
        /// Filters the timeline events based on the provided conditional values. You can filter timeline events using the following keys:    eventTime     eventType
        public let filters: [Filter]?
        /// The Amazon Resource Name (ARN) of the incident that the event is part of.
        public let incidentRecordArn: String
        /// The maximum number of results per page.
        public let maxResults: Int?
        /// The pagination token to continue to the next page of results.
        public let nextToken: String?
        /// Sort by the specified key value pair.
        public let sortBy: TimelineEventSort?
        /// Sorts the order of timeline events by the value specified in the sortBy field.
        public let sortOrder: SortOrder?

        public init(filters: [Filter]? = nil, incidentRecordArn: String, maxResults: Int? = nil, nextToken: String? = nil, sortBy: TimelineEventSort? = nil, sortOrder: SortOrder? = nil) {
            self.filters = filters
            self.incidentRecordArn = incidentRecordArn
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.sortBy = sortBy
            self.sortOrder = sortOrder
        }

        public func validate(name: String) throws {
            try self.filters?.forEach {
                try $0.validate(name: "\(name).filters[]")
            }
            try self.validate(self.filters, name: "filters", parent: name, max: 5)
            try self.validate(self.filters, name: "filters", parent: name, min: 0)
            try self.validate(self.incidentRecordArn, name: "incidentRecordArn", parent: name, max: 1000)
            try self.validate(self.incidentRecordArn, name: "incidentRecordArn", parent: name, min: 0)
            try self.validate(self.incidentRecordArn, name: "incidentRecordArn", parent: name, pattern: "^arn:aws(-cn|-us-gov)?:[a-z0-9-]*:[a-z0-9-]*:([0-9]{12})?:.+$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 1000)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 0)
        }

        private enum CodingKeys: String, CodingKey {
            case filters
            case incidentRecordArn
            case maxResults
            case nextToken
            case sortBy
            case sortOrder
        }
    }

    public struct ListTimelineEventsOutput: AWSDecodableShape {
        /// Details about each event that occurred during the incident.
        public let eventSummaries: [EventSummary]
        /// The pagination token to continue to the next page of results.
        public let nextToken: String?

        public init(eventSummaries: [EventSummary], nextToken: String? = nil) {
            self.eventSummaries = eventSummaries
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case eventSummaries
            case nextToken
        }
    }

    public struct NotificationTargetItem: AWSEncodableShape & AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the SNS topic.
        public let snsTopicArn: String?

        public init(snsTopicArn: String? = nil) {
            self.snsTopicArn = snsTopicArn
        }

        public func validate(name: String) throws {
            try self.validate(self.snsTopicArn, name: "snsTopicArn", parent: name, max: 1000)
            try self.validate(self.snsTopicArn, name: "snsTopicArn", parent: name, min: 0)
            try self.validate(self.snsTopicArn, name: "snsTopicArn", parent: name, pattern: "^arn:aws(-cn|-us-gov)?:[a-z0-9-]*:[a-z0-9-]*:([0-9]{12})?:.+$")
        }

        private enum CodingKeys: String, CodingKey {
            case snsTopicArn
        }
    }

    public struct PutResourcePolicyInput: AWSEncodableShape {
        /// Details of the resource policy.
        public let policy: String
        /// The Amazon Resource Name (ARN) of the response plan you're adding the resource policy to.
        public let resourceArn: String

        public init(policy: String, resourceArn: String) {
            self.policy = policy
            self.resourceArn = resourceArn
        }

        public func validate(name: String) throws {
            try self.validate(self.policy, name: "policy", parent: name, max: 4000)
            try self.validate(self.policy, name: "policy", parent: name, min: 0)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, max: 1000)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, min: 0)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, pattern: "^arn:aws(-cn|-us-gov)?:[a-z0-9-]*:[a-z0-9-]*:([0-9]{12})?:.+$")
        }

        private enum CodingKeys: String, CodingKey {
            case policy
            case resourceArn
        }
    }

    public struct PutResourcePolicyOutput: AWSDecodableShape {
        /// The ID of the resource policy.
        public let policyId: String

        public init(policyId: String) {
            self.policyId = policyId
        }

        private enum CodingKeys: String, CodingKey {
            case policyId
        }
    }

    public struct RegionInfo: AWSDecodableShape {
        /// The ID of the KMS key used to encrypt the data in this Region.
        public let sseKmsKeyId: String?
        /// The status of the Region in the replication set.
        public let status: RegionStatus
        /// Information displayed about the status of the Region.
        public let statusMessage: String?
        /// The most recent date and time that the Region's status was updated.
        public let statusUpdateDateTime: Date

        public init(sseKmsKeyId: String? = nil, status: RegionStatus, statusMessage: String? = nil, statusUpdateDateTime: Date) {
            self.sseKmsKeyId = sseKmsKeyId
            self.status = status
            self.statusMessage = statusMessage
            self.statusUpdateDateTime = statusUpdateDateTime
        }

        private enum CodingKeys: String, CodingKey {
            case sseKmsKeyId
            case status
            case statusMessage
            case statusUpdateDateTime
        }
    }

    public struct RegionMapInputValue: AWSEncodableShape {
        /// The KMS key used to encrypt the data in your replication set.
        public let sseKmsKeyId: String?

        public init(sseKmsKeyId: String? = nil) {
            self.sseKmsKeyId = sseKmsKeyId
        }

        public func validate(name: String) throws {
            try self.validate(self.sseKmsKeyId, name: "sseKmsKeyId", parent: name, max: 2048)
            try self.validate(self.sseKmsKeyId, name: "sseKmsKeyId", parent: name, min: 0)
        }

        private enum CodingKeys: String, CodingKey {
            case sseKmsKeyId
        }
    }

    public struct RelatedItem: AWSEncodableShape & AWSDecodableShape {
        /// Details about the related item.
        public let identifier: ItemIdentifier
        /// The title of the related item.
        public let title: String?

        public init(identifier: ItemIdentifier, title: String? = nil) {
            self.identifier = identifier
            self.title = title
        }

        public func validate(name: String) throws {
            try self.identifier.validate(name: "\(name).identifier")
            try self.validate(self.title, name: "title", parent: name, max: 200)
            try self.validate(self.title, name: "title", parent: name, min: 0)
        }

        private enum CodingKeys: String, CodingKey {
            case identifier
            case title
        }
    }

    public struct RelatedItemsUpdate: AWSEncodableShape {
        /// Details about the related item you're adding.
        public let itemToAdd: RelatedItem?
        /// Details about the related item you're deleting.
        public let itemToRemove: ItemIdentifier?

        public init(itemToAdd: RelatedItem? = nil, itemToRemove: ItemIdentifier? = nil) {
            self.itemToAdd = itemToAdd
            self.itemToRemove = itemToRemove
        }

        public func validate(name: String) throws {
            try self.itemToAdd?.validate(name: "\(name).itemToAdd")
            try self.itemToRemove?.validate(name: "\(name).itemToRemove")
        }

        private enum CodingKeys: String, CodingKey {
            case itemToAdd
            case itemToRemove
        }
    }

    public struct ReplicationSet: AWSDecodableShape {
        /// Details about who created the replication set.
        public let createdBy: String
        /// When the replication set was created.
        public let createdTime: Date
        /// Determines if the replication set deletion protection is enabled or not. If deletion protection is enabled, you can't delete the last Region in the replication set.
        public let deletionProtected: Bool
        /// Who last modified the replication set.
        public let lastModifiedBy: String
        /// When the replication set was last updated.
        public let lastModifiedTime: Date
        /// The map between each Region in your replication set and the KMS key that is used to encrypt the data in that Region.
        public let regionMap: [String: RegionInfo]
        /// The status of the replication set. If the replication set is still pending, you can't use Incident Manager functionality.
        public let status: ReplicationSetStatus

        public init(createdBy: String, createdTime: Date, deletionProtected: Bool, lastModifiedBy: String, lastModifiedTime: Date, regionMap: [String: RegionInfo], status: ReplicationSetStatus) {
            self.createdBy = createdBy
            self.createdTime = createdTime
            self.deletionProtected = deletionProtected
            self.lastModifiedBy = lastModifiedBy
            self.lastModifiedTime = lastModifiedTime
            self.regionMap = regionMap
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case createdBy
            case createdTime
            case deletionProtected
            case lastModifiedBy
            case lastModifiedTime
            case regionMap
            case status
        }
    }

    public struct ResourcePolicy: AWSDecodableShape {
        /// The JSON blob that describes the policy.
        public let policyDocument: String
        /// The ID of the resource policy.
        public let policyId: String
        /// The Region that policy allows resources to be used in.
        public let ramResourceShareRegion: String

        public init(policyDocument: String, policyId: String, ramResourceShareRegion: String) {
            self.policyDocument = policyDocument
            self.policyId = policyId
            self.ramResourceShareRegion = ramResourceShareRegion
        }

        private enum CodingKeys: String, CodingKey {
            case policyDocument
            case policyId
            case ramResourceShareRegion
        }
    }

    public struct ResponsePlanSummary: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the response plan.
        public let arn: String
        /// The human readable name of the response plan. This can include spaces.
        public let displayName: String?
        /// The name of the response plan. This can't include spaces.
        public let name: String

        public init(arn: String, displayName: String? = nil, name: String) {
            self.arn = arn
            self.displayName = displayName
            self.name = name
        }

        private enum CodingKeys: String, CodingKey {
            case arn
            case displayName
            case name
        }
    }

    public struct SsmAutomation: AWSEncodableShape & AWSDecodableShape {
        /// The automation document's name.
        public let documentName: String
        /// The automation document's version to use when running.
        public let documentVersion: String?
        /// The key-value pair parameters to use when running the automation document.
        public let parameters: [String: [String]]?
        /// The Amazon Resource Name (ARN) of the role that the automation document will assume when running commands.
        public let roleArn: String
        /// The account that the automation document will be run in. This can be in either the management account or an application account.
        public let targetAccount: SsmTargetAccount?

        public init(documentName: String, documentVersion: String? = nil, parameters: [String: [String]]? = nil, roleArn: String, targetAccount: SsmTargetAccount? = nil) {
            self.documentName = documentName
            self.documentVersion = documentVersion
            self.parameters = parameters
            self.roleArn = roleArn
            self.targetAccount = targetAccount
        }

        public func validate(name: String) throws {
            try self.validate(self.documentName, name: "documentName", parent: name, pattern: "^[a-zA-Z0-9_\\-.:/]{3,128}$")
            try self.validate(self.documentVersion, name: "documentVersion", parent: name, max: 128)
            try self.validate(self.documentVersion, name: "documentVersion", parent: name, min: 0)
            try self.parameters?.forEach {
                try validate($0.key, name: "parameters.key", parent: name, max: 50)
                try validate($0.key, name: "parameters.key", parent: name, min: 1)
                try validate($0.value, name: "parameters[\"\($0.key)\"]", parent: name, max: 100)
                try validate($0.value, name: "parameters[\"\($0.key)\"]", parent: name, min: 0)
            }
            try self.validate(self.roleArn, name: "roleArn", parent: name, max: 1000)
            try self.validate(self.roleArn, name: "roleArn", parent: name, min: 0)
            try self.validate(self.roleArn, name: "roleArn", parent: name, pattern: "^arn:aws(-cn|-us-gov)?:iam::([0-9]{12})?:role/.+$")
        }

        private enum CodingKeys: String, CodingKey {
            case documentName
            case documentVersion
            case parameters
            case roleArn
            case targetAccount
        }
    }

    public struct StartIncidentInput: AWSEncodableShape {
        /// A token ensuring that the action is called only once with the specified details.
        public let clientToken: String?
        /// Defines the impact to the customers. Providing an impact overwrites the impact provided by a response plan.  Possible impacts:     1 - Critical impact, this typically relates to full application failure that impacts many to all customers.     2 - High impact, partial application failure with impact to many customers.    3 - Medium impact, the application is providing reduced service to customers.    4 - Low impact, customer might aren't impacted by the problem yet.    5 - No impact, customers aren't currently impacted but urgent action is needed to avoid impact.
        public let impact: Int?
        /// Add related items to the incident for other responders to use. Related items are AWS resources, external links, or files uploaded to an S3 bucket.
        public let relatedItems: [RelatedItem]?
        /// The Amazon Resource Name (ARN) of the response plan that pre-defines summary, chat channels, SNS topics, runbooks, title, and impact of the incident.
        public let responsePlanArn: String
        /// Provide a title for the incident. Providing a title overwrites the title provided by the response plan.
        public let title: String?
        /// Details of what created the incident record in Incident Manager.
        public let triggerDetails: TriggerDetails?

        public init(clientToken: String? = StartIncidentInput.idempotencyToken(), impact: Int? = nil, relatedItems: [RelatedItem]? = nil, responsePlanArn: String, title: String? = nil, triggerDetails: TriggerDetails? = nil) {
            self.clientToken = clientToken
            self.impact = impact
            self.relatedItems = relatedItems
            self.responsePlanArn = responsePlanArn
            self.title = title
            self.triggerDetails = triggerDetails
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 128)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 0)
            try self.validate(self.impact, name: "impact", parent: name, max: 5)
            try self.validate(self.impact, name: "impact", parent: name, min: 1)
            try self.relatedItems?.forEach {
                try $0.validate(name: "\(name).relatedItems[]")
            }
            try self.validate(self.relatedItems, name: "relatedItems", parent: name, max: 100)
            try self.validate(self.relatedItems, name: "relatedItems", parent: name, min: 0)
            try self.validate(self.responsePlanArn, name: "responsePlanArn", parent: name, max: 1000)
            try self.validate(self.responsePlanArn, name: "responsePlanArn", parent: name, min: 0)
            try self.validate(self.responsePlanArn, name: "responsePlanArn", parent: name, pattern: "^arn:aws(-cn|-us-gov)?:[a-z0-9-]*:[a-z0-9-]*:([0-9]{12})?:.+$")
            try self.validate(self.title, name: "title", parent: name, max: 200)
            try self.validate(self.title, name: "title", parent: name, min: 0)
            try self.triggerDetails?.validate(name: "\(name).triggerDetails")
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken
            case impact
            case relatedItems
            case responsePlanArn
            case title
            case triggerDetails
        }
    }

    public struct StartIncidentOutput: AWSDecodableShape {
        /// The ARN of the newly created incident record.
        public let incidentRecordArn: String

        public init(incidentRecordArn: String) {
            self.incidentRecordArn = incidentRecordArn
        }

        private enum CodingKeys: String, CodingKey {
            case incidentRecordArn
        }
    }

    public struct TagResourceRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "resourceArn", location: .uri(locationName: "resourceArn"))
        ]

        /// The Amazon Resource Name (ARN) of the response plan you're adding the tags to.
        public let resourceArn: String
        /// A list of tags that you are adding to the response plan.
        public let tags: [String: String]

        public init(resourceArn: String, tags: [String: String]) {
            self.resourceArn = resourceArn
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.tags.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.key, name: "tags.key", parent: name, pattern: "^(?!aws:)[A-Za-z0-9 _=@:.+-/]+$")
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, min: 0)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, pattern: "^[A-Za-z0-9 _=@:.+-/]*$")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case tags
        }
    }

    public struct TagResourceResponse: AWSDecodableShape {
        public init() {}
    }

    public struct TimelineEvent: AWSDecodableShape {
        /// A short description of the event.
        public let eventData: String
        /// The ID of the timeline event.
        public let eventId: String
        /// The time that the event occurred.
        public let eventTime: Date
        /// The type of event that occurred. Currently Incident Manager supports only the Custom Event type.
        public let eventType: String
        /// The time that the timeline event was last updated.
        public let eventUpdatedTime: Date
        /// The Amazon Resource Name (ARN) of the incident that the event occurred during.
        public let incidentRecordArn: String

        public init(eventData: String, eventId: String, eventTime: Date, eventType: String, eventUpdatedTime: Date, incidentRecordArn: String) {
            self.eventData = eventData
            self.eventId = eventId
            self.eventTime = eventTime
            self.eventType = eventType
            self.eventUpdatedTime = eventUpdatedTime
            self.incidentRecordArn = incidentRecordArn
        }

        private enum CodingKeys: String, CodingKey {
            case eventData
            case eventId
            case eventTime
            case eventType
            case eventUpdatedTime
            case incidentRecordArn
        }
    }

    public struct TriggerDetails: AWSEncodableShape {
        /// Raw data passed from either EventBridge, CloudWatch, or Incident Manager when an incident is created.
        public let rawData: String?
        /// Identifies the service that sourced the event. All events sourced from within AWS begin with "aws." Customer-generated events can have any value here, as long as it doesn't begin with "aws." We recommend the use of Java package-name style reverse domain-name strings.
        public let source: String
        /// The time that the incident was detected.
        public let timestamp: Date
        /// The ARN of the source that detected the incident.
        public let triggerArn: String?

        public init(rawData: String? = nil, source: String, timestamp: Date, triggerArn: String? = nil) {
            self.rawData = rawData
            self.source = source
            self.timestamp = timestamp
            self.triggerArn = triggerArn
        }

        public func validate(name: String) throws {
            try self.validate(self.rawData, name: "rawData", parent: name, max: 4000)
            try self.validate(self.rawData, name: "rawData", parent: name, min: 0)
            try self.validate(self.source, name: "source", parent: name, max: 50)
            try self.validate(self.source, name: "source", parent: name, min: 0)
            try self.validate(self.triggerArn, name: "triggerArn", parent: name, max: 1000)
            try self.validate(self.triggerArn, name: "triggerArn", parent: name, min: 0)
            try self.validate(self.triggerArn, name: "triggerArn", parent: name, pattern: "^arn:aws(-cn|-us-gov)?:[a-z0-9-]*:[a-z0-9-]*:([0-9]{12})?:.+$")
        }

        private enum CodingKeys: String, CodingKey {
            case rawData
            case source
            case timestamp
            case triggerArn
        }
    }

    public struct UntagResourceRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "resourceArn", location: .uri(locationName: "resourceArn")),
            AWSMemberEncoding(label: "tagKeys", location: .querystring(locationName: "tagKeys"))
        ]

        /// The Amazon Resource Name (ARN) of the response plan you're removing a tag from.
        public let resourceArn: String
        /// The name of the tag you're removing from the response plan.
        public let tagKeys: [String]

        public init(resourceArn: String, tagKeys: [String]) {
            self.resourceArn = resourceArn
            self.tagKeys = tagKeys
        }

        public func validate(name: String) throws {
            try self.tagKeys.forEach {
                try validate($0, name: "tagKeys[]", parent: name, max: 128)
                try validate($0, name: "tagKeys[]", parent: name, min: 1)
                try validate($0, name: "tagKeys[]", parent: name, pattern: "^(?!aws:)[A-Za-z0-9 _=@:.+-/]+$")
            }
            try self.validate(self.tagKeys, name: "tagKeys", parent: name, max: 50)
            try self.validate(self.tagKeys, name: "tagKeys", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct UntagResourceResponse: AWSDecodableShape {
        public init() {}
    }

    public struct UpdateDeletionProtectionInput: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the replication set you're updating.
        public let arn: String
        /// A token ensuring that the action is called only once with the specified details.
        public let clientToken: String?
        /// Details if deletion protection is enabled or disabled in your account.
        public let deletionProtected: Bool

        public init(arn: String, clientToken: String? = UpdateDeletionProtectionInput.idempotencyToken(), deletionProtected: Bool) {
            self.arn = arn
            self.clientToken = clientToken
            self.deletionProtected = deletionProtected
        }

        public func validate(name: String) throws {
            try self.validate(self.arn, name: "arn", parent: name, max: 1000)
            try self.validate(self.arn, name: "arn", parent: name, min: 0)
            try self.validate(self.arn, name: "arn", parent: name, pattern: "^arn:aws(-cn|-us-gov)?:[a-z0-9-]*:[a-z0-9-]*:([0-9]{12})?:.+$")
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 128)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 0)
        }

        private enum CodingKeys: String, CodingKey {
            case arn
            case clientToken
            case deletionProtected
        }
    }

    public struct UpdateDeletionProtectionOutput: AWSDecodableShape {
        public init() {}
    }

    public struct UpdateIncidentRecordInput: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the incident record you are updating.
        public let arn: String
        /// The AWS Chatbot chat channel for responders to collaborate in.
        public let chatChannel: ChatChannel?
        /// A token ensuring that the action is called only once with the specified details.
        public let clientToken: String?
        /// Defines the impact to customers and applications. Providing an impact overwrites the impact provided by the response plan.  Possible impacts:     1 - Critical impact, this typically relates to full application failure that impacts many to all customers.     2 - High impact, partial application failure with impact to many customers.    3 - Medium impact, the application is providing reduced service to customers.    4 - Low impact, customer might aren't impacted by the problem yet.    5 - No impact, customers aren't currently impacted but urgent action is needed to avoid impact.
        public let impact: Int?
        /// The SNS targets that AWS Chatbot uses to notify the chat channel of updates to an incident. You can also make updates to the incident through the chat channel using the SNS topics.  Using multiple SNS topics creates redundancy in the case that a Region is down during the incident.
        public let notificationTargets: [NotificationTargetItem]?
        /// The status of the incident. An incident can be Open or Resolved.
        public let status: IncidentRecordStatus?
        /// The summary describes what has happened during the incident.
        public let summary: String?
        /// The title of the incident is a brief and easily recognizable.
        public let title: String?

        public init(arn: String, chatChannel: ChatChannel? = nil, clientToken: String? = UpdateIncidentRecordInput.idempotencyToken(), impact: Int? = nil, notificationTargets: [NotificationTargetItem]? = nil, status: IncidentRecordStatus? = nil, summary: String? = nil, title: String? = nil) {
            self.arn = arn
            self.chatChannel = chatChannel
            self.clientToken = clientToken
            self.impact = impact
            self.notificationTargets = notificationTargets
            self.status = status
            self.summary = summary
            self.title = title
        }

        public func validate(name: String) throws {
            try self.validate(self.arn, name: "arn", parent: name, max: 1000)
            try self.validate(self.arn, name: "arn", parent: name, min: 0)
            try self.validate(self.arn, name: "arn", parent: name, pattern: "^arn:aws(-cn|-us-gov)?:[a-z0-9-]*:[a-z0-9-]*:([0-9]{12})?:.+$")
            try self.chatChannel?.validate(name: "\(name).chatChannel")
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 128)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 0)
            try self.validate(self.impact, name: "impact", parent: name, max: 5)
            try self.validate(self.impact, name: "impact", parent: name, min: 1)
            try self.notificationTargets?.forEach {
                try $0.validate(name: "\(name).notificationTargets[]")
            }
            try self.validate(self.notificationTargets, name: "notificationTargets", parent: name, max: 10)
            try self.validate(self.notificationTargets, name: "notificationTargets", parent: name, min: 0)
            try self.validate(self.summary, name: "summary", parent: name, max: 4000)
            try self.validate(self.summary, name: "summary", parent: name, min: 0)
            try self.validate(self.title, name: "title", parent: name, max: 200)
            try self.validate(self.title, name: "title", parent: name, min: 0)
        }

        private enum CodingKeys: String, CodingKey {
            case arn
            case chatChannel
            case clientToken
            case impact
            case notificationTargets
            case status
            case summary
            case title
        }
    }

    public struct UpdateIncidentRecordOutput: AWSDecodableShape {
        public init() {}
    }

    public struct UpdateRelatedItemsInput: AWSEncodableShape {
        /// A token ensuring that the action is called only once with the specified details.
        public let clientToken: String?
        /// The Amazon Resource Name (ARN) of the incident record you are updating related items in.
        public let incidentRecordArn: String
        /// Details about the item you are adding or deleting.
        public let relatedItemsUpdate: RelatedItemsUpdate

        public init(clientToken: String? = UpdateRelatedItemsInput.idempotencyToken(), incidentRecordArn: String, relatedItemsUpdate: RelatedItemsUpdate) {
            self.clientToken = clientToken
            self.incidentRecordArn = incidentRecordArn
            self.relatedItemsUpdate = relatedItemsUpdate
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 128)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 0)
            try self.validate(self.incidentRecordArn, name: "incidentRecordArn", parent: name, max: 1000)
            try self.validate(self.incidentRecordArn, name: "incidentRecordArn", parent: name, min: 0)
            try self.validate(self.incidentRecordArn, name: "incidentRecordArn", parent: name, pattern: "^arn:aws(-cn|-us-gov)?:[a-z0-9-]*:[a-z0-9-]*:([0-9]{12})?:.+$")
            try self.relatedItemsUpdate.validate(name: "\(name).relatedItemsUpdate")
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken
            case incidentRecordArn
            case relatedItemsUpdate
        }
    }

    public struct UpdateRelatedItemsOutput: AWSDecodableShape {
        public init() {}
    }

    public struct UpdateReplicationSetAction: AWSEncodableShape {
        /// Details about the Region that you're adding to the replication set.
        public let addRegionAction: AddRegionAction?
        /// Details about the Region that you're deleting to the replication set.
        public let deleteRegionAction: DeleteRegionAction?

        public init(addRegionAction: AddRegionAction? = nil, deleteRegionAction: DeleteRegionAction? = nil) {
            self.addRegionAction = addRegionAction
            self.deleteRegionAction = deleteRegionAction
        }

        public func validate(name: String) throws {
            try self.addRegionAction?.validate(name: "\(name).addRegionAction")
            try self.deleteRegionAction?.validate(name: "\(name).deleteRegionAction")
        }

        private enum CodingKeys: String, CodingKey {
            case addRegionAction
            case deleteRegionAction
        }
    }

    public struct UpdateReplicationSetInput: AWSEncodableShape {
        /// An action to add or delete a Region.
        public let actions: [UpdateReplicationSetAction]
        /// The Amazon Resource Name (ARN) of the replication set you're updating.
        public let arn: String
        /// A token ensuring that the action is called only once with the specified details.
        public let clientToken: String?

        public init(actions: [UpdateReplicationSetAction], arn: String, clientToken: String? = UpdateReplicationSetInput.idempotencyToken()) {
            self.actions = actions
            self.arn = arn
            self.clientToken = clientToken
        }

        public func validate(name: String) throws {
            try self.actions.forEach {
                try $0.validate(name: "\(name).actions[]")
            }
            try self.validate(self.actions, name: "actions", parent: name, max: 1)
            try self.validate(self.actions, name: "actions", parent: name, min: 1)
            try self.validate(self.arn, name: "arn", parent: name, max: 1000)
            try self.validate(self.arn, name: "arn", parent: name, min: 0)
            try self.validate(self.arn, name: "arn", parent: name, pattern: "^arn:aws(-cn|-us-gov)?:[a-z0-9-]*:[a-z0-9-]*:([0-9]{12})?:.+$")
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 128)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 0)
        }

        private enum CodingKeys: String, CodingKey {
            case actions
            case arn
            case clientToken
        }
    }

    public struct UpdateReplicationSetOutput: AWSDecodableShape {
        public init() {}
    }

    public struct UpdateResponsePlanInput: AWSEncodableShape {
        /// The actions that this response plan takes at the beginning of an incident.
        public let actions: [Action]?
        /// The Amazon Resource Name (ARN) of the response plan.
        public let arn: String
        /// The AWS Chatbot chat channel used for collaboration during an incident.
        public let chatChannel: ChatChannel?
        /// A token ensuring that the action is called only once with the specified details.
        public let clientToken: String?
        /// The long format name of the response plan. Can't contain spaces.
        public let displayName: String?
        /// The contacts and escalation plans that Incident Manager engages at the start of the incident.
        public let engagements: [String]?
        /// Used to create only one incident record for an incident.
        public let incidentTemplateDedupeString: String?
        /// Defines the impact to the customers. Providing an impact overwrites the impact provided by a response plan.  Possible impacts:     5 - Severe impact    4 - High impact    3 - Medium impact    2 - Low impact    1 - No impact
        public let incidentTemplateImpact: Int?
        /// The SNS targets that AWS Chatbot uses to notify the chat channels and perform actions on the incident record.
        public let incidentTemplateNotificationTargets: [NotificationTargetItem]?
        /// A brief summary of the incident. This typically contains what has happened, what's currently happening, and next steps.
        public let incidentTemplateSummary: String?
        /// The short format name of the incident. Can't contain spaces.
        public let incidentTemplateTitle: String?

        public init(actions: [Action]? = nil, arn: String, chatChannel: ChatChannel? = nil, clientToken: String? = UpdateResponsePlanInput.idempotencyToken(), displayName: String? = nil, engagements: [String]? = nil, incidentTemplateDedupeString: String? = nil, incidentTemplateImpact: Int? = nil, incidentTemplateNotificationTargets: [NotificationTargetItem]? = nil, incidentTemplateSummary: String? = nil, incidentTemplateTitle: String? = nil) {
            self.actions = actions
            self.arn = arn
            self.chatChannel = chatChannel
            self.clientToken = clientToken
            self.displayName = displayName
            self.engagements = engagements
            self.incidentTemplateDedupeString = incidentTemplateDedupeString
            self.incidentTemplateImpact = incidentTemplateImpact
            self.incidentTemplateNotificationTargets = incidentTemplateNotificationTargets
            self.incidentTemplateSummary = incidentTemplateSummary
            self.incidentTemplateTitle = incidentTemplateTitle
        }

        public func validate(name: String) throws {
            try self.actions?.forEach {
                try $0.validate(name: "\(name).actions[]")
            }
            try self.validate(self.actions, name: "actions", parent: name, max: 1)
            try self.validate(self.actions, name: "actions", parent: name, min: 0)
            try self.validate(self.arn, name: "arn", parent: name, max: 1000)
            try self.validate(self.arn, name: "arn", parent: name, min: 0)
            try self.validate(self.arn, name: "arn", parent: name, pattern: "^arn:aws(-cn|-us-gov)?:[a-z0-9-]*:[a-z0-9-]*:([0-9]{12})?:.+$")
            try self.chatChannel?.validate(name: "\(name).chatChannel")
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 128)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 0)
            try self.validate(self.displayName, name: "displayName", parent: name, max: 200)
            try self.validate(self.displayName, name: "displayName", parent: name, min: 0)
            try self.engagements?.forEach {
                try validate($0, name: "engagements[]", parent: name, max: 2048)
                try validate($0, name: "engagements[]", parent: name, min: 0)
                try validate($0, name: "engagements[]", parent: name, pattern: "^arn:[-\\w+=/,.@]+:ssm-contacts:[-\\w+=/,.@]*:[0-9]+:([\\w+=/,.@:-]+)*$")
            }
            try self.validate(self.engagements, name: "engagements", parent: name, max: 5)
            try self.validate(self.engagements, name: "engagements", parent: name, min: 0)
            try self.validate(self.incidentTemplateDedupeString, name: "incidentTemplateDedupeString", parent: name, max: 1000)
            try self.validate(self.incidentTemplateDedupeString, name: "incidentTemplateDedupeString", parent: name, min: 0)
            try self.validate(self.incidentTemplateImpact, name: "incidentTemplateImpact", parent: name, max: 5)
            try self.validate(self.incidentTemplateImpact, name: "incidentTemplateImpact", parent: name, min: 1)
            try self.incidentTemplateNotificationTargets?.forEach {
                try $0.validate(name: "\(name).incidentTemplateNotificationTargets[]")
            }
            try self.validate(self.incidentTemplateNotificationTargets, name: "incidentTemplateNotificationTargets", parent: name, max: 10)
            try self.validate(self.incidentTemplateNotificationTargets, name: "incidentTemplateNotificationTargets", parent: name, min: 0)
            try self.validate(self.incidentTemplateSummary, name: "incidentTemplateSummary", parent: name, max: 4000)
            try self.validate(self.incidentTemplateSummary, name: "incidentTemplateSummary", parent: name, min: 0)
            try self.validate(self.incidentTemplateTitle, name: "incidentTemplateTitle", parent: name, max: 200)
            try self.validate(self.incidentTemplateTitle, name: "incidentTemplateTitle", parent: name, min: 0)
        }

        private enum CodingKeys: String, CodingKey {
            case actions
            case arn
            case chatChannel
            case clientToken
            case displayName
            case engagements
            case incidentTemplateDedupeString
            case incidentTemplateImpact
            case incidentTemplateNotificationTargets
            case incidentTemplateSummary
            case incidentTemplateTitle
        }
    }

    public struct UpdateResponsePlanOutput: AWSDecodableShape {
        public init() {}
    }

    public struct UpdateTimelineEventInput: AWSEncodableShape {
        /// A token ensuring that the action is called only once with the specified details.
        public let clientToken: String
        /// A short description of the event.
        public let eventData: String?
        /// The ID of the event you are updating. You can find this by using ListTimelineEvents.
        public let eventId: String
        /// The time that the event occurred.
        public let eventTime: Date?
        /// The type of the event. You can update events of type Custom Event.
        public let eventType: String?
        /// The Amazon Resource Name (ARN) of the incident that the timeline event is part of.
        public let incidentRecordArn: String

        public init(clientToken: String = UpdateTimelineEventInput.idempotencyToken(), eventData: String? = nil, eventId: String, eventTime: Date? = nil, eventType: String? = nil, incidentRecordArn: String) {
            self.clientToken = clientToken
            self.eventData = eventData
            self.eventId = eventId
            self.eventTime = eventTime
            self.eventType = eventType
            self.incidentRecordArn = incidentRecordArn
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 128)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 0)
            try self.validate(self.eventData, name: "eventData", parent: name, max: 6000)
            try self.validate(self.eventData, name: "eventData", parent: name, min: 0)
            try self.validate(self.eventId, name: "eventId", parent: name, max: 50)
            try self.validate(self.eventId, name: "eventId", parent: name, min: 0)
            try self.validate(self.eventType, name: "eventType", parent: name, max: 100)
            try self.validate(self.eventType, name: "eventType", parent: name, min: 0)
            try self.validate(self.incidentRecordArn, name: "incidentRecordArn", parent: name, max: 1000)
            try self.validate(self.incidentRecordArn, name: "incidentRecordArn", parent: name, min: 0)
            try self.validate(self.incidentRecordArn, name: "incidentRecordArn", parent: name, pattern: "^arn:aws(-cn|-us-gov)?:[a-z0-9-]*:[a-z0-9-]*:([0-9]{12})?:.+$")
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken
            case eventData
            case eventId
            case eventTime
            case eventType
            case incidentRecordArn
        }
    }

    public struct UpdateTimelineEventOutput: AWSDecodableShape {
        public init() {}
    }
}
