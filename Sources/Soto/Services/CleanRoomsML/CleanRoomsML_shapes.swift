//===----------------------------------------------------------------------===//
//
// This source file is part of the Soto for AWS open source project
//
// Copyright (c) 2017-2023 the Soto project authors
// Licensed under Apache License v2.0
//
// See LICENSE.txt for license information
// See CONTRIBUTORS.txt for the list of Soto project authors
//
// SPDX-License-Identifier: Apache-2.0
//
//===----------------------------------------------------------------------===//

// THIS FILE IS AUTOMATICALLY GENERATED by https://github.com/soto-project/soto-codegenerator.
// DO NOT EDIT.

#if os(Linux) && compiler(<5.10)
// swift-corelibs-foundation hasn't been updated with Sendable conformances
@preconcurrency import Foundation
#else
import Foundation
#endif
@_spi(SotoInternal) import SotoCore

extension CleanRoomsML {
    // MARK: Enums

    public enum AudienceExportJobStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case active = "ACTIVE"
        case createFailed = "CREATE_FAILED"
        case createInProgress = "CREATE_IN_PROGRESS"
        case createPending = "CREATE_PENDING"
        public var description: String { return self.rawValue }
    }

    public enum AudienceGenerationJobStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case active = "ACTIVE"
        case createFailed = "CREATE_FAILED"
        case createInProgress = "CREATE_IN_PROGRESS"
        case createPending = "CREATE_PENDING"
        case deleteFailed = "DELETE_FAILED"
        case deleteInProgress = "DELETE_IN_PROGRESS"
        case deletePending = "DELETE_PENDING"
        public var description: String { return self.rawValue }
    }

    public enum AudienceModelStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case active = "ACTIVE"
        case createFailed = "CREATE_FAILED"
        case createInProgress = "CREATE_IN_PROGRESS"
        case createPending = "CREATE_PENDING"
        case deleteFailed = "DELETE_FAILED"
        case deleteInProgress = "DELETE_IN_PROGRESS"
        case deletePending = "DELETE_PENDING"
        public var description: String { return self.rawValue }
    }

    public enum AudienceSizeType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case absolute = "ABSOLUTE"
        case percentage = "PERCENTAGE"
        public var description: String { return self.rawValue }
    }

    public enum ColumnType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case categoricalFeature = "CATEGORICAL_FEATURE"
        case itemId = "ITEM_ID"
        case numericalFeature = "NUMERICAL_FEATURE"
        case timestamp = "TIMESTAMP"
        case userId = "USER_ID"
        public var description: String { return self.rawValue }
    }

    public enum ConfiguredAudienceModelStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case active = "ACTIVE"
        public var description: String { return self.rawValue }
    }

    public enum DatasetType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case interactions = "INTERACTIONS"
        public var description: String { return self.rawValue }
    }

    public enum PolicyExistenceCondition: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case policyMustExist = "POLICY_MUST_EXIST"
        case policyMustNotExist = "POLICY_MUST_NOT_EXIST"
        public var description: String { return self.rawValue }
    }

    public enum SharedAudienceMetrics: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case all = "ALL"
        case none = "NONE"
        public var description: String { return self.rawValue }
    }

    public enum TagOnCreatePolicy: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case fromParentResource = "FROM_PARENT_RESOURCE"
        case none = "NONE"
        public var description: String { return self.rawValue }
    }

    public enum TrainingDatasetStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case active = "ACTIVE"
        public var description: String { return self.rawValue }
    }

    // MARK: Shapes

    public struct AudienceDestination: AWSEncodableShape & AWSDecodableShape {
        /// The Amazon S3 bucket and path for the configured audience.
        public let s3Destination: S3ConfigMap

        public init(s3Destination: S3ConfigMap) {
            self.s3Destination = s3Destination
        }

        public func validate(name: String) throws {
            try self.s3Destination.validate(name: "\(name).s3Destination")
        }

        private enum CodingKeys: String, CodingKey {
            case s3Destination = "s3Destination"
        }
    }

    public struct AudienceExportJobSummary: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the audience generation job that was exported.
        public let audienceGenerationJobArn: String
        public let audienceSize: AudienceSize
        /// The time at which the audience export job was created.
        public let createTime: Date
        /// The description of the audience export job.
        public let description: String?
        /// The name of the audience export job.
        public let name: String
        /// The Amazon S3 bucket where the audience export is stored.
        public let outputLocation: String?
        /// The status of the audience export job.
        public let status: AudienceExportJobStatus
        public let statusDetails: StatusDetails?
        /// The most recent time at which the audience export job was updated.
        public let updateTime: Date

        public init(audienceGenerationJobArn: String, audienceSize: AudienceSize, createTime: Date, description: String? = nil, name: String, outputLocation: String? = nil, status: AudienceExportJobStatus, statusDetails: StatusDetails? = nil, updateTime: Date) {
            self.audienceGenerationJobArn = audienceGenerationJobArn
            self.audienceSize = audienceSize
            self.createTime = createTime
            self.description = description
            self.name = name
            self.outputLocation = outputLocation
            self.status = status
            self.statusDetails = statusDetails
            self.updateTime = updateTime
        }

        private enum CodingKeys: String, CodingKey {
            case audienceGenerationJobArn = "audienceGenerationJobArn"
            case audienceSize = "audienceSize"
            case createTime = "createTime"
            case description = "description"
            case name = "name"
            case outputLocation = "outputLocation"
            case status = "status"
            case statusDetails = "statusDetails"
            case updateTime = "updateTime"
        }
    }

    public struct AudienceGenerationJobDataSource: AWSEncodableShape & AWSDecodableShape {
        /// Defines the Amazon S3 bucket where the seed audience for the generating audience is stored. A valid data source is a JSON line file in the following format:  {"user_id": "111111"}   {"user_id": "222222"}   ...
        public let dataSource: S3ConfigMap
        /// The ARN of the IAM role that can read the Amazon S3 bucket where the training data is stored.
        public let roleArn: String

        public init(dataSource: S3ConfigMap, roleArn: String) {
            self.dataSource = dataSource
            self.roleArn = roleArn
        }

        public func validate(name: String) throws {
            try self.dataSource.validate(name: "\(name).dataSource")
            try self.validate(self.roleArn, name: "roleArn", parent: name, max: 2048)
            try self.validate(self.roleArn, name: "roleArn", parent: name, min: 20)
            try self.validate(self.roleArn, name: "roleArn", parent: name, pattern: "^arn:aws[-a-z]*:iam::[0-9]{12}:role/.+$")
        }

        private enum CodingKeys: String, CodingKey {
            case dataSource = "dataSource"
            case roleArn = "roleArn"
        }
    }

    public struct AudienceGenerationJobSummary: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the audience generation job.
        public let audienceGenerationJobArn: String
        /// The identifier of the collaboration that contains this audience generation job.
        public let collaborationId: String?
        /// The Amazon Resource Name (ARN) of the configured audience model that was used for this audience generation job.
        public let configuredAudienceModelArn: String
        /// The time at which the audience generation job was created.
        public let createTime: Date
        /// The description of the audience generation job.
        public let description: String?
        /// The name of the audience generation job.
        public let name: String
        /// The AWS Account that submitted the job.
        public let startedBy: String?
        /// The status of the audience generation job.
        public let status: AudienceGenerationJobStatus
        /// The most recent time at which the audience generation job was updated.
        public let updateTime: Date

        public init(audienceGenerationJobArn: String, collaborationId: String? = nil, configuredAudienceModelArn: String, createTime: Date, description: String? = nil, name: String, startedBy: String? = nil, status: AudienceGenerationJobStatus, updateTime: Date) {
            self.audienceGenerationJobArn = audienceGenerationJobArn
            self.collaborationId = collaborationId
            self.configuredAudienceModelArn = configuredAudienceModelArn
            self.createTime = createTime
            self.description = description
            self.name = name
            self.startedBy = startedBy
            self.status = status
            self.updateTime = updateTime
        }

        private enum CodingKeys: String, CodingKey {
            case audienceGenerationJobArn = "audienceGenerationJobArn"
            case collaborationId = "collaborationId"
            case configuredAudienceModelArn = "configuredAudienceModelArn"
            case createTime = "createTime"
            case description = "description"
            case name = "name"
            case startedBy = "startedBy"
            case status = "status"
            case updateTime = "updateTime"
        }
    }

    public struct AudienceModelSummary: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the audience model.
        public let audienceModelArn: String
        /// The time at which the audience model was created.
        public let createTime: Date
        /// The description of the audience model.
        public let description: String?
        /// The name of the audience model.
        public let name: String
        /// The status of the audience model.
        public let status: AudienceModelStatus
        /// The Amazon Resource Name (ARN) of the training dataset that was used for the audience model.
        public let trainingDatasetArn: String
        /// The most recent time at which the audience model was updated.
        public let updateTime: Date

        public init(audienceModelArn: String, createTime: Date, description: String? = nil, name: String, status: AudienceModelStatus, trainingDatasetArn: String, updateTime: Date) {
            self.audienceModelArn = audienceModelArn
            self.createTime = createTime
            self.description = description
            self.name = name
            self.status = status
            self.trainingDatasetArn = trainingDatasetArn
            self.updateTime = updateTime
        }

        private enum CodingKeys: String, CodingKey {
            case audienceModelArn = "audienceModelArn"
            case createTime = "createTime"
            case description = "description"
            case name = "name"
            case status = "status"
            case trainingDatasetArn = "trainingDatasetArn"
            case updateTime = "updateTime"
        }
    }

    public struct AudienceQualityMetrics: AWSDecodableShape {
        /// The recall score of the generated audience. Recall is the percentage of the most similar users (by default, the most similar 20%) from a sample of the training data that are included in the seed audience by the audience generation job. Values range from 0-1, larger values indicate a better audience. A recall value approximately equal to the maximum bin size indicates that the audience model is equivalent to random selection.
        public let recallMetric: Double?
        /// The relevance scores of the generated audience.
        public let relevanceMetrics: [RelevanceMetric]

        public init(recallMetric: Double? = nil, relevanceMetrics: [RelevanceMetric]) {
            self.recallMetric = recallMetric
            self.relevanceMetrics = relevanceMetrics
        }

        private enum CodingKeys: String, CodingKey {
            case recallMetric = "recallMetric"
            case relevanceMetrics = "relevanceMetrics"
        }
    }

    public struct AudienceSize: AWSEncodableShape & AWSDecodableShape {
        /// Whether the audience size is defined in absolute terms or as a percentage. You can use the ABSOLUTE AudienceSize to configure out audience sizes using the count of identifiers in the output. You can use the Percentage AudienceSize to configure sizes in the range 1-100 percent.
        public let type: AudienceSizeType
        /// Specify an audience size value.
        public let value: Int

        public init(type: AudienceSizeType, value: Int) {
            self.type = type
            self.value = value
        }

        public func validate(name: String) throws {
            try self.validate(self.value, name: "value", parent: name, max: 20000000)
            try self.validate(self.value, name: "value", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case type = "type"
            case value = "value"
        }
    }

    public struct AudienceSizeConfig: AWSEncodableShape & AWSDecodableShape {
        /// An array of the different audience output sizes.
        public let audienceSizeBins: [Int]
        /// Whether the audience output sizes are defined as an absolute number or a percentage.
        public let audienceSizeType: AudienceSizeType

        public init(audienceSizeBins: [Int], audienceSizeType: AudienceSizeType) {
            self.audienceSizeBins = audienceSizeBins
            self.audienceSizeType = audienceSizeType
        }

        public func validate(name: String) throws {
            try self.audienceSizeBins.forEach {
                try validate($0, name: "audienceSizeBins[]", parent: name, max: 20000000)
                try validate($0, name: "audienceSizeBins[]", parent: name, min: 1)
            }
            try self.validate(self.audienceSizeBins, name: "audienceSizeBins", parent: name, max: 25)
            try self.validate(self.audienceSizeBins, name: "audienceSizeBins", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case audienceSizeBins = "audienceSizeBins"
            case audienceSizeType = "audienceSizeType"
        }
    }

    public struct ColumnSchema: AWSEncodableShape & AWSDecodableShape {
        /// The name of a column.
        public let columnName: String
        /// The data type of column.
        public let columnTypes: [ColumnType]

        public init(columnName: String, columnTypes: [ColumnType]) {
            self.columnName = columnName
            self.columnTypes = columnTypes
        }

        public func validate(name: String) throws {
            try self.validate(self.columnName, name: "columnName", parent: name, max: 128)
            try self.validate(self.columnName, name: "columnName", parent: name, min: 1)
            try self.validate(self.columnName, name: "columnName", parent: name, pattern: "^[a-zA-Z0-9_](([a-zA-Z0-9_ ]+-)*([a-zA-Z0-9_ ]+))?$")
            try self.validate(self.columnTypes, name: "columnTypes", parent: name, max: 1)
            try self.validate(self.columnTypes, name: "columnTypes", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case columnName = "columnName"
            case columnTypes = "columnTypes"
        }
    }

    public struct ConfiguredAudienceModelOutputConfig: AWSEncodableShape & AWSDecodableShape {
        public let destination: AudienceDestination
        /// The ARN of the IAM role that can write the Amazon S3 bucket.
        public let roleArn: String

        public init(destination: AudienceDestination, roleArn: String) {
            self.destination = destination
            self.roleArn = roleArn
        }

        public func validate(name: String) throws {
            try self.destination.validate(name: "\(name).destination")
            try self.validate(self.roleArn, name: "roleArn", parent: name, max: 2048)
            try self.validate(self.roleArn, name: "roleArn", parent: name, min: 20)
            try self.validate(self.roleArn, name: "roleArn", parent: name, pattern: "^arn:aws[-a-z]*:iam::[0-9]{12}:role/.+$")
        }

        private enum CodingKeys: String, CodingKey {
            case destination = "destination"
            case roleArn = "roleArn"
        }
    }

    public struct ConfiguredAudienceModelSummary: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the audience model that was used to create the configured audience model.
        public let audienceModelArn: String
        /// The Amazon Resource Name (ARN) of the configured audience model that you are interested in.
        public let configuredAudienceModelArn: String
        /// The time at which the configured audience model was created.
        public let createTime: Date
        /// The description of the configured audience model.
        public let description: String?
        /// The name of the configured audience model.
        public let name: String
        /// The output configuration of the configured audience model.
        public let outputConfig: ConfiguredAudienceModelOutputConfig
        /// The status of the configured audience model.
        public let status: ConfiguredAudienceModelStatus
        /// The most recent time at which the configured audience model was updated.
        public let updateTime: Date

        public init(audienceModelArn: String, configuredAudienceModelArn: String, createTime: Date, description: String? = nil, name: String, outputConfig: ConfiguredAudienceModelOutputConfig, status: ConfiguredAudienceModelStatus, updateTime: Date) {
            self.audienceModelArn = audienceModelArn
            self.configuredAudienceModelArn = configuredAudienceModelArn
            self.createTime = createTime
            self.description = description
            self.name = name
            self.outputConfig = outputConfig
            self.status = status
            self.updateTime = updateTime
        }

        private enum CodingKeys: String, CodingKey {
            case audienceModelArn = "audienceModelArn"
            case configuredAudienceModelArn = "configuredAudienceModelArn"
            case createTime = "createTime"
            case description = "description"
            case name = "name"
            case outputConfig = "outputConfig"
            case status = "status"
            case updateTime = "updateTime"
        }
    }

    public struct CreateAudienceModelRequest: AWSEncodableShape {
        /// The description of the audience model.
        public let description: String?
        /// The Amazon Resource Name (ARN) of the KMS key. This key is used to encrypt and decrypt customer-owned data in the trained ML model and the associated data.
        public let kmsKeyArn: String?
        /// The name of the audience model resource.
        public let name: String
        /// The optional metadata that you apply to the resource to help you categorize and organize them. Each tag consists of a key and an optional value, both of which you define. The following basic restrictions apply to tags:   Maximum number of tags per resource - 50.   For each resource, each tag key must be unique, and each tag key can have only one value.   Maximum key length - 128 Unicode characters in UTF-8.   Maximum value length - 256 Unicode characters in UTF-8.   If your tagging schema is used across multiple services and resources, remember that other services may have restrictions on allowed characters. Generally allowed characters are: letters, numbers, and spaces representable in UTF-8, and the following characters: + - = . _ : / @.   Tag keys and values are case sensitive.   Do not use aws:, AWS:, or any upper or lowercase combination of such as a prefix for keys as it is reserved for AWS use. You cannot edit or delete tag keys with this prefix. Values can have this prefix. If a tag value has aws as its prefix but the key does not, then Clean Rooms ML considers it to be a user tag and will count against the limit of 50 tags. Tags with only the key prefix of aws do not count against your tags per resource limit.
        public let tags: [String: String]?
        /// The end date and time of the training window.
        public let trainingDataEndTime: Date?
        /// The Amazon Resource Name (ARN) of the training dataset for this audience model.
        public let trainingDatasetArn: String
        /// The start date and time of the training window.
        public let trainingDataStartTime: Date?

        public init(description: String? = nil, kmsKeyArn: String? = nil, name: String, tags: [String: String]? = nil, trainingDataEndTime: Date? = nil, trainingDatasetArn: String, trainingDataStartTime: Date? = nil) {
            self.description = description
            self.kmsKeyArn = kmsKeyArn
            self.name = name
            self.tags = tags
            self.trainingDataEndTime = trainingDataEndTime
            self.trainingDatasetArn = trainingDatasetArn
            self.trainingDataStartTime = trainingDataStartTime
        }

        public func validate(name: String) throws {
            try self.validate(self.description, name: "description", parent: name, max: 255)
            try self.validate(self.description, name: "description", parent: name, pattern: "^[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDBFF-\\uDC00\\uDFFF\\t\\r\\n]*$")
            try self.validate(self.kmsKeyArn, name: "kmsKeyArn", parent: name, max: 2048)
            try self.validate(self.kmsKeyArn, name: "kmsKeyArn", parent: name, min: 20)
            try self.validate(self.kmsKeyArn, name: "kmsKeyArn", parent: name, pattern: "^arn:aws[-a-z]*:kms:[-a-z0-9]+:[0-9]{12}:key/.+$")
            try self.validate(self.name, name: "name", parent: name, max: 63)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^(?!\\s*$)[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDBFF-\\uDC00\\uDFFF\\t]*$")
            try self.tags?.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 200)
            try self.validate(self.trainingDatasetArn, name: "trainingDatasetArn", parent: name, max: 2048)
            try self.validate(self.trainingDatasetArn, name: "trainingDatasetArn", parent: name, min: 20)
            try self.validate(self.trainingDatasetArn, name: "trainingDatasetArn", parent: name, pattern: "^arn:aws[-a-z]*:cleanrooms-ml:[-a-z0-9]+:[0-9]{12}:training-dataset/[-a-zA-Z0-9_/.]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case description = "description"
            case kmsKeyArn = "kmsKeyArn"
            case name = "name"
            case tags = "tags"
            case trainingDataEndTime = "trainingDataEndTime"
            case trainingDatasetArn = "trainingDatasetArn"
            case trainingDataStartTime = "trainingDataStartTime"
        }
    }

    public struct CreateAudienceModelResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the audience model.
        public let audienceModelArn: String

        public init(audienceModelArn: String) {
            self.audienceModelArn = audienceModelArn
        }

        private enum CodingKeys: String, CodingKey {
            case audienceModelArn = "audienceModelArn"
        }
    }

    public struct CreateConfiguredAudienceModelRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the audience model to use for the configured audience model.
        public let audienceModelArn: String
        /// Configure the list of output sizes of audiences that can be created using this configured audience model. A request to StartAudienceGenerationJob that uses this configured audience model must have an audienceSize selected from this list. You can use the ABSOLUTE AudienceSize to configure out audience sizes using the count of identifiers in the output. You can use the Percentage AudienceSize to configure sizes in the range 1-100 percent.
        public let audienceSizeConfig: AudienceSizeConfig?
        /// Configure how the service tags audience generation jobs created using this configured audience model. If you specify NONE, the tags from the StartAudienceGenerationJob request determine the tags of the audience generation job. If you specify FROM_PARENT_RESOURCE, the audience generation job inherits the tags from the configured audience model, by default. Tags in the StartAudienceGenerationJob will override the default. When the client is in a different account than the configured audience model, the tags from the client are never applied to a resource in the caller's account.
        public let childResourceTagOnCreatePolicy: TagOnCreatePolicy?
        /// The description of the configured audience model.
        public let description: String?
        /// The minimum number of users from the seed audience that must match with users in the training data of the audience model. The default value is 500.
        public let minMatchingSeedSize: Int?
        /// The name of the configured audience model.
        public let name: String
        /// Configure the Amazon S3 location and IAM Role for audiences created using this configured audience model. Each audience will have a unique location. The IAM Role must have s3:PutObject permission on the destination Amazon S3 location. If the destination is protected with Amazon S3 KMS-SSE, then the Role must also have the required KMS permissions.
        public let outputConfig: ConfiguredAudienceModelOutputConfig
        /// Whether audience metrics are shared.
        public let sharedAudienceMetrics: [SharedAudienceMetrics]
        /// The optional metadata that you apply to the resource to help you categorize and organize them. Each tag consists of a key and an optional value, both of which you define. The following basic restrictions apply to tags:   Maximum number of tags per resource - 50.   For each resource, each tag key must be unique, and each tag key can have only one value.   Maximum key length - 128 Unicode characters in UTF-8.   Maximum value length - 256 Unicode characters in UTF-8.   If your tagging schema is used across multiple services and resources, remember that other services may have restrictions on allowed characters. Generally allowed characters are: letters, numbers, and spaces representable in UTF-8, and the following characters: + - = . _ : / @.   Tag keys and values are case sensitive.   Do not use aws:, AWS:, or any upper or lowercase combination of such as a prefix for keys as it is reserved for AWS use. You cannot edit or delete tag keys with this prefix. Values can have this prefix. If a tag value has aws as its prefix but the key does not, then Clean Rooms ML considers it to be a user tag and will count against the limit of 50 tags. Tags with only the key prefix of aws do not count against your tags per resource limit.
        public let tags: [String: String]?

        public init(audienceModelArn: String, audienceSizeConfig: AudienceSizeConfig? = nil, childResourceTagOnCreatePolicy: TagOnCreatePolicy? = nil, description: String? = nil, minMatchingSeedSize: Int? = nil, name: String, outputConfig: ConfiguredAudienceModelOutputConfig, sharedAudienceMetrics: [SharedAudienceMetrics], tags: [String: String]? = nil) {
            self.audienceModelArn = audienceModelArn
            self.audienceSizeConfig = audienceSizeConfig
            self.childResourceTagOnCreatePolicy = childResourceTagOnCreatePolicy
            self.description = description
            self.minMatchingSeedSize = minMatchingSeedSize
            self.name = name
            self.outputConfig = outputConfig
            self.sharedAudienceMetrics = sharedAudienceMetrics
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.validate(self.audienceModelArn, name: "audienceModelArn", parent: name, max: 2048)
            try self.validate(self.audienceModelArn, name: "audienceModelArn", parent: name, min: 20)
            try self.validate(self.audienceModelArn, name: "audienceModelArn", parent: name, pattern: "^arn:aws[-a-z]*:cleanrooms-ml:[-a-z0-9]+:[0-9]{12}:audience-model/[-a-zA-Z0-9_/.]+$")
            try self.audienceSizeConfig?.validate(name: "\(name).audienceSizeConfig")
            try self.validate(self.description, name: "description", parent: name, max: 255)
            try self.validate(self.description, name: "description", parent: name, pattern: "^[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDBFF-\\uDC00\\uDFFF\\t\\r\\n]*$")
            try self.validate(self.minMatchingSeedSize, name: "minMatchingSeedSize", parent: name, max: 500000)
            try self.validate(self.minMatchingSeedSize, name: "minMatchingSeedSize", parent: name, min: 25)
            try self.validate(self.name, name: "name", parent: name, max: 63)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^(?!\\s*$)[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDBFF-\\uDC00\\uDFFF\\t]*$")
            try self.outputConfig.validate(name: "\(name).outputConfig")
            try self.validate(self.sharedAudienceMetrics, name: "sharedAudienceMetrics", parent: name, max: 1)
            try self.validate(self.sharedAudienceMetrics, name: "sharedAudienceMetrics", parent: name, min: 1)
            try self.tags?.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 200)
        }

        private enum CodingKeys: String, CodingKey {
            case audienceModelArn = "audienceModelArn"
            case audienceSizeConfig = "audienceSizeConfig"
            case childResourceTagOnCreatePolicy = "childResourceTagOnCreatePolicy"
            case description = "description"
            case minMatchingSeedSize = "minMatchingSeedSize"
            case name = "name"
            case outputConfig = "outputConfig"
            case sharedAudienceMetrics = "sharedAudienceMetrics"
            case tags = "tags"
        }
    }

    public struct CreateConfiguredAudienceModelResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the configured audience model.
        public let configuredAudienceModelArn: String

        public init(configuredAudienceModelArn: String) {
            self.configuredAudienceModelArn = configuredAudienceModelArn
        }

        private enum CodingKeys: String, CodingKey {
            case configuredAudienceModelArn = "configuredAudienceModelArn"
        }
    }

    public struct CreateTrainingDatasetRequest: AWSEncodableShape {
        /// The description of the training dataset.
        public let description: String?
        /// The name of the training dataset. This name must be unique in your account and region.
        public let name: String
        /// The ARN of the IAM role that Clean Rooms ML can assume to read the data referred to in the dataSource field of each dataset. Passing a role across AWS accounts is not allowed. If you pass a role that isn't in your account, you get an AccessDeniedException error.
        public let roleArn: String
        /// The optional metadata that you apply to the resource to help you categorize and organize them. Each tag consists of a key and an optional value, both of which you define. The following basic restrictions apply to tags:   Maximum number of tags per resource - 50.   For each resource, each tag key must be unique, and each tag key can have only one value.   Maximum key length - 128 Unicode characters in UTF-8.   Maximum value length - 256 Unicode characters in UTF-8.   If your tagging schema is used across multiple services and resources, remember that other services may have restrictions on allowed characters. Generally allowed characters are: letters, numbers, and spaces representable in UTF-8, and the following characters: + - = . _ : / @.   Tag keys and values are case sensitive.   Do not use aws:, AWS:, or any upper or lowercase combination of such as a prefix for keys as it is reserved for AWS use. You cannot edit or delete tag keys with this prefix. Values can have this prefix. If a tag value has aws as its prefix but the key does not, then Clean Rooms ML considers it to be a user tag and will count against the limit of 50 tags. Tags with only the key prefix of aws do not count against your tags per resource limit.
        public let tags: [String: String]?
        /// An array of information that lists the Dataset objects, which specifies the dataset type and details on its location and schema. You must provide a role that has read access to these tables.
        public let trainingData: [Dataset]

        public init(description: String? = nil, name: String, roleArn: String, tags: [String: String]? = nil, trainingData: [Dataset]) {
            self.description = description
            self.name = name
            self.roleArn = roleArn
            self.tags = tags
            self.trainingData = trainingData
        }

        public func validate(name: String) throws {
            try self.validate(self.description, name: "description", parent: name, max: 255)
            try self.validate(self.description, name: "description", parent: name, pattern: "^[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDBFF-\\uDC00\\uDFFF\\t\\r\\n]*$")
            try self.validate(self.name, name: "name", parent: name, max: 63)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^(?!\\s*$)[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDBFF-\\uDC00\\uDFFF\\t]*$")
            try self.validate(self.roleArn, name: "roleArn", parent: name, max: 2048)
            try self.validate(self.roleArn, name: "roleArn", parent: name, min: 20)
            try self.validate(self.roleArn, name: "roleArn", parent: name, pattern: "^arn:aws[-a-z]*:iam::[0-9]{12}:role/.+$")
            try self.tags?.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 200)
            try self.trainingData.forEach {
                try $0.validate(name: "\(name).trainingData[]")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case description = "description"
            case name = "name"
            case roleArn = "roleArn"
            case tags = "tags"
            case trainingData = "trainingData"
        }
    }

    public struct CreateTrainingDatasetResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the training dataset resource.
        public let trainingDatasetArn: String

        public init(trainingDatasetArn: String) {
            self.trainingDatasetArn = trainingDatasetArn
        }

        private enum CodingKeys: String, CodingKey {
            case trainingDatasetArn = "trainingDatasetArn"
        }
    }

    public struct DataSource: AWSEncodableShape & AWSDecodableShape {
        /// A GlueDataSource object that defines the catalog ID, database name, and table name for the training data.
        public let glueDataSource: GlueDataSource

        public init(glueDataSource: GlueDataSource) {
            self.glueDataSource = glueDataSource
        }

        public func validate(name: String) throws {
            try self.glueDataSource.validate(name: "\(name).glueDataSource")
        }

        private enum CodingKeys: String, CodingKey {
            case glueDataSource = "glueDataSource"
        }
    }

    public struct Dataset: AWSEncodableShape & AWSDecodableShape {
        /// A DatasetInputConfig object that defines the data source and schema mapping.
        public let inputConfig: DatasetInputConfig
        /// What type of information is found in the dataset.
        public let type: DatasetType

        public init(inputConfig: DatasetInputConfig, type: DatasetType) {
            self.inputConfig = inputConfig
            self.type = type
        }

        public func validate(name: String) throws {
            try self.inputConfig.validate(name: "\(name).inputConfig")
        }

        private enum CodingKeys: String, CodingKey {
            case inputConfig = "inputConfig"
            case type = "type"
        }
    }

    public struct DatasetInputConfig: AWSEncodableShape & AWSDecodableShape {
        /// A DataSource object that specifies the Glue data source for the training data.
        public let dataSource: DataSource
        /// The schema information for the training data.
        public let schema: [ColumnSchema]

        public init(dataSource: DataSource, schema: [ColumnSchema]) {
            self.dataSource = dataSource
            self.schema = schema
        }

        public func validate(name: String) throws {
            try self.dataSource.validate(name: "\(name).dataSource")
            try self.schema.forEach {
                try $0.validate(name: "\(name).schema[]")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case dataSource = "dataSource"
            case schema = "schema"
        }
    }

    public struct DeleteAudienceGenerationJobRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the audience generation job that you want to delete.
        public let audienceGenerationJobArn: String

        public init(audienceGenerationJobArn: String) {
            self.audienceGenerationJobArn = audienceGenerationJobArn
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.audienceGenerationJobArn, key: "audienceGenerationJobArn")
        }

        public func validate(name: String) throws {
            try self.validate(self.audienceGenerationJobArn, name: "audienceGenerationJobArn", parent: name, max: 2048)
            try self.validate(self.audienceGenerationJobArn, name: "audienceGenerationJobArn", parent: name, min: 20)
            try self.validate(self.audienceGenerationJobArn, name: "audienceGenerationJobArn", parent: name, pattern: "^arn:aws[-a-z]*:cleanrooms-ml:[-a-z0-9]+:[0-9]{12}:audience-generation-job/[-a-zA-Z0-9_/.]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteAudienceModelRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the audience model that you want to delete.
        public let audienceModelArn: String

        public init(audienceModelArn: String) {
            self.audienceModelArn = audienceModelArn
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.audienceModelArn, key: "audienceModelArn")
        }

        public func validate(name: String) throws {
            try self.validate(self.audienceModelArn, name: "audienceModelArn", parent: name, max: 2048)
            try self.validate(self.audienceModelArn, name: "audienceModelArn", parent: name, min: 20)
            try self.validate(self.audienceModelArn, name: "audienceModelArn", parent: name, pattern: "^arn:aws[-a-z]*:cleanrooms-ml:[-a-z0-9]+:[0-9]{12}:audience-model/[-a-zA-Z0-9_/.]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteConfiguredAudienceModelPolicyRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the configured audience model policy that you want to delete.
        public let configuredAudienceModelArn: String

        public init(configuredAudienceModelArn: String) {
            self.configuredAudienceModelArn = configuredAudienceModelArn
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.configuredAudienceModelArn, key: "configuredAudienceModelArn")
        }

        public func validate(name: String) throws {
            try self.validate(self.configuredAudienceModelArn, name: "configuredAudienceModelArn", parent: name, max: 2048)
            try self.validate(self.configuredAudienceModelArn, name: "configuredAudienceModelArn", parent: name, min: 20)
            try self.validate(self.configuredAudienceModelArn, name: "configuredAudienceModelArn", parent: name, pattern: "^arn:aws[-a-z]*:cleanrooms-ml:[-a-z0-9]+:[0-9]{12}:configured-audience-model/[-a-zA-Z0-9_/.]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteConfiguredAudienceModelRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the configured audience model that you want to delete.
        public let configuredAudienceModelArn: String

        public init(configuredAudienceModelArn: String) {
            self.configuredAudienceModelArn = configuredAudienceModelArn
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.configuredAudienceModelArn, key: "configuredAudienceModelArn")
        }

        public func validate(name: String) throws {
            try self.validate(self.configuredAudienceModelArn, name: "configuredAudienceModelArn", parent: name, max: 2048)
            try self.validate(self.configuredAudienceModelArn, name: "configuredAudienceModelArn", parent: name, min: 20)
            try self.validate(self.configuredAudienceModelArn, name: "configuredAudienceModelArn", parent: name, pattern: "^arn:aws[-a-z]*:cleanrooms-ml:[-a-z0-9]+:[0-9]{12}:configured-audience-model/[-a-zA-Z0-9_/.]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteTrainingDatasetRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the training dataset that you want to delete.
        public let trainingDatasetArn: String

        public init(trainingDatasetArn: String) {
            self.trainingDatasetArn = trainingDatasetArn
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.trainingDatasetArn, key: "trainingDatasetArn")
        }

        public func validate(name: String) throws {
            try self.validate(self.trainingDatasetArn, name: "trainingDatasetArn", parent: name, max: 2048)
            try self.validate(self.trainingDatasetArn, name: "trainingDatasetArn", parent: name, min: 20)
            try self.validate(self.trainingDatasetArn, name: "trainingDatasetArn", parent: name, pattern: "^arn:aws[-a-z]*:cleanrooms-ml:[-a-z0-9]+:[0-9]{12}:training-dataset/[-a-zA-Z0-9_/.]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetAudienceGenerationJobRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the audience generation job that you are interested in.
        public let audienceGenerationJobArn: String

        public init(audienceGenerationJobArn: String) {
            self.audienceGenerationJobArn = audienceGenerationJobArn
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.audienceGenerationJobArn, key: "audienceGenerationJobArn")
        }

        public func validate(name: String) throws {
            try self.validate(self.audienceGenerationJobArn, name: "audienceGenerationJobArn", parent: name, max: 2048)
            try self.validate(self.audienceGenerationJobArn, name: "audienceGenerationJobArn", parent: name, min: 20)
            try self.validate(self.audienceGenerationJobArn, name: "audienceGenerationJobArn", parent: name, pattern: "^arn:aws[-a-z]*:cleanrooms-ml:[-a-z0-9]+:[0-9]{12}:audience-generation-job/[-a-zA-Z0-9_/.]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetAudienceGenerationJobResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the audience generation job.
        public let audienceGenerationJobArn: String
        /// The identifier of the collaboration that this audience generation job is associated with.
        public let collaborationId: String?
        /// The Amazon Resource Name (ARN) of the configured audience model used for this audience generation job.
        public let configuredAudienceModelArn: String
        /// The time at which the audience generation job was created.
        public let createTime: Date
        /// The description of the audience generation job.
        public let description: String?
        /// Configure whether the seed users are included in the output audience. By default, Clean Rooms ML removes seed users from the output audience. If you specify TRUE, the seed users will appear first in the output. Clean Rooms ML does not explicitly reveal whether a user was in the seed, but the recipient of the audience will know that the first minimumSeedSize count of users are from the seed.
        public let includeSeedInOutput: Bool?
        /// The relevance scores for different audience sizes and the recall score of the generated audience.
        public let metrics: AudienceQualityMetrics?
        /// The name of the audience generation job.
        public let name: String
        /// The seed audience that was used for this audience generation job. This field will be null if the account calling the API is the account that started this audience generation job.
        public let seedAudience: AudienceGenerationJobDataSource?
        /// The AWS account that started this audience generation job.
        public let startedBy: String?
        /// The status of the audience generation job.
        public let status: AudienceGenerationJobStatus
        /// Details about the status of the audience generation job.
        public let statusDetails: StatusDetails?
        /// The tags that are associated to this audience generation job.
        public let tags: [String: String]?
        /// The most recent time at which the audience generation job was updated.
        public let updateTime: Date

        public init(audienceGenerationJobArn: String, collaborationId: String? = nil, configuredAudienceModelArn: String, createTime: Date, description: String? = nil, includeSeedInOutput: Bool? = nil, metrics: AudienceQualityMetrics? = nil, name: String, seedAudience: AudienceGenerationJobDataSource? = nil, startedBy: String? = nil, status: AudienceGenerationJobStatus, statusDetails: StatusDetails? = nil, tags: [String: String]? = nil, updateTime: Date) {
            self.audienceGenerationJobArn = audienceGenerationJobArn
            self.collaborationId = collaborationId
            self.configuredAudienceModelArn = configuredAudienceModelArn
            self.createTime = createTime
            self.description = description
            self.includeSeedInOutput = includeSeedInOutput
            self.metrics = metrics
            self.name = name
            self.seedAudience = seedAudience
            self.startedBy = startedBy
            self.status = status
            self.statusDetails = statusDetails
            self.tags = tags
            self.updateTime = updateTime
        }

        private enum CodingKeys: String, CodingKey {
            case audienceGenerationJobArn = "audienceGenerationJobArn"
            case collaborationId = "collaborationId"
            case configuredAudienceModelArn = "configuredAudienceModelArn"
            case createTime = "createTime"
            case description = "description"
            case includeSeedInOutput = "includeSeedInOutput"
            case metrics = "metrics"
            case name = "name"
            case seedAudience = "seedAudience"
            case startedBy = "startedBy"
            case status = "status"
            case statusDetails = "statusDetails"
            case tags = "tags"
            case updateTime = "updateTime"
        }
    }

    public struct GetAudienceModelRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the audience model that you are interested in.
        public let audienceModelArn: String

        public init(audienceModelArn: String) {
            self.audienceModelArn = audienceModelArn
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.audienceModelArn, key: "audienceModelArn")
        }

        public func validate(name: String) throws {
            try self.validate(self.audienceModelArn, name: "audienceModelArn", parent: name, max: 2048)
            try self.validate(self.audienceModelArn, name: "audienceModelArn", parent: name, min: 20)
            try self.validate(self.audienceModelArn, name: "audienceModelArn", parent: name, pattern: "^arn:aws[-a-z]*:cleanrooms-ml:[-a-z0-9]+:[0-9]{12}:audience-model/[-a-zA-Z0-9_/.]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetAudienceModelResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the audience model.
        public let audienceModelArn: String
        /// The time at which the audience model was created.
        public let createTime: Date
        /// The description of the audience model.
        public let description: String?
        /// The KMS key ARN used for the audience model.
        public let kmsKeyArn: String?
        /// The name of the audience model.
        public let name: String
        /// The status of the audience model.
        public let status: AudienceModelStatus
        /// Details about the status of the audience model.
        public let statusDetails: StatusDetails?
        /// The tags that are assigned to the audience model.
        public let tags: [String: String]?
        /// The end date specified for the training window.
        public let trainingDataEndTime: Date?
        /// The Amazon Resource Name (ARN) of the training dataset that was used for this audience model.
        public let trainingDatasetArn: String
        /// The start date specified for the training window.
        public let trainingDataStartTime: Date?
        /// The most recent time at which the audience model was updated.
        public let updateTime: Date

        public init(audienceModelArn: String, createTime: Date, description: String? = nil, kmsKeyArn: String? = nil, name: String, status: AudienceModelStatus, statusDetails: StatusDetails? = nil, tags: [String: String]? = nil, trainingDataEndTime: Date? = nil, trainingDatasetArn: String, trainingDataStartTime: Date? = nil, updateTime: Date) {
            self.audienceModelArn = audienceModelArn
            self.createTime = createTime
            self.description = description
            self.kmsKeyArn = kmsKeyArn
            self.name = name
            self.status = status
            self.statusDetails = statusDetails
            self.tags = tags
            self.trainingDataEndTime = trainingDataEndTime
            self.trainingDatasetArn = trainingDatasetArn
            self.trainingDataStartTime = trainingDataStartTime
            self.updateTime = updateTime
        }

        private enum CodingKeys: String, CodingKey {
            case audienceModelArn = "audienceModelArn"
            case createTime = "createTime"
            case description = "description"
            case kmsKeyArn = "kmsKeyArn"
            case name = "name"
            case status = "status"
            case statusDetails = "statusDetails"
            case tags = "tags"
            case trainingDataEndTime = "trainingDataEndTime"
            case trainingDatasetArn = "trainingDatasetArn"
            case trainingDataStartTime = "trainingDataStartTime"
            case updateTime = "updateTime"
        }
    }

    public struct GetConfiguredAudienceModelPolicyRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the configured audience model that you are interested in.
        public let configuredAudienceModelArn: String

        public init(configuredAudienceModelArn: String) {
            self.configuredAudienceModelArn = configuredAudienceModelArn
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.configuredAudienceModelArn, key: "configuredAudienceModelArn")
        }

        public func validate(name: String) throws {
            try self.validate(self.configuredAudienceModelArn, name: "configuredAudienceModelArn", parent: name, max: 2048)
            try self.validate(self.configuredAudienceModelArn, name: "configuredAudienceModelArn", parent: name, min: 20)
            try self.validate(self.configuredAudienceModelArn, name: "configuredAudienceModelArn", parent: name, pattern: "^arn:aws[-a-z]*:cleanrooms-ml:[-a-z0-9]+:[0-9]{12}:configured-audience-model/[-a-zA-Z0-9_/.]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetConfiguredAudienceModelPolicyResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the configured audience model.
        public let configuredAudienceModelArn: String
        /// The configured audience model policy. This is a JSON IAM resource policy.
        public let configuredAudienceModelPolicy: String
        /// A cryptographic hash of the contents of the policy used to prevent unexpected concurrent modification of the policy.
        public let policyHash: String

        public init(configuredAudienceModelArn: String, configuredAudienceModelPolicy: String, policyHash: String) {
            self.configuredAudienceModelArn = configuredAudienceModelArn
            self.configuredAudienceModelPolicy = configuredAudienceModelPolicy
            self.policyHash = policyHash
        }

        private enum CodingKeys: String, CodingKey {
            case configuredAudienceModelArn = "configuredAudienceModelArn"
            case configuredAudienceModelPolicy = "configuredAudienceModelPolicy"
            case policyHash = "policyHash"
        }
    }

    public struct GetConfiguredAudienceModelRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the configured audience model that you are interested in.
        public let configuredAudienceModelArn: String

        public init(configuredAudienceModelArn: String) {
            self.configuredAudienceModelArn = configuredAudienceModelArn
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.configuredAudienceModelArn, key: "configuredAudienceModelArn")
        }

        public func validate(name: String) throws {
            try self.validate(self.configuredAudienceModelArn, name: "configuredAudienceModelArn", parent: name, max: 2048)
            try self.validate(self.configuredAudienceModelArn, name: "configuredAudienceModelArn", parent: name, min: 20)
            try self.validate(self.configuredAudienceModelArn, name: "configuredAudienceModelArn", parent: name, pattern: "^arn:aws[-a-z]*:cleanrooms-ml:[-a-z0-9]+:[0-9]{12}:configured-audience-model/[-a-zA-Z0-9_/.]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetConfiguredAudienceModelResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the audience model used for this configured audience model.
        public let audienceModelArn: String
        /// The list of output sizes of audiences that can be created using this configured audience model. A request to StartAudienceGenerationJob that uses this configured audience model must have an audienceSize selected from this list. You can use the ABSOLUTE AudienceSize to configure out audience sizes using the count of identifiers in the output. You can use the Percentage AudienceSize to configure sizes in the range 1-100 percent.
        public let audienceSizeConfig: AudienceSizeConfig?
        /// Provides the childResourceTagOnCreatePolicy that was used for this configured audience model.
        public let childResourceTagOnCreatePolicy: TagOnCreatePolicy?
        /// The Amazon Resource Name (ARN) of the configured audience model.
        public let configuredAudienceModelArn: String
        /// The time at which the configured audience model was created.
        public let createTime: Date
        /// The description of the configured audience model.
        public let description: String?
        /// The minimum number of users from the seed audience that must match with users in the training data of the audience model.
        public let minMatchingSeedSize: Int?
        /// The name of the configured audience model.
        public let name: String
        /// The output configuration of the configured audience model
        public let outputConfig: ConfiguredAudienceModelOutputConfig
        /// Whether audience metrics are shared.
        public let sharedAudienceMetrics: [SharedAudienceMetrics]
        /// The status of the configured audience model.
        public let status: ConfiguredAudienceModelStatus
        /// The tags that are associated to this configured audience model.
        public let tags: [String: String]?
        /// The most recent time at which the configured audience model was updated.
        public let updateTime: Date

        public init(audienceModelArn: String, audienceSizeConfig: AudienceSizeConfig? = nil, childResourceTagOnCreatePolicy: TagOnCreatePolicy? = nil, configuredAudienceModelArn: String, createTime: Date, description: String? = nil, minMatchingSeedSize: Int? = nil, name: String, outputConfig: ConfiguredAudienceModelOutputConfig, sharedAudienceMetrics: [SharedAudienceMetrics], status: ConfiguredAudienceModelStatus, tags: [String: String]? = nil, updateTime: Date) {
            self.audienceModelArn = audienceModelArn
            self.audienceSizeConfig = audienceSizeConfig
            self.childResourceTagOnCreatePolicy = childResourceTagOnCreatePolicy
            self.configuredAudienceModelArn = configuredAudienceModelArn
            self.createTime = createTime
            self.description = description
            self.minMatchingSeedSize = minMatchingSeedSize
            self.name = name
            self.outputConfig = outputConfig
            self.sharedAudienceMetrics = sharedAudienceMetrics
            self.status = status
            self.tags = tags
            self.updateTime = updateTime
        }

        private enum CodingKeys: String, CodingKey {
            case audienceModelArn = "audienceModelArn"
            case audienceSizeConfig = "audienceSizeConfig"
            case childResourceTagOnCreatePolicy = "childResourceTagOnCreatePolicy"
            case configuredAudienceModelArn = "configuredAudienceModelArn"
            case createTime = "createTime"
            case description = "description"
            case minMatchingSeedSize = "minMatchingSeedSize"
            case name = "name"
            case outputConfig = "outputConfig"
            case sharedAudienceMetrics = "sharedAudienceMetrics"
            case status = "status"
            case tags = "tags"
            case updateTime = "updateTime"
        }
    }

    public struct GetTrainingDatasetRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the training dataset that you are interested in.
        public let trainingDatasetArn: String

        public init(trainingDatasetArn: String) {
            self.trainingDatasetArn = trainingDatasetArn
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.trainingDatasetArn, key: "trainingDatasetArn")
        }

        public func validate(name: String) throws {
            try self.validate(self.trainingDatasetArn, name: "trainingDatasetArn", parent: name, max: 2048)
            try self.validate(self.trainingDatasetArn, name: "trainingDatasetArn", parent: name, min: 20)
            try self.validate(self.trainingDatasetArn, name: "trainingDatasetArn", parent: name, pattern: "^arn:aws[-a-z]*:cleanrooms-ml:[-a-z0-9]+:[0-9]{12}:training-dataset/[-a-zA-Z0-9_/.]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetTrainingDatasetResponse: AWSDecodableShape {
        /// The time at which the training dataset was created.
        public let createTime: Date
        /// The description of the training dataset.
        public let description: String?
        /// The name of the training dataset.
        public let name: String
        /// The IAM role used to read the training data.
        public let roleArn: String
        /// The status of the training dataset.
        public let status: TrainingDatasetStatus
        /// The tags that are assigned to this training dataset.
        public let tags: [String: String]?
        /// Metadata about the requested training data.
        public let trainingData: [Dataset]
        /// The Amazon Resource Name (ARN) of the training dataset.
        public let trainingDatasetArn: String
        /// The most recent time at which the training dataset was updated.
        public let updateTime: Date

        public init(createTime: Date, description: String? = nil, name: String, roleArn: String, status: TrainingDatasetStatus, tags: [String: String]? = nil, trainingData: [Dataset], trainingDatasetArn: String, updateTime: Date) {
            self.createTime = createTime
            self.description = description
            self.name = name
            self.roleArn = roleArn
            self.status = status
            self.tags = tags
            self.trainingData = trainingData
            self.trainingDatasetArn = trainingDatasetArn
            self.updateTime = updateTime
        }

        private enum CodingKeys: String, CodingKey {
            case createTime = "createTime"
            case description = "description"
            case name = "name"
            case roleArn = "roleArn"
            case status = "status"
            case tags = "tags"
            case trainingData = "trainingData"
            case trainingDatasetArn = "trainingDatasetArn"
            case updateTime = "updateTime"
        }
    }

    public struct GlueDataSource: AWSEncodableShape & AWSDecodableShape {
        /// The Glue catalog that contains the training data.
        public let catalogId: String?
        /// The Glue database that contains the training data.
        public let databaseName: String
        /// The Glue table that contains the training data.
        public let tableName: String

        public init(catalogId: String? = nil, databaseName: String, tableName: String) {
            self.catalogId = catalogId
            self.databaseName = databaseName
            self.tableName = tableName
        }

        public func validate(name: String) throws {
            try self.validate(self.catalogId, name: "catalogId", parent: name, max: 12)
            try self.validate(self.catalogId, name: "catalogId", parent: name, min: 12)
            try self.validate(self.catalogId, name: "catalogId", parent: name, pattern: "^[0-9]{12}$")
            try self.validate(self.databaseName, name: "databaseName", parent: name, max: 128)
            try self.validate(self.databaseName, name: "databaseName", parent: name, min: 1)
            try self.validate(self.databaseName, name: "databaseName", parent: name, pattern: "^[a-zA-Z0-9_](([a-zA-Z0-9_]+-)*([a-zA-Z0-9_]+))?$")
            try self.validate(self.tableName, name: "tableName", parent: name, max: 128)
            try self.validate(self.tableName, name: "tableName", parent: name, min: 1)
            try self.validate(self.tableName, name: "tableName", parent: name, pattern: "^[a-zA-Z0-9_](([a-zA-Z0-9_ ]+-)*([a-zA-Z0-9_ ]+))?$")
        }

        private enum CodingKeys: String, CodingKey {
            case catalogId = "catalogId"
            case databaseName = "databaseName"
            case tableName = "tableName"
        }
    }

    public struct ListAudienceExportJobsRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the audience generation job that you are interested in.
        public let audienceGenerationJobArn: String?
        /// The maximum size of the results that is returned per call.
        public let maxResults: Int?
        /// The token value retrieved from a previous call to access the next page of results.
        public let nextToken: String?

        public init(audienceGenerationJobArn: String? = nil, maxResults: Int? = nil, nextToken: String? = nil) {
            self.audienceGenerationJobArn = audienceGenerationJobArn
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.audienceGenerationJobArn, key: "audienceGenerationJobArn")
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
        }

        public func validate(name: String) throws {
            try self.validate(self.audienceGenerationJobArn, name: "audienceGenerationJobArn", parent: name, max: 2048)
            try self.validate(self.audienceGenerationJobArn, name: "audienceGenerationJobArn", parent: name, min: 20)
            try self.validate(self.audienceGenerationJobArn, name: "audienceGenerationJobArn", parent: name, pattern: "^arn:aws[-a-z]*:cleanrooms-ml:[-a-z0-9]+:[0-9]{12}:audience-generation-job/[-a-zA-Z0-9_/.]+$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 10240)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListAudienceExportJobsResponse: AWSDecodableShape {
        /// The audience export jobs that match the request.
        public let audienceExportJobs: [AudienceExportJobSummary]
        /// The token value retrieved from a previous call to access the next page of results.
        public let nextToken: String?

        public init(audienceExportJobs: [AudienceExportJobSummary], nextToken: String? = nil) {
            self.audienceExportJobs = audienceExportJobs
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case audienceExportJobs = "audienceExportJobs"
            case nextToken = "nextToken"
        }
    }

    public struct ListAudienceGenerationJobsRequest: AWSEncodableShape {
        /// The identifier of the collaboration that contains the audience generation jobs that you are interested in.
        public let collaborationId: String?
        /// The Amazon Resource Name (ARN) of the configured audience model that was used for the audience generation jobs that you are interested in.
        public let configuredAudienceModelArn: String?
        /// The maximum size of the results that is returned per call.
        public let maxResults: Int?
        /// The token value retrieved from a previous call to access the next page of results.
        public let nextToken: String?

        public init(collaborationId: String? = nil, configuredAudienceModelArn: String? = nil, maxResults: Int? = nil, nextToken: String? = nil) {
            self.collaborationId = collaborationId
            self.configuredAudienceModelArn = configuredAudienceModelArn
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.collaborationId, key: "collaborationId")
            request.encodeQuery(self.configuredAudienceModelArn, key: "configuredAudienceModelArn")
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
        }

        public func validate(name: String) throws {
            try self.validate(self.collaborationId, name: "collaborationId", parent: name, max: 36)
            try self.validate(self.collaborationId, name: "collaborationId", parent: name, min: 36)
            try self.validate(self.collaborationId, name: "collaborationId", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$")
            try self.validate(self.configuredAudienceModelArn, name: "configuredAudienceModelArn", parent: name, max: 2048)
            try self.validate(self.configuredAudienceModelArn, name: "configuredAudienceModelArn", parent: name, min: 20)
            try self.validate(self.configuredAudienceModelArn, name: "configuredAudienceModelArn", parent: name, pattern: "^arn:aws[-a-z]*:cleanrooms-ml:[-a-z0-9]+:[0-9]{12}:configured-audience-model/[-a-zA-Z0-9_/.]+$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 10240)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListAudienceGenerationJobsResponse: AWSDecodableShape {
        /// The audience generation jobs that match the request.
        public let audienceGenerationJobs: [AudienceGenerationJobSummary]
        /// The token value retrieved from a previous call to access the next page of results.
        public let nextToken: String?

        public init(audienceGenerationJobs: [AudienceGenerationJobSummary], nextToken: String? = nil) {
            self.audienceGenerationJobs = audienceGenerationJobs
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case audienceGenerationJobs = "audienceGenerationJobs"
            case nextToken = "nextToken"
        }
    }

    public struct ListAudienceModelsRequest: AWSEncodableShape {
        /// The maximum size of the results that is returned per call.
        public let maxResults: Int?
        /// The token value retrieved from a previous call to access the next page of results.
        public let nextToken: String?

        public init(maxResults: Int? = nil, nextToken: String? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 10240)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListAudienceModelsResponse: AWSDecodableShape {
        /// The audience models that match the request.
        public let audienceModels: [AudienceModelSummary]
        /// The token value retrieved from a previous call to access the next page of results.
        public let nextToken: String?

        public init(audienceModels: [AudienceModelSummary], nextToken: String? = nil) {
            self.audienceModels = audienceModels
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case audienceModels = "audienceModels"
            case nextToken = "nextToken"
        }
    }

    public struct ListConfiguredAudienceModelsRequest: AWSEncodableShape {
        /// The maximum size of the results that is returned per call.
        public let maxResults: Int?
        /// The token value retrieved from a previous call to access the next page of results.
        public let nextToken: String?

        public init(maxResults: Int? = nil, nextToken: String? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 10240)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListConfiguredAudienceModelsResponse: AWSDecodableShape {
        /// The configured audience models.
        public let configuredAudienceModels: [ConfiguredAudienceModelSummary]
        /// The token value retrieved from a previous call to access the next page of results.
        public let nextToken: String?

        public init(configuredAudienceModels: [ConfiguredAudienceModelSummary], nextToken: String? = nil) {
            self.configuredAudienceModels = configuredAudienceModels
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case configuredAudienceModels = "configuredAudienceModels"
            case nextToken = "nextToken"
        }
    }

    public struct ListTagsForResourceRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the resource that you are interested in.
        public let resourceArn: String

        public init(resourceArn: String) {
            self.resourceArn = resourceArn
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.resourceArn, key: "resourceArn")
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, max: 2048)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, min: 20)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, pattern: "^arn:aws[-a-z]*:cleanrooms-ml:[-a-z0-9]+:[0-9]{12}:(training-dataset|audience-model|configured-audience-model|audience-generation-job)/[-a-zA-Z0-9_/.]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListTagsForResourceResponse: AWSDecodableShape {
        /// The tags that are associated with the resource.
        public let tags: [String: String]

        public init(tags: [String: String]) {
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case tags = "tags"
        }
    }

    public struct ListTrainingDatasetsRequest: AWSEncodableShape {
        /// The maximum size of the results that is returned per call.
        public let maxResults: Int?
        /// The token value retrieved from a previous call to access the next page of results.
        public let nextToken: String?

        public init(maxResults: Int? = nil, nextToken: String? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 10240)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListTrainingDatasetsResponse: AWSDecodableShape {
        /// The token value retrieved from a previous call to access the next page of results.
        public let nextToken: String?
        /// The training datasets that match the request.
        public let trainingDatasets: [TrainingDatasetSummary]

        public init(nextToken: String? = nil, trainingDatasets: [TrainingDatasetSummary]) {
            self.nextToken = nextToken
            self.trainingDatasets = trainingDatasets
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "nextToken"
            case trainingDatasets = "trainingDatasets"
        }
    }

    public struct PutConfiguredAudienceModelPolicyRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the configured audience model that the resource policy will govern.
        public let configuredAudienceModelArn: String
        /// The IAM resource policy.
        public let configuredAudienceModelPolicy: String
        /// Use this to prevent unexpected concurrent modification of the policy.
        public let policyExistenceCondition: PolicyExistenceCondition?
        /// A cryptographic hash of the contents of the policy used to prevent unexpected concurrent modification of the policy.
        public let previousPolicyHash: String?

        public init(configuredAudienceModelArn: String, configuredAudienceModelPolicy: String, policyExistenceCondition: PolicyExistenceCondition? = nil, previousPolicyHash: String? = nil) {
            self.configuredAudienceModelArn = configuredAudienceModelArn
            self.configuredAudienceModelPolicy = configuredAudienceModelPolicy
            self.policyExistenceCondition = policyExistenceCondition
            self.previousPolicyHash = previousPolicyHash
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.configuredAudienceModelArn, key: "configuredAudienceModelArn")
            try container.encode(self.configuredAudienceModelPolicy, forKey: .configuredAudienceModelPolicy)
            try container.encodeIfPresent(self.policyExistenceCondition, forKey: .policyExistenceCondition)
            try container.encodeIfPresent(self.previousPolicyHash, forKey: .previousPolicyHash)
        }

        public func validate(name: String) throws {
            try self.validate(self.configuredAudienceModelArn, name: "configuredAudienceModelArn", parent: name, max: 2048)
            try self.validate(self.configuredAudienceModelArn, name: "configuredAudienceModelArn", parent: name, min: 20)
            try self.validate(self.configuredAudienceModelArn, name: "configuredAudienceModelArn", parent: name, pattern: "^arn:aws[-a-z]*:cleanrooms-ml:[-a-z0-9]+:[0-9]{12}:configured-audience-model/[-a-zA-Z0-9_/.]+$")
            try self.validate(self.configuredAudienceModelPolicy, name: "configuredAudienceModelPolicy", parent: name, max: 20480)
            try self.validate(self.configuredAudienceModelPolicy, name: "configuredAudienceModelPolicy", parent: name, min: 1)
            try self.validate(self.previousPolicyHash, name: "previousPolicyHash", parent: name, max: 128)
            try self.validate(self.previousPolicyHash, name: "previousPolicyHash", parent: name, min: 64)
            try self.validate(self.previousPolicyHash, name: "previousPolicyHash", parent: name, pattern: "^[0-9a-f]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case configuredAudienceModelPolicy = "configuredAudienceModelPolicy"
            case policyExistenceCondition = "policyExistenceCondition"
            case previousPolicyHash = "previousPolicyHash"
        }
    }

    public struct PutConfiguredAudienceModelPolicyResponse: AWSDecodableShape {
        /// The IAM resource policy.
        public let configuredAudienceModelPolicy: String
        /// A cryptographic hash of the contents of the policy used to prevent unexpected concurrent modification of the policy.
        public let policyHash: String

        public init(configuredAudienceModelPolicy: String, policyHash: String) {
            self.configuredAudienceModelPolicy = configuredAudienceModelPolicy
            self.policyHash = policyHash
        }

        private enum CodingKeys: String, CodingKey {
            case configuredAudienceModelPolicy = "configuredAudienceModelPolicy"
            case policyHash = "policyHash"
        }
    }

    public struct RelevanceMetric: AWSDecodableShape {
        public let audienceSize: AudienceSize
        /// The relevance score of the generated audience.
        public let score: Double?

        public init(audienceSize: AudienceSize, score: Double? = nil) {
            self.audienceSize = audienceSize
            self.score = score
        }

        private enum CodingKeys: String, CodingKey {
            case audienceSize = "audienceSize"
            case score = "score"
        }
    }

    public struct S3ConfigMap: AWSEncodableShape & AWSDecodableShape {
        /// The Amazon S3 location URI.
        public let s3Uri: String

        public init(s3Uri: String) {
            self.s3Uri = s3Uri
        }

        public func validate(name: String) throws {
            try self.validate(self.s3Uri, name: "s3Uri", parent: name, max: 1285)
            try self.validate(self.s3Uri, name: "s3Uri", parent: name, min: 1)
            try self.validate(self.s3Uri, name: "s3Uri", parent: name, pattern: "^s3://.+$")
        }

        private enum CodingKeys: String, CodingKey {
            case s3Uri = "s3Uri"
        }
    }

    public struct StartAudienceExportJobRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the audience generation job that you want to export.
        public let audienceGenerationJobArn: String
        public let audienceSize: AudienceSize
        /// The description of the audience export job.
        public let description: String?
        /// The name of the audience export job.
        public let name: String

        public init(audienceGenerationJobArn: String, audienceSize: AudienceSize, description: String? = nil, name: String) {
            self.audienceGenerationJobArn = audienceGenerationJobArn
            self.audienceSize = audienceSize
            self.description = description
            self.name = name
        }

        public func validate(name: String) throws {
            try self.validate(self.audienceGenerationJobArn, name: "audienceGenerationJobArn", parent: name, max: 2048)
            try self.validate(self.audienceGenerationJobArn, name: "audienceGenerationJobArn", parent: name, min: 20)
            try self.validate(self.audienceGenerationJobArn, name: "audienceGenerationJobArn", parent: name, pattern: "^arn:aws[-a-z]*:cleanrooms-ml:[-a-z0-9]+:[0-9]{12}:audience-generation-job/[-a-zA-Z0-9_/.]+$")
            try self.audienceSize.validate(name: "\(name).audienceSize")
            try self.validate(self.description, name: "description", parent: name, max: 255)
            try self.validate(self.description, name: "description", parent: name, pattern: "^[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDBFF-\\uDC00\\uDFFF\\t\\r\\n]*$")
            try self.validate(self.name, name: "name", parent: name, max: 63)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^(?!\\s*$)[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDBFF-\\uDC00\\uDFFF\\t]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case audienceGenerationJobArn = "audienceGenerationJobArn"
            case audienceSize = "audienceSize"
            case description = "description"
            case name = "name"
        }
    }

    public struct StartAudienceGenerationJobRequest: AWSEncodableShape {
        /// The identifier of the collaboration that contains the audience generation job.
        public let collaborationId: String?
        /// The Amazon Resource Name (ARN) of the configured audience model that is used for this audience generation job.
        public let configuredAudienceModelArn: String
        /// The description of the audience generation job.
        public let description: String?
        /// Whether the seed audience is included in the audience generation output.
        public let includeSeedInOutput: Bool?
        /// The name of the audience generation job.
        public let name: String
        /// The seed audience that is used to generate the audience.
        public let seedAudience: AudienceGenerationJobDataSource
        /// The optional metadata that you apply to the resource to help you categorize and organize them. Each tag consists of a key and an optional value, both of which you define. The following basic restrictions apply to tags:   Maximum number of tags per resource - 50.   For each resource, each tag key must be unique, and each tag key can have only one value.   Maximum key length - 128 Unicode characters in UTF-8.   Maximum value length - 256 Unicode characters in UTF-8.   If your tagging schema is used across multiple services and resources, remember that other services may have restrictions on allowed characters. Generally allowed characters are: letters, numbers, and spaces representable in UTF-8, and the following characters: + - = . _ : / @.   Tag keys and values are case sensitive.   Do not use aws:, AWS:, or any upper or lowercase combination of such as a prefix for keys as it is reserved for AWS use. You cannot edit or delete tag keys with this prefix. Values can have this prefix. If a tag value has aws as its prefix but the key does not, then Clean Rooms ML considers it to be a user tag and will count against the limit of 50 tags. Tags with only the key prefix of aws do not count against your tags per resource limit.
        public let tags: [String: String]?

        public init(collaborationId: String? = nil, configuredAudienceModelArn: String, description: String? = nil, includeSeedInOutput: Bool? = nil, name: String, seedAudience: AudienceGenerationJobDataSource, tags: [String: String]? = nil) {
            self.collaborationId = collaborationId
            self.configuredAudienceModelArn = configuredAudienceModelArn
            self.description = description
            self.includeSeedInOutput = includeSeedInOutput
            self.name = name
            self.seedAudience = seedAudience
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.validate(self.collaborationId, name: "collaborationId", parent: name, max: 36)
            try self.validate(self.collaborationId, name: "collaborationId", parent: name, min: 36)
            try self.validate(self.collaborationId, name: "collaborationId", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$")
            try self.validate(self.configuredAudienceModelArn, name: "configuredAudienceModelArn", parent: name, max: 2048)
            try self.validate(self.configuredAudienceModelArn, name: "configuredAudienceModelArn", parent: name, min: 20)
            try self.validate(self.configuredAudienceModelArn, name: "configuredAudienceModelArn", parent: name, pattern: "^arn:aws[-a-z]*:cleanrooms-ml:[-a-z0-9]+:[0-9]{12}:configured-audience-model/[-a-zA-Z0-9_/.]+$")
            try self.validate(self.description, name: "description", parent: name, max: 255)
            try self.validate(self.description, name: "description", parent: name, pattern: "^[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDBFF-\\uDC00\\uDFFF\\t\\r\\n]*$")
            try self.validate(self.name, name: "name", parent: name, max: 63)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^(?!\\s*$)[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDBFF-\\uDC00\\uDFFF\\t]*$")
            try self.seedAudience.validate(name: "\(name).seedAudience")
            try self.tags?.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 200)
        }

        private enum CodingKeys: String, CodingKey {
            case collaborationId = "collaborationId"
            case configuredAudienceModelArn = "configuredAudienceModelArn"
            case description = "description"
            case includeSeedInOutput = "includeSeedInOutput"
            case name = "name"
            case seedAudience = "seedAudience"
            case tags = "tags"
        }
    }

    public struct StartAudienceGenerationJobResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the audience generation job.
        public let audienceGenerationJobArn: String

        public init(audienceGenerationJobArn: String) {
            self.audienceGenerationJobArn = audienceGenerationJobArn
        }

        private enum CodingKeys: String, CodingKey {
            case audienceGenerationJobArn = "audienceGenerationJobArn"
        }
    }

    public struct StatusDetails: AWSDecodableShape {
        /// The error message that was returned. The message is intended for human consumption and can change at any time. Use the statusCode for programmatic error handling.
        public let message: String?
        /// The status code that was returned. The status code is intended for programmatic error handling. Clean Rooms ML will not change the status code for existing error conditions.
        public let statusCode: String?

        public init(message: String? = nil, statusCode: String? = nil) {
            self.message = message
            self.statusCode = statusCode
        }

        private enum CodingKeys: String, CodingKey {
            case message = "message"
            case statusCode = "statusCode"
        }
    }

    public struct TagResourceRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the resource that you want to assign tags.
        public let resourceArn: String
        /// The optional metadata that you apply to the resource to help you categorize and organize them. Each tag consists of a key and an optional value, both of which you define. The following basic restrictions apply to tags:   Maximum number of tags per resource - 50.   For each resource, each tag key must be unique, and each tag key can have only one value.   Maximum key length - 128 Unicode characters in UTF-8.   Maximum value length - 256 Unicode characters in UTF-8.   If your tagging schema is used across multiple services and resources, remember that other services may have restrictions on allowed characters. Generally allowed characters are: letters, numbers, and spaces representable in UTF-8, and the following characters: + - = . _ : / @.   Tag keys and values are case sensitive.   Do not use aws:, AWS:, or any upper or lowercase combination of such as a prefix for keys as it is reserved for AWS use. You cannot edit or delete tag keys with this prefix. Values can have this prefix. If a tag value has aws as its prefix but the key does not, then Clean Rooms considers it to be a user tag and will count against the limit of 50 tags. Tags with only the key prefix of aws do not count against your tags per resource limit.
        public let tags: [String: String]

        public init(resourceArn: String, tags: [String: String]) {
            self.resourceArn = resourceArn
            self.tags = tags
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.resourceArn, key: "resourceArn")
            try container.encode(self.tags, forKey: .tags)
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, max: 2048)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, min: 20)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, pattern: "^arn:aws[-a-z]*:cleanrooms-ml:[-a-z0-9]+:[0-9]{12}:(training-dataset|audience-model|configured-audience-model|audience-generation-job)/[-a-zA-Z0-9_/.]+$")
            try self.tags.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 200)
        }

        private enum CodingKeys: String, CodingKey {
            case tags = "tags"
        }
    }

    public struct TagResourceResponse: AWSDecodableShape {
        public init() {}
    }

    public struct TrainingDatasetSummary: AWSDecodableShape {
        /// The time at which the training dataset was created.
        public let createTime: Date
        /// The description of the training dataset.
        public let description: String?
        /// The name of the training dataset.
        public let name: String
        /// The status of the training dataset.
        public let status: TrainingDatasetStatus
        /// The Amazon Resource Name (ARN) of the training dataset.
        public let trainingDatasetArn: String
        /// The most recent time at which the training dataset was updated.
        public let updateTime: Date

        public init(createTime: Date, description: String? = nil, name: String, status: TrainingDatasetStatus, trainingDatasetArn: String, updateTime: Date) {
            self.createTime = createTime
            self.description = description
            self.name = name
            self.status = status
            self.trainingDatasetArn = trainingDatasetArn
            self.updateTime = updateTime
        }

        private enum CodingKeys: String, CodingKey {
            case createTime = "createTime"
            case description = "description"
            case name = "name"
            case status = "status"
            case trainingDatasetArn = "trainingDatasetArn"
            case updateTime = "updateTime"
        }
    }

    public struct UntagResourceRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the resource that you want to remove tags from.
        public let resourceArn: String
        /// The key values of tags that you want to remove.
        public let tagKeys: [String]

        public init(resourceArn: String, tagKeys: [String]) {
            self.resourceArn = resourceArn
            self.tagKeys = tagKeys
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.resourceArn, key: "resourceArn")
            request.encodeQuery(self.tagKeys, key: "tagKeys")
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, max: 2048)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, min: 20)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, pattern: "^arn:aws[-a-z]*:cleanrooms-ml:[-a-z0-9]+:[0-9]{12}:(training-dataset|audience-model|configured-audience-model|audience-generation-job)/[-a-zA-Z0-9_/.]+$")
            try self.tagKeys.forEach {
                try validate($0, name: "tagKeys[]", parent: name, max: 128)
                try validate($0, name: "tagKeys[]", parent: name, min: 1)
            }
            try self.validate(self.tagKeys, name: "tagKeys", parent: name, max: 200)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct UntagResourceResponse: AWSDecodableShape {
        public init() {}
    }

    public struct UpdateConfiguredAudienceModelRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the new audience model that you want to use.
        public let audienceModelArn: String?
        /// The new audience size configuration.
        public let audienceSizeConfig: AudienceSizeConfig?
        /// The Amazon Resource Name (ARN) of the configured audience model that you want to update.
        public let configuredAudienceModelArn: String
        /// The new description of the configured audience model.
        public let description: String?
        /// The minimum number of users from the seed audience that must match with users in the training data of the audience model.
        public let minMatchingSeedSize: Int?
        /// The new output configuration.
        public let outputConfig: ConfiguredAudienceModelOutputConfig?
        /// The new value for whether to share audience metrics.
        public let sharedAudienceMetrics: [SharedAudienceMetrics]?

        public init(audienceModelArn: String? = nil, audienceSizeConfig: AudienceSizeConfig? = nil, configuredAudienceModelArn: String, description: String? = nil, minMatchingSeedSize: Int? = nil, outputConfig: ConfiguredAudienceModelOutputConfig? = nil, sharedAudienceMetrics: [SharedAudienceMetrics]? = nil) {
            self.audienceModelArn = audienceModelArn
            self.audienceSizeConfig = audienceSizeConfig
            self.configuredAudienceModelArn = configuredAudienceModelArn
            self.description = description
            self.minMatchingSeedSize = minMatchingSeedSize
            self.outputConfig = outputConfig
            self.sharedAudienceMetrics = sharedAudienceMetrics
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.audienceModelArn, forKey: .audienceModelArn)
            try container.encodeIfPresent(self.audienceSizeConfig, forKey: .audienceSizeConfig)
            request.encodePath(self.configuredAudienceModelArn, key: "configuredAudienceModelArn")
            try container.encodeIfPresent(self.description, forKey: .description)
            try container.encodeIfPresent(self.minMatchingSeedSize, forKey: .minMatchingSeedSize)
            try container.encodeIfPresent(self.outputConfig, forKey: .outputConfig)
            try container.encodeIfPresent(self.sharedAudienceMetrics, forKey: .sharedAudienceMetrics)
        }

        public func validate(name: String) throws {
            try self.validate(self.audienceModelArn, name: "audienceModelArn", parent: name, max: 2048)
            try self.validate(self.audienceModelArn, name: "audienceModelArn", parent: name, min: 20)
            try self.validate(self.audienceModelArn, name: "audienceModelArn", parent: name, pattern: "^arn:aws[-a-z]*:cleanrooms-ml:[-a-z0-9]+:[0-9]{12}:audience-model/[-a-zA-Z0-9_/.]+$")
            try self.audienceSizeConfig?.validate(name: "\(name).audienceSizeConfig")
            try self.validate(self.configuredAudienceModelArn, name: "configuredAudienceModelArn", parent: name, max: 2048)
            try self.validate(self.configuredAudienceModelArn, name: "configuredAudienceModelArn", parent: name, min: 20)
            try self.validate(self.configuredAudienceModelArn, name: "configuredAudienceModelArn", parent: name, pattern: "^arn:aws[-a-z]*:cleanrooms-ml:[-a-z0-9]+:[0-9]{12}:configured-audience-model/[-a-zA-Z0-9_/.]+$")
            try self.validate(self.description, name: "description", parent: name, max: 255)
            try self.validate(self.description, name: "description", parent: name, pattern: "^[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDBFF-\\uDC00\\uDFFF\\t\\r\\n]*$")
            try self.validate(self.minMatchingSeedSize, name: "minMatchingSeedSize", parent: name, max: 500000)
            try self.validate(self.minMatchingSeedSize, name: "minMatchingSeedSize", parent: name, min: 25)
            try self.outputConfig?.validate(name: "\(name).outputConfig")
            try self.validate(self.sharedAudienceMetrics, name: "sharedAudienceMetrics", parent: name, max: 1)
            try self.validate(self.sharedAudienceMetrics, name: "sharedAudienceMetrics", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case audienceModelArn = "audienceModelArn"
            case audienceSizeConfig = "audienceSizeConfig"
            case description = "description"
            case minMatchingSeedSize = "minMatchingSeedSize"
            case outputConfig = "outputConfig"
            case sharedAudienceMetrics = "sharedAudienceMetrics"
        }
    }

    public struct UpdateConfiguredAudienceModelResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the configured audience model that was updated.
        public let configuredAudienceModelArn: String

        public init(configuredAudienceModelArn: String) {
            self.configuredAudienceModelArn = configuredAudienceModelArn
        }

        private enum CodingKeys: String, CodingKey {
            case configuredAudienceModelArn = "configuredAudienceModelArn"
        }
    }
}

// MARK: - Errors

/// Error enum for CleanRoomsML
public struct CleanRoomsMLErrorType: AWSErrorType {
    enum Code: String {
        case accessDeniedException = "AccessDeniedException"
        case conflictException = "ConflictException"
        case resourceNotFoundException = "ResourceNotFoundException"
        case serviceQuotaExceededException = "ServiceQuotaExceededException"
        case validationException = "ValidationException"
    }

    private let error: Code
    public let context: AWSErrorContext?

    /// initialize CleanRoomsML
    public init?(errorCode: String, context: AWSErrorContext) {
        guard let error = Code(rawValue: errorCode) else { return nil }
        self.error = error
        self.context = context
    }

    internal init(_ error: Code) {
        self.error = error
        self.context = nil
    }

    /// return error code string
    public var errorCode: String { self.error.rawValue }

    /// You do not have sufficient access to perform this action.
    public static var accessDeniedException: Self { .init(.accessDeniedException) }
    /// You can't complete this action because another resource depends on this resource.
    public static var conflictException: Self { .init(.conflictException) }
    /// The resource you are requesting does not exist.
    public static var resourceNotFoundException: Self { .init(.resourceNotFoundException) }
    /// You have exceeded your service quota.
    public static var serviceQuotaExceededException: Self { .init(.serviceQuotaExceededException) }
    /// The request parameters for this request are incorrect.
    public static var validationException: Self { .init(.validationException) }
}

extension CleanRoomsMLErrorType: Equatable {
    public static func == (lhs: CleanRoomsMLErrorType, rhs: CleanRoomsMLErrorType) -> Bool {
        lhs.error == rhs.error
    }
}

extension CleanRoomsMLErrorType: CustomStringConvertible {
    public var description: String {
        return "\(self.error.rawValue): \(self.message ?? "")"
    }
}
