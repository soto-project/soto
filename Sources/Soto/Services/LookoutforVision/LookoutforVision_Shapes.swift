//===----------------------------------------------------------------------===//
//
// This source file is part of the Soto for AWS open source project
//
// Copyright (c) 2017-2021 the Soto project authors
// Licensed under Apache License v2.0
//
// See LICENSE.txt for license information
// See CONTRIBUTORS.txt for the list of Soto project authors
//
// SPDX-License-Identifier: Apache-2.0
//
//===----------------------------------------------------------------------===//

// THIS FILE IS AUTOMATICALLY GENERATED by https://github.com/soto-project/soto/tree/main/CodeGenerator. DO NOT EDIT.

import Foundation
import SotoCore

extension LookoutforVision {
    // MARK: Enums

    public enum DatasetStatus: String, CustomStringConvertible, Codable {
        case createComplete = "CREATE_COMPLETE"
        case createFailed = "CREATE_FAILED"
        case createInProgress = "CREATE_IN_PROGRESS"
        case deleteComplete = "DELETE_COMPLETE"
        case deleteFailed = "DELETE_FAILED"
        case deleteInProgress = "DELETE_IN_PROGRESS"
        case updateComplete = "UPDATE_COMPLETE"
        case updateFailedRollbackComplete = "UPDATE_FAILED_ROLLBACK_COMPLETE"
        case updateFailedRollbackInProgress = "UPDATE_FAILED_ROLLBACK_IN_PROGRESS"
        case updateInProgress = "UPDATE_IN_PROGRESS"
        public var description: String { return self.rawValue }
    }

    public enum ModelHostingStatus: String, CustomStringConvertible, Codable {
        case hosted = "HOSTED"
        case hostingFailed = "HOSTING_FAILED"
        case startingHosting = "STARTING_HOSTING"
        case stoppingHosting = "STOPPING_HOSTING"
        case systemUpdating = "SYSTEM_UPDATING"
        public var description: String { return self.rawValue }
    }

    public enum ModelStatus: String, CustomStringConvertible, Codable {
        case deleting = "DELETING"
        case hosted = "HOSTED"
        case hostingFailed = "HOSTING_FAILED"
        case startingHosting = "STARTING_HOSTING"
        case stoppingHosting = "STOPPING_HOSTING"
        case systemUpdating = "SYSTEM_UPDATING"
        case trained = "TRAINED"
        case training = "TRAINING"
        case trainingFailed = "TRAINING_FAILED"
        public var description: String { return self.rawValue }
    }

    // MARK: Shapes

    public struct CreateDatasetRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "clientToken", location: .header(locationName: "X-Amzn-Client-Token")),
            AWSMemberEncoding(label: "projectName", location: .uri(locationName: "projectName"))
        ]

        /// ClientToken is an idempotency token that ensures a call to CreateDataset completes only once. You choose the value to pass. For example, An issue, such as an network outage, might prevent you from getting a response from CreateDataset. In this case, safely retry your call to CreateDataset by using the same ClientToken parameter value. An error occurs if the other input parameters are not the same as in the first request. Using a different value for ClientToken is considered a new call to CreateDataset. An idempotency token is active for 8 hours.
        public let clientToken: String?
        /// The location of the manifest file that Amazon Lookout for Vision uses to create the dataset. If you don't specify DatasetSource, an empty dataset is created and the operation synchronously returns. Later, you can add JSON Lines by calling UpdateDatasetEntries.  If you specify a value for DataSource, the manifest at the S3 location is validated and used to create the dataset. The call to CreateDataset is asynchronous and might take a while to complete. To find out the current status, Check the value of Status returned in a call to DescribeDataset.
        public let datasetSource: DatasetSource?
        /// The type of the dataset. Specify train for a training dataset. Specify test for a test dataset.
        public let datasetType: String
        /// The name of the project in which you want to create a dataset.
        public let projectName: String

        public init(clientToken: String? = CreateDatasetRequest.idempotencyToken(), datasetSource: DatasetSource? = nil, datasetType: String, projectName: String) {
            self.clientToken = clientToken
            self.datasetSource = datasetSource
            self.datasetType = datasetType
            self.projectName = projectName
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 64)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "^[a-zA-Z0-9-]+$")
            try self.datasetSource?.validate(name: "\(name).datasetSource")
            try self.validate(self.datasetType, name: "datasetType", parent: name, max: 10)
            try self.validate(self.datasetType, name: "datasetType", parent: name, min: 1)
            try self.validate(self.datasetType, name: "datasetType", parent: name, pattern: "train|test")
            try self.validate(self.projectName, name: "projectName", parent: name, max: 255)
            try self.validate(self.projectName, name: "projectName", parent: name, min: 1)
            try self.validate(self.projectName, name: "projectName", parent: name, pattern: "[a-zA-Z0-9][a-zA-Z0-9_\\-]*")
        }

        private enum CodingKeys: String, CodingKey {
            case datasetSource = "DatasetSource"
            case datasetType = "DatasetType"
        }
    }

    public struct CreateDatasetResponse: AWSDecodableShape {
        /// Information about the dataset.
        public let datasetMetadata: DatasetMetadata?

        public init(datasetMetadata: DatasetMetadata? = nil) {
            self.datasetMetadata = datasetMetadata
        }

        private enum CodingKeys: String, CodingKey {
            case datasetMetadata = "DatasetMetadata"
        }
    }

    public struct CreateModelRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "clientToken", location: .header(locationName: "X-Amzn-Client-Token")),
            AWSMemberEncoding(label: "projectName", location: .uri(locationName: "projectName"))
        ]

        /// ClientToken is an idempotency token that ensures a call to CreateModel completes only once. You choose the value to pass. For example, An issue, such as an network outage, might prevent you from getting a response from CreateModel. In this case, safely retry your call to CreateModel by using the same ClientToken parameter value. An error occurs if the other input parameters are not the same as in the first request. Using a different value for ClientToken is considered a new call to CreateModel. An idempotency token is active for 8 hours.
        public let clientToken: String?
        /// A description for the version of the model.
        public let description: String?
        /// The identifier for your AWS Key Management Service (AWS KMS) customer master key (CMK). The key is used to encrypt training and test images copied into the service for model training. Your source images are unaffected. If this parameter is not specified, the copied images are encrypted by a key that AWS owns and manages.
        public let kmsKeyId: String?
        /// The location where Amazon Lookout for Vision saves the training results.
        public let outputConfig: OutputConfig
        /// The name of the project in which you want to create a model version.
        public let projectName: String
        /// A set of tags (key-value pairs) that you want to attach to the model.
        public let tags: [Tag]?

        public init(clientToken: String? = CreateModelRequest.idempotencyToken(), description: String? = nil, kmsKeyId: String? = nil, outputConfig: OutputConfig, projectName: String, tags: [Tag]? = nil) {
            self.clientToken = clientToken
            self.description = description
            self.kmsKeyId = kmsKeyId
            self.outputConfig = outputConfig
            self.projectName = projectName
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 64)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "^[a-zA-Z0-9-]+$")
            try self.validate(self.description, name: "description", parent: name, max: 500)
            try self.validate(self.description, name: "description", parent: name, min: 1)
            try self.validate(self.description, name: "description", parent: name, pattern: "[0-9A-Za-z\\.\\-_]*")
            try self.validate(self.kmsKeyId, name: "kmsKeyId", parent: name, max: 2048)
            try self.validate(self.kmsKeyId, name: "kmsKeyId", parent: name, min: 1)
            try self.validate(self.kmsKeyId, name: "kmsKeyId", parent: name, pattern: "^[A-Za-z0-9][A-Za-z0-9:_/+=,@.-]{0,2048}$")
            try self.outputConfig.validate(name: "\(name).outputConfig")
            try self.validate(self.projectName, name: "projectName", parent: name, max: 255)
            try self.validate(self.projectName, name: "projectName", parent: name, min: 1)
            try self.validate(self.projectName, name: "projectName", parent: name, pattern: "[a-zA-Z0-9][a-zA-Z0-9_\\-]*")
            try self.tags?.forEach {
                try $0.validate(name: "\(name).tags[]")
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 200)
            try self.validate(self.tags, name: "tags", parent: name, min: 0)
        }

        private enum CodingKeys: String, CodingKey {
            case description = "Description"
            case kmsKeyId = "KmsKeyId"
            case outputConfig = "OutputConfig"
            case tags = "Tags"
        }
    }

    public struct CreateModelResponse: AWSDecodableShape {
        /// The response from a call to CreateModel.
        public let modelMetadata: ModelMetadata?

        public init(modelMetadata: ModelMetadata? = nil) {
            self.modelMetadata = modelMetadata
        }

        private enum CodingKeys: String, CodingKey {
            case modelMetadata = "ModelMetadata"
        }
    }

    public struct CreateProjectRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "clientToken", location: .header(locationName: "X-Amzn-Client-Token"))
        ]

        /// ClientToken is an idempotency token that ensures a call to CreateProject completes only once. You choose the value to pass. For example, An issue, such as an network outage, might prevent you from getting a response from CreateProject. In this case, safely retry your call to CreateProject by using the same ClientToken parameter value. An error occurs if the other input parameters are not the same as in the first request. Using a different value for ClientToken is considered a new call to CreateProject. An idempotency token is active for 8 hours.
        public let clientToken: String?
        /// The name for the project.
        public let projectName: String

        public init(clientToken: String? = CreateProjectRequest.idempotencyToken(), projectName: String) {
            self.clientToken = clientToken
            self.projectName = projectName
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 64)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "^[a-zA-Z0-9-]+$")
            try self.validate(self.projectName, name: "projectName", parent: name, max: 255)
            try self.validate(self.projectName, name: "projectName", parent: name, min: 1)
            try self.validate(self.projectName, name: "projectName", parent: name, pattern: "[a-zA-Z0-9][a-zA-Z0-9_\\-]*")
        }

        private enum CodingKeys: String, CodingKey {
            case projectName = "ProjectName"
        }
    }

    public struct CreateProjectResponse: AWSDecodableShape {
        /// Information about the project.
        public let projectMetadata: ProjectMetadata?

        public init(projectMetadata: ProjectMetadata? = nil) {
            self.projectMetadata = projectMetadata
        }

        private enum CodingKeys: String, CodingKey {
            case projectMetadata = "ProjectMetadata"
        }
    }

    public struct DatasetDescription: AWSDecodableShape {
        /// The Unix timestamp for the time and date that the dataset was created.
        public let creationTimestamp: Date?
        /// The type of the dataset. The value train represents a training dataset or single dataset project. The value test represents a test dataset.
        public let datasetType: String?
        public let imageStats: DatasetImageStats?
        /// The Unix timestamp for the date and time that the dataset was last updated.
        public let lastUpdatedTimestamp: Date?
        /// The name of the project that contains the dataset.
        public let projectName: String?
        /// The status of the dataset.
        public let status: DatasetStatus?
        /// The status message for the dataset.
        public let statusMessage: String?

        public init(creationTimestamp: Date? = nil, datasetType: String? = nil, imageStats: DatasetImageStats? = nil, lastUpdatedTimestamp: Date? = nil, projectName: String? = nil, status: DatasetStatus? = nil, statusMessage: String? = nil) {
            self.creationTimestamp = creationTimestamp
            self.datasetType = datasetType
            self.imageStats = imageStats
            self.lastUpdatedTimestamp = lastUpdatedTimestamp
            self.projectName = projectName
            self.status = status
            self.statusMessage = statusMessage
        }

        private enum CodingKeys: String, CodingKey {
            case creationTimestamp = "CreationTimestamp"
            case datasetType = "DatasetType"
            case imageStats = "ImageStats"
            case lastUpdatedTimestamp = "LastUpdatedTimestamp"
            case projectName = "ProjectName"
            case status = "Status"
            case statusMessage = "StatusMessage"
        }
    }

    public struct DatasetGroundTruthManifest: AWSEncodableShape {
        /// The S3 bucket location for the manifest file.
        public let s3Object: InputS3Object?

        public init(s3Object: InputS3Object? = nil) {
            self.s3Object = s3Object
        }

        public func validate(name: String) throws {
            try self.s3Object?.validate(name: "\(name).s3Object")
        }

        private enum CodingKeys: String, CodingKey {
            case s3Object = "S3Object"
        }
    }

    public struct DatasetImageStats: AWSDecodableShape {
        /// the total number of images labeled as an anomaly.
        public let anomaly: Int?
        /// The total number of labeled images.
        public let labeled: Int?
        /// The total number of images labeled as normal.
        public let normal: Int?
        /// The total number of images in the dataset.
        public let total: Int?

        public init(anomaly: Int? = nil, labeled: Int? = nil, normal: Int? = nil, total: Int? = nil) {
            self.anomaly = anomaly
            self.labeled = labeled
            self.normal = normal
            self.total = total
        }

        private enum CodingKeys: String, CodingKey {
            case anomaly = "Anomaly"
            case labeled = "Labeled"
            case normal = "Normal"
            case total = "Total"
        }
    }

    public struct DatasetMetadata: AWSDecodableShape {
        /// The Unix timestamp for the date and time that the dataset was created.
        public let creationTimestamp: Date?
        /// The type of the dataset.
        public let datasetType: String?
        /// The status for the dataset.
        public let status: DatasetStatus?
        /// The status message for the dataset.
        public let statusMessage: String?

        public init(creationTimestamp: Date? = nil, datasetType: String? = nil, status: DatasetStatus? = nil, statusMessage: String? = nil) {
            self.creationTimestamp = creationTimestamp
            self.datasetType = datasetType
            self.status = status
            self.statusMessage = statusMessage
        }

        private enum CodingKeys: String, CodingKey {
            case creationTimestamp = "CreationTimestamp"
            case datasetType = "DatasetType"
            case status = "Status"
            case statusMessage = "StatusMessage"
        }
    }

    public struct DatasetSource: AWSEncodableShape {
        /// Location information for the manifest file.
        public let groundTruthManifest: DatasetGroundTruthManifest?

        public init(groundTruthManifest: DatasetGroundTruthManifest? = nil) {
            self.groundTruthManifest = groundTruthManifest
        }

        public func validate(name: String) throws {
            try self.groundTruthManifest?.validate(name: "\(name).groundTruthManifest")
        }

        private enum CodingKeys: String, CodingKey {
            case groundTruthManifest = "GroundTruthManifest"
        }
    }

    public struct DeleteDatasetRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "clientToken", location: .header(locationName: "X-Amzn-Client-Token")),
            AWSMemberEncoding(label: "datasetType", location: .uri(locationName: "datasetType")),
            AWSMemberEncoding(label: "projectName", location: .uri(locationName: "projectName"))
        ]

        /// ClientToken is an idempotency token that ensures a call to DeleteDataset completes only once. You choose the value to pass. For example, An issue, such as an network outage, might prevent you from getting a response from DeleteDataset. In this case, safely retry your call to DeleteDataset by using the same ClientToken parameter value. An error occurs if the other input parameters are not the same as in the first request. Using a different value for ClientToken is considered a new call to DeleteDataset. An idempotency token is active for 8 hours.
        public let clientToken: String?
        /// The type of the dataset to delete. Specify train to delete the training dataset. Specify test to delete the test dataset. To delete the dataset in a single dataset project, specify train.
        public let datasetType: String
        /// The name of the project that contains the dataset that you want to delete.
        public let projectName: String

        public init(clientToken: String? = DeleteDatasetRequest.idempotencyToken(), datasetType: String, projectName: String) {
            self.clientToken = clientToken
            self.datasetType = datasetType
            self.projectName = projectName
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 64)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "^[a-zA-Z0-9-]+$")
            try self.validate(self.datasetType, name: "datasetType", parent: name, max: 10)
            try self.validate(self.datasetType, name: "datasetType", parent: name, min: 1)
            try self.validate(self.datasetType, name: "datasetType", parent: name, pattern: "train|test")
            try self.validate(self.projectName, name: "projectName", parent: name, max: 255)
            try self.validate(self.projectName, name: "projectName", parent: name, min: 1)
            try self.validate(self.projectName, name: "projectName", parent: name, pattern: "[a-zA-Z0-9][a-zA-Z0-9_\\-]*")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteDatasetResponse: AWSDecodableShape {
        public init() {}
    }

    public struct DeleteModelRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "clientToken", location: .header(locationName: "X-Amzn-Client-Token")),
            AWSMemberEncoding(label: "modelVersion", location: .uri(locationName: "modelVersion")),
            AWSMemberEncoding(label: "projectName", location: .uri(locationName: "projectName"))
        ]

        /// ClientToken is an idempotency token that ensures a call to DeleteModel completes only once. You choose the value to pass. For example, An issue, such as an network outage, might prevent you from getting a response from DeleteModel. In this case, safely retry your call to DeleteModel by using the same ClientToken parameter value. An error occurs if the other input parameters are not the same as in the first request. Using a different value for ClientToken is considered a new call to DeleteModel. An idempotency token is active for 8 hours.
        public let clientToken: String?
        /// The version of the model that you want to delete.
        public let modelVersion: String
        /// The name of the project that contains the model that you want to delete.
        public let projectName: String

        public init(clientToken: String? = DeleteModelRequest.idempotencyToken(), modelVersion: String, projectName: String) {
            self.clientToken = clientToken
            self.modelVersion = modelVersion
            self.projectName = projectName
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 64)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "^[a-zA-Z0-9-]+$")
            try self.validate(self.modelVersion, name: "modelVersion", parent: name, max: 10)
            try self.validate(self.modelVersion, name: "modelVersion", parent: name, min: 1)
            try self.validate(self.modelVersion, name: "modelVersion", parent: name, pattern: "([1-9][0-9]*|latest)")
            try self.validate(self.projectName, name: "projectName", parent: name, max: 255)
            try self.validate(self.projectName, name: "projectName", parent: name, min: 1)
            try self.validate(self.projectName, name: "projectName", parent: name, pattern: "[a-zA-Z0-9][a-zA-Z0-9_\\-]*")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteModelResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the model that was deleted.
        public let modelArn: String?

        public init(modelArn: String? = nil) {
            self.modelArn = modelArn
        }

        private enum CodingKeys: String, CodingKey {
            case modelArn = "ModelArn"
        }
    }

    public struct DeleteProjectRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "clientToken", location: .header(locationName: "X-Amzn-Client-Token")),
            AWSMemberEncoding(label: "projectName", location: .uri(locationName: "projectName"))
        ]

        /// ClientToken is an idempotency token that ensures a call to DeleteProject completes only once. You choose the value to pass. For example, An issue, such as an network outage, might prevent you from getting a response from DeleteProject. In this case, safely retry your call to DeleteProject by using the same ClientToken parameter value. An error occurs if the other input parameters are not the same as in the first request. Using a different value for ClientToken is considered a new call to DeleteProject. An idempotency token is active for 8 hours.
        public let clientToken: String?
        /// The name of the project to delete.
        public let projectName: String

        public init(clientToken: String? = DeleteProjectRequest.idempotencyToken(), projectName: String) {
            self.clientToken = clientToken
            self.projectName = projectName
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 64)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "^[a-zA-Z0-9-]+$")
            try self.validate(self.projectName, name: "projectName", parent: name, max: 255)
            try self.validate(self.projectName, name: "projectName", parent: name, min: 1)
            try self.validate(self.projectName, name: "projectName", parent: name, pattern: "[a-zA-Z0-9][a-zA-Z0-9_\\-]*")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteProjectResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the project that was deleted.
        public let projectArn: String?

        public init(projectArn: String? = nil) {
            self.projectArn = projectArn
        }

        private enum CodingKeys: String, CodingKey {
            case projectArn = "ProjectArn"
        }
    }

    public struct DescribeDatasetRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "datasetType", location: .uri(locationName: "datasetType")),
            AWSMemberEncoding(label: "projectName", location: .uri(locationName: "projectName"))
        ]

        /// The type of the dataset to describe. Specify train to describe the training dataset. Specify test to describe the test dataset. If you have a single dataset project, specify train
        public let datasetType: String
        /// The name of the project that contains the dataset that you want to describe.
        public let projectName: String

        public init(datasetType: String, projectName: String) {
            self.datasetType = datasetType
            self.projectName = projectName
        }

        public func validate(name: String) throws {
            try self.validate(self.datasetType, name: "datasetType", parent: name, max: 10)
            try self.validate(self.datasetType, name: "datasetType", parent: name, min: 1)
            try self.validate(self.datasetType, name: "datasetType", parent: name, pattern: "train|test")
            try self.validate(self.projectName, name: "projectName", parent: name, max: 255)
            try self.validate(self.projectName, name: "projectName", parent: name, min: 1)
            try self.validate(self.projectName, name: "projectName", parent: name, pattern: "[a-zA-Z0-9][a-zA-Z0-9_\\-]*")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DescribeDatasetResponse: AWSDecodableShape {
        /// The description of the requested dataset.
        public let datasetDescription: DatasetDescription?

        public init(datasetDescription: DatasetDescription? = nil) {
            self.datasetDescription = datasetDescription
        }

        private enum CodingKeys: String, CodingKey {
            case datasetDescription = "DatasetDescription"
        }
    }

    public struct DescribeModelRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "modelVersion", location: .uri(locationName: "modelVersion")),
            AWSMemberEncoding(label: "projectName", location: .uri(locationName: "projectName"))
        ]

        /// The version of the model that you want to describe.
        public let modelVersion: String
        /// The project that contains the version of a model that you want to describe.
        public let projectName: String

        public init(modelVersion: String, projectName: String) {
            self.modelVersion = modelVersion
            self.projectName = projectName
        }

        public func validate(name: String) throws {
            try self.validate(self.modelVersion, name: "modelVersion", parent: name, max: 10)
            try self.validate(self.modelVersion, name: "modelVersion", parent: name, min: 1)
            try self.validate(self.modelVersion, name: "modelVersion", parent: name, pattern: "([1-9][0-9]*|latest)")
            try self.validate(self.projectName, name: "projectName", parent: name, max: 255)
            try self.validate(self.projectName, name: "projectName", parent: name, min: 1)
            try self.validate(self.projectName, name: "projectName", parent: name, pattern: "[a-zA-Z0-9][a-zA-Z0-9_\\-]*")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DescribeModelResponse: AWSDecodableShape {
        /// Contains the description of the model.
        public let modelDescription: ModelDescription?

        public init(modelDescription: ModelDescription? = nil) {
            self.modelDescription = modelDescription
        }

        private enum CodingKeys: String, CodingKey {
            case modelDescription = "ModelDescription"
        }
    }

    public struct DescribeProjectRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "projectName", location: .uri(locationName: "projectName"))
        ]

        /// The name of the project that you want to describe.
        public let projectName: String

        public init(projectName: String) {
            self.projectName = projectName
        }

        public func validate(name: String) throws {
            try self.validate(self.projectName, name: "projectName", parent: name, max: 255)
            try self.validate(self.projectName, name: "projectName", parent: name, min: 1)
            try self.validate(self.projectName, name: "projectName", parent: name, pattern: "[a-zA-Z0-9][a-zA-Z0-9_\\-]*")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DescribeProjectResponse: AWSDecodableShape {
        /// The description of the project.
        public let projectDescription: ProjectDescription?

        public init(projectDescription: ProjectDescription? = nil) {
            self.projectDescription = projectDescription
        }

        private enum CodingKeys: String, CodingKey {
            case projectDescription = "ProjectDescription"
        }
    }

    public struct DetectAnomaliesRequest: AWSEncodableShape & AWSShapeWithPayload {
        /// The key for the payload
        public static let _payloadPath: String = "body"
        public static let _payloadOptions: AWSShapePayloadOptions = [.raw, .allowStreaming]
        public static var _encoding = [
            AWSMemberEncoding(label: "body", location: .body(locationName: "Body")),
            AWSMemberEncoding(label: "contentType", location: .header(locationName: "Content-Type")),
            AWSMemberEncoding(label: "modelVersion", location: .uri(locationName: "modelVersion")),
            AWSMemberEncoding(label: "projectName", location: .uri(locationName: "projectName"))
        ]

        /// The unencrypted image bytes that you want to analyze.
        public let body: AWSPayload
        /// The type of the image passed in Body. Valid values are image/png (PNG format images) and image/jpeg (JPG format images).
        public let contentType: String
        /// The version of the model that you want to use.
        public let modelVersion: String
        /// The name of the project that contains the model version that you want to use.
        public let projectName: String

        public init(body: AWSPayload, contentType: String, modelVersion: String, projectName: String) {
            self.body = body
            self.contentType = contentType
            self.modelVersion = modelVersion
            self.projectName = projectName
        }

        public func validate(name: String) throws {
            try self.validate(self.contentType, name: "contentType", parent: name, max: 255)
            try self.validate(self.contentType, name: "contentType", parent: name, min: 1)
            try self.validate(self.contentType, name: "contentType", parent: name, pattern: ".*")
            try self.validate(self.modelVersion, name: "modelVersion", parent: name, max: 10)
            try self.validate(self.modelVersion, name: "modelVersion", parent: name, min: 1)
            try self.validate(self.modelVersion, name: "modelVersion", parent: name, pattern: "([1-9][0-9]*|latest)")
            try self.validate(self.projectName, name: "projectName", parent: name, max: 255)
            try self.validate(self.projectName, name: "projectName", parent: name, min: 1)
            try self.validate(self.projectName, name: "projectName", parent: name, pattern: "[a-zA-Z0-9][a-zA-Z0-9_\\-]*")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DetectAnomaliesResponse: AWSDecodableShape {
        /// The results of the DetectAnomalies operation.
        public let detectAnomalyResult: DetectAnomalyResult?

        public init(detectAnomalyResult: DetectAnomalyResult? = nil) {
            self.detectAnomalyResult = detectAnomalyResult
        }

        private enum CodingKeys: String, CodingKey {
            case detectAnomalyResult = "DetectAnomalyResult"
        }
    }

    public struct DetectAnomalyResult: AWSDecodableShape {
        /// The confidence that Amazon Lookout for Vision has in the accuracy of the prediction.
        public let confidence: Float?
        /// True if the image contains an anomaly, otherwise false.
        public let isAnomalous: Bool?
        /// The source of the image that was analyzed. direct means that the images was supplied from the local computer. No other values are supported.
        public let source: ImageSource?

        public init(confidence: Float? = nil, isAnomalous: Bool? = nil, source: ImageSource? = nil) {
            self.confidence = confidence
            self.isAnomalous = isAnomalous
            self.source = source
        }

        private enum CodingKeys: String, CodingKey {
            case confidence = "Confidence"
            case isAnomalous = "IsAnomalous"
            case source = "Source"
        }
    }

    public struct ImageSource: AWSDecodableShape {
        /// The type of the image.
        public let type: String?

        public init(type: String? = nil) {
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case type = "Type"
        }
    }

    public struct InputS3Object: AWSEncodableShape {
        /// The Amazon S3 bucket that contains the manifest.
        public let bucket: String
        /// The name and location of the manifest file withiin the bucket.
        public let key: String
        /// The version ID of the bucket.
        public let versionId: String?

        public init(bucket: String, key: String, versionId: String? = nil) {
            self.bucket = bucket
            self.key = key
            self.versionId = versionId
        }

        public func validate(name: String) throws {
            try self.validate(self.bucket, name: "bucket", parent: name, max: 63)
            try self.validate(self.bucket, name: "bucket", parent: name, min: 3)
            try self.validate(self.bucket, name: "bucket", parent: name, pattern: "[0-9A-Za-z\\.\\-_]*")
            try self.validate(self.key, name: "key", parent: name, max: 1024)
            try self.validate(self.key, name: "key", parent: name, min: 1)
            try self.validate(self.key, name: "key", parent: name, pattern: "^([a-zA-Z0-9!_.*'()-][/a-zA-Z0-9!_.*'()-]*)?$")
            try self.validate(self.versionId, name: "versionId", parent: name, max: 1024)
            try self.validate(self.versionId, name: "versionId", parent: name, min: 1)
            try self.validate(self.versionId, name: "versionId", parent: name, pattern: ".*")
        }

        private enum CodingKeys: String, CodingKey {
            case bucket = "Bucket"
            case key = "Key"
            case versionId = "VersionId"
        }
    }

    public struct ListDatasetEntriesRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "afterCreationDate", location: .querystring(locationName: "createdAfter")),
            AWSMemberEncoding(label: "anomalyClass", location: .querystring(locationName: "anomalyClass")),
            AWSMemberEncoding(label: "beforeCreationDate", location: .querystring(locationName: "createdBefore")),
            AWSMemberEncoding(label: "datasetType", location: .uri(locationName: "datasetType")),
            AWSMemberEncoding(label: "labeled", location: .querystring(locationName: "labeled")),
            AWSMemberEncoding(label: "maxResults", location: .querystring(locationName: "maxResults")),
            AWSMemberEncoding(label: "nextToken", location: .querystring(locationName: "nextToken")),
            AWSMemberEncoding(label: "projectName", location: .uri(locationName: "projectName")),
            AWSMemberEncoding(label: "sourceRefContains", location: .querystring(locationName: "sourceRefContains"))
        ]

        /// Only includes entries after the specified date in the response. For example, 2020-06-23T00:00:00.
        public let afterCreationDate: Date?
        /// Specify normal to include only normal images. Specify anomaly to only include anomalous entries. If you don't specify a value, Amazon Lookout for Vision returns normal and anomalous images.
        public let anomalyClass: String?
        /// Only includes entries before the specified date in the response. For example, 2020-06-23T00:00:00.
        public let beforeCreationDate: Date?
        /// The type of the dataset that you want to list. Specify train to list the training dataset. Specify test to list the test dataset. If you have a single dataset project, specify train.
        public let datasetType: String
        /// Specify true to include labeled entries, otherwise specify false. If you don't specify a value, Lookout for Vision returns all entries.
        public let labeled: Bool?
        /// The maximum number of results to return per paginated call. The largest value you can specify is 100. If you specify a value greater than 100, a ValidationException error occurs. The default value is 100.
        public let maxResults: Int?
        /// If the previous response was incomplete (because there is more data to retrieve), Amazon Lookout for Vision returns a pagination token in the response. You can use this pagination token to retrieve the next set of dataset entries.
        public let nextToken: String?
        /// The name of the project that contains the dataset that you want to list.
        public let projectName: String
        /// Perform a "contains" search on the values of the source-ref key within the dataset. For example a value of "IMG_17" returns all JSON Lines where the source-ref key value matches *IMG_17*.
        public let sourceRefContains: String?

        public init(afterCreationDate: Date? = nil, anomalyClass: String? = nil, beforeCreationDate: Date? = nil, datasetType: String, labeled: Bool? = nil, maxResults: Int? = nil, nextToken: String? = nil, projectName: String, sourceRefContains: String? = nil) {
            self.afterCreationDate = afterCreationDate
            self.anomalyClass = anomalyClass
            self.beforeCreationDate = beforeCreationDate
            self.datasetType = datasetType
            self.labeled = labeled
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.projectName = projectName
            self.sourceRefContains = sourceRefContains
        }

        public func validate(name: String) throws {
            try self.validate(self.anomalyClass, name: "anomalyClass", parent: name, max: 10)
            try self.validate(self.anomalyClass, name: "anomalyClass", parent: name, min: 1)
            try self.validate(self.anomalyClass, name: "anomalyClass", parent: name, pattern: "(normal|anomaly)")
            try self.validate(self.datasetType, name: "datasetType", parent: name, max: 10)
            try self.validate(self.datasetType, name: "datasetType", parent: name, min: 1)
            try self.validate(self.datasetType, name: "datasetType", parent: name, pattern: "train|test")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 2048)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^[a-zA-Z0-9\\/\\+\\=]{0,2048}$")
            try self.validate(self.projectName, name: "projectName", parent: name, max: 255)
            try self.validate(self.projectName, name: "projectName", parent: name, min: 1)
            try self.validate(self.projectName, name: "projectName", parent: name, pattern: "[a-zA-Z0-9][a-zA-Z0-9_\\-]*")
            try self.validate(self.sourceRefContains, name: "sourceRefContains", parent: name, max: 2048)
            try self.validate(self.sourceRefContains, name: "sourceRefContains", parent: name, min: 1)
            try self.validate(self.sourceRefContains, name: "sourceRefContains", parent: name, pattern: ".*\\S.*")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListDatasetEntriesResponse: AWSDecodableShape {
        /// A list of the entries (JSON Lines) within the dataset.
        public let datasetEntries: [String]?
        /// If the response is truncated, Amazon Lookout for Vision returns this token that you can use in the subsequent request to retrieve the next set ofdataset entries.
        public let nextToken: String?

        public init(datasetEntries: [String]? = nil, nextToken: String? = nil) {
            self.datasetEntries = datasetEntries
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case datasetEntries = "DatasetEntries"
            case nextToken = "NextToken"
        }
    }

    public struct ListModelsRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "maxResults", location: .querystring(locationName: "maxResults")),
            AWSMemberEncoding(label: "nextToken", location: .querystring(locationName: "nextToken")),
            AWSMemberEncoding(label: "projectName", location: .uri(locationName: "projectName"))
        ]

        /// The maximum number of results to return per paginated call. The largest value you can specify is 100. If you specify a value greater than 100, a ValidationException error occurs. The default value is 100.
        public let maxResults: Int?
        /// If the previous response was incomplete (because there is more data to retrieve), Amazon Lookout for Vision returns a pagination token in the response. You can use this pagination token to retrieve the next set of models.
        public let nextToken: String?
        /// The name of the project that contains the model versions that you want to list.
        public let projectName: String

        public init(maxResults: Int? = nil, nextToken: String? = nil, projectName: String) {
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.projectName = projectName
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 2048)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^[a-zA-Z0-9\\/\\+\\=]{0,2048}$")
            try self.validate(self.projectName, name: "projectName", parent: name, max: 255)
            try self.validate(self.projectName, name: "projectName", parent: name, min: 1)
            try self.validate(self.projectName, name: "projectName", parent: name, pattern: "[a-zA-Z0-9][a-zA-Z0-9_\\-]*")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListModelsResponse: AWSDecodableShape {
        /// A list of model versions in the specified project.
        public let models: [ModelMetadata]?
        /// If the response is truncated, Amazon Lookout for Vision returns this token that you can use in the subsequent request to retrieve the next set of models.
        public let nextToken: String?

        public init(models: [ModelMetadata]? = nil, nextToken: String? = nil) {
            self.models = models
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case models = "Models"
            case nextToken = "NextToken"
        }
    }

    public struct ListProjectsRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "maxResults", location: .querystring(locationName: "maxResults")),
            AWSMemberEncoding(label: "nextToken", location: .querystring(locationName: "nextToken"))
        ]

        /// The maximum number of results to return per paginated call. The largest value you can specify is 100. If you specify a value greater than 100, a ValidationException error occurs. The default value is 100.
        public let maxResults: Int?
        /// If the previous response was incomplete (because there is more data to retrieve), Amazon Lookout for Vision returns a pagination token in the response. You can use this pagination token to retrieve the next set of projects.
        public let nextToken: String?

        public init(maxResults: Int? = nil, nextToken: String? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 2048)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^[a-zA-Z0-9\\/\\+\\=]{0,2048}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListProjectsResponse: AWSDecodableShape {
        /// If the response is truncated, Amazon Lookout for Vision returns this token that you can use in the subsequent request to retrieve the next set of projects.
        public let nextToken: String?
        /// A list of projects in your AWS account.
        public let projects: [ProjectMetadata]?

        public init(nextToken: String? = nil, projects: [ProjectMetadata]? = nil) {
            self.nextToken = nextToken
            self.projects = projects
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "NextToken"
            case projects = "Projects"
        }
    }

    public struct ListTagsForResourceRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "resourceArn", location: .uri(locationName: "resourceArn"))
        ]

        /// The Amazon Resource Name (ARN) of the model for which you want to list tags.
        public let resourceArn: String

        public init(resourceArn: String) {
            self.resourceArn = resourceArn
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, max: 1011)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListTagsForResourceResponse: AWSDecodableShape {
        /// A map of tag keys and values attached to the specified model.
        public let tags: [Tag]?

        public init(tags: [Tag]? = nil) {
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case tags = "Tags"
        }
    }

    public struct ModelDescription: AWSDecodableShape {
        /// The unix timestamp for the date and time that the model was created.
        public let creationTimestamp: Date?
        /// The description for the model.
        public let description: String?
        /// The unix timestamp for the date and time that the evaluation ended.
        public let evaluationEndTimestamp: Date?
        /// The S3 location where Amazon Lookout for Vision saves the manifest file that was used to test the trained model and generate the performance scores.
        public let evaluationManifest: OutputS3Object?
        /// The S3 location where Amazon Lookout for Vision saves the performance metrics.
        public let evaluationResult: OutputS3Object?
        /// The identifer for the AWS Key Management Service (AWS KMS) key that was used to encrypt the model during training.
        public let kmsKeyId: String?
        /// The Amazon Resource Name (ARN) of the model.
        public let modelArn: String?
        /// The version of the model
        public let modelVersion: String?
        /// The S3 location where Amazon Lookout for Vision saves model training files.
        public let outputConfig: OutputConfig?
        /// Performance metrics for the model. Created during training.
        public let performance: ModelPerformance?
        /// The status of the model.
        public let status: ModelStatus?
        /// The status message for the model.
        public let statusMessage: String?

        public init(creationTimestamp: Date? = nil, description: String? = nil, evaluationEndTimestamp: Date? = nil, evaluationManifest: OutputS3Object? = nil, evaluationResult: OutputS3Object? = nil, kmsKeyId: String? = nil, modelArn: String? = nil, modelVersion: String? = nil, outputConfig: OutputConfig? = nil, performance: ModelPerformance? = nil, status: ModelStatus? = nil, statusMessage: String? = nil) {
            self.creationTimestamp = creationTimestamp
            self.description = description
            self.evaluationEndTimestamp = evaluationEndTimestamp
            self.evaluationManifest = evaluationManifest
            self.evaluationResult = evaluationResult
            self.kmsKeyId = kmsKeyId
            self.modelArn = modelArn
            self.modelVersion = modelVersion
            self.outputConfig = outputConfig
            self.performance = performance
            self.status = status
            self.statusMessage = statusMessage
        }

        private enum CodingKeys: String, CodingKey {
            case creationTimestamp = "CreationTimestamp"
            case description = "Description"
            case evaluationEndTimestamp = "EvaluationEndTimestamp"
            case evaluationManifest = "EvaluationManifest"
            case evaluationResult = "EvaluationResult"
            case kmsKeyId = "KmsKeyId"
            case modelArn = "ModelArn"
            case modelVersion = "ModelVersion"
            case outputConfig = "OutputConfig"
            case performance = "Performance"
            case status = "Status"
            case statusMessage = "StatusMessage"
        }
    }

    public struct ModelMetadata: AWSDecodableShape {
        /// The unix timestamp for the date and time that the model was created.
        public let creationTimestamp: Date?
        /// The description for the model.
        public let description: String?
        /// The Amazon Resource Name (ARN) of the model.
        public let modelArn: String?
        /// The version of the model.
        public let modelVersion: String?
        /// Performance metrics for the model. Not available until training has successfully completed.
        public let performance: ModelPerformance?
        /// The status of the model.
        public let status: ModelStatus?
        /// The status message for the model.
        public let statusMessage: String?

        public init(creationTimestamp: Date? = nil, description: String? = nil, modelArn: String? = nil, modelVersion: String? = nil, performance: ModelPerformance? = nil, status: ModelStatus? = nil, statusMessage: String? = nil) {
            self.creationTimestamp = creationTimestamp
            self.description = description
            self.modelArn = modelArn
            self.modelVersion = modelVersion
            self.performance = performance
            self.status = status
            self.statusMessage = statusMessage
        }

        private enum CodingKeys: String, CodingKey {
            case creationTimestamp = "CreationTimestamp"
            case description = "Description"
            case modelArn = "ModelArn"
            case modelVersion = "ModelVersion"
            case performance = "Performance"
            case status = "Status"
            case statusMessage = "StatusMessage"
        }
    }

    public struct ModelPerformance: AWSDecodableShape {
        /// The overall F1 score metric for the trained model.
        public let f1Score: Float?
        /// The overall precision metric value for the trained model.
        public let precision: Float?
        /// The overall recall metric value for the trained model.
        public let recall: Float?

        public init(f1Score: Float? = nil, precision: Float? = nil, recall: Float? = nil) {
            self.f1Score = f1Score
            self.precision = precision
            self.recall = recall
        }

        private enum CodingKeys: String, CodingKey {
            case f1Score = "F1Score"
            case precision = "Precision"
            case recall = "Recall"
        }
    }

    public struct OutputConfig: AWSEncodableShape & AWSDecodableShape {
        /// The S3 location for the output.
        public let s3Location: S3Location

        public init(s3Location: S3Location) {
            self.s3Location = s3Location
        }

        public func validate(name: String) throws {
            try self.s3Location.validate(name: "\(name).s3Location")
        }

        private enum CodingKeys: String, CodingKey {
            case s3Location = "S3Location"
        }
    }

    public struct OutputS3Object: AWSDecodableShape {
        /// The bucket that contains the training output.
        public let bucket: String
        /// The location of the training output in the bucket.
        public let key: String

        public init(bucket: String, key: String) {
            self.bucket = bucket
            self.key = key
        }

        private enum CodingKeys: String, CodingKey {
            case bucket = "Bucket"
            case key = "Key"
        }
    }

    public struct ProjectDescription: AWSDecodableShape {
        /// The unix timestamp for the date and time that the project was created.
        public let creationTimestamp: Date?
        /// A list of datasets in the project.
        public let datasets: [DatasetMetadata]?
        /// The Amazon Resource Name (ARN) of the project.
        public let projectArn: String?
        /// The name of the project.
        public let projectName: String?

        public init(creationTimestamp: Date? = nil, datasets: [DatasetMetadata]? = nil, projectArn: String? = nil, projectName: String? = nil) {
            self.creationTimestamp = creationTimestamp
            self.datasets = datasets
            self.projectArn = projectArn
            self.projectName = projectName
        }

        private enum CodingKeys: String, CodingKey {
            case creationTimestamp = "CreationTimestamp"
            case datasets = "Datasets"
            case projectArn = "ProjectArn"
            case projectName = "ProjectName"
        }
    }

    public struct ProjectMetadata: AWSDecodableShape {
        /// The unix timestamp for the date and time that the project was created.
        public let creationTimestamp: Date?
        /// The Amazon Resource Name (ARN) of the project.
        public let projectArn: String?
        /// The name of the project.
        public let projectName: String?

        public init(creationTimestamp: Date? = nil, projectArn: String? = nil, projectName: String? = nil) {
            self.creationTimestamp = creationTimestamp
            self.projectArn = projectArn
            self.projectName = projectName
        }

        private enum CodingKeys: String, CodingKey {
            case creationTimestamp = "CreationTimestamp"
            case projectArn = "ProjectArn"
            case projectName = "ProjectName"
        }
    }

    public struct S3Location: AWSEncodableShape & AWSDecodableShape {
        /// The S3 bucket that contains the training output.
        public let bucket: String
        /// The path of the folder, within the S3 bucket, that contains the training output.
        public let prefix: String?

        public init(bucket: String, prefix: String? = nil) {
            self.bucket = bucket
            self.prefix = prefix
        }

        public func validate(name: String) throws {
            try self.validate(self.bucket, name: "bucket", parent: name, max: 63)
            try self.validate(self.bucket, name: "bucket", parent: name, min: 3)
            try self.validate(self.bucket, name: "bucket", parent: name, pattern: "[0-9A-Za-z\\.\\-_]*")
            try self.validate(self.prefix, name: "prefix", parent: name, max: 1024)
            try self.validate(self.prefix, name: "prefix", parent: name, pattern: "^([a-zA-Z0-9!_.*'()-][/a-zA-Z0-9!_.*'()-]*)?$")
        }

        private enum CodingKeys: String, CodingKey {
            case bucket = "Bucket"
            case prefix = "Prefix"
        }
    }

    public struct StartModelRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "clientToken", location: .header(locationName: "X-Amzn-Client-Token")),
            AWSMemberEncoding(label: "modelVersion", location: .uri(locationName: "modelVersion")),
            AWSMemberEncoding(label: "projectName", location: .uri(locationName: "projectName"))
        ]

        /// ClientToken is an idempotency token that ensures a call to StartModel completes only once. You choose the value to pass. For example, An issue, such as an network outage, might prevent you from getting a response from StartModel. In this case, safely retry your call to StartModel by using the same ClientToken parameter value. An error occurs if the other input parameters are not the same as in the first request. Using a different value for ClientToken is considered a new call to StartModel. An idempotency token is active for 8 hours.
        public let clientToken: String?
        /// The minimum number of inference units to use. A single inference unit represents 1 hour of processing and can support up to 5 Transaction Pers Second (TPS). Use a higher number to increase the TPS throughput of your model. You are charged for the number of inference units that you use.
        public let minInferenceUnits: Int
        /// The version of the model that you want to start.
        public let modelVersion: String
        /// The name of the project that contains the model that you want to start.
        public let projectName: String

        public init(clientToken: String? = StartModelRequest.idempotencyToken(), minInferenceUnits: Int, modelVersion: String, projectName: String) {
            self.clientToken = clientToken
            self.minInferenceUnits = minInferenceUnits
            self.modelVersion = modelVersion
            self.projectName = projectName
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 64)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "^[a-zA-Z0-9-]+$")
            try self.validate(self.minInferenceUnits, name: "minInferenceUnits", parent: name, min: 1)
            try self.validate(self.modelVersion, name: "modelVersion", parent: name, max: 10)
            try self.validate(self.modelVersion, name: "modelVersion", parent: name, min: 1)
            try self.validate(self.modelVersion, name: "modelVersion", parent: name, pattern: "([1-9][0-9]*|latest)")
            try self.validate(self.projectName, name: "projectName", parent: name, max: 255)
            try self.validate(self.projectName, name: "projectName", parent: name, min: 1)
            try self.validate(self.projectName, name: "projectName", parent: name, pattern: "[a-zA-Z0-9][a-zA-Z0-9_\\-]*")
        }

        private enum CodingKeys: String, CodingKey {
            case minInferenceUnits = "MinInferenceUnits"
        }
    }

    public struct StartModelResponse: AWSDecodableShape {
        /// The current running status of the model.
        public let status: ModelHostingStatus?

        public init(status: ModelHostingStatus? = nil) {
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case status = "Status"
        }
    }

    public struct StopModelRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "clientToken", location: .header(locationName: "X-Amzn-Client-Token")),
            AWSMemberEncoding(label: "modelVersion", location: .uri(locationName: "modelVersion")),
            AWSMemberEncoding(label: "projectName", location: .uri(locationName: "projectName"))
        ]

        /// ClientToken is an idempotency token that ensures a call to StopModel completes only once. You choose the value to pass. For example, An issue, such as an network outage, might prevent you from getting a response from StopModel. In this case, safely retry your call to StopModel by using the same ClientToken parameter value. An error occurs if the other input parameters are not the same as in the first request. Using a different value for ClientToken is considered a new call to StopModel. An idempotency token is active for 8 hours.
        public let clientToken: String?
        /// The version of the model that you want to stop.
        public let modelVersion: String
        /// The name of the project that contains the model that you want to stop.
        public let projectName: String

        public init(clientToken: String? = StopModelRequest.idempotencyToken(), modelVersion: String, projectName: String) {
            self.clientToken = clientToken
            self.modelVersion = modelVersion
            self.projectName = projectName
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 64)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "^[a-zA-Z0-9-]+$")
            try self.validate(self.modelVersion, name: "modelVersion", parent: name, max: 10)
            try self.validate(self.modelVersion, name: "modelVersion", parent: name, min: 1)
            try self.validate(self.modelVersion, name: "modelVersion", parent: name, pattern: "([1-9][0-9]*|latest)")
            try self.validate(self.projectName, name: "projectName", parent: name, max: 255)
            try self.validate(self.projectName, name: "projectName", parent: name, min: 1)
            try self.validate(self.projectName, name: "projectName", parent: name, pattern: "[a-zA-Z0-9][a-zA-Z0-9_\\-]*")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct StopModelResponse: AWSDecodableShape {
        /// The status of the model.
        public let status: ModelHostingStatus?

        public init(status: ModelHostingStatus? = nil) {
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case status = "Status"
        }
    }

    public struct Tag: AWSEncodableShape & AWSDecodableShape {
        /// The key of the tag that is attached to the specified model.
        public let key: String
        /// The value of the tag that is attached to the specified model.
        public let value: String

        public init(key: String, value: String) {
            self.key = key
            self.value = value
        }

        public func validate(name: String) throws {
            try self.validate(self.key, name: "key", parent: name, max: 128)
            try self.validate(self.key, name: "key", parent: name, min: 1)
            try self.validate(self.key, name: "key", parent: name, pattern: "^([\\p{L}\\p{Z}\\p{N}_.:/=+\\-@]*)$")
            try self.validate(self.value, name: "value", parent: name, max: 256)
            try self.validate(self.value, name: "value", parent: name, min: 0)
            try self.validate(self.value, name: "value", parent: name, pattern: "^([\\p{L}\\p{Z}\\p{N}_.:/=+\\-@]*)$")
        }

        private enum CodingKeys: String, CodingKey {
            case key = "Key"
            case value = "Value"
        }
    }

    public struct TagResourceRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "resourceArn", location: .uri(locationName: "resourceArn"))
        ]

        /// The Amazon Resource Name (ARN) of the model to assign the tags.
        public let resourceArn: String
        /// The key-value tags to assign to the model.
        public let tags: [Tag]

        public init(resourceArn: String, tags: [Tag]) {
            self.resourceArn = resourceArn
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, max: 1011)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, min: 1)
            try self.tags.forEach {
                try $0.validate(name: "\(name).tags[]")
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 200)
            try self.validate(self.tags, name: "tags", parent: name, min: 0)
        }

        private enum CodingKeys: String, CodingKey {
            case tags = "Tags"
        }
    }

    public struct TagResourceResponse: AWSDecodableShape {
        public init() {}
    }

    public struct UntagResourceRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "resourceArn", location: .uri(locationName: "resourceArn")),
            AWSMemberEncoding(label: "tagKeys", location: .querystring(locationName: "tagKeys"))
        ]

        /// The Amazon Resource Name (ARN) of the model from which you want to remove tags.
        public let resourceArn: String
        /// A list of the keys of the tags that you want to remove.
        public let tagKeys: [String]

        public init(resourceArn: String, tagKeys: [String]) {
            self.resourceArn = resourceArn
            self.tagKeys = tagKeys
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, max: 1011)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, min: 1)
            try self.tagKeys.forEach {
                try validate($0, name: "tagKeys[]", parent: name, max: 128)
                try validate($0, name: "tagKeys[]", parent: name, min: 1)
                try validate($0, name: "tagKeys[]", parent: name, pattern: "^([\\p{L}\\p{Z}\\p{N}_.:/=+\\-@]*)$")
            }
            try self.validate(self.tagKeys, name: "tagKeys", parent: name, max: 200)
            try self.validate(self.tagKeys, name: "tagKeys", parent: name, min: 0)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct UntagResourceResponse: AWSDecodableShape {
        public init() {}
    }

    public struct UpdateDatasetEntriesRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "clientToken", location: .header(locationName: "X-Amzn-Client-Token")),
            AWSMemberEncoding(label: "datasetType", location: .uri(locationName: "datasetType")),
            AWSMemberEncoding(label: "projectName", location: .uri(locationName: "projectName"))
        ]

        /// The entries to add to the dataset.
        public let changes: Data
        /// ClientToken is an idempotency token that ensures a call to UpdateDatasetEntries completes only once. You choose the value to pass. For example, An issue, such as an network outage, might prevent you from getting a response from UpdateDatasetEntries. In this case, safely retry your call to UpdateDatasetEntries by using the same ClientToken parameter value. An error occurs if the other input parameters are not the same as in the first request. Using a different value for ClientToken is considered a new call to UpdateDatasetEntries. An idempotency token is active for 8 hours.
        public let clientToken: String?
        /// The type of the dataset that you want to update. Specify train to update the training dataset. Specify test to update the test dataset. If you have a single dataset project, specify train.
        public let datasetType: String
        /// The name of the project that contains the dataset that you want to update.
        public let projectName: String

        public init(changes: Data, clientToken: String? = UpdateDatasetEntriesRequest.idempotencyToken(), datasetType: String, projectName: String) {
            self.changes = changes
            self.clientToken = clientToken
            self.datasetType = datasetType
            self.projectName = projectName
        }

        public func validate(name: String) throws {
            try self.validate(self.changes, name: "changes", parent: name, max: 10_485_760)
            try self.validate(self.changes, name: "changes", parent: name, min: 1)
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 64)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "^[a-zA-Z0-9-]+$")
            try self.validate(self.datasetType, name: "datasetType", parent: name, max: 10)
            try self.validate(self.datasetType, name: "datasetType", parent: name, min: 1)
            try self.validate(self.datasetType, name: "datasetType", parent: name, pattern: "train|test")
            try self.validate(self.projectName, name: "projectName", parent: name, max: 255)
            try self.validate(self.projectName, name: "projectName", parent: name, min: 1)
            try self.validate(self.projectName, name: "projectName", parent: name, pattern: "[a-zA-Z0-9][a-zA-Z0-9_\\-]*")
        }

        private enum CodingKeys: String, CodingKey {
            case changes = "Changes"
        }
    }

    public struct UpdateDatasetEntriesResponse: AWSDecodableShape {
        /// The status of the dataset update.
        public let status: DatasetStatus?

        public init(status: DatasetStatus? = nil) {
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case status = "Status"
        }
    }
}
