//===----------------------------------------------------------------------===//
//
// This source file is part of the Soto for AWS open source project
//
// Copyright (c) 2017-2024 the Soto project authors
// Licensed under Apache License v2.0
//
// See LICENSE.txt for license information
// See CONTRIBUTORS.txt for the list of Soto project authors
//
// SPDX-License-Identifier: Apache-2.0
//
//===----------------------------------------------------------------------===//

// THIS FILE IS AUTOMATICALLY GENERATED by https://github.com/soto-project/soto-codegenerator.
// DO NOT EDIT.

#if canImport(FoundationEssentials)
import FoundationEssentials
#else
import Foundation
#endif
@_exported import SotoCore

/// Service object for interacting with AWS Route53GlobalResolver service.
///
///  Amazon Route 53 Global Resolver is a global, internet-accessible DNS resolver that enables customers to resolve and forward traffic for both public and private domains while ensuring security and authenticity of queries over the internet. Route 53 Global Resolver supports DNS-over-port 53 (Do53), DNS-over-TLS (DoT), and DNS-over-HTTPS (DoH) protocols through global anycast IP addresses.
public struct Route53GlobalResolver: AWSService {
    // MARK: Member variables

    /// Client used for communication with AWS
    public let client: AWSClient
    /// Service configuration
    public let config: AWSServiceConfig

    // MARK: Initialization

    /// Initialize the Route53GlobalResolver client
    /// - parameters:
    ///     - client: AWSClient used to process requests
    ///     - region: Region of server you want to communicate with. This will override the partition parameter.
    ///     - partition: AWS partition where service resides, standard (.aws), china (.awscn), government (.awsusgov).
    ///     - endpoint: Custom endpoint URL to use instead of standard AWS servers
    ///     - middleware: Middleware chain used to edit requests before they are sent and responses before they are decoded 
    ///     - timeout: Timeout value for HTTP requests
    ///     - byteBufferAllocator: Allocator for ByteBuffers
    ///     - options: Service options
    public init(
        client: AWSClient,
        region: SotoCore.Region? = nil,
        partition: AWSPartition = .aws,
        endpoint: String? = nil,
        middleware: AWSMiddlewareProtocol? = nil,
        timeout: TimeAmount? = nil,
        byteBufferAllocator: ByteBufferAllocator = ByteBufferAllocator(),
        options: AWSServiceConfig.Options = []
    ) {
        self.client = client
        self.config = AWSServiceConfig(
            region: region,
            partition: region?.partition ?? partition,
            serviceName: "Route53GlobalResolver",
            serviceIdentifier: "route53globalresolver",
            serviceProtocol: .restjson,
            apiVersion: "2022-09-27",
            endpoint: endpoint,
            errorType: Route53GlobalResolverErrorType.self,
            middleware: middleware,
            timeout: timeout,
            byteBufferAllocator: byteBufferAllocator,
            options: options
        )
    }





    // MARK: API Calls

    /// Associates a Route 53 private hosted zone with a Route 53 Global Resolver resource. This allows the resolver to resolve DNS queries for the private hosted zone from anywhere globally.
    @Sendable
    @inlinable
    public func associateHostedZone(_ input: AssociateHostedZoneInput, logger: Logger = AWSClient.loggingDisabled) async throws -> AssociateHostedZoneOutput {
        try await self.client.execute(
            operation: "AssociateHostedZone", 
            path: "/hosted-zone-associations/{hostedZoneId}", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Associates a Route 53 private hosted zone with a Route 53 Global Resolver resource. This allows the resolver to resolve DNS queries for the private hosted zone from anywhere globally.
    ///
    /// Parameters:
    ///   - hostedZoneId: The ID of the Route 53 private hosted zone to associate with the Route 53 Global Resolver resource.
    ///   - name: Name for the private hosted zone association.
    ///   - resourceArn: An Amazon Resource Name (ARN) of the Route 53 Global Resolver the private hosted zone will be associated to.
    ///   - logger: Logger use during operation
    @inlinable
    public func associateHostedZone(
        hostedZoneId: String,
        name: String,
        resourceArn: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> AssociateHostedZoneOutput {
        let input = AssociateHostedZoneInput(
            hostedZoneId: hostedZoneId, 
            name: name, 
            resourceArn: resourceArn
        )
        return try await self.associateHostedZone(input, logger: logger)
    }

    /// Creates multiple DNS firewall rules in a single operation. This is more efficient than creating rules individually when you need to set up multiple rules at once.
    @Sendable
    @inlinable
    public func batchCreateFirewallRule(_ input: BatchCreateFirewallRuleInput, logger: Logger = AWSClient.loggingDisabled) async throws -> BatchCreateFirewallRuleOutput {
        try await self.client.execute(
            operation: "BatchCreateFirewallRule", 
            path: "/firewall-rules/batch-create", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Creates multiple DNS firewall rules in a single operation. This is more efficient than creating rules individually when you need to set up multiple rules at once.
    ///
    /// Parameters:
    ///   - firewallRules: The BatchCreateFirewallRuleInputItem objects contain the information for each Firewall rule.
    ///   - logger: Logger use during operation
    @inlinable
    public func batchCreateFirewallRule(
        firewallRules: [BatchCreateFirewallRuleInputItem],
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> BatchCreateFirewallRuleOutput {
        let input = BatchCreateFirewallRuleInput(
            firewallRules: firewallRules
        )
        return try await self.batchCreateFirewallRule(input, logger: logger)
    }

    /// Deletes multiple DNS firewall rules in a single operation. This is more efficient than deleting rules individually.
    @Sendable
    @inlinable
    public func batchDeleteFirewallRule(_ input: BatchDeleteFirewallRuleInput, logger: Logger = AWSClient.loggingDisabled) async throws -> BatchDeleteFirewallRuleOutput {
        try await self.client.execute(
            operation: "BatchDeleteFirewallRule", 
            path: "/firewall-rules/batch-delete", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Deletes multiple DNS firewall rules in a single operation. This is more efficient than deleting rules individually.
    ///
    /// Parameters:
    ///   - firewallRules: An array of the DNS Firewall IDs to be deleted.
    ///   - logger: Logger use during operation
    @inlinable
    public func batchDeleteFirewallRule(
        firewallRules: [BatchDeleteFirewallRuleInputItem],
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> BatchDeleteFirewallRuleOutput {
        let input = BatchDeleteFirewallRuleInput(
            firewallRules: firewallRules
        )
        return try await self.batchDeleteFirewallRule(input, logger: logger)
    }

    /// Updates multiple DNS firewall rules in a single operation. This is more efficient than updating rules individually.
    @Sendable
    @inlinable
    public func batchUpdateFirewallRule(_ input: BatchUpdateFirewallRuleInput, logger: Logger = AWSClient.loggingDisabled) async throws -> BatchUpdateFirewallRuleOutput {
        try await self.client.execute(
            operation: "BatchUpdateFirewallRule", 
            path: "/firewall-rules/batch-update", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Updates multiple DNS firewall rules in a single operation. This is more efficient than updating rules individually.
    ///
    /// Parameters:
    ///   - firewallRules: The DNS Firewall rule IDs to be updated.
    ///   - logger: Logger use during operation
    @inlinable
    public func batchUpdateFirewallRule(
        firewallRules: [BatchUpdateFirewallRuleInputItem],
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> BatchUpdateFirewallRuleOutput {
        let input = BatchUpdateFirewallRuleInput(
            firewallRules: firewallRules
        )
        return try await self.batchUpdateFirewallRule(input, logger: logger)
    }

    /// Creates an access source for a DNS view. Access sources define IP addresses or CIDR ranges that are allowed to send DNS queries to the Route 53 Global Resolver, along with the permitted DNS protocols.
    @Sendable
    @inlinable
    public func createAccessSource(_ input: CreateAccessSourceInput, logger: Logger = AWSClient.loggingDisabled) async throws -> CreateAccessSourceOutput {
        try await self.client.execute(
            operation: "CreateAccessSource", 
            path: "/access-sources", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Creates an access source for a DNS view. Access sources define IP addresses or CIDR ranges that are allowed to send DNS queries to the Route 53 Global Resolver, along with the permitted DNS protocols.
    ///
    /// Parameters:
    ///   - cidr: The IP address or CIDR range that is allowed to send DNS queries to the Route 53 Global Resolver.
    ///   - clientToken: A unique string that identifies the request and ensures idempotency.
    ///   - dnsViewId: The ID of the DNS view to associate with this access source.
    ///   - ipAddressType: The IP address type for this access source. Valid values are IPv4 and IPv6 (if the Route 53 Global Resolver supports dual-stack).
    ///   - name: A descriptive name for the access source.
    ///   - protocol: The DNS protocol that is permitted for this access source. Valid values are Do53 (DNS over port 53), DoT (DNS over TLS), and DoH (DNS over HTTPS).
    ///   - tags: Tags to associate with the access source.
    ///   - logger: Logger use during operation
    @inlinable
    public func createAccessSource(
        cidr: String,
        clientToken: String? = CreateAccessSourceInput.idempotencyToken(),
        dnsViewId: String,
        ipAddressType: IpAddressType? = nil,
        name: String? = nil,
        protocol: DnsProtocol,
        tags: [String: String]? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> CreateAccessSourceOutput {
        let input = CreateAccessSourceInput(
            cidr: cidr, 
            clientToken: clientToken, 
            dnsViewId: dnsViewId, 
            ipAddressType: ipAddressType, 
            name: name, 
            protocol: `protocol`, 
            tags: tags
        )
        return try await self.createAccessSource(input, logger: logger)
    }

    /// Creates an access token for a DNS view. Access tokens provide token-based authentication for DNS-over-HTTPS (DoH) and DNS-over-TLS (DoT) connections to the Route 53 Global Resolver.
    @Sendable
    @inlinable
    public func createAccessToken(_ input: CreateAccessTokenInput, logger: Logger = AWSClient.loggingDisabled) async throws -> CreateAccessTokenOutput {
        try await self.client.execute(
            operation: "CreateAccessToken", 
            path: "/tokens/{dnsViewId}", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Creates an access token for a DNS view. Access tokens provide token-based authentication for DNS-over-HTTPS (DoH) and DNS-over-TLS (DoT) connections to the Route 53 Global Resolver.
    ///
    /// Parameters:
    ///   - clientToken: A unique, case-sensitive identifier to ensure idempotency. This means that making the same request multiple times with the same clientToken has the same result every time.
    ///   - dnsViewId: The ID of the DNS view to associate with this token.
    ///   - expiresAt: The date and time when the token expires. Tokens can have a minimum expiration of 30 days and maximum of 365 days from creation.
    ///   - name: A descriptive name for the access token.
    ///   - tags: An array of user-defined keys and optional values. These tags can be used for categorization and organization.
    ///   - logger: Logger use during operation
    @inlinable
    public func createAccessToken(
        clientToken: String? = CreateAccessTokenInput.idempotencyToken(),
        dnsViewId: String,
        expiresAt: Date? = nil,
        name: String? = nil,
        tags: [String: String]? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> CreateAccessTokenOutput {
        let input = CreateAccessTokenInput(
            clientToken: clientToken, 
            dnsViewId: dnsViewId, 
            expiresAt: expiresAt, 
            name: name, 
            tags: tags
        )
        return try await self.createAccessToken(input, logger: logger)
    }

    /// Creates a DNS view within a Route 53 Global Resolver. A DNS view models end users, user groups, networks, and devices, and serves as a parent resource that holds configurations controlling access, authorization, DNS firewall rules, and forwarding rules.
    @Sendable
    @inlinable
    public func createDNSView(_ input: CreateDNSViewInput, logger: Logger = AWSClient.loggingDisabled) async throws -> CreateDNSViewOutput {
        try await self.client.execute(
            operation: "CreateDNSView", 
            path: "/dns-views/{globalResolverId}", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Creates a DNS view within a Route 53 Global Resolver. A DNS view models end users, user groups, networks, and devices, and serves as a parent resource that holds configurations controlling access, authorization, DNS firewall rules, and forwarding rules.
    ///
    /// Parameters:
    ///   - clientToken: A unique string that identifies the request and ensures idempotency.
    ///   - description: An optional description for the DNS view.
    ///   - dnssecValidation: Whether to enable DNSSEC validation for DNS queries in this DNS view. When enabled, the resolver verifies the authenticity and integrity of DNS responses from public name servers for DNSSEC-signed domains.
    ///   - ednsClientSubnet: Whether to enable EDNS Client Subnet injection for DNS queries in this DNS view. When enabled, client subnet information is forwarded to provide more accurate geographic-based DNS responses.
    ///   - firewallRulesFailOpen: Determines the behavior when Route 53 Global Resolver cannot apply DNS firewall rules due to service impairment. When enabled, DNS queries are allowed through; when disabled, queries are blocked.
    ///   - globalResolverId: The ID of the Route 53 Global Resolver to associate with this DNS view.
    ///   - name: A descriptive name for the DNS view.
    ///   - tags: Tags to associate with the DNS view.
    ///   - logger: Logger use during operation
    @inlinable
    public func createDNSView(
        clientToken: String? = CreateDNSViewInput.idempotencyToken(),
        description: String? = nil,
        dnssecValidation: DnsSecValidationType? = nil,
        ednsClientSubnet: EdnsClientSubnetType? = nil,
        firewallRulesFailOpen: FirewallRulesFailOpenType? = nil,
        globalResolverId: String,
        name: String,
        tags: [String: String]? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> CreateDNSViewOutput {
        let input = CreateDNSViewInput(
            clientToken: clientToken, 
            description: description, 
            dnssecValidation: dnssecValidation, 
            ednsClientSubnet: ednsClientSubnet, 
            firewallRulesFailOpen: firewallRulesFailOpen, 
            globalResolverId: globalResolverId, 
            name: name, 
            tags: tags
        )
        return try await self.createDNSView(input, logger: logger)
    }

    /// Creates a firewall domain list. Domain lists are reusable sets of domain specifications that you use in DNS firewall rules to allow, block, or alert on DNS queries to specific domains.
    @Sendable
    @inlinable
    public func createFirewallDomainList(_ input: CreateFirewallDomainListInput, logger: Logger = AWSClient.loggingDisabled) async throws -> CreateFirewallDomainListOutput {
        try await self.client.execute(
            operation: "CreateFirewallDomainList", 
            path: "/firewall-domain-lists/{globalResolverId}", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Creates a firewall domain list. Domain lists are reusable sets of domain specifications that you use in DNS firewall rules to allow, block, or alert on DNS queries to specific domains.
    ///
    /// Parameters:
    ///   - clientToken: A unique, case-sensitive identifier to ensure idempotency. This means that making the same request multiple times with the same clientToken has the same result every time.
    ///   - description: An optional description for the firewall domain list.
    ///   - globalResolverId: The ID of the Route 53 Global Resolver that the domain list will be associated with.
    ///   - name: A descriptive name for the firewall domain list.
    ///   - tags: An array of user-defined keys and optional values. These tags can be used for categorization and organization.
    ///   - logger: Logger use during operation
    @inlinable
    public func createFirewallDomainList(
        clientToken: String? = CreateFirewallDomainListInput.idempotencyToken(),
        description: String? = nil,
        globalResolverId: String,
        name: String,
        tags: [String: String]? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> CreateFirewallDomainListOutput {
        let input = CreateFirewallDomainListInput(
            clientToken: clientToken, 
            description: description, 
            globalResolverId: globalResolverId, 
            name: name, 
            tags: tags
        )
        return try await self.createFirewallDomainList(input, logger: logger)
    }

    /// Creates a DNS firewall rule. Firewall rules define actions (ALLOW, BLOCK, or ALERT) to take on DNS queries that match specified domain lists, managed domain lists, or advanced threat protections.
    @Sendable
    @inlinable
    public func createFirewallRule(_ input: CreateFirewallRuleInput, logger: Logger = AWSClient.loggingDisabled) async throws -> CreateFirewallRuleOutput {
        try await self.client.execute(
            operation: "CreateFirewallRule", 
            path: "/firewall-rules", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Creates a DNS firewall rule. Firewall rules define actions (ALLOW, BLOCK, or ALERT) to take on DNS queries that match specified domain lists, managed domain lists, or advanced threat protections.
    ///
    /// Parameters:
    ///   - action: The action that DNS Firewall should take on a DNS query when it matches one of the domains in the rule's domain list:    ALLOW - Permit the request to go through.    ALERT - Permit the request and send metrics and logs to CloudWatch.    BLOCK - Disallow the request. This option requires additional details in the rule's BlockResponse.
    ///   - blockOverrideDnsType: The DNS record's type. This determines the format of the record value that you provided in BlockOverrideDomain. Used for the rule action BLOCK with a BlockResponse setting of OVERRIDE. This setting is required if the BlockResponse setting is OVERRIDE.
    ///   - blockOverrideDomain: The custom DNS record to send back in response to the query. Used for the rule action BLOCK with a BlockResponse setting of OVERRIDE. This setting is required if the BlockResponse setting is OVERRIDE.
    ///   - blockOverrideTtl: The recommended amount of time, in seconds, for the DNS resolver or web browser to cache the provided override record. Used for the rule action BLOCK with a BlockResponse setting of OVERRIDE. This setting is required if the BlockResponse setting is OVERRIDE.
    ///   - blockResponse: The response to return when the action is BLOCK. Valid values are NXDOMAIN (domain does not exist), NODATA (domain exists but no records), or OVERRIDE (return custom response).
    ///   - clientToken: A unique, case-sensitive identifier to ensure idempotency. This means that making the same request multiple times with the same clientToken has the same result every time.
    ///   - confidenceThreshold: The confidence threshold for advanced threat detection. Valid values are HIGH, MEDIUM, or LOW, indicating the accuracy level required for threat detection.
    ///   - description: An optional description for the firewall rule.
    ///   - dnsAdvancedProtection: Whether to enable advanced DNS threat protection for this rule. Advanced protection can detect and block DNS tunneling and Domain Generation Algorithm (DGA) threats.
    ///   - dnsViewId: The ID of the DNS view to associate with this firewall rule.
    ///   - firewallDomainListId: The ID of the firewall domain list to use in this rule.
    ///   - name: A descriptive name for the firewall rule.
    ///   - priority: The priority of this rule. Rules are evaluated in priority order, with lower numbers having higher priority. When a DNS query matches multiple rules, the rule with the highest priority (lowest number) is applied.
    ///   - qType: The DNS query type to match for this rule. Examples include A (IPv4 address), AAAA (IPv6 address), MX (mail exchange), or TXT (text record).
    ///   - logger: Logger use during operation
    @inlinable
    public func createFirewallRule(
        action: FirewallRuleAction,
        blockOverrideDnsType: BlockOverrideDnsQueryType? = nil,
        blockOverrideDomain: String? = nil,
        blockOverrideTtl: Int? = nil,
        blockResponse: FirewallBlockResponse? = nil,
        clientToken: String? = CreateFirewallRuleInput.idempotencyToken(),
        confidenceThreshold: ConfidenceThreshold? = nil,
        description: String? = nil,
        dnsAdvancedProtection: DnsAdvancedProtection? = nil,
        dnsViewId: String,
        firewallDomainListId: String? = nil,
        name: String,
        priority: Int64? = nil,
        qType: String? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> CreateFirewallRuleOutput {
        let input = CreateFirewallRuleInput(
            action: action, 
            blockOverrideDnsType: blockOverrideDnsType, 
            blockOverrideDomain: blockOverrideDomain, 
            blockOverrideTtl: blockOverrideTtl, 
            blockResponse: blockResponse, 
            clientToken: clientToken, 
            confidenceThreshold: confidenceThreshold, 
            description: description, 
            dnsAdvancedProtection: dnsAdvancedProtection, 
            dnsViewId: dnsViewId, 
            firewallDomainListId: firewallDomainListId, 
            name: name, 
            priority: priority, 
            qType: qType
        )
        return try await self.createFirewallRule(input, logger: logger)
    }

    /// Creates a new Route 53 Global Resolver instance. A Route 53 Global Resolver is a global, internet-accessible DNS resolver that provides secure DNS resolution for both public and private domains through global anycast IP addresses.
    @Sendable
    @inlinable
    public func createGlobalResolver(_ input: CreateGlobalResolverInput, logger: Logger = AWSClient.loggingDisabled) async throws -> CreateGlobalResolverOutput {
        try await self.client.execute(
            operation: "CreateGlobalResolver", 
            path: "/global-resolver", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Creates a new Route 53 Global Resolver instance. A Route 53 Global Resolver is a global, internet-accessible DNS resolver that provides secure DNS resolution for both public and private domains through global anycast IP addresses.
    ///
    /// Parameters:
    ///   - clientToken: A unique string that identifies the request and ensures idempotency. If you make multiple requests with the same client token, only one Route 53 Global Resolver is created.
    ///   - description: An optional description for the Route 53 Global Resolver instance. Maximum length of 1024 characters.
    ///   - name: A descriptive name for the Route 53 Global Resolver instance. Maximum length of 64 characters.
    ///   - observabilityRegion: The AWS region where query resolution logs and metrics will be aggregated and delivered. If not specified, logging is not enabled.
    ///   - regions: List of AWS regions where the Route 53 Global Resolver will operate. The resolver will be distributed across these regions to provide global availability and low-latency DNS resolution.
    ///   - tags: Tags to associate with the Route 53 Global Resolver. Tags are key-value pairs that help you organize and identify your resources.
    ///   - logger: Logger use during operation
    @inlinable
    public func createGlobalResolver(
        clientToken: String? = CreateGlobalResolverInput.idempotencyToken(),
        description: String? = nil,
        name: String,
        observabilityRegion: String? = nil,
        regions: [String],
        tags: [String: String]? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> CreateGlobalResolverOutput {
        let input = CreateGlobalResolverInput(
            clientToken: clientToken, 
            description: description, 
            name: name, 
            observabilityRegion: observabilityRegion, 
            regions: regions, 
            tags: tags
        )
        return try await self.createGlobalResolver(input, logger: logger)
    }

    /// Deletes an access source. This operation cannot be undone.
    @Sendable
    @inlinable
    public func deleteAccessSource(_ input: DeleteAccessSourceInput, logger: Logger = AWSClient.loggingDisabled) async throws -> DeleteAccessSourceOutput {
        try await self.client.execute(
            operation: "DeleteAccessSource", 
            path: "/access-sources/{accessSourceId}", 
            httpMethod: .DELETE, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Deletes an access source. This operation cannot be undone.
    ///
    /// Parameters:
    ///   - accessSourceId: The unique identifier of the access source to delete.
    ///   - logger: Logger use during operation
    @inlinable
    public func deleteAccessSource(
        accessSourceId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> DeleteAccessSourceOutput {
        let input = DeleteAccessSourceInput(
            accessSourceId: accessSourceId
        )
        return try await self.deleteAccessSource(input, logger: logger)
    }

    /// Deletes an access token. This operation cannot be undone.
    @Sendable
    @inlinable
    public func deleteAccessToken(_ input: DeleteAccessTokenInput, logger: Logger = AWSClient.loggingDisabled) async throws -> DeleteAccessTokenOutput {
        try await self.client.execute(
            operation: "DeleteAccessToken", 
            path: "/tokens/{accessTokenId}", 
            httpMethod: .DELETE, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Deletes an access token. This operation cannot be undone.
    ///
    /// Parameters:
    ///   - accessTokenId: The unique identifier of the access token to delete.
    ///   - logger: Logger use during operation
    @inlinable
    public func deleteAccessToken(
        accessTokenId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> DeleteAccessTokenOutput {
        let input = DeleteAccessTokenInput(
            accessTokenId: accessTokenId
        )
        return try await self.deleteAccessToken(input, logger: logger)
    }

    /// Deletes a DNS view. This operation cannot be undone.
    @Sendable
    @inlinable
    public func deleteDNSView(_ input: DeleteDNSViewInput, logger: Logger = AWSClient.loggingDisabled) async throws -> DeleteDNSViewOutput {
        try await self.client.execute(
            operation: "DeleteDNSView", 
            path: "/dns-views/{dnsViewId}", 
            httpMethod: .DELETE, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Deletes a DNS view. This operation cannot be undone.
    ///
    /// Parameters:
    ///   - dnsViewId: The unique identifier of the DNS view to delete.
    ///   - logger: Logger use during operation
    @inlinable
    public func deleteDNSView(
        dnsViewId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> DeleteDNSViewOutput {
        let input = DeleteDNSViewInput(
            dnsViewId: dnsViewId
        )
        return try await self.deleteDNSView(input, logger: logger)
    }

    /// Deletes a firewall domain list. This operation cannot be undone.
    @Sendable
    @inlinable
    public func deleteFirewallDomainList(_ input: DeleteFirewallDomainListInput, logger: Logger = AWSClient.loggingDisabled) async throws -> DeleteFirewallDomainListOutput {
        try await self.client.execute(
            operation: "DeleteFirewallDomainList", 
            path: "/firewall-domain-lists/{firewallDomainListId}", 
            httpMethod: .DELETE, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Deletes a firewall domain list. This operation cannot be undone.
    ///
    /// Parameters:
    ///   - firewallDomainListId: The unique identifier of the firewall domain list to delete.
    ///   - logger: Logger use during operation
    @inlinable
    public func deleteFirewallDomainList(
        firewallDomainListId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> DeleteFirewallDomainListOutput {
        let input = DeleteFirewallDomainListInput(
            firewallDomainListId: firewallDomainListId
        )
        return try await self.deleteFirewallDomainList(input, logger: logger)
    }

    /// Deletes a DNS firewall rule. This operation cannot be undone.
    @Sendable
    @inlinable
    public func deleteFirewallRule(_ input: DeleteFirewallRuleInput, logger: Logger = AWSClient.loggingDisabled) async throws -> DeleteFirewallRuleOutput {
        try await self.client.execute(
            operation: "DeleteFirewallRule", 
            path: "/firewall-rules/{firewallRuleId}", 
            httpMethod: .DELETE, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Deletes a DNS firewall rule. This operation cannot be undone.
    ///
    /// Parameters:
    ///   - firewallRuleId: The unique identifier of the firewall rule to delete.
    ///   - logger: Logger use during operation
    @inlinable
    public func deleteFirewallRule(
        firewallRuleId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> DeleteFirewallRuleOutput {
        let input = DeleteFirewallRuleInput(
            firewallRuleId: firewallRuleId
        )
        return try await self.deleteFirewallRule(input, logger: logger)
    }

    /// Deletes a Route 53 Global Resolver instance. This operation cannot be undone. All associated DNS views, access sources, tokens, and firewall rules are also deleted.
    @Sendable
    @inlinable
    public func deleteGlobalResolver(_ input: DeleteGlobalResolverInput, logger: Logger = AWSClient.loggingDisabled) async throws -> DeleteGlobalResolverOutput {
        try await self.client.execute(
            operation: "DeleteGlobalResolver", 
            path: "/global-resolver/{globalResolverId}", 
            httpMethod: .DELETE, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Deletes a Route 53 Global Resolver instance. This operation cannot be undone. All associated DNS views, access sources, tokens, and firewall rules are also deleted.
    ///
    /// Parameters:
    ///   - globalResolverId: The unique identifier of the Route 53 Global Resolver to delete.
    ///   - logger: Logger use during operation
    @inlinable
    public func deleteGlobalResolver(
        globalResolverId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> DeleteGlobalResolverOutput {
        let input = DeleteGlobalResolverInput(
            globalResolverId: globalResolverId
        )
        return try await self.deleteGlobalResolver(input, logger: logger)
    }

    /// Disables a DNS view, preventing it from serving DNS queries.
    @Sendable
    @inlinable
    public func disableDNSView(_ input: DisableDNSViewInput, logger: Logger = AWSClient.loggingDisabled) async throws -> DisableDNSViewOutput {
        try await self.client.execute(
            operation: "DisableDNSView", 
            path: "/dns-views/{dnsViewId}/disable", 
            httpMethod: .PATCH, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Disables a DNS view, preventing it from serving DNS queries.
    ///
    /// Parameters:
    ///   - dnsViewId: The unique identifier of the DNS view to disable.
    ///   - logger: Logger use during operation
    @inlinable
    public func disableDNSView(
        dnsViewId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> DisableDNSViewOutput {
        let input = DisableDNSViewInput(
            dnsViewId: dnsViewId
        )
        return try await self.disableDNSView(input, logger: logger)
    }

    /// Disassociates a Route 53 private hosted zone from a Route 53 Global Resolver resource.
    @Sendable
    @inlinable
    public func disassociateHostedZone(_ input: DisassociateHostedZoneInput, logger: Logger = AWSClient.loggingDisabled) async throws -> DisassociateHostedZoneOutput {
        try await self.client.execute(
            operation: "DisassociateHostedZone", 
            path: "/hosted-zone-associations/hosted-zone/{hostedZoneId}/resource-arn/{resourceArn+}", 
            httpMethod: .DELETE, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Disassociates a Route 53 private hosted zone from a Route 53 Global Resolver resource.
    ///
    /// Parameters:
    ///   - hostedZoneId: The ID of the Route 53 private hosted zone to disassociate.
    ///   - resourceArn: The Amazon Resource Name (ARN) of the Route 53 Global Resolver resource to disassociate the hosted zone from.
    ///   - logger: Logger use during operation
    @inlinable
    public func disassociateHostedZone(
        hostedZoneId: String,
        resourceArn: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> DisassociateHostedZoneOutput {
        let input = DisassociateHostedZoneInput(
            hostedZoneId: hostedZoneId, 
            resourceArn: resourceArn
        )
        return try await self.disassociateHostedZone(input, logger: logger)
    }

    /// Enables a disabled DNS view, allowing it to serve DNS queries again.
    @Sendable
    @inlinable
    public func enableDNSView(_ input: EnableDNSViewInput, logger: Logger = AWSClient.loggingDisabled) async throws -> EnableDNSViewOutput {
        try await self.client.execute(
            operation: "EnableDNSView", 
            path: "/dns-views/{dnsViewId}/enable", 
            httpMethod: .PATCH, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Enables a disabled DNS view, allowing it to serve DNS queries again.
    ///
    /// Parameters:
    ///   - dnsViewId: The unique identifier of the DNS view to enable.
    ///   - logger: Logger use during operation
    @inlinable
    public func enableDNSView(
        dnsViewId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> EnableDNSViewOutput {
        let input = EnableDNSViewInput(
            dnsViewId: dnsViewId
        )
        return try await self.enableDNSView(input, logger: logger)
    }

    /// Retrieves information about an access source.
    @Sendable
    @inlinable
    public func getAccessSource(_ input: GetAccessSourceInput, logger: Logger = AWSClient.loggingDisabled) async throws -> GetAccessSourceOutput {
        try await self.client.execute(
            operation: "GetAccessSource", 
            path: "/access-sources/{accessSourceId}", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Retrieves information about an access source.
    ///
    /// Parameters:
    ///   - accessSourceId: The unique identifier of the access source to retrieve.
    ///   - logger: Logger use during operation
    @inlinable
    public func getAccessSource(
        accessSourceId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> GetAccessSourceOutput {
        let input = GetAccessSourceInput(
            accessSourceId: accessSourceId
        )
        return try await self.getAccessSource(input, logger: logger)
    }

    /// Retrieves information about an access token.
    @Sendable
    @inlinable
    public func getAccessToken(_ input: GetAccessTokenInput, logger: Logger = AWSClient.loggingDisabled) async throws -> GetAccessTokenOutput {
        try await self.client.execute(
            operation: "GetAccessToken", 
            path: "/tokens/{accessTokenId}", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Retrieves information about an access token.
    ///
    /// Parameters:
    ///   - accessTokenId: ID of the token.
    ///   - logger: Logger use during operation
    @inlinable
    public func getAccessToken(
        accessTokenId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> GetAccessTokenOutput {
        let input = GetAccessTokenInput(
            accessTokenId: accessTokenId
        )
        return try await self.getAccessToken(input, logger: logger)
    }

    /// Retrieves information about a DNS view.
    @Sendable
    @inlinable
    public func getDNSView(_ input: GetDNSViewInput, logger: Logger = AWSClient.loggingDisabled) async throws -> GetDNSViewOutput {
        try await self.client.execute(
            operation: "GetDNSView", 
            path: "/dns-views/{dnsViewId}", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Retrieves information about a DNS view.
    ///
    /// Parameters:
    ///   - dnsViewId: The ID of the DNS view to retrieve information about.
    ///   - logger: Logger use during operation
    @inlinable
    public func getDNSView(
        dnsViewId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> GetDNSViewOutput {
        let input = GetDNSViewInput(
            dnsViewId: dnsViewId
        )
        return try await self.getDNSView(input, logger: logger)
    }

    /// Retrieves information about a firewall domain list.
    @Sendable
    @inlinable
    public func getFirewallDomainList(_ input: GetFirewallDomainListInput, logger: Logger = AWSClient.loggingDisabled) async throws -> GetFirewallDomainListOutput {
        try await self.client.execute(
            operation: "GetFirewallDomainList", 
            path: "/firewall-domain-lists/{firewallDomainListId}", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Retrieves information about a firewall domain list.
    ///
    /// Parameters:
    ///   - firewallDomainListId: ID of the domain list.
    ///   - logger: Logger use during operation
    @inlinable
    public func getFirewallDomainList(
        firewallDomainListId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> GetFirewallDomainListOutput {
        let input = GetFirewallDomainListInput(
            firewallDomainListId: firewallDomainListId
        )
        return try await self.getFirewallDomainList(input, logger: logger)
    }

    /// Retrieves information about a DNS firewall rule.
    @Sendable
    @inlinable
    public func getFirewallRule(_ input: GetFirewallRuleInput, logger: Logger = AWSClient.loggingDisabled) async throws -> GetFirewallRuleOutput {
        try await self.client.execute(
            operation: "GetFirewallRule", 
            path: "/firewall-rules/{firewallRuleId}", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Retrieves information about a DNS firewall rule.
    ///
    /// Parameters:
    ///   - firewallRuleId: ID of the DNS Firewall rule.
    ///   - logger: Logger use during operation
    @inlinable
    public func getFirewallRule(
        firewallRuleId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> GetFirewallRuleOutput {
        let input = GetFirewallRuleInput(
            firewallRuleId: firewallRuleId
        )
        return try await self.getFirewallRule(input, logger: logger)
    }

    /// Retrieves information about a Route 53 Global Resolver instance.
    @Sendable
    @inlinable
    public func getGlobalResolver(_ input: GetGlobalResolverInput, logger: Logger = AWSClient.loggingDisabled) async throws -> GetGlobalResolverOutput {
        try await self.client.execute(
            operation: "GetGlobalResolver", 
            path: "/global-resolver/{globalResolverId}", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Retrieves information about a Route 53 Global Resolver instance.
    ///
    /// Parameters:
    ///   - globalResolverId: The ID of the Route 53 Global Resolver to retrieve information about.
    ///   - logger: Logger use during operation
    @inlinable
    public func getGlobalResolver(
        globalResolverId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> GetGlobalResolverOutput {
        let input = GetGlobalResolverInput(
            globalResolverId: globalResolverId
        )
        return try await self.getGlobalResolver(input, logger: logger)
    }

    /// Retrieves information about a hosted zone association.
    @Sendable
    @inlinable
    public func getHostedZoneAssociation(_ input: GetHostedZoneAssociationInput, logger: Logger = AWSClient.loggingDisabled) async throws -> GetHostedZoneAssociationOutput {
        try await self.client.execute(
            operation: "GetHostedZoneAssociation", 
            path: "/hosted-zone-associations/{hostedZoneAssociationId}", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Retrieves information about a hosted zone association.
    ///
    /// Parameters:
    ///   - hostedZoneAssociationId: ID of the private hosted zone association.
    ///   - logger: Logger use during operation
    @inlinable
    public func getHostedZoneAssociation(
        hostedZoneAssociationId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> GetHostedZoneAssociationOutput {
        let input = GetHostedZoneAssociationInput(
            hostedZoneAssociationId: hostedZoneAssociationId
        )
        return try await self.getHostedZoneAssociation(input, logger: logger)
    }

    /// Retrieves information about an AWS-managed firewall domain list. Managed domain lists contain domains associated with malicious activity, content categories, or specific threats.
    @Sendable
    @inlinable
    public func getManagedFirewallDomainList(_ input: GetManagedFirewallDomainListInput, logger: Logger = AWSClient.loggingDisabled) async throws -> GetManagedFirewallDomainListOutput {
        try await self.client.execute(
            operation: "GetManagedFirewallDomainList", 
            path: "/managed-firewall-domain-lists/{managedFirewallDomainListId}", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Retrieves information about an AWS-managed firewall domain list. Managed domain lists contain domains associated with malicious activity, content categories, or specific threats.
    ///
    /// Parameters:
    ///   - managedFirewallDomainListId: ID of the Managed Domain List.
    ///   - logger: Logger use during operation
    @inlinable
    public func getManagedFirewallDomainList(
        managedFirewallDomainListId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> GetManagedFirewallDomainListOutput {
        let input = GetManagedFirewallDomainListInput(
            managedFirewallDomainListId: managedFirewallDomainListId
        )
        return try await self.getManagedFirewallDomainList(input, logger: logger)
    }

    /// Imports a list of domains from an Amazon S3 file into a firewall domain list. The file should contain one domain per line.
    @Sendable
    @inlinable
    public func importFirewallDomains(_ input: ImportFirewallDomainsInput, logger: Logger = AWSClient.loggingDisabled) async throws -> ImportFirewallDomainsOutput {
        try await self.client.execute(
            operation: "ImportFirewallDomains", 
            path: "/firewall-domain-lists/{firewallDomainListId}/domains/s3_file_url", 
            httpMethod: .PATCH, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Imports a list of domains from an Amazon S3 file into a firewall domain list. The file should contain one domain per line.
    ///
    /// Parameters:
    ///   - domainFileUrl: The fully qualified URL of the file in Amazon S3 that contains the list of domains to import. The file should contain one domain per line.
    ///   - firewallDomainListId: ID of the DNS Firewall domain list that you want to import the domain list to.
    ///   - operation: This value is REPLACE, and it updates the domain list to match the list of domains in the imported file.
    ///   - logger: Logger use during operation
    @inlinable
    public func importFirewallDomains(
        domainFileUrl: String,
        firewallDomainListId: String,
        operation: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ImportFirewallDomainsOutput {
        let input = ImportFirewallDomainsInput(
            domainFileUrl: domainFileUrl, 
            firewallDomainListId: firewallDomainListId, 
            operation: operation
        )
        return try await self.importFirewallDomains(input, logger: logger)
    }

    /// Lists all access sources with pagination support.
    @Sendable
    @inlinable
    public func listAccessSources(_ input: ListAccessSourcesInput, logger: Logger = AWSClient.loggingDisabled) async throws -> ListAccessSourcesOutput {
        try await self.client.execute(
            operation: "ListAccessSources", 
            path: "/access-sources", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Lists all access sources with pagination support.
    ///
    /// Parameters:
    ///   - filters: Values to filter the results.
    ///   - maxResults: The maximum number of results to retrieve in a single call.
    ///   - nextToken: A pagination token used for large sets of results that can't be returned in a single response.
    ///   - logger: Logger use during operation
    @inlinable
    public func listAccessSources(
        filters: [String: [String]]? = nil,
        maxResults: Int? = nil,
        nextToken: String? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ListAccessSourcesOutput {
        let input = ListAccessSourcesInput(
            filters: filters, 
            maxResults: maxResults, 
            nextToken: nextToken
        )
        return try await self.listAccessSources(input, logger: logger)
    }

    /// Lists all access tokens for a DNS view with pagination support.
    @Sendable
    @inlinable
    public func listAccessTokens(_ input: ListAccessTokensInput, logger: Logger = AWSClient.loggingDisabled) async throws -> ListAccessTokensOutput {
        try await self.client.execute(
            operation: "ListAccessTokens", 
            path: "/tokens/dns-view/{dnsViewId}", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Lists all access tokens for a DNS view with pagination support.
    ///
    /// Parameters:
    ///   - dnsViewId: The ID of the DNS view to list the tokens for.
    ///   - filters: Filtering parameters.
    ///   - maxResults: The maximum number of results to retrieve in a single call.
    ///   - nextToken: A pagination token used for large sets of results that can't be returned in a single response.
    ///   - logger: Logger use during operation
    @inlinable
    public func listAccessTokens(
        dnsViewId: String,
        filters: [String: [String]]? = nil,
        maxResults: Int? = nil,
        nextToken: String? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ListAccessTokensOutput {
        let input = ListAccessTokensInput(
            dnsViewId: dnsViewId, 
            filters: filters, 
            maxResults: maxResults, 
            nextToken: nextToken
        )
        return try await self.listAccessTokens(input, logger: logger)
    }

    /// Lists all DNS views for a Route 53 Global Resolver with pagination support.
    @Sendable
    @inlinable
    public func listDNSViews(_ input: ListDNSViewsInput, logger: Logger = AWSClient.loggingDisabled) async throws -> ListDNSViewsOutput {
        try await self.client.execute(
            operation: "ListDNSViews", 
            path: "/dns-views/resolver/{globalResolverId}", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Lists all DNS views for a Route 53 Global Resolver with pagination support.
    ///
    /// Parameters:
    ///   - globalResolverId: The Global Resolver ID.
    ///   - maxResults: The maximum number of results to retrieve in a single call.
    ///   - nextToken: A pagination token used for large sets of results that can't be returned in a single response.
    ///   - logger: Logger use during operation
    @inlinable
    public func listDNSViews(
        globalResolverId: String,
        maxResults: Int? = nil,
        nextToken: String? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ListDNSViewsOutput {
        let input = ListDNSViewsInput(
            globalResolverId: globalResolverId, 
            maxResults: maxResults, 
            nextToken: nextToken
        )
        return try await self.listDNSViews(input, logger: logger)
    }

    /// Lists all firewall domain lists for a Route 53 Global Resolver with pagination support.
    @Sendable
    @inlinable
    public func listFirewallDomainLists(_ input: ListFirewallDomainListsInput, logger: Logger = AWSClient.loggingDisabled) async throws -> ListFirewallDomainListsOutput {
        try await self.client.execute(
            operation: "ListFirewallDomainLists", 
            path: "/firewall-domain-lists", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Lists all firewall domain lists for a Route 53 Global Resolver with pagination support.
    ///
    /// Parameters:
    ///   - globalResolverId: The ID of the Global Resolver that contains the DNS view the domain lists are associated to.
    ///   - maxResults: The maximum number of results to retrieve in a single call.
    ///   - nextToken: A pagination token used for large sets of results that can't be returned in a single response.
    ///   - logger: Logger use during operation
    @inlinable
    public func listFirewallDomainLists(
        globalResolverId: String? = nil,
        maxResults: Int? = nil,
        nextToken: String? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ListFirewallDomainListsOutput {
        let input = ListFirewallDomainListsInput(
            globalResolverId: globalResolverId, 
            maxResults: maxResults, 
            nextToken: nextToken
        )
        return try await self.listFirewallDomainLists(input, logger: logger)
    }

    /// Lists all the domains in DNS Firewall domain list you have created.
    @Sendable
    @inlinable
    public func listFirewallDomains(_ input: ListFirewallDomainsInput, logger: Logger = AWSClient.loggingDisabled) async throws -> ListFirewallDomainsOutput {
        try await self.client.execute(
            operation: "ListFirewallDomains", 
            path: "/firewall-domain-lists/{firewallDomainListId}/domains", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Lists all the domains in DNS Firewall domain list you have created.
    ///
    /// Parameters:
    ///   - firewallDomainListId: ID of the DNS Firewall domain list.
    ///   - maxResults: The maximum number of results to retrieve in a single call.
    ///   - nextToken: A pagination token used for large sets of results that can't be returned in a single response.
    ///   - logger: Logger use during operation
    @inlinable
    public func listFirewallDomains(
        firewallDomainListId: String,
        maxResults: Int? = nil,
        nextToken: String? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ListFirewallDomainsOutput {
        let input = ListFirewallDomainsInput(
            firewallDomainListId: firewallDomainListId, 
            maxResults: maxResults, 
            nextToken: nextToken
        )
        return try await self.listFirewallDomains(input, logger: logger)
    }

    /// Lists all DNS firewall rules for a DNS view with pagination support.
    @Sendable
    @inlinable
    public func listFirewallRules(_ input: ListFirewallRulesInput, logger: Logger = AWSClient.loggingDisabled) async throws -> ListFirewallRulesOutput {
        try await self.client.execute(
            operation: "ListFirewallRules", 
            path: "/firewall-rules", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Lists all DNS firewall rules for a DNS view with pagination support.
    ///
    /// Parameters:
    ///   - dnsViewId: ID of the DNS view.
    ///   - filters: Values to filter the results.
    ///   - maxResults: The maximum number of results to retrieve in a single call.
    ///   - nextToken: A pagination token used for large sets of results that can't be returned in a single response.
    ///   - logger: Logger use during operation
    @inlinable
    public func listFirewallRules(
        dnsViewId: String,
        filters: [String: [String]]? = nil,
        maxResults: Int? = nil,
        nextToken: String? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ListFirewallRulesOutput {
        let input = ListFirewallRulesInput(
            dnsViewId: dnsViewId, 
            filters: filters, 
            maxResults: maxResults, 
            nextToken: nextToken
        )
        return try await self.listFirewallRules(input, logger: logger)
    }

    /// Lists all Route 53 Global Resolver instances in your account with pagination support.
    @Sendable
    @inlinable
    public func listGlobalResolvers(_ input: ListGlobalResolversInput, logger: Logger = AWSClient.loggingDisabled) async throws -> ListGlobalResolversOutput {
        try await self.client.execute(
            operation: "ListGlobalResolvers", 
            path: "/global-resolver", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Lists all Route 53 Global Resolver instances in your account with pagination support.
    ///
    /// Parameters:
    ///   - maxResults: The maximum number of Route 53 Global Resolver instances to return in the response. Valid range is 1-100.
    ///   - nextToken: The token for the next page of results. This value is returned in the response if there are more results to retrieve.
    ///   - logger: Logger use during operation
    @inlinable
    public func listGlobalResolvers(
        maxResults: Int? = nil,
        nextToken: String? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ListGlobalResolversOutput {
        let input = ListGlobalResolversInput(
            maxResults: maxResults, 
            nextToken: nextToken
        )
        return try await self.listGlobalResolvers(input, logger: logger)
    }

    /// Lists all hosted zone associations for a Route 53 Global Resolver resource with pagination support.
    @Sendable
    @inlinable
    public func listHostedZoneAssociations(_ input: ListHostedZoneAssociationsInput, logger: Logger = AWSClient.loggingDisabled) async throws -> ListHostedZoneAssociationsOutput {
        try await self.client.execute(
            operation: "ListHostedZoneAssociations", 
            path: "/hosted-zone-associations/resource-arn/{resourceArn+}", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Lists all hosted zone associations for a Route 53 Global Resolver resource with pagination support.
    ///
    /// Parameters:
    ///   - maxResults: The maximum number of results to retrieve in a single call.
    ///   - nextToken: A pagination token used for large sets of results that can't be returned in a single response.
    ///   - resourceArn: Amazon Resource Name (ARN) of the DNS view.
    ///   - logger: Logger use during operation
    @inlinable
    public func listHostedZoneAssociations(
        maxResults: Int? = nil,
        nextToken: String? = nil,
        resourceArn: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ListHostedZoneAssociationsOutput {
        let input = ListHostedZoneAssociationsInput(
            maxResults: maxResults, 
            nextToken: nextToken, 
            resourceArn: resourceArn
        )
        return try await self.listHostedZoneAssociations(input, logger: logger)
    }

    /// Returns a paginated list of the AWS Managed DNS Lists and the categories for DNS Firewall. The categories are either THREAT or CONTENT.
    @Sendable
    @inlinable
    public func listManagedFirewallDomainLists(_ input: ListManagedFirewallDomainListsInput, logger: Logger = AWSClient.loggingDisabled) async throws -> ListManagedFirewallDomainListsOutput {
        try await self.client.execute(
            operation: "ListManagedFirewallDomainLists", 
            path: "/list-managed-firewall-domain-lists/{managedFirewallDomainListType}", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Returns a paginated list of the AWS Managed DNS Lists and the categories for DNS Firewall. The categories are either THREAT or CONTENT.
    ///
    /// Parameters:
    ///   - managedFirewallDomainListType: The category of the Manage DNS list either THREAT or CONTENT.
    ///   - maxResults: The maximum number of results to retrieve in a single call.
    ///   - nextToken: A pagination token used for large sets of results that can't be returned in a single response.
    ///   - logger: Logger use during operation
    @inlinable
    public func listManagedFirewallDomainLists(
        managedFirewallDomainListType: String,
        maxResults: Int? = nil,
        nextToken: String? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ListManagedFirewallDomainListsOutput {
        let input = ListManagedFirewallDomainListsInput(
            managedFirewallDomainListType: managedFirewallDomainListType, 
            maxResults: maxResults, 
            nextToken: nextToken
        )
        return try await self.listManagedFirewallDomainLists(input, logger: logger)
    }

    /// Lists the tags associated with a Route 53 Global Resolver resource.
    @Sendable
    @inlinable
    public func listTagsForResource(_ input: ListTagsForResourceRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> ListTagsForResourceResponse {
        try await self.client.execute(
            operation: "ListTagsForResource", 
            path: "/get-all-tags", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Lists the tags associated with a Route 53 Global Resolver resource.
    ///
    /// Parameters:
    ///   - resourceArn: Amazon Resource Name (ARN) for the resource.
    ///   - logger: Logger use during operation
    @inlinable
    public func listTagsForResource(
        resourceArn: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ListTagsForResourceResponse {
        let input = ListTagsForResourceRequest(
            resourceArn: resourceArn
        )
        return try await self.listTagsForResource(input, logger: logger)
    }

    /// Adds or updates tags for a Route 53 Global Resolver resource. Tags are key-value pairs that help you organize and identify your resources.
    @Sendable
    @inlinable
    public func tagResource(_ input: TagResourceRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> TagResourceResponse {
        try await self.client.execute(
            operation: "TagResource", 
            path: "/tag-resource", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Adds or updates tags for a Route 53 Global Resolver resource. Tags are key-value pairs that help you organize and identify your resources.
    ///
    /// Parameters:
    ///   - resourceArn: Amazon Resource Name (ARN) of the resource to be tagged.
    ///   - tags: An array of user-defined keys and optional values. These tags can be used for categorization and organization.
    ///   - logger: Logger use during operation
    @inlinable
    public func tagResource(
        resourceArn: String,
        tags: [String: String],
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> TagResourceResponse {
        let input = TagResourceRequest(
            resourceArn: resourceArn, 
            tags: tags
        )
        return try await self.tagResource(input, logger: logger)
    }

    /// Removes tags from a Route 53 Global Resolver resource.
    @Sendable
    @inlinable
    public func untagResource(_ input: UntagResourceRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> UntagResourceResponse {
        try await self.client.execute(
            operation: "UntagResource", 
            path: "/untag-resource", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Removes tags from a Route 53 Global Resolver resource.
    ///
    /// Parameters:
    ///   - resourceArn: Amazon Resource Name (ARN) of the resource.
    ///   - tagKeys: The tag keys associated with the resource.
    ///   - logger: Logger use during operation
    @inlinable
    public func untagResource(
        resourceArn: String,
        tagKeys: [String],
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> UntagResourceResponse {
        let input = UntagResourceRequest(
            resourceArn: resourceArn, 
            tagKeys: tagKeys
        )
        return try await self.untagResource(input, logger: logger)
    }

    /// Updates the configuration of an access source.
    @Sendable
    @inlinable
    public func updateAccessSource(_ input: UpdateAccessSourceInput, logger: Logger = AWSClient.loggingDisabled) async throws -> UpdateAccessSourceOutput {
        try await self.client.execute(
            operation: "UpdateAccessSource", 
            path: "/access-sources/{accessSourceId}", 
            httpMethod: .PATCH, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Updates the configuration of an access source.
    ///
    /// Parameters:
    ///   - accessSourceId: The unique identifier of the access source to update.
    ///   - cidr: The CIDR block for the access source.
    ///   - ipAddressType: The IP address type for the access source.
    ///   - name: The name of the access source.
    ///   - protocol: The protocol for the access source.
    ///   - logger: Logger use during operation
    @inlinable
    public func updateAccessSource(
        accessSourceId: String,
        cidr: String? = nil,
        ipAddressType: IpAddressType? = nil,
        name: String? = nil,
        protocol: DnsProtocol? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> UpdateAccessSourceOutput {
        let input = UpdateAccessSourceInput(
            accessSourceId: accessSourceId, 
            cidr: cidr, 
            ipAddressType: ipAddressType, 
            name: name, 
            protocol: `protocol`
        )
        return try await self.updateAccessSource(input, logger: logger)
    }

    /// Updates the configuration of an access token.
    @Sendable
    @inlinable
    public func updateAccessToken(_ input: UpdateAccessTokenInput, logger: Logger = AWSClient.loggingDisabled) async throws -> UpdateAccessTokenOutput {
        try await self.client.execute(
            operation: "UpdateAccessToken", 
            path: "/tokens/{accessTokenId}", 
            httpMethod: .PATCH, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Updates the configuration of an access token.
    ///
    /// Parameters:
    ///   - accessTokenId: The ID of the token.
    ///   - name: The new name of the token.
    ///   - logger: Logger use during operation
    @inlinable
    public func updateAccessToken(
        accessTokenId: String,
        name: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> UpdateAccessTokenOutput {
        let input = UpdateAccessTokenInput(
            accessTokenId: accessTokenId, 
            name: name
        )
        return try await self.updateAccessToken(input, logger: logger)
    }

    /// Updates the configuration of a DNS view.
    @Sendable
    @inlinable
    public func updateDNSView(_ input: UpdateDNSViewInput, logger: Logger = AWSClient.loggingDisabled) async throws -> UpdateDNSViewOutput {
        try await self.client.execute(
            operation: "UpdateDNSView", 
            path: "/dns-views/{dnsViewId}", 
            httpMethod: .PATCH, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Updates the configuration of a DNS view.
    ///
    /// Parameters:
    ///   - description: A description of the DNS view.
    ///   - dnssecValidation: Whether to enable DNSSEC validation for the DNS view.
    ///   - dnsViewId: The unique identifier of the DNS view to update.
    ///   - ednsClientSubnet: Whether to enable EDNS Client Subnet injection for the DNS view.
    ///   - firewallRulesFailOpen: Whether firewall rules should fail open when they cannot be evaluated.
    ///   - name: The name of the DNS view.
    ///   - logger: Logger use during operation
    @inlinable
    public func updateDNSView(
        description: String? = nil,
        dnssecValidation: DnsSecValidationType? = nil,
        dnsViewId: String,
        ednsClientSubnet: EdnsClientSubnetType? = nil,
        firewallRulesFailOpen: FirewallRulesFailOpenType? = nil,
        name: String? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> UpdateDNSViewOutput {
        let input = UpdateDNSViewInput(
            description: description, 
            dnssecValidation: dnssecValidation, 
            dnsViewId: dnsViewId, 
            ednsClientSubnet: ednsClientSubnet, 
            firewallRulesFailOpen: firewallRulesFailOpen, 
            name: name
        )
        return try await self.updateDNSView(input, logger: logger)
    }

    /// Updates a DNS Firewall domain list from an array of specified domains.
    @Sendable
    @inlinable
    public func updateFirewallDomains(_ input: UpdateFirewallDomainsInput, logger: Logger = AWSClient.loggingDisabled) async throws -> UpdateFirewallDomainsOutput {
        try await self.client.execute(
            operation: "UpdateFirewallDomains", 
            path: "/firewall-domain-lists/{firewallDomainListId}/domains", 
            httpMethod: .PATCH, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Updates a DNS Firewall domain list from an array of specified domains.
    ///
    /// Parameters:
    ///   - domains: A list of the domains. You can add up to 1000 domains per request.
    ///   - firewallDomainListId: The ID of the DNS Firewall domain list to which you want to add the domains.
    ///   - operation: The operation for updating the domain list. The allowed values are ADD, REMOVE, and REPLACE.
    ///   - logger: Logger use during operation
    @inlinable
    public func updateFirewallDomains(
        domains: [String],
        firewallDomainListId: String,
        operation: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> UpdateFirewallDomainsOutput {
        let input = UpdateFirewallDomainsInput(
            domains: domains, 
            firewallDomainListId: firewallDomainListId, 
            operation: operation
        )
        return try await self.updateFirewallDomains(input, logger: logger)
    }

    /// Updates the configuration of a DNS firewall rule.
    @Sendable
    @inlinable
    public func updateFirewallRule(_ input: UpdateFirewallRuleInput, logger: Logger = AWSClient.loggingDisabled) async throws -> UpdateFirewallRuleOutput {
        try await self.client.execute(
            operation: "UpdateFirewallRule", 
            path: "/firewall-rules/{firewallRuleId}", 
            httpMethod: .PATCH, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Updates the configuration of a DNS firewall rule.
    ///
    /// Parameters:
    ///   - action: The action that DNS Firewall should take on a DNS query when it matches one of the domains in the rule's domain list, or a threat in a DNS Firewall Advanced rule.
    ///   - blockOverrideDnsType: The DNS record's type. This determines the format of the record value that you provided in BlockOverrideDomain. Used for the rule action BLOCK with a BlockResponse setting of OVERRIDE.
    ///   - blockOverrideDomain: The custom DNS record to send back in response to the query. Used for the rule action BLOCK with a BlockResponse setting of OVERRIDE.
    ///   - blockOverrideTtl: The recommended amount of time, in seconds, for the DNS resolver or web browser to cache the provided override record. Used for the rule action BLOCK with a BlockResponse setting of OVERRIDE.
    ///   - blockResponse: The way that you want DNS Firewall to block the request. Used for the rule action setting BLOCK.
    ///   - clientToken: A unique, case-sensitive identifier to ensure idempotency. This means that making the same request multiple times with the same clientToken has the same result every time.
    ///   - confidenceThreshold: The confidence threshold for DNS Firewall Advanced. You must provide this value when you create a DNS Firewall Advanced rule.
    ///   - description: The description for the Firewall rule.
    ///   - dnsAdvancedProtection: The type of the DNS Firewall Advanced rule. Valid values are DGA and DNS_TUNNELING.
    ///   - firewallRuleId: The ID of the DNS Firewall rule.
    ///   - name: The name of the DNS Firewall rule.
    ///   - priority: The setting that determines the processing order of the rule in the rule group. DNS Firewall processes the rules in a rule group by order of priority, starting from the lowest setting.
    ///   - logger: Logger use during operation
    @inlinable
    public func updateFirewallRule(
        action: FirewallRuleAction? = nil,
        blockOverrideDnsType: BlockOverrideDnsQueryType? = nil,
        blockOverrideDomain: String? = nil,
        blockOverrideTtl: Int? = nil,
        blockResponse: FirewallBlockResponse? = nil,
        clientToken: String = UpdateFirewallRuleInput.idempotencyToken(),
        confidenceThreshold: ConfidenceThreshold? = nil,
        description: String? = nil,
        dnsAdvancedProtection: DnsAdvancedProtection? = nil,
        firewallRuleId: String,
        name: String? = nil,
        priority: Int64? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> UpdateFirewallRuleOutput {
        let input = UpdateFirewallRuleInput(
            action: action, 
            blockOverrideDnsType: blockOverrideDnsType, 
            blockOverrideDomain: blockOverrideDomain, 
            blockOverrideTtl: blockOverrideTtl, 
            blockResponse: blockResponse, 
            clientToken: clientToken, 
            confidenceThreshold: confidenceThreshold, 
            description: description, 
            dnsAdvancedProtection: dnsAdvancedProtection, 
            firewallRuleId: firewallRuleId, 
            name: name, 
            priority: priority
        )
        return try await self.updateFirewallRule(input, logger: logger)
    }

    /// Updates the configuration of a Route 53 Global Resolver instance. You can modify the name, description, and observability region.
    @Sendable
    @inlinable
    public func updateGlobalResolver(_ input: UpdateGlobalResolverInput, logger: Logger = AWSClient.loggingDisabled) async throws -> UpdateGlobalResolverOutput {
        try await self.client.execute(
            operation: "UpdateGlobalResolver", 
            path: "/global-resolver/{globalResolverId}", 
            httpMethod: .PATCH, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Updates the configuration of a Route 53 Global Resolver instance. You can modify the name, description, and observability region.
    ///
    /// Parameters:
    ///   - description: The description of the Global Resolver.
    ///   - globalResolverId: The ID of the Global Resolver.
    ///   - name: The name of the Global Resolver.
    ///   - observabilityRegion: The AWS Regions in which the users' Global Resolver query resolution logs will be propagated.
    ///   - logger: Logger use during operation
    @inlinable
    public func updateGlobalResolver(
        description: String? = nil,
        globalResolverId: String,
        name: String? = nil,
        observabilityRegion: String? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> UpdateGlobalResolverOutput {
        let input = UpdateGlobalResolverInput(
            description: description, 
            globalResolverId: globalResolverId, 
            name: name, 
            observabilityRegion: observabilityRegion
        )
        return try await self.updateGlobalResolver(input, logger: logger)
    }

    /// Updates the configuration of a hosted zone association.
    @Sendable
    @inlinable
    public func updateHostedZoneAssociation(_ input: UpdateHostedZoneAssociationInput, logger: Logger = AWSClient.loggingDisabled) async throws -> UpdateHostedZoneAssociationOutput {
        try await self.client.execute(
            operation: "UpdateHostedZoneAssociation", 
            path: "/hosted-zone-associations/{hostedZoneAssociationId}", 
            httpMethod: .PATCH, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Updates the configuration of a hosted zone association.
    ///
    /// Parameters:
    ///   - hostedZoneAssociationId: The ID of the private hosted zone association.
    ///   - name: The name you want to update the hosted zone association to.
    ///   - logger: Logger use during operation
    @inlinable
    public func updateHostedZoneAssociation(
        hostedZoneAssociationId: String,
        name: String? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> UpdateHostedZoneAssociationOutput {
        let input = UpdateHostedZoneAssociationInput(
            hostedZoneAssociationId: hostedZoneAssociationId, 
            name: name
        )
        return try await self.updateHostedZoneAssociation(input, logger: logger)
    }
}

extension Route53GlobalResolver {
    /// Initializer required by `AWSService.with(middlewares:timeout:byteBufferAllocator:options)`. You are not able to use this initializer directly as there are not public
    /// initializers for `AWSServiceConfig.Patch`. Please use `AWSService.with(middlewares:timeout:byteBufferAllocator:options)` instead.
    public init(from: Route53GlobalResolver, patch: AWSServiceConfig.Patch) {
        self.client = from.client
        self.config = from.config.with(patch: patch)
    }
}

// MARK: Paginators

@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension Route53GlobalResolver {
    /// Return PaginatorSequence for operation ``listAccessSources(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func listAccessSourcesPaginator(
        _ input: ListAccessSourcesInput,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<ListAccessSourcesInput, ListAccessSourcesOutput> {
        return .init(
            input: input,
            command: self.listAccessSources,
            inputKey: \ListAccessSourcesInput.nextToken,
            outputKey: \ListAccessSourcesOutput.nextToken,
            logger: logger
        )
    }
    /// Return PaginatorSequence for operation ``listAccessSources(_:logger:)``.
    ///
    /// - Parameters:
    ///   - filters: Values to filter the results.
    ///   - maxResults: The maximum number of results to retrieve in a single call.
    ///   - logger: Logger used for logging
    @inlinable
    public func listAccessSourcesPaginator(
        filters: [String: [String]]? = nil,
        maxResults: Int? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) -> AWSClient.PaginatorSequence<ListAccessSourcesInput, ListAccessSourcesOutput> {
        let input = ListAccessSourcesInput(
            filters: filters, 
            maxResults: maxResults
        )
        return self.listAccessSourcesPaginator(input, logger: logger)
    }

    /// Return PaginatorSequence for operation ``listAccessTokens(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func listAccessTokensPaginator(
        _ input: ListAccessTokensInput,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<ListAccessTokensInput, ListAccessTokensOutput> {
        return .init(
            input: input,
            command: self.listAccessTokens,
            inputKey: \ListAccessTokensInput.nextToken,
            outputKey: \ListAccessTokensOutput.nextToken,
            logger: logger
        )
    }
    /// Return PaginatorSequence for operation ``listAccessTokens(_:logger:)``.
    ///
    /// - Parameters:
    ///   - dnsViewId: The ID of the DNS view to list the tokens for.
    ///   - filters: Filtering parameters.
    ///   - maxResults: The maximum number of results to retrieve in a single call.
    ///   - logger: Logger used for logging
    @inlinable
    public func listAccessTokensPaginator(
        dnsViewId: String,
        filters: [String: [String]]? = nil,
        maxResults: Int? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) -> AWSClient.PaginatorSequence<ListAccessTokensInput, ListAccessTokensOutput> {
        let input = ListAccessTokensInput(
            dnsViewId: dnsViewId, 
            filters: filters, 
            maxResults: maxResults
        )
        return self.listAccessTokensPaginator(input, logger: logger)
    }

    /// Return PaginatorSequence for operation ``listDNSViews(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func listDNSViewsPaginator(
        _ input: ListDNSViewsInput,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<ListDNSViewsInput, ListDNSViewsOutput> {
        return .init(
            input: input,
            command: self.listDNSViews,
            inputKey: \ListDNSViewsInput.nextToken,
            outputKey: \ListDNSViewsOutput.nextToken,
            logger: logger
        )
    }
    /// Return PaginatorSequence for operation ``listDNSViews(_:logger:)``.
    ///
    /// - Parameters:
    ///   - globalResolverId: The Global Resolver ID.
    ///   - maxResults: The maximum number of results to retrieve in a single call.
    ///   - logger: Logger used for logging
    @inlinable
    public func listDNSViewsPaginator(
        globalResolverId: String,
        maxResults: Int? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) -> AWSClient.PaginatorSequence<ListDNSViewsInput, ListDNSViewsOutput> {
        let input = ListDNSViewsInput(
            globalResolverId: globalResolverId, 
            maxResults: maxResults
        )
        return self.listDNSViewsPaginator(input, logger: logger)
    }

    /// Return PaginatorSequence for operation ``listFirewallDomainLists(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func listFirewallDomainListsPaginator(
        _ input: ListFirewallDomainListsInput,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<ListFirewallDomainListsInput, ListFirewallDomainListsOutput> {
        return .init(
            input: input,
            command: self.listFirewallDomainLists,
            inputKey: \ListFirewallDomainListsInput.nextToken,
            outputKey: \ListFirewallDomainListsOutput.nextToken,
            logger: logger
        )
    }
    /// Return PaginatorSequence for operation ``listFirewallDomainLists(_:logger:)``.
    ///
    /// - Parameters:
    ///   - globalResolverId: The ID of the Global Resolver that contains the DNS view the domain lists are associated to.
    ///   - maxResults: The maximum number of results to retrieve in a single call.
    ///   - logger: Logger used for logging
    @inlinable
    public func listFirewallDomainListsPaginator(
        globalResolverId: String? = nil,
        maxResults: Int? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) -> AWSClient.PaginatorSequence<ListFirewallDomainListsInput, ListFirewallDomainListsOutput> {
        let input = ListFirewallDomainListsInput(
            globalResolverId: globalResolverId, 
            maxResults: maxResults
        )
        return self.listFirewallDomainListsPaginator(input, logger: logger)
    }

    /// Return PaginatorSequence for operation ``listFirewallDomains(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func listFirewallDomainsPaginator(
        _ input: ListFirewallDomainsInput,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<ListFirewallDomainsInput, ListFirewallDomainsOutput> {
        return .init(
            input: input,
            command: self.listFirewallDomains,
            inputKey: \ListFirewallDomainsInput.nextToken,
            outputKey: \ListFirewallDomainsOutput.nextToken,
            logger: logger
        )
    }
    /// Return PaginatorSequence for operation ``listFirewallDomains(_:logger:)``.
    ///
    /// - Parameters:
    ///   - firewallDomainListId: ID of the DNS Firewall domain list.
    ///   - maxResults: The maximum number of results to retrieve in a single call.
    ///   - logger: Logger used for logging
    @inlinable
    public func listFirewallDomainsPaginator(
        firewallDomainListId: String,
        maxResults: Int? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) -> AWSClient.PaginatorSequence<ListFirewallDomainsInput, ListFirewallDomainsOutput> {
        let input = ListFirewallDomainsInput(
            firewallDomainListId: firewallDomainListId, 
            maxResults: maxResults
        )
        return self.listFirewallDomainsPaginator(input, logger: logger)
    }

    /// Return PaginatorSequence for operation ``listFirewallRules(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func listFirewallRulesPaginator(
        _ input: ListFirewallRulesInput,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<ListFirewallRulesInput, ListFirewallRulesOutput> {
        return .init(
            input: input,
            command: self.listFirewallRules,
            inputKey: \ListFirewallRulesInput.nextToken,
            outputKey: \ListFirewallRulesOutput.nextToken,
            logger: logger
        )
    }
    /// Return PaginatorSequence for operation ``listFirewallRules(_:logger:)``.
    ///
    /// - Parameters:
    ///   - dnsViewId: ID of the DNS view.
    ///   - filters: Values to filter the results.
    ///   - maxResults: The maximum number of results to retrieve in a single call.
    ///   - logger: Logger used for logging
    @inlinable
    public func listFirewallRulesPaginator(
        dnsViewId: String,
        filters: [String: [String]]? = nil,
        maxResults: Int? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) -> AWSClient.PaginatorSequence<ListFirewallRulesInput, ListFirewallRulesOutput> {
        let input = ListFirewallRulesInput(
            dnsViewId: dnsViewId, 
            filters: filters, 
            maxResults: maxResults
        )
        return self.listFirewallRulesPaginator(input, logger: logger)
    }

    /// Return PaginatorSequence for operation ``listGlobalResolvers(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func listGlobalResolversPaginator(
        _ input: ListGlobalResolversInput,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<ListGlobalResolversInput, ListGlobalResolversOutput> {
        return .init(
            input: input,
            command: self.listGlobalResolvers,
            inputKey: \ListGlobalResolversInput.nextToken,
            outputKey: \ListGlobalResolversOutput.nextToken,
            logger: logger
        )
    }
    /// Return PaginatorSequence for operation ``listGlobalResolvers(_:logger:)``.
    ///
    /// - Parameters:
    ///   - maxResults: The maximum number of Route 53 Global Resolver instances to return in the response. Valid range is 1-100.
    ///   - logger: Logger used for logging
    @inlinable
    public func listGlobalResolversPaginator(
        maxResults: Int? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) -> AWSClient.PaginatorSequence<ListGlobalResolversInput, ListGlobalResolversOutput> {
        let input = ListGlobalResolversInput(
            maxResults: maxResults
        )
        return self.listGlobalResolversPaginator(input, logger: logger)
    }

    /// Return PaginatorSequence for operation ``listHostedZoneAssociations(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func listHostedZoneAssociationsPaginator(
        _ input: ListHostedZoneAssociationsInput,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<ListHostedZoneAssociationsInput, ListHostedZoneAssociationsOutput> {
        return .init(
            input: input,
            command: self.listHostedZoneAssociations,
            inputKey: \ListHostedZoneAssociationsInput.nextToken,
            outputKey: \ListHostedZoneAssociationsOutput.nextToken,
            logger: logger
        )
    }
    /// Return PaginatorSequence for operation ``listHostedZoneAssociations(_:logger:)``.
    ///
    /// - Parameters:
    ///   - maxResults: The maximum number of results to retrieve in a single call.
    ///   - resourceArn: Amazon Resource Name (ARN) of the DNS view.
    ///   - logger: Logger used for logging
    @inlinable
    public func listHostedZoneAssociationsPaginator(
        maxResults: Int? = nil,
        resourceArn: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) -> AWSClient.PaginatorSequence<ListHostedZoneAssociationsInput, ListHostedZoneAssociationsOutput> {
        let input = ListHostedZoneAssociationsInput(
            maxResults: maxResults, 
            resourceArn: resourceArn
        )
        return self.listHostedZoneAssociationsPaginator(input, logger: logger)
    }

    /// Return PaginatorSequence for operation ``listManagedFirewallDomainLists(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func listManagedFirewallDomainListsPaginator(
        _ input: ListManagedFirewallDomainListsInput,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<ListManagedFirewallDomainListsInput, ListManagedFirewallDomainListsOutput> {
        return .init(
            input: input,
            command: self.listManagedFirewallDomainLists,
            inputKey: \ListManagedFirewallDomainListsInput.nextToken,
            outputKey: \ListManagedFirewallDomainListsOutput.nextToken,
            logger: logger
        )
    }
    /// Return PaginatorSequence for operation ``listManagedFirewallDomainLists(_:logger:)``.
    ///
    /// - Parameters:
    ///   - managedFirewallDomainListType: The category of the Manage DNS list either THREAT or CONTENT.
    ///   - maxResults: The maximum number of results to retrieve in a single call.
    ///   - logger: Logger used for logging
    @inlinable
    public func listManagedFirewallDomainListsPaginator(
        managedFirewallDomainListType: String,
        maxResults: Int? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) -> AWSClient.PaginatorSequence<ListManagedFirewallDomainListsInput, ListManagedFirewallDomainListsOutput> {
        let input = ListManagedFirewallDomainListsInput(
            managedFirewallDomainListType: managedFirewallDomainListType, 
            maxResults: maxResults
        )
        return self.listManagedFirewallDomainListsPaginator(input, logger: logger)
    }
}

extension Route53GlobalResolver.ListAccessSourcesInput: AWSPaginateToken {
    @inlinable
    public func usingPaginationToken(_ token: String) -> Route53GlobalResolver.ListAccessSourcesInput {
        return .init(
            filters: self.filters,
            maxResults: self.maxResults,
            nextToken: token
        )
    }
}

extension Route53GlobalResolver.ListAccessTokensInput: AWSPaginateToken {
    @inlinable
    public func usingPaginationToken(_ token: String) -> Route53GlobalResolver.ListAccessTokensInput {
        return .init(
            dnsViewId: self.dnsViewId,
            filters: self.filters,
            maxResults: self.maxResults,
            nextToken: token
        )
    }
}

extension Route53GlobalResolver.ListDNSViewsInput: AWSPaginateToken {
    @inlinable
    public func usingPaginationToken(_ token: String) -> Route53GlobalResolver.ListDNSViewsInput {
        return .init(
            globalResolverId: self.globalResolverId,
            maxResults: self.maxResults,
            nextToken: token
        )
    }
}

extension Route53GlobalResolver.ListFirewallDomainListsInput: AWSPaginateToken {
    @inlinable
    public func usingPaginationToken(_ token: String) -> Route53GlobalResolver.ListFirewallDomainListsInput {
        return .init(
            globalResolverId: self.globalResolverId,
            maxResults: self.maxResults,
            nextToken: token
        )
    }
}

extension Route53GlobalResolver.ListFirewallDomainsInput: AWSPaginateToken {
    @inlinable
    public func usingPaginationToken(_ token: String) -> Route53GlobalResolver.ListFirewallDomainsInput {
        return .init(
            firewallDomainListId: self.firewallDomainListId,
            maxResults: self.maxResults,
            nextToken: token
        )
    }
}

extension Route53GlobalResolver.ListFirewallRulesInput: AWSPaginateToken {
    @inlinable
    public func usingPaginationToken(_ token: String) -> Route53GlobalResolver.ListFirewallRulesInput {
        return .init(
            dnsViewId: self.dnsViewId,
            filters: self.filters,
            maxResults: self.maxResults,
            nextToken: token
        )
    }
}

extension Route53GlobalResolver.ListGlobalResolversInput: AWSPaginateToken {
    @inlinable
    public func usingPaginationToken(_ token: String) -> Route53GlobalResolver.ListGlobalResolversInput {
        return .init(
            maxResults: self.maxResults,
            nextToken: token
        )
    }
}

extension Route53GlobalResolver.ListHostedZoneAssociationsInput: AWSPaginateToken {
    @inlinable
    public func usingPaginationToken(_ token: String) -> Route53GlobalResolver.ListHostedZoneAssociationsInput {
        return .init(
            maxResults: self.maxResults,
            nextToken: token,
            resourceArn: self.resourceArn
        )
    }
}

extension Route53GlobalResolver.ListManagedFirewallDomainListsInput: AWSPaginateToken {
    @inlinable
    public func usingPaginationToken(_ token: String) -> Route53GlobalResolver.ListManagedFirewallDomainListsInput {
        return .init(
            managedFirewallDomainListType: self.managedFirewallDomainListType,
            maxResults: self.maxResults,
            nextToken: token
        )
    }
}
